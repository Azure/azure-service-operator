// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_STATUSARM, VirtualMachine_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_STATUSARM runs a test to see if a specific instance of VirtualMachine_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_STATUSARM(subject VirtualMachine_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachine_STATUSARMGenerator()
var virtualMachine_STATUSARMGenerator gopter.Gen

// VirtualMachine_STATUSARMGenerator returns a generator of VirtualMachine_STATUSARM instances for property testing.
// We first initialize virtualMachine_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_STATUSARMGenerator() gopter.Gen {
	if virtualMachine_STATUSARMGenerator != nil {
		return virtualMachine_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_STATUSARM(generators)
	virtualMachine_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_STATUSARM(generators)
	virtualMachine_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_STATUSARM{}), generators)

	return virtualMachine_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentity_STATUSARMGenerator())
	gens["Plan"] = gen.PtrOf(Plan_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachineProperties_STATUSARMGenerator())
	gens["Resources"] = gen.SliceOf(VirtualMachineExtension_STATUSARMGenerator())
}

func Test_VirtualMachineExtension_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtension_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtension_STATUSARM, VirtualMachineExtension_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtension_STATUSARM runs a test to see if a specific instance of VirtualMachineExtension_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtension_STATUSARM(subject VirtualMachineExtension_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtension_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtension_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineExtension_STATUSARMGenerator()
var virtualMachineExtension_STATUSARMGenerator gopter.Gen

// VirtualMachineExtension_STATUSARMGenerator returns a generator of VirtualMachineExtension_STATUSARM instances for property testing.
// We first initialize virtualMachineExtension_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtension_STATUSARMGenerator() gopter.Gen {
	if virtualMachineExtension_STATUSARMGenerator != nil {
		return virtualMachineExtension_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtension_STATUSARM(generators)
	virtualMachineExtension_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtension_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtension_STATUSARM(generators)
	virtualMachineExtension_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_STATUSARM{}), generators)

	return virtualMachineExtension_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtension_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtension_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtension_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtension_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachineExtensionProperties_STATUSARMGenerator())
}

func Test_VirtualMachineIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_STATUSARM, VirtualMachineIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_STATUSARM runs a test to see if a specific instance of VirtualMachineIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_STATUSARM(subject VirtualMachineIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineIdentity_STATUSARMGenerator()
var virtualMachineIdentity_STATUSARMGenerator gopter.Gen

// VirtualMachineIdentity_STATUSARMGenerator returns a generator of VirtualMachineIdentity_STATUSARM instances for property testing.
func VirtualMachineIdentity_STATUSARMGenerator() gopter.Gen {
	if virtualMachineIdentity_STATUSARMGenerator != nil {
		return virtualMachineIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_STATUSARM(generators)
	virtualMachineIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_STATUSARM{}), generators)

	return virtualMachineIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentity_STATUS_Type_None,
		VirtualMachineIdentity_STATUS_Type_SystemAssigned,
		VirtualMachineIdentity_STATUS_Type_SystemAssignedUserAssigned,
		VirtualMachineIdentity_STATUS_Type_UserAssigned))
}

func Test_VirtualMachineProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineProperties_STATUSARM, VirtualMachineProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineProperties_STATUSARM runs a test to see if a specific instance of VirtualMachineProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineProperties_STATUSARM(subject VirtualMachineProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineProperties_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineProperties_STATUSARMGenerator()
var virtualMachineProperties_STATUSARMGenerator gopter.Gen

// VirtualMachineProperties_STATUSARMGenerator returns a generator of VirtualMachineProperties_STATUSARM instances for property testing.
// We first initialize virtualMachineProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineProperties_STATUSARMGenerator() gopter.Gen {
	if virtualMachineProperties_STATUSARMGenerator != nil {
		return virtualMachineProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_STATUSARM(generators)
	virtualMachineProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineProperties_STATUSARM(generators)
	virtualMachineProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_STATUSARM{}), generators)

	return virtualMachineProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_STATUS_Deallocate, EvictionPolicy_STATUS_Delete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_STATUS_Low, Priority_STATUS_Regular, Priority_STATUS_Spot))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_STATUSARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_STATUSARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_STATUSARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfile_STATUSARMGenerator())
	gens["Host"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceView_STATUSARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_STATUSARMGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfile_STATUSARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_STATUSARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfile_STATUSARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResource_STATUSARMGenerator())
}

func Test_BillingProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile_STATUSARM, BillingProfile_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile_STATUSARM runs a test to see if a specific instance of BillingProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile_STATUSARM(subject BillingProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_STATUSARM instances for property testing - lazily instantiated by
// BillingProfile_STATUSARMGenerator()
var billingProfile_STATUSARMGenerator gopter.Gen

// BillingProfile_STATUSARMGenerator returns a generator of BillingProfile_STATUSARM instances for property testing.
func BillingProfile_STATUSARMGenerator() gopter.Gen {
	if billingProfile_STATUSARMGenerator != nil {
		return billingProfile_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile_STATUSARM(generators)
	billingProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BillingProfile_STATUSARM{}), generators)

	return billingProfile_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile_STATUSARM, DiagnosticsProfile_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile_STATUSARM runs a test to see if a specific instance of DiagnosticsProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile_STATUSARM(subject DiagnosticsProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_STATUSARM instances for property testing - lazily instantiated by
// DiagnosticsProfile_STATUSARMGenerator()
var diagnosticsProfile_STATUSARMGenerator gopter.Gen

// DiagnosticsProfile_STATUSARMGenerator returns a generator of DiagnosticsProfile_STATUSARM instances for property testing.
func DiagnosticsProfile_STATUSARMGenerator() gopter.Gen {
	if diagnosticsProfile_STATUSARMGenerator != nil {
		return diagnosticsProfile_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile_STATUSARM(generators)
	diagnosticsProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_STATUSARM{}), generators)

	return diagnosticsProfile_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnostics_STATUSARMGenerator())
}

func Test_HardwareProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile_STATUSARM, HardwareProfile_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile_STATUSARM runs a test to see if a specific instance of HardwareProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile_STATUSARM(subject HardwareProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_STATUSARM instances for property testing - lazily instantiated by
// HardwareProfile_STATUSARMGenerator()
var hardwareProfile_STATUSARMGenerator gopter.Gen

// HardwareProfile_STATUSARMGenerator returns a generator of HardwareProfile_STATUSARM instances for property testing.
func HardwareProfile_STATUSARMGenerator() gopter.Gen {
	if hardwareProfile_STATUSARMGenerator != nil {
		return hardwareProfile_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile_STATUSARM(generators)
	hardwareProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_STATUSARM{}), generators)

	return hardwareProfile_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfile_STATUS_VmSize_Basic_A0,
		HardwareProfile_STATUS_VmSize_Basic_A1,
		HardwareProfile_STATUS_VmSize_Basic_A2,
		HardwareProfile_STATUS_VmSize_Basic_A3,
		HardwareProfile_STATUS_VmSize_Basic_A4,
		HardwareProfile_STATUS_VmSize_Standard_A0,
		HardwareProfile_STATUS_VmSize_Standard_A1,
		HardwareProfile_STATUS_VmSize_Standard_A10,
		HardwareProfile_STATUS_VmSize_Standard_A11,
		HardwareProfile_STATUS_VmSize_Standard_A1_V2,
		HardwareProfile_STATUS_VmSize_Standard_A2,
		HardwareProfile_STATUS_VmSize_Standard_A2M_V2,
		HardwareProfile_STATUS_VmSize_Standard_A2_V2,
		HardwareProfile_STATUS_VmSize_Standard_A3,
		HardwareProfile_STATUS_VmSize_Standard_A4,
		HardwareProfile_STATUS_VmSize_Standard_A4M_V2,
		HardwareProfile_STATUS_VmSize_Standard_A4_V2,
		HardwareProfile_STATUS_VmSize_Standard_A5,
		HardwareProfile_STATUS_VmSize_Standard_A6,
		HardwareProfile_STATUS_VmSize_Standard_A7,
		HardwareProfile_STATUS_VmSize_Standard_A8,
		HardwareProfile_STATUS_VmSize_Standard_A8M_V2,
		HardwareProfile_STATUS_VmSize_Standard_A8_V2,
		HardwareProfile_STATUS_VmSize_Standard_A9,
		HardwareProfile_STATUS_VmSize_Standard_B1Ms,
		HardwareProfile_STATUS_VmSize_Standard_B1S,
		HardwareProfile_STATUS_VmSize_Standard_B2Ms,
		HardwareProfile_STATUS_VmSize_Standard_B2S,
		HardwareProfile_STATUS_VmSize_Standard_B4Ms,
		HardwareProfile_STATUS_VmSize_Standard_B8Ms,
		HardwareProfile_STATUS_VmSize_Standard_D1,
		HardwareProfile_STATUS_VmSize_Standard_D11,
		HardwareProfile_STATUS_VmSize_Standard_D11_V2,
		HardwareProfile_STATUS_VmSize_Standard_D12,
		HardwareProfile_STATUS_VmSize_Standard_D12_V2,
		HardwareProfile_STATUS_VmSize_Standard_D13,
		HardwareProfile_STATUS_VmSize_Standard_D13_V2,
		HardwareProfile_STATUS_VmSize_Standard_D14,
		HardwareProfile_STATUS_VmSize_Standard_D14_V2,
		HardwareProfile_STATUS_VmSize_Standard_D15_V2,
		HardwareProfile_STATUS_VmSize_Standard_D16S_V3,
		HardwareProfile_STATUS_VmSize_Standard_D16_V3,
		HardwareProfile_STATUS_VmSize_Standard_D1_V2,
		HardwareProfile_STATUS_VmSize_Standard_D2,
		HardwareProfile_STATUS_VmSize_Standard_D2S_V3,
		HardwareProfile_STATUS_VmSize_Standard_D2_V2,
		HardwareProfile_STATUS_VmSize_Standard_D2_V3,
		HardwareProfile_STATUS_VmSize_Standard_D3,
		HardwareProfile_STATUS_VmSize_Standard_D32S_V3,
		HardwareProfile_STATUS_VmSize_Standard_D32_V3,
		HardwareProfile_STATUS_VmSize_Standard_D3_V2,
		HardwareProfile_STATUS_VmSize_Standard_D4,
		HardwareProfile_STATUS_VmSize_Standard_D4S_V3,
		HardwareProfile_STATUS_VmSize_Standard_D4_V2,
		HardwareProfile_STATUS_VmSize_Standard_D4_V3,
		HardwareProfile_STATUS_VmSize_Standard_D5_V2,
		HardwareProfile_STATUS_VmSize_Standard_D64S_V3,
		HardwareProfile_STATUS_VmSize_Standard_D64_V3,
		HardwareProfile_STATUS_VmSize_Standard_D8S_V3,
		HardwareProfile_STATUS_VmSize_Standard_D8_V3,
		HardwareProfile_STATUS_VmSize_Standard_DS1,
		HardwareProfile_STATUS_VmSize_Standard_DS11,
		HardwareProfile_STATUS_VmSize_Standard_DS11_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS12,
		HardwareProfile_STATUS_VmSize_Standard_DS12_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS13,
		HardwareProfile_STATUS_VmSize_Standard_DS132_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS134_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS13_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS14,
		HardwareProfile_STATUS_VmSize_Standard_DS144_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS148_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS14_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS15_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS1_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS2,
		HardwareProfile_STATUS_VmSize_Standard_DS2_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS3,
		HardwareProfile_STATUS_VmSize_Standard_DS3_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS4,
		HardwareProfile_STATUS_VmSize_Standard_DS4_V2,
		HardwareProfile_STATUS_VmSize_Standard_DS5_V2,
		HardwareProfile_STATUS_VmSize_Standard_E16S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E16_V3,
		HardwareProfile_STATUS_VmSize_Standard_E2S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E2_V3,
		HardwareProfile_STATUS_VmSize_Standard_E3216_V3,
		HardwareProfile_STATUS_VmSize_Standard_E328S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E32S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E32_V3,
		HardwareProfile_STATUS_VmSize_Standard_E4S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E4_V3,
		HardwareProfile_STATUS_VmSize_Standard_E6416S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E6432S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E64S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E64_V3,
		HardwareProfile_STATUS_VmSize_Standard_E8S_V3,
		HardwareProfile_STATUS_VmSize_Standard_E8_V3,
		HardwareProfile_STATUS_VmSize_Standard_F1,
		HardwareProfile_STATUS_VmSize_Standard_F16,
		HardwareProfile_STATUS_VmSize_Standard_F16S,
		HardwareProfile_STATUS_VmSize_Standard_F16S_V2,
		HardwareProfile_STATUS_VmSize_Standard_F1S,
		HardwareProfile_STATUS_VmSize_Standard_F2,
		HardwareProfile_STATUS_VmSize_Standard_F2S,
		HardwareProfile_STATUS_VmSize_Standard_F2S_V2,
		HardwareProfile_STATUS_VmSize_Standard_F32S_V2,
		HardwareProfile_STATUS_VmSize_Standard_F4,
		HardwareProfile_STATUS_VmSize_Standard_F4S,
		HardwareProfile_STATUS_VmSize_Standard_F4S_V2,
		HardwareProfile_STATUS_VmSize_Standard_F64S_V2,
		HardwareProfile_STATUS_VmSize_Standard_F72S_V2,
		HardwareProfile_STATUS_VmSize_Standard_F8,
		HardwareProfile_STATUS_VmSize_Standard_F8S,
		HardwareProfile_STATUS_VmSize_Standard_F8S_V2,
		HardwareProfile_STATUS_VmSize_Standard_G1,
		HardwareProfile_STATUS_VmSize_Standard_G2,
		HardwareProfile_STATUS_VmSize_Standard_G3,
		HardwareProfile_STATUS_VmSize_Standard_G4,
		HardwareProfile_STATUS_VmSize_Standard_G5,
		HardwareProfile_STATUS_VmSize_Standard_GS1,
		HardwareProfile_STATUS_VmSize_Standard_GS2,
		HardwareProfile_STATUS_VmSize_Standard_GS3,
		HardwareProfile_STATUS_VmSize_Standard_GS4,
		HardwareProfile_STATUS_VmSize_Standard_GS44,
		HardwareProfile_STATUS_VmSize_Standard_GS48,
		HardwareProfile_STATUS_VmSize_Standard_GS5,
		HardwareProfile_STATUS_VmSize_Standard_GS516,
		HardwareProfile_STATUS_VmSize_Standard_GS58,
		HardwareProfile_STATUS_VmSize_Standard_H16,
		HardwareProfile_STATUS_VmSize_Standard_H16M,
		HardwareProfile_STATUS_VmSize_Standard_H16Mr,
		HardwareProfile_STATUS_VmSize_Standard_H16R,
		HardwareProfile_STATUS_VmSize_Standard_H8,
		HardwareProfile_STATUS_VmSize_Standard_H8M,
		HardwareProfile_STATUS_VmSize_Standard_L16S,
		HardwareProfile_STATUS_VmSize_Standard_L32S,
		HardwareProfile_STATUS_VmSize_Standard_L4S,
		HardwareProfile_STATUS_VmSize_Standard_L8S,
		HardwareProfile_STATUS_VmSize_Standard_M12832Ms,
		HardwareProfile_STATUS_VmSize_Standard_M12864Ms,
		HardwareProfile_STATUS_VmSize_Standard_M128Ms,
		HardwareProfile_STATUS_VmSize_Standard_M128S,
		HardwareProfile_STATUS_VmSize_Standard_M6416Ms,
		HardwareProfile_STATUS_VmSize_Standard_M6432Ms,
		HardwareProfile_STATUS_VmSize_Standard_M64Ms,
		HardwareProfile_STATUS_VmSize_Standard_M64S,
		HardwareProfile_STATUS_VmSize_Standard_NC12,
		HardwareProfile_STATUS_VmSize_Standard_NC12S_V2,
		HardwareProfile_STATUS_VmSize_Standard_NC12S_V3,
		HardwareProfile_STATUS_VmSize_Standard_NC24,
		HardwareProfile_STATUS_VmSize_Standard_NC24R,
		HardwareProfile_STATUS_VmSize_Standard_NC24Rs_V2,
		HardwareProfile_STATUS_VmSize_Standard_NC24Rs_V3,
		HardwareProfile_STATUS_VmSize_Standard_NC24S_V2,
		HardwareProfile_STATUS_VmSize_Standard_NC24S_V3,
		HardwareProfile_STATUS_VmSize_Standard_NC6,
		HardwareProfile_STATUS_VmSize_Standard_NC6S_V2,
		HardwareProfile_STATUS_VmSize_Standard_NC6S_V3,
		HardwareProfile_STATUS_VmSize_Standard_ND12S,
		HardwareProfile_STATUS_VmSize_Standard_ND24Rs,
		HardwareProfile_STATUS_VmSize_Standard_ND24S,
		HardwareProfile_STATUS_VmSize_Standard_ND6S,
		HardwareProfile_STATUS_VmSize_Standard_NV12,
		HardwareProfile_STATUS_VmSize_Standard_NV24,
		HardwareProfile_STATUS_VmSize_Standard_NV6))
}

func Test_NetworkProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_STATUSARM, NetworkProfile_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_STATUSARM runs a test to see if a specific instance of NetworkProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_STATUSARM(subject NetworkProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_STATUSARM instances for property testing - lazily instantiated by
// NetworkProfile_STATUSARMGenerator()
var networkProfile_STATUSARMGenerator gopter.Gen

// NetworkProfile_STATUSARMGenerator returns a generator of NetworkProfile_STATUSARM instances for property testing.
func NetworkProfile_STATUSARMGenerator() gopter.Gen {
	if networkProfile_STATUSARMGenerator != nil {
		return networkProfile_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfile_STATUSARM(generators)
	networkProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_STATUSARM{}), generators)

	return networkProfile_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfile_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReference_STATUSARMGenerator())
}

func Test_OSProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfile_STATUSARM, OSProfile_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfile_STATUSARM runs a test to see if a specific instance of OSProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfile_STATUSARM(subject OSProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_STATUSARM instances for property testing - lazily instantiated by
// OSProfile_STATUSARMGenerator()
var osProfile_STATUSARMGenerator gopter.Gen

// OSProfile_STATUSARMGenerator returns a generator of OSProfile_STATUSARM instances for property testing.
// We first initialize osProfile_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfile_STATUSARMGenerator() gopter.Gen {
	if osProfile_STATUSARMGenerator != nil {
		return osProfile_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_STATUSARM(generators)
	osProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForOSProfile_STATUSARM(generators)
	osProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_STATUSARM{}), generators)

	return osProfile_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForOSProfile_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfile_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_STATUSARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_STATUSARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_STATUSARMGenerator())
}

func Test_SecurityProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile_STATUSARM, SecurityProfile_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile_STATUSARM runs a test to see if a specific instance of SecurityProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile_STATUSARM(subject SecurityProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_STATUSARM instances for property testing - lazily instantiated by
// SecurityProfile_STATUSARMGenerator()
var securityProfile_STATUSARMGenerator gopter.Gen

// SecurityProfile_STATUSARMGenerator returns a generator of SecurityProfile_STATUSARM instances for property testing.
// We first initialize securityProfile_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfile_STATUSARMGenerator() gopter.Gen {
	if securityProfile_STATUSARMGenerator != nil {
		return securityProfile_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_STATUSARM(generators)
	securityProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile_STATUSARM(generators)
	securityProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_STATUSARM{}), generators)

	return securityProfile_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfile_STATUS_SecurityType_TrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfile_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettings_STATUSARMGenerator())
}

func Test_StorageProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile_STATUSARM, StorageProfile_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile_STATUSARM runs a test to see if a specific instance of StorageProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile_STATUSARM(subject StorageProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_STATUSARM instances for property testing - lazily instantiated by
// StorageProfile_STATUSARMGenerator()
var storageProfile_STATUSARMGenerator gopter.Gen

// StorageProfile_STATUSARMGenerator returns a generator of StorageProfile_STATUSARM instances for property testing.
func StorageProfile_STATUSARMGenerator() gopter.Gen {
	if storageProfile_STATUSARMGenerator != nil {
		return storageProfile_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile_STATUSARM(generators)
	storageProfile_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageProfile_STATUSARM{}), generators)

	return storageProfile_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile_STATUSARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDisk_STATUSARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_STATUSARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDisk_STATUSARMGenerator())
}

func Test_VirtualMachineExtensionProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionProperties_STATUSARM, VirtualMachineExtensionProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionProperties_STATUSARM runs a test to see if a specific instance of VirtualMachineExtensionProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionProperties_STATUSARM(subject VirtualMachineExtensionProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionProperties_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineExtensionProperties_STATUSARMGenerator()
var virtualMachineExtensionProperties_STATUSARMGenerator gopter.Gen

// VirtualMachineExtensionProperties_STATUSARMGenerator returns a generator of VirtualMachineExtensionProperties_STATUSARM instances for property testing.
// We first initialize virtualMachineExtensionProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionProperties_STATUSARMGenerator() gopter.Gen {
	if virtualMachineExtensionProperties_STATUSARMGenerator != nil {
		return virtualMachineExtensionProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionProperties_STATUSARM(generators)
	virtualMachineExtensionProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionProperties_STATUSARM(generators)
	virtualMachineExtensionProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionProperties_STATUSARM{}), generators)

	return virtualMachineExtensionProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["ForceUpdateTag"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["InstanceView"] = gen.PtrOf(VirtualMachineExtensionInstanceView_STATUSARMGenerator())
}

func Test_VirtualMachineInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceView_STATUSARM, VirtualMachineInstanceView_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceView_STATUSARM runs a test to see if a specific instance of VirtualMachineInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceView_STATUSARM(subject VirtualMachineInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceView_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineInstanceView_STATUSARMGenerator()
var virtualMachineInstanceView_STATUSARMGenerator gopter.Gen

// VirtualMachineInstanceView_STATUSARMGenerator returns a generator of VirtualMachineInstanceView_STATUSARM instances for property testing.
// We first initialize virtualMachineInstanceView_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceView_STATUSARMGenerator() gopter.Gen {
	if virtualMachineInstanceView_STATUSARMGenerator != nil {
		return virtualMachineInstanceView_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_STATUSARM(generators)
	virtualMachineInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_STATUSARM(generators)
	virtualMachineInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_STATUSARM{}), generators)

	return virtualMachineInstanceView_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(VirtualMachineInstanceView_STATUS_HyperVGeneration_V1, VirtualMachineInstanceView_STATUS_HyperVGeneration_V2))
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceView_STATUSARMGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceView_STATUSARMGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceView_STATUSARMGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatus_STATUSARMGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatus_STATUSARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_STATUSARMGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceView_STATUSARMGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatus_STATUSARMGenerator())
}

func Test_BootDiagnostics_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics_STATUSARM, BootDiagnostics_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics_STATUSARM runs a test to see if a specific instance of BootDiagnostics_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics_STATUSARM(subject BootDiagnostics_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_STATUSARM instances for property testing - lazily instantiated by
// BootDiagnostics_STATUSARMGenerator()
var bootDiagnostics_STATUSARMGenerator gopter.Gen

// BootDiagnostics_STATUSARMGenerator returns a generator of BootDiagnostics_STATUSARM instances for property testing.
func BootDiagnostics_STATUSARMGenerator() gopter.Gen {
	if bootDiagnostics_STATUSARMGenerator != nil {
		return bootDiagnostics_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics_STATUSARM(generators)
	bootDiagnostics_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_STATUSARM{}), generators)

	return bootDiagnostics_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics_STATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_BootDiagnosticsInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceView_STATUSARM, BootDiagnosticsInstanceView_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceView_STATUSARM runs a test to see if a specific instance of BootDiagnosticsInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceView_STATUSARM(subject BootDiagnosticsInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceView_STATUSARM instances for property testing - lazily instantiated by
// BootDiagnosticsInstanceView_STATUSARMGenerator()
var bootDiagnosticsInstanceView_STATUSARMGenerator gopter.Gen

// BootDiagnosticsInstanceView_STATUSARMGenerator returns a generator of BootDiagnosticsInstanceView_STATUSARM instances for property testing.
// We first initialize bootDiagnosticsInstanceView_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceView_STATUSARMGenerator() gopter.Gen {
	if bootDiagnosticsInstanceView_STATUSARMGenerator != nil {
		return bootDiagnosticsInstanceView_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_STATUSARM(generators)
	bootDiagnosticsInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_STATUSARM(generators)
	bootDiagnosticsInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_STATUSARM{}), generators)

	return bootDiagnosticsInstanceView_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_STATUSARMGenerator())
}

func Test_DataDisk_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk_STATUSARM, DataDisk_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk_STATUSARM runs a test to see if a specific instance of DataDisk_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk_STATUSARM(subject DataDisk_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_STATUSARM instances for property testing - lazily instantiated by DataDisk_STATUSARMGenerator()
var dataDisk_STATUSARMGenerator gopter.Gen

// DataDisk_STATUSARMGenerator returns a generator of DataDisk_STATUSARM instances for property testing.
// We first initialize dataDisk_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDisk_STATUSARMGenerator() gopter.Gen {
	if dataDisk_STATUSARMGenerator != nil {
		return dataDisk_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_STATUSARM(generators)
	dataDisk_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForDataDisk_STATUSARM(generators)
	dataDisk_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_STATUSARM{}), generators)

	return dataDisk_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk_STATUSARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_STATUS_None, Caching_STATUS_ReadOnly, Caching_STATUS_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_STATUS_Attach, CreateOption_STATUS_Empty, CreateOption_STATUS_FromImage))
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_STATUS_ForceDetach))
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk_STATUSARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDisk_STATUSARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_STATUSARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_STATUSARMGenerator())
}

func Test_DiskInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceView_STATUSARM, DiskInstanceView_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceView_STATUSARM runs a test to see if a specific instance of DiskInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceView_STATUSARM(subject DiskInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceView_STATUSARM instances for property testing - lazily instantiated by
// DiskInstanceView_STATUSARMGenerator()
var diskInstanceView_STATUSARMGenerator gopter.Gen

// DiskInstanceView_STATUSARMGenerator returns a generator of DiskInstanceView_STATUSARM instances for property testing.
// We first initialize diskInstanceView_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceView_STATUSARMGenerator() gopter.Gen {
	if diskInstanceView_STATUSARMGenerator != nil {
		return diskInstanceView_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceView_STATUSARM(generators)
	diskInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceView_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceView_STATUSARM(generators)
	diskInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_STATUSARM{}), generators)

	return diskInstanceView_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceView_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceView_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettings_STATUSARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_STATUSARMGenerator())
}

func Test_ImageReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference_STATUSARM, ImageReference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference_STATUSARM runs a test to see if a specific instance of ImageReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference_STATUSARM(subject ImageReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_STATUSARM instances for property testing - lazily instantiated by
// ImageReference_STATUSARMGenerator()
var imageReference_STATUSARMGenerator gopter.Gen

// ImageReference_STATUSARMGenerator returns a generator of ImageReference_STATUSARM instances for property testing.
func ImageReference_STATUSARMGenerator() gopter.Gen {
	if imageReference_STATUSARMGenerator != nil {
		return imageReference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference_STATUSARM(generators)
	imageReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ImageReference_STATUSARM{}), generators)

	return imageReference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatus_STATUSARM, InstanceViewStatus_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatus_STATUSARM runs a test to see if a specific instance of InstanceViewStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatus_STATUSARM(subject InstanceViewStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_STATUSARM instances for property testing - lazily instantiated by
// InstanceViewStatus_STATUSARMGenerator()
var instanceViewStatus_STATUSARMGenerator gopter.Gen

// InstanceViewStatus_STATUSARMGenerator returns a generator of InstanceViewStatus_STATUSARM instances for property testing.
func InstanceViewStatus_STATUSARMGenerator() gopter.Gen {
	if instanceViewStatus_STATUSARMGenerator != nil {
		return instanceViewStatus_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUSARM(generators)
	instanceViewStatus_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_STATUSARM{}), generators)

	return instanceViewStatus_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUSARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.OneConstOf(InstanceViewStatus_STATUS_Level_Error, InstanceViewStatus_STATUS_Level_Info, InstanceViewStatus_STATUS_Level_Warning))
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration_STATUSARM, LinuxConfiguration_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration_STATUSARM runs a test to see if a specific instance of LinuxConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration_STATUSARM(subject LinuxConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_STATUSARM instances for property testing - lazily instantiated by
// LinuxConfiguration_STATUSARMGenerator()
var linuxConfiguration_STATUSARMGenerator gopter.Gen

// LinuxConfiguration_STATUSARMGenerator returns a generator of LinuxConfiguration_STATUSARM instances for property testing.
// We first initialize linuxConfiguration_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfiguration_STATUSARMGenerator() gopter.Gen {
	if linuxConfiguration_STATUSARMGenerator != nil {
		return linuxConfiguration_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_STATUSARM(generators)
	linuxConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration_STATUSARM(generators)
	linuxConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_STATUSARM{}), generators)

	return linuxConfiguration_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettings_STATUSARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfiguration_STATUSARMGenerator())
}

func Test_MaintenanceRedeployStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatus_STATUSARM, MaintenanceRedeployStatus_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatus_STATUSARM runs a test to see if a specific instance of MaintenanceRedeployStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatus_STATUSARM(subject MaintenanceRedeployStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatus_STATUSARM instances for property testing - lazily instantiated by
// MaintenanceRedeployStatus_STATUSARMGenerator()
var maintenanceRedeployStatus_STATUSARMGenerator gopter.Gen

// MaintenanceRedeployStatus_STATUSARMGenerator returns a generator of MaintenanceRedeployStatus_STATUSARM instances for property testing.
func MaintenanceRedeployStatus_STATUSARMGenerator() gopter.Gen {
	if maintenanceRedeployStatus_STATUSARMGenerator != nil {
		return maintenanceRedeployStatus_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_STATUSARM(generators)
	maintenanceRedeployStatus_STATUSARMGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatus_STATUSARM{}), generators)

	return maintenanceRedeployStatus_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_STATUSARM(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.OneConstOf(
		MaintenanceRedeployStatus_STATUS_LastOperationResultCode_MaintenanceAborted,
		MaintenanceRedeployStatus_STATUS_LastOperationResultCode_MaintenanceCompleted,
		MaintenanceRedeployStatus_STATUS_LastOperationResultCode_None,
		MaintenanceRedeployStatus_STATUS_LastOperationResultCode_RetryLater))
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReference_STATUSARM, NetworkInterfaceReference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReference_STATUSARM runs a test to see if a specific instance of NetworkInterfaceReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReference_STATUSARM(subject NetworkInterfaceReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_STATUSARM instances for property testing - lazily instantiated by
// NetworkInterfaceReference_STATUSARMGenerator()
var networkInterfaceReference_STATUSARMGenerator gopter.Gen

// NetworkInterfaceReference_STATUSARMGenerator returns a generator of NetworkInterfaceReference_STATUSARM instances for property testing.
// We first initialize networkInterfaceReference_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceReference_STATUSARMGenerator() gopter.Gen {
	if networkInterfaceReference_STATUSARMGenerator != nil {
		return networkInterfaceReference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_STATUSARM(generators)
	networkInterfaceReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceReference_STATUSARM(generators)
	networkInterfaceReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_STATUSARM{}), generators)

	return networkInterfaceReference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceReference_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferenceProperties_STATUSARMGenerator())
}

func Test_OSDisk_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk_STATUSARM, OSDisk_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk_STATUSARM runs a test to see if a specific instance of OSDisk_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk_STATUSARM(subject OSDisk_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_STATUSARM instances for property testing - lazily instantiated by OSDisk_STATUSARMGenerator()
var osDisk_STATUSARMGenerator gopter.Gen

// OSDisk_STATUSARMGenerator returns a generator of OSDisk_STATUSARM instances for property testing.
// We first initialize osDisk_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDisk_STATUSARMGenerator() gopter.Gen {
	if osDisk_STATUSARMGenerator != nil {
		return osDisk_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_STATUSARM(generators)
	osDisk_STATUSARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForOSDisk_STATUSARM(generators)
	osDisk_STATUSARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_STATUSARM{}), generators)

	return osDisk_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk_STATUSARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_STATUS_None, Caching_STATUS_ReadOnly, Caching_STATUS_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_STATUS_Attach, CreateOption_STATUS_Empty, CreateOption_STATUS_FromImage))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDisk_STATUS_OsType_Linux, OSDisk_STATUS_OsType_Windows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk_STATUSARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_STATUSARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettings_STATUSARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_STATUSARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_STATUSARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_STATUSARMGenerator())
}

func Test_UefiSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings_STATUSARM, UefiSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings_STATUSARM runs a test to see if a specific instance of UefiSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings_STATUSARM(subject UefiSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_STATUSARM instances for property testing - lazily instantiated by
// UefiSettings_STATUSARMGenerator()
var uefiSettings_STATUSARMGenerator gopter.Gen

// UefiSettings_STATUSARMGenerator returns a generator of UefiSettings_STATUSARM instances for property testing.
func UefiSettings_STATUSARMGenerator() gopter.Gen {
	if uefiSettings_STATUSARMGenerator != nil {
		return uefiSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings_STATUSARM(generators)
	uefiSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(UefiSettings_STATUSARM{}), generators)

	return uefiSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup_STATUSARM, VaultSecretGroup_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup_STATUSARM runs a test to see if a specific instance of VaultSecretGroup_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup_STATUSARM(subject VaultSecretGroup_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_STATUSARM instances for property testing - lazily instantiated by
// VaultSecretGroup_STATUSARMGenerator()
var vaultSecretGroup_STATUSARMGenerator gopter.Gen

// VaultSecretGroup_STATUSARMGenerator returns a generator of VaultSecretGroup_STATUSARM instances for property testing.
func VaultSecretGroup_STATUSARMGenerator() gopter.Gen {
	if vaultSecretGroup_STATUSARMGenerator != nil {
		return vaultSecretGroup_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup_STATUSARM(generators)
	vaultSecretGroup_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_STATUSARM{}), generators)

	return vaultSecretGroup_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup_STATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_STATUSARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificate_STATUSARMGenerator())
}

func Test_VirtualMachineAgentInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceView_STATUSARM, VirtualMachineAgentInstanceView_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceView_STATUSARM runs a test to see if a specific instance of VirtualMachineAgentInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceView_STATUSARM(subject VirtualMachineAgentInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceView_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineAgentInstanceView_STATUSARMGenerator()
var virtualMachineAgentInstanceView_STATUSARMGenerator gopter.Gen

// VirtualMachineAgentInstanceView_STATUSARMGenerator returns a generator of VirtualMachineAgentInstanceView_STATUSARM instances for property testing.
// We first initialize virtualMachineAgentInstanceView_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceView_STATUSARMGenerator() gopter.Gen {
	if virtualMachineAgentInstanceView_STATUSARMGenerator != nil {
		return virtualMachineAgentInstanceView_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_STATUSARM(generators)
	virtualMachineAgentInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_STATUSARM(generators)
	virtualMachineAgentInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_STATUSARM{}), generators)

	return virtualMachineAgentInstanceView_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceView_STATUSARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_STATUSARMGenerator())
}

func Test_VirtualMachineExtensionInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceView_STATUSARM, VirtualMachineExtensionInstanceView_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceView_STATUSARM runs a test to see if a specific instance of VirtualMachineExtensionInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceView_STATUSARM(subject VirtualMachineExtensionInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceView_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineExtensionInstanceView_STATUSARMGenerator()
var virtualMachineExtensionInstanceView_STATUSARMGenerator gopter.Gen

// VirtualMachineExtensionInstanceView_STATUSARMGenerator returns a generator of VirtualMachineExtensionInstanceView_STATUSARM instances for property testing.
// We first initialize virtualMachineExtensionInstanceView_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceView_STATUSARMGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceView_STATUSARMGenerator != nil {
		return virtualMachineExtensionInstanceView_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_STATUSARM(generators)
	virtualMachineExtensionInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_STATUSARM(generators)
	virtualMachineExtensionInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_STATUSARM{}), generators)

	return virtualMachineExtensionInstanceView_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_STATUSARMGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatus_STATUSARMGenerator())
}

func Test_VirtualMachineHealthStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatus_STATUSARM, VirtualMachineHealthStatus_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatus_STATUSARM runs a test to see if a specific instance of VirtualMachineHealthStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatus_STATUSARM(subject VirtualMachineHealthStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatus_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineHealthStatus_STATUSARMGenerator()
var virtualMachineHealthStatus_STATUSARMGenerator gopter.Gen

// VirtualMachineHealthStatus_STATUSARMGenerator returns a generator of VirtualMachineHealthStatus_STATUSARM instances for property testing.
func VirtualMachineHealthStatus_STATUSARMGenerator() gopter.Gen {
	if virtualMachineHealthStatus_STATUSARMGenerator != nil {
		return virtualMachineHealthStatus_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_STATUSARM(generators)
	virtualMachineHealthStatus_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatus_STATUSARM{}), generators)

	return virtualMachineHealthStatus_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_STATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_STATUSARMGenerator())
}

func Test_VirtualMachinePatchStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatus_STATUSARM, VirtualMachinePatchStatus_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatus_STATUSARM runs a test to see if a specific instance of VirtualMachinePatchStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatus_STATUSARM(subject VirtualMachinePatchStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatus_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachinePatchStatus_STATUSARMGenerator()
var virtualMachinePatchStatus_STATUSARMGenerator gopter.Gen

// VirtualMachinePatchStatus_STATUSARMGenerator returns a generator of VirtualMachinePatchStatus_STATUSARM instances for property testing.
func VirtualMachinePatchStatus_STATUSARMGenerator() gopter.Gen {
	if virtualMachinePatchStatus_STATUSARMGenerator != nil {
		return virtualMachinePatchStatus_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_STATUSARM(generators)
	virtualMachinePatchStatus_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatus_STATUSARM{}), generators)

	return virtualMachinePatchStatus_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_STATUSARM(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummary_STATUSARMGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatus_STATUSARMGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummary_STATUSARMGenerator())
}

func Test_WindowsConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration_STATUSARM, WindowsConfiguration_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration_STATUSARM runs a test to see if a specific instance of WindowsConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration_STATUSARM(subject WindowsConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_STATUSARM instances for property testing - lazily instantiated by
// WindowsConfiguration_STATUSARMGenerator()
var windowsConfiguration_STATUSARMGenerator gopter.Gen

// WindowsConfiguration_STATUSARMGenerator returns a generator of WindowsConfiguration_STATUSARM instances for property testing.
// We first initialize windowsConfiguration_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfiguration_STATUSARMGenerator() gopter.Gen {
	if windowsConfiguration_STATUSARMGenerator != nil {
		return windowsConfiguration_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_STATUSARM(generators)
	windowsConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration_STATUSARM(generators)
	windowsConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_STATUSARM{}), generators)

	return windowsConfiguration_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContent_STATUSARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettings_STATUSARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfiguration_STATUSARMGenerator())
}

func Test_AdditionalUnattendContent_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent_STATUSARM, AdditionalUnattendContent_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent_STATUSARM runs a test to see if a specific instance of AdditionalUnattendContent_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent_STATUSARM(subject AdditionalUnattendContent_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_STATUSARM instances for property testing - lazily instantiated by
// AdditionalUnattendContent_STATUSARMGenerator()
var additionalUnattendContent_STATUSARMGenerator gopter.Gen

// AdditionalUnattendContent_STATUSARMGenerator returns a generator of AdditionalUnattendContent_STATUSARM instances for property testing.
func AdditionalUnattendContent_STATUSARMGenerator() gopter.Gen {
	if additionalUnattendContent_STATUSARMGenerator != nil {
		return additionalUnattendContent_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent_STATUSARM(generators)
	additionalUnattendContent_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_STATUSARM{}), generators)

	return additionalUnattendContent_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent_STATUSARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_STATUS_ComponentName_MicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_STATUS_PassName_OobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_STATUS_SettingName_AutoLogon, AdditionalUnattendContent_STATUS_SettingName_FirstLogonCommands))
}

func Test_AvailablePatchSummary_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummary_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummary_STATUSARM, AvailablePatchSummary_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummary_STATUSARM runs a test to see if a specific instance of AvailablePatchSummary_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummary_STATUSARM(subject AvailablePatchSummary_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummary_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummary_STATUSARM instances for property testing - lazily instantiated by
// AvailablePatchSummary_STATUSARMGenerator()
var availablePatchSummary_STATUSARMGenerator gopter.Gen

// AvailablePatchSummary_STATUSARMGenerator returns a generator of AvailablePatchSummary_STATUSARM instances for property testing.
// We first initialize availablePatchSummary_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummary_STATUSARMGenerator() gopter.Gen {
	if availablePatchSummary_STATUSARMGenerator != nil {
		return availablePatchSummary_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummary_STATUSARM(generators)
	availablePatchSummary_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummary_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummary_STATUSARM(generators)
	availablePatchSummary_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_STATUSARM{}), generators)

	return availablePatchSummary_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummary_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummary_STATUSARM(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		AvailablePatchSummary_STATUS_Status_CompletedWithWarnings,
		AvailablePatchSummary_STATUS_Status_Failed,
		AvailablePatchSummary_STATUS_Status_InProgress,
		AvailablePatchSummary_STATUS_Status_Succeeded,
		AvailablePatchSummary_STATUS_Status_Unknown))
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummary_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummary_STATUSARM(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiError_STATUSARMGenerator())
}

func Test_DiffDiskSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings_STATUSARM, DiffDiskSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings_STATUSARM runs a test to see if a specific instance of DiffDiskSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings_STATUSARM(subject DiffDiskSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_STATUSARM instances for property testing - lazily instantiated by
// DiffDiskSettings_STATUSARMGenerator()
var diffDiskSettings_STATUSARMGenerator gopter.Gen

// DiffDiskSettings_STATUSARMGenerator returns a generator of DiffDiskSettings_STATUSARM instances for property testing.
func DiffDiskSettings_STATUSARMGenerator() gopter.Gen {
	if diffDiskSettings_STATUSARMGenerator != nil {
		return diffDiskSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings_STATUSARM(generators)
	diffDiskSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_STATUSARM{}), generators)

	return diffDiskSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_STATUS_Local))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_STATUS_CacheDisk, DiffDiskPlacement_STATUS_ResourceDisk))
}

func Test_DiskEncryptionSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings_STATUSARM, DiskEncryptionSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings_STATUSARM runs a test to see if a specific instance of DiskEncryptionSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings_STATUSARM(subject DiskEncryptionSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_STATUSARM instances for property testing - lazily instantiated by
// DiskEncryptionSettings_STATUSARMGenerator()
var diskEncryptionSettings_STATUSARMGenerator gopter.Gen

// DiskEncryptionSettings_STATUSARMGenerator returns a generator of DiskEncryptionSettings_STATUSARM instances for property testing.
// We first initialize diskEncryptionSettings_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettings_STATUSARMGenerator() gopter.Gen {
	if diskEncryptionSettings_STATUSARMGenerator != nil {
		return diskEncryptionSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_STATUSARM(generators)
	diskEncryptionSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings_STATUSARM(generators)
	diskEncryptionSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_STATUSARM{}), generators)

	return diskEncryptionSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReference_STATUSARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReference_STATUSARMGenerator())
}

func Test_LastPatchInstallationSummary_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummary_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummary_STATUSARM, LastPatchInstallationSummary_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummary_STATUSARM runs a test to see if a specific instance of LastPatchInstallationSummary_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummary_STATUSARM(subject LastPatchInstallationSummary_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummary_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummary_STATUSARM instances for property testing - lazily instantiated by
// LastPatchInstallationSummary_STATUSARMGenerator()
var lastPatchInstallationSummary_STATUSARMGenerator gopter.Gen

// LastPatchInstallationSummary_STATUSARMGenerator returns a generator of LastPatchInstallationSummary_STATUSARM instances for property testing.
// We first initialize lastPatchInstallationSummary_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummary_STATUSARMGenerator() gopter.Gen {
	if lastPatchInstallationSummary_STATUSARMGenerator != nil {
		return lastPatchInstallationSummary_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_STATUSARM(generators)
	lastPatchInstallationSummary_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_STATUSARM(generators)
	lastPatchInstallationSummary_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_STATUSARM{}), generators)

	return lastPatchInstallationSummary_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		LastPatchInstallationSummary_STATUS_Status_CompletedWithWarnings,
		LastPatchInstallationSummary_STATUS_Status_Failed,
		LastPatchInstallationSummary_STATUS_Status_InProgress,
		LastPatchInstallationSummary_STATUS_Status_Succeeded,
		LastPatchInstallationSummary_STATUS_Status_Unknown))
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_STATUSARM(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiError_STATUSARMGenerator())
}

func Test_LinuxPatchSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings_STATUSARM, LinuxPatchSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings_STATUSARM runs a test to see if a specific instance of LinuxPatchSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings_STATUSARM(subject LinuxPatchSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_STATUSARM instances for property testing - lazily instantiated by
// LinuxPatchSettings_STATUSARMGenerator()
var linuxPatchSettings_STATUSARMGenerator gopter.Gen

// LinuxPatchSettings_STATUSARMGenerator returns a generator of LinuxPatchSettings_STATUSARM instances for property testing.
func LinuxPatchSettings_STATUSARMGenerator() gopter.Gen {
	if linuxPatchSettings_STATUSARMGenerator != nil {
		return linuxPatchSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings_STATUSARM(generators)
	linuxPatchSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_STATUSARM{}), generators)

	return linuxPatchSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_STATUS_PatchMode_AutomaticByPlatform, LinuxPatchSettings_STATUS_PatchMode_ImageDefault))
}

func Test_ManagedDiskParameters_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters_STATUSARM, ManagedDiskParameters_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters_STATUSARM runs a test to see if a specific instance of ManagedDiskParameters_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters_STATUSARM(subject ManagedDiskParameters_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_STATUSARM instances for property testing - lazily instantiated by
// ManagedDiskParameters_STATUSARMGenerator()
var managedDiskParameters_STATUSARMGenerator gopter.Gen

// ManagedDiskParameters_STATUSARMGenerator returns a generator of ManagedDiskParameters_STATUSARM instances for property testing.
// We first initialize managedDiskParameters_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParameters_STATUSARMGenerator() gopter.Gen {
	if managedDiskParameters_STATUSARMGenerator != nil {
		return managedDiskParameters_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_STATUSARM(generators)
	managedDiskParameters_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters_STATUSARM(generators)
	managedDiskParameters_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_STATUSARM{}), generators)

	return managedDiskParameters_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_STATUS_Premium_LRS,
		StorageAccountType_STATUS_Premium_ZRS,
		StorageAccountType_STATUS_StandardSSD_LRS,
		StorageAccountType_STATUS_StandardSSD_ZRS,
		StorageAccountType_STATUS_Standard_LRS,
		StorageAccountType_STATUS_UltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters_STATUSARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_STATUSARMGenerator())
}

func Test_NetworkInterfaceReferenceProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferenceProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceProperties_STATUSARM, NetworkInterfaceReferenceProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceProperties_STATUSARM runs a test to see if a specific instance of NetworkInterfaceReferenceProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceProperties_STATUSARM(subject NetworkInterfaceReferenceProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferenceProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferenceProperties_STATUSARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferenceProperties_STATUSARMGenerator()
var networkInterfaceReferenceProperties_STATUSARMGenerator gopter.Gen

// NetworkInterfaceReferenceProperties_STATUSARMGenerator returns a generator of NetworkInterfaceReferenceProperties_STATUSARM instances for property testing.
func NetworkInterfaceReferenceProperties_STATUSARMGenerator() gopter.Gen {
	if networkInterfaceReferenceProperties_STATUSARMGenerator != nil {
		return networkInterfaceReferenceProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_STATUSARM(generators)
	networkInterfaceReferenceProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceProperties_STATUSARM{}), generators)

	return networkInterfaceReferenceProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings_STATUSARM, PatchSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings_STATUSARM runs a test to see if a specific instance of PatchSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings_STATUSARM(subject PatchSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_STATUSARM instances for property testing - lazily instantiated by
// PatchSettings_STATUSARMGenerator()
var patchSettings_STATUSARMGenerator gopter.Gen

// PatchSettings_STATUSARMGenerator returns a generator of PatchSettings_STATUSARM instances for property testing.
func PatchSettings_STATUSARMGenerator() gopter.Gen {
	if patchSettings_STATUSARMGenerator != nil {
		return patchSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings_STATUSARM(generators)
	patchSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PatchSettings_STATUSARM{}), generators)

	return patchSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_STATUS_PatchMode_AutomaticByOS, PatchSettings_STATUS_PatchMode_AutomaticByPlatform, PatchSettings_STATUS_PatchMode_Manual))
}

func Test_SshConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration_STATUSARM, SshConfiguration_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration_STATUSARM runs a test to see if a specific instance of SshConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration_STATUSARM(subject SshConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_STATUSARM instances for property testing - lazily instantiated by
// SshConfiguration_STATUSARMGenerator()
var sshConfiguration_STATUSARMGenerator gopter.Gen

// SshConfiguration_STATUSARMGenerator returns a generator of SshConfiguration_STATUSARM instances for property testing.
func SshConfiguration_STATUSARMGenerator() gopter.Gen {
	if sshConfiguration_STATUSARMGenerator != nil {
		return sshConfiguration_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration_STATUSARM(generators)
	sshConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_STATUSARM{}), generators)

	return sshConfiguration_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKey_STATUSARMGenerator())
}

func Test_VaultCertificate_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate_STATUSARM, VaultCertificate_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate_STATUSARM runs a test to see if a specific instance of VaultCertificate_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate_STATUSARM(subject VaultCertificate_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_STATUSARM instances for property testing - lazily instantiated by
// VaultCertificate_STATUSARMGenerator()
var vaultCertificate_STATUSARMGenerator gopter.Gen

// VaultCertificate_STATUSARMGenerator returns a generator of VaultCertificate_STATUSARM instances for property testing.
func VaultCertificate_STATUSARMGenerator() gopter.Gen {
	if vaultCertificate_STATUSARMGenerator != nil {
		return vaultCertificate_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate_STATUSARM(generators)
	vaultCertificate_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_STATUSARM{}), generators)

	return vaultCertificate_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate_STATUSARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk_STATUSARM, VirtualHardDisk_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk_STATUSARM runs a test to see if a specific instance of VirtualHardDisk_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk_STATUSARM(subject VirtualHardDisk_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_STATUSARM instances for property testing - lazily instantiated by
// VirtualHardDisk_STATUSARMGenerator()
var virtualHardDisk_STATUSARMGenerator gopter.Gen

// VirtualHardDisk_STATUSARMGenerator returns a generator of VirtualHardDisk_STATUSARM instances for property testing.
func VirtualHardDisk_STATUSARMGenerator() gopter.Gen {
	if virtualHardDisk_STATUSARMGenerator != nil {
		return virtualHardDisk_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk_STATUSARM(generators)
	virtualHardDisk_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_STATUSARM{}), generators)

	return virtualHardDisk_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk_STATUSARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_STATUSARM, VirtualMachineExtensionHandlerInstanceView_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_STATUSARM runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_STATUSARM(subject VirtualMachineExtensionHandlerInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceView_STATUSARM instances for property testing - lazily
// instantiated by VirtualMachineExtensionHandlerInstanceView_STATUSARMGenerator()
var virtualMachineExtensionHandlerInstanceView_STATUSARMGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceView_STATUSARMGenerator returns a generator of VirtualMachineExtensionHandlerInstanceView_STATUSARM instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceView_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceView_STATUSARMGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceView_STATUSARMGenerator != nil {
		return virtualMachineExtensionHandlerInstanceView_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_STATUSARM(generators)
	virtualMachineExtensionHandlerInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_STATUSARM(generators)
	virtualMachineExtensionHandlerInstanceView_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_STATUSARM{}), generators)

	return virtualMachineExtensionHandlerInstanceView_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_STATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_STATUSARMGenerator())
}

func Test_WinRMConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration_STATUSARM, WinRMConfiguration_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration_STATUSARM runs a test to see if a specific instance of WinRMConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration_STATUSARM(subject WinRMConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_STATUSARM instances for property testing - lazily instantiated by
// WinRMConfiguration_STATUSARMGenerator()
var winRMConfiguration_STATUSARMGenerator gopter.Gen

// WinRMConfiguration_STATUSARMGenerator returns a generator of WinRMConfiguration_STATUSARM instances for property testing.
func WinRMConfiguration_STATUSARMGenerator() gopter.Gen {
	if winRMConfiguration_STATUSARMGenerator != nil {
		return winRMConfiguration_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration_STATUSARM(generators)
	winRMConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_STATUSARM{}), generators)

	return winRMConfiguration_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListener_STATUSARMGenerator())
}

func Test_ApiError_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiError_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiError_STATUSARM, ApiError_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiError_STATUSARM runs a test to see if a specific instance of ApiError_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiError_STATUSARM(subject ApiError_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiError_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiError_STATUSARM instances for property testing - lazily instantiated by ApiError_STATUSARMGenerator()
var apiError_STATUSARMGenerator gopter.Gen

// ApiError_STATUSARMGenerator returns a generator of ApiError_STATUSARM instances for property testing.
// We first initialize apiError_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiError_STATUSARMGenerator() gopter.Gen {
	if apiError_STATUSARMGenerator != nil {
		return apiError_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiError_STATUSARM(generators)
	apiError_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiError_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiError_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForApiError_STATUSARM(generators)
	apiError_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiError_STATUSARM{}), generators)

	return apiError_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiError_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiError_STATUSARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiError_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiError_STATUSARM(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBase_STATUSARMGenerator())
	gens["Innererror"] = gen.PtrOf(InnerError_STATUSARMGenerator())
}

func Test_KeyVaultKeyReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference_STATUSARM, KeyVaultKeyReference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference_STATUSARM runs a test to see if a specific instance of KeyVaultKeyReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference_STATUSARM(subject KeyVaultKeyReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultKeyReference_STATUSARMGenerator()
var keyVaultKeyReference_STATUSARMGenerator gopter.Gen

// KeyVaultKeyReference_STATUSARMGenerator returns a generator of KeyVaultKeyReference_STATUSARM instances for property testing.
// We first initialize keyVaultKeyReference_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReference_STATUSARMGenerator() gopter.Gen {
	if keyVaultKeyReference_STATUSARMGenerator != nil {
		return keyVaultKeyReference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_STATUSARM(generators)
	keyVaultKeyReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference_STATUSARM(generators)
	keyVaultKeyReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_STATUSARM{}), generators)

	return keyVaultKeyReference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_STATUSARMGenerator())
}

func Test_KeyVaultSecretReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference_STATUSARM, KeyVaultSecretReference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference_STATUSARM runs a test to see if a specific instance of KeyVaultSecretReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference_STATUSARM(subject KeyVaultSecretReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultSecretReference_STATUSARMGenerator()
var keyVaultSecretReference_STATUSARMGenerator gopter.Gen

// KeyVaultSecretReference_STATUSARMGenerator returns a generator of KeyVaultSecretReference_STATUSARM instances for property testing.
// We first initialize keyVaultSecretReference_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReference_STATUSARMGenerator() gopter.Gen {
	if keyVaultSecretReference_STATUSARMGenerator != nil {
		return keyVaultSecretReference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_STATUSARM(generators)
	keyVaultSecretReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference_STATUSARM(generators)
	keyVaultSecretReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_STATUSARM{}), generators)

	return keyVaultSecretReference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_STATUSARMGenerator())
}

func Test_SshPublicKey_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKey_STATUSARM, SshPublicKey_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKey_STATUSARM runs a test to see if a specific instance of SshPublicKey_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKey_STATUSARM(subject SshPublicKey_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_STATUSARM instances for property testing - lazily instantiated by
// SshPublicKey_STATUSARMGenerator()
var sshPublicKey_STATUSARMGenerator gopter.Gen

// SshPublicKey_STATUSARMGenerator returns a generator of SshPublicKey_STATUSARM instances for property testing.
func SshPublicKey_STATUSARMGenerator() gopter.Gen {
	if sshPublicKey_STATUSARMGenerator != nil {
		return sshPublicKey_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKey_STATUSARM(generators)
	sshPublicKey_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_STATUSARM{}), generators)

	return sshPublicKey_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKey_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKey_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener_STATUSARM, WinRMListener_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener_STATUSARM runs a test to see if a specific instance of WinRMListener_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener_STATUSARM(subject WinRMListener_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_STATUSARM instances for property testing - lazily instantiated by
// WinRMListener_STATUSARMGenerator()
var winRMListener_STATUSARMGenerator gopter.Gen

// WinRMListener_STATUSARMGenerator returns a generator of WinRMListener_STATUSARM instances for property testing.
func WinRMListener_STATUSARMGenerator() gopter.Gen {
	if winRMListener_STATUSARMGenerator != nil {
		return winRMListener_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener_STATUSARM(generators)
	winRMListener_STATUSARMGenerator = gen.Struct(reflect.TypeOf(WinRMListener_STATUSARM{}), generators)

	return winRMListener_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener_STATUSARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListener_STATUS_Protocol_Http, WinRMListener_STATUS_Protocol_Https))
}

func Test_ApiErrorBase_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBase_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBase_STATUSARM, ApiErrorBase_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBase_STATUSARM runs a test to see if a specific instance of ApiErrorBase_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBase_STATUSARM(subject ApiErrorBase_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBase_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBase_STATUSARM instances for property testing - lazily instantiated by
// ApiErrorBase_STATUSARMGenerator()
var apiErrorBase_STATUSARMGenerator gopter.Gen

// ApiErrorBase_STATUSARMGenerator returns a generator of ApiErrorBase_STATUSARM instances for property testing.
func ApiErrorBase_STATUSARMGenerator() gopter.Gen {
	if apiErrorBase_STATUSARMGenerator != nil {
		return apiErrorBase_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBase_STATUSARM(generators)
	apiErrorBase_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiErrorBase_STATUSARM{}), generators)

	return apiErrorBase_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBase_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBase_STATUSARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerError_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerError_STATUSARM, InnerError_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerError_STATUSARM runs a test to see if a specific instance of InnerError_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerError_STATUSARM(subject InnerError_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_STATUSARM instances for property testing - lazily instantiated by
// InnerError_STATUSARMGenerator()
var innerError_STATUSARMGenerator gopter.Gen

// InnerError_STATUSARMGenerator returns a generator of InnerError_STATUSARM instances for property testing.
func InnerError_STATUSARMGenerator() gopter.Gen {
	if innerError_STATUSARMGenerator != nil {
		return innerError_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_STATUSARM(generators)
	innerError_STATUSARMGenerator = gen.Struct(reflect.TypeOf(InnerError_STATUSARM{}), generators)

	return innerError_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInnerError_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerError_STATUSARM(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}
