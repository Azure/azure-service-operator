// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachines_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSPECARM, VirtualMachinesSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSPECARM runs a test to see if a specific instance of VirtualMachines_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSPECARM(subject VirtualMachines_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_SPECARM instances for property testing - lazily instantiated by
//VirtualMachinesSPECARMGenerator()
var virtualMachinesSPECARMGenerator gopter.Gen

// VirtualMachinesSPECARMGenerator returns a generator of VirtualMachines_SPECARM instances for property testing.
// We first initialize virtualMachinesSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSPECARMGenerator() gopter.Gen {
	if virtualMachinesSPECARMGenerator != nil {
		return virtualMachinesSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSPECARM(generators)
	virtualMachinesSPECARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSPECARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSPECARM(generators)
	virtualMachinesSPECARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPECARM{}), generators)

	return virtualMachinesSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentitySpecARMGenerator())
	gens["Plan"] = gen.PtrOf(PlanSpecARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachinePropertiesSpecARMGenerator())
}

func Test_VirtualMachineIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentitySpecARM, VirtualMachineIdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentitySpecARM runs a test to see if a specific instance of VirtualMachineIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentitySpecARM(subject VirtualMachineIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_SpecARM instances for property testing - lazily instantiated by
//VirtualMachineIdentitySpecARMGenerator()
var virtualMachineIdentitySpecARMGenerator gopter.Gen

// VirtualMachineIdentitySpecARMGenerator returns a generator of VirtualMachineIdentity_SpecARM instances for property testing.
func VirtualMachineIdentitySpecARMGenerator() gopter.Gen {
	if virtualMachineIdentitySpecARMGenerator != nil {
		return virtualMachineIdentitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpecARM(generators)
	virtualMachineIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_SpecARM{}), generators)

	return virtualMachineIdentitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentitySpecTypeNone,
		VirtualMachineIdentitySpecTypeSystemAssigned,
		VirtualMachineIdentitySpecTypeSystemAssignedUserAssigned,
		VirtualMachineIdentitySpecTypeUserAssigned))
}

func Test_VirtualMachineProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePropertiesSpecARM, VirtualMachinePropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePropertiesSpecARM runs a test to see if a specific instance of VirtualMachineProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePropertiesSpecARM(subject VirtualMachineProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineProperties_SpecARM instances for property testing - lazily instantiated by
//VirtualMachinePropertiesSpecARMGenerator()
var virtualMachinePropertiesSpecARMGenerator gopter.Gen

// VirtualMachinePropertiesSpecARMGenerator returns a generator of VirtualMachineProperties_SpecARM instances for property testing.
// We first initialize virtualMachinePropertiesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePropertiesSpecARMGenerator() gopter.Gen {
	if virtualMachinePropertiesSpecARMGenerator != nil {
		return virtualMachinePropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesSpecARM(generators)
	virtualMachinePropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesSpecARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePropertiesSpecARM(generators)
	virtualMachinePropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_SpecARM{}), generators)

	return virtualMachinePropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_SpecDeallocate, EvictionPolicy_SpecDelete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_SpecLow, Priority_SpecRegular, Priority_SpecSpot))
}

// AddRelatedPropertyGeneratorsForVirtualMachinePropertiesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesSpecARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileSpecARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileSpecARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileSpecARMGenerator())
	gens["Host"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileSpecARMGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileSpecARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileSpecARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileSpecARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceSpecARMGenerator())
}

func Test_BillingProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileSpecARM, BillingProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileSpecARM runs a test to see if a specific instance of BillingProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileSpecARM(subject BillingProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_SpecARM instances for property testing - lazily instantiated by
//BillingProfileSpecARMGenerator()
var billingProfileSpecARMGenerator gopter.Gen

// BillingProfileSpecARMGenerator returns a generator of BillingProfile_SpecARM instances for property testing.
func BillingProfileSpecARMGenerator() gopter.Gen {
	if billingProfileSpecARMGenerator != nil {
		return billingProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileSpecARM(generators)
	billingProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(BillingProfile_SpecARM{}), generators)

	return billingProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileSpecARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileSpecARM, DiagnosticsProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileSpecARM runs a test to see if a specific instance of DiagnosticsProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileSpecARM(subject DiagnosticsProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_SpecARM instances for property testing - lazily instantiated by
//DiagnosticsProfileSpecARMGenerator()
var diagnosticsProfileSpecARMGenerator gopter.Gen

// DiagnosticsProfileSpecARMGenerator returns a generator of DiagnosticsProfile_SpecARM instances for property testing.
func DiagnosticsProfileSpecARMGenerator() gopter.Gen {
	if diagnosticsProfileSpecARMGenerator != nil {
		return diagnosticsProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileSpecARM(generators)
	diagnosticsProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_SpecARM{}), generators)

	return diagnosticsProfileSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileSpecARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsSpecARMGenerator())
}

func Test_HardwareProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileSpecARM, HardwareProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileSpecARM runs a test to see if a specific instance of HardwareProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileSpecARM(subject HardwareProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_SpecARM instances for property testing - lazily instantiated by
//HardwareProfileSpecARMGenerator()
var hardwareProfileSpecARMGenerator gopter.Gen

// HardwareProfileSpecARMGenerator returns a generator of HardwareProfile_SpecARM instances for property testing.
func HardwareProfileSpecARMGenerator() gopter.Gen {
	if hardwareProfileSpecARMGenerator != nil {
		return hardwareProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileSpecARM(generators)
	hardwareProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_SpecARM{}), generators)

	return hardwareProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileSpecARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfileSpecVmSizeBasicA0,
		HardwareProfileSpecVmSizeBasicA1,
		HardwareProfileSpecVmSizeBasicA2,
		HardwareProfileSpecVmSizeBasicA3,
		HardwareProfileSpecVmSizeBasicA4,
		HardwareProfileSpecVmSizeStandardA0,
		HardwareProfileSpecVmSizeStandardA1,
		HardwareProfileSpecVmSizeStandardA10,
		HardwareProfileSpecVmSizeStandardA11,
		HardwareProfileSpecVmSizeStandardA1V2,
		HardwareProfileSpecVmSizeStandardA2,
		HardwareProfileSpecVmSizeStandardA2MV2,
		HardwareProfileSpecVmSizeStandardA2V2,
		HardwareProfileSpecVmSizeStandardA3,
		HardwareProfileSpecVmSizeStandardA4,
		HardwareProfileSpecVmSizeStandardA4MV2,
		HardwareProfileSpecVmSizeStandardA4V2,
		HardwareProfileSpecVmSizeStandardA5,
		HardwareProfileSpecVmSizeStandardA6,
		HardwareProfileSpecVmSizeStandardA7,
		HardwareProfileSpecVmSizeStandardA8,
		HardwareProfileSpecVmSizeStandardA8MV2,
		HardwareProfileSpecVmSizeStandardA8V2,
		HardwareProfileSpecVmSizeStandardA9,
		HardwareProfileSpecVmSizeStandardB1Ms,
		HardwareProfileSpecVmSizeStandardB1S,
		HardwareProfileSpecVmSizeStandardB2Ms,
		HardwareProfileSpecVmSizeStandardB2S,
		HardwareProfileSpecVmSizeStandardB4Ms,
		HardwareProfileSpecVmSizeStandardB8Ms,
		HardwareProfileSpecVmSizeStandardD1,
		HardwareProfileSpecVmSizeStandardD11,
		HardwareProfileSpecVmSizeStandardD11V2,
		HardwareProfileSpecVmSizeStandardD12,
		HardwareProfileSpecVmSizeStandardD12V2,
		HardwareProfileSpecVmSizeStandardD13,
		HardwareProfileSpecVmSizeStandardD13V2,
		HardwareProfileSpecVmSizeStandardD14,
		HardwareProfileSpecVmSizeStandardD14V2,
		HardwareProfileSpecVmSizeStandardD15V2,
		HardwareProfileSpecVmSizeStandardD16SV3,
		HardwareProfileSpecVmSizeStandardD16V3,
		HardwareProfileSpecVmSizeStandardD1V2,
		HardwareProfileSpecVmSizeStandardD2,
		HardwareProfileSpecVmSizeStandardD2SV3,
		HardwareProfileSpecVmSizeStandardD2V2,
		HardwareProfileSpecVmSizeStandardD2V3,
		HardwareProfileSpecVmSizeStandardD3,
		HardwareProfileSpecVmSizeStandardD32SV3,
		HardwareProfileSpecVmSizeStandardD32V3,
		HardwareProfileSpecVmSizeStandardD3V2,
		HardwareProfileSpecVmSizeStandardD4,
		HardwareProfileSpecVmSizeStandardD4SV3,
		HardwareProfileSpecVmSizeStandardD4V2,
		HardwareProfileSpecVmSizeStandardD4V3,
		HardwareProfileSpecVmSizeStandardD5V2,
		HardwareProfileSpecVmSizeStandardD64SV3,
		HardwareProfileSpecVmSizeStandardD64V3,
		HardwareProfileSpecVmSizeStandardD8SV3,
		HardwareProfileSpecVmSizeStandardD8V3,
		HardwareProfileSpecVmSizeStandardDS1,
		HardwareProfileSpecVmSizeStandardDS11,
		HardwareProfileSpecVmSizeStandardDS11V2,
		HardwareProfileSpecVmSizeStandardDS12,
		HardwareProfileSpecVmSizeStandardDS12V2,
		HardwareProfileSpecVmSizeStandardDS13,
		HardwareProfileSpecVmSizeStandardDS132V2,
		HardwareProfileSpecVmSizeStandardDS134V2,
		HardwareProfileSpecVmSizeStandardDS13V2,
		HardwareProfileSpecVmSizeStandardDS14,
		HardwareProfileSpecVmSizeStandardDS144V2,
		HardwareProfileSpecVmSizeStandardDS148V2,
		HardwareProfileSpecVmSizeStandardDS14V2,
		HardwareProfileSpecVmSizeStandardDS15V2,
		HardwareProfileSpecVmSizeStandardDS1V2,
		HardwareProfileSpecVmSizeStandardDS2,
		HardwareProfileSpecVmSizeStandardDS2V2,
		HardwareProfileSpecVmSizeStandardDS3,
		HardwareProfileSpecVmSizeStandardDS3V2,
		HardwareProfileSpecVmSizeStandardDS4,
		HardwareProfileSpecVmSizeStandardDS4V2,
		HardwareProfileSpecVmSizeStandardDS5V2,
		HardwareProfileSpecVmSizeStandardE16SV3,
		HardwareProfileSpecVmSizeStandardE16V3,
		HardwareProfileSpecVmSizeStandardE2SV3,
		HardwareProfileSpecVmSizeStandardE2V3,
		HardwareProfileSpecVmSizeStandardE3216V3,
		HardwareProfileSpecVmSizeStandardE328SV3,
		HardwareProfileSpecVmSizeStandardE32SV3,
		HardwareProfileSpecVmSizeStandardE32V3,
		HardwareProfileSpecVmSizeStandardE4SV3,
		HardwareProfileSpecVmSizeStandardE4V3,
		HardwareProfileSpecVmSizeStandardE6416SV3,
		HardwareProfileSpecVmSizeStandardE6432SV3,
		HardwareProfileSpecVmSizeStandardE64SV3,
		HardwareProfileSpecVmSizeStandardE64V3,
		HardwareProfileSpecVmSizeStandardE8SV3,
		HardwareProfileSpecVmSizeStandardE8V3,
		HardwareProfileSpecVmSizeStandardF1,
		HardwareProfileSpecVmSizeStandardF16,
		HardwareProfileSpecVmSizeStandardF16S,
		HardwareProfileSpecVmSizeStandardF16SV2,
		HardwareProfileSpecVmSizeStandardF1S,
		HardwareProfileSpecVmSizeStandardF2,
		HardwareProfileSpecVmSizeStandardF2S,
		HardwareProfileSpecVmSizeStandardF2SV2,
		HardwareProfileSpecVmSizeStandardF32SV2,
		HardwareProfileSpecVmSizeStandardF4,
		HardwareProfileSpecVmSizeStandardF4S,
		HardwareProfileSpecVmSizeStandardF4SV2,
		HardwareProfileSpecVmSizeStandardF64SV2,
		HardwareProfileSpecVmSizeStandardF72SV2,
		HardwareProfileSpecVmSizeStandardF8,
		HardwareProfileSpecVmSizeStandardF8S,
		HardwareProfileSpecVmSizeStandardF8SV2,
		HardwareProfileSpecVmSizeStandardG1,
		HardwareProfileSpecVmSizeStandardG2,
		HardwareProfileSpecVmSizeStandardG3,
		HardwareProfileSpecVmSizeStandardG4,
		HardwareProfileSpecVmSizeStandardG5,
		HardwareProfileSpecVmSizeStandardGS1,
		HardwareProfileSpecVmSizeStandardGS2,
		HardwareProfileSpecVmSizeStandardGS3,
		HardwareProfileSpecVmSizeStandardGS4,
		HardwareProfileSpecVmSizeStandardGS44,
		HardwareProfileSpecVmSizeStandardGS48,
		HardwareProfileSpecVmSizeStandardGS5,
		HardwareProfileSpecVmSizeStandardGS516,
		HardwareProfileSpecVmSizeStandardGS58,
		HardwareProfileSpecVmSizeStandardH16,
		HardwareProfileSpecVmSizeStandardH16M,
		HardwareProfileSpecVmSizeStandardH16Mr,
		HardwareProfileSpecVmSizeStandardH16R,
		HardwareProfileSpecVmSizeStandardH8,
		HardwareProfileSpecVmSizeStandardH8M,
		HardwareProfileSpecVmSizeStandardL16S,
		HardwareProfileSpecVmSizeStandardL32S,
		HardwareProfileSpecVmSizeStandardL4S,
		HardwareProfileSpecVmSizeStandardL8S,
		HardwareProfileSpecVmSizeStandardM12832Ms,
		HardwareProfileSpecVmSizeStandardM12864Ms,
		HardwareProfileSpecVmSizeStandardM128Ms,
		HardwareProfileSpecVmSizeStandardM128S,
		HardwareProfileSpecVmSizeStandardM6416Ms,
		HardwareProfileSpecVmSizeStandardM6432Ms,
		HardwareProfileSpecVmSizeStandardM64Ms,
		HardwareProfileSpecVmSizeStandardM64S,
		HardwareProfileSpecVmSizeStandardNC12,
		HardwareProfileSpecVmSizeStandardNC12SV2,
		HardwareProfileSpecVmSizeStandardNC12SV3,
		HardwareProfileSpecVmSizeStandardNC24,
		HardwareProfileSpecVmSizeStandardNC24R,
		HardwareProfileSpecVmSizeStandardNC24RsV2,
		HardwareProfileSpecVmSizeStandardNC24RsV3,
		HardwareProfileSpecVmSizeStandardNC24SV2,
		HardwareProfileSpecVmSizeStandardNC24SV3,
		HardwareProfileSpecVmSizeStandardNC6,
		HardwareProfileSpecVmSizeStandardNC6SV2,
		HardwareProfileSpecVmSizeStandardNC6SV3,
		HardwareProfileSpecVmSizeStandardND12S,
		HardwareProfileSpecVmSizeStandardND24Rs,
		HardwareProfileSpecVmSizeStandardND24S,
		HardwareProfileSpecVmSizeStandardND6S,
		HardwareProfileSpecVmSizeStandardNV12,
		HardwareProfileSpecVmSizeStandardNV24,
		HardwareProfileSpecVmSizeStandardNV6))
}

func Test_NetworkProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileSpecARM, NetworkProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileSpecARM runs a test to see if a specific instance of NetworkProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileSpecARM(subject NetworkProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_SpecARM instances for property testing - lazily instantiated by
//NetworkProfileSpecARMGenerator()
var networkProfileSpecARMGenerator gopter.Gen

// NetworkProfileSpecARMGenerator returns a generator of NetworkProfile_SpecARM instances for property testing.
func NetworkProfileSpecARMGenerator() gopter.Gen {
	if networkProfileSpecARMGenerator != nil {
		return networkProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfileSpecARM(generators)
	networkProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_SpecARM{}), generators)

	return networkProfileSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileSpecARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceSpecARMGenerator())
}

func Test_OSProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileSpecARM, OSProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileSpecARM runs a test to see if a specific instance of OSProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileSpecARM(subject OSProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_SpecARM instances for property testing - lazily instantiated by OSProfileSpecARMGenerator()
var osProfileSpecARMGenerator gopter.Gen

// OSProfileSpecARMGenerator returns a generator of OSProfile_SpecARM instances for property testing.
// We first initialize osProfileSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileSpecARMGenerator() gopter.Gen {
	if osProfileSpecARMGenerator != nil {
		return osProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileSpecARM(generators)
	osProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileSpecARM(generators)
	AddRelatedPropertyGeneratorsForOSProfileSpecARM(generators)
	osProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_SpecARM{}), generators)

	return osProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileSpecARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileSpecARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationSpecARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupSpecARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationSpecARMGenerator())
}

func Test_SecurityProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileSpecARM, SecurityProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileSpecARM runs a test to see if a specific instance of SecurityProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileSpecARM(subject SecurityProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_SpecARM instances for property testing - lazily instantiated by
//SecurityProfileSpecARMGenerator()
var securityProfileSpecARMGenerator gopter.Gen

// SecurityProfileSpecARMGenerator returns a generator of SecurityProfile_SpecARM instances for property testing.
// We first initialize securityProfileSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileSpecARMGenerator() gopter.Gen {
	if securityProfileSpecARMGenerator != nil {
		return securityProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileSpecARM(generators)
	securityProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileSpecARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileSpecARM(generators)
	securityProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_SpecARM{}), generators)

	return securityProfileSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileSpecARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfileSpecSecurityTypeTrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileSpecARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsSpecARMGenerator())
}

func Test_StorageProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileSpecARM, StorageProfileSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileSpecARM runs a test to see if a specific instance of StorageProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileSpecARM(subject StorageProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_SpecARM instances for property testing - lazily instantiated by
//StorageProfileSpecARMGenerator()
var storageProfileSpecARMGenerator gopter.Gen

// StorageProfileSpecARMGenerator returns a generator of StorageProfile_SpecARM instances for property testing.
func StorageProfileSpecARMGenerator() gopter.Gen {
	if storageProfileSpecARMGenerator != nil {
		return storageProfileSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileSpecARM(generators)
	storageProfileSpecARMGenerator = gen.Struct(reflect.TypeOf(StorageProfile_SpecARM{}), generators)

	return storageProfileSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileSpecARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskSpecARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceSpecARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskSpecARMGenerator())
}

func Test_BootDiagnostics_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsSpecARM, BootDiagnosticsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsSpecARM runs a test to see if a specific instance of BootDiagnostics_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsSpecARM(subject BootDiagnostics_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_SpecARM instances for property testing - lazily instantiated by
//BootDiagnosticsSpecARMGenerator()
var bootDiagnosticsSpecARMGenerator gopter.Gen

// BootDiagnosticsSpecARMGenerator returns a generator of BootDiagnostics_SpecARM instances for property testing.
func BootDiagnosticsSpecARMGenerator() gopter.Gen {
	if bootDiagnosticsSpecARMGenerator != nil {
		return bootDiagnosticsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsSpecARM(generators)
	bootDiagnosticsSpecARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_SpecARM{}), generators)

	return bootDiagnosticsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsSpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskSpecARM, DataDiskSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskSpecARM runs a test to see if a specific instance of DataDisk_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskSpecARM(subject DataDisk_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_SpecARM instances for property testing - lazily instantiated by DataDiskSpecARMGenerator()
var dataDiskSpecARMGenerator gopter.Gen

// DataDiskSpecARMGenerator returns a generator of DataDisk_SpecARM instances for property testing.
// We first initialize dataDiskSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskSpecARMGenerator() gopter.Gen {
	if dataDiskSpecARMGenerator != nil {
		return dataDiskSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskSpecARM(generators)
	dataDiskSpecARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskSpecARM(generators)
	AddRelatedPropertyGeneratorsForDataDiskSpecARM(generators)
	dataDiskSpecARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_SpecARM{}), generators)

	return dataDiskSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskSpecARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_SpecForceDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskSpecARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskSpecARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersSpecARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskSpecARMGenerator())
}

func Test_ImageReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceSpecARM, ImageReferenceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceSpecARM runs a test to see if a specific instance of ImageReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceSpecARM(subject ImageReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_SpecARM instances for property testing - lazily instantiated by
//ImageReferenceSpecARMGenerator()
var imageReferenceSpecARMGenerator gopter.Gen

// ImageReferenceSpecARMGenerator returns a generator of ImageReference_SpecARM instances for property testing.
func ImageReferenceSpecARMGenerator() gopter.Gen {
	if imageReferenceSpecARMGenerator != nil {
		return imageReferenceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceSpecARM(generators)
	imageReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(ImageReference_SpecARM{}), generators)

	return imageReferenceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationSpecARM, LinuxConfigurationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationSpecARM runs a test to see if a specific instance of LinuxConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationSpecARM(subject LinuxConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_SpecARM instances for property testing - lazily instantiated by
//LinuxConfigurationSpecARMGenerator()
var linuxConfigurationSpecARMGenerator gopter.Gen

// LinuxConfigurationSpecARMGenerator returns a generator of LinuxConfiguration_SpecARM instances for property testing.
// We first initialize linuxConfigurationSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationSpecARMGenerator() gopter.Gen {
	if linuxConfigurationSpecARMGenerator != nil {
		return linuxConfigurationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationSpecARM(generators)
	linuxConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationSpecARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationSpecARM(generators)
	linuxConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_SpecARM{}), generators)

	return linuxConfigurationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsSpecARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationSpecARMGenerator())
}

func Test_NetworkInterfaceReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceSpecARM, NetworkInterfaceReferenceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceSpecARM runs a test to see if a specific instance of NetworkInterfaceReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceSpecARM(subject NetworkInterfaceReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_SpecARM instances for property testing - lazily instantiated by
//NetworkInterfaceReferenceSpecARMGenerator()
var networkInterfaceReferenceSpecARMGenerator gopter.Gen

// NetworkInterfaceReferenceSpecARMGenerator returns a generator of NetworkInterfaceReference_SpecARM instances for property testing.
// We first initialize networkInterfaceReferenceSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceReferenceSpecARMGenerator() gopter.Gen {
	if networkInterfaceReferenceSpecARMGenerator != nil {
		return networkInterfaceReferenceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpecARM(generators)
	networkInterfaceReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpecARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceSpecARM(generators)
	networkInterfaceReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_SpecARM{}), generators)

	return networkInterfaceReferenceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferencePropertiesSpecARMGenerator())
}

func Test_OSDisk_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskSpecARM, OSDiskSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskSpecARM runs a test to see if a specific instance of OSDisk_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskSpecARM(subject OSDisk_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_SpecARM instances for property testing - lazily instantiated by OSDiskSpecARMGenerator()
var osDiskSpecARMGenerator gopter.Gen

// OSDiskSpecARMGenerator returns a generator of OSDisk_SpecARM instances for property testing.
// We first initialize osDiskSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskSpecARMGenerator() gopter.Gen {
	if osDiskSpecARMGenerator != nil {
		return osDiskSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskSpecARM(generators)
	osDiskSpecARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskSpecARM(generators)
	AddRelatedPropertyGeneratorsForOSDiskSpecARM(generators)
	osDiskSpecARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_SpecARM{}), generators)

	return osDiskSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskSpecARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDiskSpecOsTypeLinux, OSDiskSpecOsTypeWindows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskSpecARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsSpecARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsSpecARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskSpecARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersSpecARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskSpecARMGenerator())
}

func Test_UefiSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsSpecARM, UefiSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsSpecARM runs a test to see if a specific instance of UefiSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsSpecARM(subject UefiSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_SpecARM instances for property testing - lazily instantiated by
//UefiSettingsSpecARMGenerator()
var uefiSettingsSpecARMGenerator gopter.Gen

// UefiSettingsSpecARMGenerator returns a generator of UefiSettings_SpecARM instances for property testing.
func UefiSettingsSpecARMGenerator() gopter.Gen {
	if uefiSettingsSpecARMGenerator != nil {
		return uefiSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsSpecARM(generators)
	uefiSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(UefiSettings_SpecARM{}), generators)

	return uefiSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupSpecARM, VaultSecretGroupSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupSpecARM runs a test to see if a specific instance of VaultSecretGroup_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupSpecARM(subject VaultSecretGroup_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_SpecARM instances for property testing - lazily instantiated by
//VaultSecretGroupSpecARMGenerator()
var vaultSecretGroupSpecARMGenerator gopter.Gen

// VaultSecretGroupSpecARMGenerator returns a generator of VaultSecretGroup_SpecARM instances for property testing.
func VaultSecretGroupSpecARMGenerator() gopter.Gen {
	if vaultSecretGroupSpecARMGenerator != nil {
		return vaultSecretGroupSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupSpecARM(generators)
	vaultSecretGroupSpecARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_SpecARM{}), generators)

	return vaultSecretGroupSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupSpecARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceSpecARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateSpecARMGenerator())
}

func Test_WindowsConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationSpecARM, WindowsConfigurationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationSpecARM runs a test to see if a specific instance of WindowsConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationSpecARM(subject WindowsConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_SpecARM instances for property testing - lazily instantiated by
//WindowsConfigurationSpecARMGenerator()
var windowsConfigurationSpecARMGenerator gopter.Gen

// WindowsConfigurationSpecARMGenerator returns a generator of WindowsConfiguration_SpecARM instances for property testing.
// We first initialize windowsConfigurationSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationSpecARMGenerator() gopter.Gen {
	if windowsConfigurationSpecARMGenerator != nil {
		return windowsConfigurationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationSpecARM(generators)
	windowsConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationSpecARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationSpecARM(generators)
	windowsConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_SpecARM{}), generators)

	return windowsConfigurationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentSpecARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsSpecARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationSpecARMGenerator())
}

func Test_AdditionalUnattendContent_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentSpecARM, AdditionalUnattendContentSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentSpecARM runs a test to see if a specific instance of AdditionalUnattendContent_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentSpecARM(subject AdditionalUnattendContent_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_SpecARM instances for property testing - lazily instantiated by
//AdditionalUnattendContentSpecARMGenerator()
var additionalUnattendContentSpecARMGenerator gopter.Gen

// AdditionalUnattendContentSpecARMGenerator returns a generator of AdditionalUnattendContent_SpecARM instances for property testing.
func AdditionalUnattendContentSpecARMGenerator() gopter.Gen {
	if additionalUnattendContentSpecARMGenerator != nil {
		return additionalUnattendContentSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpecARM(generators)
	additionalUnattendContentSpecARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_SpecARM{}), generators)

	return additionalUnattendContentSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpecARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSpecComponentNameMicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSpecPassNameOobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSpecSettingNameAutoLogon, AdditionalUnattendContentSpecSettingNameFirstLogonCommands))
}

func Test_DiffDiskSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsSpecARM, DiffDiskSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsSpecARM runs a test to see if a specific instance of DiffDiskSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsSpecARM(subject DiffDiskSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_SpecARM instances for property testing - lazily instantiated by
//DiffDiskSettingsSpecARMGenerator()
var diffDiskSettingsSpecARMGenerator gopter.Gen

// DiffDiskSettingsSpecARMGenerator returns a generator of DiffDiskSettings_SpecARM instances for property testing.
func DiffDiskSettingsSpecARMGenerator() gopter.Gen {
	if diffDiskSettingsSpecARMGenerator != nil {
		return diffDiskSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsSpecARM(generators)
	diffDiskSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_SpecARM{}), generators)

	return diffDiskSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_SpecLocal))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_SpecCacheDisk, DiffDiskPlacement_SpecResourceDisk))
}

func Test_DiskEncryptionSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsSpecARM, DiskEncryptionSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsSpecARM runs a test to see if a specific instance of DiskEncryptionSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsSpecARM(subject DiskEncryptionSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_SpecARM instances for property testing - lazily instantiated by
//DiskEncryptionSettingsSpecARMGenerator()
var diskEncryptionSettingsSpecARMGenerator gopter.Gen

// DiskEncryptionSettingsSpecARMGenerator returns a generator of DiskEncryptionSettings_SpecARM instances for property testing.
// We first initialize diskEncryptionSettingsSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsSpecARMGenerator() gopter.Gen {
	if diskEncryptionSettingsSpecARMGenerator != nil {
		return diskEncryptionSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpecARM(generators)
	diskEncryptionSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpecARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpecARM(generators)
	diskEncryptionSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_SpecARM{}), generators)

	return diskEncryptionSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceSpecARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceSpecARMGenerator())
}

func Test_LinuxPatchSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsSpecARM, LinuxPatchSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsSpecARM runs a test to see if a specific instance of LinuxPatchSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsSpecARM(subject LinuxPatchSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_SpecARM instances for property testing - lazily instantiated by
//LinuxPatchSettingsSpecARMGenerator()
var linuxPatchSettingsSpecARMGenerator gopter.Gen

// LinuxPatchSettingsSpecARMGenerator returns a generator of LinuxPatchSettings_SpecARM instances for property testing.
func LinuxPatchSettingsSpecARMGenerator() gopter.Gen {
	if linuxPatchSettingsSpecARMGenerator != nil {
		return linuxPatchSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpecARM(generators)
	linuxPatchSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_SpecARM{}), generators)

	return linuxPatchSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettingsSpecPatchModeAutomaticByPlatform, LinuxPatchSettingsSpecPatchModeImageDefault))
}

func Test_ManagedDiskParameters_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersSpecARM, ManagedDiskParametersSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersSpecARM runs a test to see if a specific instance of ManagedDiskParameters_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersSpecARM(subject ManagedDiskParameters_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_SpecARM instances for property testing - lazily instantiated by
//ManagedDiskParametersSpecARMGenerator()
var managedDiskParametersSpecARMGenerator gopter.Gen

// ManagedDiskParametersSpecARMGenerator returns a generator of ManagedDiskParameters_SpecARM instances for property testing.
// We first initialize managedDiskParametersSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersSpecARMGenerator() gopter.Gen {
	if managedDiskParametersSpecARMGenerator != nil {
		return managedDiskParametersSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersSpecARM(generators)
	managedDiskParametersSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersSpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersSpecARM(generators)
	managedDiskParametersSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_SpecARM{}), generators)

	return managedDiskParametersSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_SpecPremiumLRS,
		StorageAccountType_SpecPremiumZRS,
		StorageAccountType_SpecStandardLRS,
		StorageAccountType_SpecStandardSSDLRS,
		StorageAccountType_SpecStandardSSDZRS,
		StorageAccountType_SpecUltraSSDLRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersSpecARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceSpecARMGenerator())
}

func Test_NetworkInterfaceReferenceProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferenceProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferencePropertiesSpecARM, NetworkInterfaceReferencePropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferencePropertiesSpecARM runs a test to see if a specific instance of NetworkInterfaceReferenceProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferencePropertiesSpecARM(subject NetworkInterfaceReferenceProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferenceProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferenceProperties_SpecARM instances for property testing - lazily instantiated by
//NetworkInterfaceReferencePropertiesSpecARMGenerator()
var networkInterfaceReferencePropertiesSpecARMGenerator gopter.Gen

// NetworkInterfaceReferencePropertiesSpecARMGenerator returns a generator of NetworkInterfaceReferenceProperties_SpecARM instances for property testing.
func NetworkInterfaceReferencePropertiesSpecARMGenerator() gopter.Gen {
	if networkInterfaceReferencePropertiesSpecARMGenerator != nil {
		return networkInterfaceReferencePropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesSpecARM(generators)
	networkInterfaceReferencePropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceProperties_SpecARM{}), generators)

	return networkInterfaceReferencePropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsSpecARM, PatchSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsSpecARM runs a test to see if a specific instance of PatchSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsSpecARM(subject PatchSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_SpecARM instances for property testing - lazily instantiated by
//PatchSettingsSpecARMGenerator()
var patchSettingsSpecARMGenerator gopter.Gen

// PatchSettingsSpecARMGenerator returns a generator of PatchSettings_SpecARM instances for property testing.
func PatchSettingsSpecARMGenerator() gopter.Gen {
	if patchSettingsSpecARMGenerator != nil {
		return patchSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsSpecARM(generators)
	patchSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(PatchSettings_SpecARM{}), generators)

	return patchSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettingsSpecPatchModeAutomaticByOS, PatchSettingsSpecPatchModeAutomaticByPlatform, PatchSettingsSpecPatchModeManual))
}

func Test_SshConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationSpecARM, SshConfigurationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationSpecARM runs a test to see if a specific instance of SshConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationSpecARM(subject SshConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_SpecARM instances for property testing - lazily instantiated by
//SshConfigurationSpecARMGenerator()
var sshConfigurationSpecARMGenerator gopter.Gen

// SshConfigurationSpecARMGenerator returns a generator of SshConfiguration_SpecARM instances for property testing.
func SshConfigurationSpecARMGenerator() gopter.Gen {
	if sshConfigurationSpecARMGenerator != nil {
		return sshConfigurationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationSpecARM(generators)
	sshConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_SpecARM{}), generators)

	return sshConfigurationSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeySpecARMGenerator())
}

func Test_VaultCertificate_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateSpecARM, VaultCertificateSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateSpecARM runs a test to see if a specific instance of VaultCertificate_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateSpecARM(subject VaultCertificate_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_SpecARM instances for property testing - lazily instantiated by
//VaultCertificateSpecARMGenerator()
var vaultCertificateSpecARMGenerator gopter.Gen

// VaultCertificateSpecARMGenerator returns a generator of VaultCertificate_SpecARM instances for property testing.
func VaultCertificateSpecARMGenerator() gopter.Gen {
	if vaultCertificateSpecARMGenerator != nil {
		return vaultCertificateSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateSpecARM(generators)
	vaultCertificateSpecARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_SpecARM{}), generators)

	return vaultCertificateSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateSpecARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskSpecARM, VirtualHardDiskSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskSpecARM runs a test to see if a specific instance of VirtualHardDisk_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskSpecARM(subject VirtualHardDisk_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_SpecARM instances for property testing - lazily instantiated by
//VirtualHardDiskSpecARMGenerator()
var virtualHardDiskSpecARMGenerator gopter.Gen

// VirtualHardDiskSpecARMGenerator returns a generator of VirtualHardDisk_SpecARM instances for property testing.
func VirtualHardDiskSpecARMGenerator() gopter.Gen {
	if virtualHardDiskSpecARMGenerator != nil {
		return virtualHardDiskSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskSpecARM(generators)
	virtualHardDiskSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_SpecARM{}), generators)

	return virtualHardDiskSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskSpecARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationSpecARM, WinRMConfigurationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationSpecARM runs a test to see if a specific instance of WinRMConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationSpecARM(subject WinRMConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_SpecARM instances for property testing - lazily instantiated by
//WinRMConfigurationSpecARMGenerator()
var winRMConfigurationSpecARMGenerator gopter.Gen

// WinRMConfigurationSpecARMGenerator returns a generator of WinRMConfiguration_SpecARM instances for property testing.
func WinRMConfigurationSpecARMGenerator() gopter.Gen {
	if winRMConfigurationSpecARMGenerator != nil {
		return winRMConfigurationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationSpecARM(generators)
	winRMConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_SpecARM{}), generators)

	return winRMConfigurationSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerSpecARMGenerator())
}

func Test_KeyVaultKeyReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceSpecARM, KeyVaultKeyReferenceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceSpecARM runs a test to see if a specific instance of KeyVaultKeyReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceSpecARM(subject KeyVaultKeyReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_SpecARM instances for property testing - lazily instantiated by
//KeyVaultKeyReferenceSpecARMGenerator()
var keyVaultKeyReferenceSpecARMGenerator gopter.Gen

// KeyVaultKeyReferenceSpecARMGenerator returns a generator of KeyVaultKeyReference_SpecARM instances for property testing.
// We first initialize keyVaultKeyReferenceSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceSpecARMGenerator() gopter.Gen {
	if keyVaultKeyReferenceSpecARMGenerator != nil {
		return keyVaultKeyReferenceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpecARM(generators)
	keyVaultKeyReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpecARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpecARM(generators)
	keyVaultKeyReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_SpecARM{}), generators)

	return keyVaultKeyReferenceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResourceSpecARMGenerator()
}

func Test_KeyVaultSecretReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceSpecARM, KeyVaultSecretReferenceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceSpecARM runs a test to see if a specific instance of KeyVaultSecretReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceSpecARM(subject KeyVaultSecretReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_SpecARM instances for property testing - lazily instantiated by
//KeyVaultSecretReferenceSpecARMGenerator()
var keyVaultSecretReferenceSpecARMGenerator gopter.Gen

// KeyVaultSecretReferenceSpecARMGenerator returns a generator of KeyVaultSecretReference_SpecARM instances for property testing.
// We first initialize keyVaultSecretReferenceSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceSpecARMGenerator() gopter.Gen {
	if keyVaultSecretReferenceSpecARMGenerator != nil {
		return keyVaultSecretReferenceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpecARM(generators)
	keyVaultSecretReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpecARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpecARM(generators)
	keyVaultSecretReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_SpecARM{}), generators)

	return keyVaultSecretReferenceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResourceSpecARMGenerator()
}

func Test_SshPublicKey_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeySpecARM, SshPublicKeySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeySpecARM runs a test to see if a specific instance of SshPublicKey_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeySpecARM(subject SshPublicKey_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_SpecARM instances for property testing - lazily instantiated by
//SshPublicKeySpecARMGenerator()
var sshPublicKeySpecARMGenerator gopter.Gen

// SshPublicKeySpecARMGenerator returns a generator of SshPublicKey_SpecARM instances for property testing.
func SshPublicKeySpecARMGenerator() gopter.Gen {
	if sshPublicKeySpecARMGenerator != nil {
		return sshPublicKeySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeySpecARM(generators)
	sshPublicKeySpecARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_SpecARM{}), generators)

	return sshPublicKeySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeySpecARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerSpecARM, WinRMListenerSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerSpecARM runs a test to see if a specific instance of WinRMListener_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerSpecARM(subject WinRMListener_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_SpecARM instances for property testing - lazily instantiated by
//WinRMListenerSpecARMGenerator()
var winRMListenerSpecARMGenerator gopter.Gen

// WinRMListenerSpecARMGenerator returns a generator of WinRMListener_SpecARM instances for property testing.
func WinRMListenerSpecARMGenerator() gopter.Gen {
	if winRMListenerSpecARMGenerator != nil {
		return winRMListenerSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerSpecARM(generators)
	winRMListenerSpecARMGenerator = gen.Struct(reflect.TypeOf(WinRMListener_SpecARM{}), generators)

	return winRMListenerSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerSpecARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListenerSpecProtocolHttp, WinRMListenerSpecProtocolHttps))
}
