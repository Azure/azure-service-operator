// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachines_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachines_SPECARM, VirtualMachines_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachines_SPECARM runs a test to see if a specific instance of VirtualMachines_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachines_SPECARM(subject VirtualMachines_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_SPECARM instances for property testing - lazily instantiated by
//VirtualMachines_SPECARMGenerator()
var virtualMachines_specarmGenerator gopter.Gen

// VirtualMachines_SPECARMGenerator returns a generator of VirtualMachines_SPECARM instances for property testing.
// We first initialize virtualMachines_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachines_SPECARMGenerator() gopter.Gen {
	if virtualMachines_specarmGenerator != nil {
		return virtualMachines_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachines_SPECARM(generators)
	virtualMachines_specarmGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachines_SPECARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachines_SPECARM(generators)
	virtualMachines_specarmGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPECARM{}), generators)

	return virtualMachines_specarmGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachines_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachines_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachines_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachines_SPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentity_SpecARMGenerator())
	gens["Plan"] = gen.PtrOf(Plan_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachineProperties_SpecARMGenerator())
}

func Test_VirtualMachineIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_SpecARM, VirtualMachineIdentity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_SpecARM runs a test to see if a specific instance of VirtualMachineIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_SpecARM(subject VirtualMachineIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_SpecARM instances for property testing - lazily instantiated by
//VirtualMachineIdentity_SpecARMGenerator()
var virtualMachineIdentity_specARMGenerator gopter.Gen

// VirtualMachineIdentity_SpecARMGenerator returns a generator of VirtualMachineIdentity_SpecARM instances for property testing.
func VirtualMachineIdentity_SpecARMGenerator() gopter.Gen {
	if virtualMachineIdentity_specARMGenerator != nil {
		return virtualMachineIdentity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_SpecARM(generators)
	virtualMachineIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_SpecARM{}), generators)

	return virtualMachineIdentity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentity_Type_SpecNone,
		VirtualMachineIdentity_Type_SpecSystemAssigned,
		VirtualMachineIdentity_Type_SpecSystemAssignedUserAssigned,
		VirtualMachineIdentity_Type_SpecUserAssigned))
}

func Test_VirtualMachineProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineProperties_SpecARM, VirtualMachineProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineProperties_SpecARM runs a test to see if a specific instance of VirtualMachineProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineProperties_SpecARM(subject VirtualMachineProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineProperties_SpecARM instances for property testing - lazily instantiated by
//VirtualMachineProperties_SpecARMGenerator()
var virtualMachineProperties_specARMGenerator gopter.Gen

// VirtualMachineProperties_SpecARMGenerator returns a generator of VirtualMachineProperties_SpecARM instances for property testing.
// We first initialize virtualMachineProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineProperties_SpecARMGenerator() gopter.Gen {
	if virtualMachineProperties_specARMGenerator != nil {
		return virtualMachineProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_SpecARM(generators)
	virtualMachineProperties_specARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineProperties_SpecARM(generators)
	virtualMachineProperties_specARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_SpecARM{}), generators)

	return virtualMachineProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_SpecDeallocate, EvictionPolicy_SpecDelete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_SpecLow, Priority_SpecRegular, Priority_SpecSpot))
}

// AddRelatedPropertyGeneratorsForVirtualMachineProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_SpecARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_SpecARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_SpecARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfile_SpecARMGenerator())
	gens["Host"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_SpecARMGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfile_SpecARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_SpecARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfile_SpecARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResource_SpecARMGenerator())
}

func Test_BillingProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile_SpecARM, BillingProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile_SpecARM runs a test to see if a specific instance of BillingProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile_SpecARM(subject BillingProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_SpecARM instances for property testing - lazily instantiated by
//BillingProfile_SpecARMGenerator()
var billingProfile_specARMGenerator gopter.Gen

// BillingProfile_SpecARMGenerator returns a generator of BillingProfile_SpecARM instances for property testing.
func BillingProfile_SpecARMGenerator() gopter.Gen {
	if billingProfile_specARMGenerator != nil {
		return billingProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile_SpecARM(generators)
	billingProfile_specARMGenerator = gen.Struct(reflect.TypeOf(BillingProfile_SpecARM{}), generators)

	return billingProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile_SpecARM, DiagnosticsProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile_SpecARM runs a test to see if a specific instance of DiagnosticsProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile_SpecARM(subject DiagnosticsProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_SpecARM instances for property testing - lazily instantiated by
//DiagnosticsProfile_SpecARMGenerator()
var diagnosticsProfile_specARMGenerator gopter.Gen

// DiagnosticsProfile_SpecARMGenerator returns a generator of DiagnosticsProfile_SpecARM instances for property testing.
func DiagnosticsProfile_SpecARMGenerator() gopter.Gen {
	if diagnosticsProfile_specARMGenerator != nil {
		return diagnosticsProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile_SpecARM(generators)
	diagnosticsProfile_specARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_SpecARM{}), generators)

	return diagnosticsProfile_specARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnostics_SpecARMGenerator())
}

func Test_HardwareProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile_SpecARM, HardwareProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile_SpecARM runs a test to see if a specific instance of HardwareProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile_SpecARM(subject HardwareProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_SpecARM instances for property testing - lazily instantiated by
//HardwareProfile_SpecARMGenerator()
var hardwareProfile_specARMGenerator gopter.Gen

// HardwareProfile_SpecARMGenerator returns a generator of HardwareProfile_SpecARM instances for property testing.
func HardwareProfile_SpecARMGenerator() gopter.Gen {
	if hardwareProfile_specARMGenerator != nil {
		return hardwareProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile_SpecARM(generators)
	hardwareProfile_specARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_SpecARM{}), generators)

	return hardwareProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfile_VmSize_SpecBasic_A0,
		HardwareProfile_VmSize_SpecBasic_A1,
		HardwareProfile_VmSize_SpecBasic_A2,
		HardwareProfile_VmSize_SpecBasic_A3,
		HardwareProfile_VmSize_SpecBasic_A4,
		HardwareProfile_VmSize_SpecStandard_A0,
		HardwareProfile_VmSize_SpecStandard_A1,
		HardwareProfile_VmSize_SpecStandard_A10,
		HardwareProfile_VmSize_SpecStandard_A11,
		HardwareProfile_VmSize_SpecStandard_A1_V2,
		HardwareProfile_VmSize_SpecStandard_A2,
		HardwareProfile_VmSize_SpecStandard_A2M_V2,
		HardwareProfile_VmSize_SpecStandard_A2_V2,
		HardwareProfile_VmSize_SpecStandard_A3,
		HardwareProfile_VmSize_SpecStandard_A4,
		HardwareProfile_VmSize_SpecStandard_A4M_V2,
		HardwareProfile_VmSize_SpecStandard_A4_V2,
		HardwareProfile_VmSize_SpecStandard_A5,
		HardwareProfile_VmSize_SpecStandard_A6,
		HardwareProfile_VmSize_SpecStandard_A7,
		HardwareProfile_VmSize_SpecStandard_A8,
		HardwareProfile_VmSize_SpecStandard_A8M_V2,
		HardwareProfile_VmSize_SpecStandard_A8_V2,
		HardwareProfile_VmSize_SpecStandard_A9,
		HardwareProfile_VmSize_SpecStandard_B1Ms,
		HardwareProfile_VmSize_SpecStandard_B1S,
		HardwareProfile_VmSize_SpecStandard_B2Ms,
		HardwareProfile_VmSize_SpecStandard_B2S,
		HardwareProfile_VmSize_SpecStandard_B4Ms,
		HardwareProfile_VmSize_SpecStandard_B8Ms,
		HardwareProfile_VmSize_SpecStandard_D1,
		HardwareProfile_VmSize_SpecStandard_D11,
		HardwareProfile_VmSize_SpecStandard_D11_V2,
		HardwareProfile_VmSize_SpecStandard_D12,
		HardwareProfile_VmSize_SpecStandard_D12_V2,
		HardwareProfile_VmSize_SpecStandard_D13,
		HardwareProfile_VmSize_SpecStandard_D13_V2,
		HardwareProfile_VmSize_SpecStandard_D14,
		HardwareProfile_VmSize_SpecStandard_D14_V2,
		HardwareProfile_VmSize_SpecStandard_D15_V2,
		HardwareProfile_VmSize_SpecStandard_D16S_V3,
		HardwareProfile_VmSize_SpecStandard_D16_V3,
		HardwareProfile_VmSize_SpecStandard_D1_V2,
		HardwareProfile_VmSize_SpecStandard_D2,
		HardwareProfile_VmSize_SpecStandard_D2S_V3,
		HardwareProfile_VmSize_SpecStandard_D2_V2,
		HardwareProfile_VmSize_SpecStandard_D2_V3,
		HardwareProfile_VmSize_SpecStandard_D3,
		HardwareProfile_VmSize_SpecStandard_D32S_V3,
		HardwareProfile_VmSize_SpecStandard_D32_V3,
		HardwareProfile_VmSize_SpecStandard_D3_V2,
		HardwareProfile_VmSize_SpecStandard_D4,
		HardwareProfile_VmSize_SpecStandard_D4S_V3,
		HardwareProfile_VmSize_SpecStandard_D4_V2,
		HardwareProfile_VmSize_SpecStandard_D4_V3,
		HardwareProfile_VmSize_SpecStandard_D5_V2,
		HardwareProfile_VmSize_SpecStandard_D64S_V3,
		HardwareProfile_VmSize_SpecStandard_D64_V3,
		HardwareProfile_VmSize_SpecStandard_D8S_V3,
		HardwareProfile_VmSize_SpecStandard_D8_V3,
		HardwareProfile_VmSize_SpecStandard_DS1,
		HardwareProfile_VmSize_SpecStandard_DS11,
		HardwareProfile_VmSize_SpecStandard_DS11_V2,
		HardwareProfile_VmSize_SpecStandard_DS12,
		HardwareProfile_VmSize_SpecStandard_DS12_V2,
		HardwareProfile_VmSize_SpecStandard_DS13,
		HardwareProfile_VmSize_SpecStandard_DS132_V2,
		HardwareProfile_VmSize_SpecStandard_DS134_V2,
		HardwareProfile_VmSize_SpecStandard_DS13_V2,
		HardwareProfile_VmSize_SpecStandard_DS14,
		HardwareProfile_VmSize_SpecStandard_DS144_V2,
		HardwareProfile_VmSize_SpecStandard_DS148_V2,
		HardwareProfile_VmSize_SpecStandard_DS14_V2,
		HardwareProfile_VmSize_SpecStandard_DS15_V2,
		HardwareProfile_VmSize_SpecStandard_DS1_V2,
		HardwareProfile_VmSize_SpecStandard_DS2,
		HardwareProfile_VmSize_SpecStandard_DS2_V2,
		HardwareProfile_VmSize_SpecStandard_DS3,
		HardwareProfile_VmSize_SpecStandard_DS3_V2,
		HardwareProfile_VmSize_SpecStandard_DS4,
		HardwareProfile_VmSize_SpecStandard_DS4_V2,
		HardwareProfile_VmSize_SpecStandard_DS5_V2,
		HardwareProfile_VmSize_SpecStandard_E16S_V3,
		HardwareProfile_VmSize_SpecStandard_E16_V3,
		HardwareProfile_VmSize_SpecStandard_E2S_V3,
		HardwareProfile_VmSize_SpecStandard_E2_V3,
		HardwareProfile_VmSize_SpecStandard_E3216_V3,
		HardwareProfile_VmSize_SpecStandard_E328S_V3,
		HardwareProfile_VmSize_SpecStandard_E32S_V3,
		HardwareProfile_VmSize_SpecStandard_E32_V3,
		HardwareProfile_VmSize_SpecStandard_E4S_V3,
		HardwareProfile_VmSize_SpecStandard_E4_V3,
		HardwareProfile_VmSize_SpecStandard_E6416S_V3,
		HardwareProfile_VmSize_SpecStandard_E6432S_V3,
		HardwareProfile_VmSize_SpecStandard_E64S_V3,
		HardwareProfile_VmSize_SpecStandard_E64_V3,
		HardwareProfile_VmSize_SpecStandard_E8S_V3,
		HardwareProfile_VmSize_SpecStandard_E8_V3,
		HardwareProfile_VmSize_SpecStandard_F1,
		HardwareProfile_VmSize_SpecStandard_F16,
		HardwareProfile_VmSize_SpecStandard_F16S,
		HardwareProfile_VmSize_SpecStandard_F16S_V2,
		HardwareProfile_VmSize_SpecStandard_F1S,
		HardwareProfile_VmSize_SpecStandard_F2,
		HardwareProfile_VmSize_SpecStandard_F2S,
		HardwareProfile_VmSize_SpecStandard_F2S_V2,
		HardwareProfile_VmSize_SpecStandard_F32S_V2,
		HardwareProfile_VmSize_SpecStandard_F4,
		HardwareProfile_VmSize_SpecStandard_F4S,
		HardwareProfile_VmSize_SpecStandard_F4S_V2,
		HardwareProfile_VmSize_SpecStandard_F64S_V2,
		HardwareProfile_VmSize_SpecStandard_F72S_V2,
		HardwareProfile_VmSize_SpecStandard_F8,
		HardwareProfile_VmSize_SpecStandard_F8S,
		HardwareProfile_VmSize_SpecStandard_F8S_V2,
		HardwareProfile_VmSize_SpecStandard_G1,
		HardwareProfile_VmSize_SpecStandard_G2,
		HardwareProfile_VmSize_SpecStandard_G3,
		HardwareProfile_VmSize_SpecStandard_G4,
		HardwareProfile_VmSize_SpecStandard_G5,
		HardwareProfile_VmSize_SpecStandard_GS1,
		HardwareProfile_VmSize_SpecStandard_GS2,
		HardwareProfile_VmSize_SpecStandard_GS3,
		HardwareProfile_VmSize_SpecStandard_GS4,
		HardwareProfile_VmSize_SpecStandard_GS44,
		HardwareProfile_VmSize_SpecStandard_GS48,
		HardwareProfile_VmSize_SpecStandard_GS5,
		HardwareProfile_VmSize_SpecStandard_GS516,
		HardwareProfile_VmSize_SpecStandard_GS58,
		HardwareProfile_VmSize_SpecStandard_H16,
		HardwareProfile_VmSize_SpecStandard_H16M,
		HardwareProfile_VmSize_SpecStandard_H16Mr,
		HardwareProfile_VmSize_SpecStandard_H16R,
		HardwareProfile_VmSize_SpecStandard_H8,
		HardwareProfile_VmSize_SpecStandard_H8M,
		HardwareProfile_VmSize_SpecStandard_L16S,
		HardwareProfile_VmSize_SpecStandard_L32S,
		HardwareProfile_VmSize_SpecStandard_L4S,
		HardwareProfile_VmSize_SpecStandard_L8S,
		HardwareProfile_VmSize_SpecStandard_M12832Ms,
		HardwareProfile_VmSize_SpecStandard_M12864Ms,
		HardwareProfile_VmSize_SpecStandard_M128Ms,
		HardwareProfile_VmSize_SpecStandard_M128S,
		HardwareProfile_VmSize_SpecStandard_M6416Ms,
		HardwareProfile_VmSize_SpecStandard_M6432Ms,
		HardwareProfile_VmSize_SpecStandard_M64Ms,
		HardwareProfile_VmSize_SpecStandard_M64S,
		HardwareProfile_VmSize_SpecStandard_NC12,
		HardwareProfile_VmSize_SpecStandard_NC12S_V2,
		HardwareProfile_VmSize_SpecStandard_NC12S_V3,
		HardwareProfile_VmSize_SpecStandard_NC24,
		HardwareProfile_VmSize_SpecStandard_NC24R,
		HardwareProfile_VmSize_SpecStandard_NC24Rs_V2,
		HardwareProfile_VmSize_SpecStandard_NC24Rs_V3,
		HardwareProfile_VmSize_SpecStandard_NC24S_V2,
		HardwareProfile_VmSize_SpecStandard_NC24S_V3,
		HardwareProfile_VmSize_SpecStandard_NC6,
		HardwareProfile_VmSize_SpecStandard_NC6S_V2,
		HardwareProfile_VmSize_SpecStandard_NC6S_V3,
		HardwareProfile_VmSize_SpecStandard_ND12S,
		HardwareProfile_VmSize_SpecStandard_ND24Rs,
		HardwareProfile_VmSize_SpecStandard_ND24S,
		HardwareProfile_VmSize_SpecStandard_ND6S,
		HardwareProfile_VmSize_SpecStandard_NV12,
		HardwareProfile_VmSize_SpecStandard_NV24,
		HardwareProfile_VmSize_SpecStandard_NV6))
}

func Test_NetworkProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_SpecARM, NetworkProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_SpecARM runs a test to see if a specific instance of NetworkProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_SpecARM(subject NetworkProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_SpecARM instances for property testing - lazily instantiated by
//NetworkProfile_SpecARMGenerator()
var networkProfile_specARMGenerator gopter.Gen

// NetworkProfile_SpecARMGenerator returns a generator of NetworkProfile_SpecARM instances for property testing.
func NetworkProfile_SpecARMGenerator() gopter.Gen {
	if networkProfile_specARMGenerator != nil {
		return networkProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfile_SpecARM(generators)
	networkProfile_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_SpecARM{}), generators)

	return networkProfile_specARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReference_SpecARMGenerator())
}

func Test_OSProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfile_SpecARM, OSProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfile_SpecARM runs a test to see if a specific instance of OSProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfile_SpecARM(subject OSProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_SpecARM instances for property testing - lazily instantiated by OSProfile_SpecARMGenerator()
var osProfile_specARMGenerator gopter.Gen

// OSProfile_SpecARMGenerator returns a generator of OSProfile_SpecARM instances for property testing.
// We first initialize osProfile_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfile_SpecARMGenerator() gopter.Gen {
	if osProfile_specARMGenerator != nil {
		return osProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_SpecARM(generators)
	osProfile_specARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_SpecARM(generators)
	AddRelatedPropertyGeneratorsForOSProfile_SpecARM(generators)
	osProfile_specARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_SpecARM{}), generators)

	return osProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForOSProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_SpecARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_SpecARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_SpecARMGenerator())
}

func Test_SecurityProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile_SpecARM, SecurityProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile_SpecARM runs a test to see if a specific instance of SecurityProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile_SpecARM(subject SecurityProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_SpecARM instances for property testing - lazily instantiated by
//SecurityProfile_SpecARMGenerator()
var securityProfile_specARMGenerator gopter.Gen

// SecurityProfile_SpecARMGenerator returns a generator of SecurityProfile_SpecARM instances for property testing.
// We first initialize securityProfile_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfile_SpecARMGenerator() gopter.Gen {
	if securityProfile_specARMGenerator != nil {
		return securityProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_SpecARM(generators)
	securityProfile_specARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_SpecARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile_SpecARM(generators)
	securityProfile_specARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_SpecARM{}), generators)

	return securityProfile_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfile_SecurityType_SpecTrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettings_SpecARMGenerator())
}

func Test_StorageProfile_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile_SpecARM, StorageProfile_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile_SpecARM runs a test to see if a specific instance of StorageProfile_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile_SpecARM(subject StorageProfile_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_SpecARM instances for property testing - lazily instantiated by
//StorageProfile_SpecARMGenerator()
var storageProfile_specARMGenerator gopter.Gen

// StorageProfile_SpecARMGenerator returns a generator of StorageProfile_SpecARM instances for property testing.
func StorageProfile_SpecARMGenerator() gopter.Gen {
	if storageProfile_specARMGenerator != nil {
		return storageProfile_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile_SpecARM(generators)
	storageProfile_specARMGenerator = gen.Struct(reflect.TypeOf(StorageProfile_SpecARM{}), generators)

	return storageProfile_specARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile_SpecARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDisk_SpecARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_SpecARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDisk_SpecARMGenerator())
}

func Test_BootDiagnostics_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics_SpecARM, BootDiagnostics_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics_SpecARM runs a test to see if a specific instance of BootDiagnostics_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics_SpecARM(subject BootDiagnostics_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_SpecARM instances for property testing - lazily instantiated by
//BootDiagnostics_SpecARMGenerator()
var bootDiagnostics_specARMGenerator gopter.Gen

// BootDiagnostics_SpecARMGenerator returns a generator of BootDiagnostics_SpecARM instances for property testing.
func BootDiagnostics_SpecARMGenerator() gopter.Gen {
	if bootDiagnostics_specARMGenerator != nil {
		return bootDiagnostics_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics_SpecARM(generators)
	bootDiagnostics_specARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_SpecARM{}), generators)

	return bootDiagnostics_specARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics_SpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk_SpecARM, DataDisk_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk_SpecARM runs a test to see if a specific instance of DataDisk_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk_SpecARM(subject DataDisk_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_SpecARM instances for property testing - lazily instantiated by DataDisk_SpecARMGenerator()
var dataDisk_specARMGenerator gopter.Gen

// DataDisk_SpecARMGenerator returns a generator of DataDisk_SpecARM instances for property testing.
// We first initialize dataDisk_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDisk_SpecARMGenerator() gopter.Gen {
	if dataDisk_specARMGenerator != nil {
		return dataDisk_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_SpecARM(generators)
	dataDisk_specARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_SpecARM(generators)
	AddRelatedPropertyGeneratorsForDataDisk_SpecARM(generators)
	dataDisk_specARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_SpecARM{}), generators)

	return dataDisk_specARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk_SpecARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_SpecForceDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk_SpecARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDisk_SpecARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_SpecARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_SpecARMGenerator())
}

func Test_ImageReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference_SpecARM, ImageReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference_SpecARM runs a test to see if a specific instance of ImageReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference_SpecARM(subject ImageReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_SpecARM instances for property testing - lazily instantiated by
//ImageReference_SpecARMGenerator()
var imageReference_specARMGenerator gopter.Gen

// ImageReference_SpecARMGenerator returns a generator of ImageReference_SpecARM instances for property testing.
func ImageReference_SpecARMGenerator() gopter.Gen {
	if imageReference_specARMGenerator != nil {
		return imageReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference_SpecARM(generators)
	imageReference_specARMGenerator = gen.Struct(reflect.TypeOf(ImageReference_SpecARM{}), generators)

	return imageReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration_SpecARM, LinuxConfiguration_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration_SpecARM runs a test to see if a specific instance of LinuxConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration_SpecARM(subject LinuxConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_SpecARM instances for property testing - lazily instantiated by
//LinuxConfiguration_SpecARMGenerator()
var linuxConfiguration_specARMGenerator gopter.Gen

// LinuxConfiguration_SpecARMGenerator returns a generator of LinuxConfiguration_SpecARM instances for property testing.
// We first initialize linuxConfiguration_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfiguration_SpecARMGenerator() gopter.Gen {
	if linuxConfiguration_specARMGenerator != nil {
		return linuxConfiguration_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_SpecARM(generators)
	linuxConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_SpecARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration_SpecARM(generators)
	linuxConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_SpecARM{}), generators)

	return linuxConfiguration_specARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettings_SpecARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfiguration_SpecARMGenerator())
}

func Test_NetworkInterfaceReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReference_SpecARM, NetworkInterfaceReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReference_SpecARM runs a test to see if a specific instance of NetworkInterfaceReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReference_SpecARM(subject NetworkInterfaceReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_SpecARM instances for property testing - lazily instantiated by
//NetworkInterfaceReference_SpecARMGenerator()
var networkInterfaceReference_specARMGenerator gopter.Gen

// NetworkInterfaceReference_SpecARMGenerator returns a generator of NetworkInterfaceReference_SpecARM instances for property testing.
// We first initialize networkInterfaceReference_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceReference_SpecARMGenerator() gopter.Gen {
	if networkInterfaceReference_specARMGenerator != nil {
		return networkInterfaceReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_SpecARM(generators)
	networkInterfaceReference_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_SpecARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceReference_SpecARM(generators)
	networkInterfaceReference_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_SpecARM{}), generators)

	return networkInterfaceReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReference_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceReference_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceReference_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferenceProperties_SpecARMGenerator())
}

func Test_OSDisk_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk_SpecARM, OSDisk_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk_SpecARM runs a test to see if a specific instance of OSDisk_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk_SpecARM(subject OSDisk_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_SpecARM instances for property testing - lazily instantiated by OSDisk_SpecARMGenerator()
var osDisk_specARMGenerator gopter.Gen

// OSDisk_SpecARMGenerator returns a generator of OSDisk_SpecARM instances for property testing.
// We first initialize osDisk_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDisk_SpecARMGenerator() gopter.Gen {
	if osDisk_specARMGenerator != nil {
		return osDisk_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_SpecARM(generators)
	osDisk_specARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_SpecARM(generators)
	AddRelatedPropertyGeneratorsForOSDisk_SpecARM(generators)
	osDisk_specARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_SpecARM{}), generators)

	return osDisk_specARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk_SpecARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDisk_OsType_SpecLinux, OSDisk_OsType_SpecWindows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk_SpecARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_SpecARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettings_SpecARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_SpecARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_SpecARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_SpecARMGenerator())
}

func Test_UefiSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings_SpecARM, UefiSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings_SpecARM runs a test to see if a specific instance of UefiSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings_SpecARM(subject UefiSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_SpecARM instances for property testing - lazily instantiated by
//UefiSettings_SpecARMGenerator()
var uefiSettings_specARMGenerator gopter.Gen

// UefiSettings_SpecARMGenerator returns a generator of UefiSettings_SpecARM instances for property testing.
func UefiSettings_SpecARMGenerator() gopter.Gen {
	if uefiSettings_specARMGenerator != nil {
		return uefiSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings_SpecARM(generators)
	uefiSettings_specARMGenerator = gen.Struct(reflect.TypeOf(UefiSettings_SpecARM{}), generators)

	return uefiSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup_SpecARM, VaultSecretGroup_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup_SpecARM runs a test to see if a specific instance of VaultSecretGroup_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup_SpecARM(subject VaultSecretGroup_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_SpecARM instances for property testing - lazily instantiated by
//VaultSecretGroup_SpecARMGenerator()
var vaultSecretGroup_specARMGenerator gopter.Gen

// VaultSecretGroup_SpecARMGenerator returns a generator of VaultSecretGroup_SpecARM instances for property testing.
func VaultSecretGroup_SpecARMGenerator() gopter.Gen {
	if vaultSecretGroup_specARMGenerator != nil {
		return vaultSecretGroup_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup_SpecARM(generators)
	vaultSecretGroup_specARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_SpecARM{}), generators)

	return vaultSecretGroup_specARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup_SpecARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_SpecARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificate_SpecARMGenerator())
}

func Test_WindowsConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration_SpecARM, WindowsConfiguration_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration_SpecARM runs a test to see if a specific instance of WindowsConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration_SpecARM(subject WindowsConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_SpecARM instances for property testing - lazily instantiated by
//WindowsConfiguration_SpecARMGenerator()
var windowsConfiguration_specARMGenerator gopter.Gen

// WindowsConfiguration_SpecARMGenerator returns a generator of WindowsConfiguration_SpecARM instances for property testing.
// We first initialize windowsConfiguration_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfiguration_SpecARMGenerator() gopter.Gen {
	if windowsConfiguration_specARMGenerator != nil {
		return windowsConfiguration_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_SpecARM(generators)
	windowsConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_SpecARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration_SpecARM(generators)
	windowsConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_SpecARM{}), generators)

	return windowsConfiguration_specARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContent_SpecARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettings_SpecARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfiguration_SpecARMGenerator())
}

func Test_AdditionalUnattendContent_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent_SpecARM, AdditionalUnattendContent_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent_SpecARM runs a test to see if a specific instance of AdditionalUnattendContent_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent_SpecARM(subject AdditionalUnattendContent_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_SpecARM instances for property testing - lazily instantiated by
//AdditionalUnattendContent_SpecARMGenerator()
var additionalUnattendContent_specARMGenerator gopter.Gen

// AdditionalUnattendContent_SpecARMGenerator returns a generator of AdditionalUnattendContent_SpecARM instances for property testing.
func AdditionalUnattendContent_SpecARMGenerator() gopter.Gen {
	if additionalUnattendContent_specARMGenerator != nil {
		return additionalUnattendContent_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent_SpecARM(generators)
	additionalUnattendContent_specARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_SpecARM{}), generators)

	return additionalUnattendContent_specARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent_SpecARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_ComponentName_SpecMicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_PassName_SpecOobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_SettingName_SpecAutoLogon, AdditionalUnattendContent_SettingName_SpecFirstLogonCommands))
}

func Test_DiffDiskSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings_SpecARM, DiffDiskSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings_SpecARM runs a test to see if a specific instance of DiffDiskSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings_SpecARM(subject DiffDiskSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_SpecARM instances for property testing - lazily instantiated by
//DiffDiskSettings_SpecARMGenerator()
var diffDiskSettings_specARMGenerator gopter.Gen

// DiffDiskSettings_SpecARMGenerator returns a generator of DiffDiskSettings_SpecARM instances for property testing.
func DiffDiskSettings_SpecARMGenerator() gopter.Gen {
	if diffDiskSettings_specARMGenerator != nil {
		return diffDiskSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings_SpecARM(generators)
	diffDiskSettings_specARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_SpecARM{}), generators)

	return diffDiskSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_SpecLocal))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_SpecCacheDisk, DiffDiskPlacement_SpecResourceDisk))
}

func Test_DiskEncryptionSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings_SpecARM, DiskEncryptionSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings_SpecARM runs a test to see if a specific instance of DiskEncryptionSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings_SpecARM(subject DiskEncryptionSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_SpecARM instances for property testing - lazily instantiated by
//DiskEncryptionSettings_SpecARMGenerator()
var diskEncryptionSettings_specARMGenerator gopter.Gen

// DiskEncryptionSettings_SpecARMGenerator returns a generator of DiskEncryptionSettings_SpecARM instances for property testing.
// We first initialize diskEncryptionSettings_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettings_SpecARMGenerator() gopter.Gen {
	if diskEncryptionSettings_specARMGenerator != nil {
		return diskEncryptionSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_SpecARM(generators)
	diskEncryptionSettings_specARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_SpecARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings_SpecARM(generators)
	diskEncryptionSettings_specARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_SpecARM{}), generators)

	return diskEncryptionSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReference_SpecARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReference_SpecARMGenerator())
}

func Test_LinuxPatchSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings_SpecARM, LinuxPatchSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings_SpecARM runs a test to see if a specific instance of LinuxPatchSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings_SpecARM(subject LinuxPatchSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_SpecARM instances for property testing - lazily instantiated by
//LinuxPatchSettings_SpecARMGenerator()
var linuxPatchSettings_specARMGenerator gopter.Gen

// LinuxPatchSettings_SpecARMGenerator returns a generator of LinuxPatchSettings_SpecARM instances for property testing.
func LinuxPatchSettings_SpecARMGenerator() gopter.Gen {
	if linuxPatchSettings_specARMGenerator != nil {
		return linuxPatchSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings_SpecARM(generators)
	linuxPatchSettings_specARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_SpecARM{}), generators)

	return linuxPatchSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_PatchMode_SpecAutomaticByPlatform, LinuxPatchSettings_PatchMode_SpecImageDefault))
}

func Test_ManagedDiskParameters_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters_SpecARM, ManagedDiskParameters_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters_SpecARM runs a test to see if a specific instance of ManagedDiskParameters_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters_SpecARM(subject ManagedDiskParameters_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_SpecARM instances for property testing - lazily instantiated by
//ManagedDiskParameters_SpecARMGenerator()
var managedDiskParameters_specARMGenerator gopter.Gen

// ManagedDiskParameters_SpecARMGenerator returns a generator of ManagedDiskParameters_SpecARM instances for property testing.
// We first initialize managedDiskParameters_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParameters_SpecARMGenerator() gopter.Gen {
	if managedDiskParameters_specARMGenerator != nil {
		return managedDiskParameters_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_SpecARM(generators)
	managedDiskParameters_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_SpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters_SpecARM(generators)
	managedDiskParameters_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_SpecARM{}), generators)

	return managedDiskParameters_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_SpecPremium_LRS,
		StorageAccountType_SpecPremium_ZRS,
		StorageAccountType_SpecStandardSSD_LRS,
		StorageAccountType_SpecStandardSSD_ZRS,
		StorageAccountType_SpecStandard_LRS,
		StorageAccountType_SpecUltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters_SpecARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_SpecARMGenerator())
}

func Test_NetworkInterfaceReferenceProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferenceProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceProperties_SpecARM, NetworkInterfaceReferenceProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceProperties_SpecARM runs a test to see if a specific instance of NetworkInterfaceReferenceProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceProperties_SpecARM(subject NetworkInterfaceReferenceProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferenceProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferenceProperties_SpecARM instances for property testing - lazily instantiated by
//NetworkInterfaceReferenceProperties_SpecARMGenerator()
var networkInterfaceReferenceProperties_specARMGenerator gopter.Gen

// NetworkInterfaceReferenceProperties_SpecARMGenerator returns a generator of NetworkInterfaceReferenceProperties_SpecARM instances for property testing.
func NetworkInterfaceReferenceProperties_SpecARMGenerator() gopter.Gen {
	if networkInterfaceReferenceProperties_specARMGenerator != nil {
		return networkInterfaceReferenceProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_SpecARM(generators)
	networkInterfaceReferenceProperties_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceProperties_SpecARM{}), generators)

	return networkInterfaceReferenceProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings_SpecARM, PatchSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings_SpecARM runs a test to see if a specific instance of PatchSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings_SpecARM(subject PatchSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_SpecARM instances for property testing - lazily instantiated by
//PatchSettings_SpecARMGenerator()
var patchSettings_specARMGenerator gopter.Gen

// PatchSettings_SpecARMGenerator returns a generator of PatchSettings_SpecARM instances for property testing.
func PatchSettings_SpecARMGenerator() gopter.Gen {
	if patchSettings_specARMGenerator != nil {
		return patchSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings_SpecARM(generators)
	patchSettings_specARMGenerator = gen.Struct(reflect.TypeOf(PatchSettings_SpecARM{}), generators)

	return patchSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_PatchMode_SpecAutomaticByOS, PatchSettings_PatchMode_SpecAutomaticByPlatform, PatchSettings_PatchMode_SpecManual))
}

func Test_SshConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration_SpecARM, SshConfiguration_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration_SpecARM runs a test to see if a specific instance of SshConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration_SpecARM(subject SshConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_SpecARM instances for property testing - lazily instantiated by
//SshConfiguration_SpecARMGenerator()
var sshConfiguration_specARMGenerator gopter.Gen

// SshConfiguration_SpecARMGenerator returns a generator of SshConfiguration_SpecARM instances for property testing.
func SshConfiguration_SpecARMGenerator() gopter.Gen {
	if sshConfiguration_specARMGenerator != nil {
		return sshConfiguration_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration_SpecARM(generators)
	sshConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_SpecARM{}), generators)

	return sshConfiguration_specARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKey_SpecARMGenerator())
}

func Test_VaultCertificate_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate_SpecARM, VaultCertificate_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate_SpecARM runs a test to see if a specific instance of VaultCertificate_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate_SpecARM(subject VaultCertificate_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_SpecARM instances for property testing - lazily instantiated by
//VaultCertificate_SpecARMGenerator()
var vaultCertificate_specARMGenerator gopter.Gen

// VaultCertificate_SpecARMGenerator returns a generator of VaultCertificate_SpecARM instances for property testing.
func VaultCertificate_SpecARMGenerator() gopter.Gen {
	if vaultCertificate_specARMGenerator != nil {
		return vaultCertificate_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate_SpecARM(generators)
	vaultCertificate_specARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_SpecARM{}), generators)

	return vaultCertificate_specARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate_SpecARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk_SpecARM, VirtualHardDisk_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk_SpecARM runs a test to see if a specific instance of VirtualHardDisk_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk_SpecARM(subject VirtualHardDisk_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_SpecARM instances for property testing - lazily instantiated by
//VirtualHardDisk_SpecARMGenerator()
var virtualHardDisk_specARMGenerator gopter.Gen

// VirtualHardDisk_SpecARMGenerator returns a generator of VirtualHardDisk_SpecARM instances for property testing.
func VirtualHardDisk_SpecARMGenerator() gopter.Gen {
	if virtualHardDisk_specARMGenerator != nil {
		return virtualHardDisk_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk_SpecARM(generators)
	virtualHardDisk_specARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_SpecARM{}), generators)

	return virtualHardDisk_specARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk_SpecARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration_SpecARM, WinRMConfiguration_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration_SpecARM runs a test to see if a specific instance of WinRMConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration_SpecARM(subject WinRMConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_SpecARM instances for property testing - lazily instantiated by
//WinRMConfiguration_SpecARMGenerator()
var winRMConfiguration_specARMGenerator gopter.Gen

// WinRMConfiguration_SpecARMGenerator returns a generator of WinRMConfiguration_SpecARM instances for property testing.
func WinRMConfiguration_SpecARMGenerator() gopter.Gen {
	if winRMConfiguration_specARMGenerator != nil {
		return winRMConfiguration_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration_SpecARM(generators)
	winRMConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_SpecARM{}), generators)

	return winRMConfiguration_specARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListener_SpecARMGenerator())
}

func Test_KeyVaultKeyReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference_SpecARM, KeyVaultKeyReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference_SpecARM runs a test to see if a specific instance of KeyVaultKeyReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference_SpecARM(subject KeyVaultKeyReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_SpecARM instances for property testing - lazily instantiated by
//KeyVaultKeyReference_SpecARMGenerator()
var keyVaultKeyReference_specARMGenerator gopter.Gen

// KeyVaultKeyReference_SpecARMGenerator returns a generator of KeyVaultKeyReference_SpecARM instances for property testing.
// We first initialize keyVaultKeyReference_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReference_SpecARMGenerator() gopter.Gen {
	if keyVaultKeyReference_specARMGenerator != nil {
		return keyVaultKeyReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_SpecARM(generators)
	keyVaultKeyReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_SpecARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference_SpecARM(generators)
	keyVaultKeyReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_SpecARM{}), generators)

	return keyVaultKeyReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference_SpecARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResource_SpecARMGenerator()
}

func Test_KeyVaultSecretReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference_SpecARM, KeyVaultSecretReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference_SpecARM runs a test to see if a specific instance of KeyVaultSecretReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference_SpecARM(subject KeyVaultSecretReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_SpecARM instances for property testing - lazily instantiated by
//KeyVaultSecretReference_SpecARMGenerator()
var keyVaultSecretReference_specARMGenerator gopter.Gen

// KeyVaultSecretReference_SpecARMGenerator returns a generator of KeyVaultSecretReference_SpecARM instances for property testing.
// We first initialize keyVaultSecretReference_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReference_SpecARMGenerator() gopter.Gen {
	if keyVaultSecretReference_specARMGenerator != nil {
		return keyVaultSecretReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_SpecARM(generators)
	keyVaultSecretReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_SpecARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference_SpecARM(generators)
	keyVaultSecretReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_SpecARM{}), generators)

	return keyVaultSecretReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference_SpecARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference_SpecARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResource_SpecARMGenerator()
}

func Test_SshPublicKey_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKey_SpecARM, SshPublicKey_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKey_SpecARM runs a test to see if a specific instance of SshPublicKey_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKey_SpecARM(subject SshPublicKey_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_SpecARM instances for property testing - lazily instantiated by
//SshPublicKey_SpecARMGenerator()
var sshPublicKey_specARMGenerator gopter.Gen

// SshPublicKey_SpecARMGenerator returns a generator of SshPublicKey_SpecARM instances for property testing.
func SshPublicKey_SpecARMGenerator() gopter.Gen {
	if sshPublicKey_specARMGenerator != nil {
		return sshPublicKey_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKey_SpecARM(generators)
	sshPublicKey_specARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_SpecARM{}), generators)

	return sshPublicKey_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKey_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKey_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener_SpecARM, WinRMListener_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener_SpecARM runs a test to see if a specific instance of WinRMListener_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener_SpecARM(subject WinRMListener_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_SpecARM instances for property testing - lazily instantiated by
//WinRMListener_SpecARMGenerator()
var winRMListener_specARMGenerator gopter.Gen

// WinRMListener_SpecARMGenerator returns a generator of WinRMListener_SpecARM instances for property testing.
func WinRMListener_SpecARMGenerator() gopter.Gen {
	if winRMListener_specARMGenerator != nil {
		return winRMListener_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener_SpecARM(generators)
	winRMListener_specARMGenerator = gen.Struct(reflect.TypeOf(WinRMListener_SpecARM{}), generators)

	return winRMListener_specARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener_SpecARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListener_Protocol_SpecHttp, WinRMListener_Protocol_SpecHttps))
}
