// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachines_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecARM, VirtualMachinesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecARM runs a test to see if a specific instance of VirtualMachines_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecARM(subject VirtualMachines_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_SpecARM instances for property testing - lazily instantiated by
// VirtualMachinesSpecARMGenerator()
var virtualMachinesSpecARMGenerator gopter.Gen

// VirtualMachinesSpecARMGenerator returns a generator of VirtualMachines_SpecARM instances for property testing.
// We first initialize virtualMachinesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecARMGenerator() gopter.Gen {
	if virtualMachinesSpecARMGenerator != nil {
		return virtualMachinesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecARM(generators)
	virtualMachinesSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecARM(generators)
	virtualMachinesSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SpecARM{}), generators)

	return virtualMachinesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentityARMGenerator())
	gens["Plan"] = gen.PtrOf(PlanARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachinesSpecPropertiesARMGenerator())
}

func Test_VirtualMachineIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityARM, VirtualMachineIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityARM runs a test to see if a specific instance of VirtualMachineIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityARM(subject VirtualMachineIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentityARM instances for property testing - lazily instantiated by
// VirtualMachineIdentityARMGenerator()
var virtualMachineIdentityARMGenerator gopter.Gen

// VirtualMachineIdentityARMGenerator returns a generator of VirtualMachineIdentityARM instances for property testing.
func VirtualMachineIdentityARMGenerator() gopter.Gen {
	if virtualMachineIdentityARMGenerator != nil {
		return virtualMachineIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(generators)
	virtualMachineIdentityARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentityARM{}), generators)

	return virtualMachineIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentityType_None,
		VirtualMachineIdentityType_SystemAssigned,
		VirtualMachineIdentityType_SystemAssignedUserAssigned,
		VirtualMachineIdentityType_UserAssigned))
}

func Test_VirtualMachines_Spec_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesARM, VirtualMachinesSpecPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesARM runs a test to see if a specific instance of VirtualMachines_Spec_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesARM(subject VirtualMachines_Spec_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_PropertiesARM instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesARMGenerator()
var virtualMachinesSpecPropertiesARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesARMGenerator returns a generator of VirtualMachines_Spec_PropertiesARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesARMGenerator != nil {
		return virtualMachinesSpecPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(generators)
	virtualMachinesSpecPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(generators)
	virtualMachinesSpecPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_PropertiesARM{}), generators)

	return virtualMachinesSpecPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(VirtualMachinesSpecPropertiesEvictionPolicy_Deallocate, VirtualMachinesSpecPropertiesEvictionPolicy_Delete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(VirtualMachinesSpecPropertiesPriority_Low, VirtualMachinesSpecPropertiesPriority_Regular, VirtualMachinesSpecPropertiesPriority_Spot))
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileARMGenerator())
	gens["Host"] = gen.PtrOf(SubResourceARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(VirtualMachinesSpecPropertiesNetworkProfileARMGenerator())
	gens["OsProfile"] = gen.PtrOf(VirtualMachinesSpecPropertiesOsProfileARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_BillingProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileARM, BillingProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileARM runs a test to see if a specific instance of BillingProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileARM(subject BillingProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfileARM instances for property testing - lazily instantiated by BillingProfileARMGenerator()
var billingProfileARMGenerator gopter.Gen

// BillingProfileARMGenerator returns a generator of BillingProfileARM instances for property testing.
func BillingProfileARMGenerator() gopter.Gen {
	if billingProfileARMGenerator != nil {
		return billingProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileARM(generators)
	billingProfileARMGenerator = gen.Struct(reflect.TypeOf(BillingProfileARM{}), generators)

	return billingProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileARM, DiagnosticsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileARM runs a test to see if a specific instance of DiagnosticsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileARM(subject DiagnosticsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfileARM instances for property testing - lazily instantiated by
// DiagnosticsProfileARMGenerator()
var diagnosticsProfileARMGenerator gopter.Gen

// DiagnosticsProfileARMGenerator returns a generator of DiagnosticsProfileARM instances for property testing.
func DiagnosticsProfileARMGenerator() gopter.Gen {
	if diagnosticsProfileARMGenerator != nil {
		return diagnosticsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileARM(generators)
	diagnosticsProfileARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfileARM{}), generators)

	return diagnosticsProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsARMGenerator())
}

func Test_HardwareProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileARM, HardwareProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileARM runs a test to see if a specific instance of HardwareProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileARM(subject HardwareProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfileARM instances for property testing - lazily instantiated by HardwareProfileARMGenerator()
var hardwareProfileARMGenerator gopter.Gen

// HardwareProfileARMGenerator returns a generator of HardwareProfileARM instances for property testing.
func HardwareProfileARMGenerator() gopter.Gen {
	if hardwareProfileARMGenerator != nil {
		return hardwareProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileARM(generators)
	hardwareProfileARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfileARM{}), generators)

	return hardwareProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfileVmSize_BasicA0,
		HardwareProfileVmSize_BasicA1,
		HardwareProfileVmSize_BasicA2,
		HardwareProfileVmSize_BasicA3,
		HardwareProfileVmSize_BasicA4,
		HardwareProfileVmSize_StandardA0,
		HardwareProfileVmSize_StandardA1,
		HardwareProfileVmSize_StandardA10,
		HardwareProfileVmSize_StandardA11,
		HardwareProfileVmSize_StandardA1V2,
		HardwareProfileVmSize_StandardA2,
		HardwareProfileVmSize_StandardA2MV2,
		HardwareProfileVmSize_StandardA2V2,
		HardwareProfileVmSize_StandardA3,
		HardwareProfileVmSize_StandardA4,
		HardwareProfileVmSize_StandardA4MV2,
		HardwareProfileVmSize_StandardA4V2,
		HardwareProfileVmSize_StandardA5,
		HardwareProfileVmSize_StandardA6,
		HardwareProfileVmSize_StandardA7,
		HardwareProfileVmSize_StandardA8,
		HardwareProfileVmSize_StandardA8MV2,
		HardwareProfileVmSize_StandardA8V2,
		HardwareProfileVmSize_StandardA9,
		HardwareProfileVmSize_StandardB1Ms,
		HardwareProfileVmSize_StandardB1S,
		HardwareProfileVmSize_StandardB2Ms,
		HardwareProfileVmSize_StandardB2S,
		HardwareProfileVmSize_StandardB4Ms,
		HardwareProfileVmSize_StandardB8Ms,
		HardwareProfileVmSize_StandardD1,
		HardwareProfileVmSize_StandardD11,
		HardwareProfileVmSize_StandardD11V2,
		HardwareProfileVmSize_StandardD12,
		HardwareProfileVmSize_StandardD12V2,
		HardwareProfileVmSize_StandardD13,
		HardwareProfileVmSize_StandardD13V2,
		HardwareProfileVmSize_StandardD14,
		HardwareProfileVmSize_StandardD14V2,
		HardwareProfileVmSize_StandardD15V2,
		HardwareProfileVmSize_StandardD16SV3,
		HardwareProfileVmSize_StandardD16V3,
		HardwareProfileVmSize_StandardD1V2,
		HardwareProfileVmSize_StandardD2,
		HardwareProfileVmSize_StandardD2SV3,
		HardwareProfileVmSize_StandardD2V2,
		HardwareProfileVmSize_StandardD2V3,
		HardwareProfileVmSize_StandardD3,
		HardwareProfileVmSize_StandardD32SV3,
		HardwareProfileVmSize_StandardD32V3,
		HardwareProfileVmSize_StandardD3V2,
		HardwareProfileVmSize_StandardD4,
		HardwareProfileVmSize_StandardD4SV3,
		HardwareProfileVmSize_StandardD4V2,
		HardwareProfileVmSize_StandardD4V3,
		HardwareProfileVmSize_StandardD5V2,
		HardwareProfileVmSize_StandardD64SV3,
		HardwareProfileVmSize_StandardD64V3,
		HardwareProfileVmSize_StandardD8SV3,
		HardwareProfileVmSize_StandardD8V3,
		HardwareProfileVmSize_StandardDS1,
		HardwareProfileVmSize_StandardDS11,
		HardwareProfileVmSize_StandardDS11V2,
		HardwareProfileVmSize_StandardDS12,
		HardwareProfileVmSize_StandardDS12V2,
		HardwareProfileVmSize_StandardDS13,
		HardwareProfileVmSize_StandardDS132V2,
		HardwareProfileVmSize_StandardDS134V2,
		HardwareProfileVmSize_StandardDS13V2,
		HardwareProfileVmSize_StandardDS14,
		HardwareProfileVmSize_StandardDS144V2,
		HardwareProfileVmSize_StandardDS148V2,
		HardwareProfileVmSize_StandardDS14V2,
		HardwareProfileVmSize_StandardDS15V2,
		HardwareProfileVmSize_StandardDS1V2,
		HardwareProfileVmSize_StandardDS2,
		HardwareProfileVmSize_StandardDS2V2,
		HardwareProfileVmSize_StandardDS3,
		HardwareProfileVmSize_StandardDS3V2,
		HardwareProfileVmSize_StandardDS4,
		HardwareProfileVmSize_StandardDS4V2,
		HardwareProfileVmSize_StandardDS5V2,
		HardwareProfileVmSize_StandardE16SV3,
		HardwareProfileVmSize_StandardE16V3,
		HardwareProfileVmSize_StandardE2SV3,
		HardwareProfileVmSize_StandardE2V3,
		HardwareProfileVmSize_StandardE3216V3,
		HardwareProfileVmSize_StandardE328SV3,
		HardwareProfileVmSize_StandardE32SV3,
		HardwareProfileVmSize_StandardE32V3,
		HardwareProfileVmSize_StandardE4SV3,
		HardwareProfileVmSize_StandardE4V3,
		HardwareProfileVmSize_StandardE6416SV3,
		HardwareProfileVmSize_StandardE6432SV3,
		HardwareProfileVmSize_StandardE64SV3,
		HardwareProfileVmSize_StandardE64V3,
		HardwareProfileVmSize_StandardE8SV3,
		HardwareProfileVmSize_StandardE8V3,
		HardwareProfileVmSize_StandardF1,
		HardwareProfileVmSize_StandardF16,
		HardwareProfileVmSize_StandardF16S,
		HardwareProfileVmSize_StandardF16SV2,
		HardwareProfileVmSize_StandardF1S,
		HardwareProfileVmSize_StandardF2,
		HardwareProfileVmSize_StandardF2S,
		HardwareProfileVmSize_StandardF2SV2,
		HardwareProfileVmSize_StandardF32SV2,
		HardwareProfileVmSize_StandardF4,
		HardwareProfileVmSize_StandardF4S,
		HardwareProfileVmSize_StandardF4SV2,
		HardwareProfileVmSize_StandardF64SV2,
		HardwareProfileVmSize_StandardF72SV2,
		HardwareProfileVmSize_StandardF8,
		HardwareProfileVmSize_StandardF8S,
		HardwareProfileVmSize_StandardF8SV2,
		HardwareProfileVmSize_StandardG1,
		HardwareProfileVmSize_StandardG2,
		HardwareProfileVmSize_StandardG3,
		HardwareProfileVmSize_StandardG4,
		HardwareProfileVmSize_StandardG5,
		HardwareProfileVmSize_StandardGS1,
		HardwareProfileVmSize_StandardGS2,
		HardwareProfileVmSize_StandardGS3,
		HardwareProfileVmSize_StandardGS4,
		HardwareProfileVmSize_StandardGS44,
		HardwareProfileVmSize_StandardGS48,
		HardwareProfileVmSize_StandardGS5,
		HardwareProfileVmSize_StandardGS516,
		HardwareProfileVmSize_StandardGS58,
		HardwareProfileVmSize_StandardH16,
		HardwareProfileVmSize_StandardH16M,
		HardwareProfileVmSize_StandardH16Mr,
		HardwareProfileVmSize_StandardH16R,
		HardwareProfileVmSize_StandardH8,
		HardwareProfileVmSize_StandardH8M,
		HardwareProfileVmSize_StandardL16S,
		HardwareProfileVmSize_StandardL32S,
		HardwareProfileVmSize_StandardL4S,
		HardwareProfileVmSize_StandardL8S,
		HardwareProfileVmSize_StandardM12832Ms,
		HardwareProfileVmSize_StandardM12864Ms,
		HardwareProfileVmSize_StandardM128Ms,
		HardwareProfileVmSize_StandardM128S,
		HardwareProfileVmSize_StandardM6416Ms,
		HardwareProfileVmSize_StandardM6432Ms,
		HardwareProfileVmSize_StandardM64Ms,
		HardwareProfileVmSize_StandardM64S,
		HardwareProfileVmSize_StandardNC12,
		HardwareProfileVmSize_StandardNC12SV2,
		HardwareProfileVmSize_StandardNC12SV3,
		HardwareProfileVmSize_StandardNC24,
		HardwareProfileVmSize_StandardNC24R,
		HardwareProfileVmSize_StandardNC24RsV2,
		HardwareProfileVmSize_StandardNC24RsV3,
		HardwareProfileVmSize_StandardNC24SV2,
		HardwareProfileVmSize_StandardNC24SV3,
		HardwareProfileVmSize_StandardNC6,
		HardwareProfileVmSize_StandardNC6SV2,
		HardwareProfileVmSize_StandardNC6SV3,
		HardwareProfileVmSize_StandardND12S,
		HardwareProfileVmSize_StandardND24Rs,
		HardwareProfileVmSize_StandardND24S,
		HardwareProfileVmSize_StandardND6S,
		HardwareProfileVmSize_StandardNV12,
		HardwareProfileVmSize_StandardNV24,
		HardwareProfileVmSize_StandardNV6))
}

func Test_SecurityProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileARM, SecurityProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileARM runs a test to see if a specific instance of SecurityProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileARM(subject SecurityProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfileARM instances for property testing - lazily instantiated by SecurityProfileARMGenerator()
var securityProfileARMGenerator gopter.Gen

// SecurityProfileARMGenerator returns a generator of SecurityProfileARM instances for property testing.
// We first initialize securityProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileARMGenerator() gopter.Gen {
	if securityProfileARMGenerator != nil {
		return securityProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileARM(generators)
	securityProfileARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileARM(generators)
	securityProfileARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfileARM{}), generators)

	return securityProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfileSecurityType_TrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsARMGenerator())
}

func Test_StorageProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileARM, StorageProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileARM runs a test to see if a specific instance of StorageProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileARM(subject StorageProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfileARM instances for property testing - lazily instantiated by StorageProfileARMGenerator()
var storageProfileARMGenerator gopter.Gen

// StorageProfileARMGenerator returns a generator of StorageProfileARM instances for property testing.
func StorageProfileARMGenerator() gopter.Gen {
	if storageProfileARMGenerator != nil {
		return storageProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileARM(generators)
	storageProfileARMGenerator = gen.Struct(reflect.TypeOf(StorageProfileARM{}), generators)

	return storageProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskARMGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileARM, VirtualMachinesSpecPropertiesNetworkProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileARM(subject VirtualMachines_Spec_Properties_NetworkProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfileARM instances for property testing - lazily instantiated
// by VirtualMachinesSpecPropertiesNetworkProfileARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfileARM instances for property testing.
func VirtualMachinesSpecPropertiesNetworkProfileARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfileARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator())
}

func Test_VirtualMachines_Spec_Properties_OsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_OsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfileARM, VirtualMachinesSpecPropertiesOsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfileARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_OsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfileARM(subject VirtualMachines_Spec_Properties_OsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_OsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_OsProfileARM instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesOsProfileARMGenerator()
var virtualMachinesSpecPropertiesOsProfileARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesOsProfileARMGenerator returns a generator of VirtualMachines_Spec_Properties_OsProfileARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesOsProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesOsProfileARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesOsProfileARMGenerator != nil {
		return virtualMachinesSpecPropertiesOsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(generators)
	virtualMachinesSpecPropertiesOsProfileARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_OsProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(generators)
	virtualMachinesSpecPropertiesOsProfileARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_OsProfileARM{}), generators)

	return virtualMachinesSpecPropertiesOsProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationARMGenerator())
}

func Test_BootDiagnosticsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsARM, BootDiagnosticsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsARM runs a test to see if a specific instance of BootDiagnosticsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsARM(subject BootDiagnosticsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsARM instances for property testing - lazily instantiated by BootDiagnosticsARMGenerator()
var bootDiagnosticsARMGenerator gopter.Gen

// BootDiagnosticsARMGenerator returns a generator of BootDiagnosticsARM instances for property testing.
func BootDiagnosticsARMGenerator() gopter.Gen {
	if bootDiagnosticsARMGenerator != nil {
		return bootDiagnosticsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsARM(generators)
	bootDiagnosticsARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsARM{}), generators)

	return bootDiagnosticsARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskARM, DataDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskARM runs a test to see if a specific instance of DataDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskARM(subject DataDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDiskARM instances for property testing - lazily instantiated by DataDiskARMGenerator()
var dataDiskARMGenerator gopter.Gen

// DataDiskARMGenerator returns a generator of DataDiskARM instances for property testing.
// We first initialize dataDiskARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskARMGenerator() gopter.Gen {
	if dataDiskARMGenerator != nil {
		return dataDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskARM(generators)
	dataDiskARMGenerator = gen.Struct(reflect.TypeOf(DataDiskARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskARM(generators)
	AddRelatedPropertyGeneratorsForDataDiskARM(generators)
	dataDiskARMGenerator = gen.Struct(reflect.TypeOf(DataDiskARM{}), generators)

	return dataDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(DataDiskCaching_None, DataDiskCaching_ReadOnly, DataDiskCaching_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(DataDiskCreateOption_Attach, DataDiskCreateOption_Empty, DataDiskCreateOption_FromImage))
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DataDiskDetachOption_ForceDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskARMGenerator())
}

func Test_ImageReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceARM, ImageReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceARM runs a test to see if a specific instance of ImageReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceARM(subject ImageReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReferenceARM instances for property testing - lazily instantiated by ImageReferenceARMGenerator()
var imageReferenceARMGenerator gopter.Gen

// ImageReferenceARMGenerator returns a generator of ImageReferenceARM instances for property testing.
func ImageReferenceARMGenerator() gopter.Gen {
	if imageReferenceARMGenerator != nil {
		return imageReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceARM(generators)
	imageReferenceARMGenerator = gen.Struct(reflect.TypeOf(ImageReferenceARM{}), generators)

	return imageReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationARM, LinuxConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationARM runs a test to see if a specific instance of LinuxConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationARM(subject LinuxConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfigurationARM instances for property testing - lazily instantiated by
// LinuxConfigurationARMGenerator()
var linuxConfigurationARMGenerator gopter.Gen

// LinuxConfigurationARMGenerator returns a generator of LinuxConfigurationARM instances for property testing.
// We first initialize linuxConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationARMGenerator() gopter.Gen {
	if linuxConfigurationARMGenerator != nil {
		return linuxConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationARM(generators)
	linuxConfigurationARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationARM(generators)
	linuxConfigurationARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfigurationARM{}), generators)

	return linuxConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationARMGenerator())
}

func Test_OSDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskARM, OSDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskARM runs a test to see if a specific instance of OSDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskARM(subject OSDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDiskARM instances for property testing - lazily instantiated by OSDiskARMGenerator()
var osDiskARMGenerator gopter.Gen

// OSDiskARMGenerator returns a generator of OSDiskARM instances for property testing.
// We first initialize osDiskARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskARMGenerator() gopter.Gen {
	if osDiskARMGenerator != nil {
		return osDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskARM(generators)
	osDiskARMGenerator = gen.Struct(reflect.TypeOf(OSDiskARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskARM(generators)
	AddRelatedPropertyGeneratorsForOSDiskARM(generators)
	osDiskARMGenerator = gen.Struct(reflect.TypeOf(OSDiskARM{}), generators)

	return osDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(OSDiskCaching_None, OSDiskCaching_ReadOnly, OSDiskCaching_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(OSDiskCreateOption_Attach, OSDiskCreateOption_Empty, OSDiskCreateOption_FromImage))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDiskOsType_Linux, OSDiskOsType_Windows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskARMGenerator())
}

func Test_UefiSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsARM, UefiSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsARM runs a test to see if a specific instance of UefiSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsARM(subject UefiSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettingsARM instances for property testing - lazily instantiated by UefiSettingsARMGenerator()
var uefiSettingsARMGenerator gopter.Gen

// UefiSettingsARMGenerator returns a generator of UefiSettingsARM instances for property testing.
func UefiSettingsARMGenerator() gopter.Gen {
	if uefiSettingsARMGenerator != nil {
		return uefiSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsARM(generators)
	uefiSettingsARMGenerator = gen.Struct(reflect.TypeOf(UefiSettingsARM{}), generators)

	return uefiSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroupARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroupARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupARM, VaultSecretGroupARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupARM runs a test to see if a specific instance of VaultSecretGroupARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupARM(subject VaultSecretGroupARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroupARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroupARM instances for property testing - lazily instantiated by
// VaultSecretGroupARMGenerator()
var vaultSecretGroupARMGenerator gopter.Gen

// VaultSecretGroupARMGenerator returns a generator of VaultSecretGroupARM instances for property testing.
func VaultSecretGroupARMGenerator() gopter.Gen {
	if vaultSecretGroupARMGenerator != nil {
		return vaultSecretGroupARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupARM(generators)
	vaultSecretGroupARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroupARM{}), generators)

	return vaultSecretGroupARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateARMGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM instances for property testing -
// lazily instantiated by VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferencePropertiesARMGenerator())
}

func Test_WindowsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationARM, WindowsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationARM runs a test to see if a specific instance of WindowsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationARM(subject WindowsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfigurationARM instances for property testing - lazily instantiated by
// WindowsConfigurationARMGenerator()
var windowsConfigurationARMGenerator gopter.Gen

// WindowsConfigurationARMGenerator returns a generator of WindowsConfigurationARM instances for property testing.
// We first initialize windowsConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationARMGenerator() gopter.Gen {
	if windowsConfigurationARMGenerator != nil {
		return windowsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationARM(generators)
	windowsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationARM(generators)
	windowsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfigurationARM{}), generators)

	return windowsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationARMGenerator())
}

func Test_AdditionalUnattendContentARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContentARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentARM, AdditionalUnattendContentARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentARM runs a test to see if a specific instance of AdditionalUnattendContentARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentARM(subject AdditionalUnattendContentARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContentARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContentARM instances for property testing - lazily instantiated by
// AdditionalUnattendContentARMGenerator()
var additionalUnattendContentARMGenerator gopter.Gen

// AdditionalUnattendContentARMGenerator returns a generator of AdditionalUnattendContentARM instances for property testing.
func AdditionalUnattendContentARMGenerator() gopter.Gen {
	if additionalUnattendContentARMGenerator != nil {
		return additionalUnattendContentARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM(generators)
	additionalUnattendContentARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContentARM{}), generators)

	return additionalUnattendContentARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentComponentName_MicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentPassName_OobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSettingName_AutoLogon, AdditionalUnattendContentSettingName_FirstLogonCommands))
}

func Test_DiffDiskSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsARM, DiffDiskSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsARM runs a test to see if a specific instance of DiffDiskSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsARM(subject DiffDiskSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettingsARM instances for property testing - lazily instantiated by
// DiffDiskSettingsARMGenerator()
var diffDiskSettingsARMGenerator gopter.Gen

// DiffDiskSettingsARMGenerator returns a generator of DiffDiskSettingsARM instances for property testing.
func DiffDiskSettingsARMGenerator() gopter.Gen {
	if diffDiskSettingsARMGenerator != nil {
		return diffDiskSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsARM(generators)
	diffDiskSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettingsARM{}), generators)

	return diffDiskSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskSettingsOption_Local))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskSettingsPlacement_CacheDisk, DiffDiskSettingsPlacement_ResourceDisk))
}

func Test_DiskEncryptionSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsARM, DiskEncryptionSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsARM runs a test to see if a specific instance of DiskEncryptionSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsARM(subject DiskEncryptionSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettingsARM instances for property testing - lazily instantiated by
// DiskEncryptionSettingsARMGenerator()
var diskEncryptionSettingsARMGenerator gopter.Gen

// DiskEncryptionSettingsARMGenerator returns a generator of DiskEncryptionSettingsARM instances for property testing.
// We first initialize diskEncryptionSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsARMGenerator() gopter.Gen {
	if diskEncryptionSettingsARMGenerator != nil {
		return diskEncryptionSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	diskEncryptionSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	diskEncryptionSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettingsARM{}), generators)

	return diskEncryptionSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceARMGenerator())
}

func Test_LinuxPatchSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsARM, LinuxPatchSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsARM runs a test to see if a specific instance of LinuxPatchSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsARM(subject LinuxPatchSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettingsARM instances for property testing - lazily instantiated by
// LinuxPatchSettingsARMGenerator()
var linuxPatchSettingsARMGenerator gopter.Gen

// LinuxPatchSettingsARMGenerator returns a generator of LinuxPatchSettingsARM instances for property testing.
func LinuxPatchSettingsARMGenerator() gopter.Gen {
	if linuxPatchSettingsARMGenerator != nil {
		return linuxPatchSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(generators)
	linuxPatchSettingsARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettingsARM{}), generators)

	return linuxPatchSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettingsPatchMode_AutomaticByPlatform, LinuxPatchSettingsPatchMode_ImageDefault))
}

func Test_ManagedDiskParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersARM, ManagedDiskParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersARM runs a test to see if a specific instance of ManagedDiskParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersARM(subject ManagedDiskParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParametersARM instances for property testing - lazily instantiated by
// ManagedDiskParametersARMGenerator()
var managedDiskParametersARMGenerator gopter.Gen

// ManagedDiskParametersARMGenerator returns a generator of ManagedDiskParametersARM instances for property testing.
// We first initialize managedDiskParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersARMGenerator() gopter.Gen {
	if managedDiskParametersARMGenerator != nil {
		return managedDiskParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersARM(generators)
	managedDiskParametersARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersARM(generators)
	managedDiskParametersARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParametersARM{}), generators)

	return managedDiskParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		ManagedDiskParametersStorageAccountType_PremiumLRS,
		ManagedDiskParametersStorageAccountType_PremiumZRS,
		ManagedDiskParametersStorageAccountType_StandardLRS,
		ManagedDiskParametersStorageAccountType_StandardSSDLRS,
		ManagedDiskParametersStorageAccountType_StandardSSDZRS,
		ManagedDiskParametersStorageAccountType_UltraSSDLRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(DiskEncryptionSetParametersARMGenerator())
}

func Test_NetworkInterfaceReferencePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferencePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM, NetworkInterfaceReferencePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM runs a test to see if a specific instance of NetworkInterfaceReferencePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM(subject NetworkInterfaceReferencePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferencePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferencePropertiesARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferencePropertiesARMGenerator()
var networkInterfaceReferencePropertiesARMGenerator gopter.Gen

// NetworkInterfaceReferencePropertiesARMGenerator returns a generator of NetworkInterfaceReferencePropertiesARM instances for property testing.
func NetworkInterfaceReferencePropertiesARMGenerator() gopter.Gen {
	if networkInterfaceReferencePropertiesARMGenerator != nil {
		return networkInterfaceReferencePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM(generators)
	networkInterfaceReferencePropertiesARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferencePropertiesARM{}), generators)

	return networkInterfaceReferencePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsARM, PatchSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsARM runs a test to see if a specific instance of PatchSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsARM(subject PatchSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettingsARM instances for property testing - lazily instantiated by PatchSettingsARMGenerator()
var patchSettingsARMGenerator gopter.Gen

// PatchSettingsARMGenerator returns a generator of PatchSettingsARM instances for property testing.
func PatchSettingsARMGenerator() gopter.Gen {
	if patchSettingsARMGenerator != nil {
		return patchSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsARM(generators)
	patchSettingsARMGenerator = gen.Struct(reflect.TypeOf(PatchSettingsARM{}), generators)

	return patchSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettingsPatchMode_AutomaticByOS, PatchSettingsPatchMode_AutomaticByPlatform, PatchSettingsPatchMode_Manual))
}

func Test_SshConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationARM, SshConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationARM runs a test to see if a specific instance of SshConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationARM(subject SshConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfigurationARM instances for property testing - lazily instantiated by
// SshConfigurationARMGenerator()
var sshConfigurationARMGenerator gopter.Gen

// SshConfigurationARMGenerator returns a generator of SshConfigurationARM instances for property testing.
func SshConfigurationARMGenerator() gopter.Gen {
	if sshConfigurationARMGenerator != nil {
		return sshConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationARM(generators)
	sshConfigurationARMGenerator = gen.Struct(reflect.TypeOf(SshConfigurationARM{}), generators)

	return sshConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeyARMGenerator())
}

func Test_VaultCertificateARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificateARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateARM, VaultCertificateARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateARM runs a test to see if a specific instance of VaultCertificateARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateARM(subject VaultCertificateARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificateARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificateARM instances for property testing - lazily instantiated by
// VaultCertificateARMGenerator()
var vaultCertificateARMGenerator gopter.Gen

// VaultCertificateARMGenerator returns a generator of VaultCertificateARM instances for property testing.
func VaultCertificateARMGenerator() gopter.Gen {
	if vaultCertificateARMGenerator != nil {
		return vaultCertificateARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateARM(generators)
	vaultCertificateARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificateARM{}), generators)

	return vaultCertificateARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskARM, VirtualHardDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskARM runs a test to see if a specific instance of VirtualHardDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskARM(subject VirtualHardDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDiskARM instances for property testing - lazily instantiated by VirtualHardDiskARMGenerator()
var virtualHardDiskARMGenerator gopter.Gen

// VirtualHardDiskARMGenerator returns a generator of VirtualHardDiskARM instances for property testing.
func VirtualHardDiskARMGenerator() gopter.Gen {
	if virtualHardDiskARMGenerator != nil {
		return virtualHardDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskARM(generators)
	virtualHardDiskARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDiskARM{}), generators)

	return virtualHardDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationARM, WinRMConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationARM runs a test to see if a specific instance of WinRMConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationARM(subject WinRMConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfigurationARM instances for property testing - lazily instantiated by
// WinRMConfigurationARMGenerator()
var winRMConfigurationARMGenerator gopter.Gen

// WinRMConfigurationARMGenerator returns a generator of WinRMConfigurationARM instances for property testing.
func WinRMConfigurationARMGenerator() gopter.Gen {
	if winRMConfigurationARMGenerator != nil {
		return winRMConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationARM(generators)
	winRMConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfigurationARM{}), generators)

	return winRMConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerARMGenerator())
}

func Test_DiskEncryptionSetParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSetParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSetParametersARM, DiskEncryptionSetParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSetParametersARM runs a test to see if a specific instance of DiskEncryptionSetParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSetParametersARM(subject DiskEncryptionSetParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSetParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSetParametersARM instances for property testing - lazily instantiated by
// DiskEncryptionSetParametersARMGenerator()
var diskEncryptionSetParametersARMGenerator gopter.Gen

// DiskEncryptionSetParametersARMGenerator returns a generator of DiskEncryptionSetParametersARM instances for property testing.
func DiskEncryptionSetParametersARMGenerator() gopter.Gen {
	if diskEncryptionSetParametersARMGenerator != nil {
		return diskEncryptionSetParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSetParametersARM(generators)
	diskEncryptionSetParametersARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSetParametersARM{}), generators)

	return diskEncryptionSetParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSetParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSetParametersARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultKeyReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceARM, KeyVaultKeyReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceARM runs a test to see if a specific instance of KeyVaultKeyReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceARM(subject KeyVaultKeyReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReferenceARM instances for property testing - lazily instantiated by
// KeyVaultKeyReferenceARMGenerator()
var keyVaultKeyReferenceARMGenerator gopter.Gen

// KeyVaultKeyReferenceARMGenerator returns a generator of KeyVaultKeyReferenceARM instances for property testing.
// We first initialize keyVaultKeyReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceARMGenerator() gopter.Gen {
	if keyVaultKeyReferenceARMGenerator != nil {
		return keyVaultKeyReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	keyVaultKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	keyVaultKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReferenceARM{}), generators)

	return keyVaultKeyReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_KeyVaultSecretReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceARM, KeyVaultSecretReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceARM runs a test to see if a specific instance of KeyVaultSecretReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceARM(subject KeyVaultSecretReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReferenceARM instances for property testing - lazily instantiated by
// KeyVaultSecretReferenceARMGenerator()
var keyVaultSecretReferenceARMGenerator gopter.Gen

// KeyVaultSecretReferenceARMGenerator returns a generator of KeyVaultSecretReferenceARM instances for property testing.
// We first initialize keyVaultSecretReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceARMGenerator() gopter.Gen {
	if keyVaultSecretReferenceARMGenerator != nil {
		return keyVaultSecretReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	keyVaultSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	keyVaultSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReferenceARM{}), generators)

	return keyVaultSecretReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_SshPublicKeyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKeyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeyARM, SshPublicKeyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeyARM runs a test to see if a specific instance of SshPublicKeyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeyARM(subject SshPublicKeyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKeyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKeyARM instances for property testing - lazily instantiated by SshPublicKeyARMGenerator()
var sshPublicKeyARMGenerator gopter.Gen

// SshPublicKeyARMGenerator returns a generator of SshPublicKeyARM instances for property testing.
func SshPublicKeyARMGenerator() gopter.Gen {
	if sshPublicKeyARMGenerator != nil {
		return sshPublicKeyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeyARM(generators)
	sshPublicKeyARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKeyARM{}), generators)

	return sshPublicKeyARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeyARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListenerARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListenerARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerARM, WinRMListenerARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerARM runs a test to see if a specific instance of WinRMListenerARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerARM(subject WinRMListenerARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListenerARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListenerARM instances for property testing - lazily instantiated by WinRMListenerARMGenerator()
var winRMListenerARMGenerator gopter.Gen

// WinRMListenerARMGenerator returns a generator of WinRMListenerARM instances for property testing.
func WinRMListenerARMGenerator() gopter.Gen {
	if winRMListenerARMGenerator != nil {
		return winRMListenerARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerARM(generators)
	winRMListenerARMGenerator = gen.Struct(reflect.TypeOf(WinRMListenerARM{}), generators)

	return winRMListenerARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListenerProtocol_Http, WinRMListenerProtocol_Https))
}
