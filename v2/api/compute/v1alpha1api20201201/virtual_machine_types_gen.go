// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"fmt"
	alpha20201201s "github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Deprecated version of VirtualMachine. Use v1beta20201201.VirtualMachine instead
type VirtualMachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachines_Spec  `json:"spec,omitempty"`
	Status            VirtualMachine_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachine{}

// GetConditions returns the conditions of the resource
func (machine *VirtualMachine) GetConditions() conditions.Conditions {
	return machine.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (machine *VirtualMachine) SetConditions(conditions conditions.Conditions) {
	machine.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachine{}

// ConvertFrom populates our VirtualMachine from the provided hub VirtualMachine
func (machine *VirtualMachine) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source alpha20201201s.VirtualMachine

	err := source.ConvertFrom(hub)
	if err != nil {
		return errors.Wrap(err, "converting from hub to source")
	}

	err = machine.AssignPropertiesFromVirtualMachine(&source)
	if err != nil {
		return errors.Wrap(err, "converting from source to machine")
	}

	return nil
}

// ConvertTo populates the provided hub VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination alpha20201201s.VirtualMachine
	err := machine.AssignPropertiesToVirtualMachine(&destination)
	if err != nil {
		return errors.Wrap(err, "converting to destination from machine")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return errors.Wrap(err, "converting from destination to hub")
	}

	return nil
}

// +kubebuilder:webhook:path=/mutate-compute-azure-com-v1alpha1api20201201-virtualmachine,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachines,verbs=create;update,versions=v1alpha1api20201201,name=default.v1alpha1api20201201.virtualmachines.compute.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &VirtualMachine{}

// Default applies defaults to the VirtualMachine resource
func (machine *VirtualMachine) Default() {
	machine.defaultImpl()
	var temp interface{} = machine
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (machine *VirtualMachine) defaultAzureName() {
	if machine.Spec.AzureName == "" {
		machine.Spec.AzureName = machine.Name
	}
}

// defaultImpl applies the code generated defaults to the VirtualMachine resource
func (machine *VirtualMachine) defaultImpl() { machine.defaultAzureName() }

var _ genruntime.KubernetesResource = &VirtualMachine{}

// AzureName returns the Azure name of the resource
func (machine *VirtualMachine) AzureName() string {
	return machine.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-12-01"
func (machine VirtualMachine) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (machine *VirtualMachine) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (machine *VirtualMachine) GetSpec() genruntime.ConvertibleSpec {
	return &machine.Spec
}

// GetStatus returns the status of this resource
func (machine *VirtualMachine) GetStatus() genruntime.ConvertibleStatus {
	return &machine.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachines"
func (machine *VirtualMachine) GetType() string {
	return "Microsoft.Compute/virtualMachines"
}

// NewEmptyStatus returns a new empty (blank) status
func (machine *VirtualMachine) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachine_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (machine *VirtualMachine) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(machine.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  machine.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (machine *VirtualMachine) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachine_STATUS); ok {
		machine.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachine_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	machine.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-compute-azure-com-v1alpha1api20201201-virtualmachine,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachines,verbs=create;update,versions=v1alpha1api20201201,name=validate.v1alpha1api20201201.virtualmachines.compute.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &VirtualMachine{}

// ValidateCreate validates the creation of the resource
func (machine *VirtualMachine) ValidateCreate() error {
	validations := machine.createValidations()
	var temp interface{} = machine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (machine *VirtualMachine) ValidateDelete() error {
	validations := machine.deleteValidations()
	var temp interface{} = machine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (machine *VirtualMachine) ValidateUpdate(old runtime.Object) error {
	validations := machine.updateValidations()
	var temp interface{} = machine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (machine *VirtualMachine) createValidations() []func() error {
	return []func() error{machine.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (machine *VirtualMachine) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (machine *VirtualMachine) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return machine.validateResourceReferences()
		},
		machine.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (machine *VirtualMachine) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&machine.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (machine *VirtualMachine) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*VirtualMachine)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, machine)
}

// AssignPropertiesFromVirtualMachine populates our VirtualMachine from the provided source VirtualMachine
func (machine *VirtualMachine) AssignPropertiesFromVirtualMachine(source *alpha20201201s.VirtualMachine) error {

	// ObjectMeta
	machine.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachines_Spec
	err := spec.AssignPropertiesFromVirtualMachinesSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinesSpec() to populate field Spec")
	}
	machine.Spec = spec

	// Status
	var status VirtualMachine_STATUS
	err = status.AssignPropertiesFromVirtualMachineSTATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineSTATUS() to populate field Status")
	}
	machine.Status = status

	// No error
	return nil
}

// AssignPropertiesToVirtualMachine populates the provided destination VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) AssignPropertiesToVirtualMachine(destination *alpha20201201s.VirtualMachine) error {

	// ObjectMeta
	destination.ObjectMeta = *machine.ObjectMeta.DeepCopy()

	// Spec
	var spec alpha20201201s.VirtualMachines_Spec
	err := machine.Spec.AssignPropertiesToVirtualMachinesSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinesSpec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status alpha20201201s.VirtualMachine_STATUS
	err = machine.Status.AssignPropertiesToVirtualMachineSTATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineSTATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (machine *VirtualMachine) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: machine.Spec.OriginalVersion(),
		Kind:    "VirtualMachine",
	}
}

// +kubebuilder:object:root=true
// Deprecated version of VirtualMachine. Use v1beta20201201.VirtualMachine instead
type VirtualMachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachine `json:"items"`
}

// Deprecated version of APIVersion. Use v1beta20201201.APIVersion instead
// +kubebuilder:validation:Enum={"2020-12-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2020-12-01")

// Deprecated version of VirtualMachine_STATUS. Use v1beta20201201.VirtualMachine_STATUS instead
type VirtualMachine_STATUS struct {
	AdditionalCapabilities *AdditionalCapabilities_STATUS `json:"additionalCapabilities,omitempty"`
	AvailabilitySet        *SubResource_STATUS            `json:"availabilitySet,omitempty"`
	BillingProfile         *BillingProfile_STATUS         `json:"billingProfile,omitempty"`

	// Conditions: The observed state of the resource
	Conditions              []conditions.Condition             `json:"conditions,omitempty"`
	DiagnosticsProfile      *DiagnosticsProfile_STATUS         `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy          *EvictionPolicy_STATUS             `json:"evictionPolicy,omitempty"`
	ExtendedLocation        *ExtendedLocation_STATUS           `json:"extendedLocation,omitempty"`
	ExtensionsTimeBudget    *string                            `json:"extensionsTimeBudget,omitempty"`
	HardwareProfile         *HardwareProfile_STATUS            `json:"hardwareProfile,omitempty"`
	Host                    *SubResource_STATUS                `json:"host,omitempty"`
	HostGroup               *SubResource_STATUS                `json:"hostGroup,omitempty"`
	Id                      *string                            `json:"id,omitempty"`
	Identity                *VirtualMachineIdentity_STATUS     `json:"identity,omitempty"`
	InstanceView            *VirtualMachineInstanceView_STATUS `json:"instanceView,omitempty"`
	LicenseType             *string                            `json:"licenseType,omitempty"`
	Location                *string                            `json:"location,omitempty"`
	Name                    *string                            `json:"name,omitempty"`
	NetworkProfile          *NetworkProfile_STATUS             `json:"networkProfile,omitempty"`
	OsProfile               *OSProfile_STATUS                  `json:"osProfile,omitempty"`
	Plan                    *Plan_STATUS                       `json:"plan,omitempty"`
	PlatformFaultDomain     *int                               `json:"platformFaultDomain,omitempty"`
	Priority                *Priority_STATUS                   `json:"priority,omitempty"`
	ProvisioningState       *string                            `json:"provisioningState,omitempty"`
	ProximityPlacementGroup *SubResource_STATUS                `json:"proximityPlacementGroup,omitempty"`
	Resources               []VirtualMachineExtension_STATUS   `json:"resources,omitempty"`
	SecurityProfile         *SecurityProfile_STATUS            `json:"securityProfile,omitempty"`
	StorageProfile          *StorageProfile_STATUS             `json:"storageProfile,omitempty"`
	Tags                    map[string]string                  `json:"tags,omitempty"`
	Type                    *string                            `json:"type,omitempty"`
	VirtualMachineScaleSet  *SubResource_STATUS                `json:"virtualMachineScaleSet,omitempty"`
	VmId                    *string                            `json:"vmId,omitempty"`
	Zones                   []string                           `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachine_STATUS{}

// ConvertStatusFrom populates our VirtualMachine_STATUS from the provided source
func (machine *VirtualMachine_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*alpha20201201s.VirtualMachine_STATUS)
	if ok {
		// Populate our instance from source
		return machine.AssignPropertiesFromVirtualMachineSTATUS(src)
	}

	// Convert to an intermediate form
	src = &alpha20201201s.VirtualMachine_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = machine.AssignPropertiesFromVirtualMachineSTATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*alpha20201201s.VirtualMachine_STATUS)
	if ok {
		// Populate destination from our instance
		return machine.AssignPropertiesToVirtualMachineSTATUS(dst)
	}

	// Convert to an intermediate form
	dst = &alpha20201201s.VirtualMachine_STATUS{}
	err := machine.AssignPropertiesToVirtualMachineSTATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VirtualMachine_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machine *VirtualMachine_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachine_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machine *VirtualMachine_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachine_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachine_STATUSARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities_STATUS
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			machine.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property ‘AvailabilitySet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AvailabilitySet != nil {
			var availabilitySet1 SubResource_STATUS
			err := availabilitySet1.PopulateFromARM(owner, *typedInput.Properties.AvailabilitySet)
			if err != nil {
				return err
			}
			availabilitySet := availabilitySet1
			machine.AvailabilitySet = &availabilitySet
		}
	}

	// Set property ‘BillingProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BillingProfile != nil {
			var billingProfile1 BillingProfile_STATUS
			err := billingProfile1.PopulateFromARM(owner, *typedInput.Properties.BillingProfile)
			if err != nil {
				return err
			}
			billingProfile := billingProfile1
			machine.BillingProfile = &billingProfile
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DiagnosticsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiagnosticsProfile != nil {
			var diagnosticsProfile1 DiagnosticsProfile_STATUS
			err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.Properties.DiagnosticsProfile)
			if err != nil {
				return err
			}
			diagnosticsProfile := diagnosticsProfile1
			machine.DiagnosticsProfile = &diagnosticsProfile
		}
	}

	// Set property ‘EvictionPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EvictionPolicy != nil {
			evictionPolicy := *typedInput.Properties.EvictionPolicy
			machine.EvictionPolicy = &evictionPolicy
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		machine.ExtendedLocation = &extendedLocation
	}

	// Set property ‘ExtensionsTimeBudget’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExtensionsTimeBudget != nil {
			extensionsTimeBudget := *typedInput.Properties.ExtensionsTimeBudget
			machine.ExtensionsTimeBudget = &extensionsTimeBudget
		}
	}

	// Set property ‘HardwareProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HardwareProfile != nil {
			var hardwareProfile1 HardwareProfile_STATUS
			err := hardwareProfile1.PopulateFromARM(owner, *typedInput.Properties.HardwareProfile)
			if err != nil {
				return err
			}
			hardwareProfile := hardwareProfile1
			machine.HardwareProfile = &hardwareProfile
		}
	}

	// Set property ‘Host’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Host != nil {
			var host1 SubResource_STATUS
			err := host1.PopulateFromARM(owner, *typedInput.Properties.Host)
			if err != nil {
				return err
			}
			host := host1
			machine.Host = &host
		}
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource_STATUS
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			machine.HostGroup = &hostGroup
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		machine.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		machine.Identity = &identity
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 VirtualMachineInstanceView_STATUS
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			machine.InstanceView = &instanceView
		}
	}

	// Set property ‘LicenseType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			machine.LicenseType = &licenseType
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		machine.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		machine.Name = &name
	}

	// Set property ‘NetworkProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 NetworkProfile_STATUS
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			machine.NetworkProfile = &networkProfile
		}
	}

	// Set property ‘OsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsProfile != nil {
			var osProfile1 OSProfile_STATUS
			err := osProfile1.PopulateFromARM(owner, *typedInput.Properties.OsProfile)
			if err != nil {
				return err
			}
			osProfile := osProfile1
			machine.OsProfile = &osProfile
		}
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan_STATUS
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		machine.Plan = &plan
	}

	// Set property ‘PlatformFaultDomain’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomain != nil {
			platformFaultDomain := *typedInput.Properties.PlatformFaultDomain
			machine.PlatformFaultDomain = &platformFaultDomain
		}
	}

	// Set property ‘Priority’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			machine.Priority = &priority
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			machine.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource_STATUS
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			machine.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property ‘Resources’:
	for _, item := range typedInput.Resources {
		var item1 VirtualMachineExtension_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		machine.Resources = append(machine.Resources, item1)
	}

	// Set property ‘SecurityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecurityProfile != nil {
			var securityProfile1 SecurityProfile_STATUS
			err := securityProfile1.PopulateFromARM(owner, *typedInput.Properties.SecurityProfile)
			if err != nil {
				return err
			}
			securityProfile := securityProfile1
			machine.SecurityProfile = &securityProfile
		}
	}

	// Set property ‘StorageProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 StorageProfile_STATUS
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			machine.StorageProfile = &storageProfile
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		machine.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			machine.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		machine.Type = &typeVar
	}

	// Set property ‘VirtualMachineScaleSet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineScaleSet != nil {
			var virtualMachineScaleSet1 SubResource_STATUS
			err := virtualMachineScaleSet1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineScaleSet)
			if err != nil {
				return err
			}
			virtualMachineScaleSet := virtualMachineScaleSet1
			machine.VirtualMachineScaleSet = &virtualMachineScaleSet
		}
	}

	// Set property ‘VmId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VmId != nil {
			vmId := *typedInput.Properties.VmId
			machine.VmId = &vmId
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		machine.Zones = append(machine.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineSTATUS populates our VirtualMachine_STATUS from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignPropertiesFromVirtualMachineSTATUS(source *alpha20201201s.VirtualMachine_STATUS) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_STATUS
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilitiesSTATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilitiesSTATUS() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource_STATUS
		err := availabilitySet.AssignPropertiesFromSubResourceSTATUS(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field AvailabilitySet")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_STATUS
		err := billingProfile.AssignPropertiesFromBillingProfileSTATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfileSTATUS() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// Conditions
	machine.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_STATUS
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfileSTATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfileSTATUS() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := EvictionPolicy_STATUS(*source.EvictionPolicy)
		machine.EvictionPolicy = &evictionPolicy
	} else {
		machine.EvictionPolicy = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignPropertiesFromExtendedLocationSTATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationSTATUS() to populate field ExtendedLocation")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile_STATUS
		err := hardwareProfile.AssignPropertiesFromHardwareProfileSTATUS(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHardwareProfileSTATUS() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource_STATUS
		err := host.AssignPropertiesFromSubResourceSTATUS(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field Host")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_STATUS
		err := hostGroup.AssignPropertiesFromSubResourceSTATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field HostGroup")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Id
	machine.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity_STATUS
		err := identity.AssignPropertiesFromVirtualMachineIdentitySTATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineIdentitySTATUS() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineInstanceView_STATUS
		err := instanceView.AssignPropertiesFromVirtualMachineInstanceViewSTATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineInstanceViewSTATUS() to populate field InstanceView")
		}
		machine.InstanceView = &instanceView
	} else {
		machine.InstanceView = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	machine.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile_STATUS
		err := networkProfile.AssignPropertiesFromNetworkProfileSTATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkProfileSTATUS() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile_STATUS
		err := osProfile.AssignPropertiesFromOSProfileSTATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOSProfileSTATUS() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
		err := plan.AssignPropertiesFromPlanSTATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlanSTATUS() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	if source.Priority != nil {
		priority := Priority_STATUS(*source.Priority)
		machine.Priority = &priority
	} else {
		machine.Priority = nil
	}

	// ProvisioningState
	machine.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_STATUS
		err := proximityPlacementGroup.AssignPropertiesFromSubResourceSTATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field ProximityPlacementGroup")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// Resources
	if source.Resources != nil {
		resourceList := make([]VirtualMachineExtension_STATUS, len(source.Resources))
		for resourceIndex, resourceItem := range source.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource VirtualMachineExtension_STATUS
			err := resource.AssignPropertiesFromVirtualMachineExtensionSTATUS(&resourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineExtensionSTATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		machine.Resources = resourceList
	} else {
		machine.Resources = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_STATUS
		err := securityProfile.AssignPropertiesFromSecurityProfileSTATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfileSTATUS() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile_STATUS
		err := storageProfile.AssignPropertiesFromStorageProfileSTATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromStorageProfileSTATUS() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	machine.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource_STATUS
		err := virtualMachineScaleSet.AssignPropertiesFromSubResourceSTATUS(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field VirtualMachineScaleSet")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// VmId
	machine.VmId = genruntime.ClonePointerToString(source.VmId)

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineSTATUS populates the provided destination VirtualMachine_STATUS from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignPropertiesToVirtualMachineSTATUS(destination *alpha20201201s.VirtualMachine_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if machine.AdditionalCapabilities != nil {
		var additionalCapability alpha20201201s.AdditionalCapabilities_STATUS
		err := machine.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilitiesSTATUS(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilitiesSTATUS() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AvailabilitySet
	if machine.AvailabilitySet != nil {
		var availabilitySet alpha20201201s.SubResource_STATUS
		err := machine.AvailabilitySet.AssignPropertiesToSubResourceSTATUS(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field AvailabilitySet")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// BillingProfile
	if machine.BillingProfile != nil {
		var billingProfile alpha20201201s.BillingProfile_STATUS
		err := machine.BillingProfile.AssignPropertiesToBillingProfileSTATUS(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfileSTATUS() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(machine.Conditions)

	// DiagnosticsProfile
	if machine.DiagnosticsProfile != nil {
		var diagnosticsProfile alpha20201201s.DiagnosticsProfile_STATUS
		err := machine.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfileSTATUS(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfileSTATUS() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if machine.EvictionPolicy != nil {
		evictionPolicy := string(*machine.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtendedLocation
	if machine.ExtendedLocation != nil {
		var extendedLocation alpha20201201s.ExtendedLocation_STATUS
		err := machine.ExtendedLocation.AssignPropertiesToExtendedLocationSTATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationSTATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machine.ExtensionsTimeBudget)

	// HardwareProfile
	if machine.HardwareProfile != nil {
		var hardwareProfile alpha20201201s.HardwareProfile_STATUS
		err := machine.HardwareProfile.AssignPropertiesToHardwareProfileSTATUS(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHardwareProfileSTATUS() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machine.Host != nil {
		var host alpha20201201s.SubResource_STATUS
		err := machine.Host.AssignPropertiesToSubResourceSTATUS(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field Host")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machine.HostGroup != nil {
		var hostGroup alpha20201201s.SubResource_STATUS
		err := machine.HostGroup.AssignPropertiesToSubResourceSTATUS(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(machine.Id)

	// Identity
	if machine.Identity != nil {
		var identity alpha20201201s.VirtualMachineIdentity_STATUS
		err := machine.Identity.AssignPropertiesToVirtualMachineIdentitySTATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineIdentitySTATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InstanceView
	if machine.InstanceView != nil {
		var instanceView alpha20201201s.VirtualMachineInstanceView_STATUS
		err := machine.InstanceView.AssignPropertiesToVirtualMachineInstanceViewSTATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineInstanceViewSTATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machine.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machine.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(machine.Name)

	// NetworkProfile
	if machine.NetworkProfile != nil {
		var networkProfile alpha20201201s.NetworkProfile_STATUS
		err := machine.NetworkProfile.AssignPropertiesToNetworkProfileSTATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkProfileSTATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if machine.OsProfile != nil {
		var osProfile alpha20201201s.OSProfile_STATUS
		err := machine.OsProfile.AssignPropertiesToOSProfileSTATUS(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOSProfileSTATUS() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Plan
	if machine.Plan != nil {
		var plan alpha20201201s.Plan_STATUS
		err := machine.Plan.AssignPropertiesToPlanSTATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlanSTATUS() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machine.PlatformFaultDomain)

	// Priority
	if machine.Priority != nil {
		priority := string(*machine.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(machine.ProvisioningState)

	// ProximityPlacementGroup
	if machine.ProximityPlacementGroup != nil {
		var proximityPlacementGroup alpha20201201s.SubResource_STATUS
		err := machine.ProximityPlacementGroup.AssignPropertiesToSubResourceSTATUS(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// Resources
	if machine.Resources != nil {
		resourceList := make([]alpha20201201s.VirtualMachineExtension_STATUS, len(machine.Resources))
		for resourceIndex, resourceItem := range machine.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource alpha20201201s.VirtualMachineExtension_STATUS
			err := resourceItem.AssignPropertiesToVirtualMachineExtensionSTATUS(&resource)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineExtensionSTATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		destination.Resources = resourceList
	} else {
		destination.Resources = nil
	}

	// SecurityProfile
	if machine.SecurityProfile != nil {
		var securityProfile alpha20201201s.SecurityProfile_STATUS
		err := machine.SecurityProfile.AssignPropertiesToSecurityProfileSTATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfileSTATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machine.StorageProfile != nil {
		var storageProfile alpha20201201s.StorageProfile_STATUS
		err := machine.StorageProfile.AssignPropertiesToStorageProfileSTATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToStorageProfileSTATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machine.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(machine.Type)

	// VirtualMachineScaleSet
	if machine.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet alpha20201201s.SubResource_STATUS
		err := machine.VirtualMachineScaleSet.AssignPropertiesToSubResourceSTATUS(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field VirtualMachineScaleSet")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// VmId
	destination.VmId = genruntime.ClonePointerToString(machine.VmId)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machine.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachines_Spec struct {
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`
	AvailabilitySet        *SubResource            `json:"availabilitySet,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName            string                                          `json:"azureName,omitempty"`
	BillingProfile       *BillingProfile                                 `json:"billingProfile,omitempty"`
	DiagnosticsProfile   *DiagnosticsProfile                             `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy       *VirtualMachinesSpecPropertiesEvictionPolicy    `json:"evictionPolicy,omitempty"`
	ExtendedLocation     *ExtendedLocation                               `json:"extendedLocation,omitempty"`
	ExtensionsTimeBudget *string                                         `json:"extensionsTimeBudget,omitempty"`
	HardwareProfile      *HardwareProfile                                `json:"hardwareProfile,omitempty"`
	Host                 *SubResource                                    `json:"host,omitempty"`
	HostGroup            *SubResource                                    `json:"hostGroup,omitempty"`
	Identity             *VirtualMachineIdentity                         `json:"identity,omitempty"`
	LicenseType          *string                                         `json:"licenseType,omitempty"`
	Location             *string                                         `json:"location,omitempty"`
	NetworkProfile       *VirtualMachines_Spec_Properties_NetworkProfile `json:"networkProfile,omitempty"`
	OsProfile            *VirtualMachines_Spec_Properties_OsProfile      `json:"osProfile,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                   *genruntime.KnownResourceReference     `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Plan                    *Plan                                  `json:"plan,omitempty"`
	PlatformFaultDomain     *int                                   `json:"platformFaultDomain,omitempty"`
	Priority                *VirtualMachinesSpecPropertiesPriority `json:"priority,omitempty"`
	ProximityPlacementGroup *SubResource                           `json:"proximityPlacementGroup,omitempty"`
	SecurityProfile         *SecurityProfile                       `json:"securityProfile,omitempty"`
	StorageProfile          *StorageProfile                        `json:"storageProfile,omitempty"`
	Tags                    map[string]string                      `json:"tags,omitempty"`
	VirtualMachineScaleSet  *SubResource                           `json:"virtualMachineScaleSet,omitempty"`
	Zones                   []string                               `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachines_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (machines *VirtualMachines_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if machines == nil {
		return nil, nil
	}
	result := &VirtualMachines_SpecARM{}

	// Set property ‘ExtendedLocation’:
	if machines.ExtendedLocation != nil {
		extendedLocationARM, err := (*machines.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocationARM.(*ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Identity’:
	if machines.Identity != nil {
		identityARM, err := (*machines.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identityARM.(*VirtualMachineIdentityARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	if machines.Location != nil {
		location := *machines.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Plan’:
	if machines.Plan != nil {
		planARM, err := (*machines.Plan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plan := *planARM.(*PlanARM)
		result.Plan = &plan
	}

	// Set property ‘Properties’:
	if machines.AdditionalCapabilities != nil ||
		machines.AvailabilitySet != nil ||
		machines.BillingProfile != nil ||
		machines.DiagnosticsProfile != nil ||
		machines.EvictionPolicy != nil ||
		machines.ExtensionsTimeBudget != nil ||
		machines.HardwareProfile != nil ||
		machines.Host != nil ||
		machines.HostGroup != nil ||
		machines.LicenseType != nil ||
		machines.NetworkProfile != nil ||
		machines.OsProfile != nil ||
		machines.PlatformFaultDomain != nil ||
		machines.Priority != nil ||
		machines.ProximityPlacementGroup != nil ||
		machines.SecurityProfile != nil ||
		machines.StorageProfile != nil ||
		machines.VirtualMachineScaleSet != nil {
		result.Properties = &VirtualMachines_Spec_PropertiesARM{}
	}
	if machines.AdditionalCapabilities != nil {
		additionalCapabilitiesARM, err := (*machines.AdditionalCapabilities).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		additionalCapabilities := *additionalCapabilitiesARM.(*AdditionalCapabilitiesARM)
		result.Properties.AdditionalCapabilities = &additionalCapabilities
	}
	if machines.AvailabilitySet != nil {
		availabilitySetARM, err := (*machines.AvailabilitySet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		availabilitySet := *availabilitySetARM.(*SubResourceARM)
		result.Properties.AvailabilitySet = &availabilitySet
	}
	if machines.BillingProfile != nil {
		billingProfileARM, err := (*machines.BillingProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		billingProfile := *billingProfileARM.(*BillingProfileARM)
		result.Properties.BillingProfile = &billingProfile
	}
	if machines.DiagnosticsProfile != nil {
		diagnosticsProfileARM, err := (*machines.DiagnosticsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnosticsProfile := *diagnosticsProfileARM.(*DiagnosticsProfileARM)
		result.Properties.DiagnosticsProfile = &diagnosticsProfile
	}
	if machines.EvictionPolicy != nil {
		evictionPolicy := *machines.EvictionPolicy
		result.Properties.EvictionPolicy = &evictionPolicy
	}
	if machines.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *machines.ExtensionsTimeBudget
		result.Properties.ExtensionsTimeBudget = &extensionsTimeBudget
	}
	if machines.HardwareProfile != nil {
		hardwareProfileARM, err := (*machines.HardwareProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hardwareProfile := *hardwareProfileARM.(*HardwareProfileARM)
		result.Properties.HardwareProfile = &hardwareProfile
	}
	if machines.Host != nil {
		hostARM, err := (*machines.Host).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		host := *hostARM.(*SubResourceARM)
		result.Properties.Host = &host
	}
	if machines.HostGroup != nil {
		hostGroupARM, err := (*machines.HostGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostGroup := *hostGroupARM.(*SubResourceARM)
		result.Properties.HostGroup = &hostGroup
	}
	if machines.LicenseType != nil {
		licenseType := *machines.LicenseType
		result.Properties.LicenseType = &licenseType
	}
	if machines.NetworkProfile != nil {
		networkProfileARM, err := (*machines.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := *networkProfileARM.(*VirtualMachines_Spec_Properties_NetworkProfileARM)
		result.Properties.NetworkProfile = &networkProfile
	}
	if machines.OsProfile != nil {
		osProfileARM, err := (*machines.OsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osProfile := *osProfileARM.(*VirtualMachines_Spec_Properties_OsProfileARM)
		result.Properties.OsProfile = &osProfile
	}
	if machines.PlatformFaultDomain != nil {
		platformFaultDomain := *machines.PlatformFaultDomain
		result.Properties.PlatformFaultDomain = &platformFaultDomain
	}
	if machines.Priority != nil {
		priority := *machines.Priority
		result.Properties.Priority = &priority
	}
	if machines.ProximityPlacementGroup != nil {
		proximityPlacementGroupARM, err := (*machines.ProximityPlacementGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proximityPlacementGroup := *proximityPlacementGroupARM.(*SubResourceARM)
		result.Properties.ProximityPlacementGroup = &proximityPlacementGroup
	}
	if machines.SecurityProfile != nil {
		securityProfileARM, err := (*machines.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := *securityProfileARM.(*SecurityProfileARM)
		result.Properties.SecurityProfile = &securityProfile
	}
	if machines.StorageProfile != nil {
		storageProfileARM, err := (*machines.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfileARM.(*StorageProfileARM)
		result.Properties.StorageProfile = &storageProfile
	}
	if machines.VirtualMachineScaleSet != nil {
		virtualMachineScaleSetARM, err := (*machines.VirtualMachineScaleSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineScaleSet := *virtualMachineScaleSetARM.(*SubResourceARM)
		result.Properties.VirtualMachineScaleSet = &virtualMachineScaleSet
	}

	// Set property ‘Tags’:
	if machines.Tags != nil {
		result.Tags = make(map[string]string, len(machines.Tags))
		for key, value := range machines.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range machines.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machines *VirtualMachines_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachines_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machines *VirtualMachines_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachines_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachines_SpecARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			machines.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property ‘AvailabilitySet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AvailabilitySet != nil {
			var availabilitySet1 SubResource
			err := availabilitySet1.PopulateFromARM(owner, *typedInput.Properties.AvailabilitySet)
			if err != nil {
				return err
			}
			availabilitySet := availabilitySet1
			machines.AvailabilitySet = &availabilitySet
		}
	}

	// Set property ‘AzureName’:
	machines.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘BillingProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BillingProfile != nil {
			var billingProfile1 BillingProfile
			err := billingProfile1.PopulateFromARM(owner, *typedInput.Properties.BillingProfile)
			if err != nil {
				return err
			}
			billingProfile := billingProfile1
			machines.BillingProfile = &billingProfile
		}
	}

	// Set property ‘DiagnosticsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiagnosticsProfile != nil {
			var diagnosticsProfile1 DiagnosticsProfile
			err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.Properties.DiagnosticsProfile)
			if err != nil {
				return err
			}
			diagnosticsProfile := diagnosticsProfile1
			machines.DiagnosticsProfile = &diagnosticsProfile
		}
	}

	// Set property ‘EvictionPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EvictionPolicy != nil {
			evictionPolicy := *typedInput.Properties.EvictionPolicy
			machines.EvictionPolicy = &evictionPolicy
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		machines.ExtendedLocation = &extendedLocation
	}

	// Set property ‘ExtensionsTimeBudget’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExtensionsTimeBudget != nil {
			extensionsTimeBudget := *typedInput.Properties.ExtensionsTimeBudget
			machines.ExtensionsTimeBudget = &extensionsTimeBudget
		}
	}

	// Set property ‘HardwareProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HardwareProfile != nil {
			var hardwareProfile1 HardwareProfile
			err := hardwareProfile1.PopulateFromARM(owner, *typedInput.Properties.HardwareProfile)
			if err != nil {
				return err
			}
			hardwareProfile := hardwareProfile1
			machines.HardwareProfile = &hardwareProfile
		}
	}

	// Set property ‘Host’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Host != nil {
			var host1 SubResource
			err := host1.PopulateFromARM(owner, *typedInput.Properties.Host)
			if err != nil {
				return err
			}
			host := host1
			machines.Host = &host
		}
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			machines.HostGroup = &hostGroup
		}
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		machines.Identity = &identity
	}

	// Set property ‘LicenseType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			machines.LicenseType = &licenseType
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		machines.Location = &location
	}

	// Set property ‘NetworkProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 VirtualMachines_Spec_Properties_NetworkProfile
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			machines.NetworkProfile = &networkProfile
		}
	}

	// Set property ‘OsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsProfile != nil {
			var osProfile1 VirtualMachines_Spec_Properties_OsProfile
			err := osProfile1.PopulateFromARM(owner, *typedInput.Properties.OsProfile)
			if err != nil {
				return err
			}
			osProfile := osProfile1
			machines.OsProfile = &osProfile
		}
	}

	// Set property ‘Owner’:
	machines.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		machines.Plan = &plan
	}

	// Set property ‘PlatformFaultDomain’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomain != nil {
			platformFaultDomain := *typedInput.Properties.PlatformFaultDomain
			machines.PlatformFaultDomain = &platformFaultDomain
		}
	}

	// Set property ‘Priority’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			machines.Priority = &priority
		}
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			machines.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property ‘SecurityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecurityProfile != nil {
			var securityProfile1 SecurityProfile
			err := securityProfile1.PopulateFromARM(owner, *typedInput.Properties.SecurityProfile)
			if err != nil {
				return err
			}
			securityProfile := securityProfile1
			machines.SecurityProfile = &securityProfile
		}
	}

	// Set property ‘StorageProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 StorageProfile
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			machines.StorageProfile = &storageProfile
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		machines.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			machines.Tags[key] = value
		}
	}

	// Set property ‘VirtualMachineScaleSet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineScaleSet != nil {
			var virtualMachineScaleSet1 SubResource
			err := virtualMachineScaleSet1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineScaleSet)
			if err != nil {
				return err
			}
			virtualMachineScaleSet := virtualMachineScaleSet1
			machines.VirtualMachineScaleSet = &virtualMachineScaleSet
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		machines.Zones = append(machines.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualMachines_Spec{}

// ConvertSpecFrom populates our VirtualMachines_Spec from the provided source
func (machines *VirtualMachines_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*alpha20201201s.VirtualMachines_Spec)
	if ok {
		// Populate our instance from source
		return machines.AssignPropertiesFromVirtualMachinesSpec(src)
	}

	// Convert to an intermediate form
	src = &alpha20201201s.VirtualMachines_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = machines.AssignPropertiesFromVirtualMachinesSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachines_Spec
func (machines *VirtualMachines_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*alpha20201201s.VirtualMachines_Spec)
	if ok {
		// Populate destination from our instance
		return machines.AssignPropertiesToVirtualMachinesSpec(dst)
	}

	// Convert to an intermediate form
	dst = &alpha20201201s.VirtualMachines_Spec{}
	err := machines.AssignPropertiesToVirtualMachinesSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualMachinesSpec populates our VirtualMachines_Spec from the provided source VirtualMachines_Spec
func (machines *VirtualMachines_Spec) AssignPropertiesFromVirtualMachinesSpec(source *alpha20201201s.VirtualMachines_Spec) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		machines.AdditionalCapabilities = &additionalCapability
	} else {
		machines.AdditionalCapabilities = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource
		err := availabilitySet.AssignPropertiesFromSubResource(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field AvailabilitySet")
		}
		machines.AvailabilitySet = &availabilitySet
	} else {
		machines.AvailabilitySet = nil
	}

	// AzureName
	machines.AzureName = source.AzureName

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignPropertiesFromBillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfile() to populate field BillingProfile")
		}
		machines.BillingProfile = &billingProfile
	} else {
		machines.BillingProfile = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		machines.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machines.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := VirtualMachinesSpecPropertiesEvictionPolicy(*source.EvictionPolicy)
		machines.EvictionPolicy = &evictionPolicy
	} else {
		machines.EvictionPolicy = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocation")
		}
		machines.ExtendedLocation = &extendedLocation
	} else {
		machines.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machines.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile
		err := hardwareProfile.AssignPropertiesFromHardwareProfile(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHardwareProfile() to populate field HardwareProfile")
		}
		machines.HardwareProfile = &hardwareProfile
	} else {
		machines.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource
		err := host.AssignPropertiesFromSubResource(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field Host")
		}
		machines.Host = &host
	} else {
		machines.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.AssignPropertiesFromSubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field HostGroup")
		}
		machines.HostGroup = &hostGroup
	} else {
		machines.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity
		err := identity.AssignPropertiesFromVirtualMachineIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineIdentity() to populate field Identity")
		}
		machines.Identity = &identity
	} else {
		machines.Identity = nil
	}

	// LicenseType
	machines.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machines.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachines_Spec_Properties_NetworkProfile
		err := networkProfile.AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile() to populate field NetworkProfile")
		}
		machines.NetworkProfile = &networkProfile
	} else {
		machines.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachines_Spec_Properties_OsProfile
		err := osProfile.AssignPropertiesFromVirtualMachinesSpecPropertiesOsProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinesSpecPropertiesOsProfile() to populate field OsProfile")
		}
		machines.OsProfile = &osProfile
	} else {
		machines.OsProfile = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		machines.Owner = &owner
	} else {
		machines.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignPropertiesFromPlan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlan() to populate field Plan")
		}
		machines.Plan = &plan
	} else {
		machines.Plan = nil
	}

	// PlatformFaultDomain
	machines.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	if source.Priority != nil {
		priority := VirtualMachinesSpecPropertiesPriority(*source.Priority)
		machines.Priority = &priority
	} else {
		machines.Priority = nil
	}

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.AssignPropertiesFromSubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field ProximityPlacementGroup")
		}
		machines.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machines.ProximityPlacementGroup = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignPropertiesFromSecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfile() to populate field SecurityProfile")
		}
		machines.SecurityProfile = &securityProfile
	} else {
		machines.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignPropertiesFromStorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromStorageProfile() to populate field StorageProfile")
		}
		machines.StorageProfile = &storageProfile
	} else {
		machines.StorageProfile = nil
	}

	// Tags
	machines.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource
		err := virtualMachineScaleSet.AssignPropertiesFromSubResource(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field VirtualMachineScaleSet")
		}
		machines.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machines.VirtualMachineScaleSet = nil
	}

	// Zones
	machines.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpec populates the provided destination VirtualMachines_Spec from our VirtualMachines_Spec
func (machines *VirtualMachines_Spec) AssignPropertiesToVirtualMachinesSpec(destination *alpha20201201s.VirtualMachines_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if machines.AdditionalCapabilities != nil {
		var additionalCapability alpha20201201s.AdditionalCapabilities
		err := machines.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AvailabilitySet
	if machines.AvailabilitySet != nil {
		var availabilitySet alpha20201201s.SubResource
		err := machines.AvailabilitySet.AssignPropertiesToSubResource(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field AvailabilitySet")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// AzureName
	destination.AzureName = machines.AzureName

	// BillingProfile
	if machines.BillingProfile != nil {
		var billingProfile alpha20201201s.BillingProfile
		err := machines.BillingProfile.AssignPropertiesToBillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfile() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// DiagnosticsProfile
	if machines.DiagnosticsProfile != nil {
		var diagnosticsProfile alpha20201201s.DiagnosticsProfile
		err := machines.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if machines.EvictionPolicy != nil {
		evictionPolicy := string(*machines.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtendedLocation
	if machines.ExtendedLocation != nil {
		var extendedLocation alpha20201201s.ExtendedLocation
		err := machines.ExtendedLocation.AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machines.ExtensionsTimeBudget)

	// HardwareProfile
	if machines.HardwareProfile != nil {
		var hardwareProfile alpha20201201s.HardwareProfile
		err := machines.HardwareProfile.AssignPropertiesToHardwareProfile(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHardwareProfile() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machines.Host != nil {
		var host alpha20201201s.SubResource
		err := machines.Host.AssignPropertiesToSubResource(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field Host")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machines.HostGroup != nil {
		var hostGroup alpha20201201s.SubResource
		err := machines.HostGroup.AssignPropertiesToSubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if machines.Identity != nil {
		var identity alpha20201201s.VirtualMachineIdentity
		err := machines.Identity.AssignPropertiesToVirtualMachineIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machines.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machines.Location)

	// NetworkProfile
	if machines.NetworkProfile != nil {
		var networkProfile alpha20201201s.VirtualMachines_Spec_Properties_NetworkProfile
		err := machines.NetworkProfile.AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OriginalVersion
	destination.OriginalVersion = machines.OriginalVersion()

	// OsProfile
	if machines.OsProfile != nil {
		var osProfile alpha20201201s.VirtualMachines_Spec_Properties_OsProfile
		err := machines.OsProfile.AssignPropertiesToVirtualMachinesSpecPropertiesOsProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinesSpecPropertiesOsProfile() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Owner
	if machines.Owner != nil {
		owner := machines.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if machines.Plan != nil {
		var plan alpha20201201s.Plan
		err := machines.Plan.AssignPropertiesToPlan(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machines.PlatformFaultDomain)

	// Priority
	if machines.Priority != nil {
		priority := string(*machines.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ProximityPlacementGroup
	if machines.ProximityPlacementGroup != nil {
		var proximityPlacementGroup alpha20201201s.SubResource
		err := machines.ProximityPlacementGroup.AssignPropertiesToSubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// SecurityProfile
	if machines.SecurityProfile != nil {
		var securityProfile alpha20201201s.SecurityProfile
		err := machines.SecurityProfile.AssignPropertiesToSecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machines.StorageProfile != nil {
		var storageProfile alpha20201201s.StorageProfile
		err := machines.StorageProfile.AssignPropertiesToStorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToStorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machines.Tags)

	// VirtualMachineScaleSet
	if machines.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet alpha20201201s.SubResource
		err := machines.VirtualMachineScaleSet.AssignPropertiesToSubResource(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field VirtualMachineScaleSet")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machines.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (machines *VirtualMachines_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (machines *VirtualMachines_Spec) SetAzureName(azureName string) { machines.AzureName = azureName }

// Deprecated version of AdditionalCapabilities. Use v1beta20201201.AdditionalCapabilities instead
type AdditionalCapabilities struct {
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &AdditionalCapabilities{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (capabilities *AdditionalCapabilities) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if capabilities == nil {
		return nil, nil
	}
	result := &AdditionalCapabilitiesARM{}

	// Set property ‘UltraSSDEnabled’:
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		result.UltraSSDEnabled = &ultraSSDEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (capabilities *AdditionalCapabilities) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalCapabilitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (capabilities *AdditionalCapabilities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalCapabilitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalCapabilitiesARM, got %T", armInput)
	}

	// Set property ‘UltraSSDEnabled’:
	if typedInput.UltraSSDEnabled != nil {
		ultraSSDEnabled := *typedInput.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalCapabilities populates our AdditionalCapabilities from the provided source AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignPropertiesFromAdditionalCapabilities(source *alpha20201201s.AdditionalCapabilities) error {

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalCapabilities populates the provided destination AdditionalCapabilities from our AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignPropertiesToAdditionalCapabilities(destination *alpha20201201s.AdditionalCapabilities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AdditionalCapabilities_STATUS. Use v1beta20201201.AdditionalCapabilities_STATUS instead
type AdditionalCapabilities_STATUS struct {
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &AdditionalCapabilities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (capabilities *AdditionalCapabilities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalCapabilities_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (capabilities *AdditionalCapabilities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalCapabilities_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalCapabilities_STATUSARM, got %T", armInput)
	}

	// Set property ‘UltraSSDEnabled’:
	if typedInput.UltraSSDEnabled != nil {
		ultraSSDEnabled := *typedInput.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalCapabilitiesSTATUS populates our AdditionalCapabilities_STATUS from the provided source AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignPropertiesFromAdditionalCapabilitiesSTATUS(source *alpha20201201s.AdditionalCapabilities_STATUS) error {

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalCapabilitiesSTATUS populates the provided destination AdditionalCapabilities_STATUS from our AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignPropertiesToAdditionalCapabilitiesSTATUS(destination *alpha20201201s.AdditionalCapabilities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of BillingProfile. Use v1beta20201201.BillingProfile instead
type BillingProfile struct {
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

var _ genruntime.ARMTransformer = &BillingProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *BillingProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &BillingProfileARM{}

	// Set property ‘MaxPrice’:
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		result.MaxPrice = &maxPrice
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *BillingProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BillingProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *BillingProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BillingProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BillingProfileARM, got %T", armInput)
	}

	// Set property ‘MaxPrice’:
	if typedInput.MaxPrice != nil {
		maxPrice := *typedInput.MaxPrice
		profile.MaxPrice = &maxPrice
	}

	// No error
	return nil
}

// AssignPropertiesFromBillingProfile populates our BillingProfile from the provided source BillingProfile
func (profile *BillingProfile) AssignPropertiesFromBillingProfile(source *alpha20201201s.BillingProfile) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBillingProfile populates the provided destination BillingProfile from our BillingProfile
func (profile *BillingProfile) AssignPropertiesToBillingProfile(destination *alpha20201201s.BillingProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of BillingProfile_STATUS. Use v1beta20201201.BillingProfile_STATUS instead
type BillingProfile_STATUS struct {
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

var _ genruntime.FromARMConverter = &BillingProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *BillingProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BillingProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *BillingProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BillingProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BillingProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘MaxPrice’:
	if typedInput.MaxPrice != nil {
		maxPrice := *typedInput.MaxPrice
		profile.MaxPrice = &maxPrice
	}

	// No error
	return nil
}

// AssignPropertiesFromBillingProfileSTATUS populates our BillingProfile_STATUS from the provided source BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignPropertiesFromBillingProfileSTATUS(source *alpha20201201s.BillingProfile_STATUS) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBillingProfileSTATUS populates the provided destination BillingProfile_STATUS from our BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignPropertiesToBillingProfileSTATUS(destination *alpha20201201s.BillingProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of DiagnosticsProfile. Use v1beta20201201.DiagnosticsProfile instead
type DiagnosticsProfile struct {
	BootDiagnostics *BootDiagnostics `json:"bootDiagnostics,omitempty"`
}

var _ genruntime.ARMTransformer = &DiagnosticsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *DiagnosticsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &DiagnosticsProfileARM{}

	// Set property ‘BootDiagnostics’:
	if profile.BootDiagnostics != nil {
		bootDiagnosticsARM, err := (*profile.BootDiagnostics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		bootDiagnostics := *bootDiagnosticsARM.(*BootDiagnosticsARM)
		result.BootDiagnostics = &bootDiagnostics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *DiagnosticsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiagnosticsProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *DiagnosticsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiagnosticsProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiagnosticsProfileARM, got %T", armInput)
	}

	// Set property ‘BootDiagnostics’:
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnostics
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		profile.BootDiagnostics = &bootDiagnostics
	}

	// No error
	return nil
}

// AssignPropertiesFromDiagnosticsProfile populates our DiagnosticsProfile from the provided source DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignPropertiesFromDiagnosticsProfile(source *alpha20201201s.DiagnosticsProfile) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics
		err := bootDiagnostic.AssignPropertiesFromBootDiagnostics(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBootDiagnostics() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiagnosticsProfile populates the provided destination DiagnosticsProfile from our DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignPropertiesToDiagnosticsProfile(destination *alpha20201201s.DiagnosticsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic alpha20201201s.BootDiagnostics
		err := profile.BootDiagnostics.AssignPropertiesToBootDiagnostics(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBootDiagnostics() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of DiagnosticsProfile_STATUS. Use v1beta20201201.DiagnosticsProfile_STATUS instead
type DiagnosticsProfile_STATUS struct {
	BootDiagnostics *BootDiagnostics_STATUS `json:"bootDiagnostics,omitempty"`
}

var _ genruntime.FromARMConverter = &DiagnosticsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *DiagnosticsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiagnosticsProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *DiagnosticsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiagnosticsProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiagnosticsProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘BootDiagnostics’:
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnostics_STATUS
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		profile.BootDiagnostics = &bootDiagnostics
	}

	// No error
	return nil
}

// AssignPropertiesFromDiagnosticsProfileSTATUS populates our DiagnosticsProfile_STATUS from the provided source DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignPropertiesFromDiagnosticsProfileSTATUS(source *alpha20201201s.DiagnosticsProfile_STATUS) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics_STATUS
		err := bootDiagnostic.AssignPropertiesFromBootDiagnosticsSTATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBootDiagnosticsSTATUS() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiagnosticsProfileSTATUS populates the provided destination DiagnosticsProfile_STATUS from our DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignPropertiesToDiagnosticsProfileSTATUS(destination *alpha20201201s.DiagnosticsProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic alpha20201201s.BootDiagnostics_STATUS
		err := profile.BootDiagnostics.AssignPropertiesToBootDiagnosticsSTATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBootDiagnosticsSTATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of EvictionPolicy_STATUS. Use v1beta20201201.EvictionPolicy_STATUS instead
type EvictionPolicy_STATUS string

const (
	EvictionPolicy_STATUS_Deallocate = EvictionPolicy_STATUS("Deallocate")
	EvictionPolicy_STATUS_Delete     = EvictionPolicy_STATUS("Delete")
)

// Deprecated version of ExtendedLocation. Use v1beta20201201.ExtendedLocation instead
type ExtendedLocation struct {
	Name *string               `json:"name,omitempty"`
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (location *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if location == nil {
		return nil, nil
	}
	result := &ExtendedLocationARM{}

	// Set property ‘Name’:
	if location.Name != nil {
		name := *location.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if location.Type != nil {
		typeVar := *location.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocationARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignPropertiesFromExtendedLocation(source *alpha20201201s.ExtendedLocation) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType(*source.Type)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignPropertiesToExtendedLocation(destination *alpha20201201s.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ExtendedLocation_STATUS. Use v1beta20201201.ExtendedLocation_STATUS instead
type ExtendedLocation_STATUS struct {
	Name *string                      `json:"name,omitempty"`
	Type *ExtendedLocationType_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_STATUSARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocationSTATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignPropertiesFromExtendedLocationSTATUS(source *alpha20201201s.ExtendedLocation_STATUS) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_STATUS(*source.Type)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocationSTATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignPropertiesToExtendedLocationSTATUS(destination *alpha20201201s.ExtendedLocation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of HardwareProfile. Use v1beta20201201.HardwareProfile instead
type HardwareProfile struct {
	VmSize *HardwareProfileVmSize `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &HardwareProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *HardwareProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &HardwareProfileARM{}

	// Set property ‘VmSize’:
	if profile.VmSize != nil {
		vmSize := *profile.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *HardwareProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HardwareProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *HardwareProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HardwareProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HardwareProfileARM, got %T", armInput)
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignPropertiesFromHardwareProfile populates our HardwareProfile from the provided source HardwareProfile
func (profile *HardwareProfile) AssignPropertiesFromHardwareProfile(source *alpha20201201s.HardwareProfile) error {

	// VmSize
	if source.VmSize != nil {
		vmSize := HardwareProfileVmSize(*source.VmSize)
		profile.VmSize = &vmSize
	} else {
		profile.VmSize = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHardwareProfile populates the provided destination HardwareProfile from our HardwareProfile
func (profile *HardwareProfile) AssignPropertiesToHardwareProfile(destination *alpha20201201s.HardwareProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmSize
	if profile.VmSize != nil {
		vmSize := string(*profile.VmSize)
		destination.VmSize = &vmSize
	} else {
		destination.VmSize = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of HardwareProfile_STATUS. Use v1beta20201201.HardwareProfile_STATUS instead
type HardwareProfile_STATUS struct {
	VmSize *HardwareProfileSTATUSVmSize `json:"vmSize,omitempty"`
}

var _ genruntime.FromARMConverter = &HardwareProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *HardwareProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HardwareProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *HardwareProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HardwareProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HardwareProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignPropertiesFromHardwareProfileSTATUS populates our HardwareProfile_STATUS from the provided source HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignPropertiesFromHardwareProfileSTATUS(source *alpha20201201s.HardwareProfile_STATUS) error {

	// VmSize
	if source.VmSize != nil {
		vmSize := HardwareProfileSTATUSVmSize(*source.VmSize)
		profile.VmSize = &vmSize
	} else {
		profile.VmSize = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHardwareProfileSTATUS populates the provided destination HardwareProfile_STATUS from our HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignPropertiesToHardwareProfileSTATUS(destination *alpha20201201s.HardwareProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmSize
	if profile.VmSize != nil {
		vmSize := string(*profile.VmSize)
		destination.VmSize = &vmSize
	} else {
		destination.VmSize = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of NetworkProfile_STATUS. Use v1beta20201201.NetworkProfile_STATUS instead
type NetworkProfile_STATUS struct {
	NetworkInterfaces []NetworkInterfaceReference_STATUS `json:"networkInterfaces,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘NetworkInterfaces’:
	for _, item := range typedInput.NetworkInterfaces {
		var item1 NetworkInterfaceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaces = append(profile.NetworkInterfaces, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkProfileSTATUS populates our NetworkProfile_STATUS from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignPropertiesFromNetworkProfileSTATUS(source *alpha20201201s.NetworkProfile_STATUS) error {

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference_STATUS, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference_STATUS
			err := networkInterface.AssignPropertiesFromNetworkInterfaceReferenceSTATUS(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceReferenceSTATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkProfileSTATUS populates the provided destination NetworkProfile_STATUS from our NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignPropertiesToNetworkProfileSTATUS(destination *alpha20201201s.NetworkProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]alpha20201201s.NetworkInterfaceReference_STATUS, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface alpha20201201s.NetworkInterfaceReference_STATUS
			err := networkInterfaceItem.AssignPropertiesToNetworkInterfaceReferenceSTATUS(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceReferenceSTATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of OSProfile_STATUS. Use v1beta20201201.OSProfile_STATUS instead
type OSProfile_STATUS struct {
	AdminUsername               *string                      `json:"adminUsername,omitempty"`
	AllowExtensionOperations    *bool                        `json:"allowExtensionOperations,omitempty"`
	ComputerName                *string                      `json:"computerName,omitempty"`
	CustomData                  *string                      `json:"customData,omitempty"`
	LinuxConfiguration          *LinuxConfiguration_STATUS   `json:"linuxConfiguration,omitempty"`
	RequireGuestProvisionSignal *bool                        `json:"requireGuestProvisionSignal,omitempty"`
	Secrets                     []VaultSecretGroup_STATUS    `json:"secrets,omitempty"`
	WindowsConfiguration        *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &OSProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *OSProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OSProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *OSProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OSProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OSProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property ‘AllowExtensionOperations’:
	if typedInput.AllowExtensionOperations != nil {
		allowExtensionOperations := *typedInput.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property ‘ComputerName’:
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		profile.ComputerName = &computerName
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration_STATUS
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘RequireGuestProvisionSignal’:
	if typedInput.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *typedInput.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration_STATUS
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromOSProfileSTATUS populates our OSProfile_STATUS from the provided source OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignPropertiesFromOSProfileSTATUS(source *alpha20201201s.OSProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_STATUS
		err := linuxConfiguration.AssignPropertiesFromLinuxConfigurationSTATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfigurationSTATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_STATUS
			err := secret.AssignPropertiesFromVaultSecretGroupSTATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroupSTATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_STATUS
		err := windowsConfiguration.AssignPropertiesFromWindowsConfigurationSTATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfigurationSTATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSProfileSTATUS populates the provided destination OSProfile_STATUS from our OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignPropertiesToOSProfileSTATUS(destination *alpha20201201s.OSProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration alpha20201201s.LinuxConfiguration_STATUS
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfigurationSTATUS(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfigurationSTATUS() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]alpha20201201s.VaultSecretGroup_STATUS, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret alpha20201201s.VaultSecretGroup_STATUS
			err := secretItem.AssignPropertiesToVaultSecretGroupSTATUS(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroupSTATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration alpha20201201s.WindowsConfiguration_STATUS
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfigurationSTATUS(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfigurationSTATUS() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Plan. Use v1beta20201201.Plan instead
type Plan struct {
	Name          *string `json:"name,omitempty"`
	Product       *string `json:"product,omitempty"`
	PromotionCode *string `json:"promotionCode,omitempty"`
	Publisher     *string `json:"publisher,omitempty"`
}

var _ genruntime.ARMTransformer = &Plan{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (plan *Plan) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if plan == nil {
		return nil, nil
	}
	result := &PlanARM{}

	// Set property ‘Name’:
	if plan.Name != nil {
		name := *plan.Name
		result.Name = &name
	}

	// Set property ‘Product’:
	if plan.Product != nil {
		product := *plan.Product
		result.Product = &product
	}

	// Set property ‘PromotionCode’:
	if plan.PromotionCode != nil {
		promotionCode := *plan.PromotionCode
		result.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if plan.Publisher != nil {
		publisher := *plan.Publisher
		result.Publisher = &publisher
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (plan *Plan) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PlanARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (plan *Plan) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PlanARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PlanARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		plan.Name = &name
	}

	// Set property ‘Product’:
	if typedInput.Product != nil {
		product := *typedInput.Product
		plan.Product = &product
	}

	// Set property ‘PromotionCode’:
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		plan.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		plan.Publisher = &publisher
	}

	// No error
	return nil
}

// AssignPropertiesFromPlan populates our Plan from the provided source Plan
func (plan *Plan) AssignPropertiesFromPlan(source *alpha20201201s.Plan) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// No error
	return nil
}

// AssignPropertiesToPlan populates the provided destination Plan from our Plan
func (plan *Plan) AssignPropertiesToPlan(destination *alpha20201201s.Plan) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Plan_STATUS. Use v1beta20201201.Plan_STATUS instead
type Plan_STATUS struct {
	Name          *string `json:"name,omitempty"`
	Product       *string `json:"product,omitempty"`
	PromotionCode *string `json:"promotionCode,omitempty"`
	Publisher     *string `json:"publisher,omitempty"`
}

var _ genruntime.FromARMConverter = &Plan_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (plan *Plan_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Plan_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (plan *Plan_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Plan_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Plan_STATUSARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		plan.Name = &name
	}

	// Set property ‘Product’:
	if typedInput.Product != nil {
		product := *typedInput.Product
		plan.Product = &product
	}

	// Set property ‘PromotionCode’:
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		plan.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		plan.Publisher = &publisher
	}

	// No error
	return nil
}

// AssignPropertiesFromPlanSTATUS populates our Plan_STATUS from the provided source Plan_STATUS
func (plan *Plan_STATUS) AssignPropertiesFromPlanSTATUS(source *alpha20201201s.Plan_STATUS) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// No error
	return nil
}

// AssignPropertiesToPlanSTATUS populates the provided destination Plan_STATUS from our Plan_STATUS
func (plan *Plan_STATUS) AssignPropertiesToPlanSTATUS(destination *alpha20201201s.Plan_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Priority_STATUS. Use v1beta20201201.Priority_STATUS instead
type Priority_STATUS string

const (
	Priority_STATUS_Low     = Priority_STATUS("Low")
	Priority_STATUS_Regular = Priority_STATUS("Regular")
	Priority_STATUS_Spot    = Priority_STATUS("Spot")
)

// Deprecated version of SecurityProfile. Use v1beta20201201.SecurityProfile instead
type SecurityProfile struct {
	EncryptionAtHost *bool                        `json:"encryptionAtHost,omitempty"`
	SecurityType     *SecurityProfileSecurityType `json:"securityType,omitempty"`
	UefiSettings     *UefiSettings                `json:"uefiSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &SecurityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *SecurityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &SecurityProfileARM{}

	// Set property ‘EncryptionAtHost’:
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		result.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if profile.SecurityType != nil {
		securityType := *profile.SecurityType
		result.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if profile.UefiSettings != nil {
		uefiSettingsARM, err := (*profile.UefiSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		uefiSettings := *uefiSettingsARM.(*UefiSettingsARM)
		result.UefiSettings = &uefiSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *SecurityProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecurityProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *SecurityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecurityProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecurityProfileARM, got %T", armInput)
	}

	// Set property ‘EncryptionAtHost’:
	if typedInput.EncryptionAtHost != nil {
		encryptionAtHost := *typedInput.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if typedInput.SecurityType != nil {
		securityType := *typedInput.SecurityType
		profile.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if typedInput.UefiSettings != nil {
		var uefiSettings1 UefiSettings
		err := uefiSettings1.PopulateFromARM(owner, *typedInput.UefiSettings)
		if err != nil {
			return err
		}
		uefiSettings := uefiSettings1
		profile.UefiSettings = &uefiSettings
	}

	// No error
	return nil
}

// AssignPropertiesFromSecurityProfile populates our SecurityProfile from the provided source SecurityProfile
func (profile *SecurityProfile) AssignPropertiesFromSecurityProfile(source *alpha20201201s.SecurityProfile) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := SecurityProfileSecurityType(*source.SecurityType)
		profile.SecurityType = &securityType
	} else {
		profile.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings
		err := uefiSetting.AssignPropertiesFromUefiSettings(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUefiSettings() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityProfile populates the provided destination SecurityProfile from our SecurityProfile
func (profile *SecurityProfile) AssignPropertiesToSecurityProfile(destination *alpha20201201s.SecurityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	if profile.SecurityType != nil {
		securityType := string(*profile.SecurityType)
		destination.SecurityType = &securityType
	} else {
		destination.SecurityType = nil
	}

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting alpha20201201s.UefiSettings
		err := profile.UefiSettings.AssignPropertiesToUefiSettings(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUefiSettings() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SecurityProfile_STATUS. Use v1beta20201201.SecurityProfile_STATUS instead
type SecurityProfile_STATUS struct {
	EncryptionAtHost *bool                              `json:"encryptionAtHost,omitempty"`
	SecurityType     *SecurityProfileSTATUSSecurityType `json:"securityType,omitempty"`
	UefiSettings     *UefiSettings_STATUS               `json:"uefiSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &SecurityProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *SecurityProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecurityProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *SecurityProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecurityProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecurityProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘EncryptionAtHost’:
	if typedInput.EncryptionAtHost != nil {
		encryptionAtHost := *typedInput.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if typedInput.SecurityType != nil {
		securityType := *typedInput.SecurityType
		profile.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if typedInput.UefiSettings != nil {
		var uefiSettings1 UefiSettings_STATUS
		err := uefiSettings1.PopulateFromARM(owner, *typedInput.UefiSettings)
		if err != nil {
			return err
		}
		uefiSettings := uefiSettings1
		profile.UefiSettings = &uefiSettings
	}

	// No error
	return nil
}

// AssignPropertiesFromSecurityProfileSTATUS populates our SecurityProfile_STATUS from the provided source SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignPropertiesFromSecurityProfileSTATUS(source *alpha20201201s.SecurityProfile_STATUS) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := SecurityProfileSTATUSSecurityType(*source.SecurityType)
		profile.SecurityType = &securityType
	} else {
		profile.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings_STATUS
		err := uefiSetting.AssignPropertiesFromUefiSettingsSTATUS(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUefiSettingsSTATUS() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityProfileSTATUS populates the provided destination SecurityProfile_STATUS from our SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignPropertiesToSecurityProfileSTATUS(destination *alpha20201201s.SecurityProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	if profile.SecurityType != nil {
		securityType := string(*profile.SecurityType)
		destination.SecurityType = &securityType
	} else {
		destination.SecurityType = nil
	}

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting alpha20201201s.UefiSettings_STATUS
		err := profile.UefiSettings.AssignPropertiesToUefiSettingsSTATUS(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUefiSettingsSTATUS() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of StorageProfile. Use v1beta20201201.StorageProfile instead
type StorageProfile struct {
	DataDisks      []DataDisk      `json:"dataDisks,omitempty"`
	ImageReference *ImageReference `json:"imageReference,omitempty"`
	OsDisk         *OSDisk         `json:"osDisk,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *StorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &StorageProfileARM{}

	// Set property ‘DataDisks’:
	for _, item := range profile.DataDisks {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DataDisks = append(result.DataDisks, *itemARM.(*DataDiskARM))
	}

	// Set property ‘ImageReference’:
	if profile.ImageReference != nil {
		imageReferenceARM, err := (*profile.ImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageReference := *imageReferenceARM.(*ImageReferenceARM)
		result.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if profile.OsDisk != nil {
		osDiskARM, err := (*profile.OsDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osDisk := *osDiskARM.(*OSDiskARM)
		result.OsDisk = &osDisk
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *StorageProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *StorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageProfileARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 DataDisk
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 OSDisk
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromStorageProfile populates our StorageProfile from the provided source StorageProfile
func (profile *StorageProfile) AssignPropertiesFromStorageProfile(source *alpha20201201s.StorageProfile) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk
			err := dataDisk.AssignPropertiesFromDataDisk(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignPropertiesFromImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReference() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk
		err := osDisk.AssignPropertiesFromOSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOSDisk() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToStorageProfile populates the provided destination StorageProfile from our StorageProfile
func (profile *StorageProfile) AssignPropertiesToStorageProfile(destination *alpha20201201s.StorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]alpha20201201s.DataDisk, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk alpha20201201s.DataDisk
			err := dataDiskItem.AssignPropertiesToDataDisk(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference alpha20201201s.ImageReference
		err := profile.ImageReference.AssignPropertiesToImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReference() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk alpha20201201s.OSDisk
		err := profile.OsDisk.AssignPropertiesToOSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOSDisk() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of StorageProfile_STATUS. Use v1beta20201201.StorageProfile_STATUS instead
type StorageProfile_STATUS struct {
	DataDisks      []DataDisk_STATUS      `json:"dataDisks,omitempty"`
	ImageReference *ImageReference_STATUS `json:"imageReference,omitempty"`
	OsDisk         *OSDisk_STATUS         `json:"osDisk,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *StorageProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *StorageProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 DataDisk_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference_STATUS
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 OSDisk_STATUS
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromStorageProfileSTATUS populates our StorageProfile_STATUS from the provided source StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignPropertiesFromStorageProfileSTATUS(source *alpha20201201s.StorageProfile_STATUS) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk_STATUS
			err := dataDisk.AssignPropertiesFromDataDiskSTATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDataDiskSTATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_STATUS
		err := imageReference.AssignPropertiesFromImageReferenceSTATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReferenceSTATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk_STATUS
		err := osDisk.AssignPropertiesFromOSDiskSTATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOSDiskSTATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToStorageProfileSTATUS populates the provided destination StorageProfile_STATUS from our StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignPropertiesToStorageProfileSTATUS(destination *alpha20201201s.StorageProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]alpha20201201s.DataDisk_STATUS, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk alpha20201201s.DataDisk_STATUS
			err := dataDiskItem.AssignPropertiesToDataDiskSTATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDataDiskSTATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference alpha20201201s.ImageReference_STATUS
		err := profile.ImageReference.AssignPropertiesToImageReferenceSTATUS(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReferenceSTATUS() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk alpha20201201s.OSDisk_STATUS
		err := profile.OsDisk.AssignPropertiesToOSDiskSTATUS(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOSDiskSTATUS() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SubResource. Use v1beta20201201.SubResource instead
type SubResource struct {
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SubResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *SubResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &SubResourceARM{}

	// Set property ‘Id’:
	if resource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*resource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResourceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(SubResourceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResourceARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromSubResource populates our SubResource from the provided source SubResource
func (resource *SubResource) AssignPropertiesFromSubResource(source *alpha20201201s.SubResource) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubResource populates the provided destination SubResource from our SubResource
func (resource *SubResource) AssignPropertiesToSubResource(destination *alpha20201201s.SubResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SubResource_STATUS. Use v1beta20201201.SubResource_STATUS instead
type SubResource_STATUS struct {
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SubResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResource_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SubResource_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResource_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubResourceSTATUS populates our SubResource_STATUS from the provided source SubResource_STATUS
func (resource *SubResource_STATUS) AssignPropertiesFromSubResourceSTATUS(source *alpha20201201s.SubResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToSubResourceSTATUS populates the provided destination SubResource_STATUS from our SubResource_STATUS
func (resource *SubResource_STATUS) AssignPropertiesToSubResourceSTATUS(destination *alpha20201201s.SubResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineExtension_STATUS. Use v1beta20201201.VirtualMachineExtension_STATUS instead
type VirtualMachineExtension_STATUS struct {
	AutoUpgradeMinorVersion *bool                                       `json:"autoUpgradeMinorVersion,omitempty"`
	EnableAutomaticUpgrade  *bool                                       `json:"enableAutomaticUpgrade,omitempty"`
	ForceUpdateTag          *string                                     `json:"forceUpdateTag,omitempty"`
	Id                      *string                                     `json:"id,omitempty"`
	InstanceView            *VirtualMachineExtensionInstanceView_STATUS `json:"instanceView,omitempty"`
	Location                *string                                     `json:"location,omitempty"`
	Name                    *string                                     `json:"name,omitempty"`
	PropertiesType          *string                                     `json:"properties_type,omitempty"`
	ProtectedSettings       map[string]v1.JSON                          `json:"protectedSettings,omitempty"`
	ProvisioningState       *string                                     `json:"provisioningState,omitempty"`
	Publisher               *string                                     `json:"publisher,omitempty"`
	Settings                map[string]v1.JSON                          `json:"settings,omitempty"`
	Tags                    map[string]string                           `json:"tags,omitempty"`
	Type                    *string                                     `json:"type,omitempty"`
	TypeHandlerVersion      *string                                     `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineExtension_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *VirtualMachineExtension_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineExtension_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *VirtualMachineExtension_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineExtension_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineExtension_STATUSARM, got %T", armInput)
	}

	// Set property ‘AutoUpgradeMinorVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// Set property ‘EnableAutomaticUpgrade’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutomaticUpgrade != nil {
			enableAutomaticUpgrade := *typedInput.Properties.EnableAutomaticUpgrade
			extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
		}
	}

	// Set property ‘ForceUpdateTag’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceUpdateTag != nil {
			forceUpdateTag := *typedInput.Properties.ForceUpdateTag
			extension.ForceUpdateTag = &forceUpdateTag
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		extension.Id = &id
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 VirtualMachineExtensionInstanceView_STATUS
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			extension.InstanceView = &instanceView
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		extension.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extension.Name = &name
	}

	// Set property ‘PropertiesType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Type != nil {
			propertiesType := *typedInput.Properties.Type
			extension.PropertiesType = &propertiesType
		}
	}

	// Set property ‘ProtectedSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProtectedSettings != nil {
			extension.ProtectedSettings = make(map[string]v1.JSON, len(typedInput.Properties.ProtectedSettings))
			for key, value := range typedInput.Properties.ProtectedSettings {
				extension.ProtectedSettings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			extension.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Publisher’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Publisher != nil {
			publisher := *typedInput.Properties.Publisher
			extension.Publisher = &publisher
		}
	}

	// Set property ‘Settings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Settings != nil {
			extension.Settings = make(map[string]v1.JSON, len(typedInput.Properties.Settings))
			for key, value := range typedInput.Properties.Settings {
				extension.Settings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		extension.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			extension.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extension.Type = &typeVar
	}

	// Set property ‘TypeHandlerVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TypeHandlerVersion != nil {
			typeHandlerVersion := *typedInput.Properties.TypeHandlerVersion
			extension.TypeHandlerVersion = &typeHandlerVersion
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineExtensionSTATUS populates our VirtualMachineExtension_STATUS from the provided source VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignPropertiesFromVirtualMachineExtensionSTATUS(source *alpha20201201s.VirtualMachineExtension_STATUS) error {

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineExtensionInstanceView_STATUS
		err := instanceView.AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS() to populate field InstanceView")
		}
		extension.InstanceView = &instanceView
	} else {
		extension.InstanceView = nil
	}

	// Location
	extension.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// PropertiesType
	extension.PropertiesType = genruntime.ClonePointerToString(source.PropertiesType)

	// ProtectedSettings
	if source.ProtectedSettings != nil {
		protectedSettingMap := make(map[string]v1.JSON, len(source.ProtectedSettings))
		for protectedSettingKey, protectedSettingValue := range source.ProtectedSettings {
			// Shadow the loop variable to avoid aliasing
			protectedSettingValue := protectedSettingValue
			protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
		}
		extension.ProtectedSettings = protectedSettingMap
	} else {
		extension.ProtectedSettings = nil
	}

	// ProvisioningState
	extension.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// Tags
	extension.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionSTATUS populates the provided destination VirtualMachineExtension_STATUS from our VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignPropertiesToVirtualMachineExtensionSTATUS(destination *alpha20201201s.VirtualMachineExtension_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// InstanceView
	if extension.InstanceView != nil {
		var instanceView alpha20201201s.VirtualMachineExtensionInstanceView_STATUS
		err := extension.InstanceView.AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(extension.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// PropertiesType
	destination.PropertiesType = genruntime.ClonePointerToString(extension.PropertiesType)

	// ProtectedSettings
	if extension.ProtectedSettings != nil {
		protectedSettingMap := make(map[string]v1.JSON, len(extension.ProtectedSettings))
		for protectedSettingKey, protectedSettingValue := range extension.ProtectedSettings {
			// Shadow the loop variable to avoid aliasing
			protectedSettingValue := protectedSettingValue
			protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
		}
		destination.ProtectedSettings = protectedSettingMap
	} else {
		destination.ProtectedSettings = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(extension.ProvisioningState)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(extension.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineIdentity. Use v1beta20201201.VirtualMachineIdentity instead
type VirtualMachineIdentity struct {
	Type *VirtualMachineIdentityType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *VirtualMachineIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &VirtualMachineIdentityARM{}

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineIdentityARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineIdentity populates our VirtualMachineIdentity from the provided source VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignPropertiesFromVirtualMachineIdentity(source *alpha20201201s.VirtualMachineIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineIdentityType(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineIdentity populates the provided destination VirtualMachineIdentity from our VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignPropertiesToVirtualMachineIdentity(destination *alpha20201201s.VirtualMachineIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineIdentity_STATUS. Use v1beta20201201.VirtualMachineIdentity_STATUS instead
type VirtualMachineIdentity_STATUS struct {
	PrincipalId *string                           `json:"principalId,omitempty"`
	TenantId    *string                           `json:"tenantId,omitempty"`
	Type        *VirtualMachineIdentitySTATUSType `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineIdentity_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineIdentity_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineIdentity_STATUSARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineIdentitySTATUS populates our VirtualMachineIdentity_STATUS from the provided source VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignPropertiesFromVirtualMachineIdentitySTATUS(source *alpha20201201s.VirtualMachineIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineIdentitySTATUSType(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineIdentitySTATUS populates the provided destination VirtualMachineIdentity_STATUS from our VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignPropertiesToVirtualMachineIdentitySTATUS(destination *alpha20201201s.VirtualMachineIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineInstanceView_STATUS. Use v1beta20201201.VirtualMachineInstanceView_STATUS instead
type VirtualMachineInstanceView_STATUS struct {
	AssignedHost              *string                                           `json:"assignedHost,omitempty"`
	BootDiagnostics           *BootDiagnosticsInstanceView_STATUS               `json:"bootDiagnostics,omitempty"`
	ComputerName              *string                                           `json:"computerName,omitempty"`
	Disks                     []DiskInstanceView_STATUS                         `json:"disks,omitempty"`
	Extensions                []VirtualMachineExtensionInstanceView_STATUS      `json:"extensions,omitempty"`
	HyperVGeneration          *VirtualMachineInstanceViewSTATUSHyperVGeneration `json:"hyperVGeneration,omitempty"`
	MaintenanceRedeployStatus *MaintenanceRedeployStatus_STATUS                 `json:"maintenanceRedeployStatus,omitempty"`
	OsName                    *string                                           `json:"osName,omitempty"`
	OsVersion                 *string                                           `json:"osVersion,omitempty"`
	PatchStatus               *VirtualMachinePatchStatus_STATUS                 `json:"patchStatus,omitempty"`
	PlatformFaultDomain       *int                                              `json:"platformFaultDomain,omitempty"`
	PlatformUpdateDomain      *int                                              `json:"platformUpdateDomain,omitempty"`
	RdpThumbPrint             *string                                           `json:"rdpThumbPrint,omitempty"`
	Statuses                  []InstanceViewStatus_STATUS                       `json:"statuses,omitempty"`
	VmAgent                   *VirtualMachineAgentInstanceView_STATUS           `json:"vmAgent,omitempty"`
	VmHealth                  *VirtualMachineHealthStatus_STATUS                `json:"vmHealth,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *VirtualMachineInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineInstanceView_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *VirtualMachineInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineInstanceView_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineInstanceView_STATUSARM, got %T", armInput)
	}

	// Set property ‘AssignedHost’:
	if typedInput.AssignedHost != nil {
		assignedHost := *typedInput.AssignedHost
		view.AssignedHost = &assignedHost
	}

	// Set property ‘BootDiagnostics’:
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnosticsInstanceView_STATUS
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		view.BootDiagnostics = &bootDiagnostics
	}

	// Set property ‘ComputerName’:
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		view.ComputerName = &computerName
	}

	// Set property ‘Disks’:
	for _, item := range typedInput.Disks {
		var item1 DiskInstanceView_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Disks = append(view.Disks, item1)
	}

	// Set property ‘Extensions’:
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineExtensionInstanceView_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Extensions = append(view.Extensions, item1)
	}

	// Set property ‘HyperVGeneration’:
	if typedInput.HyperVGeneration != nil {
		hyperVGeneration := *typedInput.HyperVGeneration
		view.HyperVGeneration = &hyperVGeneration
	}

	// Set property ‘MaintenanceRedeployStatus’:
	if typedInput.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus1 MaintenanceRedeployStatus_STATUS
		err := maintenanceRedeployStatus1.PopulateFromARM(owner, *typedInput.MaintenanceRedeployStatus)
		if err != nil {
			return err
		}
		maintenanceRedeployStatus := maintenanceRedeployStatus1
		view.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	}

	// Set property ‘OsName’:
	if typedInput.OsName != nil {
		osName := *typedInput.OsName
		view.OsName = &osName
	}

	// Set property ‘OsVersion’:
	if typedInput.OsVersion != nil {
		osVersion := *typedInput.OsVersion
		view.OsVersion = &osVersion
	}

	// Set property ‘PatchStatus’:
	if typedInput.PatchStatus != nil {
		var patchStatus1 VirtualMachinePatchStatus_STATUS
		err := patchStatus1.PopulateFromARM(owner, *typedInput.PatchStatus)
		if err != nil {
			return err
		}
		patchStatus := patchStatus1
		view.PatchStatus = &patchStatus
	}

	// Set property ‘PlatformFaultDomain’:
	if typedInput.PlatformFaultDomain != nil {
		platformFaultDomain := *typedInput.PlatformFaultDomain
		view.PlatformFaultDomain = &platformFaultDomain
	}

	// Set property ‘PlatformUpdateDomain’:
	if typedInput.PlatformUpdateDomain != nil {
		platformUpdateDomain := *typedInput.PlatformUpdateDomain
		view.PlatformUpdateDomain = &platformUpdateDomain
	}

	// Set property ‘RdpThumbPrint’:
	if typedInput.RdpThumbPrint != nil {
		rdpThumbPrint := *typedInput.RdpThumbPrint
		view.RdpThumbPrint = &rdpThumbPrint
	}

	// Set property ‘Statuses’:
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Statuses = append(view.Statuses, item1)
	}

	// Set property ‘VmAgent’:
	if typedInput.VmAgent != nil {
		var vmAgent1 VirtualMachineAgentInstanceView_STATUS
		err := vmAgent1.PopulateFromARM(owner, *typedInput.VmAgent)
		if err != nil {
			return err
		}
		vmAgent := vmAgent1
		view.VmAgent = &vmAgent
	}

	// Set property ‘VmHealth’:
	if typedInput.VmHealth != nil {
		var vmHealth1 VirtualMachineHealthStatus_STATUS
		err := vmHealth1.PopulateFromARM(owner, *typedInput.VmHealth)
		if err != nil {
			return err
		}
		vmHealth := vmHealth1
		view.VmHealth = &vmHealth
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineInstanceViewSTATUS populates our VirtualMachineInstanceView_STATUS from the provided source VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignPropertiesFromVirtualMachineInstanceViewSTATUS(source *alpha20201201s.VirtualMachineInstanceView_STATUS) error {

	// AssignedHost
	view.AssignedHost = genruntime.ClonePointerToString(source.AssignedHost)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnosticsInstanceView_STATUS
		err := bootDiagnostic.AssignPropertiesFromBootDiagnosticsInstanceViewSTATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBootDiagnosticsInstanceViewSTATUS() to populate field BootDiagnostics")
		}
		view.BootDiagnostics = &bootDiagnostic
	} else {
		view.BootDiagnostics = nil
	}

	// ComputerName
	view.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// Disks
	if source.Disks != nil {
		diskList := make([]DiskInstanceView_STATUS, len(source.Disks))
		for diskIndex, diskItem := range source.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk DiskInstanceView_STATUS
			err := disk.AssignPropertiesFromDiskInstanceViewSTATUS(&diskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDiskInstanceViewSTATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		view.Disks = diskList
	} else {
		view.Disks = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineExtensionInstanceView_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineExtensionInstanceView_STATUS
			err := extension.AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		view.Extensions = extensionList
	} else {
		view.Extensions = nil
	}

	// HyperVGeneration
	if source.HyperVGeneration != nil {
		hyperVGeneration := VirtualMachineInstanceViewSTATUSHyperVGeneration(*source.HyperVGeneration)
		view.HyperVGeneration = &hyperVGeneration
	} else {
		view.HyperVGeneration = nil
	}

	// MaintenanceRedeployStatus
	if source.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus MaintenanceRedeployStatus_STATUS
		err := maintenanceRedeployStatus.AssignPropertiesFromMaintenanceRedeployStatusSTATUS(source.MaintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromMaintenanceRedeployStatusSTATUS() to populate field MaintenanceRedeployStatus")
		}
		view.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		view.MaintenanceRedeployStatus = nil
	}

	// OsName
	view.OsName = genruntime.ClonePointerToString(source.OsName)

	// OsVersion
	view.OsVersion = genruntime.ClonePointerToString(source.OsVersion)

	// PatchStatus
	if source.PatchStatus != nil {
		var patchStatus VirtualMachinePatchStatus_STATUS
		err := patchStatus.AssignPropertiesFromVirtualMachinePatchStatusSTATUS(source.PatchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinePatchStatusSTATUS() to populate field PatchStatus")
		}
		view.PatchStatus = &patchStatus
	} else {
		view.PatchStatus = nil
	}

	// PlatformFaultDomain
	view.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// PlatformUpdateDomain
	view.PlatformUpdateDomain = genruntime.ClonePointerToInt(source.PlatformUpdateDomain)

	// RdpThumbPrint
	view.RdpThumbPrint = genruntime.ClonePointerToString(source.RdpThumbPrint)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignPropertiesFromInstanceViewStatusSTATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgent
	if source.VmAgent != nil {
		var vmAgent VirtualMachineAgentInstanceView_STATUS
		err := vmAgent.AssignPropertiesFromVirtualMachineAgentInstanceViewSTATUS(source.VmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineAgentInstanceViewSTATUS() to populate field VmAgent")
		}
		view.VmAgent = &vmAgent
	} else {
		view.VmAgent = nil
	}

	// VmHealth
	if source.VmHealth != nil {
		var vmHealth VirtualMachineHealthStatus_STATUS
		err := vmHealth.AssignPropertiesFromVirtualMachineHealthStatusSTATUS(source.VmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineHealthStatusSTATUS() to populate field VmHealth")
		}
		view.VmHealth = &vmHealth
	} else {
		view.VmHealth = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineInstanceViewSTATUS populates the provided destination VirtualMachineInstanceView_STATUS from our VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignPropertiesToVirtualMachineInstanceViewSTATUS(destination *alpha20201201s.VirtualMachineInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssignedHost
	destination.AssignedHost = genruntime.ClonePointerToString(view.AssignedHost)

	// BootDiagnostics
	if view.BootDiagnostics != nil {
		var bootDiagnostic alpha20201201s.BootDiagnosticsInstanceView_STATUS
		err := view.BootDiagnostics.AssignPropertiesToBootDiagnosticsInstanceViewSTATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBootDiagnosticsInstanceViewSTATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(view.ComputerName)

	// Disks
	if view.Disks != nil {
		diskList := make([]alpha20201201s.DiskInstanceView_STATUS, len(view.Disks))
		for diskIndex, diskItem := range view.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk alpha20201201s.DiskInstanceView_STATUS
			err := diskItem.AssignPropertiesToDiskInstanceViewSTATUS(&disk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDiskInstanceViewSTATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		destination.Disks = diskList
	} else {
		destination.Disks = nil
	}

	// Extensions
	if view.Extensions != nil {
		extensionList := make([]alpha20201201s.VirtualMachineExtensionInstanceView_STATUS, len(view.Extensions))
		for extensionIndex, extensionItem := range view.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension alpha20201201s.VirtualMachineExtensionInstanceView_STATUS
			err := extensionItem.AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// HyperVGeneration
	if view.HyperVGeneration != nil {
		hyperVGeneration := string(*view.HyperVGeneration)
		destination.HyperVGeneration = &hyperVGeneration
	} else {
		destination.HyperVGeneration = nil
	}

	// MaintenanceRedeployStatus
	if view.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus alpha20201201s.MaintenanceRedeployStatus_STATUS
		err := view.MaintenanceRedeployStatus.AssignPropertiesToMaintenanceRedeployStatusSTATUS(&maintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToMaintenanceRedeployStatusSTATUS() to populate field MaintenanceRedeployStatus")
		}
		destination.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		destination.MaintenanceRedeployStatus = nil
	}

	// OsName
	destination.OsName = genruntime.ClonePointerToString(view.OsName)

	// OsVersion
	destination.OsVersion = genruntime.ClonePointerToString(view.OsVersion)

	// PatchStatus
	if view.PatchStatus != nil {
		var patchStatus alpha20201201s.VirtualMachinePatchStatus_STATUS
		err := view.PatchStatus.AssignPropertiesToVirtualMachinePatchStatusSTATUS(&patchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinePatchStatusSTATUS() to populate field PatchStatus")
		}
		destination.PatchStatus = &patchStatus
	} else {
		destination.PatchStatus = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(view.PlatformFaultDomain)

	// PlatformUpdateDomain
	destination.PlatformUpdateDomain = genruntime.ClonePointerToInt(view.PlatformUpdateDomain)

	// RdpThumbPrint
	destination.RdpThumbPrint = genruntime.ClonePointerToString(view.RdpThumbPrint)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]alpha20201201s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status alpha20201201s.InstanceViewStatus_STATUS
			err := statusItem.AssignPropertiesToInstanceViewStatusSTATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgent
	if view.VmAgent != nil {
		var vmAgent alpha20201201s.VirtualMachineAgentInstanceView_STATUS
		err := view.VmAgent.AssignPropertiesToVirtualMachineAgentInstanceViewSTATUS(&vmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineAgentInstanceViewSTATUS() to populate field VmAgent")
		}
		destination.VmAgent = &vmAgent
	} else {
		destination.VmAgent = nil
	}

	// VmHealth
	if view.VmHealth != nil {
		var vmHealth alpha20201201s.VirtualMachineHealthStatus_STATUS
		err := view.VmHealth.AssignPropertiesToVirtualMachineHealthStatusSTATUS(&vmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineHealthStatusSTATUS() to populate field VmHealth")
		}
		destination.VmHealth = &vmHealth
	} else {
		destination.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachines_Spec_Properties_NetworkProfile. Use v1beta20201201.VirtualMachines_Spec_Properties_NetworkProfile instead
type VirtualMachines_Spec_Properties_NetworkProfile struct {
	NetworkInterfaces []VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces `json:"networkInterfaces,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachines_Spec_Properties_NetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachines_Spec_Properties_NetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachines_Spec_Properties_NetworkProfileARM{}

	// Set property ‘NetworkInterfaces’:
	for _, item := range profile.NetworkInterfaces {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaces = append(result.NetworkInterfaces, *itemARM.(*VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachines_Spec_Properties_NetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachines_Spec_Properties_NetworkProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachines_Spec_Properties_NetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachines_Spec_Properties_NetworkProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachines_Spec_Properties_NetworkProfileARM, got %T", armInput)
	}

	// Set property ‘NetworkInterfaces’:
	for _, item := range typedInput.NetworkInterfaces {
		var item1 VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaces = append(profile.NetworkInterfaces, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile populates our VirtualMachines_Spec_Properties_NetworkProfile from the provided source VirtualMachines_Spec_Properties_NetworkProfile
func (profile *VirtualMachines_Spec_Properties_NetworkProfile) AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile(source *alpha20201201s.VirtualMachines_Spec_Properties_NetworkProfile) error {

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
			err := networkInterface.AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile populates the provided destination VirtualMachines_Spec_Properties_NetworkProfile from our VirtualMachines_Spec_Properties_NetworkProfile
func (profile *VirtualMachines_Spec_Properties_NetworkProfile) AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile(destination *alpha20201201s.VirtualMachines_Spec_Properties_NetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]alpha20201201s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface alpha20201201s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
			err := networkInterfaceItem.AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachines_Spec_Properties_OsProfile. Use v1beta20201201.VirtualMachines_Spec_Properties_OsProfile instead
type VirtualMachines_Spec_Properties_OsProfile struct {
	AdminPassword               *genruntime.SecretReference `json:"adminPassword,omitempty"`
	AdminUsername               *string                     `json:"adminUsername,omitempty"`
	AllowExtensionOperations    *bool                       `json:"allowExtensionOperations,omitempty"`
	ComputerName                *string                     `json:"computerName,omitempty"`
	CustomData                  *string                     `json:"customData,omitempty"`
	LinuxConfiguration          *LinuxConfiguration         `json:"linuxConfiguration,omitempty"`
	RequireGuestProvisionSignal *bool                       `json:"requireGuestProvisionSignal,omitempty"`
	Secrets                     []VaultSecretGroup          `json:"secrets,omitempty"`
	WindowsConfiguration        *WindowsConfiguration       `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachines_Spec_Properties_OsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachines_Spec_Properties_OsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachines_Spec_Properties_OsProfileARM{}

	// Set property ‘AdminPassword’:
	if profile.AdminPassword != nil {
		adminPasswordSecret, err := resolved.ResolvedSecrets.LookupSecret(*profile.AdminPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminPassword")
		}
		adminPassword := adminPasswordSecret
		result.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property ‘AllowExtensionOperations’:
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperations := *profile.AllowExtensionOperations
		result.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property ‘ComputerName’:
	if profile.ComputerName != nil {
		computerName := *profile.ComputerName
		result.ComputerName = &computerName
	}

	// Set property ‘CustomData’:
	if profile.CustomData != nil {
		customData := *profile.CustomData
		result.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if profile.LinuxConfiguration != nil {
		linuxConfigurationARM, err := (*profile.LinuxConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxConfiguration := *linuxConfigurationARM.(*LinuxConfigurationARM)
		result.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘RequireGuestProvisionSignal’:
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		result.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property ‘Secrets’:
	for _, item := range profile.Secrets {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, *itemARM.(*VaultSecretGroupARM))
	}

	// Set property ‘WindowsConfiguration’:
	if profile.WindowsConfiguration != nil {
		windowsConfigurationARM, err := (*profile.WindowsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsConfiguration := *windowsConfigurationARM.(*WindowsConfigurationARM)
		result.WindowsConfiguration = &windowsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachines_Spec_Properties_OsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachines_Spec_Properties_OsProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachines_Spec_Properties_OsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachines_Spec_Properties_OsProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachines_Spec_Properties_OsProfileARM, got %T", armInput)
	}

	// no assignment for property ‘AdminPassword’

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property ‘AllowExtensionOperations’:
	if typedInput.AllowExtensionOperations != nil {
		allowExtensionOperations := *typedInput.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property ‘ComputerName’:
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		profile.ComputerName = &computerName
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘RequireGuestProvisionSignal’:
	if typedInput.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *typedInput.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachinesSpecPropertiesOsProfile populates our VirtualMachines_Spec_Properties_OsProfile from the provided source VirtualMachines_Spec_Properties_OsProfile
func (profile *VirtualMachines_Spec_Properties_OsProfile) AssignPropertiesFromVirtualMachinesSpecPropertiesOsProfile(source *alpha20201201s.VirtualMachines_Spec_Properties_OsProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignPropertiesFromLinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignPropertiesFromVaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignPropertiesFromWindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpecPropertiesOsProfile populates the provided destination VirtualMachines_Spec_Properties_OsProfile from our VirtualMachines_Spec_Properties_OsProfile
func (profile *VirtualMachines_Spec_Properties_OsProfile) AssignPropertiesToVirtualMachinesSpecPropertiesOsProfile(destination *alpha20201201s.VirtualMachines_Spec_Properties_OsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration alpha20201201s.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]alpha20201201s.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret alpha20201201s.VaultSecretGroup
			err := secretItem.AssignPropertiesToVaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration alpha20201201s.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachinesSpecPropertiesEvictionPolicy. Use
// v1beta20201201.VirtualMachinesSpecPropertiesEvictionPolicy instead
// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type VirtualMachinesSpecPropertiesEvictionPolicy string

const (
	VirtualMachinesSpecPropertiesEvictionPolicy_Deallocate = VirtualMachinesSpecPropertiesEvictionPolicy("Deallocate")
	VirtualMachinesSpecPropertiesEvictionPolicy_Delete     = VirtualMachinesSpecPropertiesEvictionPolicy("Delete")
)

// Deprecated version of VirtualMachinesSpecPropertiesPriority. Use v1beta20201201.VirtualMachinesSpecPropertiesPriority
// instead
// +kubebuilder:validation:Enum={"Low","Regular","Spot"}
type VirtualMachinesSpecPropertiesPriority string

const (
	VirtualMachinesSpecPropertiesPriority_Low     = VirtualMachinesSpecPropertiesPriority("Low")
	VirtualMachinesSpecPropertiesPriority_Regular = VirtualMachinesSpecPropertiesPriority("Regular")
	VirtualMachinesSpecPropertiesPriority_Spot    = VirtualMachinesSpecPropertiesPriority("Spot")
)

// Deprecated version of BootDiagnostics. Use v1beta20201201.BootDiagnostics instead
type BootDiagnostics struct {
	Enabled    *bool   `json:"enabled,omitempty"`
	StorageUri *string `json:"storageUri,omitempty"`
}

var _ genruntime.ARMTransformer = &BootDiagnostics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diagnostics *BootDiagnostics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diagnostics == nil {
		return nil, nil
	}
	result := &BootDiagnosticsARM{}

	// Set property ‘Enabled’:
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if diagnostics.StorageUri != nil {
		storageUri := *diagnostics.StorageUri
		result.StorageUri = &storageUri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *BootDiagnostics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BootDiagnosticsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *BootDiagnostics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BootDiagnosticsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BootDiagnosticsARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		diagnostics.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if typedInput.StorageUri != nil {
		storageUri := *typedInput.StorageUri
		diagnostics.StorageUri = &storageUri
	}

	// No error
	return nil
}

// AssignPropertiesFromBootDiagnostics populates our BootDiagnostics from the provided source BootDiagnostics
func (diagnostics *BootDiagnostics) AssignPropertiesFromBootDiagnostics(source *alpha20201201s.BootDiagnostics) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// No error
	return nil
}

// AssignPropertiesToBootDiagnostics populates the provided destination BootDiagnostics from our BootDiagnostics
func (diagnostics *BootDiagnostics) AssignPropertiesToBootDiagnostics(destination *alpha20201201s.BootDiagnostics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of BootDiagnostics_STATUS. Use v1beta20201201.BootDiagnostics_STATUS instead
type BootDiagnostics_STATUS struct {
	Enabled    *bool   `json:"enabled,omitempty"`
	StorageUri *string `json:"storageUri,omitempty"`
}

var _ genruntime.FromARMConverter = &BootDiagnostics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *BootDiagnostics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BootDiagnostics_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *BootDiagnostics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BootDiagnostics_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BootDiagnostics_STATUSARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		diagnostics.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if typedInput.StorageUri != nil {
		storageUri := *typedInput.StorageUri
		diagnostics.StorageUri = &storageUri
	}

	// No error
	return nil
}

// AssignPropertiesFromBootDiagnosticsSTATUS populates our BootDiagnostics_STATUS from the provided source BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignPropertiesFromBootDiagnosticsSTATUS(source *alpha20201201s.BootDiagnostics_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// No error
	return nil
}

// AssignPropertiesToBootDiagnosticsSTATUS populates the provided destination BootDiagnostics_STATUS from our BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignPropertiesToBootDiagnosticsSTATUS(destination *alpha20201201s.BootDiagnostics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of BootDiagnosticsInstanceView_STATUS. Use v1beta20201201.BootDiagnosticsInstanceView_STATUS instead
type BootDiagnosticsInstanceView_STATUS struct {
	ConsoleScreenshotBlobUri *string                    `json:"consoleScreenshotBlobUri,omitempty"`
	SerialConsoleLogBlobUri  *string                    `json:"serialConsoleLogBlobUri,omitempty"`
	Status                   *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &BootDiagnosticsInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *BootDiagnosticsInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BootDiagnosticsInstanceView_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *BootDiagnosticsInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BootDiagnosticsInstanceView_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BootDiagnosticsInstanceView_STATUSARM, got %T", armInput)
	}

	// Set property ‘ConsoleScreenshotBlobUri’:
	if typedInput.ConsoleScreenshotBlobUri != nil {
		consoleScreenshotBlobUri := *typedInput.ConsoleScreenshotBlobUri
		view.ConsoleScreenshotBlobUri = &consoleScreenshotBlobUri
	}

	// Set property ‘SerialConsoleLogBlobUri’:
	if typedInput.SerialConsoleLogBlobUri != nil {
		serialConsoleLogBlobUri := *typedInput.SerialConsoleLogBlobUri
		view.SerialConsoleLogBlobUri = &serialConsoleLogBlobUri
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		var status1 InstanceViewStatus_STATUS
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		view.Status = &status
	}

	// No error
	return nil
}

// AssignPropertiesFromBootDiagnosticsInstanceViewSTATUS populates our BootDiagnosticsInstanceView_STATUS from the provided source BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignPropertiesFromBootDiagnosticsInstanceViewSTATUS(source *alpha20201201s.BootDiagnosticsInstanceView_STATUS) error {

	// ConsoleScreenshotBlobUri
	view.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(source.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	view.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(source.SerialConsoleLogBlobUri)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignPropertiesFromInstanceViewStatusSTATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBootDiagnosticsInstanceViewSTATUS populates the provided destination BootDiagnosticsInstanceView_STATUS from our BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignPropertiesToBootDiagnosticsInstanceViewSTATUS(destination *alpha20201201s.BootDiagnosticsInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsoleScreenshotBlobUri
	destination.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(view.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	destination.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(view.SerialConsoleLogBlobUri)

	// Status
	if view.Status != nil {
		var status alpha20201201s.InstanceViewStatus_STATUS
		err := view.Status.AssignPropertiesToInstanceViewStatusSTATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of DataDisk. Use v1beta20201201.DataDisk instead
type DataDisk struct {
	Caching *DataDiskCaching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	CreateOption *DataDiskCreateOption `json:"createOption,omitempty"`
	DetachOption *DataDiskDetachOption `json:"detachOption,omitempty"`
	DiskSizeGB   *int                  `json:"diskSizeGB,omitempty"`
	Image        *VirtualHardDisk      `json:"image,omitempty"`

	// +kubebuilder:validation:Required
	Lun                     *int                   `json:"lun,omitempty"`
	ManagedDisk             *ManagedDiskParameters `json:"managedDisk,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	ToBeDetached            *bool                  `json:"toBeDetached,omitempty"`
	Vhd                     *VirtualHardDisk       `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                  `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &DataDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *DataDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &DataDiskARM{}

	// Set property ‘Caching’:
	if disk.Caching != nil {
		caching := *disk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if disk.CreateOption != nil {
		createOption := *disk.CreateOption
		result.CreateOption = &createOption
	}

	// Set property ‘DetachOption’:
	if disk.DetachOption != nil {
		detachOption := *disk.DetachOption
		result.DetachOption = &detachOption
	}

	// Set property ‘DiskSizeGB’:
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if disk.Image != nil {
		imageARM, err := (*disk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := *imageARM.(*VirtualHardDiskARM)
		result.Image = &image
	}

	// Set property ‘Lun’:
	if disk.Lun != nil {
		lun := *disk.Lun
		result.Lun = &lun
	}

	// Set property ‘ManagedDisk’:
	if disk.ManagedDisk != nil {
		managedDiskARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDiskARM.(*ManagedDiskParametersARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property ‘ToBeDetached’:
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		result.ToBeDetached = &toBeDetached
	}

	// Set property ‘Vhd’:
	if disk.Vhd != nil {
		vhdARM, err := (*disk.Vhd).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vhd := *vhdARM.(*VirtualHardDiskARM)
		result.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *DataDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *DataDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataDiskARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if typedInput.CreateOption != nil {
		createOption := *typedInput.CreateOption
		disk.CreateOption = &createOption
	}

	// Set property ‘DetachOption’:
	if typedInput.DetachOption != nil {
		detachOption := *typedInput.DetachOption
		disk.DetachOption = &detachOption
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property ‘Lun’:
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘ToBeDetached’:
	if typedInput.ToBeDetached != nil {
		toBeDetached := *typedInput.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	}

	// Set property ‘Vhd’:
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		disk.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromDataDisk populates our DataDisk from the provided source DataDisk
func (disk *DataDisk) AssignPropertiesFromDataDisk(source *alpha20201201s.DataDisk) error {

	// Caching
	if source.Caching != nil {
		caching := DataDiskCaching(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := DataDiskCreateOption(*source.CreateOption)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DetachOption
	if source.DetachOption != nil {
		detachOption := DataDiskDetachOption(*source.DetachOption)
		disk.DetachOption = &detachOption
	} else {
		disk.DetachOption = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignPropertiesFromVirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignPropertiesFromManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignPropertiesFromVirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDataDisk populates the provided destination DataDisk from our DataDisk
func (disk *DataDisk) AssignPropertiesToDataDisk(destination *alpha20201201s.DataDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DetachOption
	if disk.DetachOption != nil {
		detachOption := string(*disk.DetachOption)
		destination.DetachOption = &detachOption
	} else {
		destination.DetachOption = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image alpha20201201s.VirtualHardDisk
		err := disk.Image.AssignPropertiesToVirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk alpha20201201s.ManagedDiskParameters
		err := disk.ManagedDisk.AssignPropertiesToManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd alpha20201201s.VirtualHardDisk
		err := disk.Vhd.AssignPropertiesToVirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of DataDisk_STATUS. Use v1beta20201201.DataDisk_STATUS instead
type DataDisk_STATUS struct {
	Caching                 *Caching_STATUS               `json:"caching,omitempty"`
	CreateOption            *CreateOption_STATUS          `json:"createOption,omitempty"`
	DetachOption            *DetachOption_STATUS          `json:"detachOption,omitempty"`
	DiskIOPSReadWrite       *int                          `json:"diskIOPSReadWrite,omitempty"`
	DiskMBpsReadWrite       *int                          `json:"diskMBpsReadWrite,omitempty"`
	DiskSizeGB              *int                          `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk_STATUS       `json:"image,omitempty"`
	Lun                     *int                          `json:"lun,omitempty"`
	ManagedDisk             *ManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`
	Name                    *string                       `json:"name,omitempty"`
	ToBeDetached            *bool                         `json:"toBeDetached,omitempty"`
	Vhd                     *VirtualHardDisk_STATUS       `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                         `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &DataDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *DataDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataDisk_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *DataDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataDisk_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataDisk_STATUSARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if typedInput.CreateOption != nil {
		createOption := *typedInput.CreateOption
		disk.CreateOption = &createOption
	}

	// Set property ‘DetachOption’:
	if typedInput.DetachOption != nil {
		detachOption := *typedInput.DetachOption
		disk.DetachOption = &detachOption
	}

	// Set property ‘DiskIOPSReadWrite’:
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		disk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		disk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_STATUS
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property ‘Lun’:
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘ToBeDetached’:
	if typedInput.ToBeDetached != nil {
		toBeDetached := *typedInput.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	}

	// Set property ‘Vhd’:
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk_STATUS
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		disk.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromDataDiskSTATUS populates our DataDisk_STATUS from the provided source DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignPropertiesFromDataDiskSTATUS(source *alpha20201201s.DataDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_STATUS(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := CreateOption_STATUS(*source.CreateOption)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DetachOption
	if source.DetachOption != nil {
		detachOption := DetachOption_STATUS(*source.DetachOption)
		disk.DetachOption = &detachOption
	} else {
		disk.DetachOption = nil
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignPropertiesFromVirtualHardDiskSTATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignPropertiesFromManagedDiskParametersSTATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedDiskParametersSTATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignPropertiesFromVirtualHardDiskSTATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDataDiskSTATUS populates the provided destination DataDisk_STATUS from our DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignPropertiesToDataDiskSTATUS(destination *alpha20201201s.DataDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DetachOption
	if disk.DetachOption != nil {
		detachOption := string(*disk.DetachOption)
		destination.DetachOption = &detachOption
	} else {
		destination.DetachOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image alpha20201201s.VirtualHardDisk_STATUS
		err := disk.Image.AssignPropertiesToVirtualHardDiskSTATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk alpha20201201s.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignPropertiesToManagedDiskParametersSTATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedDiskParametersSTATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd alpha20201201s.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignPropertiesToVirtualHardDiskSTATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of DiskInstanceView_STATUS. Use v1beta20201201.DiskInstanceView_STATUS instead
type DiskInstanceView_STATUS struct {
	EncryptionSettings []DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	Name               *string                         `json:"name,omitempty"`
	Statuses           []InstanceViewStatus_STATUS     `json:"statuses,omitempty"`
}

var _ genruntime.FromARMConverter = &DiskInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *DiskInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskInstanceView_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *DiskInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiskInstanceView_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskInstanceView_STATUSARM, got %T", armInput)
	}

	// Set property ‘EncryptionSettings’:
	for _, item := range typedInput.EncryptionSettings {
		var item1 DiskEncryptionSettings_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.EncryptionSettings = append(view.EncryptionSettings, item1)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		view.Name = &name
	}

	// Set property ‘Statuses’:
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Statuses = append(view.Statuses, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskInstanceViewSTATUS populates our DiskInstanceView_STATUS from the provided source DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignPropertiesFromDiskInstanceViewSTATUS(source *alpha20201201s.DiskInstanceView_STATUS) error {

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		encryptionSettingList := make([]DiskEncryptionSettings_STATUS, len(source.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range source.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting DiskEncryptionSettings_STATUS
			err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettingsSTATUS(&encryptionSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSettingsSTATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		view.EncryptionSettings = encryptionSettingList
	} else {
		view.EncryptionSettings = nil
	}

	// Name
	view.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignPropertiesFromInstanceViewStatusSTATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskInstanceViewSTATUS populates the provided destination DiskInstanceView_STATUS from our DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignPropertiesToDiskInstanceViewSTATUS(destination *alpha20201201s.DiskInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionSettings
	if view.EncryptionSettings != nil {
		encryptionSettingList := make([]alpha20201201s.DiskEncryptionSettings_STATUS, len(view.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range view.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting alpha20201201s.DiskEncryptionSettings_STATUS
			err := encryptionSettingItem.AssignPropertiesToDiskEncryptionSettingsSTATUS(&encryptionSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSettingsSTATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		destination.EncryptionSettings = encryptionSettingList
	} else {
		destination.EncryptionSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(view.Name)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]alpha20201201s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status alpha20201201s.InstanceViewStatus_STATUS
			err := statusItem.AssignPropertiesToInstanceViewStatusSTATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of HardwareProfileSTATUSVmSize. Use v1beta20201201.HardwareProfileSTATUSVmSize instead
type HardwareProfileSTATUSVmSize string

const (
	HardwareProfileSTATUSVmSize_BasicA0          = HardwareProfileSTATUSVmSize("Basic_A0")
	HardwareProfileSTATUSVmSize_BasicA1          = HardwareProfileSTATUSVmSize("Basic_A1")
	HardwareProfileSTATUSVmSize_BasicA2          = HardwareProfileSTATUSVmSize("Basic_A2")
	HardwareProfileSTATUSVmSize_BasicA3          = HardwareProfileSTATUSVmSize("Basic_A3")
	HardwareProfileSTATUSVmSize_BasicA4          = HardwareProfileSTATUSVmSize("Basic_A4")
	HardwareProfileSTATUSVmSize_StandardA0       = HardwareProfileSTATUSVmSize("Standard_A0")
	HardwareProfileSTATUSVmSize_StandardA1       = HardwareProfileSTATUSVmSize("Standard_A1")
	HardwareProfileSTATUSVmSize_StandardA10      = HardwareProfileSTATUSVmSize("Standard_A10")
	HardwareProfileSTATUSVmSize_StandardA11      = HardwareProfileSTATUSVmSize("Standard_A11")
	HardwareProfileSTATUSVmSize_StandardA1V2     = HardwareProfileSTATUSVmSize("Standard_A1_v2")
	HardwareProfileSTATUSVmSize_StandardA2       = HardwareProfileSTATUSVmSize("Standard_A2")
	HardwareProfileSTATUSVmSize_StandardA2MV2    = HardwareProfileSTATUSVmSize("Standard_A2m_v2")
	HardwareProfileSTATUSVmSize_StandardA2V2     = HardwareProfileSTATUSVmSize("Standard_A2_v2")
	HardwareProfileSTATUSVmSize_StandardA3       = HardwareProfileSTATUSVmSize("Standard_A3")
	HardwareProfileSTATUSVmSize_StandardA4       = HardwareProfileSTATUSVmSize("Standard_A4")
	HardwareProfileSTATUSVmSize_StandardA4MV2    = HardwareProfileSTATUSVmSize("Standard_A4m_v2")
	HardwareProfileSTATUSVmSize_StandardA4V2     = HardwareProfileSTATUSVmSize("Standard_A4_v2")
	HardwareProfileSTATUSVmSize_StandardA5       = HardwareProfileSTATUSVmSize("Standard_A5")
	HardwareProfileSTATUSVmSize_StandardA6       = HardwareProfileSTATUSVmSize("Standard_A6")
	HardwareProfileSTATUSVmSize_StandardA7       = HardwareProfileSTATUSVmSize("Standard_A7")
	HardwareProfileSTATUSVmSize_StandardA8       = HardwareProfileSTATUSVmSize("Standard_A8")
	HardwareProfileSTATUSVmSize_StandardA8MV2    = HardwareProfileSTATUSVmSize("Standard_A8m_v2")
	HardwareProfileSTATUSVmSize_StandardA8V2     = HardwareProfileSTATUSVmSize("Standard_A8_v2")
	HardwareProfileSTATUSVmSize_StandardA9       = HardwareProfileSTATUSVmSize("Standard_A9")
	HardwareProfileSTATUSVmSize_StandardB1Ms     = HardwareProfileSTATUSVmSize("Standard_B1ms")
	HardwareProfileSTATUSVmSize_StandardB1S      = HardwareProfileSTATUSVmSize("Standard_B1s")
	HardwareProfileSTATUSVmSize_StandardB2Ms     = HardwareProfileSTATUSVmSize("Standard_B2ms")
	HardwareProfileSTATUSVmSize_StandardB2S      = HardwareProfileSTATUSVmSize("Standard_B2s")
	HardwareProfileSTATUSVmSize_StandardB4Ms     = HardwareProfileSTATUSVmSize("Standard_B4ms")
	HardwareProfileSTATUSVmSize_StandardB8Ms     = HardwareProfileSTATUSVmSize("Standard_B8ms")
	HardwareProfileSTATUSVmSize_StandardD1       = HardwareProfileSTATUSVmSize("Standard_D1")
	HardwareProfileSTATUSVmSize_StandardD11      = HardwareProfileSTATUSVmSize("Standard_D11")
	HardwareProfileSTATUSVmSize_StandardD11V2    = HardwareProfileSTATUSVmSize("Standard_D11_v2")
	HardwareProfileSTATUSVmSize_StandardD12      = HardwareProfileSTATUSVmSize("Standard_D12")
	HardwareProfileSTATUSVmSize_StandardD12V2    = HardwareProfileSTATUSVmSize("Standard_D12_v2")
	HardwareProfileSTATUSVmSize_StandardD13      = HardwareProfileSTATUSVmSize("Standard_D13")
	HardwareProfileSTATUSVmSize_StandardD13V2    = HardwareProfileSTATUSVmSize("Standard_D13_v2")
	HardwareProfileSTATUSVmSize_StandardD14      = HardwareProfileSTATUSVmSize("Standard_D14")
	HardwareProfileSTATUSVmSize_StandardD14V2    = HardwareProfileSTATUSVmSize("Standard_D14_v2")
	HardwareProfileSTATUSVmSize_StandardD15V2    = HardwareProfileSTATUSVmSize("Standard_D15_v2")
	HardwareProfileSTATUSVmSize_StandardD16SV3   = HardwareProfileSTATUSVmSize("Standard_D16s_v3")
	HardwareProfileSTATUSVmSize_StandardD16V3    = HardwareProfileSTATUSVmSize("Standard_D16_v3")
	HardwareProfileSTATUSVmSize_StandardD1V2     = HardwareProfileSTATUSVmSize("Standard_D1_v2")
	HardwareProfileSTATUSVmSize_StandardD2       = HardwareProfileSTATUSVmSize("Standard_D2")
	HardwareProfileSTATUSVmSize_StandardD2SV3    = HardwareProfileSTATUSVmSize("Standard_D2s_v3")
	HardwareProfileSTATUSVmSize_StandardD2V2     = HardwareProfileSTATUSVmSize("Standard_D2_v2")
	HardwareProfileSTATUSVmSize_StandardD2V3     = HardwareProfileSTATUSVmSize("Standard_D2_v3")
	HardwareProfileSTATUSVmSize_StandardD3       = HardwareProfileSTATUSVmSize("Standard_D3")
	HardwareProfileSTATUSVmSize_StandardD32SV3   = HardwareProfileSTATUSVmSize("Standard_D32s_v3")
	HardwareProfileSTATUSVmSize_StandardD32V3    = HardwareProfileSTATUSVmSize("Standard_D32_v3")
	HardwareProfileSTATUSVmSize_StandardD3V2     = HardwareProfileSTATUSVmSize("Standard_D3_v2")
	HardwareProfileSTATUSVmSize_StandardD4       = HardwareProfileSTATUSVmSize("Standard_D4")
	HardwareProfileSTATUSVmSize_StandardD4SV3    = HardwareProfileSTATUSVmSize("Standard_D4s_v3")
	HardwareProfileSTATUSVmSize_StandardD4V2     = HardwareProfileSTATUSVmSize("Standard_D4_v2")
	HardwareProfileSTATUSVmSize_StandardD4V3     = HardwareProfileSTATUSVmSize("Standard_D4_v3")
	HardwareProfileSTATUSVmSize_StandardD5V2     = HardwareProfileSTATUSVmSize("Standard_D5_v2")
	HardwareProfileSTATUSVmSize_StandardD64SV3   = HardwareProfileSTATUSVmSize("Standard_D64s_v3")
	HardwareProfileSTATUSVmSize_StandardD64V3    = HardwareProfileSTATUSVmSize("Standard_D64_v3")
	HardwareProfileSTATUSVmSize_StandardD8SV3    = HardwareProfileSTATUSVmSize("Standard_D8s_v3")
	HardwareProfileSTATUSVmSize_StandardD8V3     = HardwareProfileSTATUSVmSize("Standard_D8_v3")
	HardwareProfileSTATUSVmSize_StandardDS1      = HardwareProfileSTATUSVmSize("Standard_DS1")
	HardwareProfileSTATUSVmSize_StandardDS11     = HardwareProfileSTATUSVmSize("Standard_DS11")
	HardwareProfileSTATUSVmSize_StandardDS11V2   = HardwareProfileSTATUSVmSize("Standard_DS11_v2")
	HardwareProfileSTATUSVmSize_StandardDS12     = HardwareProfileSTATUSVmSize("Standard_DS12")
	HardwareProfileSTATUSVmSize_StandardDS12V2   = HardwareProfileSTATUSVmSize("Standard_DS12_v2")
	HardwareProfileSTATUSVmSize_StandardDS13     = HardwareProfileSTATUSVmSize("Standard_DS13")
	HardwareProfileSTATUSVmSize_StandardDS132V2  = HardwareProfileSTATUSVmSize("Standard_DS13-2_v2")
	HardwareProfileSTATUSVmSize_StandardDS134V2  = HardwareProfileSTATUSVmSize("Standard_DS13-4_v2")
	HardwareProfileSTATUSVmSize_StandardDS13V2   = HardwareProfileSTATUSVmSize("Standard_DS13_v2")
	HardwareProfileSTATUSVmSize_StandardDS14     = HardwareProfileSTATUSVmSize("Standard_DS14")
	HardwareProfileSTATUSVmSize_StandardDS144V2  = HardwareProfileSTATUSVmSize("Standard_DS14-4_v2")
	HardwareProfileSTATUSVmSize_StandardDS148V2  = HardwareProfileSTATUSVmSize("Standard_DS14-8_v2")
	HardwareProfileSTATUSVmSize_StandardDS14V2   = HardwareProfileSTATUSVmSize("Standard_DS14_v2")
	HardwareProfileSTATUSVmSize_StandardDS15V2   = HardwareProfileSTATUSVmSize("Standard_DS15_v2")
	HardwareProfileSTATUSVmSize_StandardDS1V2    = HardwareProfileSTATUSVmSize("Standard_DS1_v2")
	HardwareProfileSTATUSVmSize_StandardDS2      = HardwareProfileSTATUSVmSize("Standard_DS2")
	HardwareProfileSTATUSVmSize_StandardDS2V2    = HardwareProfileSTATUSVmSize("Standard_DS2_v2")
	HardwareProfileSTATUSVmSize_StandardDS3      = HardwareProfileSTATUSVmSize("Standard_DS3")
	HardwareProfileSTATUSVmSize_StandardDS3V2    = HardwareProfileSTATUSVmSize("Standard_DS3_v2")
	HardwareProfileSTATUSVmSize_StandardDS4      = HardwareProfileSTATUSVmSize("Standard_DS4")
	HardwareProfileSTATUSVmSize_StandardDS4V2    = HardwareProfileSTATUSVmSize("Standard_DS4_v2")
	HardwareProfileSTATUSVmSize_StandardDS5V2    = HardwareProfileSTATUSVmSize("Standard_DS5_v2")
	HardwareProfileSTATUSVmSize_StandardE16SV3   = HardwareProfileSTATUSVmSize("Standard_E16s_v3")
	HardwareProfileSTATUSVmSize_StandardE16V3    = HardwareProfileSTATUSVmSize("Standard_E16_v3")
	HardwareProfileSTATUSVmSize_StandardE2SV3    = HardwareProfileSTATUSVmSize("Standard_E2s_v3")
	HardwareProfileSTATUSVmSize_StandardE2V3     = HardwareProfileSTATUSVmSize("Standard_E2_v3")
	HardwareProfileSTATUSVmSize_StandardE3216V3  = HardwareProfileSTATUSVmSize("Standard_E32-16_v3")
	HardwareProfileSTATUSVmSize_StandardE328SV3  = HardwareProfileSTATUSVmSize("Standard_E32-8s_v3")
	HardwareProfileSTATUSVmSize_StandardE32SV3   = HardwareProfileSTATUSVmSize("Standard_E32s_v3")
	HardwareProfileSTATUSVmSize_StandardE32V3    = HardwareProfileSTATUSVmSize("Standard_E32_v3")
	HardwareProfileSTATUSVmSize_StandardE4SV3    = HardwareProfileSTATUSVmSize("Standard_E4s_v3")
	HardwareProfileSTATUSVmSize_StandardE4V3     = HardwareProfileSTATUSVmSize("Standard_E4_v3")
	HardwareProfileSTATUSVmSize_StandardE6416SV3 = HardwareProfileSTATUSVmSize("Standard_E64-16s_v3")
	HardwareProfileSTATUSVmSize_StandardE6432SV3 = HardwareProfileSTATUSVmSize("Standard_E64-32s_v3")
	HardwareProfileSTATUSVmSize_StandardE64SV3   = HardwareProfileSTATUSVmSize("Standard_E64s_v3")
	HardwareProfileSTATUSVmSize_StandardE64V3    = HardwareProfileSTATUSVmSize("Standard_E64_v3")
	HardwareProfileSTATUSVmSize_StandardE8SV3    = HardwareProfileSTATUSVmSize("Standard_E8s_v3")
	HardwareProfileSTATUSVmSize_StandardE8V3     = HardwareProfileSTATUSVmSize("Standard_E8_v3")
	HardwareProfileSTATUSVmSize_StandardF1       = HardwareProfileSTATUSVmSize("Standard_F1")
	HardwareProfileSTATUSVmSize_StandardF16      = HardwareProfileSTATUSVmSize("Standard_F16")
	HardwareProfileSTATUSVmSize_StandardF16S     = HardwareProfileSTATUSVmSize("Standard_F16s")
	HardwareProfileSTATUSVmSize_StandardF16SV2   = HardwareProfileSTATUSVmSize("Standard_F16s_v2")
	HardwareProfileSTATUSVmSize_StandardF1S      = HardwareProfileSTATUSVmSize("Standard_F1s")
	HardwareProfileSTATUSVmSize_StandardF2       = HardwareProfileSTATUSVmSize("Standard_F2")
	HardwareProfileSTATUSVmSize_StandardF2S      = HardwareProfileSTATUSVmSize("Standard_F2s")
	HardwareProfileSTATUSVmSize_StandardF2SV2    = HardwareProfileSTATUSVmSize("Standard_F2s_v2")
	HardwareProfileSTATUSVmSize_StandardF32SV2   = HardwareProfileSTATUSVmSize("Standard_F32s_v2")
	HardwareProfileSTATUSVmSize_StandardF4       = HardwareProfileSTATUSVmSize("Standard_F4")
	HardwareProfileSTATUSVmSize_StandardF4S      = HardwareProfileSTATUSVmSize("Standard_F4s")
	HardwareProfileSTATUSVmSize_StandardF4SV2    = HardwareProfileSTATUSVmSize("Standard_F4s_v2")
	HardwareProfileSTATUSVmSize_StandardF64SV2   = HardwareProfileSTATUSVmSize("Standard_F64s_v2")
	HardwareProfileSTATUSVmSize_StandardF72SV2   = HardwareProfileSTATUSVmSize("Standard_F72s_v2")
	HardwareProfileSTATUSVmSize_StandardF8       = HardwareProfileSTATUSVmSize("Standard_F8")
	HardwareProfileSTATUSVmSize_StandardF8S      = HardwareProfileSTATUSVmSize("Standard_F8s")
	HardwareProfileSTATUSVmSize_StandardF8SV2    = HardwareProfileSTATUSVmSize("Standard_F8s_v2")
	HardwareProfileSTATUSVmSize_StandardG1       = HardwareProfileSTATUSVmSize("Standard_G1")
	HardwareProfileSTATUSVmSize_StandardG2       = HardwareProfileSTATUSVmSize("Standard_G2")
	HardwareProfileSTATUSVmSize_StandardG3       = HardwareProfileSTATUSVmSize("Standard_G3")
	HardwareProfileSTATUSVmSize_StandardG4       = HardwareProfileSTATUSVmSize("Standard_G4")
	HardwareProfileSTATUSVmSize_StandardG5       = HardwareProfileSTATUSVmSize("Standard_G5")
	HardwareProfileSTATUSVmSize_StandardGS1      = HardwareProfileSTATUSVmSize("Standard_GS1")
	HardwareProfileSTATUSVmSize_StandardGS2      = HardwareProfileSTATUSVmSize("Standard_GS2")
	HardwareProfileSTATUSVmSize_StandardGS3      = HardwareProfileSTATUSVmSize("Standard_GS3")
	HardwareProfileSTATUSVmSize_StandardGS4      = HardwareProfileSTATUSVmSize("Standard_GS4")
	HardwareProfileSTATUSVmSize_StandardGS44     = HardwareProfileSTATUSVmSize("Standard_GS4-4")
	HardwareProfileSTATUSVmSize_StandardGS48     = HardwareProfileSTATUSVmSize("Standard_GS4-8")
	HardwareProfileSTATUSVmSize_StandardGS5      = HardwareProfileSTATUSVmSize("Standard_GS5")
	HardwareProfileSTATUSVmSize_StandardGS516    = HardwareProfileSTATUSVmSize("Standard_GS5-16")
	HardwareProfileSTATUSVmSize_StandardGS58     = HardwareProfileSTATUSVmSize("Standard_GS5-8")
	HardwareProfileSTATUSVmSize_StandardH16      = HardwareProfileSTATUSVmSize("Standard_H16")
	HardwareProfileSTATUSVmSize_StandardH16M     = HardwareProfileSTATUSVmSize("Standard_H16m")
	HardwareProfileSTATUSVmSize_StandardH16Mr    = HardwareProfileSTATUSVmSize("Standard_H16mr")
	HardwareProfileSTATUSVmSize_StandardH16R     = HardwareProfileSTATUSVmSize("Standard_H16r")
	HardwareProfileSTATUSVmSize_StandardH8       = HardwareProfileSTATUSVmSize("Standard_H8")
	HardwareProfileSTATUSVmSize_StandardH8M      = HardwareProfileSTATUSVmSize("Standard_H8m")
	HardwareProfileSTATUSVmSize_StandardL16S     = HardwareProfileSTATUSVmSize("Standard_L16s")
	HardwareProfileSTATUSVmSize_StandardL32S     = HardwareProfileSTATUSVmSize("Standard_L32s")
	HardwareProfileSTATUSVmSize_StandardL4S      = HardwareProfileSTATUSVmSize("Standard_L4s")
	HardwareProfileSTATUSVmSize_StandardL8S      = HardwareProfileSTATUSVmSize("Standard_L8s")
	HardwareProfileSTATUSVmSize_StandardM12832Ms = HardwareProfileSTATUSVmSize("Standard_M128-32ms")
	HardwareProfileSTATUSVmSize_StandardM12864Ms = HardwareProfileSTATUSVmSize("Standard_M128-64ms")
	HardwareProfileSTATUSVmSize_StandardM128Ms   = HardwareProfileSTATUSVmSize("Standard_M128ms")
	HardwareProfileSTATUSVmSize_StandardM128S    = HardwareProfileSTATUSVmSize("Standard_M128s")
	HardwareProfileSTATUSVmSize_StandardM6416Ms  = HardwareProfileSTATUSVmSize("Standard_M64-16ms")
	HardwareProfileSTATUSVmSize_StandardM6432Ms  = HardwareProfileSTATUSVmSize("Standard_M64-32ms")
	HardwareProfileSTATUSVmSize_StandardM64Ms    = HardwareProfileSTATUSVmSize("Standard_M64ms")
	HardwareProfileSTATUSVmSize_StandardM64S     = HardwareProfileSTATUSVmSize("Standard_M64s")
	HardwareProfileSTATUSVmSize_StandardNC12     = HardwareProfileSTATUSVmSize("Standard_NC12")
	HardwareProfileSTATUSVmSize_StandardNC12SV2  = HardwareProfileSTATUSVmSize("Standard_NC12s_v2")
	HardwareProfileSTATUSVmSize_StandardNC12SV3  = HardwareProfileSTATUSVmSize("Standard_NC12s_v3")
	HardwareProfileSTATUSVmSize_StandardNC24     = HardwareProfileSTATUSVmSize("Standard_NC24")
	HardwareProfileSTATUSVmSize_StandardNC24R    = HardwareProfileSTATUSVmSize("Standard_NC24r")
	HardwareProfileSTATUSVmSize_StandardNC24RsV2 = HardwareProfileSTATUSVmSize("Standard_NC24rs_v2")
	HardwareProfileSTATUSVmSize_StandardNC24RsV3 = HardwareProfileSTATUSVmSize("Standard_NC24rs_v3")
	HardwareProfileSTATUSVmSize_StandardNC24SV2  = HardwareProfileSTATUSVmSize("Standard_NC24s_v2")
	HardwareProfileSTATUSVmSize_StandardNC24SV3  = HardwareProfileSTATUSVmSize("Standard_NC24s_v3")
	HardwareProfileSTATUSVmSize_StandardNC6      = HardwareProfileSTATUSVmSize("Standard_NC6")
	HardwareProfileSTATUSVmSize_StandardNC6SV2   = HardwareProfileSTATUSVmSize("Standard_NC6s_v2")
	HardwareProfileSTATUSVmSize_StandardNC6SV3   = HardwareProfileSTATUSVmSize("Standard_NC6s_v3")
	HardwareProfileSTATUSVmSize_StandardND12S    = HardwareProfileSTATUSVmSize("Standard_ND12s")
	HardwareProfileSTATUSVmSize_StandardND24Rs   = HardwareProfileSTATUSVmSize("Standard_ND24rs")
	HardwareProfileSTATUSVmSize_StandardND24S    = HardwareProfileSTATUSVmSize("Standard_ND24s")
	HardwareProfileSTATUSVmSize_StandardND6S     = HardwareProfileSTATUSVmSize("Standard_ND6s")
	HardwareProfileSTATUSVmSize_StandardNV12     = HardwareProfileSTATUSVmSize("Standard_NV12")
	HardwareProfileSTATUSVmSize_StandardNV24     = HardwareProfileSTATUSVmSize("Standard_NV24")
	HardwareProfileSTATUSVmSize_StandardNV6      = HardwareProfileSTATUSVmSize("Standard_NV6")
)

// Deprecated version of HardwareProfileVmSize. Use v1beta20201201.HardwareProfileVmSize instead
// +kubebuilder:validation:Enum={"Basic_A0","Basic_A1","Basic_A2","Basic_A3","Basic_A4","Standard_A0","Standard_A1","Standard_A10","Standard_A11","Standard_A1_v2","Standard_A2","Standard_A2m_v2","Standard_A2_v2","Standard_A3","Standard_A4","Standard_A4m_v2","Standard_A4_v2","Standard_A5","Standard_A6","Standard_A7","Standard_A8","Standard_A8m_v2","Standard_A8_v2","Standard_A9","Standard_B1ms","Standard_B1s","Standard_B2ms","Standard_B2s","Standard_B4ms","Standard_B8ms","Standard_D1","Standard_D11","Standard_D11_v2","Standard_D12","Standard_D12_v2","Standard_D13","Standard_D13_v2","Standard_D14","Standard_D14_v2","Standard_D15_v2","Standard_D16s_v3","Standard_D16_v3","Standard_D1_v2","Standard_D2","Standard_D2s_v3","Standard_D2_v2","Standard_D2_v3","Standard_D3","Standard_D32s_v3","Standard_D32_v3","Standard_D3_v2","Standard_D4","Standard_D4s_v3","Standard_D4_v2","Standard_D4_v3","Standard_D5_v2","Standard_D64s_v3","Standard_D64_v3","Standard_D8s_v3","Standard_D8_v3","Standard_DS1","Standard_DS11","Standard_DS11_v2","Standard_DS12","Standard_DS12_v2","Standard_DS13","Standard_DS13-2_v2","Standard_DS13-4_v2","Standard_DS13_v2","Standard_DS14","Standard_DS14-4_v2","Standard_DS14-8_v2","Standard_DS14_v2","Standard_DS15_v2","Standard_DS1_v2","Standard_DS2","Standard_DS2_v2","Standard_DS3","Standard_DS3_v2","Standard_DS4","Standard_DS4_v2","Standard_DS5_v2","Standard_E16s_v3","Standard_E16_v3","Standard_E2s_v3","Standard_E2_v3","Standard_E32-16_v3","Standard_E32-8s_v3","Standard_E32s_v3","Standard_E32_v3","Standard_E4s_v3","Standard_E4_v3","Standard_E64-16s_v3","Standard_E64-32s_v3","Standard_E64s_v3","Standard_E64_v3","Standard_E8s_v3","Standard_E8_v3","Standard_F1","Standard_F16","Standard_F16s","Standard_F16s_v2","Standard_F1s","Standard_F2","Standard_F2s","Standard_F2s_v2","Standard_F32s_v2","Standard_F4","Standard_F4s","Standard_F4s_v2","Standard_F64s_v2","Standard_F72s_v2","Standard_F8","Standard_F8s","Standard_F8s_v2","Standard_G1","Standard_G2","Standard_G3","Standard_G4","Standard_G5","Standard_GS1","Standard_GS2","Standard_GS3","Standard_GS4","Standard_GS4-4","Standard_GS4-8","Standard_GS5","Standard_GS5-16","Standard_GS5-8","Standard_H16","Standard_H16m","Standard_H16mr","Standard_H16r","Standard_H8","Standard_H8m","Standard_L16s","Standard_L32s","Standard_L4s","Standard_L8s","Standard_M128-32ms","Standard_M128-64ms","Standard_M128ms","Standard_M128s","Standard_M64-16ms","Standard_M64-32ms","Standard_M64ms","Standard_M64s","Standard_NC12","Standard_NC12s_v2","Standard_NC12s_v3","Standard_NC24","Standard_NC24r","Standard_NC24rs_v2","Standard_NC24rs_v3","Standard_NC24s_v2","Standard_NC24s_v3","Standard_NC6","Standard_NC6s_v2","Standard_NC6s_v3","Standard_ND12s","Standard_ND24rs","Standard_ND24s","Standard_ND6s","Standard_NV12","Standard_NV24","Standard_NV6"}
type HardwareProfileVmSize string

const (
	HardwareProfileVmSize_BasicA0          = HardwareProfileVmSize("Basic_A0")
	HardwareProfileVmSize_BasicA1          = HardwareProfileVmSize("Basic_A1")
	HardwareProfileVmSize_BasicA2          = HardwareProfileVmSize("Basic_A2")
	HardwareProfileVmSize_BasicA3          = HardwareProfileVmSize("Basic_A3")
	HardwareProfileVmSize_BasicA4          = HardwareProfileVmSize("Basic_A4")
	HardwareProfileVmSize_StandardA0       = HardwareProfileVmSize("Standard_A0")
	HardwareProfileVmSize_StandardA1       = HardwareProfileVmSize("Standard_A1")
	HardwareProfileVmSize_StandardA10      = HardwareProfileVmSize("Standard_A10")
	HardwareProfileVmSize_StandardA11      = HardwareProfileVmSize("Standard_A11")
	HardwareProfileVmSize_StandardA1V2     = HardwareProfileVmSize("Standard_A1_v2")
	HardwareProfileVmSize_StandardA2       = HardwareProfileVmSize("Standard_A2")
	HardwareProfileVmSize_StandardA2MV2    = HardwareProfileVmSize("Standard_A2m_v2")
	HardwareProfileVmSize_StandardA2V2     = HardwareProfileVmSize("Standard_A2_v2")
	HardwareProfileVmSize_StandardA3       = HardwareProfileVmSize("Standard_A3")
	HardwareProfileVmSize_StandardA4       = HardwareProfileVmSize("Standard_A4")
	HardwareProfileVmSize_StandardA4MV2    = HardwareProfileVmSize("Standard_A4m_v2")
	HardwareProfileVmSize_StandardA4V2     = HardwareProfileVmSize("Standard_A4_v2")
	HardwareProfileVmSize_StandardA5       = HardwareProfileVmSize("Standard_A5")
	HardwareProfileVmSize_StandardA6       = HardwareProfileVmSize("Standard_A6")
	HardwareProfileVmSize_StandardA7       = HardwareProfileVmSize("Standard_A7")
	HardwareProfileVmSize_StandardA8       = HardwareProfileVmSize("Standard_A8")
	HardwareProfileVmSize_StandardA8MV2    = HardwareProfileVmSize("Standard_A8m_v2")
	HardwareProfileVmSize_StandardA8V2     = HardwareProfileVmSize("Standard_A8_v2")
	HardwareProfileVmSize_StandardA9       = HardwareProfileVmSize("Standard_A9")
	HardwareProfileVmSize_StandardB1Ms     = HardwareProfileVmSize("Standard_B1ms")
	HardwareProfileVmSize_StandardB1S      = HardwareProfileVmSize("Standard_B1s")
	HardwareProfileVmSize_StandardB2Ms     = HardwareProfileVmSize("Standard_B2ms")
	HardwareProfileVmSize_StandardB2S      = HardwareProfileVmSize("Standard_B2s")
	HardwareProfileVmSize_StandardB4Ms     = HardwareProfileVmSize("Standard_B4ms")
	HardwareProfileVmSize_StandardB8Ms     = HardwareProfileVmSize("Standard_B8ms")
	HardwareProfileVmSize_StandardD1       = HardwareProfileVmSize("Standard_D1")
	HardwareProfileVmSize_StandardD11      = HardwareProfileVmSize("Standard_D11")
	HardwareProfileVmSize_StandardD11V2    = HardwareProfileVmSize("Standard_D11_v2")
	HardwareProfileVmSize_StandardD12      = HardwareProfileVmSize("Standard_D12")
	HardwareProfileVmSize_StandardD12V2    = HardwareProfileVmSize("Standard_D12_v2")
	HardwareProfileVmSize_StandardD13      = HardwareProfileVmSize("Standard_D13")
	HardwareProfileVmSize_StandardD13V2    = HardwareProfileVmSize("Standard_D13_v2")
	HardwareProfileVmSize_StandardD14      = HardwareProfileVmSize("Standard_D14")
	HardwareProfileVmSize_StandardD14V2    = HardwareProfileVmSize("Standard_D14_v2")
	HardwareProfileVmSize_StandardD15V2    = HardwareProfileVmSize("Standard_D15_v2")
	HardwareProfileVmSize_StandardD16SV3   = HardwareProfileVmSize("Standard_D16s_v3")
	HardwareProfileVmSize_StandardD16V3    = HardwareProfileVmSize("Standard_D16_v3")
	HardwareProfileVmSize_StandardD1V2     = HardwareProfileVmSize("Standard_D1_v2")
	HardwareProfileVmSize_StandardD2       = HardwareProfileVmSize("Standard_D2")
	HardwareProfileVmSize_StandardD2SV3    = HardwareProfileVmSize("Standard_D2s_v3")
	HardwareProfileVmSize_StandardD2V2     = HardwareProfileVmSize("Standard_D2_v2")
	HardwareProfileVmSize_StandardD2V3     = HardwareProfileVmSize("Standard_D2_v3")
	HardwareProfileVmSize_StandardD3       = HardwareProfileVmSize("Standard_D3")
	HardwareProfileVmSize_StandardD32SV3   = HardwareProfileVmSize("Standard_D32s_v3")
	HardwareProfileVmSize_StandardD32V3    = HardwareProfileVmSize("Standard_D32_v3")
	HardwareProfileVmSize_StandardD3V2     = HardwareProfileVmSize("Standard_D3_v2")
	HardwareProfileVmSize_StandardD4       = HardwareProfileVmSize("Standard_D4")
	HardwareProfileVmSize_StandardD4SV3    = HardwareProfileVmSize("Standard_D4s_v3")
	HardwareProfileVmSize_StandardD4V2     = HardwareProfileVmSize("Standard_D4_v2")
	HardwareProfileVmSize_StandardD4V3     = HardwareProfileVmSize("Standard_D4_v3")
	HardwareProfileVmSize_StandardD5V2     = HardwareProfileVmSize("Standard_D5_v2")
	HardwareProfileVmSize_StandardD64SV3   = HardwareProfileVmSize("Standard_D64s_v3")
	HardwareProfileVmSize_StandardD64V3    = HardwareProfileVmSize("Standard_D64_v3")
	HardwareProfileVmSize_StandardD8SV3    = HardwareProfileVmSize("Standard_D8s_v3")
	HardwareProfileVmSize_StandardD8V3     = HardwareProfileVmSize("Standard_D8_v3")
	HardwareProfileVmSize_StandardDS1      = HardwareProfileVmSize("Standard_DS1")
	HardwareProfileVmSize_StandardDS11     = HardwareProfileVmSize("Standard_DS11")
	HardwareProfileVmSize_StandardDS11V2   = HardwareProfileVmSize("Standard_DS11_v2")
	HardwareProfileVmSize_StandardDS12     = HardwareProfileVmSize("Standard_DS12")
	HardwareProfileVmSize_StandardDS12V2   = HardwareProfileVmSize("Standard_DS12_v2")
	HardwareProfileVmSize_StandardDS13     = HardwareProfileVmSize("Standard_DS13")
	HardwareProfileVmSize_StandardDS132V2  = HardwareProfileVmSize("Standard_DS13-2_v2")
	HardwareProfileVmSize_StandardDS134V2  = HardwareProfileVmSize("Standard_DS13-4_v2")
	HardwareProfileVmSize_StandardDS13V2   = HardwareProfileVmSize("Standard_DS13_v2")
	HardwareProfileVmSize_StandardDS14     = HardwareProfileVmSize("Standard_DS14")
	HardwareProfileVmSize_StandardDS144V2  = HardwareProfileVmSize("Standard_DS14-4_v2")
	HardwareProfileVmSize_StandardDS148V2  = HardwareProfileVmSize("Standard_DS14-8_v2")
	HardwareProfileVmSize_StandardDS14V2   = HardwareProfileVmSize("Standard_DS14_v2")
	HardwareProfileVmSize_StandardDS15V2   = HardwareProfileVmSize("Standard_DS15_v2")
	HardwareProfileVmSize_StandardDS1V2    = HardwareProfileVmSize("Standard_DS1_v2")
	HardwareProfileVmSize_StandardDS2      = HardwareProfileVmSize("Standard_DS2")
	HardwareProfileVmSize_StandardDS2V2    = HardwareProfileVmSize("Standard_DS2_v2")
	HardwareProfileVmSize_StandardDS3      = HardwareProfileVmSize("Standard_DS3")
	HardwareProfileVmSize_StandardDS3V2    = HardwareProfileVmSize("Standard_DS3_v2")
	HardwareProfileVmSize_StandardDS4      = HardwareProfileVmSize("Standard_DS4")
	HardwareProfileVmSize_StandardDS4V2    = HardwareProfileVmSize("Standard_DS4_v2")
	HardwareProfileVmSize_StandardDS5V2    = HardwareProfileVmSize("Standard_DS5_v2")
	HardwareProfileVmSize_StandardE16SV3   = HardwareProfileVmSize("Standard_E16s_v3")
	HardwareProfileVmSize_StandardE16V3    = HardwareProfileVmSize("Standard_E16_v3")
	HardwareProfileVmSize_StandardE2SV3    = HardwareProfileVmSize("Standard_E2s_v3")
	HardwareProfileVmSize_StandardE2V3     = HardwareProfileVmSize("Standard_E2_v3")
	HardwareProfileVmSize_StandardE3216V3  = HardwareProfileVmSize("Standard_E32-16_v3")
	HardwareProfileVmSize_StandardE328SV3  = HardwareProfileVmSize("Standard_E32-8s_v3")
	HardwareProfileVmSize_StandardE32SV3   = HardwareProfileVmSize("Standard_E32s_v3")
	HardwareProfileVmSize_StandardE32V3    = HardwareProfileVmSize("Standard_E32_v3")
	HardwareProfileVmSize_StandardE4SV3    = HardwareProfileVmSize("Standard_E4s_v3")
	HardwareProfileVmSize_StandardE4V3     = HardwareProfileVmSize("Standard_E4_v3")
	HardwareProfileVmSize_StandardE6416SV3 = HardwareProfileVmSize("Standard_E64-16s_v3")
	HardwareProfileVmSize_StandardE6432SV3 = HardwareProfileVmSize("Standard_E64-32s_v3")
	HardwareProfileVmSize_StandardE64SV3   = HardwareProfileVmSize("Standard_E64s_v3")
	HardwareProfileVmSize_StandardE64V3    = HardwareProfileVmSize("Standard_E64_v3")
	HardwareProfileVmSize_StandardE8SV3    = HardwareProfileVmSize("Standard_E8s_v3")
	HardwareProfileVmSize_StandardE8V3     = HardwareProfileVmSize("Standard_E8_v3")
	HardwareProfileVmSize_StandardF1       = HardwareProfileVmSize("Standard_F1")
	HardwareProfileVmSize_StandardF16      = HardwareProfileVmSize("Standard_F16")
	HardwareProfileVmSize_StandardF16S     = HardwareProfileVmSize("Standard_F16s")
	HardwareProfileVmSize_StandardF16SV2   = HardwareProfileVmSize("Standard_F16s_v2")
	HardwareProfileVmSize_StandardF1S      = HardwareProfileVmSize("Standard_F1s")
	HardwareProfileVmSize_StandardF2       = HardwareProfileVmSize("Standard_F2")
	HardwareProfileVmSize_StandardF2S      = HardwareProfileVmSize("Standard_F2s")
	HardwareProfileVmSize_StandardF2SV2    = HardwareProfileVmSize("Standard_F2s_v2")
	HardwareProfileVmSize_StandardF32SV2   = HardwareProfileVmSize("Standard_F32s_v2")
	HardwareProfileVmSize_StandardF4       = HardwareProfileVmSize("Standard_F4")
	HardwareProfileVmSize_StandardF4S      = HardwareProfileVmSize("Standard_F4s")
	HardwareProfileVmSize_StandardF4SV2    = HardwareProfileVmSize("Standard_F4s_v2")
	HardwareProfileVmSize_StandardF64SV2   = HardwareProfileVmSize("Standard_F64s_v2")
	HardwareProfileVmSize_StandardF72SV2   = HardwareProfileVmSize("Standard_F72s_v2")
	HardwareProfileVmSize_StandardF8       = HardwareProfileVmSize("Standard_F8")
	HardwareProfileVmSize_StandardF8S      = HardwareProfileVmSize("Standard_F8s")
	HardwareProfileVmSize_StandardF8SV2    = HardwareProfileVmSize("Standard_F8s_v2")
	HardwareProfileVmSize_StandardG1       = HardwareProfileVmSize("Standard_G1")
	HardwareProfileVmSize_StandardG2       = HardwareProfileVmSize("Standard_G2")
	HardwareProfileVmSize_StandardG3       = HardwareProfileVmSize("Standard_G3")
	HardwareProfileVmSize_StandardG4       = HardwareProfileVmSize("Standard_G4")
	HardwareProfileVmSize_StandardG5       = HardwareProfileVmSize("Standard_G5")
	HardwareProfileVmSize_StandardGS1      = HardwareProfileVmSize("Standard_GS1")
	HardwareProfileVmSize_StandardGS2      = HardwareProfileVmSize("Standard_GS2")
	HardwareProfileVmSize_StandardGS3      = HardwareProfileVmSize("Standard_GS3")
	HardwareProfileVmSize_StandardGS4      = HardwareProfileVmSize("Standard_GS4")
	HardwareProfileVmSize_StandardGS44     = HardwareProfileVmSize("Standard_GS4-4")
	HardwareProfileVmSize_StandardGS48     = HardwareProfileVmSize("Standard_GS4-8")
	HardwareProfileVmSize_StandardGS5      = HardwareProfileVmSize("Standard_GS5")
	HardwareProfileVmSize_StandardGS516    = HardwareProfileVmSize("Standard_GS5-16")
	HardwareProfileVmSize_StandardGS58     = HardwareProfileVmSize("Standard_GS5-8")
	HardwareProfileVmSize_StandardH16      = HardwareProfileVmSize("Standard_H16")
	HardwareProfileVmSize_StandardH16M     = HardwareProfileVmSize("Standard_H16m")
	HardwareProfileVmSize_StandardH16Mr    = HardwareProfileVmSize("Standard_H16mr")
	HardwareProfileVmSize_StandardH16R     = HardwareProfileVmSize("Standard_H16r")
	HardwareProfileVmSize_StandardH8       = HardwareProfileVmSize("Standard_H8")
	HardwareProfileVmSize_StandardH8M      = HardwareProfileVmSize("Standard_H8m")
	HardwareProfileVmSize_StandardL16S     = HardwareProfileVmSize("Standard_L16s")
	HardwareProfileVmSize_StandardL32S     = HardwareProfileVmSize("Standard_L32s")
	HardwareProfileVmSize_StandardL4S      = HardwareProfileVmSize("Standard_L4s")
	HardwareProfileVmSize_StandardL8S      = HardwareProfileVmSize("Standard_L8s")
	HardwareProfileVmSize_StandardM12832Ms = HardwareProfileVmSize("Standard_M128-32ms")
	HardwareProfileVmSize_StandardM12864Ms = HardwareProfileVmSize("Standard_M128-64ms")
	HardwareProfileVmSize_StandardM128Ms   = HardwareProfileVmSize("Standard_M128ms")
	HardwareProfileVmSize_StandardM128S    = HardwareProfileVmSize("Standard_M128s")
	HardwareProfileVmSize_StandardM6416Ms  = HardwareProfileVmSize("Standard_M64-16ms")
	HardwareProfileVmSize_StandardM6432Ms  = HardwareProfileVmSize("Standard_M64-32ms")
	HardwareProfileVmSize_StandardM64Ms    = HardwareProfileVmSize("Standard_M64ms")
	HardwareProfileVmSize_StandardM64S     = HardwareProfileVmSize("Standard_M64s")
	HardwareProfileVmSize_StandardNC12     = HardwareProfileVmSize("Standard_NC12")
	HardwareProfileVmSize_StandardNC12SV2  = HardwareProfileVmSize("Standard_NC12s_v2")
	HardwareProfileVmSize_StandardNC12SV3  = HardwareProfileVmSize("Standard_NC12s_v3")
	HardwareProfileVmSize_StandardNC24     = HardwareProfileVmSize("Standard_NC24")
	HardwareProfileVmSize_StandardNC24R    = HardwareProfileVmSize("Standard_NC24r")
	HardwareProfileVmSize_StandardNC24RsV2 = HardwareProfileVmSize("Standard_NC24rs_v2")
	HardwareProfileVmSize_StandardNC24RsV3 = HardwareProfileVmSize("Standard_NC24rs_v3")
	HardwareProfileVmSize_StandardNC24SV2  = HardwareProfileVmSize("Standard_NC24s_v2")
	HardwareProfileVmSize_StandardNC24SV3  = HardwareProfileVmSize("Standard_NC24s_v3")
	HardwareProfileVmSize_StandardNC6      = HardwareProfileVmSize("Standard_NC6")
	HardwareProfileVmSize_StandardNC6SV2   = HardwareProfileVmSize("Standard_NC6s_v2")
	HardwareProfileVmSize_StandardNC6SV3   = HardwareProfileVmSize("Standard_NC6s_v3")
	HardwareProfileVmSize_StandardND12S    = HardwareProfileVmSize("Standard_ND12s")
	HardwareProfileVmSize_StandardND24Rs   = HardwareProfileVmSize("Standard_ND24rs")
	HardwareProfileVmSize_StandardND24S    = HardwareProfileVmSize("Standard_ND24s")
	HardwareProfileVmSize_StandardND6S     = HardwareProfileVmSize("Standard_ND6s")
	HardwareProfileVmSize_StandardNV12     = HardwareProfileVmSize("Standard_NV12")
	HardwareProfileVmSize_StandardNV24     = HardwareProfileVmSize("Standard_NV24")
	HardwareProfileVmSize_StandardNV6      = HardwareProfileVmSize("Standard_NV6")
)

// Deprecated version of ImageReference. Use v1beta20201201.ImageReference instead
type ImageReference struct {
	Offer     *string                       `json:"offer,omitempty"`
	Publisher *string                       `json:"publisher,omitempty"`
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	Sku       *string                       `json:"sku,omitempty"`
	Version   *string                       `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ImageReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ImageReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &ImageReferenceARM{}

	// Set property ‘Id’:
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}

	// Set property ‘Offer’:
	if reference.Offer != nil {
		offer := *reference.Offer
		result.Offer = &offer
	}

	// Set property ‘Publisher’:
	if reference.Publisher != nil {
		publisher := *reference.Publisher
		result.Publisher = &publisher
	}

	// Set property ‘Sku’:
	if reference.Sku != nil {
		sku := *reference.Sku
		result.Sku = &sku
	}

	// Set property ‘Version’:
	if reference.Version != nil {
		version := *reference.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ImageReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ImageReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageReferenceARM, got %T", armInput)
	}

	// Set property ‘Offer’:
	if typedInput.Offer != nil {
		offer := *typedInput.Offer
		reference.Offer = &offer
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		reference.Publisher = &publisher
	}

	// no assignment for property ‘Reference’

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		reference.Sku = &sku
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		reference.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromImageReference populates our ImageReference from the provided source ImageReference
func (reference *ImageReference) AssignPropertiesFromImageReference(source *alpha20201201s.ImageReference) error {

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignPropertiesToImageReference populates the provided destination ImageReference from our ImageReference
func (reference *ImageReference) AssignPropertiesToImageReference(destination *alpha20201201s.ImageReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ImageReference_STATUS. Use v1beta20201201.ImageReference_STATUS instead
type ImageReference_STATUS struct {
	ExactVersion *string `json:"exactVersion,omitempty"`
	Id           *string `json:"id,omitempty"`
	Offer        *string `json:"offer,omitempty"`
	Publisher    *string `json:"publisher,omitempty"`
	Sku          *string `json:"sku,omitempty"`
	Version      *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ImageReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageReference_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ImageReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageReference_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageReference_STATUSARM, got %T", armInput)
	}

	// Set property ‘ExactVersion’:
	if typedInput.ExactVersion != nil {
		exactVersion := *typedInput.ExactVersion
		reference.ExactVersion = &exactVersion
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// Set property ‘Offer’:
	if typedInput.Offer != nil {
		offer := *typedInput.Offer
		reference.Offer = &offer
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		reference.Publisher = &publisher
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		reference.Sku = &sku
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		reference.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromImageReferenceSTATUS populates our ImageReference_STATUS from the provided source ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignPropertiesFromImageReferenceSTATUS(source *alpha20201201s.ImageReference_STATUS) error {

	// ExactVersion
	reference.ExactVersion = genruntime.ClonePointerToString(source.ExactVersion)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignPropertiesToImageReferenceSTATUS populates the provided destination ImageReference_STATUS from our ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignPropertiesToImageReferenceSTATUS(destination *alpha20201201s.ImageReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExactVersion
	destination.ExactVersion = genruntime.ClonePointerToString(reference.ExactVersion)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of InstanceViewStatus_STATUS. Use v1beta20201201.InstanceViewStatus_STATUS instead
type InstanceViewStatus_STATUS struct {
	Code          *string                        `json:"code,omitempty"`
	DisplayStatus *string                        `json:"displayStatus,omitempty"`
	Level         *InstanceViewStatusSTATUSLevel `json:"level,omitempty"`
	Message       *string                        `json:"message,omitempty"`
	Time          *string                        `json:"time,omitempty"`
}

var _ genruntime.FromARMConverter = &InstanceViewStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *InstanceViewStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InstanceViewStatus_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *InstanceViewStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InstanceViewStatus_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InstanceViewStatus_STATUSARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		status.Code = &code
	}

	// Set property ‘DisplayStatus’:
	if typedInput.DisplayStatus != nil {
		displayStatus := *typedInput.DisplayStatus
		status.DisplayStatus = &displayStatus
	}

	// Set property ‘Level’:
	if typedInput.Level != nil {
		level := *typedInput.Level
		status.Level = &level
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		status.Message = &message
	}

	// Set property ‘Time’:
	if typedInput.Time != nil {
		time := *typedInput.Time
		status.Time = &time
	}

	// No error
	return nil
}

// AssignPropertiesFromInstanceViewStatusSTATUS populates our InstanceViewStatus_STATUS from the provided source InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignPropertiesFromInstanceViewStatusSTATUS(source *alpha20201201s.InstanceViewStatus_STATUS) error {

	// Code
	status.Code = genruntime.ClonePointerToString(source.Code)

	// DisplayStatus
	status.DisplayStatus = genruntime.ClonePointerToString(source.DisplayStatus)

	// Level
	if source.Level != nil {
		level := InstanceViewStatusSTATUSLevel(*source.Level)
		status.Level = &level
	} else {
		status.Level = nil
	}

	// Message
	status.Message = genruntime.ClonePointerToString(source.Message)

	// Time
	status.Time = genruntime.ClonePointerToString(source.Time)

	// No error
	return nil
}

// AssignPropertiesToInstanceViewStatusSTATUS populates the provided destination InstanceViewStatus_STATUS from our InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignPropertiesToInstanceViewStatusSTATUS(destination *alpha20201201s.InstanceViewStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(status.Code)

	// DisplayStatus
	destination.DisplayStatus = genruntime.ClonePointerToString(status.DisplayStatus)

	// Level
	if status.Level != nil {
		level := string(*status.Level)
		destination.Level = &level
	} else {
		destination.Level = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(status.Message)

	// Time
	destination.Time = genruntime.ClonePointerToString(status.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LinuxConfiguration. Use v1beta20201201.LinuxConfiguration instead
type LinuxConfiguration struct {
	DisablePasswordAuthentication *bool               `json:"disablePasswordAuthentication,omitempty"`
	PatchSettings                 *LinuxPatchSettings `json:"patchSettings,omitempty"`
	ProvisionVMAgent              *bool               `json:"provisionVMAgent,omitempty"`
	Ssh                           *SshConfiguration   `json:"ssh,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *LinuxConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &LinuxConfigurationARM{}

	// Set property ‘DisablePasswordAuthentication’:
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		result.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if configuration.PatchSettings != nil {
		patchSettingsARM, err := (*configuration.PatchSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		patchSettings := *patchSettingsARM.(*LinuxPatchSettingsARM)
		result.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		result.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if configuration.Ssh != nil {
		sshARM, err := (*configuration.Ssh).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ssh := *sshARM.(*SshConfigurationARM)
		result.Ssh = &ssh
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *LinuxConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *LinuxConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxConfigurationARM, got %T", armInput)
	}

	// Set property ‘DisablePasswordAuthentication’:
	if typedInput.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *typedInput.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 LinuxPatchSettings
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		configuration.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if typedInput.Ssh != nil {
		var ssh1 SshConfiguration
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		configuration.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxConfiguration populates our LinuxConfiguration from the provided source LinuxConfiguration
func (configuration *LinuxConfiguration) AssignPropertiesFromLinuxConfiguration(source *alpha20201201s.LinuxConfiguration) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings
		err := patchSetting.AssignPropertiesFromLinuxPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxPatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration
		err := ssh.AssignPropertiesFromSshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSshConfiguration() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxConfiguration populates the provided destination LinuxConfiguration from our LinuxConfiguration
func (configuration *LinuxConfiguration) AssignPropertiesToLinuxConfiguration(destination *alpha20201201s.LinuxConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting alpha20201201s.LinuxPatchSettings
		err := configuration.PatchSettings.AssignPropertiesToLinuxPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxPatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh alpha20201201s.SshConfiguration
		err := configuration.Ssh.AssignPropertiesToSshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSshConfiguration() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LinuxConfiguration_STATUS. Use v1beta20201201.LinuxConfiguration_STATUS instead
type LinuxConfiguration_STATUS struct {
	DisablePasswordAuthentication *bool                      `json:"disablePasswordAuthentication,omitempty"`
	PatchSettings                 *LinuxPatchSettings_STATUS `json:"patchSettings,omitempty"`
	ProvisionVMAgent              *bool                      `json:"provisionVMAgent,omitempty"`
	Ssh                           *SshConfiguration_STATUS   `json:"ssh,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *LinuxConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *LinuxConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘DisablePasswordAuthentication’:
	if typedInput.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *typedInput.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 LinuxPatchSettings_STATUS
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		configuration.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if typedInput.Ssh != nil {
		var ssh1 SshConfiguration_STATUS
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		configuration.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxConfigurationSTATUS populates our LinuxConfiguration_STATUS from the provided source LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignPropertiesFromLinuxConfigurationSTATUS(source *alpha20201201s.LinuxConfiguration_STATUS) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings_STATUS
		err := patchSetting.AssignPropertiesFromLinuxPatchSettingsSTATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxPatchSettingsSTATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration_STATUS
		err := ssh.AssignPropertiesFromSshConfigurationSTATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSshConfigurationSTATUS() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxConfigurationSTATUS populates the provided destination LinuxConfiguration_STATUS from our LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignPropertiesToLinuxConfigurationSTATUS(destination *alpha20201201s.LinuxConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting alpha20201201s.LinuxPatchSettings_STATUS
		err := configuration.PatchSettings.AssignPropertiesToLinuxPatchSettingsSTATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxPatchSettingsSTATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh alpha20201201s.SshConfiguration_STATUS
		err := configuration.Ssh.AssignPropertiesToSshConfigurationSTATUS(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSshConfigurationSTATUS() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of MaintenanceRedeployStatus_STATUS. Use v1beta20201201.MaintenanceRedeployStatus_STATUS instead
type MaintenanceRedeployStatus_STATUS struct {
	IsCustomerInitiatedMaintenanceAllowed *bool                                                   `json:"isCustomerInitiatedMaintenanceAllowed,omitempty"`
	LastOperationMessage                  *string                                                 `json:"lastOperationMessage,omitempty"`
	LastOperationResultCode               *MaintenanceRedeployStatusSTATUSLastOperationResultCode `json:"lastOperationResultCode,omitempty"`
	MaintenanceWindowEndTime              *string                                                 `json:"maintenanceWindowEndTime,omitempty"`
	MaintenanceWindowStartTime            *string                                                 `json:"maintenanceWindowStartTime,omitempty"`
	PreMaintenanceWindowEndTime           *string                                                 `json:"preMaintenanceWindowEndTime,omitempty"`
	PreMaintenanceWindowStartTime         *string                                                 `json:"preMaintenanceWindowStartTime,omitempty"`
}

var _ genruntime.FromARMConverter = &MaintenanceRedeployStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *MaintenanceRedeployStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MaintenanceRedeployStatus_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *MaintenanceRedeployStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MaintenanceRedeployStatus_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MaintenanceRedeployStatus_STATUSARM, got %T", armInput)
	}

	// Set property ‘IsCustomerInitiatedMaintenanceAllowed’:
	if typedInput.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *typedInput.IsCustomerInitiatedMaintenanceAllowed
		status.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	}

	// Set property ‘LastOperationMessage’:
	if typedInput.LastOperationMessage != nil {
		lastOperationMessage := *typedInput.LastOperationMessage
		status.LastOperationMessage = &lastOperationMessage
	}

	// Set property ‘LastOperationResultCode’:
	if typedInput.LastOperationResultCode != nil {
		lastOperationResultCode := *typedInput.LastOperationResultCode
		status.LastOperationResultCode = &lastOperationResultCode
	}

	// Set property ‘MaintenanceWindowEndTime’:
	if typedInput.MaintenanceWindowEndTime != nil {
		maintenanceWindowEndTime := *typedInput.MaintenanceWindowEndTime
		status.MaintenanceWindowEndTime = &maintenanceWindowEndTime
	}

	// Set property ‘MaintenanceWindowStartTime’:
	if typedInput.MaintenanceWindowStartTime != nil {
		maintenanceWindowStartTime := *typedInput.MaintenanceWindowStartTime
		status.MaintenanceWindowStartTime = &maintenanceWindowStartTime
	}

	// Set property ‘PreMaintenanceWindowEndTime’:
	if typedInput.PreMaintenanceWindowEndTime != nil {
		preMaintenanceWindowEndTime := *typedInput.PreMaintenanceWindowEndTime
		status.PreMaintenanceWindowEndTime = &preMaintenanceWindowEndTime
	}

	// Set property ‘PreMaintenanceWindowStartTime’:
	if typedInput.PreMaintenanceWindowStartTime != nil {
		preMaintenanceWindowStartTime := *typedInput.PreMaintenanceWindowStartTime
		status.PreMaintenanceWindowStartTime = &preMaintenanceWindowStartTime
	}

	// No error
	return nil
}

// AssignPropertiesFromMaintenanceRedeployStatusSTATUS populates our MaintenanceRedeployStatus_STATUS from the provided source MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignPropertiesFromMaintenanceRedeployStatusSTATUS(source *alpha20201201s.MaintenanceRedeployStatus_STATUS) error {

	// IsCustomerInitiatedMaintenanceAllowed
	if source.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *source.IsCustomerInitiatedMaintenanceAllowed
		status.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		status.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	status.LastOperationMessage = genruntime.ClonePointerToString(source.LastOperationMessage)

	// LastOperationResultCode
	if source.LastOperationResultCode != nil {
		lastOperationResultCode := MaintenanceRedeployStatusSTATUSLastOperationResultCode(*source.LastOperationResultCode)
		status.LastOperationResultCode = &lastOperationResultCode
	} else {
		status.LastOperationResultCode = nil
	}

	// MaintenanceWindowEndTime
	status.MaintenanceWindowEndTime = genruntime.ClonePointerToString(source.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	status.MaintenanceWindowStartTime = genruntime.ClonePointerToString(source.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	status.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	status.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowStartTime)

	// No error
	return nil
}

// AssignPropertiesToMaintenanceRedeployStatusSTATUS populates the provided destination MaintenanceRedeployStatus_STATUS from our MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignPropertiesToMaintenanceRedeployStatusSTATUS(destination *alpha20201201s.MaintenanceRedeployStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsCustomerInitiatedMaintenanceAllowed
	if status.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *status.IsCustomerInitiatedMaintenanceAllowed
		destination.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		destination.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	destination.LastOperationMessage = genruntime.ClonePointerToString(status.LastOperationMessage)

	// LastOperationResultCode
	if status.LastOperationResultCode != nil {
		lastOperationResultCode := string(*status.LastOperationResultCode)
		destination.LastOperationResultCode = &lastOperationResultCode
	} else {
		destination.LastOperationResultCode = nil
	}

	// MaintenanceWindowEndTime
	destination.MaintenanceWindowEndTime = genruntime.ClonePointerToString(status.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	destination.MaintenanceWindowStartTime = genruntime.ClonePointerToString(status.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	destination.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	destination.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of NetworkInterfaceReference_STATUS. Use v1beta20201201.NetworkInterfaceReference_STATUS instead
type NetworkInterfaceReference_STATUS struct {
	Id      *string `json:"id,omitempty"`
	Primary *bool   `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *NetworkInterfaceReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceReference_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *NetworkInterfaceReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceReference_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceReference_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			reference.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceReferenceSTATUS populates our NetworkInterfaceReference_STATUS from the provided source NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignPropertiesFromNetworkInterfaceReferenceSTATUS(source *alpha20201201s.NetworkInterfaceReference_STATUS) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceReferenceSTATUS populates the provided destination NetworkInterfaceReference_STATUS from our NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignPropertiesToNetworkInterfaceReferenceSTATUS(destination *alpha20201201s.NetworkInterfaceReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Primary
	if reference.Primary != nil {
		primary := *reference.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of OSDisk. Use v1beta20201201.OSDisk instead
type OSDisk struct {
	Caching *OSDiskCaching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	CreateOption            *OSDiskCreateOption     `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings       `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                    `json:"diskSizeGB,omitempty"`
	EncryptionSettings      *DiskEncryptionSettings `json:"encryptionSettings,omitempty"`
	Image                   *VirtualHardDisk        `json:"image,omitempty"`
	ManagedDisk             *ManagedDiskParameters  `json:"managedDisk,omitempty"`
	Name                    *string                 `json:"name,omitempty"`
	OsType                  *OSDiskOsType           `json:"osType,omitempty"`
	Vhd                     *VirtualHardDisk        `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                   `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &OSDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *OSDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &OSDiskARM{}

	// Set property ‘Caching’:
	if disk.Caching != nil {
		caching := *disk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if disk.CreateOption != nil {
		createOption := *disk.CreateOption
		result.CreateOption = &createOption
	}

	// Set property ‘DiffDiskSettings’:
	if disk.DiffDiskSettings != nil {
		diffDiskSettingsARM, err := (*disk.DiffDiskSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diffDiskSettings := *diffDiskSettingsARM.(*DiffDiskSettingsARM)
		result.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘EncryptionSettings’:
	if disk.EncryptionSettings != nil {
		encryptionSettingsARM, err := (*disk.EncryptionSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionSettings := *encryptionSettingsARM.(*DiskEncryptionSettingsARM)
		result.EncryptionSettings = &encryptionSettings
	}

	// Set property ‘Image’:
	if disk.Image != nil {
		imageARM, err := (*disk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := *imageARM.(*VirtualHardDiskARM)
		result.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if disk.ManagedDisk != nil {
		managedDiskARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDiskARM.(*ManagedDiskParametersARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property ‘OsType’:
	if disk.OsType != nil {
		osType := *disk.OsType
		result.OsType = &osType
	}

	// Set property ‘Vhd’:
	if disk.Vhd != nil {
		vhdARM, err := (*disk.Vhd).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vhd := *vhdARM.(*VirtualHardDiskARM)
		result.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *OSDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OSDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *OSDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OSDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OSDiskARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if typedInput.CreateOption != nil {
		createOption := *typedInput.CreateOption
		disk.CreateOption = &createOption
	}

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘EncryptionSettings’:
	if typedInput.EncryptionSettings != nil {
		var encryptionSettings1 DiskEncryptionSettings
		err := encryptionSettings1.PopulateFromARM(owner, *typedInput.EncryptionSettings)
		if err != nil {
			return err
		}
		encryptionSettings := encryptionSettings1
		disk.EncryptionSettings = &encryptionSettings
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		disk.OsType = &osType
	}

	// Set property ‘Vhd’:
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		disk.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromOSDisk populates our OSDisk from the provided source OSDisk
func (disk *OSDisk) AssignPropertiesFromOSDisk(source *alpha20201201s.OSDisk) error {

	// Caching
	if source.Caching != nil {
		caching := OSDiskCaching(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := OSDiskCreateOption(*source.CreateOption)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettings() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings
		err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettings(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSettings() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignPropertiesFromVirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignPropertiesFromManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := OSDiskOsType(*source.OsType)
		disk.OsType = &osType
	} else {
		disk.OsType = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignPropertiesFromVirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSDisk populates the provided destination OSDisk from our OSDisk
func (disk *OSDisk) AssignPropertiesToOSDisk(destination *alpha20201201s.OSDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting alpha20201201s.DiffDiskSettings
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettings() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting alpha20201201s.DiskEncryptionSettings
		err := disk.EncryptionSettings.AssignPropertiesToDiskEncryptionSettings(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSettings() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image alpha20201201s.VirtualHardDisk
		err := disk.Image.AssignPropertiesToVirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk alpha20201201s.ManagedDiskParameters
		err := disk.ManagedDisk.AssignPropertiesToManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd alpha20201201s.VirtualHardDisk
		err := disk.Vhd.AssignPropertiesToVirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of OSDisk_STATUS. Use v1beta20201201.OSDisk_STATUS instead
type OSDisk_STATUS struct {
	Caching                 *Caching_STATUS                `json:"caching,omitempty"`
	CreateOption            *CreateOption_STATUS           `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings_STATUS       `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                           `json:"diskSizeGB,omitempty"`
	EncryptionSettings      *DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	Image                   *VirtualHardDisk_STATUS        `json:"image,omitempty"`
	ManagedDisk             *ManagedDiskParameters_STATUS  `json:"managedDisk,omitempty"`
	Name                    *string                        `json:"name,omitempty"`
	OsType                  *OSDiskSTATUSOsType            `json:"osType,omitempty"`
	Vhd                     *VirtualHardDisk_STATUS        `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                          `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &OSDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *OSDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OSDisk_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *OSDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OSDisk_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OSDisk_STATUSARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if typedInput.CreateOption != nil {
		createOption := *typedInput.CreateOption
		disk.CreateOption = &createOption
	}

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings_STATUS
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘EncryptionSettings’:
	if typedInput.EncryptionSettings != nil {
		var encryptionSettings1 DiskEncryptionSettings_STATUS
		err := encryptionSettings1.PopulateFromARM(owner, *typedInput.EncryptionSettings)
		if err != nil {
			return err
		}
		encryptionSettings := encryptionSettings1
		disk.EncryptionSettings = &encryptionSettings
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_STATUS
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		disk.OsType = &osType
	}

	// Set property ‘Vhd’:
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk_STATUS
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		disk.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromOSDiskSTATUS populates our OSDisk_STATUS from the provided source OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignPropertiesFromOSDiskSTATUS(source *alpha20201201s.OSDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_STATUS(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := CreateOption_STATUS(*source.CreateOption)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_STATUS
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettingsSTATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettingsSTATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings_STATUS
		err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettingsSTATUS(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSettingsSTATUS() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignPropertiesFromVirtualHardDiskSTATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignPropertiesFromManagedDiskParametersSTATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedDiskParametersSTATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := OSDiskSTATUSOsType(*source.OsType)
		disk.OsType = &osType
	} else {
		disk.OsType = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignPropertiesFromVirtualHardDiskSTATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSDiskSTATUS populates the provided destination OSDisk_STATUS from our OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignPropertiesToOSDiskSTATUS(destination *alpha20201201s.OSDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting alpha20201201s.DiffDiskSettings_STATUS
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettingsSTATUS(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettingsSTATUS() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting alpha20201201s.DiskEncryptionSettings_STATUS
		err := disk.EncryptionSettings.AssignPropertiesToDiskEncryptionSettingsSTATUS(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSettingsSTATUS() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image alpha20201201s.VirtualHardDisk_STATUS
		err := disk.Image.AssignPropertiesToVirtualHardDiskSTATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk alpha20201201s.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignPropertiesToManagedDiskParametersSTATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedDiskParametersSTATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd alpha20201201s.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignPropertiesToVirtualHardDiskSTATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SecurityProfileSecurityType. Use v1beta20201201.SecurityProfileSecurityType instead
// +kubebuilder:validation:Enum={"TrustedLaunch"}
type SecurityProfileSecurityType string

const SecurityProfileSecurityType_TrustedLaunch = SecurityProfileSecurityType("TrustedLaunch")

// Deprecated version of SecurityProfileSTATUSSecurityType. Use v1beta20201201.SecurityProfileSTATUSSecurityType instead
type SecurityProfileSTATUSSecurityType string

const SecurityProfileSTATUSSecurityType_TrustedLaunch = SecurityProfileSTATUSSecurityType("TrustedLaunch")

// Deprecated version of UefiSettings. Use v1beta20201201.UefiSettings instead
type UefiSettings struct {
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`
	VTpmEnabled       *bool `json:"vTpmEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &UefiSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *UefiSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &UefiSettingsARM{}

	// Set property ‘SecureBootEnabled’:
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		result.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		result.VTpmEnabled = &vTpmEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *UefiSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UefiSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *UefiSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UefiSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UefiSettingsARM, got %T", armInput)
	}

	// Set property ‘SecureBootEnabled’:
	if typedInput.SecureBootEnabled != nil {
		secureBootEnabled := *typedInput.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if typedInput.VTpmEnabled != nil {
		vTpmEnabled := *typedInput.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromUefiSettings populates our UefiSettings from the provided source UefiSettings
func (settings *UefiSettings) AssignPropertiesFromUefiSettings(source *alpha20201201s.UefiSettings) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUefiSettings populates the provided destination UefiSettings from our UefiSettings
func (settings *UefiSettings) AssignPropertiesToUefiSettings(destination *alpha20201201s.UefiSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of UefiSettings_STATUS. Use v1beta20201201.UefiSettings_STATUS instead
type UefiSettings_STATUS struct {
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`
	VTpmEnabled       *bool `json:"vTpmEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &UefiSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *UefiSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UefiSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *UefiSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UefiSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UefiSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘SecureBootEnabled’:
	if typedInput.SecureBootEnabled != nil {
		secureBootEnabled := *typedInput.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if typedInput.VTpmEnabled != nil {
		vTpmEnabled := *typedInput.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromUefiSettingsSTATUS populates our UefiSettings_STATUS from the provided source UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignPropertiesFromUefiSettingsSTATUS(source *alpha20201201s.UefiSettings_STATUS) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUefiSettingsSTATUS populates the provided destination UefiSettings_STATUS from our UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignPropertiesToUefiSettingsSTATUS(destination *alpha20201201s.UefiSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VaultSecretGroup. Use v1beta20201201.VaultSecretGroup instead
type VaultSecretGroup struct {
	SourceVault       *SubResource       `json:"sourceVault,omitempty"`
	VaultCertificates []VaultCertificate `json:"vaultCertificates,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultSecretGroup{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (group *VaultSecretGroup) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if group == nil {
		return nil, nil
	}
	result := &VaultSecretGroupARM{}

	// Set property ‘SourceVault’:
	if group.SourceVault != nil {
		sourceVaultARM, err := (*group.SourceVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceVault := *sourceVaultARM.(*SubResourceARM)
		result.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range group.VaultCertificates {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VaultCertificates = append(result.VaultCertificates, *itemARM.(*VaultCertificateARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *VaultSecretGroup) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultSecretGroupARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *VaultSecretGroup) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultSecretGroupARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultSecretGroupARM, got %T", armInput)
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		group.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range typedInput.VaultCertificates {
		var item1 VaultCertificate
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		group.VaultCertificates = append(group.VaultCertificates, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultSecretGroup populates our VaultSecretGroup from the provided source VaultSecretGroup
func (group *VaultSecretGroup) AssignPropertiesFromVaultSecretGroup(source *alpha20201201s.VaultSecretGroup) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SourceVault")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate
			err := vaultCertificate.AssignPropertiesFromVaultCertificate(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultSecretGroup populates the provided destination VaultSecretGroup from our VaultSecretGroup
func (group *VaultSecretGroup) AssignPropertiesToVaultSecretGroup(destination *alpha20201201s.VaultSecretGroup) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceVault
	if group.SourceVault != nil {
		var sourceVault alpha20201201s.SubResource
		err := group.SourceVault.AssignPropertiesToSubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]alpha20201201s.VaultCertificate, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate alpha20201201s.VaultCertificate
			err := vaultCertificateItem.AssignPropertiesToVaultCertificate(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VaultSecretGroup_STATUS. Use v1beta20201201.VaultSecretGroup_STATUS instead
type VaultSecretGroup_STATUS struct {
	SourceVault       *SubResource_STATUS       `json:"sourceVault,omitempty"`
	VaultCertificates []VaultCertificate_STATUS `json:"vaultCertificates,omitempty"`
}

var _ genruntime.FromARMConverter = &VaultSecretGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *VaultSecretGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultSecretGroup_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *VaultSecretGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultSecretGroup_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultSecretGroup_STATUSARM, got %T", armInput)
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource_STATUS
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		group.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range typedInput.VaultCertificates {
		var item1 VaultCertificate_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		group.VaultCertificates = append(group.VaultCertificates, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultSecretGroupSTATUS populates our VaultSecretGroup_STATUS from the provided source VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignPropertiesFromVaultSecretGroupSTATUS(source *alpha20201201s.VaultSecretGroup_STATUS) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_STATUS
		err := sourceVault.AssignPropertiesFromSubResourceSTATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SourceVault")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate_STATUS, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate_STATUS
			err := vaultCertificate.AssignPropertiesFromVaultCertificateSTATUS(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultCertificateSTATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultSecretGroupSTATUS populates the provided destination VaultSecretGroup_STATUS from our VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignPropertiesToVaultSecretGroupSTATUS(destination *alpha20201201s.VaultSecretGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceVault
	if group.SourceVault != nil {
		var sourceVault alpha20201201s.SubResource_STATUS
		err := group.SourceVault.AssignPropertiesToSubResourceSTATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]alpha20201201s.VaultCertificate_STATUS, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate alpha20201201s.VaultCertificate_STATUS
			err := vaultCertificateItem.AssignPropertiesToVaultCertificateSTATUS(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultCertificateSTATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineAgentInstanceView_STATUS. Use v1beta20201201.VirtualMachineAgentInstanceView_STATUS instead
type VirtualMachineAgentInstanceView_STATUS struct {
	ExtensionHandlers []VirtualMachineExtensionHandlerInstanceView_STATUS `json:"extensionHandlers,omitempty"`
	Statuses          []InstanceViewStatus_STATUS                         `json:"statuses,omitempty"`
	VmAgentVersion    *string                                             `json:"vmAgentVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineAgentInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *VirtualMachineAgentInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineAgentInstanceView_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *VirtualMachineAgentInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineAgentInstanceView_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineAgentInstanceView_STATUSARM, got %T", armInput)
	}

	// Set property ‘ExtensionHandlers’:
	for _, item := range typedInput.ExtensionHandlers {
		var item1 VirtualMachineExtensionHandlerInstanceView_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.ExtensionHandlers = append(view.ExtensionHandlers, item1)
	}

	// Set property ‘Statuses’:
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Statuses = append(view.Statuses, item1)
	}

	// Set property ‘VmAgentVersion’:
	if typedInput.VmAgentVersion != nil {
		vmAgentVersion := *typedInput.VmAgentVersion
		view.VmAgentVersion = &vmAgentVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineAgentInstanceViewSTATUS populates our VirtualMachineAgentInstanceView_STATUS from the provided source VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignPropertiesFromVirtualMachineAgentInstanceViewSTATUS(source *alpha20201201s.VirtualMachineAgentInstanceView_STATUS) error {

	// ExtensionHandlers
	if source.ExtensionHandlers != nil {
		extensionHandlerList := make([]VirtualMachineExtensionHandlerInstanceView_STATUS, len(source.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range source.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandler.AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewSTATUS(&extensionHandlerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewSTATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		view.ExtensionHandlers = extensionHandlerList
	} else {
		view.ExtensionHandlers = nil
	}

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignPropertiesFromInstanceViewStatusSTATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgentVersion
	view.VmAgentVersion = genruntime.ClonePointerToString(source.VmAgentVersion)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineAgentInstanceViewSTATUS populates the provided destination VirtualMachineAgentInstanceView_STATUS from our VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignPropertiesToVirtualMachineAgentInstanceViewSTATUS(destination *alpha20201201s.VirtualMachineAgentInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtensionHandlers
	if view.ExtensionHandlers != nil {
		extensionHandlerList := make([]alpha20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS, len(view.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range view.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler alpha20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandlerItem.AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewSTATUS(&extensionHandler)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewSTATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		destination.ExtensionHandlers = extensionHandlerList
	} else {
		destination.ExtensionHandlers = nil
	}

	// Statuses
	if view.Statuses != nil {
		statusList := make([]alpha20201201s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status alpha20201201s.InstanceViewStatus_STATUS
			err := statusItem.AssignPropertiesToInstanceViewStatusSTATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgentVersion
	destination.VmAgentVersion = genruntime.ClonePointerToString(view.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineExtensionInstanceView_STATUS. Use v1beta20201201.VirtualMachineExtensionInstanceView_STATUS instead
type VirtualMachineExtensionInstanceView_STATUS struct {
	Name               *string                     `json:"name,omitempty"`
	Statuses           []InstanceViewStatus_STATUS `json:"statuses,omitempty"`
	Substatuses        []InstanceViewStatus_STATUS `json:"substatuses,omitempty"`
	Type               *string                     `json:"type,omitempty"`
	TypeHandlerVersion *string                     `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineExtensionInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *VirtualMachineExtensionInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineExtensionInstanceView_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *VirtualMachineExtensionInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineExtensionInstanceView_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineExtensionInstanceView_STATUSARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		view.Name = &name
	}

	// Set property ‘Statuses’:
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Statuses = append(view.Statuses, item1)
	}

	// Set property ‘Substatuses’:
	for _, item := range typedInput.Substatuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Substatuses = append(view.Substatuses, item1)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		view.Type = &typeVar
	}

	// Set property ‘TypeHandlerVersion’:
	if typedInput.TypeHandlerVersion != nil {
		typeHandlerVersion := *typedInput.TypeHandlerVersion
		view.TypeHandlerVersion = &typeHandlerVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS populates our VirtualMachineExtensionInstanceView_STATUS from the provided source VirtualMachineExtensionInstanceView_STATUS
func (view *VirtualMachineExtensionInstanceView_STATUS) AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS(source *alpha20201201s.VirtualMachineExtensionInstanceView_STATUS) error {

	// Name
	view.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignPropertiesFromInstanceViewStatusSTATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// Substatuses
	if source.Substatuses != nil {
		substatusList := make([]InstanceViewStatus_STATUS, len(source.Substatuses))
		for substatusIndex, substatusItem := range source.Substatuses {
			// Shadow the loop variable to avoid aliasing
			substatusItem := substatusItem
			var substatus InstanceViewStatus_STATUS
			err := substatus.AssignPropertiesFromInstanceViewStatusSTATUS(&substatusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Substatuses")
			}
			substatusList[substatusIndex] = substatus
		}
		view.Substatuses = substatusList
	} else {
		view.Substatuses = nil
	}

	// Type
	view.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	view.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS populates the provided destination VirtualMachineExtensionInstanceView_STATUS from our VirtualMachineExtensionInstanceView_STATUS
func (view *VirtualMachineExtensionInstanceView_STATUS) AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS(destination *alpha20201201s.VirtualMachineExtensionInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(view.Name)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]alpha20201201s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status alpha20201201s.InstanceViewStatus_STATUS
			err := statusItem.AssignPropertiesToInstanceViewStatusSTATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Substatuses
	if view.Substatuses != nil {
		substatusList := make([]alpha20201201s.InstanceViewStatus_STATUS, len(view.Substatuses))
		for substatusIndex, substatusItem := range view.Substatuses {
			// Shadow the loop variable to avoid aliasing
			substatusItem := substatusItem
			var substatus alpha20201201s.InstanceViewStatus_STATUS
			err := substatusItem.AssignPropertiesToInstanceViewStatusSTATUS(&substatus)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Substatuses")
			}
			substatusList[substatusIndex] = substatus
		}
		destination.Substatuses = substatusList
	} else {
		destination.Substatuses = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(view.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(view.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineHealthStatus_STATUS. Use v1beta20201201.VirtualMachineHealthStatus_STATUS instead
type VirtualMachineHealthStatus_STATUS struct {
	Status *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineHealthStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *VirtualMachineHealthStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineHealthStatus_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *VirtualMachineHealthStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineHealthStatus_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineHealthStatus_STATUSARM, got %T", armInput)
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		var status2 InstanceViewStatus_STATUS
		err := status2.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status1 := status2
		status.Status = &status1
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineHealthStatusSTATUS populates our VirtualMachineHealthStatus_STATUS from the provided source VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignPropertiesFromVirtualMachineHealthStatusSTATUS(source *alpha20201201s.VirtualMachineHealthStatus_STATUS) error {

	// Status
	if source.Status != nil {
		var statusLocal InstanceViewStatus_STATUS
		err := statusLocal.AssignPropertiesFromInstanceViewStatusSTATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Status")
		}
		status.Status = &statusLocal
	} else {
		status.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineHealthStatusSTATUS populates the provided destination VirtualMachineHealthStatus_STATUS from our VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignPropertiesToVirtualMachineHealthStatusSTATUS(destination *alpha20201201s.VirtualMachineHealthStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Status
	if status.Status != nil {
		var statusLocal alpha20201201s.InstanceViewStatus_STATUS
		err := status.Status.AssignPropertiesToInstanceViewStatusSTATUS(&statusLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Status")
		}
		destination.Status = &statusLocal
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineInstanceViewSTATUSHyperVGeneration. Use
// v1beta20201201.VirtualMachineInstanceViewSTATUSHyperVGeneration instead
type VirtualMachineInstanceViewSTATUSHyperVGeneration string

const (
	VirtualMachineInstanceViewSTATUSHyperVGeneration_V1 = VirtualMachineInstanceViewSTATUSHyperVGeneration("V1")
	VirtualMachineInstanceViewSTATUSHyperVGeneration_V2 = VirtualMachineInstanceViewSTATUSHyperVGeneration("V2")
)

// Deprecated version of VirtualMachinePatchStatus_STATUS. Use v1beta20201201.VirtualMachinePatchStatus_STATUS instead
type VirtualMachinePatchStatus_STATUS struct {
	AvailablePatchSummary        *AvailablePatchSummary_STATUS        `json:"availablePatchSummary,omitempty"`
	ConfigurationStatuses        []InstanceViewStatus_STATUS          `json:"configurationStatuses,omitempty"`
	LastPatchInstallationSummary *LastPatchInstallationSummary_STATUS `json:"lastPatchInstallationSummary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachinePatchStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *VirtualMachinePatchStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachinePatchStatus_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *VirtualMachinePatchStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachinePatchStatus_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachinePatchStatus_STATUSARM, got %T", armInput)
	}

	// Set property ‘AvailablePatchSummary’:
	if typedInput.AvailablePatchSummary != nil {
		var availablePatchSummary1 AvailablePatchSummary_STATUS
		err := availablePatchSummary1.PopulateFromARM(owner, *typedInput.AvailablePatchSummary)
		if err != nil {
			return err
		}
		availablePatchSummary := availablePatchSummary1
		status.AvailablePatchSummary = &availablePatchSummary
	}

	// Set property ‘ConfigurationStatuses’:
	for _, item := range typedInput.ConfigurationStatuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		status.ConfigurationStatuses = append(status.ConfigurationStatuses, item1)
	}

	// Set property ‘LastPatchInstallationSummary’:
	if typedInput.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary1 LastPatchInstallationSummary_STATUS
		err := lastPatchInstallationSummary1.PopulateFromARM(owner, *typedInput.LastPatchInstallationSummary)
		if err != nil {
			return err
		}
		lastPatchInstallationSummary := lastPatchInstallationSummary1
		status.LastPatchInstallationSummary = &lastPatchInstallationSummary
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachinePatchStatusSTATUS populates our VirtualMachinePatchStatus_STATUS from the provided source VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignPropertiesFromVirtualMachinePatchStatusSTATUS(source *alpha20201201s.VirtualMachinePatchStatus_STATUS) error {

	// AvailablePatchSummary
	if source.AvailablePatchSummary != nil {
		var availablePatchSummary AvailablePatchSummary_STATUS
		err := availablePatchSummary.AssignPropertiesFromAvailablePatchSummarySTATUS(source.AvailablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAvailablePatchSummarySTATUS() to populate field AvailablePatchSummary")
		}
		status.AvailablePatchSummary = &availablePatchSummary
	} else {
		status.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if source.ConfigurationStatuses != nil {
		configurationStatusList := make([]InstanceViewStatus_STATUS, len(source.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range source.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus InstanceViewStatus_STATUS
			err := configurationStatus.AssignPropertiesFromInstanceViewStatusSTATUS(&configurationStatusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		status.ConfigurationStatuses = configurationStatusList
	} else {
		status.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if source.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary LastPatchInstallationSummary_STATUS
		err := lastPatchInstallationSummary.AssignPropertiesFromLastPatchInstallationSummarySTATUS(source.LastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLastPatchInstallationSummarySTATUS() to populate field LastPatchInstallationSummary")
		}
		status.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		status.LastPatchInstallationSummary = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinePatchStatusSTATUS populates the provided destination VirtualMachinePatchStatus_STATUS from our VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignPropertiesToVirtualMachinePatchStatusSTATUS(destination *alpha20201201s.VirtualMachinePatchStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailablePatchSummary
	if status.AvailablePatchSummary != nil {
		var availablePatchSummary alpha20201201s.AvailablePatchSummary_STATUS
		err := status.AvailablePatchSummary.AssignPropertiesToAvailablePatchSummarySTATUS(&availablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAvailablePatchSummarySTATUS() to populate field AvailablePatchSummary")
		}
		destination.AvailablePatchSummary = &availablePatchSummary
	} else {
		destination.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if status.ConfigurationStatuses != nil {
		configurationStatusList := make([]alpha20201201s.InstanceViewStatus_STATUS, len(status.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range status.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus alpha20201201s.InstanceViewStatus_STATUS
			err := configurationStatusItem.AssignPropertiesToInstanceViewStatusSTATUS(&configurationStatus)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		destination.ConfigurationStatuses = configurationStatusList
	} else {
		destination.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if status.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary alpha20201201s.LastPatchInstallationSummary_STATUS
		err := status.LastPatchInstallationSummary.AssignPropertiesToLastPatchInstallationSummarySTATUS(&lastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLastPatchInstallationSummarySTATUS() to populate field LastPatchInstallationSummary")
		}
		destination.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		destination.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces. Use v1beta20201201.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces instead
type VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces struct {
	Primary   *bool                         `json:"primary,omitempty"`
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (interfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if interfaces == nil {
		return nil, nil
	}
	result := &VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM{}

	// Set property ‘Id’:
	if interfaces.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*interfaces.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Properties’:
	if interfaces.Primary != nil {
		result.Properties = &NetworkInterfaceReferencePropertiesARM{}
	}
	if interfaces.Primary != nil {
		primary := *interfaces.Primary
		result.Properties.Primary = &primary
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (interfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (interfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM, got %T", armInput)
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			interfaces.Primary = &primary
		}
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces populates our VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces from the provided source VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
func (interfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(source *alpha20201201s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) error {

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		interfaces.Primary = &primary
	} else {
		interfaces.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		interfaces.Reference = &reference
	} else {
		interfaces.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces populates the provided destination VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces from our VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
func (interfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(destination *alpha20201201s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Primary
	if interfaces.Primary != nil {
		primary := *interfaces.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if interfaces.Reference != nil {
		reference := interfaces.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of WindowsConfiguration. Use v1beta20201201.WindowsConfiguration instead
type WindowsConfiguration struct {
	AdditionalUnattendContent []AdditionalUnattendContent `json:"additionalUnattendContent,omitempty"`
	EnableAutomaticUpdates    *bool                       `json:"enableAutomaticUpdates,omitempty"`
	PatchSettings             *PatchSettings              `json:"patchSettings,omitempty"`
	ProvisionVMAgent          *bool                       `json:"provisionVMAgent,omitempty"`
	TimeZone                  *string                     `json:"timeZone,omitempty"`
	WinRM                     *WinRMConfiguration         `json:"winRM,omitempty"`
}

var _ genruntime.ARMTransformer = &WindowsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *WindowsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &WindowsConfigurationARM{}

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range configuration.AdditionalUnattendContent {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AdditionalUnattendContent = append(result.AdditionalUnattendContent, *itemARM.(*AdditionalUnattendContentARM))
	}

	// Set property ‘EnableAutomaticUpdates’:
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *configuration.EnableAutomaticUpdates
		result.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if configuration.PatchSettings != nil {
		patchSettingsARM, err := (*configuration.PatchSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		patchSettings := *patchSettingsARM.(*PatchSettingsARM)
		result.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		result.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if configuration.TimeZone != nil {
		timeZone := *configuration.TimeZone
		result.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if configuration.WinRM != nil {
		winRMARM, err := (*configuration.WinRM).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		winRM := *winRMARM.(*WinRMConfigurationARM)
		result.WinRM = &winRM
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *WindowsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WindowsConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *WindowsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WindowsConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WindowsConfigurationARM, got %T", armInput)
	}

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range typedInput.AdditionalUnattendContent {
		var item1 AdditionalUnattendContent
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.AdditionalUnattendContent = append(configuration.AdditionalUnattendContent, item1)
	}

	// Set property ‘EnableAutomaticUpdates’:
	if typedInput.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *typedInput.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 PatchSettings
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		configuration.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		configuration.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if typedInput.WinRM != nil {
		var winRM1 WinRMConfiguration
		err := winRM1.PopulateFromARM(owner, *typedInput.WinRM)
		if err != nil {
			return err
		}
		winRM := winRM1
		configuration.WinRM = &winRM
	}

	// No error
	return nil
}

// AssignPropertiesFromWindowsConfiguration populates our WindowsConfiguration from the provided source WindowsConfiguration
func (configuration *WindowsConfiguration) AssignPropertiesFromWindowsConfiguration(source *alpha20201201s.WindowsConfiguration) error {

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent
			err := additionalUnattendContent.AssignPropertiesFromAdditionalUnattendContent(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromAdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings
		err := patchSetting.AssignPropertiesFromPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration
		err := winRM.AssignPropertiesFromWinRMConfiguration(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWinRMConfiguration() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWindowsConfiguration populates the provided destination WindowsConfiguration from our WindowsConfiguration
func (configuration *WindowsConfiguration) AssignPropertiesToWindowsConfiguration(destination *alpha20201201s.WindowsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]alpha20201201s.AdditionalUnattendContent, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent alpha20201201s.AdditionalUnattendContent
			err := additionalUnattendContentItem.AssignPropertiesToAdditionalUnattendContent(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToAdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting alpha20201201s.PatchSettings
		err := configuration.PatchSettings.AssignPropertiesToPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM alpha20201201s.WinRMConfiguration
		err := configuration.WinRM.AssignPropertiesToWinRMConfiguration(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWinRMConfiguration() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of WindowsConfiguration_STATUS. Use v1beta20201201.WindowsConfiguration_STATUS instead
type WindowsConfiguration_STATUS struct {
	AdditionalUnattendContent []AdditionalUnattendContent_STATUS `json:"additionalUnattendContent,omitempty"`
	EnableAutomaticUpdates    *bool                              `json:"enableAutomaticUpdates,omitempty"`
	PatchSettings             *PatchSettings_STATUS              `json:"patchSettings,omitempty"`
	ProvisionVMAgent          *bool                              `json:"provisionVMAgent,omitempty"`
	TimeZone                  *string                            `json:"timeZone,omitempty"`
	WinRM                     *WinRMConfiguration_STATUS         `json:"winRM,omitempty"`
}

var _ genruntime.FromARMConverter = &WindowsConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *WindowsConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WindowsConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *WindowsConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WindowsConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WindowsConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range typedInput.AdditionalUnattendContent {
		var item1 AdditionalUnattendContent_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.AdditionalUnattendContent = append(configuration.AdditionalUnattendContent, item1)
	}

	// Set property ‘EnableAutomaticUpdates’:
	if typedInput.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *typedInput.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 PatchSettings_STATUS
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		configuration.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		configuration.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if typedInput.WinRM != nil {
		var winRM1 WinRMConfiguration_STATUS
		err := winRM1.PopulateFromARM(owner, *typedInput.WinRM)
		if err != nil {
			return err
		}
		winRM := winRM1
		configuration.WinRM = &winRM
	}

	// No error
	return nil
}

// AssignPropertiesFromWindowsConfigurationSTATUS populates our WindowsConfiguration_STATUS from the provided source WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignPropertiesFromWindowsConfigurationSTATUS(source *alpha20201201s.WindowsConfiguration_STATUS) error {

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent_STATUS, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent_STATUS
			err := additionalUnattendContent.AssignPropertiesFromAdditionalUnattendContentSTATUS(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromAdditionalUnattendContentSTATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings_STATUS
		err := patchSetting.AssignPropertiesFromPatchSettingsSTATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPatchSettingsSTATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration_STATUS
		err := winRM.AssignPropertiesFromWinRMConfigurationSTATUS(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWinRMConfigurationSTATUS() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWindowsConfigurationSTATUS populates the provided destination WindowsConfiguration_STATUS from our WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignPropertiesToWindowsConfigurationSTATUS(destination *alpha20201201s.WindowsConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]alpha20201201s.AdditionalUnattendContent_STATUS, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent alpha20201201s.AdditionalUnattendContent_STATUS
			err := additionalUnattendContentItem.AssignPropertiesToAdditionalUnattendContentSTATUS(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToAdditionalUnattendContentSTATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting alpha20201201s.PatchSettings_STATUS
		err := configuration.PatchSettings.AssignPropertiesToPatchSettingsSTATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPatchSettingsSTATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM alpha20201201s.WinRMConfiguration_STATUS
		err := configuration.WinRM.AssignPropertiesToWinRMConfigurationSTATUS(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWinRMConfigurationSTATUS() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AdditionalUnattendContent. Use v1beta20201201.AdditionalUnattendContent instead
type AdditionalUnattendContent struct {
	ComponentName *AdditionalUnattendContentComponentName `json:"componentName,omitempty"`
	Content       *string                                 `json:"content,omitempty"`
	PassName      *AdditionalUnattendContentPassName      `json:"passName,omitempty"`
	SettingName   *AdditionalUnattendContentSettingName   `json:"settingName,omitempty"`
}

var _ genruntime.ARMTransformer = &AdditionalUnattendContent{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (content *AdditionalUnattendContent) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if content == nil {
		return nil, nil
	}
	result := &AdditionalUnattendContentARM{}

	// Set property ‘ComponentName’:
	if content.ComponentName != nil {
		componentName := *content.ComponentName
		result.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if content.Content != nil {
		content1 := *content.Content
		result.Content = &content1
	}

	// Set property ‘PassName’:
	if content.PassName != nil {
		passName := *content.PassName
		result.PassName = &passName
	}

	// Set property ‘SettingName’:
	if content.SettingName != nil {
		settingName := *content.SettingName
		result.SettingName = &settingName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (content *AdditionalUnattendContent) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalUnattendContentARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (content *AdditionalUnattendContent) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalUnattendContentARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalUnattendContentARM, got %T", armInput)
	}

	// Set property ‘ComponentName’:
	if typedInput.ComponentName != nil {
		componentName := *typedInput.ComponentName
		content.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if typedInput.Content != nil {
		content1 := *typedInput.Content
		content.Content = &content1
	}

	// Set property ‘PassName’:
	if typedInput.PassName != nil {
		passName := *typedInput.PassName
		content.PassName = &passName
	}

	// Set property ‘SettingName’:
	if typedInput.SettingName != nil {
		settingName := *typedInput.SettingName
		content.SettingName = &settingName
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalUnattendContent populates our AdditionalUnattendContent from the provided source AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignPropertiesFromAdditionalUnattendContent(source *alpha20201201s.AdditionalUnattendContent) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := AdditionalUnattendContentComponentName(*source.ComponentName)
		content.ComponentName = &componentName
	} else {
		content.ComponentName = nil
	}

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	if source.PassName != nil {
		passName := AdditionalUnattendContentPassName(*source.PassName)
		content.PassName = &passName
	} else {
		content.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := AdditionalUnattendContentSettingName(*source.SettingName)
		content.SettingName = &settingName
	} else {
		content.SettingName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalUnattendContent populates the provided destination AdditionalUnattendContent from our AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignPropertiesToAdditionalUnattendContent(destination *alpha20201201s.AdditionalUnattendContent) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComponentName
	if content.ComponentName != nil {
		componentName := string(*content.ComponentName)
		destination.ComponentName = &componentName
	} else {
		destination.ComponentName = nil
	}

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	if content.PassName != nil {
		passName := string(*content.PassName)
		destination.PassName = &passName
	} else {
		destination.PassName = nil
	}

	// SettingName
	if content.SettingName != nil {
		settingName := string(*content.SettingName)
		destination.SettingName = &settingName
	} else {
		destination.SettingName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AdditionalUnattendContent_STATUS. Use v1beta20201201.AdditionalUnattendContent_STATUS instead
type AdditionalUnattendContent_STATUS struct {
	ComponentName *AdditionalUnattendContentSTATUSComponentName `json:"componentName,omitempty"`
	Content       *string                                       `json:"content,omitempty"`
	PassName      *AdditionalUnattendContentSTATUSPassName      `json:"passName,omitempty"`
	SettingName   *AdditionalUnattendContentSTATUSSettingName   `json:"settingName,omitempty"`
}

var _ genruntime.FromARMConverter = &AdditionalUnattendContent_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (content *AdditionalUnattendContent_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalUnattendContent_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (content *AdditionalUnattendContent_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalUnattendContent_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalUnattendContent_STATUSARM, got %T", armInput)
	}

	// Set property ‘ComponentName’:
	if typedInput.ComponentName != nil {
		componentName := *typedInput.ComponentName
		content.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if typedInput.Content != nil {
		content1 := *typedInput.Content
		content.Content = &content1
	}

	// Set property ‘PassName’:
	if typedInput.PassName != nil {
		passName := *typedInput.PassName
		content.PassName = &passName
	}

	// Set property ‘SettingName’:
	if typedInput.SettingName != nil {
		settingName := *typedInput.SettingName
		content.SettingName = &settingName
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalUnattendContentSTATUS populates our AdditionalUnattendContent_STATUS from the provided source AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignPropertiesFromAdditionalUnattendContentSTATUS(source *alpha20201201s.AdditionalUnattendContent_STATUS) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := AdditionalUnattendContentSTATUSComponentName(*source.ComponentName)
		content.ComponentName = &componentName
	} else {
		content.ComponentName = nil
	}

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	if source.PassName != nil {
		passName := AdditionalUnattendContentSTATUSPassName(*source.PassName)
		content.PassName = &passName
	} else {
		content.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := AdditionalUnattendContentSTATUSSettingName(*source.SettingName)
		content.SettingName = &settingName
	} else {
		content.SettingName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalUnattendContentSTATUS populates the provided destination AdditionalUnattendContent_STATUS from our AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignPropertiesToAdditionalUnattendContentSTATUS(destination *alpha20201201s.AdditionalUnattendContent_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComponentName
	if content.ComponentName != nil {
		componentName := string(*content.ComponentName)
		destination.ComponentName = &componentName
	} else {
		destination.ComponentName = nil
	}

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	if content.PassName != nil {
		passName := string(*content.PassName)
		destination.PassName = &passName
	} else {
		destination.PassName = nil
	}

	// SettingName
	if content.SettingName != nil {
		settingName := string(*content.SettingName)
		destination.SettingName = &settingName
	} else {
		destination.SettingName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AvailablePatchSummary_STATUS. Use v1beta20201201.AvailablePatchSummary_STATUS instead
type AvailablePatchSummary_STATUS struct {
	AssessmentActivityId          *string                            `json:"assessmentActivityId,omitempty"`
	CriticalAndSecurityPatchCount *int                               `json:"criticalAndSecurityPatchCount,omitempty"`
	Error                         *ApiError_STATUS                   `json:"error,omitempty"`
	LastModifiedTime              *string                            `json:"lastModifiedTime,omitempty"`
	OtherPatchCount               *int                               `json:"otherPatchCount,omitempty"`
	RebootPending                 *bool                              `json:"rebootPending,omitempty"`
	StartTime                     *string                            `json:"startTime,omitempty"`
	Status                        *AvailablePatchSummarySTATUSStatus `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &AvailablePatchSummary_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (summary *AvailablePatchSummary_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AvailablePatchSummary_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (summary *AvailablePatchSummary_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AvailablePatchSummary_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AvailablePatchSummary_STATUSARM, got %T", armInput)
	}

	// Set property ‘AssessmentActivityId’:
	if typedInput.AssessmentActivityId != nil {
		assessmentActivityId := *typedInput.AssessmentActivityId
		summary.AssessmentActivityId = &assessmentActivityId
	}

	// Set property ‘CriticalAndSecurityPatchCount’:
	if typedInput.CriticalAndSecurityPatchCount != nil {
		criticalAndSecurityPatchCount := *typedInput.CriticalAndSecurityPatchCount
		summary.CriticalAndSecurityPatchCount = &criticalAndSecurityPatchCount
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error1 ApiError_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		summary.Error = &error
	}

	// Set property ‘LastModifiedTime’:
	if typedInput.LastModifiedTime != nil {
		lastModifiedTime := *typedInput.LastModifiedTime
		summary.LastModifiedTime = &lastModifiedTime
	}

	// Set property ‘OtherPatchCount’:
	if typedInput.OtherPatchCount != nil {
		otherPatchCount := *typedInput.OtherPatchCount
		summary.OtherPatchCount = &otherPatchCount
	}

	// Set property ‘RebootPending’:
	if typedInput.RebootPending != nil {
		rebootPending := *typedInput.RebootPending
		summary.RebootPending = &rebootPending
	}

	// Set property ‘StartTime’:
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		summary.StartTime = &startTime
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		summary.Status = &status
	}

	// No error
	return nil
}

// AssignPropertiesFromAvailablePatchSummarySTATUS populates our AvailablePatchSummary_STATUS from the provided source AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignPropertiesFromAvailablePatchSummarySTATUS(source *alpha20201201s.AvailablePatchSummary_STATUS) error {

	// AssessmentActivityId
	summary.AssessmentActivityId = genruntime.ClonePointerToString(source.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	summary.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(source.CriticalAndSecurityPatchCount)

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignPropertiesFromApiErrorSTATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiErrorSTATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// OtherPatchCount
	summary.OtherPatchCount = genruntime.ClonePointerToInt(source.OtherPatchCount)

	// RebootPending
	if source.RebootPending != nil {
		rebootPending := *source.RebootPending
		summary.RebootPending = &rebootPending
	} else {
		summary.RebootPending = nil
	}

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	if source.Status != nil {
		status := AvailablePatchSummarySTATUSStatus(*source.Status)
		summary.Status = &status
	} else {
		summary.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAvailablePatchSummarySTATUS populates the provided destination AvailablePatchSummary_STATUS from our AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignPropertiesToAvailablePatchSummarySTATUS(destination *alpha20201201s.AvailablePatchSummary_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssessmentActivityId
	destination.AssessmentActivityId = genruntime.ClonePointerToString(summary.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	destination.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(summary.CriticalAndSecurityPatchCount)

	// Error
	if summary.Error != nil {
		var error alpha20201201s.ApiError_STATUS
		err := summary.Error.AssignPropertiesToApiErrorSTATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiErrorSTATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// OtherPatchCount
	destination.OtherPatchCount = genruntime.ClonePointerToInt(summary.OtherPatchCount)

	// RebootPending
	if summary.RebootPending != nil {
		rebootPending := *summary.RebootPending
		destination.RebootPending = &rebootPending
	} else {
		destination.RebootPending = nil
	}

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	if summary.Status != nil {
		status := string(*summary.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Caching_STATUS. Use v1beta20201201.Caching_STATUS instead
type Caching_STATUS string

const (
	Caching_STATUS_None      = Caching_STATUS("None")
	Caching_STATUS_ReadOnly  = Caching_STATUS("ReadOnly")
	Caching_STATUS_ReadWrite = Caching_STATUS("ReadWrite")
)

// Deprecated version of CreateOption_STATUS. Use v1beta20201201.CreateOption_STATUS instead
type CreateOption_STATUS string

const (
	CreateOption_STATUS_Attach    = CreateOption_STATUS("Attach")
	CreateOption_STATUS_Empty     = CreateOption_STATUS("Empty")
	CreateOption_STATUS_FromImage = CreateOption_STATUS("FromImage")
)

// Deprecated version of DataDiskCaching. Use v1beta20201201.DataDiskCaching instead
// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type DataDiskCaching string

const (
	DataDiskCaching_None      = DataDiskCaching("None")
	DataDiskCaching_ReadOnly  = DataDiskCaching("ReadOnly")
	DataDiskCaching_ReadWrite = DataDiskCaching("ReadWrite")
)

// Deprecated version of DataDiskCreateOption. Use v1beta20201201.DataDiskCreateOption instead
// +kubebuilder:validation:Enum={"Attach","Empty","FromImage"}
type DataDiskCreateOption string

const (
	DataDiskCreateOption_Attach    = DataDiskCreateOption("Attach")
	DataDiskCreateOption_Empty     = DataDiskCreateOption("Empty")
	DataDiskCreateOption_FromImage = DataDiskCreateOption("FromImage")
)

// Deprecated version of DataDiskDetachOption. Use v1beta20201201.DataDiskDetachOption instead
// +kubebuilder:validation:Enum={"ForceDetach"}
type DataDiskDetachOption string

const DataDiskDetachOption_ForceDetach = DataDiskDetachOption("ForceDetach")

// Deprecated version of DetachOption_STATUS. Use v1beta20201201.DetachOption_STATUS instead
type DetachOption_STATUS string

const DetachOption_STATUS_ForceDetach = DetachOption_STATUS("ForceDetach")

// Deprecated version of DiffDiskSettings. Use v1beta20201201.DiffDiskSettings instead
type DiffDiskSettings struct {
	Option    *DiffDiskSettingsOption    `json:"option,omitempty"`
	Placement *DiffDiskSettingsPlacement `json:"placement,omitempty"`
}

var _ genruntime.ARMTransformer = &DiffDiskSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *DiffDiskSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &DiffDiskSettingsARM{}

	// Set property ‘Option’:
	if settings.Option != nil {
		option := *settings.Option
		result.Option = &option
	}

	// Set property ‘Placement’:
	if settings.Placement != nil {
		placement := *settings.Placement
		result.Placement = &placement
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DiffDiskSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiffDiskSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DiffDiskSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiffDiskSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiffDiskSettingsARM, got %T", armInput)
	}

	// Set property ‘Option’:
	if typedInput.Option != nil {
		option := *typedInput.Option
		settings.Option = &option
	}

	// Set property ‘Placement’:
	if typedInput.Placement != nil {
		placement := *typedInput.Placement
		settings.Placement = &placement
	}

	// No error
	return nil
}

// AssignPropertiesFromDiffDiskSettings populates our DiffDiskSettings from the provided source DiffDiskSettings
func (settings *DiffDiskSettings) AssignPropertiesFromDiffDiskSettings(source *alpha20201201s.DiffDiskSettings) error {

	// Option
	if source.Option != nil {
		option := DiffDiskSettingsOption(*source.Option)
		settings.Option = &option
	} else {
		settings.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := DiffDiskSettingsPlacement(*source.Placement)
		settings.Placement = &placement
	} else {
		settings.Placement = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiffDiskSettings populates the provided destination DiffDiskSettings from our DiffDiskSettings
func (settings *DiffDiskSettings) AssignPropertiesToDiffDiskSettings(destination *alpha20201201s.DiffDiskSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Option
	if settings.Option != nil {
		option := string(*settings.Option)
		destination.Option = &option
	} else {
		destination.Option = nil
	}

	// Placement
	if settings.Placement != nil {
		placement := string(*settings.Placement)
		destination.Placement = &placement
	} else {
		destination.Placement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of DiffDiskSettings_STATUS. Use v1beta20201201.DiffDiskSettings_STATUS instead
type DiffDiskSettings_STATUS struct {
	Option    *DiffDiskOption_STATUS    `json:"option,omitempty"`
	Placement *DiffDiskPlacement_STATUS `json:"placement,omitempty"`
}

var _ genruntime.FromARMConverter = &DiffDiskSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DiffDiskSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiffDiskSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DiffDiskSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiffDiskSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiffDiskSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘Option’:
	if typedInput.Option != nil {
		option := *typedInput.Option
		settings.Option = &option
	}

	// Set property ‘Placement’:
	if typedInput.Placement != nil {
		placement := *typedInput.Placement
		settings.Placement = &placement
	}

	// No error
	return nil
}

// AssignPropertiesFromDiffDiskSettingsSTATUS populates our DiffDiskSettings_STATUS from the provided source DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignPropertiesFromDiffDiskSettingsSTATUS(source *alpha20201201s.DiffDiskSettings_STATUS) error {

	// Option
	if source.Option != nil {
		option := DiffDiskOption_STATUS(*source.Option)
		settings.Option = &option
	} else {
		settings.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := DiffDiskPlacement_STATUS(*source.Placement)
		settings.Placement = &placement
	} else {
		settings.Placement = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiffDiskSettingsSTATUS populates the provided destination DiffDiskSettings_STATUS from our DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignPropertiesToDiffDiskSettingsSTATUS(destination *alpha20201201s.DiffDiskSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Option
	if settings.Option != nil {
		option := string(*settings.Option)
		destination.Option = &option
	} else {
		destination.Option = nil
	}

	// Placement
	if settings.Placement != nil {
		placement := string(*settings.Placement)
		destination.Placement = &placement
	} else {
		destination.Placement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of DiskEncryptionSettings. Use v1beta20201201.DiskEncryptionSettings instead
type DiskEncryptionSettings struct {
	DiskEncryptionKey *KeyVaultSecretReference `json:"diskEncryptionKey,omitempty"`
	Enabled           *bool                    `json:"enabled,omitempty"`
	KeyEncryptionKey  *KeyVaultKeyReference    `json:"keyEncryptionKey,omitempty"`
}

var _ genruntime.ARMTransformer = &DiskEncryptionSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *DiskEncryptionSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &DiskEncryptionSettingsARM{}

	// Set property ‘DiskEncryptionKey’:
	if settings.DiskEncryptionKey != nil {
		diskEncryptionKeyARM, err := (*settings.DiskEncryptionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionKey := *diskEncryptionKeyARM.(*KeyVaultSecretReferenceARM)
		result.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘Enabled’:
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘KeyEncryptionKey’:
	if settings.KeyEncryptionKey != nil {
		keyEncryptionKeyARM, err := (*settings.KeyEncryptionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyEncryptionKey := *keyEncryptionKeyARM.(*KeyVaultKeyReferenceARM)
		result.KeyEncryptionKey = &keyEncryptionKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DiskEncryptionSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskEncryptionSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DiskEncryptionSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiskEncryptionSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskEncryptionSettingsARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionKey’:
	if typedInput.DiskEncryptionKey != nil {
		var diskEncryptionKey1 KeyVaultSecretReference
		err := diskEncryptionKey1.PopulateFromARM(owner, *typedInput.DiskEncryptionKey)
		if err != nil {
			return err
		}
		diskEncryptionKey := diskEncryptionKey1
		settings.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		settings.Enabled = &enabled
	}

	// Set property ‘KeyEncryptionKey’:
	if typedInput.KeyEncryptionKey != nil {
		var keyEncryptionKey1 KeyVaultKeyReference
		err := keyEncryptionKey1.PopulateFromARM(owner, *typedInput.KeyEncryptionKey)
		if err != nil {
			return err
		}
		keyEncryptionKey := keyEncryptionKey1
		settings.KeyEncryptionKey = &keyEncryptionKey
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskEncryptionSettings populates our DiskEncryptionSettings from the provided source DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignPropertiesFromDiskEncryptionSettings(source *alpha20201201s.DiskEncryptionSettings) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference
		err := diskEncryptionKey.AssignPropertiesFromKeyVaultSecretReference(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference
		err := keyEncryptionKey.AssignPropertiesFromKeyVaultKeyReference(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSettings populates the provided destination DiskEncryptionSettings from our DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignPropertiesToDiskEncryptionSettings(destination *alpha20201201s.DiskEncryptionSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey alpha20201201s.KeyVaultSecretReference
		err := settings.DiskEncryptionKey.AssignPropertiesToKeyVaultSecretReference(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey alpha20201201s.KeyVaultKeyReference
		err := settings.KeyEncryptionKey.AssignPropertiesToKeyVaultKeyReference(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of DiskEncryptionSettings_STATUS. Use v1beta20201201.DiskEncryptionSettings_STATUS instead
type DiskEncryptionSettings_STATUS struct {
	DiskEncryptionKey *KeyVaultSecretReference_STATUS `json:"diskEncryptionKey,omitempty"`
	Enabled           *bool                           `json:"enabled,omitempty"`
	KeyEncryptionKey  *KeyVaultKeyReference_STATUS    `json:"keyEncryptionKey,omitempty"`
}

var _ genruntime.FromARMConverter = &DiskEncryptionSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DiskEncryptionSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskEncryptionSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DiskEncryptionSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiskEncryptionSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskEncryptionSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionKey’:
	if typedInput.DiskEncryptionKey != nil {
		var diskEncryptionKey1 KeyVaultSecretReference_STATUS
		err := diskEncryptionKey1.PopulateFromARM(owner, *typedInput.DiskEncryptionKey)
		if err != nil {
			return err
		}
		diskEncryptionKey := diskEncryptionKey1
		settings.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		settings.Enabled = &enabled
	}

	// Set property ‘KeyEncryptionKey’:
	if typedInput.KeyEncryptionKey != nil {
		var keyEncryptionKey1 KeyVaultKeyReference_STATUS
		err := keyEncryptionKey1.PopulateFromARM(owner, *typedInput.KeyEncryptionKey)
		if err != nil {
			return err
		}
		keyEncryptionKey := keyEncryptionKey1
		settings.KeyEncryptionKey = &keyEncryptionKey
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskEncryptionSettingsSTATUS populates our DiskEncryptionSettings_STATUS from the provided source DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignPropertiesFromDiskEncryptionSettingsSTATUS(source *alpha20201201s.DiskEncryptionSettings_STATUS) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference_STATUS
		err := diskEncryptionKey.AssignPropertiesFromKeyVaultSecretReferenceSTATUS(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultSecretReferenceSTATUS() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference_STATUS
		err := keyEncryptionKey.AssignPropertiesFromKeyVaultKeyReferenceSTATUS(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultKeyReferenceSTATUS() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSettingsSTATUS populates the provided destination DiskEncryptionSettings_STATUS from our DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignPropertiesToDiskEncryptionSettingsSTATUS(destination *alpha20201201s.DiskEncryptionSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey alpha20201201s.KeyVaultSecretReference_STATUS
		err := settings.DiskEncryptionKey.AssignPropertiesToKeyVaultSecretReferenceSTATUS(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultSecretReferenceSTATUS() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey alpha20201201s.KeyVaultKeyReference_STATUS
		err := settings.KeyEncryptionKey.AssignPropertiesToKeyVaultKeyReferenceSTATUS(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultKeyReferenceSTATUS() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of InstanceViewStatusSTATUSLevel. Use v1beta20201201.InstanceViewStatusSTATUSLevel instead
type InstanceViewStatusSTATUSLevel string

const (
	InstanceViewStatusSTATUSLevel_Error   = InstanceViewStatusSTATUSLevel("Error")
	InstanceViewStatusSTATUSLevel_Info    = InstanceViewStatusSTATUSLevel("Info")
	InstanceViewStatusSTATUSLevel_Warning = InstanceViewStatusSTATUSLevel("Warning")
)

// Deprecated version of LastPatchInstallationSummary_STATUS. Use v1beta20201201.LastPatchInstallationSummary_STATUS instead
type LastPatchInstallationSummary_STATUS struct {
	Error                     *ApiError_STATUS                          `json:"error,omitempty"`
	ExcludedPatchCount        *int                                      `json:"excludedPatchCount,omitempty"`
	FailedPatchCount          *int                                      `json:"failedPatchCount,omitempty"`
	InstallationActivityId    *string                                   `json:"installationActivityId,omitempty"`
	InstalledPatchCount       *int                                      `json:"installedPatchCount,omitempty"`
	LastModifiedTime          *string                                   `json:"lastModifiedTime,omitempty"`
	MaintenanceWindowExceeded *bool                                     `json:"maintenanceWindowExceeded,omitempty"`
	NotSelectedPatchCount     *int                                      `json:"notSelectedPatchCount,omitempty"`
	PendingPatchCount         *int                                      `json:"pendingPatchCount,omitempty"`
	StartTime                 *string                                   `json:"startTime,omitempty"`
	Status                    *LastPatchInstallationSummarySTATUSStatus `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &LastPatchInstallationSummary_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (summary *LastPatchInstallationSummary_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LastPatchInstallationSummary_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (summary *LastPatchInstallationSummary_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LastPatchInstallationSummary_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LastPatchInstallationSummary_STATUSARM, got %T", armInput)
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error1 ApiError_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		summary.Error = &error
	}

	// Set property ‘ExcludedPatchCount’:
	if typedInput.ExcludedPatchCount != nil {
		excludedPatchCount := *typedInput.ExcludedPatchCount
		summary.ExcludedPatchCount = &excludedPatchCount
	}

	// Set property ‘FailedPatchCount’:
	if typedInput.FailedPatchCount != nil {
		failedPatchCount := *typedInput.FailedPatchCount
		summary.FailedPatchCount = &failedPatchCount
	}

	// Set property ‘InstallationActivityId’:
	if typedInput.InstallationActivityId != nil {
		installationActivityId := *typedInput.InstallationActivityId
		summary.InstallationActivityId = &installationActivityId
	}

	// Set property ‘InstalledPatchCount’:
	if typedInput.InstalledPatchCount != nil {
		installedPatchCount := *typedInput.InstalledPatchCount
		summary.InstalledPatchCount = &installedPatchCount
	}

	// Set property ‘LastModifiedTime’:
	if typedInput.LastModifiedTime != nil {
		lastModifiedTime := *typedInput.LastModifiedTime
		summary.LastModifiedTime = &lastModifiedTime
	}

	// Set property ‘MaintenanceWindowExceeded’:
	if typedInput.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *typedInput.MaintenanceWindowExceeded
		summary.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	}

	// Set property ‘NotSelectedPatchCount’:
	if typedInput.NotSelectedPatchCount != nil {
		notSelectedPatchCount := *typedInput.NotSelectedPatchCount
		summary.NotSelectedPatchCount = &notSelectedPatchCount
	}

	// Set property ‘PendingPatchCount’:
	if typedInput.PendingPatchCount != nil {
		pendingPatchCount := *typedInput.PendingPatchCount
		summary.PendingPatchCount = &pendingPatchCount
	}

	// Set property ‘StartTime’:
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		summary.StartTime = &startTime
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		summary.Status = &status
	}

	// No error
	return nil
}

// AssignPropertiesFromLastPatchInstallationSummarySTATUS populates our LastPatchInstallationSummary_STATUS from the provided source LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignPropertiesFromLastPatchInstallationSummarySTATUS(source *alpha20201201s.LastPatchInstallationSummary_STATUS) error {

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignPropertiesFromApiErrorSTATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiErrorSTATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// ExcludedPatchCount
	summary.ExcludedPatchCount = genruntime.ClonePointerToInt(source.ExcludedPatchCount)

	// FailedPatchCount
	summary.FailedPatchCount = genruntime.ClonePointerToInt(source.FailedPatchCount)

	// InstallationActivityId
	summary.InstallationActivityId = genruntime.ClonePointerToString(source.InstallationActivityId)

	// InstalledPatchCount
	summary.InstalledPatchCount = genruntime.ClonePointerToInt(source.InstalledPatchCount)

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// MaintenanceWindowExceeded
	if source.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *source.MaintenanceWindowExceeded
		summary.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		summary.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	summary.NotSelectedPatchCount = genruntime.ClonePointerToInt(source.NotSelectedPatchCount)

	// PendingPatchCount
	summary.PendingPatchCount = genruntime.ClonePointerToInt(source.PendingPatchCount)

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	if source.Status != nil {
		status := LastPatchInstallationSummarySTATUSStatus(*source.Status)
		summary.Status = &status
	} else {
		summary.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLastPatchInstallationSummarySTATUS populates the provided destination LastPatchInstallationSummary_STATUS from our LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignPropertiesToLastPatchInstallationSummarySTATUS(destination *alpha20201201s.LastPatchInstallationSummary_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if summary.Error != nil {
		var error alpha20201201s.ApiError_STATUS
		err := summary.Error.AssignPropertiesToApiErrorSTATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiErrorSTATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// ExcludedPatchCount
	destination.ExcludedPatchCount = genruntime.ClonePointerToInt(summary.ExcludedPatchCount)

	// FailedPatchCount
	destination.FailedPatchCount = genruntime.ClonePointerToInt(summary.FailedPatchCount)

	// InstallationActivityId
	destination.InstallationActivityId = genruntime.ClonePointerToString(summary.InstallationActivityId)

	// InstalledPatchCount
	destination.InstalledPatchCount = genruntime.ClonePointerToInt(summary.InstalledPatchCount)

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// MaintenanceWindowExceeded
	if summary.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *summary.MaintenanceWindowExceeded
		destination.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		destination.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	destination.NotSelectedPatchCount = genruntime.ClonePointerToInt(summary.NotSelectedPatchCount)

	// PendingPatchCount
	destination.PendingPatchCount = genruntime.ClonePointerToInt(summary.PendingPatchCount)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	if summary.Status != nil {
		status := string(*summary.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LinuxPatchSettings. Use v1beta20201201.LinuxPatchSettings instead
type LinuxPatchSettings struct {
	PatchMode *LinuxPatchSettingsPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxPatchSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *LinuxPatchSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &LinuxPatchSettingsARM{}

	// Set property ‘PatchMode’:
	if settings.PatchMode != nil {
		patchMode := *settings.PatchMode
		result.PatchMode = &patchMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LinuxPatchSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxPatchSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LinuxPatchSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxPatchSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxPatchSettingsARM, got %T", armInput)
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		settings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxPatchSettings populates our LinuxPatchSettings from the provided source LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignPropertiesFromLinuxPatchSettings(source *alpha20201201s.LinuxPatchSettings) error {

	// PatchMode
	if source.PatchMode != nil {
		patchMode := LinuxPatchSettingsPatchMode(*source.PatchMode)
		settings.PatchMode = &patchMode
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxPatchSettings populates the provided destination LinuxPatchSettings from our LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignPropertiesToLinuxPatchSettings(destination *alpha20201201s.LinuxPatchSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PatchMode
	if settings.PatchMode != nil {
		patchMode := string(*settings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LinuxPatchSettings_STATUS. Use v1beta20201201.LinuxPatchSettings_STATUS instead
type LinuxPatchSettings_STATUS struct {
	PatchMode *LinuxPatchSettingsSTATUSPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxPatchSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LinuxPatchSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxPatchSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LinuxPatchSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxPatchSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxPatchSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		settings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxPatchSettingsSTATUS populates our LinuxPatchSettings_STATUS from the provided source LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignPropertiesFromLinuxPatchSettingsSTATUS(source *alpha20201201s.LinuxPatchSettings_STATUS) error {

	// PatchMode
	if source.PatchMode != nil {
		patchMode := LinuxPatchSettingsSTATUSPatchMode(*source.PatchMode)
		settings.PatchMode = &patchMode
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxPatchSettingsSTATUS populates the provided destination LinuxPatchSettings_STATUS from our LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignPropertiesToLinuxPatchSettingsSTATUS(destination *alpha20201201s.LinuxPatchSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PatchMode
	if settings.PatchMode != nil {
		patchMode := string(*settings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of MaintenanceRedeployStatusSTATUSLastOperationResultCode. Use
// v1beta20201201.MaintenanceRedeployStatusSTATUSLastOperationResultCode instead
type MaintenanceRedeployStatusSTATUSLastOperationResultCode string

const (
	MaintenanceRedeployStatusSTATUSLastOperationResultCode_MaintenanceAborted   = MaintenanceRedeployStatusSTATUSLastOperationResultCode("MaintenanceAborted")
	MaintenanceRedeployStatusSTATUSLastOperationResultCode_MaintenanceCompleted = MaintenanceRedeployStatusSTATUSLastOperationResultCode("MaintenanceCompleted")
	MaintenanceRedeployStatusSTATUSLastOperationResultCode_None                 = MaintenanceRedeployStatusSTATUSLastOperationResultCode("None")
	MaintenanceRedeployStatusSTATUSLastOperationResultCode_RetryLater           = MaintenanceRedeployStatusSTATUSLastOperationResultCode("RetryLater")
)

// Deprecated version of ManagedDiskParameters. Use v1beta20201201.ManagedDiskParameters instead
type ManagedDiskParameters struct {
	DiskEncryptionSet  *DiskEncryptionSetParameters             `json:"diskEncryptionSet,omitempty"`
	Reference          *genruntime.ResourceReference            `armReference:"Id" json:"reference,omitempty"`
	StorageAccountType *ManagedDiskParametersStorageAccountType `json:"storageAccountType,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedDiskParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *ManagedDiskParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &ManagedDiskParametersARM{}

	// Set property ‘DiskEncryptionSet’:
	if parameters.DiskEncryptionSet != nil {
		diskEncryptionSetARM, err := (*parameters.DiskEncryptionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionSet := *diskEncryptionSetARM.(*DiskEncryptionSetParametersARM)
		result.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘Id’:
	if parameters.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*parameters.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘StorageAccountType’:
	if parameters.StorageAccountType != nil {
		storageAccountType := *parameters.StorageAccountType
		result.StorageAccountType = &storageAccountType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ManagedDiskParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedDiskParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ManagedDiskParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedDiskParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedDiskParametersARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 DiskEncryptionSetParameters
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// no assignment for property ‘Reference’

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedDiskParameters populates our ManagedDiskParameters from the provided source ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignPropertiesFromManagedDiskParameters(source *alpha20201201s.ManagedDiskParameters) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet DiskEncryptionSetParameters
		err := diskEncryptionSet.AssignPropertiesFromDiskEncryptionSetParameters(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSetParameters() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		parameters.Reference = &reference
	} else {
		parameters.Reference = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := ManagedDiskParametersStorageAccountType(*source.StorageAccountType)
		parameters.StorageAccountType = &storageAccountType
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedDiskParameters populates the provided destination ManagedDiskParameters from our ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignPropertiesToManagedDiskParameters(destination *alpha20201201s.ManagedDiskParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet alpha20201201s.DiskEncryptionSetParameters
		err := parameters.DiskEncryptionSet.AssignPropertiesToDiskEncryptionSetParameters(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSetParameters() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Reference
	if parameters.Reference != nil {
		reference := parameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ManagedDiskParameters_STATUS. Use v1beta20201201.ManagedDiskParameters_STATUS instead
type ManagedDiskParameters_STATUS struct {
	DiskEncryptionSet  *SubResource_STATUS        `json:"diskEncryptionSet,omitempty"`
	Id                 *string                    `json:"id,omitempty"`
	StorageAccountType *StorageAccountType_STATUS `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedDiskParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ManagedDiskParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedDiskParameters_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ManagedDiskParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedDiskParameters_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedDiskParameters_STATUSARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_STATUS
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		parameters.Id = &id
	}

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedDiskParametersSTATUS populates our ManagedDiskParameters_STATUS from the provided source ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignPropertiesFromManagedDiskParametersSTATUS(source *alpha20201201s.ManagedDiskParameters_STATUS) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_STATUS
		err := diskEncryptionSet.AssignPropertiesFromSubResourceSTATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Id
	parameters.Id = genruntime.ClonePointerToString(source.Id)

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := StorageAccountType_STATUS(*source.StorageAccountType)
		parameters.StorageAccountType = &storageAccountType
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedDiskParametersSTATUS populates the provided destination ManagedDiskParameters_STATUS from our ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignPropertiesToManagedDiskParametersSTATUS(destination *alpha20201201s.ManagedDiskParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet alpha20201201s.SubResource_STATUS
		err := parameters.DiskEncryptionSet.AssignPropertiesToSubResourceSTATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(parameters.Id)

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of OSDiskCaching. Use v1beta20201201.OSDiskCaching instead
// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type OSDiskCaching string

const (
	OSDiskCaching_None      = OSDiskCaching("None")
	OSDiskCaching_ReadOnly  = OSDiskCaching("ReadOnly")
	OSDiskCaching_ReadWrite = OSDiskCaching("ReadWrite")
)

// Deprecated version of OSDiskCreateOption. Use v1beta20201201.OSDiskCreateOption instead
// +kubebuilder:validation:Enum={"Attach","Empty","FromImage"}
type OSDiskCreateOption string

const (
	OSDiskCreateOption_Attach    = OSDiskCreateOption("Attach")
	OSDiskCreateOption_Empty     = OSDiskCreateOption("Empty")
	OSDiskCreateOption_FromImage = OSDiskCreateOption("FromImage")
)

// Deprecated version of OSDiskOsType. Use v1beta20201201.OSDiskOsType instead
// +kubebuilder:validation:Enum={"Linux","Windows"}
type OSDiskOsType string

const (
	OSDiskOsType_Linux   = OSDiskOsType("Linux")
	OSDiskOsType_Windows = OSDiskOsType("Windows")
)

// Deprecated version of OSDiskSTATUSOsType. Use v1beta20201201.OSDiskSTATUSOsType instead
type OSDiskSTATUSOsType string

const (
	OSDiskSTATUSOsType_Linux   = OSDiskSTATUSOsType("Linux")
	OSDiskSTATUSOsType_Windows = OSDiskSTATUSOsType("Windows")
)

// Deprecated version of PatchSettings. Use v1beta20201201.PatchSettings instead
type PatchSettings struct {
	EnableHotpatching *bool                   `json:"enableHotpatching,omitempty"`
	PatchMode         *PatchSettingsPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.ARMTransformer = &PatchSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PatchSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &PatchSettingsARM{}

	// Set property ‘EnableHotpatching’:
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		result.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if settings.PatchMode != nil {
		patchMode := *settings.PatchMode
		result.PatchMode = &patchMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PatchSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PatchSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PatchSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PatchSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PatchSettingsARM, got %T", armInput)
	}

	// Set property ‘EnableHotpatching’:
	if typedInput.EnableHotpatching != nil {
		enableHotpatching := *typedInput.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		settings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromPatchSettings populates our PatchSettings from the provided source PatchSettings
func (settings *PatchSettings) AssignPropertiesFromPatchSettings(source *alpha20201201s.PatchSettings) error {

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := PatchSettingsPatchMode(*source.PatchMode)
		settings.PatchMode = &patchMode
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPatchSettings populates the provided destination PatchSettings from our PatchSettings
func (settings *PatchSettings) AssignPropertiesToPatchSettings(destination *alpha20201201s.PatchSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	if settings.PatchMode != nil {
		patchMode := string(*settings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of PatchSettings_STATUS. Use v1beta20201201.PatchSettings_STATUS instead
type PatchSettings_STATUS struct {
	EnableHotpatching *bool                         `json:"enableHotpatching,omitempty"`
	PatchMode         *PatchSettingsSTATUSPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.FromARMConverter = &PatchSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PatchSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PatchSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PatchSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PatchSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PatchSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘EnableHotpatching’:
	if typedInput.EnableHotpatching != nil {
		enableHotpatching := *typedInput.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		settings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromPatchSettingsSTATUS populates our PatchSettings_STATUS from the provided source PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignPropertiesFromPatchSettingsSTATUS(source *alpha20201201s.PatchSettings_STATUS) error {

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := PatchSettingsSTATUSPatchMode(*source.PatchMode)
		settings.PatchMode = &patchMode
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPatchSettingsSTATUS populates the provided destination PatchSettings_STATUS from our PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignPropertiesToPatchSettingsSTATUS(destination *alpha20201201s.PatchSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	if settings.PatchMode != nil {
		patchMode := string(*settings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SshConfiguration. Use v1beta20201201.SshConfiguration instead
type SshConfiguration struct {
	PublicKeys []SshPublicKey `json:"publicKeys,omitempty"`
}

var _ genruntime.ARMTransformer = &SshConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *SshConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &SshConfigurationARM{}

	// Set property ‘PublicKeys’:
	for _, item := range configuration.PublicKeys {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicKeys = append(result.PublicKeys, *itemARM.(*SshPublicKeyARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SshConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SshConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshConfigurationARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 SshPublicKey
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromSshConfiguration populates our SshConfiguration from the provided source SshConfiguration
func (configuration *SshConfiguration) AssignPropertiesFromSshConfiguration(source *alpha20201201s.SshConfiguration) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey
			err := publicKey.AssignPropertiesFromSshPublicKey(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshConfiguration populates the provided destination SshConfiguration from our SshConfiguration
func (configuration *SshConfiguration) AssignPropertiesToSshConfiguration(destination *alpha20201201s.SshConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]alpha20201201s.SshPublicKey, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey alpha20201201s.SshPublicKey
			err := publicKeyItem.AssignPropertiesToSshPublicKey(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SshConfiguration_STATUS. Use v1beta20201201.SshConfiguration_STATUS instead
type SshConfiguration_STATUS struct {
	PublicKeys []SshPublicKey_STATUS `json:"publicKeys,omitempty"`
}

var _ genruntime.FromARMConverter = &SshConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SshConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SshConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 SshPublicKey_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromSshConfigurationSTATUS populates our SshConfiguration_STATUS from the provided source SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignPropertiesFromSshConfigurationSTATUS(source *alpha20201201s.SshConfiguration_STATUS) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey_STATUS, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey_STATUS
			err := publicKey.AssignPropertiesFromSshPublicKeySTATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSshPublicKeySTATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshConfigurationSTATUS populates the provided destination SshConfiguration_STATUS from our SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignPropertiesToSshConfigurationSTATUS(destination *alpha20201201s.SshConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]alpha20201201s.SshPublicKey_STATUS, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey alpha20201201s.SshPublicKey_STATUS
			err := publicKeyItem.AssignPropertiesToSshPublicKeySTATUS(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSshPublicKeySTATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VaultCertificate. Use v1beta20201201.VaultCertificate instead
type VaultCertificate struct {
	CertificateStore *string `json:"certificateStore,omitempty"`
	CertificateUrl   *string `json:"certificateUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultCertificate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (certificate *VaultCertificate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if certificate == nil {
		return nil, nil
	}
	result := &VaultCertificateARM{}

	// Set property ‘CertificateStore’:
	if certificate.CertificateStore != nil {
		certificateStore := *certificate.CertificateStore
		result.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if certificate.CertificateUrl != nil {
		certificateUrl := *certificate.CertificateUrl
		result.CertificateUrl = &certificateUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *VaultCertificate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultCertificateARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *VaultCertificate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultCertificateARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultCertificateARM, got %T", armInput)
	}

	// Set property ‘CertificateStore’:
	if typedInput.CertificateStore != nil {
		certificateStore := *typedInput.CertificateStore
		certificate.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		certificate.CertificateUrl = &certificateUrl
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultCertificate populates our VaultCertificate from the provided source VaultCertificate
func (certificate *VaultCertificate) AssignPropertiesFromVaultCertificate(source *alpha20201201s.VaultCertificate) error {

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// No error
	return nil
}

// AssignPropertiesToVaultCertificate populates the provided destination VaultCertificate from our VaultCertificate
func (certificate *VaultCertificate) AssignPropertiesToVaultCertificate(destination *alpha20201201s.VaultCertificate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VaultCertificate_STATUS. Use v1beta20201201.VaultCertificate_STATUS instead
type VaultCertificate_STATUS struct {
	CertificateStore *string `json:"certificateStore,omitempty"`
	CertificateUrl   *string `json:"certificateUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &VaultCertificate_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *VaultCertificate_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultCertificate_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *VaultCertificate_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultCertificate_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultCertificate_STATUSARM, got %T", armInput)
	}

	// Set property ‘CertificateStore’:
	if typedInput.CertificateStore != nil {
		certificateStore := *typedInput.CertificateStore
		certificate.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		certificate.CertificateUrl = &certificateUrl
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultCertificateSTATUS populates our VaultCertificate_STATUS from the provided source VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignPropertiesFromVaultCertificateSTATUS(source *alpha20201201s.VaultCertificate_STATUS) error {

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// No error
	return nil
}

// AssignPropertiesToVaultCertificateSTATUS populates the provided destination VaultCertificate_STATUS from our VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignPropertiesToVaultCertificateSTATUS(destination *alpha20201201s.VaultCertificate_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualHardDisk. Use v1beta20201201.VirtualHardDisk instead
type VirtualHardDisk struct {
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualHardDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *VirtualHardDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &VirtualHardDiskARM{}

	// Set property ‘Uri’:
	if disk.Uri != nil {
		uri := *disk.Uri
		result.Uri = &uri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualHardDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualHardDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualHardDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualHardDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualHardDiskARM, got %T", armInput)
	}

	// Set property ‘Uri’:
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		disk.Uri = &uri
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualHardDisk populates our VirtualHardDisk from the provided source VirtualHardDisk
func (disk *VirtualHardDisk) AssignPropertiesFromVirtualHardDisk(source *alpha20201201s.VirtualHardDisk) error {

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// No error
	return nil
}

// AssignPropertiesToVirtualHardDisk populates the provided destination VirtualHardDisk from our VirtualHardDisk
func (disk *VirtualHardDisk) AssignPropertiesToVirtualHardDisk(destination *alpha20201201s.VirtualHardDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualHardDisk_STATUS. Use v1beta20201201.VirtualHardDisk_STATUS instead
type VirtualHardDisk_STATUS struct {
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualHardDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualHardDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualHardDisk_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualHardDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualHardDisk_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualHardDisk_STATUSARM, got %T", armInput)
	}

	// Set property ‘Uri’:
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		disk.Uri = &uri
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualHardDiskSTATUS populates our VirtualHardDisk_STATUS from the provided source VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignPropertiesFromVirtualHardDiskSTATUS(source *alpha20201201s.VirtualHardDisk_STATUS) error {

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// No error
	return nil
}

// AssignPropertiesToVirtualHardDiskSTATUS populates the provided destination VirtualHardDisk_STATUS from our VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignPropertiesToVirtualHardDiskSTATUS(destination *alpha20201201s.VirtualHardDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineExtensionHandlerInstanceView_STATUS. Use v1beta20201201.VirtualMachineExtensionHandlerInstanceView_STATUS instead
type VirtualMachineExtensionHandlerInstanceView_STATUS struct {
	Status             *InstanceViewStatus_STATUS `json:"status,omitempty"`
	Type               *string                    `json:"type,omitempty"`
	TypeHandlerVersion *string                    `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineExtensionHandlerInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineExtensionHandlerInstanceView_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineExtensionHandlerInstanceView_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineExtensionHandlerInstanceView_STATUSARM, got %T", armInput)
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		var status1 InstanceViewStatus_STATUS
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		view.Status = &status
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		view.Type = &typeVar
	}

	// Set property ‘TypeHandlerVersion’:
	if typedInput.TypeHandlerVersion != nil {
		typeHandlerVersion := *typedInput.TypeHandlerVersion
		view.TypeHandlerVersion = &typeHandlerVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewSTATUS populates our VirtualMachineExtensionHandlerInstanceView_STATUS from the provided source VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewSTATUS(source *alpha20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS) error {

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignPropertiesFromInstanceViewStatusSTATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// Type
	view.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	view.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewSTATUS populates the provided destination VirtualMachineExtensionHandlerInstanceView_STATUS from our VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewSTATUS(destination *alpha20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Status
	if view.Status != nil {
		var status alpha20201201s.InstanceViewStatus_STATUS
		err := view.Status.AssignPropertiesToInstanceViewStatusSTATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(view.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(view.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of WinRMConfiguration. Use v1beta20201201.WinRMConfiguration instead
type WinRMConfiguration struct {
	Listeners []WinRMListener `json:"listeners,omitempty"`
}

var _ genruntime.ARMTransformer = &WinRMConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *WinRMConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &WinRMConfigurationARM{}

	// Set property ‘Listeners’:
	for _, item := range configuration.Listeners {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Listeners = append(result.Listeners, *itemARM.(*WinRMListenerARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *WinRMConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *WinRMConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMConfigurationARM, got %T", armInput)
	}

	// Set property ‘Listeners’:
	for _, item := range typedInput.Listeners {
		var item1 WinRMListener
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Listeners = append(configuration.Listeners, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMConfiguration populates our WinRMConfiguration from the provided source WinRMConfiguration
func (configuration *WinRMConfiguration) AssignPropertiesFromWinRMConfiguration(source *alpha20201201s.WinRMConfiguration) error {

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener
			err := listener.AssignPropertiesFromWinRMListener(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromWinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMConfiguration populates the provided destination WinRMConfiguration from our WinRMConfiguration
func (configuration *WinRMConfiguration) AssignPropertiesToWinRMConfiguration(destination *alpha20201201s.WinRMConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]alpha20201201s.WinRMListener, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener alpha20201201s.WinRMListener
			err := listenerItem.AssignPropertiesToWinRMListener(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToWinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of WinRMConfiguration_STATUS. Use v1beta20201201.WinRMConfiguration_STATUS instead
type WinRMConfiguration_STATUS struct {
	Listeners []WinRMListener_STATUS `json:"listeners,omitempty"`
}

var _ genruntime.FromARMConverter = &WinRMConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *WinRMConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *WinRMConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘Listeners’:
	for _, item := range typedInput.Listeners {
		var item1 WinRMListener_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Listeners = append(configuration.Listeners, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMConfigurationSTATUS populates our WinRMConfiguration_STATUS from the provided source WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignPropertiesFromWinRMConfigurationSTATUS(source *alpha20201201s.WinRMConfiguration_STATUS) error {

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener_STATUS, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener_STATUS
			err := listener.AssignPropertiesFromWinRMListenerSTATUS(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromWinRMListenerSTATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMConfigurationSTATUS populates the provided destination WinRMConfiguration_STATUS from our WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignPropertiesToWinRMConfigurationSTATUS(destination *alpha20201201s.WinRMConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]alpha20201201s.WinRMListener_STATUS, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener alpha20201201s.WinRMListener_STATUS
			err := listenerItem.AssignPropertiesToWinRMListenerSTATUS(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToWinRMListenerSTATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AdditionalUnattendContentComponentName. Use v1beta20201201.AdditionalUnattendContentComponentName
// instead
// +kubebuilder:validation:Enum={"Microsoft-Windows-Shell-Setup"}
type AdditionalUnattendContentComponentName string

const AdditionalUnattendContentComponentName_MicrosoftWindowsShellSetup = AdditionalUnattendContentComponentName("Microsoft-Windows-Shell-Setup")

// Deprecated version of AdditionalUnattendContentPassName. Use v1beta20201201.AdditionalUnattendContentPassName instead
// +kubebuilder:validation:Enum={"OobeSystem"}
type AdditionalUnattendContentPassName string

const AdditionalUnattendContentPassName_OobeSystem = AdditionalUnattendContentPassName("OobeSystem")

// Deprecated version of AdditionalUnattendContentSettingName. Use v1beta20201201.AdditionalUnattendContentSettingName
// instead
// +kubebuilder:validation:Enum={"AutoLogon","FirstLogonCommands"}
type AdditionalUnattendContentSettingName string

const (
	AdditionalUnattendContentSettingName_AutoLogon          = AdditionalUnattendContentSettingName("AutoLogon")
	AdditionalUnattendContentSettingName_FirstLogonCommands = AdditionalUnattendContentSettingName("FirstLogonCommands")
)

// Deprecated version of AdditionalUnattendContentSTATUSComponentName. Use
// v1beta20201201.AdditionalUnattendContentSTATUSComponentName instead
type AdditionalUnattendContentSTATUSComponentName string

const AdditionalUnattendContentSTATUSComponentName_MicrosoftWindowsShellSetup = AdditionalUnattendContentSTATUSComponentName("Microsoft-Windows-Shell-Setup")

// Deprecated version of AdditionalUnattendContentSTATUSPassName. Use
// v1beta20201201.AdditionalUnattendContentSTATUSPassName instead
type AdditionalUnattendContentSTATUSPassName string

const AdditionalUnattendContentSTATUSPassName_OobeSystem = AdditionalUnattendContentSTATUSPassName("OobeSystem")

// Deprecated version of AdditionalUnattendContentSTATUSSettingName. Use
// v1beta20201201.AdditionalUnattendContentSTATUSSettingName instead
type AdditionalUnattendContentSTATUSSettingName string

const (
	AdditionalUnattendContentSTATUSSettingName_AutoLogon          = AdditionalUnattendContentSTATUSSettingName("AutoLogon")
	AdditionalUnattendContentSTATUSSettingName_FirstLogonCommands = AdditionalUnattendContentSTATUSSettingName("FirstLogonCommands")
)

// Deprecated version of ApiError_STATUS. Use v1beta20201201.ApiError_STATUS instead
type ApiError_STATUS struct {
	Code       *string               `json:"code,omitempty"`
	Details    []ApiErrorBase_STATUS `json:"details,omitempty"`
	Innererror *InnerError_STATUS    `json:"innererror,omitempty"`
	Message    *string               `json:"message,omitempty"`
	Target     *string               `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *ApiError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiError_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *ApiError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiError_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiError_STATUSARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		error.Code = &code
	}

	// Set property ‘Details’:
	for _, item := range typedInput.Details {
		var item1 ApiErrorBase_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		error.Details = append(error.Details, item1)
	}

	// Set property ‘Innererror’:
	if typedInput.Innererror != nil {
		var innererror1 InnerError_STATUS
		err := innererror1.PopulateFromARM(owner, *typedInput.Innererror)
		if err != nil {
			return err
		}
		innererror := innererror1
		error.Innererror = &innererror
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		error.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		error.Target = &target
	}

	// No error
	return nil
}

// AssignPropertiesFromApiErrorSTATUS populates our ApiError_STATUS from the provided source ApiError_STATUS
func (error *ApiError_STATUS) AssignPropertiesFromApiErrorSTATUS(source *alpha20201201s.ApiError_STATUS) error {

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ApiErrorBase_STATUS, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ApiErrorBase_STATUS
			err := detail.AssignPropertiesFromApiErrorBaseSTATUS(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApiErrorBaseSTATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		error.Details = detailList
	} else {
		error.Details = nil
	}

	// Innererror
	if source.Innererror != nil {
		var innererror InnerError_STATUS
		err := innererror.AssignPropertiesFromInnerErrorSTATUS(source.Innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInnerErrorSTATUS() to populate field Innererror")
		}
		error.Innererror = &innererror
	} else {
		error.Innererror = nil
	}

	// Message
	error.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	error.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignPropertiesToApiErrorSTATUS populates the provided destination ApiError_STATUS from our ApiError_STATUS
func (error *ApiError_STATUS) AssignPropertiesToApiErrorSTATUS(destination *alpha20201201s.ApiError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// Details
	if error.Details != nil {
		detailList := make([]alpha20201201s.ApiErrorBase_STATUS, len(error.Details))
		for detailIndex, detailItem := range error.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail alpha20201201s.ApiErrorBase_STATUS
			err := detailItem.AssignPropertiesToApiErrorBaseSTATUS(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApiErrorBaseSTATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Innererror
	if error.Innererror != nil {
		var innererror alpha20201201s.InnerError_STATUS
		err := error.Innererror.AssignPropertiesToInnerErrorSTATUS(&innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInnerErrorSTATUS() to populate field Innererror")
		}
		destination.Innererror = &innererror
	} else {
		destination.Innererror = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(error.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(error.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AvailablePatchSummarySTATUSStatus. Use v1beta20201201.AvailablePatchSummarySTATUSStatus instead
type AvailablePatchSummarySTATUSStatus string

const (
	AvailablePatchSummarySTATUSStatus_CompletedWithWarnings = AvailablePatchSummarySTATUSStatus("CompletedWithWarnings")
	AvailablePatchSummarySTATUSStatus_Failed                = AvailablePatchSummarySTATUSStatus("Failed")
	AvailablePatchSummarySTATUSStatus_InProgress            = AvailablePatchSummarySTATUSStatus("InProgress")
	AvailablePatchSummarySTATUSStatus_Succeeded             = AvailablePatchSummarySTATUSStatus("Succeeded")
	AvailablePatchSummarySTATUSStatus_Unknown               = AvailablePatchSummarySTATUSStatus("Unknown")
)

// Deprecated version of DiffDiskOption_STATUS. Use v1beta20201201.DiffDiskOption_STATUS instead
type DiffDiskOption_STATUS string

const DiffDiskOption_STATUS_Local = DiffDiskOption_STATUS("Local")

// Deprecated version of DiffDiskPlacement_STATUS. Use v1beta20201201.DiffDiskPlacement_STATUS instead
type DiffDiskPlacement_STATUS string

const (
	DiffDiskPlacement_STATUS_CacheDisk    = DiffDiskPlacement_STATUS("CacheDisk")
	DiffDiskPlacement_STATUS_ResourceDisk = DiffDiskPlacement_STATUS("ResourceDisk")
)

// Deprecated version of DiffDiskSettingsOption. Use v1beta20201201.DiffDiskSettingsOption instead
// +kubebuilder:validation:Enum={"Local"}
type DiffDiskSettingsOption string

const DiffDiskSettingsOption_Local = DiffDiskSettingsOption("Local")

// Deprecated version of DiffDiskSettingsPlacement. Use v1beta20201201.DiffDiskSettingsPlacement instead
// +kubebuilder:validation:Enum={"CacheDisk","ResourceDisk"}
type DiffDiskSettingsPlacement string

const (
	DiffDiskSettingsPlacement_CacheDisk    = DiffDiskSettingsPlacement("CacheDisk")
	DiffDiskSettingsPlacement_ResourceDisk = DiffDiskSettingsPlacement("ResourceDisk")
)

// Deprecated version of DiskEncryptionSetParameters. Use v1beta20201201.DiskEncryptionSetParameters instead
type DiskEncryptionSetParameters struct {
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &DiskEncryptionSetParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *DiskEncryptionSetParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &DiskEncryptionSetParametersARM{}

	// Set property ‘Id’:
	if parameters.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*parameters.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *DiskEncryptionSetParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskEncryptionSetParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *DiskEncryptionSetParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(DiskEncryptionSetParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskEncryptionSetParametersARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromDiskEncryptionSetParameters populates our DiskEncryptionSetParameters from the provided source DiskEncryptionSetParameters
func (parameters *DiskEncryptionSetParameters) AssignPropertiesFromDiskEncryptionSetParameters(source *alpha20201201s.DiskEncryptionSetParameters) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		parameters.Reference = &reference
	} else {
		parameters.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSetParameters populates the provided destination DiskEncryptionSetParameters from our DiskEncryptionSetParameters
func (parameters *DiskEncryptionSetParameters) AssignPropertiesToDiskEncryptionSetParameters(destination *alpha20201201s.DiskEncryptionSetParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if parameters.Reference != nil {
		reference := parameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of KeyVaultKeyReference. Use v1beta20201201.KeyVaultKeyReference instead
type KeyVaultKeyReference struct {
	// +kubebuilder:validation:Required
	KeyUrl *string `json:"keyUrl,omitempty"`

	// +kubebuilder:validation:Required
	SourceVault *SubResource `json:"sourceVault,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultKeyReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *KeyVaultKeyReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &KeyVaultKeyReferenceARM{}

	// Set property ‘KeyUrl’:
	if reference.KeyUrl != nil {
		keyUrl := *reference.KeyUrl
		result.KeyUrl = &keyUrl
	}

	// Set property ‘SourceVault’:
	if reference.SourceVault != nil {
		sourceVaultARM, err := (*reference.SourceVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceVault := *sourceVaultARM.(*SubResourceARM)
		result.SourceVault = &sourceVault
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *KeyVaultKeyReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultKeyReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *KeyVaultKeyReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultKeyReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultKeyReferenceARM, got %T", armInput)
	}

	// Set property ‘KeyUrl’:
	if typedInput.KeyUrl != nil {
		keyUrl := *typedInput.KeyUrl
		reference.KeyUrl = &keyUrl
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		reference.SourceVault = &sourceVault
	}

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultKeyReference populates our KeyVaultKeyReference from the provided source KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignPropertiesFromKeyVaultKeyReference(source *alpha20201201s.KeyVaultKeyReference) error {

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultKeyReference populates the provided destination KeyVaultKeyReference from our KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignPropertiesToKeyVaultKeyReference(destination *alpha20201201s.KeyVaultKeyReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault alpha20201201s.SubResource
		err := reference.SourceVault.AssignPropertiesToSubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of KeyVaultKeyReference_STATUS. Use v1beta20201201.KeyVaultKeyReference_STATUS instead
type KeyVaultKeyReference_STATUS struct {
	KeyUrl      *string             `json:"keyUrl,omitempty"`
	SourceVault *SubResource_STATUS `json:"sourceVault,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultKeyReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *KeyVaultKeyReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultKeyReference_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *KeyVaultKeyReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultKeyReference_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultKeyReference_STATUSARM, got %T", armInput)
	}

	// Set property ‘KeyUrl’:
	if typedInput.KeyUrl != nil {
		keyUrl := *typedInput.KeyUrl
		reference.KeyUrl = &keyUrl
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource_STATUS
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		reference.SourceVault = &sourceVault
	}

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultKeyReferenceSTATUS populates our KeyVaultKeyReference_STATUS from the provided source KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignPropertiesFromKeyVaultKeyReferenceSTATUS(source *alpha20201201s.KeyVaultKeyReference_STATUS) error {

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_STATUS
		err := sourceVault.AssignPropertiesFromSubResourceSTATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultKeyReferenceSTATUS populates the provided destination KeyVaultKeyReference_STATUS from our KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignPropertiesToKeyVaultKeyReferenceSTATUS(destination *alpha20201201s.KeyVaultKeyReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault alpha20201201s.SubResource_STATUS
		err := reference.SourceVault.AssignPropertiesToSubResourceSTATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of KeyVaultSecretReference. Use v1beta20201201.KeyVaultSecretReference instead
type KeyVaultSecretReference struct {
	// +kubebuilder:validation:Required
	SecretUrl *string `json:"secretUrl,omitempty"`

	// +kubebuilder:validation:Required
	SourceVault *SubResource `json:"sourceVault,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultSecretReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *KeyVaultSecretReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &KeyVaultSecretReferenceARM{}

	// Set property ‘SecretUrl’:
	if reference.SecretUrl != nil {
		secretUrl := *reference.SecretUrl
		result.SecretUrl = &secretUrl
	}

	// Set property ‘SourceVault’:
	if reference.SourceVault != nil {
		sourceVaultARM, err := (*reference.SourceVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceVault := *sourceVaultARM.(*SubResourceARM)
		result.SourceVault = &sourceVault
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *KeyVaultSecretReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultSecretReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *KeyVaultSecretReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultSecretReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultSecretReferenceARM, got %T", armInput)
	}

	// Set property ‘SecretUrl’:
	if typedInput.SecretUrl != nil {
		secretUrl := *typedInput.SecretUrl
		reference.SecretUrl = &secretUrl
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		reference.SourceVault = &sourceVault
	}

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultSecretReference populates our KeyVaultSecretReference from the provided source KeyVaultSecretReference
func (reference *KeyVaultSecretReference) AssignPropertiesFromKeyVaultSecretReference(source *alpha20201201s.KeyVaultSecretReference) error {

	// SecretUrl
	reference.SecretUrl = genruntime.ClonePointerToString(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSecretReference populates the provided destination KeyVaultSecretReference from our KeyVaultSecretReference
func (reference *KeyVaultSecretReference) AssignPropertiesToKeyVaultSecretReference(destination *alpha20201201s.KeyVaultSecretReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretUrl
	destination.SecretUrl = genruntime.ClonePointerToString(reference.SecretUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault alpha20201201s.SubResource
		err := reference.SourceVault.AssignPropertiesToSubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of KeyVaultSecretReference_STATUS. Use v1beta20201201.KeyVaultSecretReference_STATUS instead
type KeyVaultSecretReference_STATUS struct {
	SecretUrl   *string             `json:"secretUrl,omitempty"`
	SourceVault *SubResource_STATUS `json:"sourceVault,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultSecretReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *KeyVaultSecretReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultSecretReference_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *KeyVaultSecretReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultSecretReference_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultSecretReference_STATUSARM, got %T", armInput)
	}

	// Set property ‘SecretUrl’:
	if typedInput.SecretUrl != nil {
		secretUrl := *typedInput.SecretUrl
		reference.SecretUrl = &secretUrl
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource_STATUS
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		reference.SourceVault = &sourceVault
	}

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultSecretReferenceSTATUS populates our KeyVaultSecretReference_STATUS from the provided source KeyVaultSecretReference_STATUS
func (reference *KeyVaultSecretReference_STATUS) AssignPropertiesFromKeyVaultSecretReferenceSTATUS(source *alpha20201201s.KeyVaultSecretReference_STATUS) error {

	// SecretUrl
	reference.SecretUrl = genruntime.ClonePointerToString(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_STATUS
		err := sourceVault.AssignPropertiesFromSubResourceSTATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSecretReferenceSTATUS populates the provided destination KeyVaultSecretReference_STATUS from our KeyVaultSecretReference_STATUS
func (reference *KeyVaultSecretReference_STATUS) AssignPropertiesToKeyVaultSecretReferenceSTATUS(destination *alpha20201201s.KeyVaultSecretReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretUrl
	destination.SecretUrl = genruntime.ClonePointerToString(reference.SecretUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault alpha20201201s.SubResource_STATUS
		err := reference.SourceVault.AssignPropertiesToSubResourceSTATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of LastPatchInstallationSummarySTATUSStatus. Use
// v1beta20201201.LastPatchInstallationSummarySTATUSStatus instead
type LastPatchInstallationSummarySTATUSStatus string

const (
	LastPatchInstallationSummarySTATUSStatus_CompletedWithWarnings = LastPatchInstallationSummarySTATUSStatus("CompletedWithWarnings")
	LastPatchInstallationSummarySTATUSStatus_Failed                = LastPatchInstallationSummarySTATUSStatus("Failed")
	LastPatchInstallationSummarySTATUSStatus_InProgress            = LastPatchInstallationSummarySTATUSStatus("InProgress")
	LastPatchInstallationSummarySTATUSStatus_Succeeded             = LastPatchInstallationSummarySTATUSStatus("Succeeded")
	LastPatchInstallationSummarySTATUSStatus_Unknown               = LastPatchInstallationSummarySTATUSStatus("Unknown")
)

// Deprecated version of LinuxPatchSettingsPatchMode. Use v1beta20201201.LinuxPatchSettingsPatchMode instead
// +kubebuilder:validation:Enum={"AutomaticByPlatform","ImageDefault"}
type LinuxPatchSettingsPatchMode string

const (
	LinuxPatchSettingsPatchMode_AutomaticByPlatform = LinuxPatchSettingsPatchMode("AutomaticByPlatform")
	LinuxPatchSettingsPatchMode_ImageDefault        = LinuxPatchSettingsPatchMode("ImageDefault")
)

// Deprecated version of LinuxPatchSettingsSTATUSPatchMode. Use v1beta20201201.LinuxPatchSettingsSTATUSPatchMode instead
type LinuxPatchSettingsSTATUSPatchMode string

const (
	LinuxPatchSettingsSTATUSPatchMode_AutomaticByPlatform = LinuxPatchSettingsSTATUSPatchMode("AutomaticByPlatform")
	LinuxPatchSettingsSTATUSPatchMode_ImageDefault        = LinuxPatchSettingsSTATUSPatchMode("ImageDefault")
)

// Deprecated version of ManagedDiskParametersStorageAccountType. Use
// v1beta20201201.ManagedDiskParametersStorageAccountType instead
// +kubebuilder:validation:Enum={"Premium_LRS","Premium_ZRS","Standard_LRS","StandardSSD_LRS","StandardSSD_ZRS","UltraSSD_LRS"}
type ManagedDiskParametersStorageAccountType string

const (
	ManagedDiskParametersStorageAccountType_PremiumLRS     = ManagedDiskParametersStorageAccountType("Premium_LRS")
	ManagedDiskParametersStorageAccountType_PremiumZRS     = ManagedDiskParametersStorageAccountType("Premium_ZRS")
	ManagedDiskParametersStorageAccountType_StandardLRS    = ManagedDiskParametersStorageAccountType("Standard_LRS")
	ManagedDiskParametersStorageAccountType_StandardSSDLRS = ManagedDiskParametersStorageAccountType("StandardSSD_LRS")
	ManagedDiskParametersStorageAccountType_StandardSSDZRS = ManagedDiskParametersStorageAccountType("StandardSSD_ZRS")
	ManagedDiskParametersStorageAccountType_UltraSSDLRS    = ManagedDiskParametersStorageAccountType("UltraSSD_LRS")
)

// Deprecated version of PatchSettingsPatchMode. Use v1beta20201201.PatchSettingsPatchMode instead
// +kubebuilder:validation:Enum={"AutomaticByOS","AutomaticByPlatform","Manual"}
type PatchSettingsPatchMode string

const (
	PatchSettingsPatchMode_AutomaticByOS       = PatchSettingsPatchMode("AutomaticByOS")
	PatchSettingsPatchMode_AutomaticByPlatform = PatchSettingsPatchMode("AutomaticByPlatform")
	PatchSettingsPatchMode_Manual              = PatchSettingsPatchMode("Manual")
)

// Deprecated version of PatchSettingsSTATUSPatchMode. Use v1beta20201201.PatchSettingsSTATUSPatchMode instead
type PatchSettingsSTATUSPatchMode string

const (
	PatchSettingsSTATUSPatchMode_AutomaticByOS       = PatchSettingsSTATUSPatchMode("AutomaticByOS")
	PatchSettingsSTATUSPatchMode_AutomaticByPlatform = PatchSettingsSTATUSPatchMode("AutomaticByPlatform")
	PatchSettingsSTATUSPatchMode_Manual              = PatchSettingsSTATUSPatchMode("Manual")
)

// Deprecated version of SshPublicKey. Use v1beta20201201.SshPublicKey instead
type SshPublicKey struct {
	KeyData *string `json:"keyData,omitempty"`
	Path    *string `json:"path,omitempty"`
}

var _ genruntime.ARMTransformer = &SshPublicKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (publicKey *SshPublicKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if publicKey == nil {
		return nil, nil
	}
	result := &SshPublicKeyARM{}

	// Set property ‘KeyData’:
	if publicKey.KeyData != nil {
		keyData := *publicKey.KeyData
		result.KeyData = &keyData
	}

	// Set property ‘Path’:
	if publicKey.Path != nil {
		path := *publicKey.Path
		result.Path = &path
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *SshPublicKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshPublicKeyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *SshPublicKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshPublicKeyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshPublicKeyARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		publicKey.KeyData = &keyData
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		publicKey.Path = &path
	}

	// No error
	return nil
}

// AssignPropertiesFromSshPublicKey populates our SshPublicKey from the provided source SshPublicKey
func (publicKey *SshPublicKey) AssignPropertiesFromSshPublicKey(source *alpha20201201s.SshPublicKey) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToSshPublicKey populates the provided destination SshPublicKey from our SshPublicKey
func (publicKey *SshPublicKey) AssignPropertiesToSshPublicKey(destination *alpha20201201s.SshPublicKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SshPublicKey_STATUS. Use v1beta20201201.SshPublicKey_STATUS instead
type SshPublicKey_STATUS struct {
	KeyData *string `json:"keyData,omitempty"`
	Path    *string `json:"path,omitempty"`
}

var _ genruntime.FromARMConverter = &SshPublicKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *SshPublicKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshPublicKey_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *SshPublicKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshPublicKey_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshPublicKey_STATUSARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		publicKey.KeyData = &keyData
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		publicKey.Path = &path
	}

	// No error
	return nil
}

// AssignPropertiesFromSshPublicKeySTATUS populates our SshPublicKey_STATUS from the provided source SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignPropertiesFromSshPublicKeySTATUS(source *alpha20201201s.SshPublicKey_STATUS) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToSshPublicKeySTATUS populates the provided destination SshPublicKey_STATUS from our SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignPropertiesToSshPublicKeySTATUS(destination *alpha20201201s.SshPublicKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of StorageAccountType_STATUS. Use v1beta20201201.StorageAccountType_STATUS instead
type StorageAccountType_STATUS string

const (
	StorageAccountType_STATUS_PremiumLRS     = StorageAccountType_STATUS("Premium_LRS")
	StorageAccountType_STATUS_PremiumZRS     = StorageAccountType_STATUS("Premium_ZRS")
	StorageAccountType_STATUS_StandardLRS    = StorageAccountType_STATUS("Standard_LRS")
	StorageAccountType_STATUS_StandardSSDLRS = StorageAccountType_STATUS("StandardSSD_LRS")
	StorageAccountType_STATUS_StandardSSDZRS = StorageAccountType_STATUS("StandardSSD_ZRS")
	StorageAccountType_STATUS_UltraSSDLRS    = StorageAccountType_STATUS("UltraSSD_LRS")
)

// Deprecated version of WinRMListener. Use v1beta20201201.WinRMListener instead
type WinRMListener struct {
	CertificateUrl *string                `json:"certificateUrl,omitempty"`
	Protocol       *WinRMListenerProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &WinRMListener{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (listener *WinRMListener) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if listener == nil {
		return nil, nil
	}
	result := &WinRMListenerARM{}

	// Set property ‘CertificateUrl’:
	if listener.CertificateUrl != nil {
		certificateUrl := *listener.CertificateUrl
		result.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if listener.Protocol != nil {
		protocol := *listener.Protocol
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (listener *WinRMListener) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMListenerARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (listener *WinRMListener) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMListenerARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMListenerARM, got %T", armInput)
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		listener.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		listener.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMListener populates our WinRMListener from the provided source WinRMListener
func (listener *WinRMListener) AssignPropertiesFromWinRMListener(source *alpha20201201s.WinRMListener) error {

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	if source.Protocol != nil {
		protocol := WinRMListenerProtocol(*source.Protocol)
		listener.Protocol = &protocol
	} else {
		listener.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMListener populates the provided destination WinRMListener from our WinRMListener
func (listener *WinRMListener) AssignPropertiesToWinRMListener(destination *alpha20201201s.WinRMListener) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	if listener.Protocol != nil {
		protocol := string(*listener.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of WinRMListener_STATUS. Use v1beta20201201.WinRMListener_STATUS instead
type WinRMListener_STATUS struct {
	CertificateUrl *string                      `json:"certificateUrl,omitempty"`
	Protocol       *WinRMListenerSTATUSProtocol `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &WinRMListener_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (listener *WinRMListener_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMListener_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (listener *WinRMListener_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMListener_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMListener_STATUSARM, got %T", armInput)
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		listener.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		listener.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMListenerSTATUS populates our WinRMListener_STATUS from the provided source WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignPropertiesFromWinRMListenerSTATUS(source *alpha20201201s.WinRMListener_STATUS) error {

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	if source.Protocol != nil {
		protocol := WinRMListenerSTATUSProtocol(*source.Protocol)
		listener.Protocol = &protocol
	} else {
		listener.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMListenerSTATUS populates the provided destination WinRMListener_STATUS from our WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignPropertiesToWinRMListenerSTATUS(destination *alpha20201201s.WinRMListener_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	if listener.Protocol != nil {
		protocol := string(*listener.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ApiErrorBase_STATUS. Use v1beta20201201.ApiErrorBase_STATUS instead
type ApiErrorBase_STATUS struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
	Target  *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiErrorBase_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *ApiErrorBase_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiErrorBase_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *ApiErrorBase_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiErrorBase_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiErrorBase_STATUSARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		base.Code = &code
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		base.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		base.Target = &target
	}

	// No error
	return nil
}

// AssignPropertiesFromApiErrorBaseSTATUS populates our ApiErrorBase_STATUS from the provided source ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignPropertiesFromApiErrorBaseSTATUS(source *alpha20201201s.ApiErrorBase_STATUS) error {

	// Code
	base.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	base.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	base.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignPropertiesToApiErrorBaseSTATUS populates the provided destination ApiErrorBase_STATUS from our ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignPropertiesToApiErrorBaseSTATUS(destination *alpha20201201s.ApiErrorBase_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(base.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(base.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(base.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of InnerError_STATUS. Use v1beta20201201.InnerError_STATUS instead
type InnerError_STATUS struct {
	Errordetail   *string `json:"errordetail,omitempty"`
	Exceptiontype *string `json:"exceptiontype,omitempty"`
}

var _ genruntime.FromARMConverter = &InnerError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *InnerError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InnerError_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *InnerError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InnerError_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InnerError_STATUSARM, got %T", armInput)
	}

	// Set property ‘Errordetail’:
	if typedInput.Errordetail != nil {
		errordetail := *typedInput.Errordetail
		error.Errordetail = &errordetail
	}

	// Set property ‘Exceptiontype’:
	if typedInput.Exceptiontype != nil {
		exceptiontype := *typedInput.Exceptiontype
		error.Exceptiontype = &exceptiontype
	}

	// No error
	return nil
}

// AssignPropertiesFromInnerErrorSTATUS populates our InnerError_STATUS from the provided source InnerError_STATUS
func (error *InnerError_STATUS) AssignPropertiesFromInnerErrorSTATUS(source *alpha20201201s.InnerError_STATUS) error {

	// Errordetail
	error.Errordetail = genruntime.ClonePointerToString(source.Errordetail)

	// Exceptiontype
	error.Exceptiontype = genruntime.ClonePointerToString(source.Exceptiontype)

	// No error
	return nil
}

// AssignPropertiesToInnerErrorSTATUS populates the provided destination InnerError_STATUS from our InnerError_STATUS
func (error *InnerError_STATUS) AssignPropertiesToInnerErrorSTATUS(destination *alpha20201201s.InnerError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Errordetail
	destination.Errordetail = genruntime.ClonePointerToString(error.Errordetail)

	// Exceptiontype
	destination.Exceptiontype = genruntime.ClonePointerToString(error.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of WinRMListenerProtocol. Use v1beta20201201.WinRMListenerProtocol instead
// +kubebuilder:validation:Enum={"Http","Https"}
type WinRMListenerProtocol string

const (
	WinRMListenerProtocol_Http  = WinRMListenerProtocol("Http")
	WinRMListenerProtocol_Https = WinRMListenerProtocol("Https")
)

// Deprecated version of WinRMListenerSTATUSProtocol. Use v1beta20201201.WinRMListenerSTATUSProtocol instead
type WinRMListenerSTATUSProtocol string

const (
	WinRMListenerSTATUSProtocol_Http  = WinRMListenerSTATUSProtocol("Http")
	WinRMListenerSTATUSProtocol_Https = WinRMListenerSTATUSProtocol("Https")
)

func init() {
	SchemeBuilder.Register(&VirtualMachine{}, &VirtualMachineList{})
}
