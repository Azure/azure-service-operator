// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:rbac:groups=compute.azure.com,resources=virtualmachines,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=compute.azure.com,resources={virtualmachines/status,virtualmachines/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/resourceDefinitions/virtualMachines
type VirtualMachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachines_Spec  `json:"spec,omitempty"`
	Status            VirtualMachine_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachine{}

// GetConditions returns the conditions of the resource
func (virtualMachine *VirtualMachine) GetConditions() conditions.Conditions {
	return virtualMachine.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (virtualMachine *VirtualMachine) SetConditions(conditions conditions.Conditions) {
	virtualMachine.Status.Conditions = conditions
}

// +kubebuilder:webhook:path=/mutate-compute-azure-com-v1alpha1api20201201-virtualmachine,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachines,verbs=create;update,versions=v1alpha1api20201201,name=default.v1alpha1api20201201.virtualmachines.compute.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &VirtualMachine{}

// Default applies defaults to the VirtualMachine resource
func (virtualMachine *VirtualMachine) Default() {
	virtualMachine.defaultImpl()
	var temp interface{} = virtualMachine
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (virtualMachine *VirtualMachine) defaultAzureName() {
	if virtualMachine.Spec.AzureName == "" {
		virtualMachine.Spec.AzureName = virtualMachine.Name
	}
}

// defaultImpl applies the code generated defaults to the VirtualMachine resource
func (virtualMachine *VirtualMachine) defaultImpl() { virtualMachine.defaultAzureName() }

var _ genruntime.KubernetesResource = &VirtualMachine{}

// AzureName returns the Azure name of the resource
func (virtualMachine *VirtualMachine) AzureName() string {
	return virtualMachine.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-12-01"
func (virtualMachine VirtualMachine) GetAPIVersion() string {
	return "2020-12-01"
}

// GetResourceKind returns the kind of the resource
func (virtualMachine *VirtualMachine) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (virtualMachine *VirtualMachine) GetSpec() genruntime.ConvertibleSpec {
	return &virtualMachine.Spec
}

// GetStatus returns the status of this resource
func (virtualMachine *VirtualMachine) GetStatus() genruntime.ConvertibleStatus {
	return &virtualMachine.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachines"
func (virtualMachine *VirtualMachine) GetType() string {
	return "Microsoft.Compute/virtualMachines"
}

// NewEmptyStatus returns a new empty (blank) status
func (virtualMachine *VirtualMachine) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachine_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (virtualMachine *VirtualMachine) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(virtualMachine.Spec)
	return &genruntime.ResourceReference{
		Group:     group,
		Kind:      kind,
		Namespace: virtualMachine.Namespace,
		Name:      virtualMachine.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (virtualMachine *VirtualMachine) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachine_Status); ok {
		virtualMachine.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachine_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	virtualMachine.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-compute-azure-com-v1alpha1api20201201-virtualmachine,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachines,verbs=create;update,versions=v1alpha1api20201201,name=validate.v1alpha1api20201201.virtualmachines.compute.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &VirtualMachine{}

// ValidateCreate validates the creation of the resource
func (virtualMachine *VirtualMachine) ValidateCreate() error {
	validations := virtualMachine.createValidations()
	var temp interface{} = virtualMachine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (virtualMachine *VirtualMachine) ValidateDelete() error {
	validations := virtualMachine.deleteValidations()
	var temp interface{} = virtualMachine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (virtualMachine *VirtualMachine) ValidateUpdate(old runtime.Object) error {
	validations := virtualMachine.updateValidations()
	var temp interface{} = virtualMachine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (virtualMachine *VirtualMachine) createValidations() []func() error {
	return []func() error{virtualMachine.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (virtualMachine *VirtualMachine) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (virtualMachine *VirtualMachine) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return virtualMachine.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (virtualMachine *VirtualMachine) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&virtualMachine.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromVirtualMachine populates our VirtualMachine from the provided source VirtualMachine
func (virtualMachine *VirtualMachine) AssignPropertiesFromVirtualMachine(source *v1alpha1api20201201storage.VirtualMachine) error {

	// ObjectMeta
	virtualMachine.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachines_Spec
	err := spec.AssignPropertiesFromVirtualMachinesSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromVirtualMachinesSpec()")
	}
	virtualMachine.Spec = spec

	// Status
	var status VirtualMachine_Status
	err = status.AssignPropertiesFromVirtualMachineStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromVirtualMachineStatus()")
	}
	virtualMachine.Status = status

	// No error
	return nil
}

// AssignPropertiesToVirtualMachine populates the provided destination VirtualMachine from our VirtualMachine
func (virtualMachine *VirtualMachine) AssignPropertiesToVirtualMachine(destination *v1alpha1api20201201storage.VirtualMachine) error {

	// ObjectMeta
	destination.ObjectMeta = *virtualMachine.ObjectMeta.DeepCopy()

	// Spec
	var spec v1alpha1api20201201storage.VirtualMachines_Spec
	err := virtualMachine.Spec.AssignPropertiesToVirtualMachinesSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToVirtualMachinesSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20201201storage.VirtualMachine_Status
	err = virtualMachine.Status.AssignPropertiesToVirtualMachineStatus(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToVirtualMachineStatus()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (virtualMachine *VirtualMachine) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: virtualMachine.Spec.OriginalVersion(),
		Kind:    "VirtualMachine",
	}
}

// +kubebuilder:object:root=true
//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/resourceDefinitions/virtualMachines
type VirtualMachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachine `json:"items"`
}

type VirtualMachine_Status struct {
	//AdditionalCapabilities: Specifies additional capabilities enabled or disabled on
	//the virtual machine.
	AdditionalCapabilities *AdditionalCapabilities_Status `json:"additionalCapabilities,omitempty"`

	//AvailabilitySet: Specifies information about the availability set that the
	//virtual machine should be assigned to. Virtual machines specified in the same
	//availability set are allocated to different nodes to maximize availability. For
	//more information about availability sets, see [Manage the availability of
	//virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-manage-availability?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	//For more information on Azure planned maintenance, see [Planned maintenance for
	//virtual machines in
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-planned-maintenance?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)
	//Currently, a VM can only be added to availability set at creation time. The
	//availability set to which the VM is being added should be under the same
	//resource group as the availability set resource. An existing VM cannot be added
	//to an availability set.
	//This property cannot exist along with a non-null
	//properties.virtualMachineScaleSet reference.
	AvailabilitySet *SubResource_Status `json:"availabilitySet,omitempty"`

	//BillingProfile: Specifies the billing related details of a Azure Spot virtual
	//machine.
	//Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile_Status `json:"billingProfile,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//DiagnosticsProfile: Specifies the boot diagnostic settings state.
	//Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile_Status `json:"diagnosticsProfile,omitempty"`

	//EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine
	//and Azure Spot scale set.
	//For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported
	//and the minimum api-version is 2019-03-01.
	//For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the
	//minimum api-version is 2017-10-30-preview.
	EvictionPolicy *EvictionPolicy_Status `json:"evictionPolicy,omitempty"`

	//ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//ExtensionsTimeBudget: Specifies the time alloted for all extensions to start.
	//The time duration should be between 15 minutes and 120 minutes (inclusive) and
	//should be specified in ISO 8601 format. The default value is 90 minutes
	//(PT1H30M).
	//Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`

	//HardwareProfile: Specifies the hardware settings for the virtual machine.
	HardwareProfile *HardwareProfile_Status `json:"hardwareProfile,omitempty"`

	//Host: Specifies information about the dedicated host that the virtual machine
	//resides in.
	//Minimum api-version: 2018-10-01.
	Host *SubResource_Status `json:"host,omitempty"`

	//HostGroup: Specifies information about the dedicated host group that the virtual
	//machine resides in.
	//Minimum api-version: 2020-06-01.
	//NOTE: User cannot specify both host and hostGroup properties.
	HostGroup *SubResource_Status `json:"hostGroup,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Identity: The identity of the virtual machine, if configured.
	Identity *VirtualMachineIdentity_Status `json:"identity,omitempty"`

	//InstanceView: The virtual machine instance view.
	InstanceView *VirtualMachineInstanceView_Status `json:"instanceView,omitempty"`

	//LicenseType: Specifies that the image or disk that is being used was licensed
	//on-premises.
	//Possible values for Windows Server operating system are:
	//Windows_Client
	//Windows_Server
	//Possible values for Linux Server operating system are:
	//RHEL_BYOS (for RHEL)
	//SLES_BYOS (for SUSE)
	//For more information, see [Azure Hybrid Use Benefit for Windows
	//Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	//[Azure Hybrid Use Benefit for Linux
	//Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	//Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	//Location: Resource location
	Location *string `json:"location,omitempty"`

	//Name: Resource name
	Name *string `json:"name,omitempty"`

	//NetworkProfile: Specifies the network interfaces of the virtual machine.
	NetworkProfile *NetworkProfile_Status `json:"networkProfile,omitempty"`

	//OsProfile: Specifies the operating system settings used while creating the
	//virtual machine. Some of the settings cannot be changed once VM is provisioned.
	OsProfile *OSProfile_Status `json:"osProfile,omitempty"`

	//Plan: Specifies information about the marketplace image used to create the
	//virtual machine. This element is only used for marketplace images. Before you
	//can use a marketplace image from an API, you must enable the image for
	//programmatic use.  In the Azure portal, find the marketplace image that you want
	//to use and then click Want to deploy programmatically, Get Started ->. Enter any
	//required information and then click Save.
	Plan *Plan_Status `json:"plan,omitempty"`

	//PlatformFaultDomain: Specifies the scale set logical fault domain into which the
	//Virtual Machine will be created. By default, the Virtual Machine will by
	//automatically assigned to a fault domain that best maintains balance across
	//available fault domains.
	//<li>This is applicable only if the 'virtualMachineScaleSet' property of this
	//Virtual Machine is set.<li>The Virtual Machine Scale Set that is referenced,
	//must have 'platformFaultDomainCount' &gt; 1.<li>This property cannot be updated
	//once the Virtual Machine is created.<li>Fault domain assignment can be viewed in
	//the Virtual Machine Instance View.
	//Minimum api‐version: 2020‐12‐01
	PlatformFaultDomain *int `json:"platformFaultDomain,omitempty"`

	//Priority: Specifies the priority for the virtual machine.
	//Minimum api-version: 2019-03-01
	Priority *Priority_Status `json:"priority,omitempty"`

	//ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//ProximityPlacementGroup: Specifies information about the proximity placement
	//group that the virtual machine should be assigned to.
	//Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource_Status `json:"proximityPlacementGroup,omitempty"`

	//Resources: The virtual machine child extension resources.
	Resources []VirtualMachineExtension_Status `json:"resources,omitempty"`

	//SecurityProfile: Specifies the Security related profile settings for the virtual
	//machine.
	SecurityProfile *SecurityProfile_Status `json:"securityProfile,omitempty"`

	//StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *StorageProfile_Status `json:"storageProfile,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type
	Type *string `json:"type,omitempty"`

	//VirtualMachineScaleSet: Specifies information about the virtual machine scale
	//set that the virtual machine should be assigned to. Virtual machines specified
	//in the same virtual machine scale set are allocated to different nodes to
	//maximize availability. Currently, a VM can only be added to virtual machine
	//scale set at creation time. An existing VM cannot be added to a virtual machine
	//scale set.
	//This property cannot exist along with a non-null properties.availabilitySet
	//reference.
	//Minimum api‐version: 2019‐03‐01
	VirtualMachineScaleSet *SubResource_Status `json:"virtualMachineScaleSet,omitempty"`

	//VmId: Specifies the VM unique ID which is a 128-bits identifier that is encoded
	//and stored in all Azure IaaS VMs SMBIOS and can be read using platform BIOS
	//commands.
	VmId *string `json:"vmId,omitempty"`

	//Zones: The virtual machine zones.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachine_Status{}

// ConvertStatusFrom populates our VirtualMachine_Status from the provided source
func (virtualMachineStatus *VirtualMachine_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20201201storage.VirtualMachine_Status)
	if ok {
		// Populate our instance from source
		return virtualMachineStatus.AssignPropertiesFromVirtualMachineStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201201storage.VirtualMachine_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = virtualMachineStatus.AssignPropertiesFromVirtualMachineStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachine_Status
func (virtualMachineStatus *VirtualMachine_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20201201storage.VirtualMachine_Status)
	if ok {
		// Populate destination from our instance
		return virtualMachineStatus.AssignPropertiesToVirtualMachineStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201201storage.VirtualMachine_Status{}
	err := virtualMachineStatus.AssignPropertiesToVirtualMachineStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VirtualMachine_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineStatus *VirtualMachine_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachine_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineStatus *VirtualMachine_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachine_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachine_StatusARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities_Status
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			virtualMachineStatus.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property ‘AvailabilitySet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AvailabilitySet != nil {
			var availabilitySet1 SubResource_Status
			err := availabilitySet1.PopulateFromARM(owner, *typedInput.Properties.AvailabilitySet)
			if err != nil {
				return err
			}
			availabilitySet := availabilitySet1
			virtualMachineStatus.AvailabilitySet = &availabilitySet
		}
	}

	// Set property ‘BillingProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BillingProfile != nil {
			var billingProfile1 BillingProfile_Status
			err := billingProfile1.PopulateFromARM(owner, *typedInput.Properties.BillingProfile)
			if err != nil {
				return err
			}
			billingProfile := billingProfile1
			virtualMachineStatus.BillingProfile = &billingProfile
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DiagnosticsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiagnosticsProfile != nil {
			var diagnosticsProfile1 DiagnosticsProfile_Status
			err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.Properties.DiagnosticsProfile)
			if err != nil {
				return err
			}
			diagnosticsProfile := diagnosticsProfile1
			virtualMachineStatus.DiagnosticsProfile = &diagnosticsProfile
		}
	}

	// Set property ‘EvictionPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EvictionPolicy != nil {
			evictionPolicy := *typedInput.Properties.EvictionPolicy
			virtualMachineStatus.EvictionPolicy = &evictionPolicy
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		virtualMachineStatus.ExtendedLocation = &extendedLocation
	}

	// Set property ‘ExtensionsTimeBudget’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExtensionsTimeBudget != nil {
			extensionsTimeBudget := *typedInput.Properties.ExtensionsTimeBudget
			virtualMachineStatus.ExtensionsTimeBudget = &extensionsTimeBudget
		}
	}

	// Set property ‘HardwareProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HardwareProfile != nil {
			var hardwareProfile1 HardwareProfile_Status
			err := hardwareProfile1.PopulateFromARM(owner, *typedInput.Properties.HardwareProfile)
			if err != nil {
				return err
			}
			hardwareProfile := hardwareProfile1
			virtualMachineStatus.HardwareProfile = &hardwareProfile
		}
	}

	// Set property ‘Host’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Host != nil {
			var host1 SubResource_Status
			err := host1.PopulateFromARM(owner, *typedInput.Properties.Host)
			if err != nil {
				return err
			}
			host := host1
			virtualMachineStatus.Host = &host
		}
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource_Status
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			virtualMachineStatus.HostGroup = &hostGroup
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualMachineStatus.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineIdentity_Status
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		virtualMachineStatus.Identity = &identity
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 VirtualMachineInstanceView_Status
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			virtualMachineStatus.InstanceView = &instanceView
		}
	}

	// Set property ‘LicenseType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			virtualMachineStatus.LicenseType = &licenseType
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		virtualMachineStatus.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineStatus.Name = &name
	}

	// Set property ‘NetworkProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 NetworkProfile_Status
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			virtualMachineStatus.NetworkProfile = &networkProfile
		}
	}

	// Set property ‘OsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsProfile != nil {
			var osProfile1 OSProfile_Status
			err := osProfile1.PopulateFromARM(owner, *typedInput.Properties.OsProfile)
			if err != nil {
				return err
			}
			osProfile := osProfile1
			virtualMachineStatus.OsProfile = &osProfile
		}
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan_Status
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		virtualMachineStatus.Plan = &plan
	}

	// Set property ‘PlatformFaultDomain’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomain != nil {
			platformFaultDomain := *typedInput.Properties.PlatformFaultDomain
			virtualMachineStatus.PlatformFaultDomain = &platformFaultDomain
		}
	}

	// Set property ‘Priority’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			virtualMachineStatus.Priority = &priority
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			virtualMachineStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource_Status
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			virtualMachineStatus.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property ‘Resources’:
	for _, item := range typedInput.Resources {
		var item1 VirtualMachineExtension_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineStatus.Resources = append(virtualMachineStatus.Resources, item1)
	}

	// Set property ‘SecurityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecurityProfile != nil {
			var securityProfile1 SecurityProfile_Status
			err := securityProfile1.PopulateFromARM(owner, *typedInput.Properties.SecurityProfile)
			if err != nil {
				return err
			}
			securityProfile := securityProfile1
			virtualMachineStatus.SecurityProfile = &securityProfile
		}
	}

	// Set property ‘StorageProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 StorageProfile_Status
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			virtualMachineStatus.StorageProfile = &storageProfile
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		virtualMachineStatus.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			virtualMachineStatus.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineStatus.Type = &typeVar
	}

	// Set property ‘VirtualMachineScaleSet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineScaleSet != nil {
			var virtualMachineScaleSet1 SubResource_Status
			err := virtualMachineScaleSet1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineScaleSet)
			if err != nil {
				return err
			}
			virtualMachineScaleSet := virtualMachineScaleSet1
			virtualMachineStatus.VirtualMachineScaleSet = &virtualMachineScaleSet
		}
	}

	// Set property ‘VmId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VmId != nil {
			vmId := *typedInput.Properties.VmId
			virtualMachineStatus.VmId = &vmId
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		virtualMachineStatus.Zones = append(virtualMachineStatus.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineStatus populates our VirtualMachine_Status from the provided source VirtualMachine_Status
func (virtualMachineStatus *VirtualMachine_Status) AssignPropertiesFromVirtualMachineStatus(source *v1alpha1api20201201storage.VirtualMachine_Status) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_Status
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilitiesStatus(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalCapabilities from AdditionalCapabilities, calling AssignPropertiesFromAdditionalCapabilitiesStatus()")
		}
		virtualMachineStatus.AdditionalCapabilities = &additionalCapability
	} else {
		virtualMachineStatus.AdditionalCapabilities = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource_Status
		err := availabilitySet.AssignPropertiesFromSubResourceStatus(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "populating AvailabilitySet from AvailabilitySet, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineStatus.AvailabilitySet = &availabilitySet
	} else {
		virtualMachineStatus.AvailabilitySet = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_Status
		err := billingProfile.AssignPropertiesFromBillingProfileStatus(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "populating BillingProfile from BillingProfile, calling AssignPropertiesFromBillingProfileStatus()")
		}
		virtualMachineStatus.BillingProfile = &billingProfile
	} else {
		virtualMachineStatus.BillingProfile = nil
	}

	// Conditions
	virtualMachineStatus.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_Status
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfileStatus(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "populating DiagnosticsProfile from DiagnosticsProfile, calling AssignPropertiesFromDiagnosticsProfileStatus()")
		}
		virtualMachineStatus.DiagnosticsProfile = &diagnosticsProfile
	} else {
		virtualMachineStatus.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := EvictionPolicy_Status(*source.EvictionPolicy)
		virtualMachineStatus.EvictionPolicy = &evictionPolicy
	} else {
		virtualMachineStatus.EvictionPolicy = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		virtualMachineStatus.ExtendedLocation = &extendedLocation
	} else {
		virtualMachineStatus.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	virtualMachineStatus.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile_Status
		err := hardwareProfile.AssignPropertiesFromHardwareProfileStatus(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "populating HardwareProfile from HardwareProfile, calling AssignPropertiesFromHardwareProfileStatus()")
		}
		virtualMachineStatus.HardwareProfile = &hardwareProfile
	} else {
		virtualMachineStatus.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource_Status
		err := host.AssignPropertiesFromSubResourceStatus(source.Host)
		if err != nil {
			return errors.Wrap(err, "populating Host from Host, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineStatus.Host = &host
	} else {
		virtualMachineStatus.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_Status
		err := hostGroup.AssignPropertiesFromSubResourceStatus(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "populating HostGroup from HostGroup, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineStatus.HostGroup = &hostGroup
	} else {
		virtualMachineStatus.HostGroup = nil
	}

	// Id
	virtualMachineStatus.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity_Status
		err := identity.AssignPropertiesFromVirtualMachineIdentityStatus(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromVirtualMachineIdentityStatus()")
		}
		virtualMachineStatus.Identity = &identity
	} else {
		virtualMachineStatus.Identity = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineInstanceView_Status
		err := instanceView.AssignPropertiesFromVirtualMachineInstanceViewStatus(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "populating InstanceView from InstanceView, calling AssignPropertiesFromVirtualMachineInstanceViewStatus()")
		}
		virtualMachineStatus.InstanceView = &instanceView
	} else {
		virtualMachineStatus.InstanceView = nil
	}

	// LicenseType
	virtualMachineStatus.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	virtualMachineStatus.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	virtualMachineStatus.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile_Status
		err := networkProfile.AssignPropertiesFromNetworkProfileStatus(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesFromNetworkProfileStatus()")
		}
		virtualMachineStatus.NetworkProfile = &networkProfile
	} else {
		virtualMachineStatus.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile_Status
		err := osProfile.AssignPropertiesFromOSProfileStatus(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "populating OsProfile from OsProfile, calling AssignPropertiesFromOSProfileStatus()")
		}
		virtualMachineStatus.OsProfile = &osProfile
	} else {
		virtualMachineStatus.OsProfile = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_Status
		err := plan.AssignPropertiesFromPlanStatus(source.Plan)
		if err != nil {
			return errors.Wrap(err, "populating Plan from Plan, calling AssignPropertiesFromPlanStatus()")
		}
		virtualMachineStatus.Plan = &plan
	} else {
		virtualMachineStatus.Plan = nil
	}

	// PlatformFaultDomain
	virtualMachineStatus.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	if source.Priority != nil {
		priority := Priority_Status(*source.Priority)
		virtualMachineStatus.Priority = &priority
	} else {
		virtualMachineStatus.Priority = nil
	}

	// ProvisioningState
	virtualMachineStatus.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_Status
		err := proximityPlacementGroup.AssignPropertiesFromSubResourceStatus(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "populating ProximityPlacementGroup from ProximityPlacementGroup, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineStatus.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		virtualMachineStatus.ProximityPlacementGroup = nil
	}

	// Resources
	if source.Resources != nil {
		resourceList := make([]VirtualMachineExtension_Status, len(source.Resources))
		for resourceIndex, resourceItem := range source.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource VirtualMachineExtension_Status
			err := resource.AssignPropertiesFromVirtualMachineExtensionStatus(&resourceItem)
			if err != nil {
				return errors.Wrap(err, "populating Resources from Resources, calling AssignPropertiesFromVirtualMachineExtensionStatus()")
			}
			resourceList[resourceIndex] = resource
		}
		virtualMachineStatus.Resources = resourceList
	} else {
		virtualMachineStatus.Resources = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_Status
		err := securityProfile.AssignPropertiesFromSecurityProfileStatus(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "populating SecurityProfile from SecurityProfile, calling AssignPropertiesFromSecurityProfileStatus()")
		}
		virtualMachineStatus.SecurityProfile = &securityProfile
	} else {
		virtualMachineStatus.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile_Status
		err := storageProfile.AssignPropertiesFromStorageProfileStatus(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "populating StorageProfile from StorageProfile, calling AssignPropertiesFromStorageProfileStatus()")
		}
		virtualMachineStatus.StorageProfile = &storageProfile
	} else {
		virtualMachineStatus.StorageProfile = nil
	}

	// Tags
	virtualMachineStatus.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	virtualMachineStatus.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource_Status
		err := virtualMachineScaleSet.AssignPropertiesFromSubResourceStatus(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "populating VirtualMachineScaleSet from VirtualMachineScaleSet, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineStatus.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		virtualMachineStatus.VirtualMachineScaleSet = nil
	}

	// VmId
	virtualMachineStatus.VmId = genruntime.ClonePointerToString(source.VmId)

	// Zones
	virtualMachineStatus.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineStatus populates the provided destination VirtualMachine_Status from our VirtualMachine_Status
func (virtualMachineStatus *VirtualMachine_Status) AssignPropertiesToVirtualMachineStatus(destination *v1alpha1api20201201storage.VirtualMachine_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if virtualMachineStatus.AdditionalCapabilities != nil {
		var additionalCapability v1alpha1api20201201storage.AdditionalCapabilities_Status
		err := (*virtualMachineStatus.AdditionalCapabilities).AssignPropertiesToAdditionalCapabilitiesStatus(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalCapabilities from AdditionalCapabilities, calling AssignPropertiesToAdditionalCapabilitiesStatus()")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AvailabilitySet
	if virtualMachineStatus.AvailabilitySet != nil {
		var availabilitySet v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineStatus.AvailabilitySet).AssignPropertiesToSubResourceStatus(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "populating AvailabilitySet from AvailabilitySet, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// BillingProfile
	if virtualMachineStatus.BillingProfile != nil {
		var billingProfile v1alpha1api20201201storage.BillingProfile_Status
		err := (*virtualMachineStatus.BillingProfile).AssignPropertiesToBillingProfileStatus(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "populating BillingProfile from BillingProfile, calling AssignPropertiesToBillingProfileStatus()")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(virtualMachineStatus.Conditions)

	// DiagnosticsProfile
	if virtualMachineStatus.DiagnosticsProfile != nil {
		var diagnosticsProfile v1alpha1api20201201storage.DiagnosticsProfile_Status
		err := (*virtualMachineStatus.DiagnosticsProfile).AssignPropertiesToDiagnosticsProfileStatus(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "populating DiagnosticsProfile from DiagnosticsProfile, calling AssignPropertiesToDiagnosticsProfileStatus()")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if virtualMachineStatus.EvictionPolicy != nil {
		evictionPolicy := string(*virtualMachineStatus.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtendedLocation
	if virtualMachineStatus.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201201storage.ExtendedLocation_Status
		err := (*virtualMachineStatus.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(virtualMachineStatus.ExtensionsTimeBudget)

	// HardwareProfile
	if virtualMachineStatus.HardwareProfile != nil {
		var hardwareProfile v1alpha1api20201201storage.HardwareProfile_Status
		err := (*virtualMachineStatus.HardwareProfile).AssignPropertiesToHardwareProfileStatus(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "populating HardwareProfile from HardwareProfile, calling AssignPropertiesToHardwareProfileStatus()")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if virtualMachineStatus.Host != nil {
		var host v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineStatus.Host).AssignPropertiesToSubResourceStatus(&host)
		if err != nil {
			return errors.Wrap(err, "populating Host from Host, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if virtualMachineStatus.HostGroup != nil {
		var hostGroup v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineStatus.HostGroup).AssignPropertiesToSubResourceStatus(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "populating HostGroup from HostGroup, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(virtualMachineStatus.Id)

	// Identity
	if virtualMachineStatus.Identity != nil {
		var identity v1alpha1api20201201storage.VirtualMachineIdentity_Status
		err := (*virtualMachineStatus.Identity).AssignPropertiesToVirtualMachineIdentityStatus(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToVirtualMachineIdentityStatus()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InstanceView
	if virtualMachineStatus.InstanceView != nil {
		var instanceView v1alpha1api20201201storage.VirtualMachineInstanceView_Status
		err := (*virtualMachineStatus.InstanceView).AssignPropertiesToVirtualMachineInstanceViewStatus(&instanceView)
		if err != nil {
			return errors.Wrap(err, "populating InstanceView from InstanceView, calling AssignPropertiesToVirtualMachineInstanceViewStatus()")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(virtualMachineStatus.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(virtualMachineStatus.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(virtualMachineStatus.Name)

	// NetworkProfile
	if virtualMachineStatus.NetworkProfile != nil {
		var networkProfile v1alpha1api20201201storage.NetworkProfile_Status
		err := (*virtualMachineStatus.NetworkProfile).AssignPropertiesToNetworkProfileStatus(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesToNetworkProfileStatus()")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if virtualMachineStatus.OsProfile != nil {
		var osProfile v1alpha1api20201201storage.OSProfile_Status
		err := (*virtualMachineStatus.OsProfile).AssignPropertiesToOSProfileStatus(&osProfile)
		if err != nil {
			return errors.Wrap(err, "populating OsProfile from OsProfile, calling AssignPropertiesToOSProfileStatus()")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Plan
	if virtualMachineStatus.Plan != nil {
		var plan v1alpha1api20201201storage.Plan_Status
		err := (*virtualMachineStatus.Plan).AssignPropertiesToPlanStatus(&plan)
		if err != nil {
			return errors.Wrap(err, "populating Plan from Plan, calling AssignPropertiesToPlanStatus()")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(virtualMachineStatus.PlatformFaultDomain)

	// Priority
	if virtualMachineStatus.Priority != nil {
		priority := string(*virtualMachineStatus.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(virtualMachineStatus.ProvisioningState)

	// ProximityPlacementGroup
	if virtualMachineStatus.ProximityPlacementGroup != nil {
		var proximityPlacementGroup v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineStatus.ProximityPlacementGroup).AssignPropertiesToSubResourceStatus(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "populating ProximityPlacementGroup from ProximityPlacementGroup, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// Resources
	if virtualMachineStatus.Resources != nil {
		resourceList := make([]v1alpha1api20201201storage.VirtualMachineExtension_Status, len(virtualMachineStatus.Resources))
		for resourceIndex, resourceItem := range virtualMachineStatus.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource v1alpha1api20201201storage.VirtualMachineExtension_Status
			err := resourceItem.AssignPropertiesToVirtualMachineExtensionStatus(&resource)
			if err != nil {
				return errors.Wrap(err, "populating Resources from Resources, calling AssignPropertiesToVirtualMachineExtensionStatus()")
			}
			resourceList[resourceIndex] = resource
		}
		destination.Resources = resourceList
	} else {
		destination.Resources = nil
	}

	// SecurityProfile
	if virtualMachineStatus.SecurityProfile != nil {
		var securityProfile v1alpha1api20201201storage.SecurityProfile_Status
		err := (*virtualMachineStatus.SecurityProfile).AssignPropertiesToSecurityProfileStatus(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "populating SecurityProfile from SecurityProfile, calling AssignPropertiesToSecurityProfileStatus()")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if virtualMachineStatus.StorageProfile != nil {
		var storageProfile v1alpha1api20201201storage.StorageProfile_Status
		err := (*virtualMachineStatus.StorageProfile).AssignPropertiesToStorageProfileStatus(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "populating StorageProfile from StorageProfile, calling AssignPropertiesToStorageProfileStatus()")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(virtualMachineStatus.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(virtualMachineStatus.Type)

	// VirtualMachineScaleSet
	if virtualMachineStatus.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineStatus.VirtualMachineScaleSet).AssignPropertiesToSubResourceStatus(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "populating VirtualMachineScaleSet from VirtualMachineScaleSet, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// VmId
	destination.VmId = genruntime.ClonePointerToString(virtualMachineStatus.VmId)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(virtualMachineStatus.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"2020-12-01"}
type VirtualMachinesSpecAPIVersion string

const VirtualMachinesSpecAPIVersion20201201 = VirtualMachinesSpecAPIVersion("2020-12-01")

type VirtualMachines_Spec struct {
	//AdditionalCapabilities: Enables or disables a capability on the virtual machine
	//or virtual machine scale set.
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`
	AvailabilitySet        *SubResource            `json:"availabilitySet,omitempty"`

	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//BillingProfile: Specifies the billing related details of a Azure Spot VM or VMSS.
	//Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile `json:"billingProfile,omitempty"`

	//DiagnosticsProfile: Specifies the boot diagnostic settings state.
	//Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile `json:"diagnosticsProfile,omitempty"`

	//EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine
	//and Azure Spot scale set.
	//For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported
	//and the minimum api-version is 2019-03-01.
	//For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the
	//minimum api-version is 2017-10-30-preview.
	EvictionPolicy *VirtualMachinesSpecPropertiesEvictionPolicy `json:"evictionPolicy,omitempty"`

	//ExtendedLocation: The complex type of the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	//ExtensionsTimeBudget: Specifies the time alloted for all extensions to start.
	//The time duration should be between 15 minutes and 120 minutes (inclusive) and
	//should be specified in ISO 8601 format. The default value is 90 minutes
	//(PT1H30M).
	//Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`

	//HardwareProfile: Specifies the hardware settings for the virtual machine.
	HardwareProfile *HardwareProfile `json:"hardwareProfile,omitempty"`
	Host            *SubResource     `json:"host,omitempty"`
	HostGroup       *SubResource     `json:"hostGroup,omitempty"`

	//Identity: Identity for the virtual machine.
	Identity *VirtualMachineIdentity `json:"identity,omitempty"`

	//LicenseType: Specifies that the image or disk that is being used was licensed
	//on-premises.
	//Possible values for Windows Server operating system are:
	//Windows_Client
	//Windows_Server
	//Possible values for Linux Server operating system are:
	//RHEL_BYOS (for RHEL)
	//SLES_BYOS (for SUSE)
	//For more information, see [Azure Hybrid Use Benefit for Windows
	//Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	//[Azure Hybrid Use Benefit for Linux
	//Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	//Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	//Location: Location to deploy resource to
	Location string `json:"location,omitempty"`

	//NetworkProfile: Specifies the network interfaces of the virtual machine.
	NetworkProfile *VirtualMachines_Spec_Properties_NetworkProfile `json:"networkProfile,omitempty"`

	//OsProfile: Specifies the operating system settings for the virtual machine. Some
	//of the settings cannot be changed once VM is provisioned.
	OsProfile *OSProfile `json:"osProfile,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//Plan: Specifies information about the marketplace image used to create the
	//virtual machine. This element is only used for marketplace images. Before you
	//can use a marketplace image from an API, you must enable the image for
	//programmatic use.  In the Azure portal, find the marketplace image that you want
	//to use and then click Want to deploy programmatically, Get Started ->. Enter any
	//required information and then click Save.
	Plan *Plan `json:"plan,omitempty"`

	//PlatformFaultDomain: Specifies the scale set logical fault domain into which the
	//Virtual Machine will be created. By default, the Virtual Machine will by
	//automatically assigned to a fault domain that best maintains balance across
	//available fault domains.
	//<li>This is applicable only if the 'virtualMachineScaleSet' property of this
	//Virtual Machine is set.<li>The Virtual Machine Scale Set that is referenced,
	//must have 'platformFaultDomainCount' &gt; 1.<li>This property cannot be updated
	//once the Virtual Machine is created.<li>Fault domain assignment can be viewed in
	//the Virtual Machine Instance View.
	//Minimum api‐version: 2020‐12‐01
	PlatformFaultDomain *int `json:"platformFaultDomain,omitempty"`

	//Priority: Specifies the priority for the virtual machine.
	//Minimum api-version: 2019-03-01.
	Priority                *VirtualMachinesSpecPropertiesPriority `json:"priority,omitempty"`
	ProximityPlacementGroup *SubResource                           `json:"proximityPlacementGroup,omitempty"`

	//SecurityProfile: Specifies the Security profile settings for the virtual machine
	//or virtual machine scale set.
	SecurityProfile *SecurityProfile `json:"securityProfile,omitempty"`

	//StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`

	//Tags: Name-value pairs to add to the resource
	Tags                   map[string]string `json:"tags,omitempty"`
	VirtualMachineScaleSet *SubResource      `json:"virtualMachineScaleSet,omitempty"`

	//Zones: The virtual machine zones.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachines_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachinesSpec *VirtualMachines_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachinesSpec == nil {
		return nil, nil
	}
	var result VirtualMachines_SpecARM

	// Set property ‘ExtendedLocation’:
	if virtualMachinesSpec.ExtendedLocation != nil {
		extendedLocationARM, err := (*virtualMachinesSpec.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Identity’:
	if virtualMachinesSpec.Identity != nil {
		identityARM, err := (*virtualMachinesSpec.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := identityARM.(VirtualMachineIdentityARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	result.Location = virtualMachinesSpec.Location

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Plan’:
	if virtualMachinesSpec.Plan != nil {
		planARM, err := (*virtualMachinesSpec.Plan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plan := planARM.(PlanARM)
		result.Plan = &plan
	}

	// Set property ‘Properties’:
	if virtualMachinesSpec.AdditionalCapabilities != nil {
		additionalCapabilitiesARM, err := (*virtualMachinesSpec.AdditionalCapabilities).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		additionalCapabilities := additionalCapabilitiesARM.(AdditionalCapabilitiesARM)
		result.Properties.AdditionalCapabilities = &additionalCapabilities
	}
	if virtualMachinesSpec.AvailabilitySet != nil {
		availabilitySetARM, err := (*virtualMachinesSpec.AvailabilitySet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		availabilitySet := availabilitySetARM.(SubResourceARM)
		result.Properties.AvailabilitySet = &availabilitySet
	}
	if virtualMachinesSpec.BillingProfile != nil {
		billingProfileARM, err := (*virtualMachinesSpec.BillingProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		billingProfile := billingProfileARM.(BillingProfileARM)
		result.Properties.BillingProfile = &billingProfile
	}
	if virtualMachinesSpec.DiagnosticsProfile != nil {
		diagnosticsProfileARM, err := (*virtualMachinesSpec.DiagnosticsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnosticsProfile := diagnosticsProfileARM.(DiagnosticsProfileARM)
		result.Properties.DiagnosticsProfile = &diagnosticsProfile
	}
	if virtualMachinesSpec.EvictionPolicy != nil {
		evictionPolicy := *virtualMachinesSpec.EvictionPolicy
		result.Properties.EvictionPolicy = &evictionPolicy
	}
	if virtualMachinesSpec.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *virtualMachinesSpec.ExtensionsTimeBudget
		result.Properties.ExtensionsTimeBudget = &extensionsTimeBudget
	}
	if virtualMachinesSpec.HardwareProfile != nil {
		hardwareProfileARM, err := (*virtualMachinesSpec.HardwareProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hardwareProfile := hardwareProfileARM.(HardwareProfileARM)
		result.Properties.HardwareProfile = &hardwareProfile
	}
	if virtualMachinesSpec.Host != nil {
		hostARM, err := (*virtualMachinesSpec.Host).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		host := hostARM.(SubResourceARM)
		result.Properties.Host = &host
	}
	if virtualMachinesSpec.HostGroup != nil {
		hostGroupARM, err := (*virtualMachinesSpec.HostGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostGroup := hostGroupARM.(SubResourceARM)
		result.Properties.HostGroup = &hostGroup
	}
	if virtualMachinesSpec.LicenseType != nil {
		licenseType := *virtualMachinesSpec.LicenseType
		result.Properties.LicenseType = &licenseType
	}
	if virtualMachinesSpec.NetworkProfile != nil {
		networkProfileARM, err := (*virtualMachinesSpec.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := networkProfileARM.(VirtualMachines_Spec_Properties_NetworkProfileARM)
		result.Properties.NetworkProfile = &networkProfile
	}
	if virtualMachinesSpec.OsProfile != nil {
		osProfileARM, err := (*virtualMachinesSpec.OsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osProfile := osProfileARM.(OSProfileARM)
		result.Properties.OsProfile = &osProfile
	}
	if virtualMachinesSpec.PlatformFaultDomain != nil {
		platformFaultDomain := *virtualMachinesSpec.PlatformFaultDomain
		result.Properties.PlatformFaultDomain = &platformFaultDomain
	}
	if virtualMachinesSpec.Priority != nil {
		priority := *virtualMachinesSpec.Priority
		result.Properties.Priority = &priority
	}
	if virtualMachinesSpec.ProximityPlacementGroup != nil {
		proximityPlacementGroupARM, err := (*virtualMachinesSpec.ProximityPlacementGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proximityPlacementGroup := proximityPlacementGroupARM.(SubResourceARM)
		result.Properties.ProximityPlacementGroup = &proximityPlacementGroup
	}
	if virtualMachinesSpec.SecurityProfile != nil {
		securityProfileARM, err := (*virtualMachinesSpec.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := securityProfileARM.(SecurityProfileARM)
		result.Properties.SecurityProfile = &securityProfile
	}
	if virtualMachinesSpec.StorageProfile != nil {
		storageProfileARM, err := (*virtualMachinesSpec.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := storageProfileARM.(StorageProfileARM)
		result.Properties.StorageProfile = &storageProfile
	}
	if virtualMachinesSpec.VirtualMachineScaleSet != nil {
		virtualMachineScaleSetARM, err := (*virtualMachinesSpec.VirtualMachineScaleSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineScaleSet := virtualMachineScaleSetARM.(SubResourceARM)
		result.Properties.VirtualMachineScaleSet = &virtualMachineScaleSet
	}

	// Set property ‘Tags’:
	if virtualMachinesSpec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range virtualMachinesSpec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range virtualMachinesSpec.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachinesSpec *VirtualMachines_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachines_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachinesSpec *VirtualMachines_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachines_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachines_SpecARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties.AdditionalCapabilities != nil {
		var additionalCapabilities1 AdditionalCapabilities
		err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
		if err != nil {
			return err
		}
		additionalCapabilities := additionalCapabilities1
		virtualMachinesSpec.AdditionalCapabilities = &additionalCapabilities
	}

	// Set property ‘AvailabilitySet’:
	// copying flattened property:
	if typedInput.Properties.AvailabilitySet != nil {
		var availabilitySet1 SubResource
		err := availabilitySet1.PopulateFromARM(owner, *typedInput.Properties.AvailabilitySet)
		if err != nil {
			return err
		}
		availabilitySet := availabilitySet1
		virtualMachinesSpec.AvailabilitySet = &availabilitySet
	}

	// Set property ‘AzureName’:
	virtualMachinesSpec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘BillingProfile’:
	// copying flattened property:
	if typedInput.Properties.BillingProfile != nil {
		var billingProfile1 BillingProfile
		err := billingProfile1.PopulateFromARM(owner, *typedInput.Properties.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		virtualMachinesSpec.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	// copying flattened property:
	if typedInput.Properties.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.Properties.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		virtualMachinesSpec.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	// copying flattened property:
	if typedInput.Properties.EvictionPolicy != nil {
		evictionPolicy := *typedInput.Properties.EvictionPolicy
		virtualMachinesSpec.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		virtualMachinesSpec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘ExtensionsTimeBudget’:
	// copying flattened property:
	if typedInput.Properties.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.Properties.ExtensionsTimeBudget
		virtualMachinesSpec.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// Set property ‘HardwareProfile’:
	// copying flattened property:
	if typedInput.Properties.HardwareProfile != nil {
		var hardwareProfile1 HardwareProfile
		err := hardwareProfile1.PopulateFromARM(owner, *typedInput.Properties.HardwareProfile)
		if err != nil {
			return err
		}
		hardwareProfile := hardwareProfile1
		virtualMachinesSpec.HardwareProfile = &hardwareProfile
	}

	// Set property ‘Host’:
	// copying flattened property:
	if typedInput.Properties.Host != nil {
		var host1 SubResource
		err := host1.PopulateFromARM(owner, *typedInput.Properties.Host)
		if err != nil {
			return err
		}
		host := host1
		virtualMachinesSpec.Host = &host
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties.HostGroup != nil {
		var hostGroup1 SubResource
		err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
		if err != nil {
			return err
		}
		hostGroup := hostGroup1
		virtualMachinesSpec.HostGroup = &hostGroup
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		virtualMachinesSpec.Identity = &identity
	}

	// Set property ‘LicenseType’:
	// copying flattened property:
	if typedInput.Properties.LicenseType != nil {
		licenseType := *typedInput.Properties.LicenseType
		virtualMachinesSpec.LicenseType = &licenseType
	}

	// Set property ‘Location’:
	virtualMachinesSpec.Location = typedInput.Location

	// Set property ‘NetworkProfile’:
	// copying flattened property:
	if typedInput.Properties.NetworkProfile != nil {
		var networkProfile1 VirtualMachines_Spec_Properties_NetworkProfile
		err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		virtualMachinesSpec.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	// copying flattened property:
	if typedInput.Properties.OsProfile != nil {
		var osProfile1 OSProfile
		err := osProfile1.PopulateFromARM(owner, *typedInput.Properties.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		virtualMachinesSpec.OsProfile = &osProfile
	}

	// Set property ‘Owner’:
	virtualMachinesSpec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		virtualMachinesSpec.Plan = &plan
	}

	// Set property ‘PlatformFaultDomain’:
	// copying flattened property:
	if typedInput.Properties.PlatformFaultDomain != nil {
		platformFaultDomain := *typedInput.Properties.PlatformFaultDomain
		virtualMachinesSpec.PlatformFaultDomain = &platformFaultDomain
	}

	// Set property ‘Priority’:
	// copying flattened property:
	if typedInput.Properties.Priority != nil {
		priority := *typedInput.Properties.Priority
		virtualMachinesSpec.Priority = &priority
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties.ProximityPlacementGroup != nil {
		var proximityPlacementGroup1 SubResource
		err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
		if err != nil {
			return err
		}
		proximityPlacementGroup := proximityPlacementGroup1
		virtualMachinesSpec.ProximityPlacementGroup = &proximityPlacementGroup
	}

	// Set property ‘SecurityProfile’:
	// copying flattened property:
	if typedInput.Properties.SecurityProfile != nil {
		var securityProfile1 SecurityProfile
		err := securityProfile1.PopulateFromARM(owner, *typedInput.Properties.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		virtualMachinesSpec.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	// copying flattened property:
	if typedInput.Properties.StorageProfile != nil {
		var storageProfile1 StorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		virtualMachinesSpec.StorageProfile = &storageProfile
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		virtualMachinesSpec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			virtualMachinesSpec.Tags[key] = value
		}
	}

	// Set property ‘VirtualMachineScaleSet’:
	// copying flattened property:
	if typedInput.Properties.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet1 SubResource
		err := virtualMachineScaleSet1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineScaleSet)
		if err != nil {
			return err
		}
		virtualMachineScaleSet := virtualMachineScaleSet1
		virtualMachinesSpec.VirtualMachineScaleSet = &virtualMachineScaleSet
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		virtualMachinesSpec.Zones = append(virtualMachinesSpec.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualMachines_Spec{}

// ConvertSpecFrom populates our VirtualMachines_Spec from the provided source
func (virtualMachinesSpec *VirtualMachines_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20201201storage.VirtualMachines_Spec)
	if ok {
		// Populate our instance from source
		return virtualMachinesSpec.AssignPropertiesFromVirtualMachinesSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201201storage.VirtualMachines_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = virtualMachinesSpec.AssignPropertiesFromVirtualMachinesSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachines_Spec
func (virtualMachinesSpec *VirtualMachines_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20201201storage.VirtualMachines_Spec)
	if ok {
		// Populate destination from our instance
		return virtualMachinesSpec.AssignPropertiesToVirtualMachinesSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201201storage.VirtualMachines_Spec{}
	err := virtualMachinesSpec.AssignPropertiesToVirtualMachinesSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualMachinesSpec populates our VirtualMachines_Spec from the provided source VirtualMachines_Spec
func (virtualMachinesSpec *VirtualMachines_Spec) AssignPropertiesFromVirtualMachinesSpec(source *v1alpha1api20201201storage.VirtualMachines_Spec) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalCapabilities from AdditionalCapabilities, calling AssignPropertiesFromAdditionalCapabilities()")
		}
		virtualMachinesSpec.AdditionalCapabilities = &additionalCapability
	} else {
		virtualMachinesSpec.AdditionalCapabilities = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource
		err := availabilitySet.AssignPropertiesFromSubResource(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "populating AvailabilitySet from AvailabilitySet, calling AssignPropertiesFromSubResource()")
		}
		virtualMachinesSpec.AvailabilitySet = &availabilitySet
	} else {
		virtualMachinesSpec.AvailabilitySet = nil
	}

	// AzureName
	virtualMachinesSpec.AzureName = source.AzureName

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignPropertiesFromBillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "populating BillingProfile from BillingProfile, calling AssignPropertiesFromBillingProfile()")
		}
		virtualMachinesSpec.BillingProfile = &billingProfile
	} else {
		virtualMachinesSpec.BillingProfile = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "populating DiagnosticsProfile from DiagnosticsProfile, calling AssignPropertiesFromDiagnosticsProfile()")
		}
		virtualMachinesSpec.DiagnosticsProfile = &diagnosticsProfile
	} else {
		virtualMachinesSpec.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := VirtualMachinesSpecPropertiesEvictionPolicy(*source.EvictionPolicy)
		virtualMachinesSpec.EvictionPolicy = &evictionPolicy
	} else {
		virtualMachinesSpec.EvictionPolicy = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocation()")
		}
		virtualMachinesSpec.ExtendedLocation = &extendedLocation
	} else {
		virtualMachinesSpec.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	virtualMachinesSpec.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile
		err := hardwareProfile.AssignPropertiesFromHardwareProfile(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "populating HardwareProfile from HardwareProfile, calling AssignPropertiesFromHardwareProfile()")
		}
		virtualMachinesSpec.HardwareProfile = &hardwareProfile
	} else {
		virtualMachinesSpec.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource
		err := host.AssignPropertiesFromSubResource(source.Host)
		if err != nil {
			return errors.Wrap(err, "populating Host from Host, calling AssignPropertiesFromSubResource()")
		}
		virtualMachinesSpec.Host = &host
	} else {
		virtualMachinesSpec.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.AssignPropertiesFromSubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "populating HostGroup from HostGroup, calling AssignPropertiesFromSubResource()")
		}
		virtualMachinesSpec.HostGroup = &hostGroup
	} else {
		virtualMachinesSpec.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity
		err := identity.AssignPropertiesFromVirtualMachineIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromVirtualMachineIdentity()")
		}
		virtualMachinesSpec.Identity = &identity
	} else {
		virtualMachinesSpec.Identity = nil
	}

	// LicenseType
	virtualMachinesSpec.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	virtualMachinesSpec.Location = genruntime.GetOptionalStringValue(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachines_Spec_Properties_NetworkProfile
		err := networkProfile.AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile()")
		}
		virtualMachinesSpec.NetworkProfile = &networkProfile
	} else {
		virtualMachinesSpec.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile
		err := osProfile.AssignPropertiesFromOSProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "populating OsProfile from OsProfile, calling AssignPropertiesFromOSProfile()")
		}
		virtualMachinesSpec.OsProfile = &osProfile
	} else {
		virtualMachinesSpec.OsProfile = nil
	}

	// Owner
	virtualMachinesSpec.Owner = source.Owner.Copy()

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignPropertiesFromPlan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "populating Plan from Plan, calling AssignPropertiesFromPlan()")
		}
		virtualMachinesSpec.Plan = &plan
	} else {
		virtualMachinesSpec.Plan = nil
	}

	// PlatformFaultDomain
	virtualMachinesSpec.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	if source.Priority != nil {
		priority := VirtualMachinesSpecPropertiesPriority(*source.Priority)
		virtualMachinesSpec.Priority = &priority
	} else {
		virtualMachinesSpec.Priority = nil
	}

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.AssignPropertiesFromSubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "populating ProximityPlacementGroup from ProximityPlacementGroup, calling AssignPropertiesFromSubResource()")
		}
		virtualMachinesSpec.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		virtualMachinesSpec.ProximityPlacementGroup = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignPropertiesFromSecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "populating SecurityProfile from SecurityProfile, calling AssignPropertiesFromSecurityProfile()")
		}
		virtualMachinesSpec.SecurityProfile = &securityProfile
	} else {
		virtualMachinesSpec.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignPropertiesFromStorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "populating StorageProfile from StorageProfile, calling AssignPropertiesFromStorageProfile()")
		}
		virtualMachinesSpec.StorageProfile = &storageProfile
	} else {
		virtualMachinesSpec.StorageProfile = nil
	}

	// Tags
	virtualMachinesSpec.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource
		err := virtualMachineScaleSet.AssignPropertiesFromSubResource(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "populating VirtualMachineScaleSet from VirtualMachineScaleSet, calling AssignPropertiesFromSubResource()")
		}
		virtualMachinesSpec.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		virtualMachinesSpec.VirtualMachineScaleSet = nil
	}

	// Zones
	virtualMachinesSpec.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpec populates the provided destination VirtualMachines_Spec from our VirtualMachines_Spec
func (virtualMachinesSpec *VirtualMachines_Spec) AssignPropertiesToVirtualMachinesSpec(destination *v1alpha1api20201201storage.VirtualMachines_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if virtualMachinesSpec.AdditionalCapabilities != nil {
		var additionalCapability v1alpha1api20201201storage.AdditionalCapabilities
		err := (*virtualMachinesSpec.AdditionalCapabilities).AssignPropertiesToAdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalCapabilities from AdditionalCapabilities, calling AssignPropertiesToAdditionalCapabilities()")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AvailabilitySet
	if virtualMachinesSpec.AvailabilitySet != nil {
		var availabilitySet v1alpha1api20201201storage.SubResource
		err := (*virtualMachinesSpec.AvailabilitySet).AssignPropertiesToSubResource(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "populating AvailabilitySet from AvailabilitySet, calling AssignPropertiesToSubResource()")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// AzureName
	destination.AzureName = virtualMachinesSpec.AzureName

	// BillingProfile
	if virtualMachinesSpec.BillingProfile != nil {
		var billingProfile v1alpha1api20201201storage.BillingProfile
		err := (*virtualMachinesSpec.BillingProfile).AssignPropertiesToBillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "populating BillingProfile from BillingProfile, calling AssignPropertiesToBillingProfile()")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// DiagnosticsProfile
	if virtualMachinesSpec.DiagnosticsProfile != nil {
		var diagnosticsProfile v1alpha1api20201201storage.DiagnosticsProfile
		err := (*virtualMachinesSpec.DiagnosticsProfile).AssignPropertiesToDiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "populating DiagnosticsProfile from DiagnosticsProfile, calling AssignPropertiesToDiagnosticsProfile()")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if virtualMachinesSpec.EvictionPolicy != nil {
		evictionPolicy := string(*virtualMachinesSpec.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtendedLocation
	if virtualMachinesSpec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201201storage.ExtendedLocation
		err := (*virtualMachinesSpec.ExtendedLocation).AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocation()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(virtualMachinesSpec.ExtensionsTimeBudget)

	// HardwareProfile
	if virtualMachinesSpec.HardwareProfile != nil {
		var hardwareProfile v1alpha1api20201201storage.HardwareProfile
		err := (*virtualMachinesSpec.HardwareProfile).AssignPropertiesToHardwareProfile(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "populating HardwareProfile from HardwareProfile, calling AssignPropertiesToHardwareProfile()")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if virtualMachinesSpec.Host != nil {
		var host v1alpha1api20201201storage.SubResource
		err := (*virtualMachinesSpec.Host).AssignPropertiesToSubResource(&host)
		if err != nil {
			return errors.Wrap(err, "populating Host from Host, calling AssignPropertiesToSubResource()")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if virtualMachinesSpec.HostGroup != nil {
		var hostGroup v1alpha1api20201201storage.SubResource
		err := (*virtualMachinesSpec.HostGroup).AssignPropertiesToSubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "populating HostGroup from HostGroup, calling AssignPropertiesToSubResource()")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if virtualMachinesSpec.Identity != nil {
		var identity v1alpha1api20201201storage.VirtualMachineIdentity
		err := (*virtualMachinesSpec.Identity).AssignPropertiesToVirtualMachineIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToVirtualMachineIdentity()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(virtualMachinesSpec.LicenseType)

	// Location
	location := virtualMachinesSpec.Location
	destination.Location = &location

	// NetworkProfile
	if virtualMachinesSpec.NetworkProfile != nil {
		var networkProfile v1alpha1api20201201storage.VirtualMachines_Spec_Properties_NetworkProfile
		err := (*virtualMachinesSpec.NetworkProfile).AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile()")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OriginalVersion
	destination.OriginalVersion = virtualMachinesSpec.OriginalVersion()

	// OsProfile
	if virtualMachinesSpec.OsProfile != nil {
		var osProfile v1alpha1api20201201storage.OSProfile
		err := (*virtualMachinesSpec.OsProfile).AssignPropertiesToOSProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "populating OsProfile from OsProfile, calling AssignPropertiesToOSProfile()")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Owner
	destination.Owner = virtualMachinesSpec.Owner.Copy()

	// Plan
	if virtualMachinesSpec.Plan != nil {
		var plan v1alpha1api20201201storage.Plan
		err := (*virtualMachinesSpec.Plan).AssignPropertiesToPlan(&plan)
		if err != nil {
			return errors.Wrap(err, "populating Plan from Plan, calling AssignPropertiesToPlan()")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(virtualMachinesSpec.PlatformFaultDomain)

	// Priority
	if virtualMachinesSpec.Priority != nil {
		priority := string(*virtualMachinesSpec.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ProximityPlacementGroup
	if virtualMachinesSpec.ProximityPlacementGroup != nil {
		var proximityPlacementGroup v1alpha1api20201201storage.SubResource
		err := (*virtualMachinesSpec.ProximityPlacementGroup).AssignPropertiesToSubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "populating ProximityPlacementGroup from ProximityPlacementGroup, calling AssignPropertiesToSubResource()")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// SecurityProfile
	if virtualMachinesSpec.SecurityProfile != nil {
		var securityProfile v1alpha1api20201201storage.SecurityProfile
		err := (*virtualMachinesSpec.SecurityProfile).AssignPropertiesToSecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "populating SecurityProfile from SecurityProfile, calling AssignPropertiesToSecurityProfile()")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if virtualMachinesSpec.StorageProfile != nil {
		var storageProfile v1alpha1api20201201storage.StorageProfile
		err := (*virtualMachinesSpec.StorageProfile).AssignPropertiesToStorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "populating StorageProfile from StorageProfile, calling AssignPropertiesToStorageProfile()")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(virtualMachinesSpec.Tags)

	// VirtualMachineScaleSet
	if virtualMachinesSpec.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet v1alpha1api20201201storage.SubResource
		err := (*virtualMachinesSpec.VirtualMachineScaleSet).AssignPropertiesToSubResource(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "populating VirtualMachineScaleSet from VirtualMachineScaleSet, calling AssignPropertiesToSubResource()")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(virtualMachinesSpec.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (virtualMachinesSpec *VirtualMachines_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (virtualMachinesSpec *VirtualMachines_Spec) SetAzureName(azureName string) {
	virtualMachinesSpec.AzureName = azureName
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/AdditionalCapabilities
type AdditionalCapabilities struct {
	//UltraSSDEnabled: The flag that enables or disables a capability to have one or
	//more managed data disks with UltraSSD_LRS storage account type on the VM or
	//VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a
	//virtual machine or virtual machine scale set only if this property is enabled.
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &AdditionalCapabilities{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (additionalCapabilities *AdditionalCapabilities) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if additionalCapabilities == nil {
		return nil, nil
	}
	var result AdditionalCapabilitiesARM

	// Set property ‘UltraSSDEnabled’:
	if additionalCapabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *additionalCapabilities.UltraSSDEnabled
		result.UltraSSDEnabled = &ultraSSDEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (additionalCapabilities *AdditionalCapabilities) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalCapabilitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (additionalCapabilities *AdditionalCapabilities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalCapabilitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalCapabilitiesARM, got %T", armInput)
	}

	// Set property ‘UltraSSDEnabled’:
	if typedInput.UltraSSDEnabled != nil {
		ultraSSDEnabled := *typedInput.UltraSSDEnabled
		additionalCapabilities.UltraSSDEnabled = &ultraSSDEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalCapabilities populates our AdditionalCapabilities from the provided source AdditionalCapabilities
func (additionalCapabilities *AdditionalCapabilities) AssignPropertiesFromAdditionalCapabilities(source *v1alpha1api20201201storage.AdditionalCapabilities) error {

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		additionalCapabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		additionalCapabilities.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalCapabilities populates the provided destination AdditionalCapabilities from our AdditionalCapabilities
func (additionalCapabilities *AdditionalCapabilities) AssignPropertiesToAdditionalCapabilities(destination *v1alpha1api20201201storage.AdditionalCapabilities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UltraSSDEnabled
	if additionalCapabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *additionalCapabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AdditionalCapabilities_Status struct {
	//UltraSSDEnabled: The flag that enables or disables a capability to have one or
	//more managed data disks with UltraSSD_LRS storage account type on the VM or
	//VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a
	//virtual machine or virtual machine scale set only if this property is enabled.
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &AdditionalCapabilities_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (additionalCapabilitiesStatus *AdditionalCapabilities_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalCapabilities_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (additionalCapabilitiesStatus *AdditionalCapabilities_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalCapabilities_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalCapabilities_StatusARM, got %T", armInput)
	}

	// Set property ‘UltraSSDEnabled’:
	if typedInput.UltraSSDEnabled != nil {
		ultraSSDEnabled := *typedInput.UltraSSDEnabled
		additionalCapabilitiesStatus.UltraSSDEnabled = &ultraSSDEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalCapabilitiesStatus populates our AdditionalCapabilities_Status from the provided source AdditionalCapabilities_Status
func (additionalCapabilitiesStatus *AdditionalCapabilities_Status) AssignPropertiesFromAdditionalCapabilitiesStatus(source *v1alpha1api20201201storage.AdditionalCapabilities_Status) error {

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		additionalCapabilitiesStatus.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		additionalCapabilitiesStatus.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalCapabilitiesStatus populates the provided destination AdditionalCapabilities_Status from our AdditionalCapabilities_Status
func (additionalCapabilitiesStatus *AdditionalCapabilities_Status) AssignPropertiesToAdditionalCapabilitiesStatus(destination *v1alpha1api20201201storage.AdditionalCapabilities_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UltraSSDEnabled
	if additionalCapabilitiesStatus.UltraSSDEnabled != nil {
		ultraSSDEnabled := *additionalCapabilitiesStatus.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/BillingProfile
type BillingProfile struct {
	//MaxPrice: Specifies the maximum price you are willing to pay for a Azure Spot
	//VM/VMSS. This price is in US Dollars.
	//This price will be compared with the current Azure Spot price for the VM size.
	//Also, the prices are compared at the time of create/update of Azure Spot VM/VMSS
	//and the operation will only succeed if  the maxPrice is greater than the current
	//Azure Spot price.
	//The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current
	//Azure Spot price goes beyond the maxPrice after creation of VM/VMSS.
	//Possible values are:
	//- Any decimal value greater than zero. Example: 0.01538
	//-1 – indicates default price to be up-to on-demand.
	//You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should
	//not be evicted for price reasons. Also, the default max price is -1 if it is not
	//provided by you.
	//Minimum api-version: 2019-03-01.
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

var _ genruntime.ARMTransformer = &BillingProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (billingProfile *BillingProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if billingProfile == nil {
		return nil, nil
	}
	var result BillingProfileARM

	// Set property ‘MaxPrice’:
	if billingProfile.MaxPrice != nil {
		maxPrice := *billingProfile.MaxPrice
		result.MaxPrice = &maxPrice
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (billingProfile *BillingProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BillingProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (billingProfile *BillingProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BillingProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BillingProfileARM, got %T", armInput)
	}

	// Set property ‘MaxPrice’:
	if typedInput.MaxPrice != nil {
		maxPrice := *typedInput.MaxPrice
		billingProfile.MaxPrice = &maxPrice
	}

	// No error
	return nil
}

// AssignPropertiesFromBillingProfile populates our BillingProfile from the provided source BillingProfile
func (billingProfile *BillingProfile) AssignPropertiesFromBillingProfile(source *v1alpha1api20201201storage.BillingProfile) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		billingProfile.MaxPrice = &maxPrice
	} else {
		billingProfile.MaxPrice = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBillingProfile populates the provided destination BillingProfile from our BillingProfile
func (billingProfile *BillingProfile) AssignPropertiesToBillingProfile(destination *v1alpha1api20201201storage.BillingProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxPrice
	if billingProfile.MaxPrice != nil {
		maxPrice := *billingProfile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BillingProfile_Status struct {
	//MaxPrice: Specifies the maximum price you are willing to pay for a Azure Spot
	//VM/VMSS. This price is in US Dollars.
	//This price will be compared with the current Azure Spot price for the VM size.
	//Also, the prices are compared at the time of create/update of Azure Spot VM/VMSS
	//and the operation will only succeed if  the maxPrice is greater than the current
	//Azure Spot price.
	//The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current
	//Azure Spot price goes beyond the maxPrice after creation of VM/VMSS.
	//Possible values are:
	//- Any decimal value greater than zero. Example: 0.01538
	//-1 – indicates default price to be up-to on-demand.
	//You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should
	//not be evicted for price reasons. Also, the default max price is -1 if it is not
	//provided by you.
	//Minimum api-version: 2019-03-01.
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

var _ genruntime.FromARMConverter = &BillingProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (billingProfileStatus *BillingProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BillingProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (billingProfileStatus *BillingProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BillingProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BillingProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘MaxPrice’:
	if typedInput.MaxPrice != nil {
		maxPrice := *typedInput.MaxPrice
		billingProfileStatus.MaxPrice = &maxPrice
	}

	// No error
	return nil
}

// AssignPropertiesFromBillingProfileStatus populates our BillingProfile_Status from the provided source BillingProfile_Status
func (billingProfileStatus *BillingProfile_Status) AssignPropertiesFromBillingProfileStatus(source *v1alpha1api20201201storage.BillingProfile_Status) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		billingProfileStatus.MaxPrice = &maxPrice
	} else {
		billingProfileStatus.MaxPrice = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBillingProfileStatus populates the provided destination BillingProfile_Status from our BillingProfile_Status
func (billingProfileStatus *BillingProfile_Status) AssignPropertiesToBillingProfileStatus(destination *v1alpha1api20201201storage.BillingProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxPrice
	if billingProfileStatus.MaxPrice != nil {
		maxPrice := *billingProfileStatus.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiagnosticsProfile
type DiagnosticsProfile struct {
	//BootDiagnostics: Boot Diagnostics is a debugging feature which allows you to
	//view Console Output and Screenshot to diagnose VM status.
	//You can easily view the output of your console log.
	//Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnostics `json:"bootDiagnostics,omitempty"`
}

var _ genruntime.ARMTransformer = &DiagnosticsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diagnosticsProfile *DiagnosticsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diagnosticsProfile == nil {
		return nil, nil
	}
	var result DiagnosticsProfileARM

	// Set property ‘BootDiagnostics’:
	if diagnosticsProfile.BootDiagnostics != nil {
		bootDiagnosticsARM, err := (*diagnosticsProfile.BootDiagnostics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		bootDiagnostics := bootDiagnosticsARM.(BootDiagnosticsARM)
		result.BootDiagnostics = &bootDiagnostics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnosticsProfile *DiagnosticsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiagnosticsProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnosticsProfile *DiagnosticsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiagnosticsProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiagnosticsProfileARM, got %T", armInput)
	}

	// Set property ‘BootDiagnostics’:
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnostics
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		diagnosticsProfile.BootDiagnostics = &bootDiagnostics
	}

	// No error
	return nil
}

// AssignPropertiesFromDiagnosticsProfile populates our DiagnosticsProfile from the provided source DiagnosticsProfile
func (diagnosticsProfile *DiagnosticsProfile) AssignPropertiesFromDiagnosticsProfile(source *v1alpha1api20201201storage.DiagnosticsProfile) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics
		err := bootDiagnostic.AssignPropertiesFromBootDiagnostics(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesFromBootDiagnostics()")
		}
		diagnosticsProfile.BootDiagnostics = &bootDiagnostic
	} else {
		diagnosticsProfile.BootDiagnostics = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiagnosticsProfile populates the provided destination DiagnosticsProfile from our DiagnosticsProfile
func (diagnosticsProfile *DiagnosticsProfile) AssignPropertiesToDiagnosticsProfile(destination *v1alpha1api20201201storage.DiagnosticsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BootDiagnostics
	if diagnosticsProfile.BootDiagnostics != nil {
		var bootDiagnostic v1alpha1api20201201storage.BootDiagnostics
		err := (*diagnosticsProfile.BootDiagnostics).AssignPropertiesToBootDiagnostics(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesToBootDiagnostics()")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DiagnosticsProfile_Status struct {
	//BootDiagnostics: Boot Diagnostics is a debugging feature which allows you to
	//view Console Output and Screenshot to diagnose VM status.
	//You can easily view the output of your console log.
	//Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnostics_Status `json:"bootDiagnostics,omitempty"`
}

var _ genruntime.FromARMConverter = &DiagnosticsProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnosticsProfileStatus *DiagnosticsProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiagnosticsProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnosticsProfileStatus *DiagnosticsProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiagnosticsProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiagnosticsProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘BootDiagnostics’:
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnostics_Status
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		diagnosticsProfileStatus.BootDiagnostics = &bootDiagnostics
	}

	// No error
	return nil
}

// AssignPropertiesFromDiagnosticsProfileStatus populates our DiagnosticsProfile_Status from the provided source DiagnosticsProfile_Status
func (diagnosticsProfileStatus *DiagnosticsProfile_Status) AssignPropertiesFromDiagnosticsProfileStatus(source *v1alpha1api20201201storage.DiagnosticsProfile_Status) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics_Status
		err := bootDiagnostic.AssignPropertiesFromBootDiagnosticsStatus(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesFromBootDiagnosticsStatus()")
		}
		diagnosticsProfileStatus.BootDiagnostics = &bootDiagnostic
	} else {
		diagnosticsProfileStatus.BootDiagnostics = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiagnosticsProfileStatus populates the provided destination DiagnosticsProfile_Status from our DiagnosticsProfile_Status
func (diagnosticsProfileStatus *DiagnosticsProfile_Status) AssignPropertiesToDiagnosticsProfileStatus(destination *v1alpha1api20201201storage.DiagnosticsProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BootDiagnostics
	if diagnosticsProfileStatus.BootDiagnostics != nil {
		var bootDiagnostic v1alpha1api20201201storage.BootDiagnostics_Status
		err := (*diagnosticsProfileStatus.BootDiagnostics).AssignPropertiesToBootDiagnosticsStatus(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesToBootDiagnosticsStatus()")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EvictionPolicy_Status string

const (
	EvictionPolicy_StatusDeallocate = EvictionPolicy_Status("Deallocate")
	EvictionPolicy_StatusDelete     = EvictionPolicy_Status("Delete")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ExtendedLocation
type ExtendedLocation struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (extendedLocation *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if extendedLocation == nil {
		return nil, nil
	}
	var result ExtendedLocationARM

	// Set property ‘Name’:
	if extendedLocation.Name != nil {
		name := *extendedLocation.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if extendedLocation.Type != nil {
		typeVar := *extendedLocation.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocation *ExtendedLocation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocation *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocationARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extendedLocation.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extendedLocation.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesFromExtendedLocation(source *v1alpha1api20201201storage.ExtendedLocation) error {

	// Name
	extendedLocation.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType(*source.Type)
		extendedLocation.Type = &typeVar
	} else {
		extendedLocation.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesToExtendedLocation(destination *v1alpha1api20201201storage.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(extendedLocation.Name)

	// Type
	if extendedLocation.Type != nil {
		typeVar := string(*extendedLocation.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExtendedLocation_Status struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType_Status `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocationStatus *ExtendedLocation_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocationStatus *ExtendedLocation_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extendedLocationStatus.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extendedLocationStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocationStatus populates our ExtendedLocation_Status from the provided source ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesFromExtendedLocationStatus(source *v1alpha1api20201201storage.ExtendedLocation_Status) error {

	// Name
	extendedLocationStatus.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_Status(*source.Type)
		extendedLocationStatus.Type = &typeVar
	} else {
		extendedLocationStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocationStatus populates the provided destination ExtendedLocation_Status from our ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesToExtendedLocationStatus(destination *v1alpha1api20201201storage.ExtendedLocation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(extendedLocationStatus.Name)

	// Type
	if extendedLocationStatus.Type != nil {
		typeVar := string(*extendedLocationStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/HardwareProfile
type HardwareProfile struct {
	//VmSize: Specifies the size of the virtual machine.
	//The enum data type is currently deprecated and will be removed by December 23rd
	//2023.
	//Recommended way to get the list of available sizes is using these APIs:
	//[List all available virtual machine sizes in an availability
	//set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes)
	//[List all available virtual machine sizes in a region](
	//https://docs.microsoft.com/en-us/rest/api/compute/resourceskus/list)
	//[List all available virtual machine sizes for
	//resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes).
	//For more information about virtual machine sizes, see [Sizes for virtual
	//machines](https://docs.microsoft.com/en-us/azure/virtual-machines/sizes).
	//The available VM sizes depend on region and availability set.
	VmSize *HardwareProfileVmSize `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &HardwareProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (hardwareProfile *HardwareProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if hardwareProfile == nil {
		return nil, nil
	}
	var result HardwareProfileARM

	// Set property ‘VmSize’:
	if hardwareProfile.VmSize != nil {
		vmSize := *hardwareProfile.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (hardwareProfile *HardwareProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HardwareProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (hardwareProfile *HardwareProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HardwareProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HardwareProfileARM, got %T", armInput)
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		hardwareProfile.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignPropertiesFromHardwareProfile populates our HardwareProfile from the provided source HardwareProfile
func (hardwareProfile *HardwareProfile) AssignPropertiesFromHardwareProfile(source *v1alpha1api20201201storage.HardwareProfile) error {

	// VmSize
	if source.VmSize != nil {
		vmSize := HardwareProfileVmSize(*source.VmSize)
		hardwareProfile.VmSize = &vmSize
	} else {
		hardwareProfile.VmSize = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHardwareProfile populates the provided destination HardwareProfile from our HardwareProfile
func (hardwareProfile *HardwareProfile) AssignPropertiesToHardwareProfile(destination *v1alpha1api20201201storage.HardwareProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmSize
	if hardwareProfile.VmSize != nil {
		vmSize := string(*hardwareProfile.VmSize)
		destination.VmSize = &vmSize
	} else {
		destination.VmSize = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HardwareProfile_Status struct {
	//VmSize: Specifies the size of the virtual machine.
	//The enum data type is currently deprecated and will be removed by December 23rd
	//2023.
	//Recommended way to get the list of available sizes is using these APIs:
	//[List all available virtual machine sizes in an availability
	//set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes)
	//[List all available virtual machine sizes in a region](
	//https://docs.microsoft.com/en-us/rest/api/compute/resourceskus/list)
	//[List all available virtual machine sizes for
	//resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes).
	//For more information about virtual machine sizes, see [Sizes for virtual
	//machines](https://docs.microsoft.com/en-us/azure/virtual-machines/sizes).
	//The available VM sizes depend on region and availability set.
	VmSize *HardwareProfileStatusVmSize `json:"vmSize,omitempty"`
}

var _ genruntime.FromARMConverter = &HardwareProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (hardwareProfileStatus *HardwareProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HardwareProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (hardwareProfileStatus *HardwareProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HardwareProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HardwareProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		hardwareProfileStatus.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignPropertiesFromHardwareProfileStatus populates our HardwareProfile_Status from the provided source HardwareProfile_Status
func (hardwareProfileStatus *HardwareProfile_Status) AssignPropertiesFromHardwareProfileStatus(source *v1alpha1api20201201storage.HardwareProfile_Status) error {

	// VmSize
	if source.VmSize != nil {
		vmSize := HardwareProfileStatusVmSize(*source.VmSize)
		hardwareProfileStatus.VmSize = &vmSize
	} else {
		hardwareProfileStatus.VmSize = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHardwareProfileStatus populates the provided destination HardwareProfile_Status from our HardwareProfile_Status
func (hardwareProfileStatus *HardwareProfile_Status) AssignPropertiesToHardwareProfileStatus(destination *v1alpha1api20201201storage.HardwareProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmSize
	if hardwareProfileStatus.VmSize != nil {
		vmSize := string(*hardwareProfileStatus.VmSize)
		destination.VmSize = &vmSize
	} else {
		destination.VmSize = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkProfile_Status struct {
	//NetworkInterfaces: Specifies the list of resource Ids for the network interfaces
	//associated with the virtual machine.
	NetworkInterfaces []NetworkInterfaceReference_Status `json:"networkInterfaces,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networkProfileStatus *NetworkProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networkProfileStatus *NetworkProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘NetworkInterfaces’:
	for _, item := range typedInput.NetworkInterfaces {
		var item1 NetworkInterfaceReference_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		networkProfileStatus.NetworkInterfaces = append(networkProfileStatus.NetworkInterfaces, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkProfileStatus populates our NetworkProfile_Status from the provided source NetworkProfile_Status
func (networkProfileStatus *NetworkProfile_Status) AssignPropertiesFromNetworkProfileStatus(source *v1alpha1api20201201storage.NetworkProfile_Status) error {

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference_Status, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference_Status
			err := networkInterface.AssignPropertiesFromNetworkInterfaceReferenceStatus(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "populating NetworkInterfaces from NetworkInterfaces, calling AssignPropertiesFromNetworkInterfaceReferenceStatus()")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		networkProfileStatus.NetworkInterfaces = networkInterfaceList
	} else {
		networkProfileStatus.NetworkInterfaces = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkProfileStatus populates the provided destination NetworkProfile_Status from our NetworkProfile_Status
func (networkProfileStatus *NetworkProfile_Status) AssignPropertiesToNetworkProfileStatus(destination *v1alpha1api20201201storage.NetworkProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NetworkInterfaces
	if networkProfileStatus.NetworkInterfaces != nil {
		networkInterfaceList := make([]v1alpha1api20201201storage.NetworkInterfaceReference_Status, len(networkProfileStatus.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range networkProfileStatus.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface v1alpha1api20201201storage.NetworkInterfaceReference_Status
			err := networkInterfaceItem.AssignPropertiesToNetworkInterfaceReferenceStatus(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "populating NetworkInterfaces from NetworkInterfaces, calling AssignPropertiesToNetworkInterfaceReferenceStatus()")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/OSProfile
type OSProfile struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length (Windows): 8 characters
	//Minimum-length (Linux): 6 characters
	//Max-length (Windows): 123 characters
	//Max-length (Linux): 72 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	//For resetting the password, see [How to reset the Remote Desktop service or its
	//login password in a Windows
	//VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)
	//For resetting root password, see [Manage users, SSH, and check or repair disks
	//on Azure Linux VMs using the VMAccess
	//Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
	AdminPassword *string `json:"adminPassword,omitempty"`

	//AdminUsername: Specifies the name of the administrator account.
	//This property cannot be updated after the VM is created.
	//Windows-only restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length (Linux): 1  character
	//Max-length (Linux): 64 characters
	//Max-length (Windows): 20 characters
	//<li> For root access to the Linux VM, see [Using root privileges on Linux
	//virtual machines in
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//<li> For a list of built-in system users on Linux that should not be used in
	//this field, see [Selecting User Names for Linux on
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	AdminUsername *string `json:"adminUsername,omitempty"`

	//AllowExtensionOperations: Specifies whether extension operations should be
	//allowed on the virtual machine.
	//This may only be set to False when no extensions are present on the virtual
	//machine.
	AllowExtensionOperations *bool `json:"allowExtensionOperations,omitempty"`

	//ComputerName: Specifies the host OS name of the virtual machine.
	//This name cannot be updated after the VM is created.
	//Max-length (Windows): 15 characters
	//Max-length (Linux): 64 characters.
	//For naming conventions and restrictions see [Azure infrastructure services
	//implementation
	//guidelines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-infrastructure-subscription-accounts-guidelines?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#1-naming-conventions).
	ComputerName *string `json:"computerName,omitempty"`

	//CustomData: Specifies a base-64 encoded string of custom data. The base-64
	//encoded string is decoded to a binary array that is saved as a file on the
	//Virtual Machine. The maximum length of the binary array is 65535 bytes.
	//Note: Do not pass any secrets or passwords in customData property
	//This property cannot be updated after the VM is created.
	//customData is passed to the VM to be saved as a file, for more information see
	//[Custom Data on Azure
	//VMs](https://azure.microsoft.com/en-us/blog/custom-data-and-cloud-init-on-windows-azure/)
	//For using cloud-init for your Linux VM, see [Using cloud-init to customize a
	//Linux VM during
	//creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	CustomData *string `json:"customData,omitempty"`

	//LinuxConfiguration: Specifies the Linux operating system settings on the virtual
	//machine.
	//For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//For running non-endorsed distributions, see [Information for Non-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	LinuxConfiguration *LinuxConfiguration `json:"linuxConfiguration,omitempty"`

	//RequireGuestProvisionSignal: Specifies whether the guest provision signal is
	//required to infer provision success of the virtual machine.  Note: This property
	//is for private testing only, and all customers must not set the property to
	//false.
	RequireGuestProvisionSignal *bool `json:"requireGuestProvisionSignal,omitempty"`

	//Secrets: Specifies set of certificates that should be installed onto the virtual
	//machine.
	Secrets []VaultSecretGroup `json:"secrets,omitempty"`

	//WindowsConfiguration: Specifies Windows operating system settings on the virtual
	//machine.
	WindowsConfiguration *WindowsConfiguration `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &OSProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (osProfile *OSProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if osProfile == nil {
		return nil, nil
	}
	var result OSProfileARM

	// Set property ‘AdminPassword’:
	if osProfile.AdminPassword != nil {
		adminPassword := *osProfile.AdminPassword
		result.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if osProfile.AdminUsername != nil {
		adminUsername := *osProfile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property ‘AllowExtensionOperations’:
	if osProfile.AllowExtensionOperations != nil {
		allowExtensionOperations := *osProfile.AllowExtensionOperations
		result.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property ‘ComputerName’:
	if osProfile.ComputerName != nil {
		computerName := *osProfile.ComputerName
		result.ComputerName = &computerName
	}

	// Set property ‘CustomData’:
	if osProfile.CustomData != nil {
		customData := *osProfile.CustomData
		result.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if osProfile.LinuxConfiguration != nil {
		linuxConfigurationARM, err := (*osProfile.LinuxConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxConfiguration := linuxConfigurationARM.(LinuxConfigurationARM)
		result.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘RequireGuestProvisionSignal’:
	if osProfile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *osProfile.RequireGuestProvisionSignal
		result.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property ‘Secrets’:
	for _, item := range osProfile.Secrets {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, itemARM.(VaultSecretGroupARM))
	}

	// Set property ‘WindowsConfiguration’:
	if osProfile.WindowsConfiguration != nil {
		windowsConfigurationARM, err := (*osProfile.WindowsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsConfiguration := windowsConfigurationARM.(WindowsConfigurationARM)
		result.WindowsConfiguration = &windowsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (osProfile *OSProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OSProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (osProfile *OSProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OSProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OSProfileARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		osProfile.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		osProfile.AdminUsername = &adminUsername
	}

	// Set property ‘AllowExtensionOperations’:
	if typedInput.AllowExtensionOperations != nil {
		allowExtensionOperations := *typedInput.AllowExtensionOperations
		osProfile.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property ‘ComputerName’:
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		osProfile.ComputerName = &computerName
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		osProfile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		osProfile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘RequireGuestProvisionSignal’:
	if typedInput.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *typedInput.RequireGuestProvisionSignal
		osProfile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		osProfile.Secrets = append(osProfile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		osProfile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromOSProfile populates our OSProfile from the provided source OSProfile
func (osProfile *OSProfile) AssignPropertiesFromOSProfile(source *v1alpha1api20201201storage.OSProfile) error {

	// AdminPassword
	osProfile.AdminPassword = genruntime.ClonePointerToString(source.AdminPassword)

	// AdminUsername
	osProfile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		osProfile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		osProfile.AllowExtensionOperations = nil
	}

	// ComputerName
	osProfile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	osProfile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignPropertiesFromLinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LinuxConfiguration from LinuxConfiguration, calling AssignPropertiesFromLinuxConfiguration()")
		}
		osProfile.LinuxConfiguration = &linuxConfiguration
	} else {
		osProfile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		osProfile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		osProfile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignPropertiesFromVaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "populating Secrets from Secrets, calling AssignPropertiesFromVaultSecretGroup()")
			}
			secretList[secretIndex] = secret
		}
		osProfile.Secrets = secretList
	} else {
		osProfile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignPropertiesFromWindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating WindowsConfiguration from WindowsConfiguration, calling AssignPropertiesFromWindowsConfiguration()")
		}
		osProfile.WindowsConfiguration = &windowsConfiguration
	} else {
		osProfile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSProfile populates the provided destination OSProfile from our OSProfile
func (osProfile *OSProfile) AssignPropertiesToOSProfile(destination *v1alpha1api20201201storage.OSProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	destination.AdminPassword = genruntime.ClonePointerToString(osProfile.AdminPassword)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(osProfile.AdminUsername)

	// AllowExtensionOperations
	if osProfile.AllowExtensionOperations != nil {
		allowExtensionOperation := *osProfile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(osProfile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(osProfile.CustomData)

	// LinuxConfiguration
	if osProfile.LinuxConfiguration != nil {
		var linuxConfiguration v1alpha1api20201201storage.LinuxConfiguration
		err := (*osProfile.LinuxConfiguration).AssignPropertiesToLinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LinuxConfiguration from LinuxConfiguration, calling AssignPropertiesToLinuxConfiguration()")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if osProfile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *osProfile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if osProfile.Secrets != nil {
		secretList := make([]v1alpha1api20201201storage.VaultSecretGroup, len(osProfile.Secrets))
		for secretIndex, secretItem := range osProfile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v1alpha1api20201201storage.VaultSecretGroup
			err := secretItem.AssignPropertiesToVaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "populating Secrets from Secrets, calling AssignPropertiesToVaultSecretGroup()")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if osProfile.WindowsConfiguration != nil {
		var windowsConfiguration v1alpha1api20201201storage.WindowsConfiguration
		err := (*osProfile.WindowsConfiguration).AssignPropertiesToWindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating WindowsConfiguration from WindowsConfiguration, calling AssignPropertiesToWindowsConfiguration()")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OSProfile_Status struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length (Windows): 8 characters
	//Minimum-length (Linux): 6 characters
	//Max-length (Windows): 123 characters
	//Max-length (Linux): 72 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	//For resetting the password, see [How to reset the Remote Desktop service or its
	//login password in a Windows
	//VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)
	//For resetting root password, see [Manage users, SSH, and check or repair disks
	//on Azure Linux VMs using the VMAccess
	//Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
	AdminPassword *string `json:"adminPassword,omitempty"`

	//AdminUsername: Specifies the name of the administrator account.
	//This property cannot be updated after the VM is created.
	//Windows-only restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length (Linux): 1  character
	//Max-length (Linux): 64 characters
	//Max-length (Windows): 20 characters
	//<li> For root access to the Linux VM, see [Using root privileges on Linux
	//virtual machines in
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//<li> For a list of built-in system users on Linux that should not be used in
	//this field, see [Selecting User Names for Linux on
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	AdminUsername *string `json:"adminUsername,omitempty"`

	//AllowExtensionOperations: Specifies whether extension operations should be
	//allowed on the virtual machine.
	//This may only be set to False when no extensions are present on the virtual
	//machine.
	AllowExtensionOperations *bool `json:"allowExtensionOperations,omitempty"`

	//ComputerName: Specifies the host OS name of the virtual machine.
	//This name cannot be updated after the VM is created.
	//Max-length (Windows): 15 characters
	//Max-length (Linux): 64 characters.
	//For naming conventions and restrictions see [Azure infrastructure services
	//implementation
	//guidelines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-infrastructure-subscription-accounts-guidelines?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#1-naming-conventions).
	ComputerName *string `json:"computerName,omitempty"`

	//CustomData: Specifies a base-64 encoded string of custom data. The base-64
	//encoded string is decoded to a binary array that is saved as a file on the
	//Virtual Machine. The maximum length of the binary array is 65535 bytes.
	//Note: Do not pass any secrets or passwords in customData property
	//This property cannot be updated after the VM is created.
	//customData is passed to the VM to be saved as a file, for more information see
	//[Custom Data on Azure
	//VMs](https://azure.microsoft.com/en-us/blog/custom-data-and-cloud-init-on-windows-azure/)
	//For using cloud-init for your Linux VM, see [Using cloud-init to customize a
	//Linux VM during
	//creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	CustomData *string `json:"customData,omitempty"`

	//LinuxConfiguration: Specifies the Linux operating system settings on the virtual
	//machine.
	//For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//For running non-endorsed distributions, see [Information for Non-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	LinuxConfiguration *LinuxConfiguration_Status `json:"linuxConfiguration,omitempty"`

	//RequireGuestProvisionSignal: Specifies whether the guest provision signal is
	//required to infer provision success of the virtual machine.  Note: This property
	//is for private testing only, and all customers must not set the property to
	//false.
	RequireGuestProvisionSignal *bool `json:"requireGuestProvisionSignal,omitempty"`

	//Secrets: Specifies set of certificates that should be installed onto the virtual
	//machine.
	Secrets []VaultSecretGroup_Status `json:"secrets,omitempty"`

	//WindowsConfiguration: Specifies Windows operating system settings on the virtual
	//machine.
	WindowsConfiguration *WindowsConfiguration_Status `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &OSProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (osProfileStatus *OSProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OSProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (osProfileStatus *OSProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OSProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OSProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		osProfileStatus.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		osProfileStatus.AdminUsername = &adminUsername
	}

	// Set property ‘AllowExtensionOperations’:
	if typedInput.AllowExtensionOperations != nil {
		allowExtensionOperations := *typedInput.AllowExtensionOperations
		osProfileStatus.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property ‘ComputerName’:
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		osProfileStatus.ComputerName = &computerName
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		osProfileStatus.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration_Status
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		osProfileStatus.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘RequireGuestProvisionSignal’:
	if typedInput.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *typedInput.RequireGuestProvisionSignal
		osProfileStatus.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		osProfileStatus.Secrets = append(osProfileStatus.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration_Status
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		osProfileStatus.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromOSProfileStatus populates our OSProfile_Status from the provided source OSProfile_Status
func (osProfileStatus *OSProfile_Status) AssignPropertiesFromOSProfileStatus(source *v1alpha1api20201201storage.OSProfile_Status) error {

	// AdminPassword
	osProfileStatus.AdminPassword = genruntime.ClonePointerToString(source.AdminPassword)

	// AdminUsername
	osProfileStatus.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		osProfileStatus.AllowExtensionOperations = &allowExtensionOperation
	} else {
		osProfileStatus.AllowExtensionOperations = nil
	}

	// ComputerName
	osProfileStatus.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	osProfileStatus.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_Status
		err := linuxConfiguration.AssignPropertiesFromLinuxConfigurationStatus(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LinuxConfiguration from LinuxConfiguration, calling AssignPropertiesFromLinuxConfigurationStatus()")
		}
		osProfileStatus.LinuxConfiguration = &linuxConfiguration
	} else {
		osProfileStatus.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		osProfileStatus.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		osProfileStatus.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_Status, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_Status
			err := secret.AssignPropertiesFromVaultSecretGroupStatus(&secretItem)
			if err != nil {
				return errors.Wrap(err, "populating Secrets from Secrets, calling AssignPropertiesFromVaultSecretGroupStatus()")
			}
			secretList[secretIndex] = secret
		}
		osProfileStatus.Secrets = secretList
	} else {
		osProfileStatus.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_Status
		err := windowsConfiguration.AssignPropertiesFromWindowsConfigurationStatus(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating WindowsConfiguration from WindowsConfiguration, calling AssignPropertiesFromWindowsConfigurationStatus()")
		}
		osProfileStatus.WindowsConfiguration = &windowsConfiguration
	} else {
		osProfileStatus.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSProfileStatus populates the provided destination OSProfile_Status from our OSProfile_Status
func (osProfileStatus *OSProfile_Status) AssignPropertiesToOSProfileStatus(destination *v1alpha1api20201201storage.OSProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	destination.AdminPassword = genruntime.ClonePointerToString(osProfileStatus.AdminPassword)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(osProfileStatus.AdminUsername)

	// AllowExtensionOperations
	if osProfileStatus.AllowExtensionOperations != nil {
		allowExtensionOperation := *osProfileStatus.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(osProfileStatus.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(osProfileStatus.CustomData)

	// LinuxConfiguration
	if osProfileStatus.LinuxConfiguration != nil {
		var linuxConfiguration v1alpha1api20201201storage.LinuxConfiguration_Status
		err := (*osProfileStatus.LinuxConfiguration).AssignPropertiesToLinuxConfigurationStatus(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LinuxConfiguration from LinuxConfiguration, calling AssignPropertiesToLinuxConfigurationStatus()")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if osProfileStatus.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *osProfileStatus.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if osProfileStatus.Secrets != nil {
		secretList := make([]v1alpha1api20201201storage.VaultSecretGroup_Status, len(osProfileStatus.Secrets))
		for secretIndex, secretItem := range osProfileStatus.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v1alpha1api20201201storage.VaultSecretGroup_Status
			err := secretItem.AssignPropertiesToVaultSecretGroupStatus(&secret)
			if err != nil {
				return errors.Wrap(err, "populating Secrets from Secrets, calling AssignPropertiesToVaultSecretGroupStatus()")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if osProfileStatus.WindowsConfiguration != nil {
		var windowsConfiguration v1alpha1api20201201storage.WindowsConfiguration_Status
		err := (*osProfileStatus.WindowsConfiguration).AssignPropertiesToWindowsConfigurationStatus(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating WindowsConfiguration from WindowsConfiguration, calling AssignPropertiesToWindowsConfigurationStatus()")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/Plan
type Plan struct {
	//Name: The plan ID.
	Name *string `json:"name,omitempty"`

	//Product: Specifies the product of the image from the marketplace. This is the
	//same value as Offer under the imageReference element.
	Product *string `json:"product,omitempty"`

	//PromotionCode: The promotion code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	//Publisher: The publisher ID.
	Publisher *string `json:"publisher,omitempty"`
}

var _ genruntime.ARMTransformer = &Plan{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (plan *Plan) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if plan == nil {
		return nil, nil
	}
	var result PlanARM

	// Set property ‘Name’:
	if plan.Name != nil {
		name := *plan.Name
		result.Name = &name
	}

	// Set property ‘Product’:
	if plan.Product != nil {
		product := *plan.Product
		result.Product = &product
	}

	// Set property ‘PromotionCode’:
	if plan.PromotionCode != nil {
		promotionCode := *plan.PromotionCode
		result.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if plan.Publisher != nil {
		publisher := *plan.Publisher
		result.Publisher = &publisher
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (plan *Plan) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PlanARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (plan *Plan) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PlanARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PlanARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		plan.Name = &name
	}

	// Set property ‘Product’:
	if typedInput.Product != nil {
		product := *typedInput.Product
		plan.Product = &product
	}

	// Set property ‘PromotionCode’:
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		plan.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		plan.Publisher = &publisher
	}

	// No error
	return nil
}

// AssignPropertiesFromPlan populates our Plan from the provided source Plan
func (plan *Plan) AssignPropertiesFromPlan(source *v1alpha1api20201201storage.Plan) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// No error
	return nil
}

// AssignPropertiesToPlan populates the provided destination Plan from our Plan
func (plan *Plan) AssignPropertiesToPlan(destination *v1alpha1api20201201storage.Plan) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Plan_Status struct {
	//Name: The plan ID.
	Name *string `json:"name,omitempty"`

	//Product: Specifies the product of the image from the marketplace. This is the
	//same value as Offer under the imageReference element.
	Product *string `json:"product,omitempty"`

	//PromotionCode: The promotion code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	//Publisher: The publisher ID.
	Publisher *string `json:"publisher,omitempty"`
}

var _ genruntime.FromARMConverter = &Plan_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (planStatus *Plan_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Plan_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (planStatus *Plan_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Plan_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Plan_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		planStatus.Name = &name
	}

	// Set property ‘Product’:
	if typedInput.Product != nil {
		product := *typedInput.Product
		planStatus.Product = &product
	}

	// Set property ‘PromotionCode’:
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		planStatus.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		planStatus.Publisher = &publisher
	}

	// No error
	return nil
}

// AssignPropertiesFromPlanStatus populates our Plan_Status from the provided source Plan_Status
func (planStatus *Plan_Status) AssignPropertiesFromPlanStatus(source *v1alpha1api20201201storage.Plan_Status) error {

	// Name
	planStatus.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	planStatus.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	planStatus.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	planStatus.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// No error
	return nil
}

// AssignPropertiesToPlanStatus populates the provided destination Plan_Status from our Plan_Status
func (planStatus *Plan_Status) AssignPropertiesToPlanStatus(destination *v1alpha1api20201201storage.Plan_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(planStatus.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(planStatus.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(planStatus.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(planStatus.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Priority_Status string

const (
	Priority_StatusLow     = Priority_Status("Low")
	Priority_StatusRegular = Priority_Status("Regular")
	Priority_StatusSpot    = Priority_Status("Spot")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SecurityProfile
type SecurityProfile struct {
	//EncryptionAtHost: This property can be used by user in the request to enable or
	//disable the Host Encryption for the virtual machine or virtual machine scale
	//set. This will enable the encryption for all the disks including Resource/Temp
	//disk at host itself.
	//Default: The Encryption at host will be disabled unless this property is set to
	//true for the resource.
	EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`

	//SecurityType: Specifies the SecurityType of the virtual machine. It is set as
	//TrustedLaunch to enable UefiSettings.
	//Default: UefiSettings will not be enabled unless this property is set as
	//TrustedLaunch.
	SecurityType *SecurityProfileSecurityType `json:"securityType,omitempty"`

	//UefiSettings: Specifies the security settings like secure boot and vTPM used
	//while creating the virtual machine.
	//Minimum api-version: 2020-12-01
	UefiSettings *UefiSettings `json:"uefiSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &SecurityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (securityProfile *SecurityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if securityProfile == nil {
		return nil, nil
	}
	var result SecurityProfileARM

	// Set property ‘EncryptionAtHost’:
	if securityProfile.EncryptionAtHost != nil {
		encryptionAtHost := *securityProfile.EncryptionAtHost
		result.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if securityProfile.SecurityType != nil {
		securityType := *securityProfile.SecurityType
		result.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if securityProfile.UefiSettings != nil {
		uefiSettingsARM, err := (*securityProfile.UefiSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		uefiSettings := uefiSettingsARM.(UefiSettingsARM)
		result.UefiSettings = &uefiSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (securityProfile *SecurityProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecurityProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (securityProfile *SecurityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecurityProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecurityProfileARM, got %T", armInput)
	}

	// Set property ‘EncryptionAtHost’:
	if typedInput.EncryptionAtHost != nil {
		encryptionAtHost := *typedInput.EncryptionAtHost
		securityProfile.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if typedInput.SecurityType != nil {
		securityType := *typedInput.SecurityType
		securityProfile.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if typedInput.UefiSettings != nil {
		var uefiSettings1 UefiSettings
		err := uefiSettings1.PopulateFromARM(owner, *typedInput.UefiSettings)
		if err != nil {
			return err
		}
		uefiSettings := uefiSettings1
		securityProfile.UefiSettings = &uefiSettings
	}

	// No error
	return nil
}

// AssignPropertiesFromSecurityProfile populates our SecurityProfile from the provided source SecurityProfile
func (securityProfile *SecurityProfile) AssignPropertiesFromSecurityProfile(source *v1alpha1api20201201storage.SecurityProfile) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		securityProfile.EncryptionAtHost = &encryptionAtHost
	} else {
		securityProfile.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := SecurityProfileSecurityType(*source.SecurityType)
		securityProfile.SecurityType = &securityType
	} else {
		securityProfile.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings
		err := uefiSetting.AssignPropertiesFromUefiSettings(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "populating UefiSettings from UefiSettings, calling AssignPropertiesFromUefiSettings()")
		}
		securityProfile.UefiSettings = &uefiSetting
	} else {
		securityProfile.UefiSettings = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityProfile populates the provided destination SecurityProfile from our SecurityProfile
func (securityProfile *SecurityProfile) AssignPropertiesToSecurityProfile(destination *v1alpha1api20201201storage.SecurityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionAtHost
	if securityProfile.EncryptionAtHost != nil {
		encryptionAtHost := *securityProfile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	if securityProfile.SecurityType != nil {
		securityType := string(*securityProfile.SecurityType)
		destination.SecurityType = &securityType
	} else {
		destination.SecurityType = nil
	}

	// UefiSettings
	if securityProfile.UefiSettings != nil {
		var uefiSetting v1alpha1api20201201storage.UefiSettings
		err := (*securityProfile.UefiSettings).AssignPropertiesToUefiSettings(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "populating UefiSettings from UefiSettings, calling AssignPropertiesToUefiSettings()")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SecurityProfile_Status struct {
	//EncryptionAtHost: This property can be used by user in the request to enable or
	//disable the Host Encryption for the virtual machine or virtual machine scale
	//set. This will enable the encryption for all the disks including Resource/Temp
	//disk at host itself.
	//Default: The Encryption at host will be disabled unless this property is set to
	//true for the resource.
	EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`

	//SecurityType: Specifies the SecurityType of the virtual machine. It is set as
	//TrustedLaunch to enable UefiSettings.
	//Default: UefiSettings will not be enabled unless this property is set as
	//TrustedLaunch.
	SecurityType *SecurityProfileStatusSecurityType `json:"securityType,omitempty"`

	//UefiSettings: Specifies the security settings like secure boot and vTPM used
	//while creating the virtual machine.
	//Minimum api-version: 2020-12-01
	UefiSettings *UefiSettings_Status `json:"uefiSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &SecurityProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (securityProfileStatus *SecurityProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecurityProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (securityProfileStatus *SecurityProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecurityProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecurityProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘EncryptionAtHost’:
	if typedInput.EncryptionAtHost != nil {
		encryptionAtHost := *typedInput.EncryptionAtHost
		securityProfileStatus.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if typedInput.SecurityType != nil {
		securityType := *typedInput.SecurityType
		securityProfileStatus.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if typedInput.UefiSettings != nil {
		var uefiSettings1 UefiSettings_Status
		err := uefiSettings1.PopulateFromARM(owner, *typedInput.UefiSettings)
		if err != nil {
			return err
		}
		uefiSettings := uefiSettings1
		securityProfileStatus.UefiSettings = &uefiSettings
	}

	// No error
	return nil
}

// AssignPropertiesFromSecurityProfileStatus populates our SecurityProfile_Status from the provided source SecurityProfile_Status
func (securityProfileStatus *SecurityProfile_Status) AssignPropertiesFromSecurityProfileStatus(source *v1alpha1api20201201storage.SecurityProfile_Status) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		securityProfileStatus.EncryptionAtHost = &encryptionAtHost
	} else {
		securityProfileStatus.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := SecurityProfileStatusSecurityType(*source.SecurityType)
		securityProfileStatus.SecurityType = &securityType
	} else {
		securityProfileStatus.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings_Status
		err := uefiSetting.AssignPropertiesFromUefiSettingsStatus(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "populating UefiSettings from UefiSettings, calling AssignPropertiesFromUefiSettingsStatus()")
		}
		securityProfileStatus.UefiSettings = &uefiSetting
	} else {
		securityProfileStatus.UefiSettings = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityProfileStatus populates the provided destination SecurityProfile_Status from our SecurityProfile_Status
func (securityProfileStatus *SecurityProfile_Status) AssignPropertiesToSecurityProfileStatus(destination *v1alpha1api20201201storage.SecurityProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionAtHost
	if securityProfileStatus.EncryptionAtHost != nil {
		encryptionAtHost := *securityProfileStatus.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	if securityProfileStatus.SecurityType != nil {
		securityType := string(*securityProfileStatus.SecurityType)
		destination.SecurityType = &securityType
	} else {
		destination.SecurityType = nil
	}

	// UefiSettings
	if securityProfileStatus.UefiSettings != nil {
		var uefiSetting v1alpha1api20201201storage.UefiSettings_Status
		err := (*securityProfileStatus.UefiSettings).AssignPropertiesToUefiSettingsStatus(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "populating UefiSettings from UefiSettings, calling AssignPropertiesToUefiSettingsStatus()")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/StorageProfile
type StorageProfile struct {
	//DataDisks: Specifies the parameters that are used to add a data disk to a
	//virtual machine.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	DataDisks []DataDisk `json:"dataDisks,omitempty"`

	//ImageReference: Specifies information about the image to use. You can specify
	//information about platform images, marketplace images, or virtual machine
	//images. This element is required when you want to use a platform image,
	//marketplace image, or virtual machine image, but is not used in other creation
	//operations. NOTE: Image reference publisher and offer can only be set when you
	//create the scale set.
	ImageReference *ImageReference `json:"imageReference,omitempty"`

	//OsDisk: Specifies information about the operating system disk used by the
	//virtual machine.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	OsDisk *OSDisk `json:"osDisk,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (storageProfile *StorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if storageProfile == nil {
		return nil, nil
	}
	var result StorageProfileARM

	// Set property ‘DataDisks’:
	for _, item := range storageProfile.DataDisks {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DataDisks = append(result.DataDisks, itemARM.(DataDiskARM))
	}

	// Set property ‘ImageReference’:
	if storageProfile.ImageReference != nil {
		imageReferenceARM, err := (*storageProfile.ImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageReference := imageReferenceARM.(ImageReferenceARM)
		result.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if storageProfile.OsDisk != nil {
		osDiskARM, err := (*storageProfile.OsDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osDisk := osDiskARM.(OSDiskARM)
		result.OsDisk = &osDisk
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (storageProfile *StorageProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (storageProfile *StorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageProfileARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 DataDisk
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		storageProfile.DataDisks = append(storageProfile.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		storageProfile.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 OSDisk
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		storageProfile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromStorageProfile populates our StorageProfile from the provided source StorageProfile
func (storageProfile *StorageProfile) AssignPropertiesFromStorageProfile(source *v1alpha1api20201201storage.StorageProfile) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk
			err := dataDisk.AssignPropertiesFromDataDisk(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "populating DataDisks from DataDisks, calling AssignPropertiesFromDataDisk()")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		storageProfile.DataDisks = dataDiskList
	} else {
		storageProfile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignPropertiesFromImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesFromImageReference()")
		}
		storageProfile.ImageReference = &imageReference
	} else {
		storageProfile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk
		err := osDisk.AssignPropertiesFromOSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "populating OsDisk from OsDisk, calling AssignPropertiesFromOSDisk()")
		}
		storageProfile.OsDisk = &osDisk
	} else {
		storageProfile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToStorageProfile populates the provided destination StorageProfile from our StorageProfile
func (storageProfile *StorageProfile) AssignPropertiesToStorageProfile(destination *v1alpha1api20201201storage.StorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if storageProfile.DataDisks != nil {
		dataDiskList := make([]v1alpha1api20201201storage.DataDisk, len(storageProfile.DataDisks))
		for dataDiskIndex, dataDiskItem := range storageProfile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v1alpha1api20201201storage.DataDisk
			err := dataDiskItem.AssignPropertiesToDataDisk(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "populating DataDisks from DataDisks, calling AssignPropertiesToDataDisk()")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if storageProfile.ImageReference != nil {
		var imageReference v1alpha1api20201201storage.ImageReference
		err := (*storageProfile.ImageReference).AssignPropertiesToImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesToImageReference()")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if storageProfile.OsDisk != nil {
		var osDisk v1alpha1api20201201storage.OSDisk
		err := (*storageProfile.OsDisk).AssignPropertiesToOSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "populating OsDisk from OsDisk, calling AssignPropertiesToOSDisk()")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type StorageProfile_Status struct {
	//DataDisks: Specifies the parameters that are used to add a data disk to a
	//virtual machine.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	DataDisks []DataDisk_Status `json:"dataDisks,omitempty"`

	//ImageReference: Specifies information about the image to use. You can specify
	//information about platform images, marketplace images, or virtual machine
	//images. This element is required when you want to use a platform image,
	//marketplace image, or virtual machine image, but is not used in other creation
	//operations.
	ImageReference *ImageReference_Status `json:"imageReference,omitempty"`

	//OsDisk: Specifies information about the operating system disk used by the
	//virtual machine.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	OsDisk *OSDisk_Status `json:"osDisk,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (storageProfileStatus *StorageProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (storageProfileStatus *StorageProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 DataDisk_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		storageProfileStatus.DataDisks = append(storageProfileStatus.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference_Status
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		storageProfileStatus.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 OSDisk_Status
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		storageProfileStatus.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromStorageProfileStatus populates our StorageProfile_Status from the provided source StorageProfile_Status
func (storageProfileStatus *StorageProfile_Status) AssignPropertiesFromStorageProfileStatus(source *v1alpha1api20201201storage.StorageProfile_Status) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk_Status, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk_Status
			err := dataDisk.AssignPropertiesFromDataDiskStatus(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "populating DataDisks from DataDisks, calling AssignPropertiesFromDataDiskStatus()")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		storageProfileStatus.DataDisks = dataDiskList
	} else {
		storageProfileStatus.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_Status
		err := imageReference.AssignPropertiesFromImageReferenceStatus(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesFromImageReferenceStatus()")
		}
		storageProfileStatus.ImageReference = &imageReference
	} else {
		storageProfileStatus.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk_Status
		err := osDisk.AssignPropertiesFromOSDiskStatus(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "populating OsDisk from OsDisk, calling AssignPropertiesFromOSDiskStatus()")
		}
		storageProfileStatus.OsDisk = &osDisk
	} else {
		storageProfileStatus.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToStorageProfileStatus populates the provided destination StorageProfile_Status from our StorageProfile_Status
func (storageProfileStatus *StorageProfile_Status) AssignPropertiesToStorageProfileStatus(destination *v1alpha1api20201201storage.StorageProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if storageProfileStatus.DataDisks != nil {
		dataDiskList := make([]v1alpha1api20201201storage.DataDisk_Status, len(storageProfileStatus.DataDisks))
		for dataDiskIndex, dataDiskItem := range storageProfileStatus.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v1alpha1api20201201storage.DataDisk_Status
			err := dataDiskItem.AssignPropertiesToDataDiskStatus(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "populating DataDisks from DataDisks, calling AssignPropertiesToDataDiskStatus()")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if storageProfileStatus.ImageReference != nil {
		var imageReference v1alpha1api20201201storage.ImageReference_Status
		err := (*storageProfileStatus.ImageReference).AssignPropertiesToImageReferenceStatus(&imageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesToImageReferenceStatus()")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if storageProfileStatus.OsDisk != nil {
		var osDisk v1alpha1api20201201storage.OSDisk_Status
		err := (*storageProfileStatus.OsDisk).AssignPropertiesToOSDiskStatus(&osDisk)
		if err != nil {
			return errors.Wrap(err, "populating OsDisk from OsDisk, calling AssignPropertiesToOSDiskStatus()")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SubResource
type SubResource struct {
	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SubResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (subResource *SubResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if subResource == nil {
		return nil, nil
	}
	var result SubResourceARM

	// Set property ‘Id’:
	if subResource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*subResource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subResource *SubResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResourceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subResource *SubResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(SubResourceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResourceARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromSubResource populates our SubResource from the provided source SubResource
func (subResource *SubResource) AssignPropertiesFromSubResource(source *v1alpha1api20201201storage.SubResource) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		subResource.Reference = &reference
	} else {
		subResource.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubResource populates the provided destination SubResource from our SubResource
func (subResource *SubResource) AssignPropertiesToSubResource(destination *v1alpha1api20201201storage.SubResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if subResource.Reference != nil {
		reference := subResource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SubResource_Status struct {
	//Id: Resource Id
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SubResource_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subResourceStatus *SubResource_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResource_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subResourceStatus *SubResource_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SubResource_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResource_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		subResourceStatus.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubResourceStatus populates our SubResource_Status from the provided source SubResource_Status
func (subResourceStatus *SubResource_Status) AssignPropertiesFromSubResourceStatus(source *v1alpha1api20201201storage.SubResource_Status) error {

	// Id
	subResourceStatus.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToSubResourceStatus populates the provided destination SubResource_Status from our SubResource_Status
func (subResourceStatus *SubResource_Status) AssignPropertiesToSubResourceStatus(destination *v1alpha1api20201201storage.SubResource_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(subResourceStatus.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineExtension_Status struct {
	//AutoUpgradeMinorVersion: Indicates whether the extension should use a newer
	//minor version if one is available at deployment time. Once deployed, however,
	//the extension will not upgrade minor versions unless redeployed, even with this
	//property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	//EnableAutomaticUpgrade: Indicates whether the extension should be automatically
	//upgraded by the platform if there is a newer version of the extension available.
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	//ForceUpdateTag: How the extension handler should be forced to update even if the
	//extension configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//InstanceView: The virtual machine extension instance view.
	InstanceView *VirtualMachineExtensionInstanceView_Status `json:"instanceView,omitempty"`

	// +kubebuilder:validation:Required
	//Location: Resource location
	Location string `json:"location"`

	//Name: Resource name
	Name *string `json:"name,omitempty"`

	//PropertiesType: Specifies the type of the extension; an example is
	//"CustomScriptExtension".
	PropertiesType *string `json:"properties_type,omitempty"`

	//ProtectedSettings: The extension can contain either protectedSettings or
	//protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings map[string]v1.JSON `json:"protectedSettings,omitempty"`

	//ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//Publisher: The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`

	//Settings: Json formatted public settings for the extension.
	Settings map[string]v1.JSON `json:"settings,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type
	Type *string `json:"type,omitempty"`

	//TypeHandlerVersion: Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineExtension_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineExtensionStatus *VirtualMachineExtension_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineExtension_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineExtensionStatus *VirtualMachineExtension_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineExtension_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineExtension_StatusARM, got %T", armInput)
	}

	// Set property ‘AutoUpgradeMinorVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			virtualMachineExtensionStatus.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// Set property ‘EnableAutomaticUpgrade’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutomaticUpgrade != nil {
			enableAutomaticUpgrade := *typedInput.Properties.EnableAutomaticUpgrade
			virtualMachineExtensionStatus.EnableAutomaticUpgrade = &enableAutomaticUpgrade
		}
	}

	// Set property ‘ForceUpdateTag’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceUpdateTag != nil {
			forceUpdateTag := *typedInput.Properties.ForceUpdateTag
			virtualMachineExtensionStatus.ForceUpdateTag = &forceUpdateTag
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualMachineExtensionStatus.Id = &id
	}

	// Set property ‘InstanceView’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 VirtualMachineExtensionInstanceView_Status
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			virtualMachineExtensionStatus.InstanceView = &instanceView
		}
	}

	// Set property ‘Location’:
	virtualMachineExtensionStatus.Location = typedInput.Location

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineExtensionStatus.Name = &name
	}

	// Set property ‘PropertiesType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Type != nil {
			propertiesType := *typedInput.Properties.Type
			virtualMachineExtensionStatus.PropertiesType = &propertiesType
		}
	}

	// Set property ‘ProtectedSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProtectedSettings != nil {
			virtualMachineExtensionStatus.ProtectedSettings = make(map[string]v1.JSON)
			for key, value := range typedInput.Properties.ProtectedSettings {
				virtualMachineExtensionStatus.ProtectedSettings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			virtualMachineExtensionStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Publisher’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Publisher != nil {
			publisher := *typedInput.Properties.Publisher
			virtualMachineExtensionStatus.Publisher = &publisher
		}
	}

	// Set property ‘Settings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Settings != nil {
			virtualMachineExtensionStatus.Settings = make(map[string]v1.JSON)
			for key, value := range typedInput.Properties.Settings {
				virtualMachineExtensionStatus.Settings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		virtualMachineExtensionStatus.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			virtualMachineExtensionStatus.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineExtensionStatus.Type = &typeVar
	}

	// Set property ‘TypeHandlerVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TypeHandlerVersion != nil {
			typeHandlerVersion := *typedInput.Properties.TypeHandlerVersion
			virtualMachineExtensionStatus.TypeHandlerVersion = &typeHandlerVersion
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineExtensionStatus populates our VirtualMachineExtension_Status from the provided source VirtualMachineExtension_Status
func (virtualMachineExtensionStatus *VirtualMachineExtension_Status) AssignPropertiesFromVirtualMachineExtensionStatus(source *v1alpha1api20201201storage.VirtualMachineExtension_Status) error {

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		virtualMachineExtensionStatus.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		virtualMachineExtensionStatus.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		virtualMachineExtensionStatus.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		virtualMachineExtensionStatus.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	virtualMachineExtensionStatus.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Id
	virtualMachineExtensionStatus.Id = genruntime.ClonePointerToString(source.Id)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineExtensionInstanceView_Status
		err := instanceView.AssignPropertiesFromVirtualMachineExtensionInstanceViewStatus(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "populating InstanceView from InstanceView, calling AssignPropertiesFromVirtualMachineExtensionInstanceViewStatus()")
		}
		virtualMachineExtensionStatus.InstanceView = &instanceView
	} else {
		virtualMachineExtensionStatus.InstanceView = nil
	}

	// Location
	virtualMachineExtensionStatus.Location = genruntime.GetOptionalStringValue(source.Location)

	// Name
	virtualMachineExtensionStatus.Name = genruntime.ClonePointerToString(source.Name)

	// PropertiesType
	virtualMachineExtensionStatus.PropertiesType = genruntime.ClonePointerToString(source.PropertiesType)

	// ProtectedSettings
	if source.ProtectedSettings != nil {
		protectedSettingMap := make(map[string]v1.JSON, len(source.ProtectedSettings))
		for protectedSettingKey, protectedSettingValue := range source.ProtectedSettings {
			// Shadow the loop variable to avoid aliasing
			protectedSettingValue := protectedSettingValue
			protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
		}
		virtualMachineExtensionStatus.ProtectedSettings = protectedSettingMap
	} else {
		virtualMachineExtensionStatus.ProtectedSettings = nil
	}

	// ProvisioningState
	virtualMachineExtensionStatus.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Publisher
	virtualMachineExtensionStatus.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		virtualMachineExtensionStatus.Settings = settingMap
	} else {
		virtualMachineExtensionStatus.Settings = nil
	}

	// Tags
	virtualMachineExtensionStatus.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	virtualMachineExtensionStatus.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	virtualMachineExtensionStatus.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionStatus populates the provided destination VirtualMachineExtension_Status from our VirtualMachineExtension_Status
func (virtualMachineExtensionStatus *VirtualMachineExtension_Status) AssignPropertiesToVirtualMachineExtensionStatus(destination *v1alpha1api20201201storage.VirtualMachineExtension_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoUpgradeMinorVersion
	if virtualMachineExtensionStatus.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *virtualMachineExtensionStatus.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if virtualMachineExtensionStatus.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *virtualMachineExtensionStatus.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(virtualMachineExtensionStatus.ForceUpdateTag)

	// Id
	destination.Id = genruntime.ClonePointerToString(virtualMachineExtensionStatus.Id)

	// InstanceView
	if virtualMachineExtensionStatus.InstanceView != nil {
		var instanceView v1alpha1api20201201storage.VirtualMachineExtensionInstanceView_Status
		err := (*virtualMachineExtensionStatus.InstanceView).AssignPropertiesToVirtualMachineExtensionInstanceViewStatus(&instanceView)
		if err != nil {
			return errors.Wrap(err, "populating InstanceView from InstanceView, calling AssignPropertiesToVirtualMachineExtensionInstanceViewStatus()")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Location
	location := virtualMachineExtensionStatus.Location
	destination.Location = &location

	// Name
	destination.Name = genruntime.ClonePointerToString(virtualMachineExtensionStatus.Name)

	// PropertiesType
	destination.PropertiesType = genruntime.ClonePointerToString(virtualMachineExtensionStatus.PropertiesType)

	// ProtectedSettings
	if virtualMachineExtensionStatus.ProtectedSettings != nil {
		protectedSettingMap := make(map[string]v1.JSON, len(virtualMachineExtensionStatus.ProtectedSettings))
		for protectedSettingKey, protectedSettingValue := range virtualMachineExtensionStatus.ProtectedSettings {
			// Shadow the loop variable to avoid aliasing
			protectedSettingValue := protectedSettingValue
			protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
		}
		destination.ProtectedSettings = protectedSettingMap
	} else {
		destination.ProtectedSettings = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(virtualMachineExtensionStatus.ProvisioningState)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(virtualMachineExtensionStatus.Publisher)

	// Settings
	if virtualMachineExtensionStatus.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(virtualMachineExtensionStatus.Settings))
		for settingKey, settingValue := range virtualMachineExtensionStatus.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(virtualMachineExtensionStatus.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(virtualMachineExtensionStatus.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(virtualMachineExtensionStatus.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineIdentity
type VirtualMachineIdentity struct {
	//Type: The type of identity used for the virtual machine. The type
	//'SystemAssigned, UserAssigned' includes both an implicitly created identity and
	//a set of user assigned identities. The type 'None' will remove any identities
	//from the virtual machine.
	Type *VirtualMachineIdentityType `json:"type,omitempty"`

	//UserAssignedIdentities: The list of user identities associated with the Virtual
	//Machine. The user identity dictionary key references will be ARM resource ids in
	//the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]v1.JSON `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineIdentity *VirtualMachineIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineIdentity == nil {
		return nil, nil
	}
	var result VirtualMachineIdentityARM

	// Set property ‘Type’:
	if virtualMachineIdentity.Type != nil {
		typeVar := *virtualMachineIdentity.Type
		result.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if virtualMachineIdentity.UserAssignedIdentities != nil {
		result.UserAssignedIdentities = make(map[string]v1.JSON)
		for key, value := range virtualMachineIdentity.UserAssignedIdentities {
			result.UserAssignedIdentities[key] = *value.DeepCopy()
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineIdentity *VirtualMachineIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineIdentity *VirtualMachineIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineIdentityARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineIdentity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		virtualMachineIdentity.UserAssignedIdentities = make(map[string]v1.JSON)
		for key, value := range typedInput.UserAssignedIdentities {
			virtualMachineIdentity.UserAssignedIdentities[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineIdentity populates our VirtualMachineIdentity from the provided source VirtualMachineIdentity
func (virtualMachineIdentity *VirtualMachineIdentity) AssignPropertiesFromVirtualMachineIdentity(source *v1alpha1api20201201storage.VirtualMachineIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineIdentityType(*source.Type)
		virtualMachineIdentity.Type = &typeVar
	} else {
		virtualMachineIdentity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1.JSON, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			userAssignedIdentityMap[userAssignedIdentityKey] = *userAssignedIdentityValue.DeepCopy()
		}
		virtualMachineIdentity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		virtualMachineIdentity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineIdentity populates the provided destination VirtualMachineIdentity from our VirtualMachineIdentity
func (virtualMachineIdentity *VirtualMachineIdentity) AssignPropertiesToVirtualMachineIdentity(destination *v1alpha1api20201201storage.VirtualMachineIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if virtualMachineIdentity.Type != nil {
		typeVar := string(*virtualMachineIdentity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if virtualMachineIdentity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1.JSON, len(virtualMachineIdentity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range virtualMachineIdentity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			userAssignedIdentityMap[userAssignedIdentityKey] = *userAssignedIdentityValue.DeepCopy()
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineIdentity_Status struct {
	//PrincipalId: The principal id of virtual machine identity. This property will
	//only be provided for a system assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	//TenantId: The tenant id associated with the virtual machine. This property will
	//only be provided for a system assigned identity.
	TenantId *string `json:"tenantId,omitempty"`

	//Type: The type of identity used for the virtual machine. The type
	//'SystemAssigned, UserAssigned' includes both an implicitly created identity and
	//a set of user assigned identities. The type 'None' will remove any identities
	//from the virtual machine.
	Type *VirtualMachineIdentityStatusType `json:"type,omitempty"`

	//UserAssignedIdentities: The list of user identities associated with the Virtual
	//Machine. The user identity dictionary key references will be ARM resource ids in
	//the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]VirtualMachineIdentity_Status_UserAssignedIdentities `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineIdentity_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineIdentityStatus *VirtualMachineIdentity_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineIdentityStatus *VirtualMachineIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		virtualMachineIdentityStatus.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		virtualMachineIdentityStatus.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineIdentityStatus.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		virtualMachineIdentityStatus.UserAssignedIdentities = make(map[string]VirtualMachineIdentity_Status_UserAssignedIdentities)
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 VirtualMachineIdentity_Status_UserAssignedIdentities
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			virtualMachineIdentityStatus.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineIdentityStatus populates our VirtualMachineIdentity_Status from the provided source VirtualMachineIdentity_Status
func (virtualMachineIdentityStatus *VirtualMachineIdentity_Status) AssignPropertiesFromVirtualMachineIdentityStatus(source *v1alpha1api20201201storage.VirtualMachineIdentity_Status) error {

	// PrincipalId
	virtualMachineIdentityStatus.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	virtualMachineIdentityStatus.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineIdentityStatusType(*source.Type)
		virtualMachineIdentityStatus.Type = &typeVar
	} else {
		virtualMachineIdentityStatus.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]VirtualMachineIdentity_Status_UserAssignedIdentities, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity VirtualMachineIdentity_Status_UserAssignedIdentities
			err := userAssignedIdentity.AssignPropertiesFromVirtualMachineIdentityStatusUserAssignedIdentities(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesFromVirtualMachineIdentityStatusUserAssignedIdentities()")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		virtualMachineIdentityStatus.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		virtualMachineIdentityStatus.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineIdentityStatus populates the provided destination VirtualMachineIdentity_Status from our VirtualMachineIdentity_Status
func (virtualMachineIdentityStatus *VirtualMachineIdentity_Status) AssignPropertiesToVirtualMachineIdentityStatus(destination *v1alpha1api20201201storage.VirtualMachineIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(virtualMachineIdentityStatus.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(virtualMachineIdentityStatus.TenantId)

	// Type
	if virtualMachineIdentityStatus.Type != nil {
		typeVar := string(*virtualMachineIdentityStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if virtualMachineIdentityStatus.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1alpha1api20201201storage.VirtualMachineIdentity_Status_UserAssignedIdentities, len(virtualMachineIdentityStatus.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range virtualMachineIdentityStatus.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v1alpha1api20201201storage.VirtualMachineIdentity_Status_UserAssignedIdentities
			err := userAssignedIdentityValue.AssignPropertiesToVirtualMachineIdentityStatusUserAssignedIdentities(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesToVirtualMachineIdentityStatusUserAssignedIdentities()")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineInstanceView_Status struct {
	//AssignedHost: Resource id of the dedicated host, on which the virtual machine is
	//allocated through automatic placement, when the virtual machine is associated
	//with a dedicated host group that has automatic placement enabled.
	//Minimum api-version: 2020-06-01.
	AssignedHost *string `json:"assignedHost,omitempty"`

	//BootDiagnostics: Boot Diagnostics is a debugging feature which allows you to
	//view Console Output and Screenshot to diagnose VM status.
	//You can easily view the output of your console log.
	//Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnosticsInstanceView_Status `json:"bootDiagnostics,omitempty"`

	//ComputerName: The computer name assigned to the virtual machine.
	ComputerName *string `json:"computerName,omitempty"`

	//Disks: The virtual machine disk information.
	Disks []DiskInstanceView_Status `json:"disks,omitempty"`

	//Extensions: The extensions information.
	Extensions []VirtualMachineExtensionInstanceView_Status `json:"extensions,omitempty"`

	//HyperVGeneration: Specifies the HyperVGeneration Type associated with a resource
	HyperVGeneration *VirtualMachineInstanceViewStatusHyperVGeneration `json:"hyperVGeneration,omitempty"`

	//MaintenanceRedeployStatus: The Maintenance Operation status on the virtual
	//machine.
	MaintenanceRedeployStatus *MaintenanceRedeployStatus_Status `json:"maintenanceRedeployStatus,omitempty"`

	//OsName: The Operating System running on the virtual machine.
	OsName *string `json:"osName,omitempty"`

	//OsVersion: The version of Operating System running on the virtual machine.
	OsVersion *string `json:"osVersion,omitempty"`

	//PatchStatus: [Preview Feature] The status of virtual machine patch operations.
	PatchStatus *VirtualMachinePatchStatus_Status `json:"patchStatus,omitempty"`

	//PlatformFaultDomain: Specifies the fault domain of the virtual machine.
	PlatformFaultDomain *int `json:"platformFaultDomain,omitempty"`

	//PlatformUpdateDomain: Specifies the update domain of the virtual machine.
	PlatformUpdateDomain *int `json:"platformUpdateDomain,omitempty"`

	//RdpThumbPrint: The Remote desktop certificate thumbprint.
	RdpThumbPrint *string `json:"rdpThumbPrint,omitempty"`

	//Statuses: The resource status information.
	Statuses []InstanceViewStatus_Status `json:"statuses,omitempty"`

	//VmAgent: The VM Agent running on the virtual machine.
	VmAgent *VirtualMachineAgentInstanceView_Status `json:"vmAgent,omitempty"`

	//VmHealth: The health status for the VM.
	VmHealth *VirtualMachineHealthStatus_Status `json:"vmHealth,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineInstanceView_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineInstanceViewStatus *VirtualMachineInstanceView_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineInstanceView_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineInstanceViewStatus *VirtualMachineInstanceView_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineInstanceView_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineInstanceView_StatusARM, got %T", armInput)
	}

	// Set property ‘AssignedHost’:
	if typedInput.AssignedHost != nil {
		assignedHost := *typedInput.AssignedHost
		virtualMachineInstanceViewStatus.AssignedHost = &assignedHost
	}

	// Set property ‘BootDiagnostics’:
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnosticsInstanceView_Status
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		virtualMachineInstanceViewStatus.BootDiagnostics = &bootDiagnostics
	}

	// Set property ‘ComputerName’:
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		virtualMachineInstanceViewStatus.ComputerName = &computerName
	}

	// Set property ‘Disks’:
	for _, item := range typedInput.Disks {
		var item1 DiskInstanceView_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineInstanceViewStatus.Disks = append(virtualMachineInstanceViewStatus.Disks, item1)
	}

	// Set property ‘Extensions’:
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineExtensionInstanceView_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineInstanceViewStatus.Extensions = append(virtualMachineInstanceViewStatus.Extensions, item1)
	}

	// Set property ‘HyperVGeneration’:
	if typedInput.HyperVGeneration != nil {
		hyperVGeneration := *typedInput.HyperVGeneration
		virtualMachineInstanceViewStatus.HyperVGeneration = &hyperVGeneration
	}

	// Set property ‘MaintenanceRedeployStatus’:
	if typedInput.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus1 MaintenanceRedeployStatus_Status
		err := maintenanceRedeployStatus1.PopulateFromARM(owner, *typedInput.MaintenanceRedeployStatus)
		if err != nil {
			return err
		}
		maintenanceRedeployStatus := maintenanceRedeployStatus1
		virtualMachineInstanceViewStatus.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	}

	// Set property ‘OsName’:
	if typedInput.OsName != nil {
		osName := *typedInput.OsName
		virtualMachineInstanceViewStatus.OsName = &osName
	}

	// Set property ‘OsVersion’:
	if typedInput.OsVersion != nil {
		osVersion := *typedInput.OsVersion
		virtualMachineInstanceViewStatus.OsVersion = &osVersion
	}

	// Set property ‘PatchStatus’:
	if typedInput.PatchStatus != nil {
		var patchStatus1 VirtualMachinePatchStatus_Status
		err := patchStatus1.PopulateFromARM(owner, *typedInput.PatchStatus)
		if err != nil {
			return err
		}
		patchStatus := patchStatus1
		virtualMachineInstanceViewStatus.PatchStatus = &patchStatus
	}

	// Set property ‘PlatformFaultDomain’:
	if typedInput.PlatformFaultDomain != nil {
		platformFaultDomain := *typedInput.PlatformFaultDomain
		virtualMachineInstanceViewStatus.PlatformFaultDomain = &platformFaultDomain
	}

	// Set property ‘PlatformUpdateDomain’:
	if typedInput.PlatformUpdateDomain != nil {
		platformUpdateDomain := *typedInput.PlatformUpdateDomain
		virtualMachineInstanceViewStatus.PlatformUpdateDomain = &platformUpdateDomain
	}

	// Set property ‘RdpThumbPrint’:
	if typedInput.RdpThumbPrint != nil {
		rdpThumbPrint := *typedInput.RdpThumbPrint
		virtualMachineInstanceViewStatus.RdpThumbPrint = &rdpThumbPrint
	}

	// Set property ‘Statuses’:
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineInstanceViewStatus.Statuses = append(virtualMachineInstanceViewStatus.Statuses, item1)
	}

	// Set property ‘VmAgent’:
	if typedInput.VmAgent != nil {
		var vmAgent1 VirtualMachineAgentInstanceView_Status
		err := vmAgent1.PopulateFromARM(owner, *typedInput.VmAgent)
		if err != nil {
			return err
		}
		vmAgent := vmAgent1
		virtualMachineInstanceViewStatus.VmAgent = &vmAgent
	}

	// Set property ‘VmHealth’:
	if typedInput.VmHealth != nil {
		var vmHealth1 VirtualMachineHealthStatus_Status
		err := vmHealth1.PopulateFromARM(owner, *typedInput.VmHealth)
		if err != nil {
			return err
		}
		vmHealth := vmHealth1
		virtualMachineInstanceViewStatus.VmHealth = &vmHealth
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineInstanceViewStatus populates our VirtualMachineInstanceView_Status from the provided source VirtualMachineInstanceView_Status
func (virtualMachineInstanceViewStatus *VirtualMachineInstanceView_Status) AssignPropertiesFromVirtualMachineInstanceViewStatus(source *v1alpha1api20201201storage.VirtualMachineInstanceView_Status) error {

	// AssignedHost
	virtualMachineInstanceViewStatus.AssignedHost = genruntime.ClonePointerToString(source.AssignedHost)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnosticsInstanceView_Status
		err := bootDiagnostic.AssignPropertiesFromBootDiagnosticsInstanceViewStatus(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesFromBootDiagnosticsInstanceViewStatus()")
		}
		virtualMachineInstanceViewStatus.BootDiagnostics = &bootDiagnostic
	} else {
		virtualMachineInstanceViewStatus.BootDiagnostics = nil
	}

	// ComputerName
	virtualMachineInstanceViewStatus.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// Disks
	if source.Disks != nil {
		diskList := make([]DiskInstanceView_Status, len(source.Disks))
		for diskIndex, diskItem := range source.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk DiskInstanceView_Status
			err := disk.AssignPropertiesFromDiskInstanceViewStatus(&diskItem)
			if err != nil {
				return errors.Wrap(err, "populating Disks from Disks, calling AssignPropertiesFromDiskInstanceViewStatus()")
			}
			diskList[diskIndex] = disk
		}
		virtualMachineInstanceViewStatus.Disks = diskList
	} else {
		virtualMachineInstanceViewStatus.Disks = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineExtensionInstanceView_Status, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineExtensionInstanceView_Status
			err := extension.AssignPropertiesFromVirtualMachineExtensionInstanceViewStatus(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "populating Extensions from Extensions, calling AssignPropertiesFromVirtualMachineExtensionInstanceViewStatus()")
			}
			extensionList[extensionIndex] = extension
		}
		virtualMachineInstanceViewStatus.Extensions = extensionList
	} else {
		virtualMachineInstanceViewStatus.Extensions = nil
	}

	// HyperVGeneration
	if source.HyperVGeneration != nil {
		hyperVGeneration := VirtualMachineInstanceViewStatusHyperVGeneration(*source.HyperVGeneration)
		virtualMachineInstanceViewStatus.HyperVGeneration = &hyperVGeneration
	} else {
		virtualMachineInstanceViewStatus.HyperVGeneration = nil
	}

	// MaintenanceRedeployStatus
	if source.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus MaintenanceRedeployStatus_Status
		err := maintenanceRedeployStatus.AssignPropertiesFromMaintenanceRedeployStatusStatus(source.MaintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "populating MaintenanceRedeployStatus from MaintenanceRedeployStatus, calling AssignPropertiesFromMaintenanceRedeployStatusStatus()")
		}
		virtualMachineInstanceViewStatus.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		virtualMachineInstanceViewStatus.MaintenanceRedeployStatus = nil
	}

	// OsName
	virtualMachineInstanceViewStatus.OsName = genruntime.ClonePointerToString(source.OsName)

	// OsVersion
	virtualMachineInstanceViewStatus.OsVersion = genruntime.ClonePointerToString(source.OsVersion)

	// PatchStatus
	if source.PatchStatus != nil {
		var patchStatus VirtualMachinePatchStatus_Status
		err := patchStatus.AssignPropertiesFromVirtualMachinePatchStatusStatus(source.PatchStatus)
		if err != nil {
			return errors.Wrap(err, "populating PatchStatus from PatchStatus, calling AssignPropertiesFromVirtualMachinePatchStatusStatus()")
		}
		virtualMachineInstanceViewStatus.PatchStatus = &patchStatus
	} else {
		virtualMachineInstanceViewStatus.PatchStatus = nil
	}

	// PlatformFaultDomain
	virtualMachineInstanceViewStatus.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// PlatformUpdateDomain
	virtualMachineInstanceViewStatus.PlatformUpdateDomain = genruntime.ClonePointerToInt(source.PlatformUpdateDomain)

	// RdpThumbPrint
	virtualMachineInstanceViewStatus.RdpThumbPrint = genruntime.ClonePointerToString(source.RdpThumbPrint)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_Status, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_Status
			err := status.AssignPropertiesFromInstanceViewStatusStatus(&statusItem)
			if err != nil {
				return errors.Wrap(err, "populating Statuses from Statuses, calling AssignPropertiesFromInstanceViewStatusStatus()")
			}
			statusList[statusIndex] = status
		}
		virtualMachineInstanceViewStatus.Statuses = statusList
	} else {
		virtualMachineInstanceViewStatus.Statuses = nil
	}

	// VmAgent
	if source.VmAgent != nil {
		var vmAgent VirtualMachineAgentInstanceView_Status
		err := vmAgent.AssignPropertiesFromVirtualMachineAgentInstanceViewStatus(source.VmAgent)
		if err != nil {
			return errors.Wrap(err, "populating VmAgent from VmAgent, calling AssignPropertiesFromVirtualMachineAgentInstanceViewStatus()")
		}
		virtualMachineInstanceViewStatus.VmAgent = &vmAgent
	} else {
		virtualMachineInstanceViewStatus.VmAgent = nil
	}

	// VmHealth
	if source.VmHealth != nil {
		var vmHealth VirtualMachineHealthStatus_Status
		err := vmHealth.AssignPropertiesFromVirtualMachineHealthStatusStatus(source.VmHealth)
		if err != nil {
			return errors.Wrap(err, "populating VmHealth from VmHealth, calling AssignPropertiesFromVirtualMachineHealthStatusStatus()")
		}
		virtualMachineInstanceViewStatus.VmHealth = &vmHealth
	} else {
		virtualMachineInstanceViewStatus.VmHealth = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineInstanceViewStatus populates the provided destination VirtualMachineInstanceView_Status from our VirtualMachineInstanceView_Status
func (virtualMachineInstanceViewStatus *VirtualMachineInstanceView_Status) AssignPropertiesToVirtualMachineInstanceViewStatus(destination *v1alpha1api20201201storage.VirtualMachineInstanceView_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssignedHost
	destination.AssignedHost = genruntime.ClonePointerToString(virtualMachineInstanceViewStatus.AssignedHost)

	// BootDiagnostics
	if virtualMachineInstanceViewStatus.BootDiagnostics != nil {
		var bootDiagnostic v1alpha1api20201201storage.BootDiagnosticsInstanceView_Status
		err := (*virtualMachineInstanceViewStatus.BootDiagnostics).AssignPropertiesToBootDiagnosticsInstanceViewStatus(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesToBootDiagnosticsInstanceViewStatus()")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(virtualMachineInstanceViewStatus.ComputerName)

	// Disks
	if virtualMachineInstanceViewStatus.Disks != nil {
		diskList := make([]v1alpha1api20201201storage.DiskInstanceView_Status, len(virtualMachineInstanceViewStatus.Disks))
		for diskIndex, diskItem := range virtualMachineInstanceViewStatus.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk v1alpha1api20201201storage.DiskInstanceView_Status
			err := diskItem.AssignPropertiesToDiskInstanceViewStatus(&disk)
			if err != nil {
				return errors.Wrap(err, "populating Disks from Disks, calling AssignPropertiesToDiskInstanceViewStatus()")
			}
			diskList[diskIndex] = disk
		}
		destination.Disks = diskList
	} else {
		destination.Disks = nil
	}

	// Extensions
	if virtualMachineInstanceViewStatus.Extensions != nil {
		extensionList := make([]v1alpha1api20201201storage.VirtualMachineExtensionInstanceView_Status, len(virtualMachineInstanceViewStatus.Extensions))
		for extensionIndex, extensionItem := range virtualMachineInstanceViewStatus.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension v1alpha1api20201201storage.VirtualMachineExtensionInstanceView_Status
			err := extensionItem.AssignPropertiesToVirtualMachineExtensionInstanceViewStatus(&extension)
			if err != nil {
				return errors.Wrap(err, "populating Extensions from Extensions, calling AssignPropertiesToVirtualMachineExtensionInstanceViewStatus()")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// HyperVGeneration
	if virtualMachineInstanceViewStatus.HyperVGeneration != nil {
		hyperVGeneration := string(*virtualMachineInstanceViewStatus.HyperVGeneration)
		destination.HyperVGeneration = &hyperVGeneration
	} else {
		destination.HyperVGeneration = nil
	}

	// MaintenanceRedeployStatus
	if virtualMachineInstanceViewStatus.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus v1alpha1api20201201storage.MaintenanceRedeployStatus_Status
		err := (*virtualMachineInstanceViewStatus.MaintenanceRedeployStatus).AssignPropertiesToMaintenanceRedeployStatusStatus(&maintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "populating MaintenanceRedeployStatus from MaintenanceRedeployStatus, calling AssignPropertiesToMaintenanceRedeployStatusStatus()")
		}
		destination.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		destination.MaintenanceRedeployStatus = nil
	}

	// OsName
	destination.OsName = genruntime.ClonePointerToString(virtualMachineInstanceViewStatus.OsName)

	// OsVersion
	destination.OsVersion = genruntime.ClonePointerToString(virtualMachineInstanceViewStatus.OsVersion)

	// PatchStatus
	if virtualMachineInstanceViewStatus.PatchStatus != nil {
		var patchStatus v1alpha1api20201201storage.VirtualMachinePatchStatus_Status
		err := (*virtualMachineInstanceViewStatus.PatchStatus).AssignPropertiesToVirtualMachinePatchStatusStatus(&patchStatus)
		if err != nil {
			return errors.Wrap(err, "populating PatchStatus from PatchStatus, calling AssignPropertiesToVirtualMachinePatchStatusStatus()")
		}
		destination.PatchStatus = &patchStatus
	} else {
		destination.PatchStatus = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(virtualMachineInstanceViewStatus.PlatformFaultDomain)

	// PlatformUpdateDomain
	destination.PlatformUpdateDomain = genruntime.ClonePointerToInt(virtualMachineInstanceViewStatus.PlatformUpdateDomain)

	// RdpThumbPrint
	destination.RdpThumbPrint = genruntime.ClonePointerToString(virtualMachineInstanceViewStatus.RdpThumbPrint)

	// Statuses
	if virtualMachineInstanceViewStatus.Statuses != nil {
		statusList := make([]v1alpha1api20201201storage.InstanceViewStatus_Status, len(virtualMachineInstanceViewStatus.Statuses))
		for statusIndex, statusItem := range virtualMachineInstanceViewStatus.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v1alpha1api20201201storage.InstanceViewStatus_Status
			err := statusItem.AssignPropertiesToInstanceViewStatusStatus(&status)
			if err != nil {
				return errors.Wrap(err, "populating Statuses from Statuses, calling AssignPropertiesToInstanceViewStatusStatus()")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgent
	if virtualMachineInstanceViewStatus.VmAgent != nil {
		var vmAgent v1alpha1api20201201storage.VirtualMachineAgentInstanceView_Status
		err := (*virtualMachineInstanceViewStatus.VmAgent).AssignPropertiesToVirtualMachineAgentInstanceViewStatus(&vmAgent)
		if err != nil {
			return errors.Wrap(err, "populating VmAgent from VmAgent, calling AssignPropertiesToVirtualMachineAgentInstanceViewStatus()")
		}
		destination.VmAgent = &vmAgent
	} else {
		destination.VmAgent = nil
	}

	// VmHealth
	if virtualMachineInstanceViewStatus.VmHealth != nil {
		var vmHealth v1alpha1api20201201storage.VirtualMachineHealthStatus_Status
		err := (*virtualMachineInstanceViewStatus.VmHealth).AssignPropertiesToVirtualMachineHealthStatusStatus(&vmHealth)
		if err != nil {
			return errors.Wrap(err, "populating VmHealth from VmHealth, calling AssignPropertiesToVirtualMachineHealthStatusStatus()")
		}
		destination.VmHealth = &vmHealth
	} else {
		destination.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type VirtualMachinesSpecPropertiesEvictionPolicy string

const (
	VirtualMachinesSpecPropertiesEvictionPolicyDeallocate = VirtualMachinesSpecPropertiesEvictionPolicy("Deallocate")
	VirtualMachinesSpecPropertiesEvictionPolicyDelete     = VirtualMachinesSpecPropertiesEvictionPolicy("Delete")
)

// +kubebuilder:validation:Enum={"Low","Regular","Spot"}
type VirtualMachinesSpecPropertiesPriority string

const (
	VirtualMachinesSpecPropertiesPriorityLow     = VirtualMachinesSpecPropertiesPriority("Low")
	VirtualMachinesSpecPropertiesPriorityRegular = VirtualMachinesSpecPropertiesPriority("Regular")
	VirtualMachinesSpecPropertiesPrioritySpot    = VirtualMachinesSpecPropertiesPriority("Spot")
)

type VirtualMachines_Spec_Properties_NetworkProfile struct {
	//NetworkInterfaces: Specifies the list of resource Ids for the network interfaces
	//associated with the virtual machine.
	NetworkInterfaces []VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces `json:"networkInterfaces,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachines_Spec_Properties_NetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachinesSpecPropertiesNetworkProfile *VirtualMachines_Spec_Properties_NetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachinesSpecPropertiesNetworkProfile == nil {
		return nil, nil
	}
	var result VirtualMachines_Spec_Properties_NetworkProfileARM

	// Set property ‘NetworkInterfaces’:
	for _, item := range virtualMachinesSpecPropertiesNetworkProfile.NetworkInterfaces {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaces = append(result.NetworkInterfaces, itemARM.(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachinesSpecPropertiesNetworkProfile *VirtualMachines_Spec_Properties_NetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachines_Spec_Properties_NetworkProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachinesSpecPropertiesNetworkProfile *VirtualMachines_Spec_Properties_NetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachines_Spec_Properties_NetworkProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachines_Spec_Properties_NetworkProfileARM, got %T", armInput)
	}

	// Set property ‘NetworkInterfaces’:
	for _, item := range typedInput.NetworkInterfaces {
		var item1 VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachinesSpecPropertiesNetworkProfile.NetworkInterfaces = append(virtualMachinesSpecPropertiesNetworkProfile.NetworkInterfaces, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile populates our VirtualMachines_Spec_Properties_NetworkProfile from the provided source VirtualMachines_Spec_Properties_NetworkProfile
func (virtualMachinesSpecPropertiesNetworkProfile *VirtualMachines_Spec_Properties_NetworkProfile) AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile(source *v1alpha1api20201201storage.VirtualMachines_Spec_Properties_NetworkProfile) error {

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
			err := networkInterface.AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "populating NetworkInterfaces from NetworkInterfaces, calling AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces()")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		virtualMachinesSpecPropertiesNetworkProfile.NetworkInterfaces = networkInterfaceList
	} else {
		virtualMachinesSpecPropertiesNetworkProfile.NetworkInterfaces = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile populates the provided destination VirtualMachines_Spec_Properties_NetworkProfile from our VirtualMachines_Spec_Properties_NetworkProfile
func (virtualMachinesSpecPropertiesNetworkProfile *VirtualMachines_Spec_Properties_NetworkProfile) AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile(destination *v1alpha1api20201201storage.VirtualMachines_Spec_Properties_NetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NetworkInterfaces
	if virtualMachinesSpecPropertiesNetworkProfile.NetworkInterfaces != nil {
		networkInterfaceList := make([]v1alpha1api20201201storage.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces, len(virtualMachinesSpecPropertiesNetworkProfile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range virtualMachinesSpecPropertiesNetworkProfile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface v1alpha1api20201201storage.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
			err := networkInterfaceItem.AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "populating NetworkInterfaces from NetworkInterfaces, calling AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces()")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/BootDiagnostics
type BootDiagnostics struct {
	//Enabled: Whether boot diagnostics should be enabled on the Virtual Machine.
	Enabled *bool `json:"enabled,omitempty"`

	//StorageUri: Uri of the storage account to use for placing the console output and
	//screenshot.
	//If storageUri is not specified while enabling boot diagnostics, managed storage
	//will be used.
	StorageUri *string `json:"storageUri,omitempty"`
}

var _ genruntime.ARMTransformer = &BootDiagnostics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (bootDiagnostics *BootDiagnostics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if bootDiagnostics == nil {
		return nil, nil
	}
	var result BootDiagnosticsARM

	// Set property ‘Enabled’:
	if bootDiagnostics.Enabled != nil {
		enabled := *bootDiagnostics.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if bootDiagnostics.StorageUri != nil {
		storageUri := *bootDiagnostics.StorageUri
		result.StorageUri = &storageUri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (bootDiagnostics *BootDiagnostics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BootDiagnosticsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (bootDiagnostics *BootDiagnostics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BootDiagnosticsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BootDiagnosticsARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		bootDiagnostics.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if typedInput.StorageUri != nil {
		storageUri := *typedInput.StorageUri
		bootDiagnostics.StorageUri = &storageUri
	}

	// No error
	return nil
}

// AssignPropertiesFromBootDiagnostics populates our BootDiagnostics from the provided source BootDiagnostics
func (bootDiagnostics *BootDiagnostics) AssignPropertiesFromBootDiagnostics(source *v1alpha1api20201201storage.BootDiagnostics) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		bootDiagnostics.Enabled = &enabled
	} else {
		bootDiagnostics.Enabled = nil
	}

	// StorageUri
	bootDiagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// No error
	return nil
}

// AssignPropertiesToBootDiagnostics populates the provided destination BootDiagnostics from our BootDiagnostics
func (bootDiagnostics *BootDiagnostics) AssignPropertiesToBootDiagnostics(destination *v1alpha1api20201201storage.BootDiagnostics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if bootDiagnostics.Enabled != nil {
		enabled := *bootDiagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(bootDiagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BootDiagnosticsInstanceView_Status struct {
	//ConsoleScreenshotBlobUri: The console screenshot blob URI.
	//NOTE: This will not be set if boot diagnostics is currently enabled with managed
	//storage.
	ConsoleScreenshotBlobUri *string `json:"consoleScreenshotBlobUri,omitempty"`

	//SerialConsoleLogBlobUri: The serial console log blob Uri.
	//NOTE: This will not be set if boot diagnostics is currently enabled with managed
	//storage.
	SerialConsoleLogBlobUri *string `json:"serialConsoleLogBlobUri,omitempty"`

	//Status: The boot diagnostics status information for the VM.
	//NOTE: It will be set only if there are errors encountered in enabling boot
	//diagnostics.
	Status *InstanceViewStatus_Status `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &BootDiagnosticsInstanceView_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (bootDiagnosticsInstanceViewStatus *BootDiagnosticsInstanceView_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BootDiagnosticsInstanceView_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (bootDiagnosticsInstanceViewStatus *BootDiagnosticsInstanceView_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BootDiagnosticsInstanceView_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BootDiagnosticsInstanceView_StatusARM, got %T", armInput)
	}

	// Set property ‘ConsoleScreenshotBlobUri’:
	if typedInput.ConsoleScreenshotBlobUri != nil {
		consoleScreenshotBlobUri := *typedInput.ConsoleScreenshotBlobUri
		bootDiagnosticsInstanceViewStatus.ConsoleScreenshotBlobUri = &consoleScreenshotBlobUri
	}

	// Set property ‘SerialConsoleLogBlobUri’:
	if typedInput.SerialConsoleLogBlobUri != nil {
		serialConsoleLogBlobUri := *typedInput.SerialConsoleLogBlobUri
		bootDiagnosticsInstanceViewStatus.SerialConsoleLogBlobUri = &serialConsoleLogBlobUri
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		var status1 InstanceViewStatus_Status
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		bootDiagnosticsInstanceViewStatus.Status = &status
	}

	// No error
	return nil
}

// AssignPropertiesFromBootDiagnosticsInstanceViewStatus populates our BootDiagnosticsInstanceView_Status from the provided source BootDiagnosticsInstanceView_Status
func (bootDiagnosticsInstanceViewStatus *BootDiagnosticsInstanceView_Status) AssignPropertiesFromBootDiagnosticsInstanceViewStatus(source *v1alpha1api20201201storage.BootDiagnosticsInstanceView_Status) error {

	// ConsoleScreenshotBlobUri
	bootDiagnosticsInstanceViewStatus.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(source.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	bootDiagnosticsInstanceViewStatus.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(source.SerialConsoleLogBlobUri)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_Status
		err := status.AssignPropertiesFromInstanceViewStatusStatus(source.Status)
		if err != nil {
			return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromInstanceViewStatusStatus()")
		}
		bootDiagnosticsInstanceViewStatus.Status = &status
	} else {
		bootDiagnosticsInstanceViewStatus.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBootDiagnosticsInstanceViewStatus populates the provided destination BootDiagnosticsInstanceView_Status from our BootDiagnosticsInstanceView_Status
func (bootDiagnosticsInstanceViewStatus *BootDiagnosticsInstanceView_Status) AssignPropertiesToBootDiagnosticsInstanceViewStatus(destination *v1alpha1api20201201storage.BootDiagnosticsInstanceView_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsoleScreenshotBlobUri
	destination.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(bootDiagnosticsInstanceViewStatus.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	destination.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(bootDiagnosticsInstanceViewStatus.SerialConsoleLogBlobUri)

	// Status
	if bootDiagnosticsInstanceViewStatus.Status != nil {
		var status v1alpha1api20201201storage.InstanceViewStatus_Status
		err := (*bootDiagnosticsInstanceViewStatus.Status).AssignPropertiesToInstanceViewStatusStatus(&status)
		if err != nil {
			return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToInstanceViewStatusStatus()")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BootDiagnostics_Status struct {
	//Enabled: Whether boot diagnostics should be enabled on the Virtual Machine.
	Enabled *bool `json:"enabled,omitempty"`

	//StorageUri: Uri of the storage account to use for placing the console output and
	//screenshot.
	//If storageUri is not specified while enabling boot diagnostics, managed storage
	//will be used.
	StorageUri *string `json:"storageUri,omitempty"`
}

var _ genruntime.FromARMConverter = &BootDiagnostics_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (bootDiagnosticsStatus *BootDiagnostics_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BootDiagnostics_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (bootDiagnosticsStatus *BootDiagnostics_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BootDiagnostics_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BootDiagnostics_StatusARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		bootDiagnosticsStatus.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if typedInput.StorageUri != nil {
		storageUri := *typedInput.StorageUri
		bootDiagnosticsStatus.StorageUri = &storageUri
	}

	// No error
	return nil
}

// AssignPropertiesFromBootDiagnosticsStatus populates our BootDiagnostics_Status from the provided source BootDiagnostics_Status
func (bootDiagnosticsStatus *BootDiagnostics_Status) AssignPropertiesFromBootDiagnosticsStatus(source *v1alpha1api20201201storage.BootDiagnostics_Status) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		bootDiagnosticsStatus.Enabled = &enabled
	} else {
		bootDiagnosticsStatus.Enabled = nil
	}

	// StorageUri
	bootDiagnosticsStatus.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// No error
	return nil
}

// AssignPropertiesToBootDiagnosticsStatus populates the provided destination BootDiagnostics_Status from our BootDiagnostics_Status
func (bootDiagnosticsStatus *BootDiagnostics_Status) AssignPropertiesToBootDiagnosticsStatus(destination *v1alpha1api20201201storage.BootDiagnostics_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if bootDiagnosticsStatus.Enabled != nil {
		enabled := *bootDiagnosticsStatus.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(bootDiagnosticsStatus.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DataDisk
type DataDisk struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage.
	Caching *DataDiskCaching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: Specifies how the virtual machine should be created.
	//Possible values are:
	//Attach \u2013 This value is used when you are using a specialized disk to create
	//the virtual machine.
	//FromImage \u2013 This value is used when you are using an image to create the
	//virtual machine. If you are using a platform image, you also use the
	//imageReference element described above. If you are using a marketplace image,
	//you  also use the plan element previously described.
	CreateOption DataDiskCreateOption `json:"createOption"`

	//DetachOption: Specifies the detach behavior to be used while detaching a disk or
	//which is already in the process of detachment from the virtual machine.
	//Supported values: ForceDetach.
	//detachOption: ForceDetach is applicable only for managed data disks. If a
	//previous detachment attempt of the data disk did not complete due to an
	//unexpected failure from the virtual machine and the disk is still not released
	//then use force-detach as a last resort option to detach the disk forcibly from
	//the VM. All writes might not have been flushed when using this detach behavior.
	//This feature is still in preview mode and is not supported for
	//VirtualMachineScaleSet. To force-detach a data disk update toBeDetached to
	//'true' along with setting detachOption: 'ForceDetach'.
	DetachOption *DataDiskDetachOption `json:"detachOption,omitempty"`

	//DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element
	//can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//Image: Describes the uri of a disk.
	Image *VirtualHardDisk `json:"image,omitempty"`

	// +kubebuilder:validation:Required
	//Lun: Specifies the logical unit number of the data disk. This value is used to
	//identify data disks within the VM and therefore must be unique for each data
	//disk attached to a VM.
	Lun int `json:"lun"`

	//ManagedDisk: The parameters of a managed disk.
	ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//ToBeDetached: Specifies whether the data disk is in process of detachment from
	//the VirtualMachine/VirtualMachineScaleset
	ToBeDetached *bool `json:"toBeDetached,omitempty"`

	//Vhd: Describes the uri of a disk.
	Vhd *VirtualHardDisk `json:"vhd,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &DataDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (dataDisk *DataDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if dataDisk == nil {
		return nil, nil
	}
	var result DataDiskARM

	// Set property ‘Caching’:
	if dataDisk.Caching != nil {
		caching := *dataDisk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	result.CreateOption = dataDisk.CreateOption

	// Set property ‘DetachOption’:
	if dataDisk.DetachOption != nil {
		detachOption := *dataDisk.DetachOption
		result.DetachOption = &detachOption
	}

	// Set property ‘DiskSizeGB’:
	if dataDisk.DiskSizeGB != nil {
		diskSizeGB := *dataDisk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if dataDisk.Image != nil {
		imageARM, err := (*dataDisk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := imageARM.(VirtualHardDiskARM)
		result.Image = &image
	}

	// Set property ‘Lun’:
	result.Lun = dataDisk.Lun

	// Set property ‘ManagedDisk’:
	if dataDisk.ManagedDisk != nil {
		managedDiskARM, err := (*dataDisk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := managedDiskARM.(ManagedDiskParametersARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if dataDisk.Name != nil {
		name := *dataDisk.Name
		result.Name = &name
	}

	// Set property ‘ToBeDetached’:
	if dataDisk.ToBeDetached != nil {
		toBeDetached := *dataDisk.ToBeDetached
		result.ToBeDetached = &toBeDetached
	}

	// Set property ‘Vhd’:
	if dataDisk.Vhd != nil {
		vhdARM, err := (*dataDisk.Vhd).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vhd := vhdARM.(VirtualHardDiskARM)
		result.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if dataDisk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *dataDisk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (dataDisk *DataDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (dataDisk *DataDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataDiskARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		dataDisk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	dataDisk.CreateOption = typedInput.CreateOption

	// Set property ‘DetachOption’:
	if typedInput.DetachOption != nil {
		detachOption := *typedInput.DetachOption
		dataDisk.DetachOption = &detachOption
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		dataDisk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		dataDisk.Image = &image
	}

	// Set property ‘Lun’:
	dataDisk.Lun = typedInput.Lun

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		dataDisk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		dataDisk.Name = &name
	}

	// Set property ‘ToBeDetached’:
	if typedInput.ToBeDetached != nil {
		toBeDetached := *typedInput.ToBeDetached
		dataDisk.ToBeDetached = &toBeDetached
	}

	// Set property ‘Vhd’:
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		dataDisk.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		dataDisk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromDataDisk populates our DataDisk from the provided source DataDisk
func (dataDisk *DataDisk) AssignPropertiesFromDataDisk(source *v1alpha1api20201201storage.DataDisk) error {

	// Caching
	if source.Caching != nil {
		caching := DataDiskCaching(*source.Caching)
		dataDisk.Caching = &caching
	} else {
		dataDisk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		dataDisk.CreateOption = DataDiskCreateOption(*source.CreateOption)
	} else {
		dataDisk.CreateOption = ""
	}

	// DetachOption
	if source.DetachOption != nil {
		detachOption := DataDiskDetachOption(*source.DetachOption)
		dataDisk.DetachOption = &detachOption
	} else {
		dataDisk.DetachOption = nil
	}

	// DiskSizeGB
	dataDisk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignPropertiesFromVirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesFromVirtualHardDisk()")
		}
		dataDisk.Image = &image
	} else {
		dataDisk.Image = nil
	}

	// Lun
	dataDisk.Lun = genruntime.GetOptionalIntValue(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignPropertiesFromManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesFromManagedDiskParameters()")
		}
		dataDisk.ManagedDisk = &managedDisk
	} else {
		dataDisk.ManagedDisk = nil
	}

	// Name
	dataDisk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		dataDisk.ToBeDetached = &toBeDetached
	} else {
		dataDisk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignPropertiesFromVirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "populating Vhd from Vhd, calling AssignPropertiesFromVirtualHardDisk()")
		}
		dataDisk.Vhd = &vhd
	} else {
		dataDisk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		dataDisk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		dataDisk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDataDisk populates the provided destination DataDisk from our DataDisk
func (dataDisk *DataDisk) AssignPropertiesToDataDisk(destination *v1alpha1api20201201storage.DataDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if dataDisk.Caching != nil {
		caching := string(*dataDisk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(dataDisk.CreateOption)
	destination.CreateOption = &createOption

	// DetachOption
	if dataDisk.DetachOption != nil {
		detachOption := string(*dataDisk.DetachOption)
		destination.DetachOption = &detachOption
	} else {
		destination.DetachOption = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(dataDisk.DiskSizeGB)

	// Image
	if dataDisk.Image != nil {
		var image v1alpha1api20201201storage.VirtualHardDisk
		err := (*dataDisk.Image).AssignPropertiesToVirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesToVirtualHardDisk()")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	lun := dataDisk.Lun
	destination.Lun = &lun

	// ManagedDisk
	if dataDisk.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.ManagedDiskParameters
		err := (*dataDisk.ManagedDisk).AssignPropertiesToManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesToManagedDiskParameters()")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(dataDisk.Name)

	// ToBeDetached
	if dataDisk.ToBeDetached != nil {
		toBeDetached := *dataDisk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if dataDisk.Vhd != nil {
		var vhd v1alpha1api20201201storage.VirtualHardDisk
		err := (*dataDisk.Vhd).AssignPropertiesToVirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "populating Vhd from Vhd, calling AssignPropertiesToVirtualHardDisk()")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if dataDisk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *dataDisk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataDisk_Status struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_Status `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: Specifies how the virtual machine should be created.
	//Possible values are:
	//Attach \u2013 This value is used when you are using a specialized disk to create
	//the virtual machine.
	//FromImage \u2013 This value is used when you are using an image to create the
	//virtual machine. If you are using a platform image, you also use the
	//imageReference element described above. If you are using a marketplace image,
	//you  also use the plan element previously described.
	CreateOption CreateOption_Status `json:"createOption"`

	//DetachOption: Specifies the detach behavior to be used while detaching a disk or
	//which is already in the process of detachment from the virtual machine.
	//Supported values: ForceDetach.
	//detachOption: ForceDetach is applicable only for managed data disks. If a
	//previous detachment attempt of the data disk did not complete due to an
	//unexpected failure from the virtual machine and the disk is still not released
	//then use force-detach as a last resort option to detach the disk forcibly from
	//the VM. All writes might not have been flushed when using this detach behavior.
	//This feature is still in preview mode and is not supported for
	//VirtualMachineScaleSet. To force-detach a data disk update toBeDetached to
	//'true' along with setting detachOption: 'ForceDetach'.
	DetachOption *DetachOption_Status `json:"detachOption,omitempty"`

	//DiskIOPSReadWrite: Specifies the Read-Write IOPS for the managed disk when
	//StorageAccountType is UltraSSD_LRS. Returned only for VirtualMachine ScaleSet VM
	//disks. Can be updated only via updates to the VirtualMachine Scale Set.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	//DiskMBpsReadWrite: Specifies the bandwidth in MB per second for the managed disk
	//when StorageAccountType is UltraSSD_LRS. Returned only for VirtualMachine
	//ScaleSet VM disks. Can be updated only via updates to the VirtualMachine Scale
	//Set.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	//DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element
	//can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//Image: The source user image virtual hard disk. The virtual hard disk will be
	//copied before being attached to the virtual machine. If SourceImage is provided,
	//the destination virtual hard drive must not exist.
	Image *VirtualHardDisk_Status `json:"image,omitempty"`

	// +kubebuilder:validation:Required
	//Lun: Specifies the logical unit number of the data disk. This value is used to
	//identify data disks within the VM and therefore must be unique for each data
	//disk attached to a VM.
	Lun int `json:"lun"`

	//ManagedDisk: The managed disk parameters.
	ManagedDisk *ManagedDiskParameters_Status `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//ToBeDetached: Specifies whether the data disk is in process of detachment from
	//the VirtualMachine/VirtualMachineScaleset
	ToBeDetached *bool `json:"toBeDetached,omitempty"`

	//Vhd: The virtual hard disk.
	Vhd *VirtualHardDisk_Status `json:"vhd,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &DataDisk_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (dataDiskStatus *DataDisk_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataDisk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (dataDiskStatus *DataDisk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataDisk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataDisk_StatusARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		dataDiskStatus.Caching = &caching
	}

	// Set property ‘CreateOption’:
	dataDiskStatus.CreateOption = typedInput.CreateOption

	// Set property ‘DetachOption’:
	if typedInput.DetachOption != nil {
		detachOption := *typedInput.DetachOption
		dataDiskStatus.DetachOption = &detachOption
	}

	// Set property ‘DiskIOPSReadWrite’:
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		dataDiskStatus.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		dataDiskStatus.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		dataDiskStatus.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_Status
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		dataDiskStatus.Image = &image
	}

	// Set property ‘Lun’:
	dataDiskStatus.Lun = typedInput.Lun

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters_Status
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		dataDiskStatus.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		dataDiskStatus.Name = &name
	}

	// Set property ‘ToBeDetached’:
	if typedInput.ToBeDetached != nil {
		toBeDetached := *typedInput.ToBeDetached
		dataDiskStatus.ToBeDetached = &toBeDetached
	}

	// Set property ‘Vhd’:
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk_Status
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		dataDiskStatus.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		dataDiskStatus.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromDataDiskStatus populates our DataDisk_Status from the provided source DataDisk_Status
func (dataDiskStatus *DataDisk_Status) AssignPropertiesFromDataDiskStatus(source *v1alpha1api20201201storage.DataDisk_Status) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_Status(*source.Caching)
		dataDiskStatus.Caching = &caching
	} else {
		dataDiskStatus.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		dataDiskStatus.CreateOption = CreateOption_Status(*source.CreateOption)
	} else {
		dataDiskStatus.CreateOption = ""
	}

	// DetachOption
	if source.DetachOption != nil {
		detachOption := DetachOption_Status(*source.DetachOption)
		dataDiskStatus.DetachOption = &detachOption
	} else {
		dataDiskStatus.DetachOption = nil
	}

	// DiskIOPSReadWrite
	dataDiskStatus.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	dataDiskStatus.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	dataDiskStatus.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_Status
		err := image.AssignPropertiesFromVirtualHardDiskStatus(source.Image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesFromVirtualHardDiskStatus()")
		}
		dataDiskStatus.Image = &image
	} else {
		dataDiskStatus.Image = nil
	}

	// Lun
	dataDiskStatus.Lun = genruntime.GetOptionalIntValue(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_Status
		err := managedDisk.AssignPropertiesFromManagedDiskParametersStatus(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesFromManagedDiskParametersStatus()")
		}
		dataDiskStatus.ManagedDisk = &managedDisk
	} else {
		dataDiskStatus.ManagedDisk = nil
	}

	// Name
	dataDiskStatus.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		dataDiskStatus.ToBeDetached = &toBeDetached
	} else {
		dataDiskStatus.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_Status
		err := vhd.AssignPropertiesFromVirtualHardDiskStatus(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "populating Vhd from Vhd, calling AssignPropertiesFromVirtualHardDiskStatus()")
		}
		dataDiskStatus.Vhd = &vhd
	} else {
		dataDiskStatus.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		dataDiskStatus.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		dataDiskStatus.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDataDiskStatus populates the provided destination DataDisk_Status from our DataDisk_Status
func (dataDiskStatus *DataDisk_Status) AssignPropertiesToDataDiskStatus(destination *v1alpha1api20201201storage.DataDisk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if dataDiskStatus.Caching != nil {
		caching := string(*dataDiskStatus.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(dataDiskStatus.CreateOption)
	destination.CreateOption = &createOption

	// DetachOption
	if dataDiskStatus.DetachOption != nil {
		detachOption := string(*dataDiskStatus.DetachOption)
		destination.DetachOption = &detachOption
	} else {
		destination.DetachOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(dataDiskStatus.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(dataDiskStatus.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(dataDiskStatus.DiskSizeGB)

	// Image
	if dataDiskStatus.Image != nil {
		var image v1alpha1api20201201storage.VirtualHardDisk_Status
		err := (*dataDiskStatus.Image).AssignPropertiesToVirtualHardDiskStatus(&image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesToVirtualHardDiskStatus()")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	lun := dataDiskStatus.Lun
	destination.Lun = &lun

	// ManagedDisk
	if dataDiskStatus.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.ManagedDiskParameters_Status
		err := (*dataDiskStatus.ManagedDisk).AssignPropertiesToManagedDiskParametersStatus(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesToManagedDiskParametersStatus()")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(dataDiskStatus.Name)

	// ToBeDetached
	if dataDiskStatus.ToBeDetached != nil {
		toBeDetached := *dataDiskStatus.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if dataDiskStatus.Vhd != nil {
		var vhd v1alpha1api20201201storage.VirtualHardDisk_Status
		err := (*dataDiskStatus.Vhd).AssignPropertiesToVirtualHardDiskStatus(&vhd)
		if err != nil {
			return errors.Wrap(err, "populating Vhd from Vhd, calling AssignPropertiesToVirtualHardDiskStatus()")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if dataDiskStatus.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *dataDiskStatus.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DiskInstanceView_Status struct {
	//EncryptionSettings: Specifies the encryption settings for the OS Disk.
	//Minimum api-version: 2015-06-15
	EncryptionSettings []DiskEncryptionSettings_Status `json:"encryptionSettings,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//Statuses: The resource status information.
	Statuses []InstanceViewStatus_Status `json:"statuses,omitempty"`
}

var _ genruntime.FromARMConverter = &DiskInstanceView_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diskInstanceViewStatus *DiskInstanceView_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskInstanceView_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diskInstanceViewStatus *DiskInstanceView_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiskInstanceView_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskInstanceView_StatusARM, got %T", armInput)
	}

	// Set property ‘EncryptionSettings’:
	for _, item := range typedInput.EncryptionSettings {
		var item1 DiskEncryptionSettings_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		diskInstanceViewStatus.EncryptionSettings = append(diskInstanceViewStatus.EncryptionSettings, item1)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		diskInstanceViewStatus.Name = &name
	}

	// Set property ‘Statuses’:
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		diskInstanceViewStatus.Statuses = append(diskInstanceViewStatus.Statuses, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskInstanceViewStatus populates our DiskInstanceView_Status from the provided source DiskInstanceView_Status
func (diskInstanceViewStatus *DiskInstanceView_Status) AssignPropertiesFromDiskInstanceViewStatus(source *v1alpha1api20201201storage.DiskInstanceView_Status) error {

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		encryptionSettingList := make([]DiskEncryptionSettings_Status, len(source.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range source.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting DiskEncryptionSettings_Status
			err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettingsStatus(&encryptionSettingItem)
			if err != nil {
				return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesFromDiskEncryptionSettingsStatus()")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		diskInstanceViewStatus.EncryptionSettings = encryptionSettingList
	} else {
		diskInstanceViewStatus.EncryptionSettings = nil
	}

	// Name
	diskInstanceViewStatus.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_Status, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_Status
			err := status.AssignPropertiesFromInstanceViewStatusStatus(&statusItem)
			if err != nil {
				return errors.Wrap(err, "populating Statuses from Statuses, calling AssignPropertiesFromInstanceViewStatusStatus()")
			}
			statusList[statusIndex] = status
		}
		diskInstanceViewStatus.Statuses = statusList
	} else {
		diskInstanceViewStatus.Statuses = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskInstanceViewStatus populates the provided destination DiskInstanceView_Status from our DiskInstanceView_Status
func (diskInstanceViewStatus *DiskInstanceView_Status) AssignPropertiesToDiskInstanceViewStatus(destination *v1alpha1api20201201storage.DiskInstanceView_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionSettings
	if diskInstanceViewStatus.EncryptionSettings != nil {
		encryptionSettingList := make([]v1alpha1api20201201storage.DiskEncryptionSettings_Status, len(diskInstanceViewStatus.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range diskInstanceViewStatus.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting v1alpha1api20201201storage.DiskEncryptionSettings_Status
			err := encryptionSettingItem.AssignPropertiesToDiskEncryptionSettingsStatus(&encryptionSetting)
			if err != nil {
				return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesToDiskEncryptionSettingsStatus()")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		destination.EncryptionSettings = encryptionSettingList
	} else {
		destination.EncryptionSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(diskInstanceViewStatus.Name)

	// Statuses
	if diskInstanceViewStatus.Statuses != nil {
		statusList := make([]v1alpha1api20201201storage.InstanceViewStatus_Status, len(diskInstanceViewStatus.Statuses))
		for statusIndex, statusItem := range diskInstanceViewStatus.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v1alpha1api20201201storage.InstanceViewStatus_Status
			err := statusItem.AssignPropertiesToInstanceViewStatusStatus(&status)
			if err != nil {
				return errors.Wrap(err, "populating Statuses from Statuses, calling AssignPropertiesToInstanceViewStatusStatus()")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HardwareProfileStatusVmSize string

const (
	HardwareProfileStatusVmSizeBasicA0          = HardwareProfileStatusVmSize("Basic_A0")
	HardwareProfileStatusVmSizeBasicA1          = HardwareProfileStatusVmSize("Basic_A1")
	HardwareProfileStatusVmSizeBasicA2          = HardwareProfileStatusVmSize("Basic_A2")
	HardwareProfileStatusVmSizeBasicA3          = HardwareProfileStatusVmSize("Basic_A3")
	HardwareProfileStatusVmSizeBasicA4          = HardwareProfileStatusVmSize("Basic_A4")
	HardwareProfileStatusVmSizeStandardA0       = HardwareProfileStatusVmSize("Standard_A0")
	HardwareProfileStatusVmSizeStandardA1       = HardwareProfileStatusVmSize("Standard_A1")
	HardwareProfileStatusVmSizeStandardA10      = HardwareProfileStatusVmSize("Standard_A10")
	HardwareProfileStatusVmSizeStandardA11      = HardwareProfileStatusVmSize("Standard_A11")
	HardwareProfileStatusVmSizeStandardA1V2     = HardwareProfileStatusVmSize("Standard_A1_v2")
	HardwareProfileStatusVmSizeStandardA2       = HardwareProfileStatusVmSize("Standard_A2")
	HardwareProfileStatusVmSizeStandardA2MV2    = HardwareProfileStatusVmSize("Standard_A2m_v2")
	HardwareProfileStatusVmSizeStandardA2V2     = HardwareProfileStatusVmSize("Standard_A2_v2")
	HardwareProfileStatusVmSizeStandardA3       = HardwareProfileStatusVmSize("Standard_A3")
	HardwareProfileStatusVmSizeStandardA4       = HardwareProfileStatusVmSize("Standard_A4")
	HardwareProfileStatusVmSizeStandardA4MV2    = HardwareProfileStatusVmSize("Standard_A4m_v2")
	HardwareProfileStatusVmSizeStandardA4V2     = HardwareProfileStatusVmSize("Standard_A4_v2")
	HardwareProfileStatusVmSizeStandardA5       = HardwareProfileStatusVmSize("Standard_A5")
	HardwareProfileStatusVmSizeStandardA6       = HardwareProfileStatusVmSize("Standard_A6")
	HardwareProfileStatusVmSizeStandardA7       = HardwareProfileStatusVmSize("Standard_A7")
	HardwareProfileStatusVmSizeStandardA8       = HardwareProfileStatusVmSize("Standard_A8")
	HardwareProfileStatusVmSizeStandardA8MV2    = HardwareProfileStatusVmSize("Standard_A8m_v2")
	HardwareProfileStatusVmSizeStandardA8V2     = HardwareProfileStatusVmSize("Standard_A8_v2")
	HardwareProfileStatusVmSizeStandardA9       = HardwareProfileStatusVmSize("Standard_A9")
	HardwareProfileStatusVmSizeStandardB1Ms     = HardwareProfileStatusVmSize("Standard_B1ms")
	HardwareProfileStatusVmSizeStandardB1S      = HardwareProfileStatusVmSize("Standard_B1s")
	HardwareProfileStatusVmSizeStandardB2Ms     = HardwareProfileStatusVmSize("Standard_B2ms")
	HardwareProfileStatusVmSizeStandardB2S      = HardwareProfileStatusVmSize("Standard_B2s")
	HardwareProfileStatusVmSizeStandardB4Ms     = HardwareProfileStatusVmSize("Standard_B4ms")
	HardwareProfileStatusVmSizeStandardB8Ms     = HardwareProfileStatusVmSize("Standard_B8ms")
	HardwareProfileStatusVmSizeStandardD1       = HardwareProfileStatusVmSize("Standard_D1")
	HardwareProfileStatusVmSizeStandardD11      = HardwareProfileStatusVmSize("Standard_D11")
	HardwareProfileStatusVmSizeStandardD11V2    = HardwareProfileStatusVmSize("Standard_D11_v2")
	HardwareProfileStatusVmSizeStandardD12      = HardwareProfileStatusVmSize("Standard_D12")
	HardwareProfileStatusVmSizeStandardD12V2    = HardwareProfileStatusVmSize("Standard_D12_v2")
	HardwareProfileStatusVmSizeStandardD13      = HardwareProfileStatusVmSize("Standard_D13")
	HardwareProfileStatusVmSizeStandardD13V2    = HardwareProfileStatusVmSize("Standard_D13_v2")
	HardwareProfileStatusVmSizeStandardD14      = HardwareProfileStatusVmSize("Standard_D14")
	HardwareProfileStatusVmSizeStandardD14V2    = HardwareProfileStatusVmSize("Standard_D14_v2")
	HardwareProfileStatusVmSizeStandardD15V2    = HardwareProfileStatusVmSize("Standard_D15_v2")
	HardwareProfileStatusVmSizeStandardD16SV3   = HardwareProfileStatusVmSize("Standard_D16s_v3")
	HardwareProfileStatusVmSizeStandardD16V3    = HardwareProfileStatusVmSize("Standard_D16_v3")
	HardwareProfileStatusVmSizeStandardD1V2     = HardwareProfileStatusVmSize("Standard_D1_v2")
	HardwareProfileStatusVmSizeStandardD2       = HardwareProfileStatusVmSize("Standard_D2")
	HardwareProfileStatusVmSizeStandardD2SV3    = HardwareProfileStatusVmSize("Standard_D2s_v3")
	HardwareProfileStatusVmSizeStandardD2V2     = HardwareProfileStatusVmSize("Standard_D2_v2")
	HardwareProfileStatusVmSizeStandardD2V3     = HardwareProfileStatusVmSize("Standard_D2_v3")
	HardwareProfileStatusVmSizeStandardD3       = HardwareProfileStatusVmSize("Standard_D3")
	HardwareProfileStatusVmSizeStandardD32SV3   = HardwareProfileStatusVmSize("Standard_D32s_v3")
	HardwareProfileStatusVmSizeStandardD32V3    = HardwareProfileStatusVmSize("Standard_D32_v3")
	HardwareProfileStatusVmSizeStandardD3V2     = HardwareProfileStatusVmSize("Standard_D3_v2")
	HardwareProfileStatusVmSizeStandardD4       = HardwareProfileStatusVmSize("Standard_D4")
	HardwareProfileStatusVmSizeStandardD4SV3    = HardwareProfileStatusVmSize("Standard_D4s_v3")
	HardwareProfileStatusVmSizeStandardD4V2     = HardwareProfileStatusVmSize("Standard_D4_v2")
	HardwareProfileStatusVmSizeStandardD4V3     = HardwareProfileStatusVmSize("Standard_D4_v3")
	HardwareProfileStatusVmSizeStandardD5V2     = HardwareProfileStatusVmSize("Standard_D5_v2")
	HardwareProfileStatusVmSizeStandardD64SV3   = HardwareProfileStatusVmSize("Standard_D64s_v3")
	HardwareProfileStatusVmSizeStandardD64V3    = HardwareProfileStatusVmSize("Standard_D64_v3")
	HardwareProfileStatusVmSizeStandardD8SV3    = HardwareProfileStatusVmSize("Standard_D8s_v3")
	HardwareProfileStatusVmSizeStandardD8V3     = HardwareProfileStatusVmSize("Standard_D8_v3")
	HardwareProfileStatusVmSizeStandardDS1      = HardwareProfileStatusVmSize("Standard_DS1")
	HardwareProfileStatusVmSizeStandardDS11     = HardwareProfileStatusVmSize("Standard_DS11")
	HardwareProfileStatusVmSizeStandardDS11V2   = HardwareProfileStatusVmSize("Standard_DS11_v2")
	HardwareProfileStatusVmSizeStandardDS12     = HardwareProfileStatusVmSize("Standard_DS12")
	HardwareProfileStatusVmSizeStandardDS12V2   = HardwareProfileStatusVmSize("Standard_DS12_v2")
	HardwareProfileStatusVmSizeStandardDS13     = HardwareProfileStatusVmSize("Standard_DS13")
	HardwareProfileStatusVmSizeStandardDS132V2  = HardwareProfileStatusVmSize("Standard_DS13-2_v2")
	HardwareProfileStatusVmSizeStandardDS134V2  = HardwareProfileStatusVmSize("Standard_DS13-4_v2")
	HardwareProfileStatusVmSizeStandardDS13V2   = HardwareProfileStatusVmSize("Standard_DS13_v2")
	HardwareProfileStatusVmSizeStandardDS14     = HardwareProfileStatusVmSize("Standard_DS14")
	HardwareProfileStatusVmSizeStandardDS144V2  = HardwareProfileStatusVmSize("Standard_DS14-4_v2")
	HardwareProfileStatusVmSizeStandardDS148V2  = HardwareProfileStatusVmSize("Standard_DS14-8_v2")
	HardwareProfileStatusVmSizeStandardDS14V2   = HardwareProfileStatusVmSize("Standard_DS14_v2")
	HardwareProfileStatusVmSizeStandardDS15V2   = HardwareProfileStatusVmSize("Standard_DS15_v2")
	HardwareProfileStatusVmSizeStandardDS1V2    = HardwareProfileStatusVmSize("Standard_DS1_v2")
	HardwareProfileStatusVmSizeStandardDS2      = HardwareProfileStatusVmSize("Standard_DS2")
	HardwareProfileStatusVmSizeStandardDS2V2    = HardwareProfileStatusVmSize("Standard_DS2_v2")
	HardwareProfileStatusVmSizeStandardDS3      = HardwareProfileStatusVmSize("Standard_DS3")
	HardwareProfileStatusVmSizeStandardDS3V2    = HardwareProfileStatusVmSize("Standard_DS3_v2")
	HardwareProfileStatusVmSizeStandardDS4      = HardwareProfileStatusVmSize("Standard_DS4")
	HardwareProfileStatusVmSizeStandardDS4V2    = HardwareProfileStatusVmSize("Standard_DS4_v2")
	HardwareProfileStatusVmSizeStandardDS5V2    = HardwareProfileStatusVmSize("Standard_DS5_v2")
	HardwareProfileStatusVmSizeStandardE16SV3   = HardwareProfileStatusVmSize("Standard_E16s_v3")
	HardwareProfileStatusVmSizeStandardE16V3    = HardwareProfileStatusVmSize("Standard_E16_v3")
	HardwareProfileStatusVmSizeStandardE2SV3    = HardwareProfileStatusVmSize("Standard_E2s_v3")
	HardwareProfileStatusVmSizeStandardE2V3     = HardwareProfileStatusVmSize("Standard_E2_v3")
	HardwareProfileStatusVmSizeStandardE3216V3  = HardwareProfileStatusVmSize("Standard_E32-16_v3")
	HardwareProfileStatusVmSizeStandardE328SV3  = HardwareProfileStatusVmSize("Standard_E32-8s_v3")
	HardwareProfileStatusVmSizeStandardE32SV3   = HardwareProfileStatusVmSize("Standard_E32s_v3")
	HardwareProfileStatusVmSizeStandardE32V3    = HardwareProfileStatusVmSize("Standard_E32_v3")
	HardwareProfileStatusVmSizeStandardE4SV3    = HardwareProfileStatusVmSize("Standard_E4s_v3")
	HardwareProfileStatusVmSizeStandardE4V3     = HardwareProfileStatusVmSize("Standard_E4_v3")
	HardwareProfileStatusVmSizeStandardE6416SV3 = HardwareProfileStatusVmSize("Standard_E64-16s_v3")
	HardwareProfileStatusVmSizeStandardE6432SV3 = HardwareProfileStatusVmSize("Standard_E64-32s_v3")
	HardwareProfileStatusVmSizeStandardE64SV3   = HardwareProfileStatusVmSize("Standard_E64s_v3")
	HardwareProfileStatusVmSizeStandardE64V3    = HardwareProfileStatusVmSize("Standard_E64_v3")
	HardwareProfileStatusVmSizeStandardE8SV3    = HardwareProfileStatusVmSize("Standard_E8s_v3")
	HardwareProfileStatusVmSizeStandardE8V3     = HardwareProfileStatusVmSize("Standard_E8_v3")
	HardwareProfileStatusVmSizeStandardF1       = HardwareProfileStatusVmSize("Standard_F1")
	HardwareProfileStatusVmSizeStandardF16      = HardwareProfileStatusVmSize("Standard_F16")
	HardwareProfileStatusVmSizeStandardF16S     = HardwareProfileStatusVmSize("Standard_F16s")
	HardwareProfileStatusVmSizeStandardF16SV2   = HardwareProfileStatusVmSize("Standard_F16s_v2")
	HardwareProfileStatusVmSizeStandardF1S      = HardwareProfileStatusVmSize("Standard_F1s")
	HardwareProfileStatusVmSizeStandardF2       = HardwareProfileStatusVmSize("Standard_F2")
	HardwareProfileStatusVmSizeStandardF2S      = HardwareProfileStatusVmSize("Standard_F2s")
	HardwareProfileStatusVmSizeStandardF2SV2    = HardwareProfileStatusVmSize("Standard_F2s_v2")
	HardwareProfileStatusVmSizeStandardF32SV2   = HardwareProfileStatusVmSize("Standard_F32s_v2")
	HardwareProfileStatusVmSizeStandardF4       = HardwareProfileStatusVmSize("Standard_F4")
	HardwareProfileStatusVmSizeStandardF4S      = HardwareProfileStatusVmSize("Standard_F4s")
	HardwareProfileStatusVmSizeStandardF4SV2    = HardwareProfileStatusVmSize("Standard_F4s_v2")
	HardwareProfileStatusVmSizeStandardF64SV2   = HardwareProfileStatusVmSize("Standard_F64s_v2")
	HardwareProfileStatusVmSizeStandardF72SV2   = HardwareProfileStatusVmSize("Standard_F72s_v2")
	HardwareProfileStatusVmSizeStandardF8       = HardwareProfileStatusVmSize("Standard_F8")
	HardwareProfileStatusVmSizeStandardF8S      = HardwareProfileStatusVmSize("Standard_F8s")
	HardwareProfileStatusVmSizeStandardF8SV2    = HardwareProfileStatusVmSize("Standard_F8s_v2")
	HardwareProfileStatusVmSizeStandardG1       = HardwareProfileStatusVmSize("Standard_G1")
	HardwareProfileStatusVmSizeStandardG2       = HardwareProfileStatusVmSize("Standard_G2")
	HardwareProfileStatusVmSizeStandardG3       = HardwareProfileStatusVmSize("Standard_G3")
	HardwareProfileStatusVmSizeStandardG4       = HardwareProfileStatusVmSize("Standard_G4")
	HardwareProfileStatusVmSizeStandardG5       = HardwareProfileStatusVmSize("Standard_G5")
	HardwareProfileStatusVmSizeStandardGS1      = HardwareProfileStatusVmSize("Standard_GS1")
	HardwareProfileStatusVmSizeStandardGS2      = HardwareProfileStatusVmSize("Standard_GS2")
	HardwareProfileStatusVmSizeStandardGS3      = HardwareProfileStatusVmSize("Standard_GS3")
	HardwareProfileStatusVmSizeStandardGS4      = HardwareProfileStatusVmSize("Standard_GS4")
	HardwareProfileStatusVmSizeStandardGS44     = HardwareProfileStatusVmSize("Standard_GS4-4")
	HardwareProfileStatusVmSizeStandardGS48     = HardwareProfileStatusVmSize("Standard_GS4-8")
	HardwareProfileStatusVmSizeStandardGS5      = HardwareProfileStatusVmSize("Standard_GS5")
	HardwareProfileStatusVmSizeStandardGS516    = HardwareProfileStatusVmSize("Standard_GS5-16")
	HardwareProfileStatusVmSizeStandardGS58     = HardwareProfileStatusVmSize("Standard_GS5-8")
	HardwareProfileStatusVmSizeStandardH16      = HardwareProfileStatusVmSize("Standard_H16")
	HardwareProfileStatusVmSizeStandardH16M     = HardwareProfileStatusVmSize("Standard_H16m")
	HardwareProfileStatusVmSizeStandardH16Mr    = HardwareProfileStatusVmSize("Standard_H16mr")
	HardwareProfileStatusVmSizeStandardH16R     = HardwareProfileStatusVmSize("Standard_H16r")
	HardwareProfileStatusVmSizeStandardH8       = HardwareProfileStatusVmSize("Standard_H8")
	HardwareProfileStatusVmSizeStandardH8M      = HardwareProfileStatusVmSize("Standard_H8m")
	HardwareProfileStatusVmSizeStandardL16S     = HardwareProfileStatusVmSize("Standard_L16s")
	HardwareProfileStatusVmSizeStandardL32S     = HardwareProfileStatusVmSize("Standard_L32s")
	HardwareProfileStatusVmSizeStandardL4S      = HardwareProfileStatusVmSize("Standard_L4s")
	HardwareProfileStatusVmSizeStandardL8S      = HardwareProfileStatusVmSize("Standard_L8s")
	HardwareProfileStatusVmSizeStandardM12832Ms = HardwareProfileStatusVmSize("Standard_M128-32ms")
	HardwareProfileStatusVmSizeStandardM12864Ms = HardwareProfileStatusVmSize("Standard_M128-64ms")
	HardwareProfileStatusVmSizeStandardM128Ms   = HardwareProfileStatusVmSize("Standard_M128ms")
	HardwareProfileStatusVmSizeStandardM128S    = HardwareProfileStatusVmSize("Standard_M128s")
	HardwareProfileStatusVmSizeStandardM6416Ms  = HardwareProfileStatusVmSize("Standard_M64-16ms")
	HardwareProfileStatusVmSizeStandardM6432Ms  = HardwareProfileStatusVmSize("Standard_M64-32ms")
	HardwareProfileStatusVmSizeStandardM64Ms    = HardwareProfileStatusVmSize("Standard_M64ms")
	HardwareProfileStatusVmSizeStandardM64S     = HardwareProfileStatusVmSize("Standard_M64s")
	HardwareProfileStatusVmSizeStandardNC12     = HardwareProfileStatusVmSize("Standard_NC12")
	HardwareProfileStatusVmSizeStandardNC12SV2  = HardwareProfileStatusVmSize("Standard_NC12s_v2")
	HardwareProfileStatusVmSizeStandardNC12SV3  = HardwareProfileStatusVmSize("Standard_NC12s_v3")
	HardwareProfileStatusVmSizeStandardNC24     = HardwareProfileStatusVmSize("Standard_NC24")
	HardwareProfileStatusVmSizeStandardNC24R    = HardwareProfileStatusVmSize("Standard_NC24r")
	HardwareProfileStatusVmSizeStandardNC24RsV2 = HardwareProfileStatusVmSize("Standard_NC24rs_v2")
	HardwareProfileStatusVmSizeStandardNC24RsV3 = HardwareProfileStatusVmSize("Standard_NC24rs_v3")
	HardwareProfileStatusVmSizeStandardNC24SV2  = HardwareProfileStatusVmSize("Standard_NC24s_v2")
	HardwareProfileStatusVmSizeStandardNC24SV3  = HardwareProfileStatusVmSize("Standard_NC24s_v3")
	HardwareProfileStatusVmSizeStandardNC6      = HardwareProfileStatusVmSize("Standard_NC6")
	HardwareProfileStatusVmSizeStandardNC6SV2   = HardwareProfileStatusVmSize("Standard_NC6s_v2")
	HardwareProfileStatusVmSizeStandardNC6SV3   = HardwareProfileStatusVmSize("Standard_NC6s_v3")
	HardwareProfileStatusVmSizeStandardND12S    = HardwareProfileStatusVmSize("Standard_ND12s")
	HardwareProfileStatusVmSizeStandardND24Rs   = HardwareProfileStatusVmSize("Standard_ND24rs")
	HardwareProfileStatusVmSizeStandardND24S    = HardwareProfileStatusVmSize("Standard_ND24s")
	HardwareProfileStatusVmSizeStandardND6S     = HardwareProfileStatusVmSize("Standard_ND6s")
	HardwareProfileStatusVmSizeStandardNV12     = HardwareProfileStatusVmSize("Standard_NV12")
	HardwareProfileStatusVmSizeStandardNV24     = HardwareProfileStatusVmSize("Standard_NV24")
	HardwareProfileStatusVmSizeStandardNV6      = HardwareProfileStatusVmSize("Standard_NV6")
)

// +kubebuilder:validation:Enum={"Basic_A0","Basic_A1","Basic_A2","Basic_A3","Basic_A4","Standard_A0","Standard_A1","Standard_A10","Standard_A11","Standard_A1_v2","Standard_A2","Standard_A2m_v2","Standard_A2_v2","Standard_A3","Standard_A4","Standard_A4m_v2","Standard_A4_v2","Standard_A5","Standard_A6","Standard_A7","Standard_A8","Standard_A8m_v2","Standard_A8_v2","Standard_A9","Standard_B1ms","Standard_B1s","Standard_B2ms","Standard_B2s","Standard_B4ms","Standard_B8ms","Standard_D1","Standard_D11","Standard_D11_v2","Standard_D12","Standard_D12_v2","Standard_D13","Standard_D13_v2","Standard_D14","Standard_D14_v2","Standard_D15_v2","Standard_D16s_v3","Standard_D16_v3","Standard_D1_v2","Standard_D2","Standard_D2s_v3","Standard_D2_v2","Standard_D2_v3","Standard_D3","Standard_D32s_v3","Standard_D32_v3","Standard_D3_v2","Standard_D4","Standard_D4s_v3","Standard_D4_v2","Standard_D4_v3","Standard_D5_v2","Standard_D64s_v3","Standard_D64_v3","Standard_D8s_v3","Standard_D8_v3","Standard_DS1","Standard_DS11","Standard_DS11_v2","Standard_DS12","Standard_DS12_v2","Standard_DS13","Standard_DS13-2_v2","Standard_DS13-4_v2","Standard_DS13_v2","Standard_DS14","Standard_DS14-4_v2","Standard_DS14-8_v2","Standard_DS14_v2","Standard_DS15_v2","Standard_DS1_v2","Standard_DS2","Standard_DS2_v2","Standard_DS3","Standard_DS3_v2","Standard_DS4","Standard_DS4_v2","Standard_DS5_v2","Standard_E16s_v3","Standard_E16_v3","Standard_E2s_v3","Standard_E2_v3","Standard_E32-16_v3","Standard_E32-8s_v3","Standard_E32s_v3","Standard_E32_v3","Standard_E4s_v3","Standard_E4_v3","Standard_E64-16s_v3","Standard_E64-32s_v3","Standard_E64s_v3","Standard_E64_v3","Standard_E8s_v3","Standard_E8_v3","Standard_F1","Standard_F16","Standard_F16s","Standard_F16s_v2","Standard_F1s","Standard_F2","Standard_F2s","Standard_F2s_v2","Standard_F32s_v2","Standard_F4","Standard_F4s","Standard_F4s_v2","Standard_F64s_v2","Standard_F72s_v2","Standard_F8","Standard_F8s","Standard_F8s_v2","Standard_G1","Standard_G2","Standard_G3","Standard_G4","Standard_G5","Standard_GS1","Standard_GS2","Standard_GS3","Standard_GS4","Standard_GS4-4","Standard_GS4-8","Standard_GS5","Standard_GS5-16","Standard_GS5-8","Standard_H16","Standard_H16m","Standard_H16mr","Standard_H16r","Standard_H8","Standard_H8m","Standard_L16s","Standard_L32s","Standard_L4s","Standard_L8s","Standard_M128-32ms","Standard_M128-64ms","Standard_M128ms","Standard_M128s","Standard_M64-16ms","Standard_M64-32ms","Standard_M64ms","Standard_M64s","Standard_NC12","Standard_NC12s_v2","Standard_NC12s_v3","Standard_NC24","Standard_NC24r","Standard_NC24rs_v2","Standard_NC24rs_v3","Standard_NC24s_v2","Standard_NC24s_v3","Standard_NC6","Standard_NC6s_v2","Standard_NC6s_v3","Standard_ND12s","Standard_ND24rs","Standard_ND24s","Standard_ND6s","Standard_NV12","Standard_NV24","Standard_NV6"}
type HardwareProfileVmSize string

const (
	HardwareProfileVmSizeBasicA0          = HardwareProfileVmSize("Basic_A0")
	HardwareProfileVmSizeBasicA1          = HardwareProfileVmSize("Basic_A1")
	HardwareProfileVmSizeBasicA2          = HardwareProfileVmSize("Basic_A2")
	HardwareProfileVmSizeBasicA3          = HardwareProfileVmSize("Basic_A3")
	HardwareProfileVmSizeBasicA4          = HardwareProfileVmSize("Basic_A4")
	HardwareProfileVmSizeStandardA0       = HardwareProfileVmSize("Standard_A0")
	HardwareProfileVmSizeStandardA1       = HardwareProfileVmSize("Standard_A1")
	HardwareProfileVmSizeStandardA10      = HardwareProfileVmSize("Standard_A10")
	HardwareProfileVmSizeStandardA11      = HardwareProfileVmSize("Standard_A11")
	HardwareProfileVmSizeStandardA1V2     = HardwareProfileVmSize("Standard_A1_v2")
	HardwareProfileVmSizeStandardA2       = HardwareProfileVmSize("Standard_A2")
	HardwareProfileVmSizeStandardA2MV2    = HardwareProfileVmSize("Standard_A2m_v2")
	HardwareProfileVmSizeStandardA2V2     = HardwareProfileVmSize("Standard_A2_v2")
	HardwareProfileVmSizeStandardA3       = HardwareProfileVmSize("Standard_A3")
	HardwareProfileVmSizeStandardA4       = HardwareProfileVmSize("Standard_A4")
	HardwareProfileVmSizeStandardA4MV2    = HardwareProfileVmSize("Standard_A4m_v2")
	HardwareProfileVmSizeStandardA4V2     = HardwareProfileVmSize("Standard_A4_v2")
	HardwareProfileVmSizeStandardA5       = HardwareProfileVmSize("Standard_A5")
	HardwareProfileVmSizeStandardA6       = HardwareProfileVmSize("Standard_A6")
	HardwareProfileVmSizeStandardA7       = HardwareProfileVmSize("Standard_A7")
	HardwareProfileVmSizeStandardA8       = HardwareProfileVmSize("Standard_A8")
	HardwareProfileVmSizeStandardA8MV2    = HardwareProfileVmSize("Standard_A8m_v2")
	HardwareProfileVmSizeStandardA8V2     = HardwareProfileVmSize("Standard_A8_v2")
	HardwareProfileVmSizeStandardA9       = HardwareProfileVmSize("Standard_A9")
	HardwareProfileVmSizeStandardB1Ms     = HardwareProfileVmSize("Standard_B1ms")
	HardwareProfileVmSizeStandardB1S      = HardwareProfileVmSize("Standard_B1s")
	HardwareProfileVmSizeStandardB2Ms     = HardwareProfileVmSize("Standard_B2ms")
	HardwareProfileVmSizeStandardB2S      = HardwareProfileVmSize("Standard_B2s")
	HardwareProfileVmSizeStandardB4Ms     = HardwareProfileVmSize("Standard_B4ms")
	HardwareProfileVmSizeStandardB8Ms     = HardwareProfileVmSize("Standard_B8ms")
	HardwareProfileVmSizeStandardD1       = HardwareProfileVmSize("Standard_D1")
	HardwareProfileVmSizeStandardD11      = HardwareProfileVmSize("Standard_D11")
	HardwareProfileVmSizeStandardD11V2    = HardwareProfileVmSize("Standard_D11_v2")
	HardwareProfileVmSizeStandardD12      = HardwareProfileVmSize("Standard_D12")
	HardwareProfileVmSizeStandardD12V2    = HardwareProfileVmSize("Standard_D12_v2")
	HardwareProfileVmSizeStandardD13      = HardwareProfileVmSize("Standard_D13")
	HardwareProfileVmSizeStandardD13V2    = HardwareProfileVmSize("Standard_D13_v2")
	HardwareProfileVmSizeStandardD14      = HardwareProfileVmSize("Standard_D14")
	HardwareProfileVmSizeStandardD14V2    = HardwareProfileVmSize("Standard_D14_v2")
	HardwareProfileVmSizeStandardD15V2    = HardwareProfileVmSize("Standard_D15_v2")
	HardwareProfileVmSizeStandardD16SV3   = HardwareProfileVmSize("Standard_D16s_v3")
	HardwareProfileVmSizeStandardD16V3    = HardwareProfileVmSize("Standard_D16_v3")
	HardwareProfileVmSizeStandardD1V2     = HardwareProfileVmSize("Standard_D1_v2")
	HardwareProfileVmSizeStandardD2       = HardwareProfileVmSize("Standard_D2")
	HardwareProfileVmSizeStandardD2SV3    = HardwareProfileVmSize("Standard_D2s_v3")
	HardwareProfileVmSizeStandardD2V2     = HardwareProfileVmSize("Standard_D2_v2")
	HardwareProfileVmSizeStandardD2V3     = HardwareProfileVmSize("Standard_D2_v3")
	HardwareProfileVmSizeStandardD3       = HardwareProfileVmSize("Standard_D3")
	HardwareProfileVmSizeStandardD32SV3   = HardwareProfileVmSize("Standard_D32s_v3")
	HardwareProfileVmSizeStandardD32V3    = HardwareProfileVmSize("Standard_D32_v3")
	HardwareProfileVmSizeStandardD3V2     = HardwareProfileVmSize("Standard_D3_v2")
	HardwareProfileVmSizeStandardD4       = HardwareProfileVmSize("Standard_D4")
	HardwareProfileVmSizeStandardD4SV3    = HardwareProfileVmSize("Standard_D4s_v3")
	HardwareProfileVmSizeStandardD4V2     = HardwareProfileVmSize("Standard_D4_v2")
	HardwareProfileVmSizeStandardD4V3     = HardwareProfileVmSize("Standard_D4_v3")
	HardwareProfileVmSizeStandardD5V2     = HardwareProfileVmSize("Standard_D5_v2")
	HardwareProfileVmSizeStandardD64SV3   = HardwareProfileVmSize("Standard_D64s_v3")
	HardwareProfileVmSizeStandardD64V3    = HardwareProfileVmSize("Standard_D64_v3")
	HardwareProfileVmSizeStandardD8SV3    = HardwareProfileVmSize("Standard_D8s_v3")
	HardwareProfileVmSizeStandardD8V3     = HardwareProfileVmSize("Standard_D8_v3")
	HardwareProfileVmSizeStandardDS1      = HardwareProfileVmSize("Standard_DS1")
	HardwareProfileVmSizeStandardDS11     = HardwareProfileVmSize("Standard_DS11")
	HardwareProfileVmSizeStandardDS11V2   = HardwareProfileVmSize("Standard_DS11_v2")
	HardwareProfileVmSizeStandardDS12     = HardwareProfileVmSize("Standard_DS12")
	HardwareProfileVmSizeStandardDS12V2   = HardwareProfileVmSize("Standard_DS12_v2")
	HardwareProfileVmSizeStandardDS13     = HardwareProfileVmSize("Standard_DS13")
	HardwareProfileVmSizeStandardDS132V2  = HardwareProfileVmSize("Standard_DS13-2_v2")
	HardwareProfileVmSizeStandardDS134V2  = HardwareProfileVmSize("Standard_DS13-4_v2")
	HardwareProfileVmSizeStandardDS13V2   = HardwareProfileVmSize("Standard_DS13_v2")
	HardwareProfileVmSizeStandardDS14     = HardwareProfileVmSize("Standard_DS14")
	HardwareProfileVmSizeStandardDS144V2  = HardwareProfileVmSize("Standard_DS14-4_v2")
	HardwareProfileVmSizeStandardDS148V2  = HardwareProfileVmSize("Standard_DS14-8_v2")
	HardwareProfileVmSizeStandardDS14V2   = HardwareProfileVmSize("Standard_DS14_v2")
	HardwareProfileVmSizeStandardDS15V2   = HardwareProfileVmSize("Standard_DS15_v2")
	HardwareProfileVmSizeStandardDS1V2    = HardwareProfileVmSize("Standard_DS1_v2")
	HardwareProfileVmSizeStandardDS2      = HardwareProfileVmSize("Standard_DS2")
	HardwareProfileVmSizeStandardDS2V2    = HardwareProfileVmSize("Standard_DS2_v2")
	HardwareProfileVmSizeStandardDS3      = HardwareProfileVmSize("Standard_DS3")
	HardwareProfileVmSizeStandardDS3V2    = HardwareProfileVmSize("Standard_DS3_v2")
	HardwareProfileVmSizeStandardDS4      = HardwareProfileVmSize("Standard_DS4")
	HardwareProfileVmSizeStandardDS4V2    = HardwareProfileVmSize("Standard_DS4_v2")
	HardwareProfileVmSizeStandardDS5V2    = HardwareProfileVmSize("Standard_DS5_v2")
	HardwareProfileVmSizeStandardE16SV3   = HardwareProfileVmSize("Standard_E16s_v3")
	HardwareProfileVmSizeStandardE16V3    = HardwareProfileVmSize("Standard_E16_v3")
	HardwareProfileVmSizeStandardE2SV3    = HardwareProfileVmSize("Standard_E2s_v3")
	HardwareProfileVmSizeStandardE2V3     = HardwareProfileVmSize("Standard_E2_v3")
	HardwareProfileVmSizeStandardE3216V3  = HardwareProfileVmSize("Standard_E32-16_v3")
	HardwareProfileVmSizeStandardE328SV3  = HardwareProfileVmSize("Standard_E32-8s_v3")
	HardwareProfileVmSizeStandardE32SV3   = HardwareProfileVmSize("Standard_E32s_v3")
	HardwareProfileVmSizeStandardE32V3    = HardwareProfileVmSize("Standard_E32_v3")
	HardwareProfileVmSizeStandardE4SV3    = HardwareProfileVmSize("Standard_E4s_v3")
	HardwareProfileVmSizeStandardE4V3     = HardwareProfileVmSize("Standard_E4_v3")
	HardwareProfileVmSizeStandardE6416SV3 = HardwareProfileVmSize("Standard_E64-16s_v3")
	HardwareProfileVmSizeStandardE6432SV3 = HardwareProfileVmSize("Standard_E64-32s_v3")
	HardwareProfileVmSizeStandardE64SV3   = HardwareProfileVmSize("Standard_E64s_v3")
	HardwareProfileVmSizeStandardE64V3    = HardwareProfileVmSize("Standard_E64_v3")
	HardwareProfileVmSizeStandardE8SV3    = HardwareProfileVmSize("Standard_E8s_v3")
	HardwareProfileVmSizeStandardE8V3     = HardwareProfileVmSize("Standard_E8_v3")
	HardwareProfileVmSizeStandardF1       = HardwareProfileVmSize("Standard_F1")
	HardwareProfileVmSizeStandardF16      = HardwareProfileVmSize("Standard_F16")
	HardwareProfileVmSizeStandardF16S     = HardwareProfileVmSize("Standard_F16s")
	HardwareProfileVmSizeStandardF16SV2   = HardwareProfileVmSize("Standard_F16s_v2")
	HardwareProfileVmSizeStandardF1S      = HardwareProfileVmSize("Standard_F1s")
	HardwareProfileVmSizeStandardF2       = HardwareProfileVmSize("Standard_F2")
	HardwareProfileVmSizeStandardF2S      = HardwareProfileVmSize("Standard_F2s")
	HardwareProfileVmSizeStandardF2SV2    = HardwareProfileVmSize("Standard_F2s_v2")
	HardwareProfileVmSizeStandardF32SV2   = HardwareProfileVmSize("Standard_F32s_v2")
	HardwareProfileVmSizeStandardF4       = HardwareProfileVmSize("Standard_F4")
	HardwareProfileVmSizeStandardF4S      = HardwareProfileVmSize("Standard_F4s")
	HardwareProfileVmSizeStandardF4SV2    = HardwareProfileVmSize("Standard_F4s_v2")
	HardwareProfileVmSizeStandardF64SV2   = HardwareProfileVmSize("Standard_F64s_v2")
	HardwareProfileVmSizeStandardF72SV2   = HardwareProfileVmSize("Standard_F72s_v2")
	HardwareProfileVmSizeStandardF8       = HardwareProfileVmSize("Standard_F8")
	HardwareProfileVmSizeStandardF8S      = HardwareProfileVmSize("Standard_F8s")
	HardwareProfileVmSizeStandardF8SV2    = HardwareProfileVmSize("Standard_F8s_v2")
	HardwareProfileVmSizeStandardG1       = HardwareProfileVmSize("Standard_G1")
	HardwareProfileVmSizeStandardG2       = HardwareProfileVmSize("Standard_G2")
	HardwareProfileVmSizeStandardG3       = HardwareProfileVmSize("Standard_G3")
	HardwareProfileVmSizeStandardG4       = HardwareProfileVmSize("Standard_G4")
	HardwareProfileVmSizeStandardG5       = HardwareProfileVmSize("Standard_G5")
	HardwareProfileVmSizeStandardGS1      = HardwareProfileVmSize("Standard_GS1")
	HardwareProfileVmSizeStandardGS2      = HardwareProfileVmSize("Standard_GS2")
	HardwareProfileVmSizeStandardGS3      = HardwareProfileVmSize("Standard_GS3")
	HardwareProfileVmSizeStandardGS4      = HardwareProfileVmSize("Standard_GS4")
	HardwareProfileVmSizeStandardGS44     = HardwareProfileVmSize("Standard_GS4-4")
	HardwareProfileVmSizeStandardGS48     = HardwareProfileVmSize("Standard_GS4-8")
	HardwareProfileVmSizeStandardGS5      = HardwareProfileVmSize("Standard_GS5")
	HardwareProfileVmSizeStandardGS516    = HardwareProfileVmSize("Standard_GS5-16")
	HardwareProfileVmSizeStandardGS58     = HardwareProfileVmSize("Standard_GS5-8")
	HardwareProfileVmSizeStandardH16      = HardwareProfileVmSize("Standard_H16")
	HardwareProfileVmSizeStandardH16M     = HardwareProfileVmSize("Standard_H16m")
	HardwareProfileVmSizeStandardH16Mr    = HardwareProfileVmSize("Standard_H16mr")
	HardwareProfileVmSizeStandardH16R     = HardwareProfileVmSize("Standard_H16r")
	HardwareProfileVmSizeStandardH8       = HardwareProfileVmSize("Standard_H8")
	HardwareProfileVmSizeStandardH8M      = HardwareProfileVmSize("Standard_H8m")
	HardwareProfileVmSizeStandardL16S     = HardwareProfileVmSize("Standard_L16s")
	HardwareProfileVmSizeStandardL32S     = HardwareProfileVmSize("Standard_L32s")
	HardwareProfileVmSizeStandardL4S      = HardwareProfileVmSize("Standard_L4s")
	HardwareProfileVmSizeStandardL8S      = HardwareProfileVmSize("Standard_L8s")
	HardwareProfileVmSizeStandardM12832Ms = HardwareProfileVmSize("Standard_M128-32ms")
	HardwareProfileVmSizeStandardM12864Ms = HardwareProfileVmSize("Standard_M128-64ms")
	HardwareProfileVmSizeStandardM128Ms   = HardwareProfileVmSize("Standard_M128ms")
	HardwareProfileVmSizeStandardM128S    = HardwareProfileVmSize("Standard_M128s")
	HardwareProfileVmSizeStandardM6416Ms  = HardwareProfileVmSize("Standard_M64-16ms")
	HardwareProfileVmSizeStandardM6432Ms  = HardwareProfileVmSize("Standard_M64-32ms")
	HardwareProfileVmSizeStandardM64Ms    = HardwareProfileVmSize("Standard_M64ms")
	HardwareProfileVmSizeStandardM64S     = HardwareProfileVmSize("Standard_M64s")
	HardwareProfileVmSizeStandardNC12     = HardwareProfileVmSize("Standard_NC12")
	HardwareProfileVmSizeStandardNC12SV2  = HardwareProfileVmSize("Standard_NC12s_v2")
	HardwareProfileVmSizeStandardNC12SV3  = HardwareProfileVmSize("Standard_NC12s_v3")
	HardwareProfileVmSizeStandardNC24     = HardwareProfileVmSize("Standard_NC24")
	HardwareProfileVmSizeStandardNC24R    = HardwareProfileVmSize("Standard_NC24r")
	HardwareProfileVmSizeStandardNC24RsV2 = HardwareProfileVmSize("Standard_NC24rs_v2")
	HardwareProfileVmSizeStandardNC24RsV3 = HardwareProfileVmSize("Standard_NC24rs_v3")
	HardwareProfileVmSizeStandardNC24SV2  = HardwareProfileVmSize("Standard_NC24s_v2")
	HardwareProfileVmSizeStandardNC24SV3  = HardwareProfileVmSize("Standard_NC24s_v3")
	HardwareProfileVmSizeStandardNC6      = HardwareProfileVmSize("Standard_NC6")
	HardwareProfileVmSizeStandardNC6SV2   = HardwareProfileVmSize("Standard_NC6s_v2")
	HardwareProfileVmSizeStandardNC6SV3   = HardwareProfileVmSize("Standard_NC6s_v3")
	HardwareProfileVmSizeStandardND12S    = HardwareProfileVmSize("Standard_ND12s")
	HardwareProfileVmSizeStandardND24Rs   = HardwareProfileVmSize("Standard_ND24rs")
	HardwareProfileVmSizeStandardND24S    = HardwareProfileVmSize("Standard_ND24s")
	HardwareProfileVmSizeStandardND6S     = HardwareProfileVmSize("Standard_ND6s")
	HardwareProfileVmSizeStandardNV12     = HardwareProfileVmSize("Standard_NV12")
	HardwareProfileVmSizeStandardNV24     = HardwareProfileVmSize("Standard_NV24")
	HardwareProfileVmSizeStandardNV6      = HardwareProfileVmSize("Standard_NV6")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ImageReference
type ImageReference struct {
	//Offer: Specifies the offer of the platform image or marketplace image used to
	//create the virtual machine.
	Offer *string `json:"offer,omitempty"`

	//Publisher: The image publisher.
	Publisher *string `json:"publisher,omitempty"`

	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Sku: The image SKU.
	Sku *string `json:"sku,omitempty"`

	//Version: Specifies the version of the platform image or marketplace image used
	//to create the virtual machine. The allowed formats are Major.Minor.Build or
	//'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use
	//the latest version of an image available at deploy time. Even if you use
	//'latest', the VM image will not automatically update after deploy time even if a
	//new version becomes available.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ImageReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (imageReference *ImageReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if imageReference == nil {
		return nil, nil
	}
	var result ImageReferenceARM

	// Set property ‘Id’:
	if imageReference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*imageReference.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Offer’:
	if imageReference.Offer != nil {
		offer := *imageReference.Offer
		result.Offer = &offer
	}

	// Set property ‘Publisher’:
	if imageReference.Publisher != nil {
		publisher := *imageReference.Publisher
		result.Publisher = &publisher
	}

	// Set property ‘Sku’:
	if imageReference.Sku != nil {
		sku := *imageReference.Sku
		result.Sku = &sku
	}

	// Set property ‘Version’:
	if imageReference.Version != nil {
		version := *imageReference.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (imageReference *ImageReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (imageReference *ImageReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageReferenceARM, got %T", armInput)
	}

	// Set property ‘Offer’:
	if typedInput.Offer != nil {
		offer := *typedInput.Offer
		imageReference.Offer = &offer
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		imageReference.Publisher = &publisher
	}

	// no assignment for property ‘Reference’

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		imageReference.Sku = &sku
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		imageReference.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromImageReference populates our ImageReference from the provided source ImageReference
func (imageReference *ImageReference) AssignPropertiesFromImageReference(source *v1alpha1api20201201storage.ImageReference) error {

	// Offer
	imageReference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	imageReference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		imageReference.Reference = &reference
	} else {
		imageReference.Reference = nil
	}

	// Sku
	imageReference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	imageReference.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignPropertiesToImageReference populates the provided destination ImageReference from our ImageReference
func (imageReference *ImageReference) AssignPropertiesToImageReference(destination *v1alpha1api20201201storage.ImageReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Offer
	destination.Offer = genruntime.ClonePointerToString(imageReference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(imageReference.Publisher)

	// Reference
	if imageReference.Reference != nil {
		reference := imageReference.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Sku
	destination.Sku = genruntime.ClonePointerToString(imageReference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(imageReference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ImageReference_Status struct {
	//ExactVersion: Specifies in decimal numbers, the version of platform image or
	//marketplace image used to create the virtual machine. This readonly field
	//differs from 'version', only if the value specified in 'version' field is
	//'latest'.
	ExactVersion *string `json:"exactVersion,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Offer: Specifies the offer of the platform image or marketplace image used to
	//create the virtual machine.
	Offer *string `json:"offer,omitempty"`

	//Publisher: The image publisher.
	Publisher *string `json:"publisher,omitempty"`

	//Sku: The image SKU.
	Sku *string `json:"sku,omitempty"`

	//Version: Specifies the version of the platform image or marketplace image used
	//to create the virtual machine. The allowed formats are Major.Minor.Build or
	//'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use
	//the latest version of an image available at deploy time. Even if you use
	//'latest', the VM image will not automatically update after deploy time even if a
	//new version becomes available.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageReference_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (imageReferenceStatus *ImageReference_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (imageReferenceStatus *ImageReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageReference_StatusARM, got %T", armInput)
	}

	// Set property ‘ExactVersion’:
	if typedInput.ExactVersion != nil {
		exactVersion := *typedInput.ExactVersion
		imageReferenceStatus.ExactVersion = &exactVersion
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		imageReferenceStatus.Id = &id
	}

	// Set property ‘Offer’:
	if typedInput.Offer != nil {
		offer := *typedInput.Offer
		imageReferenceStatus.Offer = &offer
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		imageReferenceStatus.Publisher = &publisher
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		imageReferenceStatus.Sku = &sku
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		imageReferenceStatus.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromImageReferenceStatus populates our ImageReference_Status from the provided source ImageReference_Status
func (imageReferenceStatus *ImageReference_Status) AssignPropertiesFromImageReferenceStatus(source *v1alpha1api20201201storage.ImageReference_Status) error {

	// ExactVersion
	imageReferenceStatus.ExactVersion = genruntime.ClonePointerToString(source.ExactVersion)

	// Id
	imageReferenceStatus.Id = genruntime.ClonePointerToString(source.Id)

	// Offer
	imageReferenceStatus.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	imageReferenceStatus.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Sku
	imageReferenceStatus.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	imageReferenceStatus.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignPropertiesToImageReferenceStatus populates the provided destination ImageReference_Status from our ImageReference_Status
func (imageReferenceStatus *ImageReference_Status) AssignPropertiesToImageReferenceStatus(destination *v1alpha1api20201201storage.ImageReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExactVersion
	destination.ExactVersion = genruntime.ClonePointerToString(imageReferenceStatus.ExactVersion)

	// Id
	destination.Id = genruntime.ClonePointerToString(imageReferenceStatus.Id)

	// Offer
	destination.Offer = genruntime.ClonePointerToString(imageReferenceStatus.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(imageReferenceStatus.Publisher)

	// Sku
	destination.Sku = genruntime.ClonePointerToString(imageReferenceStatus.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(imageReferenceStatus.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InstanceViewStatus_Status struct {
	//Code: The status code.
	Code *string `json:"code,omitempty"`

	//DisplayStatus: The short localizable label for the status.
	DisplayStatus *string `json:"displayStatus,omitempty"`

	//Level: The level code.
	Level *InstanceViewStatusStatusLevel `json:"level,omitempty"`

	//Message: The detailed status message, including for alerts and error messages.
	Message *string `json:"message,omitempty"`

	//Time: The time of the status.
	Time *string `json:"time,omitempty"`
}

var _ genruntime.FromARMConverter = &InstanceViewStatus_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instanceViewStatusStatus *InstanceViewStatus_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InstanceViewStatus_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instanceViewStatusStatus *InstanceViewStatus_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InstanceViewStatus_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InstanceViewStatus_StatusARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		instanceViewStatusStatus.Code = &code
	}

	// Set property ‘DisplayStatus’:
	if typedInput.DisplayStatus != nil {
		displayStatus := *typedInput.DisplayStatus
		instanceViewStatusStatus.DisplayStatus = &displayStatus
	}

	// Set property ‘Level’:
	if typedInput.Level != nil {
		level := *typedInput.Level
		instanceViewStatusStatus.Level = &level
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		instanceViewStatusStatus.Message = &message
	}

	// Set property ‘Time’:
	if typedInput.Time != nil {
		time := *typedInput.Time
		instanceViewStatusStatus.Time = &time
	}

	// No error
	return nil
}

// AssignPropertiesFromInstanceViewStatusStatus populates our InstanceViewStatus_Status from the provided source InstanceViewStatus_Status
func (instanceViewStatusStatus *InstanceViewStatus_Status) AssignPropertiesFromInstanceViewStatusStatus(source *v1alpha1api20201201storage.InstanceViewStatus_Status) error {

	// Code
	instanceViewStatusStatus.Code = genruntime.ClonePointerToString(source.Code)

	// DisplayStatus
	instanceViewStatusStatus.DisplayStatus = genruntime.ClonePointerToString(source.DisplayStatus)

	// Level
	if source.Level != nil {
		level := InstanceViewStatusStatusLevel(*source.Level)
		instanceViewStatusStatus.Level = &level
	} else {
		instanceViewStatusStatus.Level = nil
	}

	// Message
	instanceViewStatusStatus.Message = genruntime.ClonePointerToString(source.Message)

	// Time
	instanceViewStatusStatus.Time = genruntime.ClonePointerToString(source.Time)

	// No error
	return nil
}

// AssignPropertiesToInstanceViewStatusStatus populates the provided destination InstanceViewStatus_Status from our InstanceViewStatus_Status
func (instanceViewStatusStatus *InstanceViewStatus_Status) AssignPropertiesToInstanceViewStatusStatus(destination *v1alpha1api20201201storage.InstanceViewStatus_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(instanceViewStatusStatus.Code)

	// DisplayStatus
	destination.DisplayStatus = genruntime.ClonePointerToString(instanceViewStatusStatus.DisplayStatus)

	// Level
	if instanceViewStatusStatus.Level != nil {
		level := string(*instanceViewStatusStatus.Level)
		destination.Level = &level
	} else {
		destination.Level = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(instanceViewStatusStatus.Message)

	// Time
	destination.Time = genruntime.ClonePointerToString(instanceViewStatusStatus.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/LinuxConfiguration
type LinuxConfiguration struct {
	//DisablePasswordAuthentication: Specifies whether password authentication should
	//be disabled.
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`

	//PatchSettings: Specifies settings related to VM Guest Patching on Linux.
	PatchSettings *LinuxPatchSettings `json:"patchSettings,omitempty"`

	//ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned
	//on the virtual machine.
	//When this property is not specified in the request body, default behavior is to
	//set it to true.  This will ensure that VM Agent is installed on the VM so that
	//extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	//Ssh: SSH configuration for Linux based VMs running on Azure
	Ssh *SshConfiguration `json:"ssh,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (linuxConfiguration *LinuxConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if linuxConfiguration == nil {
		return nil, nil
	}
	var result LinuxConfigurationARM

	// Set property ‘DisablePasswordAuthentication’:
	if linuxConfiguration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *linuxConfiguration.DisablePasswordAuthentication
		result.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if linuxConfiguration.PatchSettings != nil {
		patchSettingsARM, err := (*linuxConfiguration.PatchSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		patchSettings := patchSettingsARM.(LinuxPatchSettingsARM)
		result.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if linuxConfiguration.ProvisionVMAgent != nil {
		provisionVMAgent := *linuxConfiguration.ProvisionVMAgent
		result.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if linuxConfiguration.Ssh != nil {
		sshARM, err := (*linuxConfiguration.Ssh).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ssh := sshARM.(SshConfigurationARM)
		result.Ssh = &ssh
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (linuxConfiguration *LinuxConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (linuxConfiguration *LinuxConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxConfigurationARM, got %T", armInput)
	}

	// Set property ‘DisablePasswordAuthentication’:
	if typedInput.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *typedInput.DisablePasswordAuthentication
		linuxConfiguration.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 LinuxPatchSettings
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		linuxConfiguration.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		linuxConfiguration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if typedInput.Ssh != nil {
		var ssh1 SshConfiguration
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		linuxConfiguration.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxConfiguration populates our LinuxConfiguration from the provided source LinuxConfiguration
func (linuxConfiguration *LinuxConfiguration) AssignPropertiesFromLinuxConfiguration(source *v1alpha1api20201201storage.LinuxConfiguration) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		linuxConfiguration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		linuxConfiguration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings
		err := patchSetting.AssignPropertiesFromLinuxPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesFromLinuxPatchSettings()")
		}
		linuxConfiguration.PatchSettings = &patchSetting
	} else {
		linuxConfiguration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		linuxConfiguration.ProvisionVMAgent = &provisionVMAgent
	} else {
		linuxConfiguration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration
		err := ssh.AssignPropertiesFromSshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesFromSshConfiguration()")
		}
		linuxConfiguration.Ssh = &ssh
	} else {
		linuxConfiguration.Ssh = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxConfiguration populates the provided destination LinuxConfiguration from our LinuxConfiguration
func (linuxConfiguration *LinuxConfiguration) AssignPropertiesToLinuxConfiguration(destination *v1alpha1api20201201storage.LinuxConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisablePasswordAuthentication
	if linuxConfiguration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *linuxConfiguration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if linuxConfiguration.PatchSettings != nil {
		var patchSetting v1alpha1api20201201storage.LinuxPatchSettings
		err := (*linuxConfiguration.PatchSettings).AssignPropertiesToLinuxPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesToLinuxPatchSettings()")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if linuxConfiguration.ProvisionVMAgent != nil {
		provisionVMAgent := *linuxConfiguration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if linuxConfiguration.Ssh != nil {
		var ssh v1alpha1api20201201storage.SshConfiguration
		err := (*linuxConfiguration.Ssh).AssignPropertiesToSshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesToSshConfiguration()")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LinuxConfiguration_Status struct {
	//DisablePasswordAuthentication: Specifies whether password authentication should
	//be disabled.
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`

	//PatchSettings: [Preview Feature] Specifies settings related to VM Guest Patching
	//on Linux.
	PatchSettings *LinuxPatchSettings_Status `json:"patchSettings,omitempty"`

	//ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned
	//on the virtual machine.
	//When this property is not specified in the request body, default behavior is to
	//set it to true.  This will ensure that VM Agent is installed on the VM so that
	//extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	//Ssh: Specifies the ssh key configuration for a Linux OS.
	Ssh *SshConfiguration_Status `json:"ssh,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (linuxConfigurationStatus *LinuxConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (linuxConfigurationStatus *LinuxConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘DisablePasswordAuthentication’:
	if typedInput.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *typedInput.DisablePasswordAuthentication
		linuxConfigurationStatus.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 LinuxPatchSettings_Status
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		linuxConfigurationStatus.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		linuxConfigurationStatus.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if typedInput.Ssh != nil {
		var ssh1 SshConfiguration_Status
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		linuxConfigurationStatus.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxConfigurationStatus populates our LinuxConfiguration_Status from the provided source LinuxConfiguration_Status
func (linuxConfigurationStatus *LinuxConfiguration_Status) AssignPropertiesFromLinuxConfigurationStatus(source *v1alpha1api20201201storage.LinuxConfiguration_Status) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		linuxConfigurationStatus.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		linuxConfigurationStatus.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings_Status
		err := patchSetting.AssignPropertiesFromLinuxPatchSettingsStatus(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesFromLinuxPatchSettingsStatus()")
		}
		linuxConfigurationStatus.PatchSettings = &patchSetting
	} else {
		linuxConfigurationStatus.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		linuxConfigurationStatus.ProvisionVMAgent = &provisionVMAgent
	} else {
		linuxConfigurationStatus.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration_Status
		err := ssh.AssignPropertiesFromSshConfigurationStatus(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesFromSshConfigurationStatus()")
		}
		linuxConfigurationStatus.Ssh = &ssh
	} else {
		linuxConfigurationStatus.Ssh = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxConfigurationStatus populates the provided destination LinuxConfiguration_Status from our LinuxConfiguration_Status
func (linuxConfigurationStatus *LinuxConfiguration_Status) AssignPropertiesToLinuxConfigurationStatus(destination *v1alpha1api20201201storage.LinuxConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisablePasswordAuthentication
	if linuxConfigurationStatus.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *linuxConfigurationStatus.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if linuxConfigurationStatus.PatchSettings != nil {
		var patchSetting v1alpha1api20201201storage.LinuxPatchSettings_Status
		err := (*linuxConfigurationStatus.PatchSettings).AssignPropertiesToLinuxPatchSettingsStatus(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesToLinuxPatchSettingsStatus()")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if linuxConfigurationStatus.ProvisionVMAgent != nil {
		provisionVMAgent := *linuxConfigurationStatus.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if linuxConfigurationStatus.Ssh != nil {
		var ssh v1alpha1api20201201storage.SshConfiguration_Status
		err := (*linuxConfigurationStatus.Ssh).AssignPropertiesToSshConfigurationStatus(&ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesToSshConfigurationStatus()")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MaintenanceRedeployStatus_Status struct {
	//IsCustomerInitiatedMaintenanceAllowed: True, if customer is allowed to perform
	//Maintenance.
	IsCustomerInitiatedMaintenanceAllowed *bool `json:"isCustomerInitiatedMaintenanceAllowed,omitempty"`

	//LastOperationMessage: Message returned for the last Maintenance Operation.
	LastOperationMessage *string `json:"lastOperationMessage,omitempty"`

	//LastOperationResultCode: The Last Maintenance Operation Result Code.
	LastOperationResultCode *MaintenanceRedeployStatusStatusLastOperationResultCode `json:"lastOperationResultCode,omitempty"`

	//MaintenanceWindowEndTime: End Time for the Maintenance Window.
	MaintenanceWindowEndTime *string `json:"maintenanceWindowEndTime,omitempty"`

	//MaintenanceWindowStartTime: Start Time for the Maintenance Window.
	MaintenanceWindowStartTime *string `json:"maintenanceWindowStartTime,omitempty"`

	//PreMaintenanceWindowEndTime: End Time for the Pre Maintenance Window.
	PreMaintenanceWindowEndTime *string `json:"preMaintenanceWindowEndTime,omitempty"`

	//PreMaintenanceWindowStartTime: Start Time for the Pre Maintenance Window.
	PreMaintenanceWindowStartTime *string `json:"preMaintenanceWindowStartTime,omitempty"`
}

var _ genruntime.FromARMConverter = &MaintenanceRedeployStatus_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (maintenanceRedeployStatusStatus *MaintenanceRedeployStatus_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MaintenanceRedeployStatus_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (maintenanceRedeployStatusStatus *MaintenanceRedeployStatus_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MaintenanceRedeployStatus_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MaintenanceRedeployStatus_StatusARM, got %T", armInput)
	}

	// Set property ‘IsCustomerInitiatedMaintenanceAllowed’:
	if typedInput.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *typedInput.IsCustomerInitiatedMaintenanceAllowed
		maintenanceRedeployStatusStatus.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	}

	// Set property ‘LastOperationMessage’:
	if typedInput.LastOperationMessage != nil {
		lastOperationMessage := *typedInput.LastOperationMessage
		maintenanceRedeployStatusStatus.LastOperationMessage = &lastOperationMessage
	}

	// Set property ‘LastOperationResultCode’:
	if typedInput.LastOperationResultCode != nil {
		lastOperationResultCode := *typedInput.LastOperationResultCode
		maintenanceRedeployStatusStatus.LastOperationResultCode = &lastOperationResultCode
	}

	// Set property ‘MaintenanceWindowEndTime’:
	if typedInput.MaintenanceWindowEndTime != nil {
		maintenanceWindowEndTime := *typedInput.MaintenanceWindowEndTime
		maintenanceRedeployStatusStatus.MaintenanceWindowEndTime = &maintenanceWindowEndTime
	}

	// Set property ‘MaintenanceWindowStartTime’:
	if typedInput.MaintenanceWindowStartTime != nil {
		maintenanceWindowStartTime := *typedInput.MaintenanceWindowStartTime
		maintenanceRedeployStatusStatus.MaintenanceWindowStartTime = &maintenanceWindowStartTime
	}

	// Set property ‘PreMaintenanceWindowEndTime’:
	if typedInput.PreMaintenanceWindowEndTime != nil {
		preMaintenanceWindowEndTime := *typedInput.PreMaintenanceWindowEndTime
		maintenanceRedeployStatusStatus.PreMaintenanceWindowEndTime = &preMaintenanceWindowEndTime
	}

	// Set property ‘PreMaintenanceWindowStartTime’:
	if typedInput.PreMaintenanceWindowStartTime != nil {
		preMaintenanceWindowStartTime := *typedInput.PreMaintenanceWindowStartTime
		maintenanceRedeployStatusStatus.PreMaintenanceWindowStartTime = &preMaintenanceWindowStartTime
	}

	// No error
	return nil
}

// AssignPropertiesFromMaintenanceRedeployStatusStatus populates our MaintenanceRedeployStatus_Status from the provided source MaintenanceRedeployStatus_Status
func (maintenanceRedeployStatusStatus *MaintenanceRedeployStatus_Status) AssignPropertiesFromMaintenanceRedeployStatusStatus(source *v1alpha1api20201201storage.MaintenanceRedeployStatus_Status) error {

	// IsCustomerInitiatedMaintenanceAllowed
	if source.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *source.IsCustomerInitiatedMaintenanceAllowed
		maintenanceRedeployStatusStatus.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		maintenanceRedeployStatusStatus.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	maintenanceRedeployStatusStatus.LastOperationMessage = genruntime.ClonePointerToString(source.LastOperationMessage)

	// LastOperationResultCode
	if source.LastOperationResultCode != nil {
		lastOperationResultCode := MaintenanceRedeployStatusStatusLastOperationResultCode(*source.LastOperationResultCode)
		maintenanceRedeployStatusStatus.LastOperationResultCode = &lastOperationResultCode
	} else {
		maintenanceRedeployStatusStatus.LastOperationResultCode = nil
	}

	// MaintenanceWindowEndTime
	maintenanceRedeployStatusStatus.MaintenanceWindowEndTime = genruntime.ClonePointerToString(source.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	maintenanceRedeployStatusStatus.MaintenanceWindowStartTime = genruntime.ClonePointerToString(source.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	maintenanceRedeployStatusStatus.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	maintenanceRedeployStatusStatus.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowStartTime)

	// No error
	return nil
}

// AssignPropertiesToMaintenanceRedeployStatusStatus populates the provided destination MaintenanceRedeployStatus_Status from our MaintenanceRedeployStatus_Status
func (maintenanceRedeployStatusStatus *MaintenanceRedeployStatus_Status) AssignPropertiesToMaintenanceRedeployStatusStatus(destination *v1alpha1api20201201storage.MaintenanceRedeployStatus_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsCustomerInitiatedMaintenanceAllowed
	if maintenanceRedeployStatusStatus.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *maintenanceRedeployStatusStatus.IsCustomerInitiatedMaintenanceAllowed
		destination.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		destination.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	destination.LastOperationMessage = genruntime.ClonePointerToString(maintenanceRedeployStatusStatus.LastOperationMessage)

	// LastOperationResultCode
	if maintenanceRedeployStatusStatus.LastOperationResultCode != nil {
		lastOperationResultCode := string(*maintenanceRedeployStatusStatus.LastOperationResultCode)
		destination.LastOperationResultCode = &lastOperationResultCode
	} else {
		destination.LastOperationResultCode = nil
	}

	// MaintenanceWindowEndTime
	destination.MaintenanceWindowEndTime = genruntime.ClonePointerToString(maintenanceRedeployStatusStatus.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	destination.MaintenanceWindowStartTime = genruntime.ClonePointerToString(maintenanceRedeployStatusStatus.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	destination.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(maintenanceRedeployStatusStatus.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	destination.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(maintenanceRedeployStatusStatus.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NetworkInterfaceReference_Status struct {
	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceReference_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networkInterfaceReferenceStatus *NetworkInterfaceReference_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkInterfaceReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networkInterfaceReferenceStatus *NetworkInterfaceReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkInterfaceReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkInterfaceReference_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		networkInterfaceReferenceStatus.Id = &id
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			networkInterfaceReferenceStatus.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromNetworkInterfaceReferenceStatus populates our NetworkInterfaceReference_Status from the provided source NetworkInterfaceReference_Status
func (networkInterfaceReferenceStatus *NetworkInterfaceReference_Status) AssignPropertiesFromNetworkInterfaceReferenceStatus(source *v1alpha1api20201201storage.NetworkInterfaceReference_Status) error {

	// Id
	networkInterfaceReferenceStatus.Id = genruntime.ClonePointerToString(source.Id)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		networkInterfaceReferenceStatus.Primary = &primary
	} else {
		networkInterfaceReferenceStatus.Primary = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceReferenceStatus populates the provided destination NetworkInterfaceReference_Status from our NetworkInterfaceReference_Status
func (networkInterfaceReferenceStatus *NetworkInterfaceReference_Status) AssignPropertiesToNetworkInterfaceReferenceStatus(destination *v1alpha1api20201201storage.NetworkInterfaceReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(networkInterfaceReferenceStatus.Id)

	// Primary
	if networkInterfaceReferenceStatus.Primary != nil {
		primary := *networkInterfaceReferenceStatus.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/OSDisk
type OSDisk struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage.
	Caching *OSDiskCaching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: Specifies how the virtual machine should be created.
	//Possible values are:
	//Attach \u2013 This value is used when you are using a specialized disk to create
	//the virtual machine.
	//FromImage \u2013 This value is used when you are using an image to create the
	//virtual machine. If you are using a platform image, you also use the
	//imageReference element described above. If you are using a marketplace image,
	//you  also use the plan element previously described.
	CreateOption OSDiskCreateOption `json:"createOption"`

	//DiffDiskSettings: Describes the parameters of ephemeral disk settings that can
	//be specified for operating system disk.
	//NOTE: The ephemeral disk settings can only be specified for managed disk.
	DiffDiskSettings *DiffDiskSettings `json:"diffDiskSettings,omitempty"`

	//DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element
	//can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//EncryptionSettings: Describes a Encryption Settings for a Disk
	EncryptionSettings *DiskEncryptionSettings `json:"encryptionSettings,omitempty"`

	//Image: Describes the uri of a disk.
	Image *VirtualHardDisk `json:"image,omitempty"`

	//ManagedDisk: The parameters of a managed disk.
	ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//OsType: This property allows you to specify the type of the OS that is included
	//in the disk if creating a VM from user-image or a specialized VHD.
	//Possible values are:
	//Windows
	//Linux.
	OsType *OSDiskOsType `json:"osType,omitempty"`

	//Vhd: Describes the uri of a disk.
	Vhd *VirtualHardDisk `json:"vhd,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &OSDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (osDisk *OSDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if osDisk == nil {
		return nil, nil
	}
	var result OSDiskARM

	// Set property ‘Caching’:
	if osDisk.Caching != nil {
		caching := *osDisk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	result.CreateOption = osDisk.CreateOption

	// Set property ‘DiffDiskSettings’:
	if osDisk.DiffDiskSettings != nil {
		diffDiskSettingsARM, err := (*osDisk.DiffDiskSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diffDiskSettings := diffDiskSettingsARM.(DiffDiskSettingsARM)
		result.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if osDisk.DiskSizeGB != nil {
		diskSizeGB := *osDisk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘EncryptionSettings’:
	if osDisk.EncryptionSettings != nil {
		encryptionSettingsARM, err := (*osDisk.EncryptionSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionSettings := encryptionSettingsARM.(DiskEncryptionSettingsARM)
		result.EncryptionSettings = &encryptionSettings
	}

	// Set property ‘Image’:
	if osDisk.Image != nil {
		imageARM, err := (*osDisk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := imageARM.(VirtualHardDiskARM)
		result.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if osDisk.ManagedDisk != nil {
		managedDiskARM, err := (*osDisk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := managedDiskARM.(ManagedDiskParametersARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if osDisk.Name != nil {
		name := *osDisk.Name
		result.Name = &name
	}

	// Set property ‘OsType’:
	if osDisk.OsType != nil {
		osType := *osDisk.OsType
		result.OsType = &osType
	}

	// Set property ‘Vhd’:
	if osDisk.Vhd != nil {
		vhdARM, err := (*osDisk.Vhd).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vhd := vhdARM.(VirtualHardDiskARM)
		result.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if osDisk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *osDisk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (osDisk *OSDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OSDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (osDisk *OSDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OSDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OSDiskARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		osDisk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	osDisk.CreateOption = typedInput.CreateOption

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		osDisk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		osDisk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘EncryptionSettings’:
	if typedInput.EncryptionSettings != nil {
		var encryptionSettings1 DiskEncryptionSettings
		err := encryptionSettings1.PopulateFromARM(owner, *typedInput.EncryptionSettings)
		if err != nil {
			return err
		}
		encryptionSettings := encryptionSettings1
		osDisk.EncryptionSettings = &encryptionSettings
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		osDisk.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		osDisk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		osDisk.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		osDisk.OsType = &osType
	}

	// Set property ‘Vhd’:
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		osDisk.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		osDisk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromOSDisk populates our OSDisk from the provided source OSDisk
func (osDisk *OSDisk) AssignPropertiesFromOSDisk(source *v1alpha1api20201201storage.OSDisk) error {

	// Caching
	if source.Caching != nil {
		caching := OSDiskCaching(*source.Caching)
		osDisk.Caching = &caching
	} else {
		osDisk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		osDisk.CreateOption = OSDiskCreateOption(*source.CreateOption)
	} else {
		osDisk.CreateOption = ""
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "populating DiffDiskSettings from DiffDiskSettings, calling AssignPropertiesFromDiffDiskSettings()")
		}
		osDisk.DiffDiskSettings = &diffDiskSetting
	} else {
		osDisk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	osDisk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings
		err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettings(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesFromDiskEncryptionSettings()")
		}
		osDisk.EncryptionSettings = &encryptionSetting
	} else {
		osDisk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignPropertiesFromVirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesFromVirtualHardDisk()")
		}
		osDisk.Image = &image
	} else {
		osDisk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignPropertiesFromManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesFromManagedDiskParameters()")
		}
		osDisk.ManagedDisk = &managedDisk
	} else {
		osDisk.ManagedDisk = nil
	}

	// Name
	osDisk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := OSDiskOsType(*source.OsType)
		osDisk.OsType = &osType
	} else {
		osDisk.OsType = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignPropertiesFromVirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "populating Vhd from Vhd, calling AssignPropertiesFromVirtualHardDisk()")
		}
		osDisk.Vhd = &vhd
	} else {
		osDisk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		osDisk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		osDisk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSDisk populates the provided destination OSDisk from our OSDisk
func (osDisk *OSDisk) AssignPropertiesToOSDisk(destination *v1alpha1api20201201storage.OSDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if osDisk.Caching != nil {
		caching := string(*osDisk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(osDisk.CreateOption)
	destination.CreateOption = &createOption

	// DiffDiskSettings
	if osDisk.DiffDiskSettings != nil {
		var diffDiskSetting v1alpha1api20201201storage.DiffDiskSettings
		err := (*osDisk.DiffDiskSettings).AssignPropertiesToDiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "populating DiffDiskSettings from DiffDiskSettings, calling AssignPropertiesToDiffDiskSettings()")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(osDisk.DiskSizeGB)

	// EncryptionSettings
	if osDisk.EncryptionSettings != nil {
		var encryptionSetting v1alpha1api20201201storage.DiskEncryptionSettings
		err := (*osDisk.EncryptionSettings).AssignPropertiesToDiskEncryptionSettings(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesToDiskEncryptionSettings()")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if osDisk.Image != nil {
		var image v1alpha1api20201201storage.VirtualHardDisk
		err := (*osDisk.Image).AssignPropertiesToVirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesToVirtualHardDisk()")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if osDisk.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.ManagedDiskParameters
		err := (*osDisk.ManagedDisk).AssignPropertiesToManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesToManagedDiskParameters()")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(osDisk.Name)

	// OsType
	if osDisk.OsType != nil {
		osType := string(*osDisk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Vhd
	if osDisk.Vhd != nil {
		var vhd v1alpha1api20201201storage.VirtualHardDisk
		err := (*osDisk.Vhd).AssignPropertiesToVirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "populating Vhd from Vhd, calling AssignPropertiesToVirtualHardDisk()")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if osDisk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *osDisk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OSDisk_Status struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage.
	Caching *Caching_Status `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: Specifies how the virtual machine should be created.
	//Possible values are:
	//Attach \u2013 This value is used when you are using a specialized disk to create
	//the virtual machine.
	//FromImage \u2013 This value is used when you are using an image to create the
	//virtual machine. If you are using a platform image, you also use the
	//imageReference element described above. If you are using a marketplace image,
	//you  also use the plan element previously described.
	CreateOption CreateOption_Status `json:"createOption"`

	//DiffDiskSettings: Specifies the ephemeral Disk Settings for the operating system
	//disk used by the virtual machine.
	DiffDiskSettings *DiffDiskSettings_Status `json:"diffDiskSettings,omitempty"`

	//DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element
	//can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//EncryptionSettings: Specifies the encryption settings for the OS Disk.
	//Minimum api-version: 2015-06-15
	EncryptionSettings *DiskEncryptionSettings_Status `json:"encryptionSettings,omitempty"`

	//Image: The source user image virtual hard disk. The virtual hard disk will be
	//copied before being attached to the virtual machine. If SourceImage is provided,
	//the destination virtual hard drive must not exist.
	Image *VirtualHardDisk_Status `json:"image,omitempty"`

	//ManagedDisk: The managed disk parameters.
	ManagedDisk *ManagedDiskParameters_Status `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//OsType: This property allows you to specify the type of the OS that is included
	//in the disk if creating a VM from user-image or a specialized VHD.
	//Possible values are:
	//Windows
	//Linux
	OsType *OSDiskStatusOsType `json:"osType,omitempty"`

	//Vhd: The virtual hard disk.
	Vhd *VirtualHardDisk_Status `json:"vhd,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &OSDisk_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (osDiskStatus *OSDisk_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OSDisk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (osDiskStatus *OSDisk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OSDisk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OSDisk_StatusARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		osDiskStatus.Caching = &caching
	}

	// Set property ‘CreateOption’:
	osDiskStatus.CreateOption = typedInput.CreateOption

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings_Status
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		osDiskStatus.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		osDiskStatus.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘EncryptionSettings’:
	if typedInput.EncryptionSettings != nil {
		var encryptionSettings1 DiskEncryptionSettings_Status
		err := encryptionSettings1.PopulateFromARM(owner, *typedInput.EncryptionSettings)
		if err != nil {
			return err
		}
		encryptionSettings := encryptionSettings1
		osDiskStatus.EncryptionSettings = &encryptionSettings
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_Status
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		osDiskStatus.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters_Status
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		osDiskStatus.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		osDiskStatus.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		osDiskStatus.OsType = &osType
	}

	// Set property ‘Vhd’:
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk_Status
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		osDiskStatus.Vhd = &vhd
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		osDiskStatus.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromOSDiskStatus populates our OSDisk_Status from the provided source OSDisk_Status
func (osDiskStatus *OSDisk_Status) AssignPropertiesFromOSDiskStatus(source *v1alpha1api20201201storage.OSDisk_Status) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_Status(*source.Caching)
		osDiskStatus.Caching = &caching
	} else {
		osDiskStatus.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		osDiskStatus.CreateOption = CreateOption_Status(*source.CreateOption)
	} else {
		osDiskStatus.CreateOption = ""
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_Status
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettingsStatus(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "populating DiffDiskSettings from DiffDiskSettings, calling AssignPropertiesFromDiffDiskSettingsStatus()")
		}
		osDiskStatus.DiffDiskSettings = &diffDiskSetting
	} else {
		osDiskStatus.DiffDiskSettings = nil
	}

	// DiskSizeGB
	osDiskStatus.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings_Status
		err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettingsStatus(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesFromDiskEncryptionSettingsStatus()")
		}
		osDiskStatus.EncryptionSettings = &encryptionSetting
	} else {
		osDiskStatus.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_Status
		err := image.AssignPropertiesFromVirtualHardDiskStatus(source.Image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesFromVirtualHardDiskStatus()")
		}
		osDiskStatus.Image = &image
	} else {
		osDiskStatus.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_Status
		err := managedDisk.AssignPropertiesFromManagedDiskParametersStatus(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesFromManagedDiskParametersStatus()")
		}
		osDiskStatus.ManagedDisk = &managedDisk
	} else {
		osDiskStatus.ManagedDisk = nil
	}

	// Name
	osDiskStatus.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := OSDiskStatusOsType(*source.OsType)
		osDiskStatus.OsType = &osType
	} else {
		osDiskStatus.OsType = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_Status
		err := vhd.AssignPropertiesFromVirtualHardDiskStatus(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "populating Vhd from Vhd, calling AssignPropertiesFromVirtualHardDiskStatus()")
		}
		osDiskStatus.Vhd = &vhd
	} else {
		osDiskStatus.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		osDiskStatus.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		osDiskStatus.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSDiskStatus populates the provided destination OSDisk_Status from our OSDisk_Status
func (osDiskStatus *OSDisk_Status) AssignPropertiesToOSDiskStatus(destination *v1alpha1api20201201storage.OSDisk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if osDiskStatus.Caching != nil {
		caching := string(*osDiskStatus.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(osDiskStatus.CreateOption)
	destination.CreateOption = &createOption

	// DiffDiskSettings
	if osDiskStatus.DiffDiskSettings != nil {
		var diffDiskSetting v1alpha1api20201201storage.DiffDiskSettings_Status
		err := (*osDiskStatus.DiffDiskSettings).AssignPropertiesToDiffDiskSettingsStatus(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "populating DiffDiskSettings from DiffDiskSettings, calling AssignPropertiesToDiffDiskSettingsStatus()")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(osDiskStatus.DiskSizeGB)

	// EncryptionSettings
	if osDiskStatus.EncryptionSettings != nil {
		var encryptionSetting v1alpha1api20201201storage.DiskEncryptionSettings_Status
		err := (*osDiskStatus.EncryptionSettings).AssignPropertiesToDiskEncryptionSettingsStatus(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesToDiskEncryptionSettingsStatus()")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if osDiskStatus.Image != nil {
		var image v1alpha1api20201201storage.VirtualHardDisk_Status
		err := (*osDiskStatus.Image).AssignPropertiesToVirtualHardDiskStatus(&image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesToVirtualHardDiskStatus()")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if osDiskStatus.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.ManagedDiskParameters_Status
		err := (*osDiskStatus.ManagedDisk).AssignPropertiesToManagedDiskParametersStatus(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesToManagedDiskParametersStatus()")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(osDiskStatus.Name)

	// OsType
	if osDiskStatus.OsType != nil {
		osType := string(*osDiskStatus.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Vhd
	if osDiskStatus.Vhd != nil {
		var vhd v1alpha1api20201201storage.VirtualHardDisk_Status
		err := (*osDiskStatus.Vhd).AssignPropertiesToVirtualHardDiskStatus(&vhd)
		if err != nil {
			return errors.Wrap(err, "populating Vhd from Vhd, calling AssignPropertiesToVirtualHardDiskStatus()")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if osDiskStatus.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *osDiskStatus.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"TrustedLaunch"}
type SecurityProfileSecurityType string

const SecurityProfileSecurityTypeTrustedLaunch = SecurityProfileSecurityType("TrustedLaunch")

type SecurityProfileStatusSecurityType string

const SecurityProfileStatusSecurityTypeTrustedLaunch = SecurityProfileStatusSecurityType("TrustedLaunch")

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/UefiSettings
type UefiSettings struct {
	//SecureBootEnabled: Specifies whether secure boot should be enabled on the
	//virtual machine.
	//Minimum api-version: 2020-12-01
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`

	//VTpmEnabled: Specifies whether vTPM should be enabled on the virtual machine.
	//Minimum api-version: 2020-12-01
	VTpmEnabled *bool `json:"vTpmEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &UefiSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (uefiSettings *UefiSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if uefiSettings == nil {
		return nil, nil
	}
	var result UefiSettingsARM

	// Set property ‘SecureBootEnabled’:
	if uefiSettings.SecureBootEnabled != nil {
		secureBootEnabled := *uefiSettings.SecureBootEnabled
		result.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if uefiSettings.VTpmEnabled != nil {
		vTpmEnabled := *uefiSettings.VTpmEnabled
		result.VTpmEnabled = &vTpmEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (uefiSettings *UefiSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UefiSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (uefiSettings *UefiSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UefiSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UefiSettingsARM, got %T", armInput)
	}

	// Set property ‘SecureBootEnabled’:
	if typedInput.SecureBootEnabled != nil {
		secureBootEnabled := *typedInput.SecureBootEnabled
		uefiSettings.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if typedInput.VTpmEnabled != nil {
		vTpmEnabled := *typedInput.VTpmEnabled
		uefiSettings.VTpmEnabled = &vTpmEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromUefiSettings populates our UefiSettings from the provided source UefiSettings
func (uefiSettings *UefiSettings) AssignPropertiesFromUefiSettings(source *v1alpha1api20201201storage.UefiSettings) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		uefiSettings.SecureBootEnabled = &secureBootEnabled
	} else {
		uefiSettings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		uefiSettings.VTpmEnabled = &vTpmEnabled
	} else {
		uefiSettings.VTpmEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUefiSettings populates the provided destination UefiSettings from our UefiSettings
func (uefiSettings *UefiSettings) AssignPropertiesToUefiSettings(destination *v1alpha1api20201201storage.UefiSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecureBootEnabled
	if uefiSettings.SecureBootEnabled != nil {
		secureBootEnabled := *uefiSettings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if uefiSettings.VTpmEnabled != nil {
		vTpmEnabled := *uefiSettings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UefiSettings_Status struct {
	//SecureBootEnabled: Specifies whether secure boot should be enabled on the
	//virtual machine.
	//Minimum api-version: 2020-12-01
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`

	//VTpmEnabled: Specifies whether vTPM should be enabled on the virtual machine.
	//Minimum api-version: 2020-12-01
	VTpmEnabled *bool `json:"vTpmEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &UefiSettings_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (uefiSettingsStatus *UefiSettings_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UefiSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (uefiSettingsStatus *UefiSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UefiSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UefiSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘SecureBootEnabled’:
	if typedInput.SecureBootEnabled != nil {
		secureBootEnabled := *typedInput.SecureBootEnabled
		uefiSettingsStatus.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if typedInput.VTpmEnabled != nil {
		vTpmEnabled := *typedInput.VTpmEnabled
		uefiSettingsStatus.VTpmEnabled = &vTpmEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromUefiSettingsStatus populates our UefiSettings_Status from the provided source UefiSettings_Status
func (uefiSettingsStatus *UefiSettings_Status) AssignPropertiesFromUefiSettingsStatus(source *v1alpha1api20201201storage.UefiSettings_Status) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		uefiSettingsStatus.SecureBootEnabled = &secureBootEnabled
	} else {
		uefiSettingsStatus.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		uefiSettingsStatus.VTpmEnabled = &vTpmEnabled
	} else {
		uefiSettingsStatus.VTpmEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUefiSettingsStatus populates the provided destination UefiSettings_Status from our UefiSettings_Status
func (uefiSettingsStatus *UefiSettings_Status) AssignPropertiesToUefiSettingsStatus(destination *v1alpha1api20201201storage.UefiSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecureBootEnabled
	if uefiSettingsStatus.SecureBootEnabled != nil {
		secureBootEnabled := *uefiSettingsStatus.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if uefiSettingsStatus.VTpmEnabled != nil {
		vTpmEnabled := *uefiSettingsStatus.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VaultSecretGroup
type VaultSecretGroup struct {
	SourceVault *SubResource `json:"sourceVault,omitempty"`

	//VaultCertificates: The list of key vault references in SourceVault which contain
	//certificates.
	VaultCertificates []VaultCertificate `json:"vaultCertificates,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultSecretGroup{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vaultSecretGroup *VaultSecretGroup) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vaultSecretGroup == nil {
		return nil, nil
	}
	var result VaultSecretGroupARM

	// Set property ‘SourceVault’:
	if vaultSecretGroup.SourceVault != nil {
		sourceVaultARM, err := (*vaultSecretGroup.SourceVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceVault := sourceVaultARM.(SubResourceARM)
		result.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range vaultSecretGroup.VaultCertificates {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VaultCertificates = append(result.VaultCertificates, itemARM.(VaultCertificateARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultSecretGroup *VaultSecretGroup) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultSecretGroupARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultSecretGroup *VaultSecretGroup) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultSecretGroupARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultSecretGroupARM, got %T", armInput)
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		vaultSecretGroup.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range typedInput.VaultCertificates {
		var item1 VaultCertificate
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		vaultSecretGroup.VaultCertificates = append(vaultSecretGroup.VaultCertificates, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultSecretGroup populates our VaultSecretGroup from the provided source VaultSecretGroup
func (vaultSecretGroup *VaultSecretGroup) AssignPropertiesFromVaultSecretGroup(source *v1alpha1api20201201storage.VaultSecretGroup) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSubResource()")
		}
		vaultSecretGroup.SourceVault = &sourceVault
	} else {
		vaultSecretGroup.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate
			err := vaultCertificate.AssignPropertiesFromVaultCertificate(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "populating VaultCertificates from VaultCertificates, calling AssignPropertiesFromVaultCertificate()")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		vaultSecretGroup.VaultCertificates = vaultCertificateList
	} else {
		vaultSecretGroup.VaultCertificates = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultSecretGroup populates the provided destination VaultSecretGroup from our VaultSecretGroup
func (vaultSecretGroup *VaultSecretGroup) AssignPropertiesToVaultSecretGroup(destination *v1alpha1api20201201storage.VaultSecretGroup) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceVault
	if vaultSecretGroup.SourceVault != nil {
		var sourceVault v1alpha1api20201201storage.SubResource
		err := (*vaultSecretGroup.SourceVault).AssignPropertiesToSubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSubResource()")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if vaultSecretGroup.VaultCertificates != nil {
		vaultCertificateList := make([]v1alpha1api20201201storage.VaultCertificate, len(vaultSecretGroup.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range vaultSecretGroup.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate v1alpha1api20201201storage.VaultCertificate
			err := vaultCertificateItem.AssignPropertiesToVaultCertificate(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "populating VaultCertificates from VaultCertificates, calling AssignPropertiesToVaultCertificate()")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VaultSecretGroup_Status struct {
	//SourceVault: The relative URL of the Key Vault containing all of the
	//certificates in VaultCertificates.
	SourceVault *SubResource_Status `json:"sourceVault,omitempty"`

	//VaultCertificates: The list of key vault references in SourceVault which contain
	//certificates.
	VaultCertificates []VaultCertificate_Status `json:"vaultCertificates,omitempty"`
}

var _ genruntime.FromARMConverter = &VaultSecretGroup_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultSecretGroupStatus *VaultSecretGroup_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultSecretGroup_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultSecretGroupStatus *VaultSecretGroup_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultSecretGroup_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultSecretGroup_StatusARM, got %T", armInput)
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource_Status
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		vaultSecretGroupStatus.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range typedInput.VaultCertificates {
		var item1 VaultCertificate_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		vaultSecretGroupStatus.VaultCertificates = append(vaultSecretGroupStatus.VaultCertificates, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultSecretGroupStatus populates our VaultSecretGroup_Status from the provided source VaultSecretGroup_Status
func (vaultSecretGroupStatus *VaultSecretGroup_Status) AssignPropertiesFromVaultSecretGroupStatus(source *v1alpha1api20201201storage.VaultSecretGroup_Status) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_Status
		err := sourceVault.AssignPropertiesFromSubResourceStatus(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSubResourceStatus()")
		}
		vaultSecretGroupStatus.SourceVault = &sourceVault
	} else {
		vaultSecretGroupStatus.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate_Status, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate_Status
			err := vaultCertificate.AssignPropertiesFromVaultCertificateStatus(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "populating VaultCertificates from VaultCertificates, calling AssignPropertiesFromVaultCertificateStatus()")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		vaultSecretGroupStatus.VaultCertificates = vaultCertificateList
	} else {
		vaultSecretGroupStatus.VaultCertificates = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultSecretGroupStatus populates the provided destination VaultSecretGroup_Status from our VaultSecretGroup_Status
func (vaultSecretGroupStatus *VaultSecretGroup_Status) AssignPropertiesToVaultSecretGroupStatus(destination *v1alpha1api20201201storage.VaultSecretGroup_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceVault
	if vaultSecretGroupStatus.SourceVault != nil {
		var sourceVault v1alpha1api20201201storage.SubResource_Status
		err := (*vaultSecretGroupStatus.SourceVault).AssignPropertiesToSubResourceStatus(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if vaultSecretGroupStatus.VaultCertificates != nil {
		vaultCertificateList := make([]v1alpha1api20201201storage.VaultCertificate_Status, len(vaultSecretGroupStatus.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range vaultSecretGroupStatus.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate v1alpha1api20201201storage.VaultCertificate_Status
			err := vaultCertificateItem.AssignPropertiesToVaultCertificateStatus(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "populating VaultCertificates from VaultCertificates, calling AssignPropertiesToVaultCertificateStatus()")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineAgentInstanceView_Status struct {
	//ExtensionHandlers: The virtual machine extension handler instance view.
	ExtensionHandlers []VirtualMachineExtensionHandlerInstanceView_Status `json:"extensionHandlers,omitempty"`

	//Statuses: The resource status information.
	Statuses []InstanceViewStatus_Status `json:"statuses,omitempty"`

	//VmAgentVersion: The VM Agent full version.
	VmAgentVersion *string `json:"vmAgentVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineAgentInstanceView_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineAgentInstanceViewStatus *VirtualMachineAgentInstanceView_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineAgentInstanceView_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineAgentInstanceViewStatus *VirtualMachineAgentInstanceView_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineAgentInstanceView_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineAgentInstanceView_StatusARM, got %T", armInput)
	}

	// Set property ‘ExtensionHandlers’:
	for _, item := range typedInput.ExtensionHandlers {
		var item1 VirtualMachineExtensionHandlerInstanceView_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineAgentInstanceViewStatus.ExtensionHandlers = append(virtualMachineAgentInstanceViewStatus.ExtensionHandlers, item1)
	}

	// Set property ‘Statuses’:
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineAgentInstanceViewStatus.Statuses = append(virtualMachineAgentInstanceViewStatus.Statuses, item1)
	}

	// Set property ‘VmAgentVersion’:
	if typedInput.VmAgentVersion != nil {
		vmAgentVersion := *typedInput.VmAgentVersion
		virtualMachineAgentInstanceViewStatus.VmAgentVersion = &vmAgentVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineAgentInstanceViewStatus populates our VirtualMachineAgentInstanceView_Status from the provided source VirtualMachineAgentInstanceView_Status
func (virtualMachineAgentInstanceViewStatus *VirtualMachineAgentInstanceView_Status) AssignPropertiesFromVirtualMachineAgentInstanceViewStatus(source *v1alpha1api20201201storage.VirtualMachineAgentInstanceView_Status) error {

	// ExtensionHandlers
	if source.ExtensionHandlers != nil {
		extensionHandlerList := make([]VirtualMachineExtensionHandlerInstanceView_Status, len(source.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range source.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler VirtualMachineExtensionHandlerInstanceView_Status
			err := extensionHandler.AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewStatus(&extensionHandlerItem)
			if err != nil {
				return errors.Wrap(err, "populating ExtensionHandlers from ExtensionHandlers, calling AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewStatus()")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		virtualMachineAgentInstanceViewStatus.ExtensionHandlers = extensionHandlerList
	} else {
		virtualMachineAgentInstanceViewStatus.ExtensionHandlers = nil
	}

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_Status, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_Status
			err := status.AssignPropertiesFromInstanceViewStatusStatus(&statusItem)
			if err != nil {
				return errors.Wrap(err, "populating Statuses from Statuses, calling AssignPropertiesFromInstanceViewStatusStatus()")
			}
			statusList[statusIndex] = status
		}
		virtualMachineAgentInstanceViewStatus.Statuses = statusList
	} else {
		virtualMachineAgentInstanceViewStatus.Statuses = nil
	}

	// VmAgentVersion
	virtualMachineAgentInstanceViewStatus.VmAgentVersion = genruntime.ClonePointerToString(source.VmAgentVersion)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineAgentInstanceViewStatus populates the provided destination VirtualMachineAgentInstanceView_Status from our VirtualMachineAgentInstanceView_Status
func (virtualMachineAgentInstanceViewStatus *VirtualMachineAgentInstanceView_Status) AssignPropertiesToVirtualMachineAgentInstanceViewStatus(destination *v1alpha1api20201201storage.VirtualMachineAgentInstanceView_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtensionHandlers
	if virtualMachineAgentInstanceViewStatus.ExtensionHandlers != nil {
		extensionHandlerList := make([]v1alpha1api20201201storage.VirtualMachineExtensionHandlerInstanceView_Status, len(virtualMachineAgentInstanceViewStatus.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range virtualMachineAgentInstanceViewStatus.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler v1alpha1api20201201storage.VirtualMachineExtensionHandlerInstanceView_Status
			err := extensionHandlerItem.AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewStatus(&extensionHandler)
			if err != nil {
				return errors.Wrap(err, "populating ExtensionHandlers from ExtensionHandlers, calling AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewStatus()")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		destination.ExtensionHandlers = extensionHandlerList
	} else {
		destination.ExtensionHandlers = nil
	}

	// Statuses
	if virtualMachineAgentInstanceViewStatus.Statuses != nil {
		statusList := make([]v1alpha1api20201201storage.InstanceViewStatus_Status, len(virtualMachineAgentInstanceViewStatus.Statuses))
		for statusIndex, statusItem := range virtualMachineAgentInstanceViewStatus.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v1alpha1api20201201storage.InstanceViewStatus_Status
			err := statusItem.AssignPropertiesToInstanceViewStatusStatus(&status)
			if err != nil {
				return errors.Wrap(err, "populating Statuses from Statuses, calling AssignPropertiesToInstanceViewStatusStatus()")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgentVersion
	destination.VmAgentVersion = genruntime.ClonePointerToString(virtualMachineAgentInstanceViewStatus.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineExtensionInstanceView_Status struct {
	//Name: The virtual machine extension name.
	Name *string `json:"name,omitempty"`

	//Statuses: The resource status information.
	Statuses []InstanceViewStatus_Status `json:"statuses,omitempty"`

	//Substatuses: The resource status information.
	Substatuses []InstanceViewStatus_Status `json:"substatuses,omitempty"`

	//Type: Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`

	//TypeHandlerVersion: Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineExtensionInstanceView_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineExtensionInstanceViewStatus *VirtualMachineExtensionInstanceView_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineExtensionInstanceView_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineExtensionInstanceViewStatus *VirtualMachineExtensionInstanceView_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineExtensionInstanceView_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineExtensionInstanceView_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineExtensionInstanceViewStatus.Name = &name
	}

	// Set property ‘Statuses’:
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineExtensionInstanceViewStatus.Statuses = append(virtualMachineExtensionInstanceViewStatus.Statuses, item1)
	}

	// Set property ‘Substatuses’:
	for _, item := range typedInput.Substatuses {
		var item1 InstanceViewStatus_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineExtensionInstanceViewStatus.Substatuses = append(virtualMachineExtensionInstanceViewStatus.Substatuses, item1)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineExtensionInstanceViewStatus.Type = &typeVar
	}

	// Set property ‘TypeHandlerVersion’:
	if typedInput.TypeHandlerVersion != nil {
		typeHandlerVersion := *typedInput.TypeHandlerVersion
		virtualMachineExtensionInstanceViewStatus.TypeHandlerVersion = &typeHandlerVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineExtensionInstanceViewStatus populates our VirtualMachineExtensionInstanceView_Status from the provided source VirtualMachineExtensionInstanceView_Status
func (virtualMachineExtensionInstanceViewStatus *VirtualMachineExtensionInstanceView_Status) AssignPropertiesFromVirtualMachineExtensionInstanceViewStatus(source *v1alpha1api20201201storage.VirtualMachineExtensionInstanceView_Status) error {

	// Name
	virtualMachineExtensionInstanceViewStatus.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_Status, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_Status
			err := status.AssignPropertiesFromInstanceViewStatusStatus(&statusItem)
			if err != nil {
				return errors.Wrap(err, "populating Statuses from Statuses, calling AssignPropertiesFromInstanceViewStatusStatus()")
			}
			statusList[statusIndex] = status
		}
		virtualMachineExtensionInstanceViewStatus.Statuses = statusList
	} else {
		virtualMachineExtensionInstanceViewStatus.Statuses = nil
	}

	// Substatuses
	if source.Substatuses != nil {
		substatusList := make([]InstanceViewStatus_Status, len(source.Substatuses))
		for substatusIndex, substatusItem := range source.Substatuses {
			// Shadow the loop variable to avoid aliasing
			substatusItem := substatusItem
			var substatus InstanceViewStatus_Status
			err := substatus.AssignPropertiesFromInstanceViewStatusStatus(&substatusItem)
			if err != nil {
				return errors.Wrap(err, "populating Substatuses from Substatuses, calling AssignPropertiesFromInstanceViewStatusStatus()")
			}
			substatusList[substatusIndex] = substatus
		}
		virtualMachineExtensionInstanceViewStatus.Substatuses = substatusList
	} else {
		virtualMachineExtensionInstanceViewStatus.Substatuses = nil
	}

	// Type
	virtualMachineExtensionInstanceViewStatus.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	virtualMachineExtensionInstanceViewStatus.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionInstanceViewStatus populates the provided destination VirtualMachineExtensionInstanceView_Status from our VirtualMachineExtensionInstanceView_Status
func (virtualMachineExtensionInstanceViewStatus *VirtualMachineExtensionInstanceView_Status) AssignPropertiesToVirtualMachineExtensionInstanceViewStatus(destination *v1alpha1api20201201storage.VirtualMachineExtensionInstanceView_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(virtualMachineExtensionInstanceViewStatus.Name)

	// Statuses
	if virtualMachineExtensionInstanceViewStatus.Statuses != nil {
		statusList := make([]v1alpha1api20201201storage.InstanceViewStatus_Status, len(virtualMachineExtensionInstanceViewStatus.Statuses))
		for statusIndex, statusItem := range virtualMachineExtensionInstanceViewStatus.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v1alpha1api20201201storage.InstanceViewStatus_Status
			err := statusItem.AssignPropertiesToInstanceViewStatusStatus(&status)
			if err != nil {
				return errors.Wrap(err, "populating Statuses from Statuses, calling AssignPropertiesToInstanceViewStatusStatus()")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Substatuses
	if virtualMachineExtensionInstanceViewStatus.Substatuses != nil {
		substatusList := make([]v1alpha1api20201201storage.InstanceViewStatus_Status, len(virtualMachineExtensionInstanceViewStatus.Substatuses))
		for substatusIndex, substatusItem := range virtualMachineExtensionInstanceViewStatus.Substatuses {
			// Shadow the loop variable to avoid aliasing
			substatusItem := substatusItem
			var substatus v1alpha1api20201201storage.InstanceViewStatus_Status
			err := substatusItem.AssignPropertiesToInstanceViewStatusStatus(&substatus)
			if err != nil {
				return errors.Wrap(err, "populating Substatuses from Substatuses, calling AssignPropertiesToInstanceViewStatusStatus()")
			}
			substatusList[substatusIndex] = substatus
		}
		destination.Substatuses = substatusList
	} else {
		destination.Substatuses = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(virtualMachineExtensionInstanceViewStatus.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(virtualMachineExtensionInstanceViewStatus.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineHealthStatus_Status struct {
	//Status: The health status information for the VM.
	Status *InstanceViewStatus_Status `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineHealthStatus_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineHealthStatusStatus *VirtualMachineHealthStatus_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineHealthStatus_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineHealthStatusStatus *VirtualMachineHealthStatus_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineHealthStatus_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineHealthStatus_StatusARM, got %T", armInput)
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		var status1 InstanceViewStatus_Status
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		virtualMachineHealthStatusStatus.Status = &status
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineHealthStatusStatus populates our VirtualMachineHealthStatus_Status from the provided source VirtualMachineHealthStatus_Status
func (virtualMachineHealthStatusStatus *VirtualMachineHealthStatus_Status) AssignPropertiesFromVirtualMachineHealthStatusStatus(source *v1alpha1api20201201storage.VirtualMachineHealthStatus_Status) error {

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_Status
		err := status.AssignPropertiesFromInstanceViewStatusStatus(source.Status)
		if err != nil {
			return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromInstanceViewStatusStatus()")
		}
		virtualMachineHealthStatusStatus.Status = &status
	} else {
		virtualMachineHealthStatusStatus.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineHealthStatusStatus populates the provided destination VirtualMachineHealthStatus_Status from our VirtualMachineHealthStatus_Status
func (virtualMachineHealthStatusStatus *VirtualMachineHealthStatus_Status) AssignPropertiesToVirtualMachineHealthStatusStatus(destination *v1alpha1api20201201storage.VirtualMachineHealthStatus_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Status
	if virtualMachineHealthStatusStatus.Status != nil {
		var status v1alpha1api20201201storage.InstanceViewStatus_Status
		err := (*virtualMachineHealthStatusStatus.Status).AssignPropertiesToInstanceViewStatusStatus(&status)
		if err != nil {
			return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToInstanceViewStatusStatus()")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineIdentity_Status_UserAssignedIdentities struct {
	//ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineIdentity_Status_UserAssignedIdentities{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineIdentityStatusUserAssignedIdentities *VirtualMachineIdentity_Status_UserAssignedIdentities) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineIdentity_Status_UserAssignedIdentitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineIdentityStatusUserAssignedIdentities *VirtualMachineIdentity_Status_UserAssignedIdentities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineIdentity_Status_UserAssignedIdentitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineIdentity_Status_UserAssignedIdentitiesARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		virtualMachineIdentityStatusUserAssignedIdentities.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		virtualMachineIdentityStatusUserAssignedIdentities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineIdentityStatusUserAssignedIdentities populates our VirtualMachineIdentity_Status_UserAssignedIdentities from the provided source VirtualMachineIdentity_Status_UserAssignedIdentities
func (virtualMachineIdentityStatusUserAssignedIdentities *VirtualMachineIdentity_Status_UserAssignedIdentities) AssignPropertiesFromVirtualMachineIdentityStatusUserAssignedIdentities(source *v1alpha1api20201201storage.VirtualMachineIdentity_Status_UserAssignedIdentities) error {

	// ClientId
	virtualMachineIdentityStatusUserAssignedIdentities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	virtualMachineIdentityStatusUserAssignedIdentities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineIdentityStatusUserAssignedIdentities populates the provided destination VirtualMachineIdentity_Status_UserAssignedIdentities from our VirtualMachineIdentity_Status_UserAssignedIdentities
func (virtualMachineIdentityStatusUserAssignedIdentities *VirtualMachineIdentity_Status_UserAssignedIdentities) AssignPropertiesToVirtualMachineIdentityStatusUserAssignedIdentities(destination *v1alpha1api20201201storage.VirtualMachineIdentity_Status_UserAssignedIdentities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(virtualMachineIdentityStatusUserAssignedIdentities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(virtualMachineIdentityStatusUserAssignedIdentities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineInstanceViewStatusHyperVGeneration string

const (
	VirtualMachineInstanceViewStatusHyperVGenerationV1 = VirtualMachineInstanceViewStatusHyperVGeneration("V1")
	VirtualMachineInstanceViewStatusHyperVGenerationV2 = VirtualMachineInstanceViewStatusHyperVGeneration("V2")
)

type VirtualMachinePatchStatus_Status struct {
	//AvailablePatchSummary: The available patch summary of the latest assessment
	//operation for the virtual machine.
	AvailablePatchSummary *AvailablePatchSummary_Status `json:"availablePatchSummary,omitempty"`

	//ConfigurationStatuses: The enablement status of the specified patchMode
	ConfigurationStatuses []InstanceViewStatus_Status `json:"configurationStatuses,omitempty"`

	//LastPatchInstallationSummary: The installation summary of the latest
	//installation operation for the virtual machine.
	LastPatchInstallationSummary *LastPatchInstallationSummary_Status `json:"lastPatchInstallationSummary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachinePatchStatus_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachinePatchStatusStatus *VirtualMachinePatchStatus_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachinePatchStatus_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachinePatchStatusStatus *VirtualMachinePatchStatus_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachinePatchStatus_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachinePatchStatus_StatusARM, got %T", armInput)
	}

	// Set property ‘AvailablePatchSummary’:
	if typedInput.AvailablePatchSummary != nil {
		var availablePatchSummary1 AvailablePatchSummary_Status
		err := availablePatchSummary1.PopulateFromARM(owner, *typedInput.AvailablePatchSummary)
		if err != nil {
			return err
		}
		availablePatchSummary := availablePatchSummary1
		virtualMachinePatchStatusStatus.AvailablePatchSummary = &availablePatchSummary
	}

	// Set property ‘ConfigurationStatuses’:
	for _, item := range typedInput.ConfigurationStatuses {
		var item1 InstanceViewStatus_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachinePatchStatusStatus.ConfigurationStatuses = append(virtualMachinePatchStatusStatus.ConfigurationStatuses, item1)
	}

	// Set property ‘LastPatchInstallationSummary’:
	if typedInput.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary1 LastPatchInstallationSummary_Status
		err := lastPatchInstallationSummary1.PopulateFromARM(owner, *typedInput.LastPatchInstallationSummary)
		if err != nil {
			return err
		}
		lastPatchInstallationSummary := lastPatchInstallationSummary1
		virtualMachinePatchStatusStatus.LastPatchInstallationSummary = &lastPatchInstallationSummary
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachinePatchStatusStatus populates our VirtualMachinePatchStatus_Status from the provided source VirtualMachinePatchStatus_Status
func (virtualMachinePatchStatusStatus *VirtualMachinePatchStatus_Status) AssignPropertiesFromVirtualMachinePatchStatusStatus(source *v1alpha1api20201201storage.VirtualMachinePatchStatus_Status) error {

	// AvailablePatchSummary
	if source.AvailablePatchSummary != nil {
		var availablePatchSummary AvailablePatchSummary_Status
		err := availablePatchSummary.AssignPropertiesFromAvailablePatchSummaryStatus(source.AvailablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "populating AvailablePatchSummary from AvailablePatchSummary, calling AssignPropertiesFromAvailablePatchSummaryStatus()")
		}
		virtualMachinePatchStatusStatus.AvailablePatchSummary = &availablePatchSummary
	} else {
		virtualMachinePatchStatusStatus.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if source.ConfigurationStatuses != nil {
		configurationStatusList := make([]InstanceViewStatus_Status, len(source.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range source.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus InstanceViewStatus_Status
			err := configurationStatus.AssignPropertiesFromInstanceViewStatusStatus(&configurationStatusItem)
			if err != nil {
				return errors.Wrap(err, "populating ConfigurationStatuses from ConfigurationStatuses, calling AssignPropertiesFromInstanceViewStatusStatus()")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		virtualMachinePatchStatusStatus.ConfigurationStatuses = configurationStatusList
	} else {
		virtualMachinePatchStatusStatus.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if source.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary LastPatchInstallationSummary_Status
		err := lastPatchInstallationSummary.AssignPropertiesFromLastPatchInstallationSummaryStatus(source.LastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "populating LastPatchInstallationSummary from LastPatchInstallationSummary, calling AssignPropertiesFromLastPatchInstallationSummaryStatus()")
		}
		virtualMachinePatchStatusStatus.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		virtualMachinePatchStatusStatus.LastPatchInstallationSummary = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinePatchStatusStatus populates the provided destination VirtualMachinePatchStatus_Status from our VirtualMachinePatchStatus_Status
func (virtualMachinePatchStatusStatus *VirtualMachinePatchStatus_Status) AssignPropertiesToVirtualMachinePatchStatusStatus(destination *v1alpha1api20201201storage.VirtualMachinePatchStatus_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailablePatchSummary
	if virtualMachinePatchStatusStatus.AvailablePatchSummary != nil {
		var availablePatchSummary v1alpha1api20201201storage.AvailablePatchSummary_Status
		err := (*virtualMachinePatchStatusStatus.AvailablePatchSummary).AssignPropertiesToAvailablePatchSummaryStatus(&availablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "populating AvailablePatchSummary from AvailablePatchSummary, calling AssignPropertiesToAvailablePatchSummaryStatus()")
		}
		destination.AvailablePatchSummary = &availablePatchSummary
	} else {
		destination.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if virtualMachinePatchStatusStatus.ConfigurationStatuses != nil {
		configurationStatusList := make([]v1alpha1api20201201storage.InstanceViewStatus_Status, len(virtualMachinePatchStatusStatus.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range virtualMachinePatchStatusStatus.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus v1alpha1api20201201storage.InstanceViewStatus_Status
			err := configurationStatusItem.AssignPropertiesToInstanceViewStatusStatus(&configurationStatus)
			if err != nil {
				return errors.Wrap(err, "populating ConfigurationStatuses from ConfigurationStatuses, calling AssignPropertiesToInstanceViewStatusStatus()")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		destination.ConfigurationStatuses = configurationStatusList
	} else {
		destination.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if virtualMachinePatchStatusStatus.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary v1alpha1api20201201storage.LastPatchInstallationSummary_Status
		err := (*virtualMachinePatchStatusStatus.LastPatchInstallationSummary).AssignPropertiesToLastPatchInstallationSummaryStatus(&lastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "populating LastPatchInstallationSummary from LastPatchInstallationSummary, calling AssignPropertiesToLastPatchInstallationSummaryStatus()")
		}
		destination.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		destination.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces struct {
	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces == nil {
		return nil, nil
	}
	var result VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM

	// Set property ‘Id’:
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Properties’:
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Primary != nil {
		result.Properties = &NetworkInterfaceReferencePropertiesARM{}
	}
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Primary != nil {
		primary := *virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Primary
		result.Properties.Primary = &primary
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM, got %T", armInput)
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Primary = &primary
		}
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces populates our VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces from the provided source VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
func (virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(source *v1alpha1api20201201storage.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) error {

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Primary = &primary
	} else {
		virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Reference = &reference
	} else {
		virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces populates the provided destination VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces from our VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
func (virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(destination *v1alpha1api20201201storage.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Primary
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Primary != nil {
		primary := *virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Reference != nil {
		reference := virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WindowsConfiguration
type WindowsConfiguration struct {
	//AdditionalUnattendContent: Specifies additional base-64 encoded XML formatted
	//information that can be included in the Unattend.xml file, which is used by
	//Windows Setup.
	AdditionalUnattendContent []AdditionalUnattendContent `json:"additionalUnattendContent,omitempty"`

	//EnableAutomaticUpdates: Indicates whether Automatic Updates is enabled for the
	//Windows virtual machine. Default value is true.
	//For virtual machine scale sets, this property can be updated and updates will
	//take effect on OS reprovisioning.
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`

	//PatchSettings: Specifies settings related to VM Guest Patching on Windows.
	PatchSettings *PatchSettings `json:"patchSettings,omitempty"`

	//ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned
	//on the virtual machine.
	//When this property is not specified in the request body, default behavior is to
	//set it to true.  This will ensure that VM Agent is installed on the VM so that
	//extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	//TimeZone: Specifies the time zone of the virtual machine. e.g. "Pacific Standard
	//Time".
	//Possible values can be
	//[TimeZoneInfo.Id](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id)
	//value from time zones returned by
	//[TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.getsystemtimezones).
	TimeZone *string `json:"timeZone,omitempty"`

	//WinRM: Describes Windows Remote Management configuration of the VM
	WinRM *WinRMConfiguration `json:"winRM,omitempty"`
}

var _ genruntime.ARMTransformer = &WindowsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (windowsConfiguration *WindowsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if windowsConfiguration == nil {
		return nil, nil
	}
	var result WindowsConfigurationARM

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range windowsConfiguration.AdditionalUnattendContent {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AdditionalUnattendContent = append(result.AdditionalUnattendContent, itemARM.(AdditionalUnattendContentARM))
	}

	// Set property ‘EnableAutomaticUpdates’:
	if windowsConfiguration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *windowsConfiguration.EnableAutomaticUpdates
		result.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if windowsConfiguration.PatchSettings != nil {
		patchSettingsARM, err := (*windowsConfiguration.PatchSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		patchSettings := patchSettingsARM.(PatchSettingsARM)
		result.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if windowsConfiguration.ProvisionVMAgent != nil {
		provisionVMAgent := *windowsConfiguration.ProvisionVMAgent
		result.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if windowsConfiguration.TimeZone != nil {
		timeZone := *windowsConfiguration.TimeZone
		result.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if windowsConfiguration.WinRM != nil {
		winRMARM, err := (*windowsConfiguration.WinRM).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		winRM := winRMARM.(WinRMConfigurationARM)
		result.WinRM = &winRM
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (windowsConfiguration *WindowsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WindowsConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (windowsConfiguration *WindowsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WindowsConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WindowsConfigurationARM, got %T", armInput)
	}

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range typedInput.AdditionalUnattendContent {
		var item1 AdditionalUnattendContent
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		windowsConfiguration.AdditionalUnattendContent = append(windowsConfiguration.AdditionalUnattendContent, item1)
	}

	// Set property ‘EnableAutomaticUpdates’:
	if typedInput.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *typedInput.EnableAutomaticUpdates
		windowsConfiguration.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 PatchSettings
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		windowsConfiguration.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		windowsConfiguration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		windowsConfiguration.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if typedInput.WinRM != nil {
		var winRM1 WinRMConfiguration
		err := winRM1.PopulateFromARM(owner, *typedInput.WinRM)
		if err != nil {
			return err
		}
		winRM := winRM1
		windowsConfiguration.WinRM = &winRM
	}

	// No error
	return nil
}

// AssignPropertiesFromWindowsConfiguration populates our WindowsConfiguration from the provided source WindowsConfiguration
func (windowsConfiguration *WindowsConfiguration) AssignPropertiesFromWindowsConfiguration(source *v1alpha1api20201201storage.WindowsConfiguration) error {

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent
			err := additionalUnattendContent.AssignPropertiesFromAdditionalUnattendContent(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "populating AdditionalUnattendContent from AdditionalUnattendContent, calling AssignPropertiesFromAdditionalUnattendContent()")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		windowsConfiguration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		windowsConfiguration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		windowsConfiguration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		windowsConfiguration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings
		err := patchSetting.AssignPropertiesFromPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesFromPatchSettings()")
		}
		windowsConfiguration.PatchSettings = &patchSetting
	} else {
		windowsConfiguration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		windowsConfiguration.ProvisionVMAgent = &provisionVMAgent
	} else {
		windowsConfiguration.ProvisionVMAgent = nil
	}

	// TimeZone
	windowsConfiguration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration
		err := winRM.AssignPropertiesFromWinRMConfiguration(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "populating WinRM from WinRM, calling AssignPropertiesFromWinRMConfiguration()")
		}
		windowsConfiguration.WinRM = &winRM
	} else {
		windowsConfiguration.WinRM = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWindowsConfiguration populates the provided destination WindowsConfiguration from our WindowsConfiguration
func (windowsConfiguration *WindowsConfiguration) AssignPropertiesToWindowsConfiguration(destination *v1alpha1api20201201storage.WindowsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalUnattendContent
	if windowsConfiguration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]v1alpha1api20201201storage.AdditionalUnattendContent, len(windowsConfiguration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range windowsConfiguration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent v1alpha1api20201201storage.AdditionalUnattendContent
			err := additionalUnattendContentItem.AssignPropertiesToAdditionalUnattendContent(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "populating AdditionalUnattendContent from AdditionalUnattendContent, calling AssignPropertiesToAdditionalUnattendContent()")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if windowsConfiguration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *windowsConfiguration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if windowsConfiguration.PatchSettings != nil {
		var patchSetting v1alpha1api20201201storage.PatchSettings
		err := (*windowsConfiguration.PatchSettings).AssignPropertiesToPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesToPatchSettings()")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if windowsConfiguration.ProvisionVMAgent != nil {
		provisionVMAgent := *windowsConfiguration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(windowsConfiguration.TimeZone)

	// WinRM
	if windowsConfiguration.WinRM != nil {
		var winRM v1alpha1api20201201storage.WinRMConfiguration
		err := (*windowsConfiguration.WinRM).AssignPropertiesToWinRMConfiguration(&winRM)
		if err != nil {
			return errors.Wrap(err, "populating WinRM from WinRM, calling AssignPropertiesToWinRMConfiguration()")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WindowsConfiguration_Status struct {
	//AdditionalUnattendContent: Specifies additional base-64 encoded XML formatted
	//information that can be included in the Unattend.xml file, which is used by
	//Windows Setup.
	AdditionalUnattendContent []AdditionalUnattendContent_Status `json:"additionalUnattendContent,omitempty"`

	//EnableAutomaticUpdates: Indicates whether Automatic Updates is enabled for the
	//Windows virtual machine. Default value is true.
	//For virtual machine scale sets, this property can be updated and updates will
	//take effect on OS reprovisioning.
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`

	//PatchSettings: [Preview Feature] Specifies settings related to VM Guest Patching
	//on Windows.
	PatchSettings *PatchSettings_Status `json:"patchSettings,omitempty"`

	//ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned
	//on the virtual machine.
	//When this property is not specified in the request body, default behavior is to
	//set it to true.  This will ensure that VM Agent is installed on the VM so that
	//extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	//TimeZone: Specifies the time zone of the virtual machine. e.g. "Pacific Standard
	//Time".
	//Possible values can be
	//[TimeZoneInfo.Id](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id)
	//value from time zones returned by
	//[TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.getsystemtimezones).
	TimeZone *string `json:"timeZone,omitempty"`

	//WinRM: Specifies the Windows Remote Management listeners. This enables remote
	//Windows PowerShell.
	WinRM *WinRMConfiguration_Status `json:"winRM,omitempty"`
}

var _ genruntime.FromARMConverter = &WindowsConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (windowsConfigurationStatus *WindowsConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WindowsConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (windowsConfigurationStatus *WindowsConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WindowsConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WindowsConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range typedInput.AdditionalUnattendContent {
		var item1 AdditionalUnattendContent_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		windowsConfigurationStatus.AdditionalUnattendContent = append(windowsConfigurationStatus.AdditionalUnattendContent, item1)
	}

	// Set property ‘EnableAutomaticUpdates’:
	if typedInput.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *typedInput.EnableAutomaticUpdates
		windowsConfigurationStatus.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 PatchSettings_Status
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		windowsConfigurationStatus.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		windowsConfigurationStatus.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		windowsConfigurationStatus.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if typedInput.WinRM != nil {
		var winRM1 WinRMConfiguration_Status
		err := winRM1.PopulateFromARM(owner, *typedInput.WinRM)
		if err != nil {
			return err
		}
		winRM := winRM1
		windowsConfigurationStatus.WinRM = &winRM
	}

	// No error
	return nil
}

// AssignPropertiesFromWindowsConfigurationStatus populates our WindowsConfiguration_Status from the provided source WindowsConfiguration_Status
func (windowsConfigurationStatus *WindowsConfiguration_Status) AssignPropertiesFromWindowsConfigurationStatus(source *v1alpha1api20201201storage.WindowsConfiguration_Status) error {

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent_Status, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent_Status
			err := additionalUnattendContent.AssignPropertiesFromAdditionalUnattendContentStatus(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "populating AdditionalUnattendContent from AdditionalUnattendContent, calling AssignPropertiesFromAdditionalUnattendContentStatus()")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		windowsConfigurationStatus.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		windowsConfigurationStatus.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		windowsConfigurationStatus.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		windowsConfigurationStatus.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings_Status
		err := patchSetting.AssignPropertiesFromPatchSettingsStatus(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesFromPatchSettingsStatus()")
		}
		windowsConfigurationStatus.PatchSettings = &patchSetting
	} else {
		windowsConfigurationStatus.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		windowsConfigurationStatus.ProvisionVMAgent = &provisionVMAgent
	} else {
		windowsConfigurationStatus.ProvisionVMAgent = nil
	}

	// TimeZone
	windowsConfigurationStatus.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration_Status
		err := winRM.AssignPropertiesFromWinRMConfigurationStatus(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "populating WinRM from WinRM, calling AssignPropertiesFromWinRMConfigurationStatus()")
		}
		windowsConfigurationStatus.WinRM = &winRM
	} else {
		windowsConfigurationStatus.WinRM = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWindowsConfigurationStatus populates the provided destination WindowsConfiguration_Status from our WindowsConfiguration_Status
func (windowsConfigurationStatus *WindowsConfiguration_Status) AssignPropertiesToWindowsConfigurationStatus(destination *v1alpha1api20201201storage.WindowsConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalUnattendContent
	if windowsConfigurationStatus.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]v1alpha1api20201201storage.AdditionalUnattendContent_Status, len(windowsConfigurationStatus.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range windowsConfigurationStatus.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent v1alpha1api20201201storage.AdditionalUnattendContent_Status
			err := additionalUnattendContentItem.AssignPropertiesToAdditionalUnattendContentStatus(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "populating AdditionalUnattendContent from AdditionalUnattendContent, calling AssignPropertiesToAdditionalUnattendContentStatus()")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if windowsConfigurationStatus.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *windowsConfigurationStatus.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if windowsConfigurationStatus.PatchSettings != nil {
		var patchSetting v1alpha1api20201201storage.PatchSettings_Status
		err := (*windowsConfigurationStatus.PatchSettings).AssignPropertiesToPatchSettingsStatus(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesToPatchSettingsStatus()")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if windowsConfigurationStatus.ProvisionVMAgent != nil {
		provisionVMAgent := *windowsConfigurationStatus.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(windowsConfigurationStatus.TimeZone)

	// WinRM
	if windowsConfigurationStatus.WinRM != nil {
		var winRM v1alpha1api20201201storage.WinRMConfiguration_Status
		err := (*windowsConfigurationStatus.WinRM).AssignPropertiesToWinRMConfigurationStatus(&winRM)
		if err != nil {
			return errors.Wrap(err, "populating WinRM from WinRM, calling AssignPropertiesToWinRMConfigurationStatus()")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/AdditionalUnattendContent
type AdditionalUnattendContent struct {
	//ComponentName: The component name. Currently, the only allowable value is
	//Microsoft-Windows-Shell-Setup.
	ComponentName *AdditionalUnattendContentComponentName `json:"componentName,omitempty"`

	//Content: Specifies the XML formatted content that is added to the unattend.xml
	//file for the specified path and component. The XML must be less than 4KB and
	//must include the root element for the setting or feature that is being inserted.
	Content *string `json:"content,omitempty"`

	//PassName: The pass name. Currently, the only allowable value is OobeSystem.
	PassName *AdditionalUnattendContentPassName `json:"passName,omitempty"`

	//SettingName: Specifies the name of the setting to which the content applies.
	//Possible values are: FirstLogonCommands and AutoLogon.
	SettingName *AdditionalUnattendContentSettingName `json:"settingName,omitempty"`
}

var _ genruntime.ARMTransformer = &AdditionalUnattendContent{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (additionalUnattendContent *AdditionalUnattendContent) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if additionalUnattendContent == nil {
		return nil, nil
	}
	var result AdditionalUnattendContentARM

	// Set property ‘ComponentName’:
	if additionalUnattendContent.ComponentName != nil {
		componentName := *additionalUnattendContent.ComponentName
		result.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if additionalUnattendContent.Content != nil {
		content := *additionalUnattendContent.Content
		result.Content = &content
	}

	// Set property ‘PassName’:
	if additionalUnattendContent.PassName != nil {
		passName := *additionalUnattendContent.PassName
		result.PassName = &passName
	}

	// Set property ‘SettingName’:
	if additionalUnattendContent.SettingName != nil {
		settingName := *additionalUnattendContent.SettingName
		result.SettingName = &settingName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (additionalUnattendContent *AdditionalUnattendContent) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalUnattendContentARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (additionalUnattendContent *AdditionalUnattendContent) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalUnattendContentARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalUnattendContentARM, got %T", armInput)
	}

	// Set property ‘ComponentName’:
	if typedInput.ComponentName != nil {
		componentName := *typedInput.ComponentName
		additionalUnattendContent.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if typedInput.Content != nil {
		content := *typedInput.Content
		additionalUnattendContent.Content = &content
	}

	// Set property ‘PassName’:
	if typedInput.PassName != nil {
		passName := *typedInput.PassName
		additionalUnattendContent.PassName = &passName
	}

	// Set property ‘SettingName’:
	if typedInput.SettingName != nil {
		settingName := *typedInput.SettingName
		additionalUnattendContent.SettingName = &settingName
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalUnattendContent populates our AdditionalUnattendContent from the provided source AdditionalUnattendContent
func (additionalUnattendContent *AdditionalUnattendContent) AssignPropertiesFromAdditionalUnattendContent(source *v1alpha1api20201201storage.AdditionalUnattendContent) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := AdditionalUnattendContentComponentName(*source.ComponentName)
		additionalUnattendContent.ComponentName = &componentName
	} else {
		additionalUnattendContent.ComponentName = nil
	}

	// Content
	additionalUnattendContent.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	if source.PassName != nil {
		passName := AdditionalUnattendContentPassName(*source.PassName)
		additionalUnattendContent.PassName = &passName
	} else {
		additionalUnattendContent.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := AdditionalUnattendContentSettingName(*source.SettingName)
		additionalUnattendContent.SettingName = &settingName
	} else {
		additionalUnattendContent.SettingName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalUnattendContent populates the provided destination AdditionalUnattendContent from our AdditionalUnattendContent
func (additionalUnattendContent *AdditionalUnattendContent) AssignPropertiesToAdditionalUnattendContent(destination *v1alpha1api20201201storage.AdditionalUnattendContent) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComponentName
	if additionalUnattendContent.ComponentName != nil {
		componentName := string(*additionalUnattendContent.ComponentName)
		destination.ComponentName = &componentName
	} else {
		destination.ComponentName = nil
	}

	// Content
	destination.Content = genruntime.ClonePointerToString(additionalUnattendContent.Content)

	// PassName
	if additionalUnattendContent.PassName != nil {
		passName := string(*additionalUnattendContent.PassName)
		destination.PassName = &passName
	} else {
		destination.PassName = nil
	}

	// SettingName
	if additionalUnattendContent.SettingName != nil {
		settingName := string(*additionalUnattendContent.SettingName)
		destination.SettingName = &settingName
	} else {
		destination.SettingName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AdditionalUnattendContent_Status struct {
	//ComponentName: The component name. Currently, the only allowable value is
	//Microsoft-Windows-Shell-Setup.
	ComponentName *AdditionalUnattendContentStatusComponentName `json:"componentName,omitempty"`

	//Content: Specifies the XML formatted content that is added to the unattend.xml
	//file for the specified path and component. The XML must be less than 4KB and
	//must include the root element for the setting or feature that is being inserted.
	Content *string `json:"content,omitempty"`

	//PassName: The pass name. Currently, the only allowable value is OobeSystem.
	PassName *AdditionalUnattendContentStatusPassName `json:"passName,omitempty"`

	//SettingName: Specifies the name of the setting to which the content applies.
	//Possible values are: FirstLogonCommands and AutoLogon.
	SettingName *AdditionalUnattendContentStatusSettingName `json:"settingName,omitempty"`
}

var _ genruntime.FromARMConverter = &AdditionalUnattendContent_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (additionalUnattendContentStatus *AdditionalUnattendContent_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalUnattendContent_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (additionalUnattendContentStatus *AdditionalUnattendContent_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalUnattendContent_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalUnattendContent_StatusARM, got %T", armInput)
	}

	// Set property ‘ComponentName’:
	if typedInput.ComponentName != nil {
		componentName := *typedInput.ComponentName
		additionalUnattendContentStatus.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if typedInput.Content != nil {
		content := *typedInput.Content
		additionalUnattendContentStatus.Content = &content
	}

	// Set property ‘PassName’:
	if typedInput.PassName != nil {
		passName := *typedInput.PassName
		additionalUnattendContentStatus.PassName = &passName
	}

	// Set property ‘SettingName’:
	if typedInput.SettingName != nil {
		settingName := *typedInput.SettingName
		additionalUnattendContentStatus.SettingName = &settingName
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalUnattendContentStatus populates our AdditionalUnattendContent_Status from the provided source AdditionalUnattendContent_Status
func (additionalUnattendContentStatus *AdditionalUnattendContent_Status) AssignPropertiesFromAdditionalUnattendContentStatus(source *v1alpha1api20201201storage.AdditionalUnattendContent_Status) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := AdditionalUnattendContentStatusComponentName(*source.ComponentName)
		additionalUnattendContentStatus.ComponentName = &componentName
	} else {
		additionalUnattendContentStatus.ComponentName = nil
	}

	// Content
	additionalUnattendContentStatus.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	if source.PassName != nil {
		passName := AdditionalUnattendContentStatusPassName(*source.PassName)
		additionalUnattendContentStatus.PassName = &passName
	} else {
		additionalUnattendContentStatus.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := AdditionalUnattendContentStatusSettingName(*source.SettingName)
		additionalUnattendContentStatus.SettingName = &settingName
	} else {
		additionalUnattendContentStatus.SettingName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalUnattendContentStatus populates the provided destination AdditionalUnattendContent_Status from our AdditionalUnattendContent_Status
func (additionalUnattendContentStatus *AdditionalUnattendContent_Status) AssignPropertiesToAdditionalUnattendContentStatus(destination *v1alpha1api20201201storage.AdditionalUnattendContent_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComponentName
	if additionalUnattendContentStatus.ComponentName != nil {
		componentName := string(*additionalUnattendContentStatus.ComponentName)
		destination.ComponentName = &componentName
	} else {
		destination.ComponentName = nil
	}

	// Content
	destination.Content = genruntime.ClonePointerToString(additionalUnattendContentStatus.Content)

	// PassName
	if additionalUnattendContentStatus.PassName != nil {
		passName := string(*additionalUnattendContentStatus.PassName)
		destination.PassName = &passName
	} else {
		destination.PassName = nil
	}

	// SettingName
	if additionalUnattendContentStatus.SettingName != nil {
		settingName := string(*additionalUnattendContentStatus.SettingName)
		destination.SettingName = &settingName
	} else {
		destination.SettingName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AvailablePatchSummary_Status struct {
	//AssessmentActivityId: The activity ID of the operation that produced this
	//result. It is used to correlate across CRP and extension logs.
	AssessmentActivityId *string `json:"assessmentActivityId,omitempty"`

	//CriticalAndSecurityPatchCount: The number of critical or security patches that
	//have been detected as available and not yet installed.
	CriticalAndSecurityPatchCount *int `json:"criticalAndSecurityPatchCount,omitempty"`

	//Error: The errors that were encountered during execution of the operation. The
	//details array contains the list of them.
	Error *ApiError_Status `json:"error,omitempty"`

	//LastModifiedTime: The UTC timestamp when the operation began.
	LastModifiedTime *string `json:"lastModifiedTime,omitempty"`

	//OtherPatchCount: The number of all available patches excluding critical and
	//security.
	OtherPatchCount *int `json:"otherPatchCount,omitempty"`

	//RebootPending: The overall reboot status of the VM. It will be true when
	//partially installed patches require a reboot to complete installation but the
	//reboot has not yet occurred.
	RebootPending *bool `json:"rebootPending,omitempty"`

	//StartTime: The UTC timestamp when the operation began.
	StartTime *string `json:"startTime,omitempty"`

	//Status: The overall success or failure status of the operation. It remains
	//"InProgress" until the operation completes. At that point it will become
	//"Unknown", "Failed", "Succeeded", or "CompletedWithWarnings."
	Status *AvailablePatchSummaryStatusStatus `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &AvailablePatchSummary_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (availablePatchSummaryStatus *AvailablePatchSummary_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AvailablePatchSummary_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (availablePatchSummaryStatus *AvailablePatchSummary_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AvailablePatchSummary_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AvailablePatchSummary_StatusARM, got %T", armInput)
	}

	// Set property ‘AssessmentActivityId’:
	if typedInput.AssessmentActivityId != nil {
		assessmentActivityId := *typedInput.AssessmentActivityId
		availablePatchSummaryStatus.AssessmentActivityId = &assessmentActivityId
	}

	// Set property ‘CriticalAndSecurityPatchCount’:
	if typedInput.CriticalAndSecurityPatchCount != nil {
		criticalAndSecurityPatchCount := *typedInput.CriticalAndSecurityPatchCount
		availablePatchSummaryStatus.CriticalAndSecurityPatchCount = &criticalAndSecurityPatchCount
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error1 ApiError_Status
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		availablePatchSummaryStatus.Error = &error
	}

	// Set property ‘LastModifiedTime’:
	if typedInput.LastModifiedTime != nil {
		lastModifiedTime := *typedInput.LastModifiedTime
		availablePatchSummaryStatus.LastModifiedTime = &lastModifiedTime
	}

	// Set property ‘OtherPatchCount’:
	if typedInput.OtherPatchCount != nil {
		otherPatchCount := *typedInput.OtherPatchCount
		availablePatchSummaryStatus.OtherPatchCount = &otherPatchCount
	}

	// Set property ‘RebootPending’:
	if typedInput.RebootPending != nil {
		rebootPending := *typedInput.RebootPending
		availablePatchSummaryStatus.RebootPending = &rebootPending
	}

	// Set property ‘StartTime’:
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		availablePatchSummaryStatus.StartTime = &startTime
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		availablePatchSummaryStatus.Status = &status
	}

	// No error
	return nil
}

// AssignPropertiesFromAvailablePatchSummaryStatus populates our AvailablePatchSummary_Status from the provided source AvailablePatchSummary_Status
func (availablePatchSummaryStatus *AvailablePatchSummary_Status) AssignPropertiesFromAvailablePatchSummaryStatus(source *v1alpha1api20201201storage.AvailablePatchSummary_Status) error {

	// AssessmentActivityId
	availablePatchSummaryStatus.AssessmentActivityId = genruntime.ClonePointerToString(source.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	availablePatchSummaryStatus.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(source.CriticalAndSecurityPatchCount)

	// Error
	if source.Error != nil {
		var error ApiError_Status
		err := error.AssignPropertiesFromApiErrorStatus(source.Error)
		if err != nil {
			return errors.Wrap(err, "populating Error from Error, calling AssignPropertiesFromApiErrorStatus()")
		}
		availablePatchSummaryStatus.Error = &error
	} else {
		availablePatchSummaryStatus.Error = nil
	}

	// LastModifiedTime
	availablePatchSummaryStatus.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// OtherPatchCount
	availablePatchSummaryStatus.OtherPatchCount = genruntime.ClonePointerToInt(source.OtherPatchCount)

	// RebootPending
	if source.RebootPending != nil {
		rebootPending := *source.RebootPending
		availablePatchSummaryStatus.RebootPending = &rebootPending
	} else {
		availablePatchSummaryStatus.RebootPending = nil
	}

	// StartTime
	availablePatchSummaryStatus.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	if source.Status != nil {
		status := AvailablePatchSummaryStatusStatus(*source.Status)
		availablePatchSummaryStatus.Status = &status
	} else {
		availablePatchSummaryStatus.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAvailablePatchSummaryStatus populates the provided destination AvailablePatchSummary_Status from our AvailablePatchSummary_Status
func (availablePatchSummaryStatus *AvailablePatchSummary_Status) AssignPropertiesToAvailablePatchSummaryStatus(destination *v1alpha1api20201201storage.AvailablePatchSummary_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssessmentActivityId
	destination.AssessmentActivityId = genruntime.ClonePointerToString(availablePatchSummaryStatus.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	destination.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(availablePatchSummaryStatus.CriticalAndSecurityPatchCount)

	// Error
	if availablePatchSummaryStatus.Error != nil {
		var error v1alpha1api20201201storage.ApiError_Status
		err := (*availablePatchSummaryStatus.Error).AssignPropertiesToApiErrorStatus(&error)
		if err != nil {
			return errors.Wrap(err, "populating Error from Error, calling AssignPropertiesToApiErrorStatus()")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(availablePatchSummaryStatus.LastModifiedTime)

	// OtherPatchCount
	destination.OtherPatchCount = genruntime.ClonePointerToInt(availablePatchSummaryStatus.OtherPatchCount)

	// RebootPending
	if availablePatchSummaryStatus.RebootPending != nil {
		rebootPending := *availablePatchSummaryStatus.RebootPending
		destination.RebootPending = &rebootPending
	} else {
		destination.RebootPending = nil
	}

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(availablePatchSummaryStatus.StartTime)

	// Status
	if availablePatchSummaryStatus.Status != nil {
		status := string(*availablePatchSummaryStatus.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Caching_Status string

const (
	Caching_StatusNone      = Caching_Status("None")
	Caching_StatusReadOnly  = Caching_Status("ReadOnly")
	Caching_StatusReadWrite = Caching_Status("ReadWrite")
)

type CreateOption_Status string

const (
	CreateOption_StatusAttach    = CreateOption_Status("Attach")
	CreateOption_StatusEmpty     = CreateOption_Status("Empty")
	CreateOption_StatusFromImage = CreateOption_Status("FromImage")
)

// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type DataDiskCaching string

const (
	DataDiskCachingNone      = DataDiskCaching("None")
	DataDiskCachingReadOnly  = DataDiskCaching("ReadOnly")
	DataDiskCachingReadWrite = DataDiskCaching("ReadWrite")
)

// +kubebuilder:validation:Enum={"Attach","Empty","FromImage"}
type DataDiskCreateOption string

const (
	DataDiskCreateOptionAttach    = DataDiskCreateOption("Attach")
	DataDiskCreateOptionEmpty     = DataDiskCreateOption("Empty")
	DataDiskCreateOptionFromImage = DataDiskCreateOption("FromImage")
)

// +kubebuilder:validation:Enum={"ForceDetach"}
type DataDiskDetachOption string

const DataDiskDetachOptionForceDetach = DataDiskDetachOption("ForceDetach")

type DetachOption_Status string

const DetachOption_StatusForceDetach = DetachOption_Status("ForceDetach")

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiffDiskSettings
type DiffDiskSettings struct {
	//Option: Specifies the ephemeral disk settings for operating system disk.
	Option *DiffDiskSettingsOption `json:"option,omitempty"`

	//Placement: Specifies the ephemeral disk placement for operating system disk.
	//Possible values are:
	//CacheDisk
	//ResourceDisk
	//Default: CacheDisk if one is configured for the VM size otherwise ResourceDisk
	//is used.
	//Refer to VM size documentation for Windows VM at
	//https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes and Linux
	//VM at https://docs.microsoft.com/en-us/azure/virtual-machines/linux/sizes to
	//check which VM sizes exposes a cache disk.
	Placement *DiffDiskSettingsPlacement `json:"placement,omitempty"`
}

var _ genruntime.ARMTransformer = &DiffDiskSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diffDiskSettings *DiffDiskSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diffDiskSettings == nil {
		return nil, nil
	}
	var result DiffDiskSettingsARM

	// Set property ‘Option’:
	if diffDiskSettings.Option != nil {
		option := *diffDiskSettings.Option
		result.Option = &option
	}

	// Set property ‘Placement’:
	if diffDiskSettings.Placement != nil {
		placement := *diffDiskSettings.Placement
		result.Placement = &placement
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diffDiskSettings *DiffDiskSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiffDiskSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diffDiskSettings *DiffDiskSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiffDiskSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiffDiskSettingsARM, got %T", armInput)
	}

	// Set property ‘Option’:
	if typedInput.Option != nil {
		option := *typedInput.Option
		diffDiskSettings.Option = &option
	}

	// Set property ‘Placement’:
	if typedInput.Placement != nil {
		placement := *typedInput.Placement
		diffDiskSettings.Placement = &placement
	}

	// No error
	return nil
}

// AssignPropertiesFromDiffDiskSettings populates our DiffDiskSettings from the provided source DiffDiskSettings
func (diffDiskSettings *DiffDiskSettings) AssignPropertiesFromDiffDiskSettings(source *v1alpha1api20201201storage.DiffDiskSettings) error {

	// Option
	if source.Option != nil {
		option := DiffDiskSettingsOption(*source.Option)
		diffDiskSettings.Option = &option
	} else {
		diffDiskSettings.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := DiffDiskSettingsPlacement(*source.Placement)
		diffDiskSettings.Placement = &placement
	} else {
		diffDiskSettings.Placement = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiffDiskSettings populates the provided destination DiffDiskSettings from our DiffDiskSettings
func (diffDiskSettings *DiffDiskSettings) AssignPropertiesToDiffDiskSettings(destination *v1alpha1api20201201storage.DiffDiskSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Option
	if diffDiskSettings.Option != nil {
		option := string(*diffDiskSettings.Option)
		destination.Option = &option
	} else {
		destination.Option = nil
	}

	// Placement
	if diffDiskSettings.Placement != nil {
		placement := string(*diffDiskSettings.Placement)
		destination.Placement = &placement
	} else {
		destination.Placement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DiffDiskSettings_Status struct {
	//Option: Specifies the ephemeral disk settings for operating system disk.
	Option *DiffDiskOption_Status `json:"option,omitempty"`

	//Placement: Specifies the ephemeral disk placement for operating system disk.
	//Possible values are:
	//CacheDisk
	//ResourceDisk
	//Default: CacheDisk if one is configured for the VM size otherwise ResourceDisk
	//is used.
	//Refer to VM size documentation for Windows VM at
	//https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes and Linux
	//VM at https://docs.microsoft.com/en-us/azure/virtual-machines/linux/sizes to
	//check which VM sizes exposes a cache disk.
	Placement *DiffDiskPlacement_Status `json:"placement,omitempty"`
}

var _ genruntime.FromARMConverter = &DiffDiskSettings_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diffDiskSettingsStatus *DiffDiskSettings_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiffDiskSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diffDiskSettingsStatus *DiffDiskSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiffDiskSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiffDiskSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘Option’:
	if typedInput.Option != nil {
		option := *typedInput.Option
		diffDiskSettingsStatus.Option = &option
	}

	// Set property ‘Placement’:
	if typedInput.Placement != nil {
		placement := *typedInput.Placement
		diffDiskSettingsStatus.Placement = &placement
	}

	// No error
	return nil
}

// AssignPropertiesFromDiffDiskSettingsStatus populates our DiffDiskSettings_Status from the provided source DiffDiskSettings_Status
func (diffDiskSettingsStatus *DiffDiskSettings_Status) AssignPropertiesFromDiffDiskSettingsStatus(source *v1alpha1api20201201storage.DiffDiskSettings_Status) error {

	// Option
	if source.Option != nil {
		option := DiffDiskOption_Status(*source.Option)
		diffDiskSettingsStatus.Option = &option
	} else {
		diffDiskSettingsStatus.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := DiffDiskPlacement_Status(*source.Placement)
		diffDiskSettingsStatus.Placement = &placement
	} else {
		diffDiskSettingsStatus.Placement = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiffDiskSettingsStatus populates the provided destination DiffDiskSettings_Status from our DiffDiskSettings_Status
func (diffDiskSettingsStatus *DiffDiskSettings_Status) AssignPropertiesToDiffDiskSettingsStatus(destination *v1alpha1api20201201storage.DiffDiskSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Option
	if diffDiskSettingsStatus.Option != nil {
		option := string(*diffDiskSettingsStatus.Option)
		destination.Option = &option
	} else {
		destination.Option = nil
	}

	// Placement
	if diffDiskSettingsStatus.Placement != nil {
		placement := string(*diffDiskSettingsStatus.Placement)
		destination.Placement = &placement
	} else {
		destination.Placement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiskEncryptionSettings
type DiskEncryptionSettings struct {
	//DiskEncryptionKey: Describes a reference to Key Vault Secret
	DiskEncryptionKey *KeyVaultSecretReference `json:"diskEncryptionKey,omitempty"`

	//Enabled: Specifies whether disk encryption should be enabled on the virtual
	//machine.
	Enabled *bool `json:"enabled,omitempty"`

	//KeyEncryptionKey: Describes a reference to Key Vault Key
	KeyEncryptionKey *KeyVaultKeyReference `json:"keyEncryptionKey,omitempty"`
}

var _ genruntime.ARMTransformer = &DiskEncryptionSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diskEncryptionSettings *DiskEncryptionSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diskEncryptionSettings == nil {
		return nil, nil
	}
	var result DiskEncryptionSettingsARM

	// Set property ‘DiskEncryptionKey’:
	if diskEncryptionSettings.DiskEncryptionKey != nil {
		diskEncryptionKeyARM, err := (*diskEncryptionSettings.DiskEncryptionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionKey := diskEncryptionKeyARM.(KeyVaultSecretReferenceARM)
		result.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘Enabled’:
	if diskEncryptionSettings.Enabled != nil {
		enabled := *diskEncryptionSettings.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘KeyEncryptionKey’:
	if diskEncryptionSettings.KeyEncryptionKey != nil {
		keyEncryptionKeyARM, err := (*diskEncryptionSettings.KeyEncryptionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyEncryptionKey := keyEncryptionKeyARM.(KeyVaultKeyReferenceARM)
		result.KeyEncryptionKey = &keyEncryptionKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diskEncryptionSettings *DiskEncryptionSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskEncryptionSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diskEncryptionSettings *DiskEncryptionSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiskEncryptionSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskEncryptionSettingsARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionKey’:
	if typedInput.DiskEncryptionKey != nil {
		var diskEncryptionKey1 KeyVaultSecretReference
		err := diskEncryptionKey1.PopulateFromARM(owner, *typedInput.DiskEncryptionKey)
		if err != nil {
			return err
		}
		diskEncryptionKey := diskEncryptionKey1
		diskEncryptionSettings.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		diskEncryptionSettings.Enabled = &enabled
	}

	// Set property ‘KeyEncryptionKey’:
	if typedInput.KeyEncryptionKey != nil {
		var keyEncryptionKey1 KeyVaultKeyReference
		err := keyEncryptionKey1.PopulateFromARM(owner, *typedInput.KeyEncryptionKey)
		if err != nil {
			return err
		}
		keyEncryptionKey := keyEncryptionKey1
		diskEncryptionSettings.KeyEncryptionKey = &keyEncryptionKey
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskEncryptionSettings populates our DiskEncryptionSettings from the provided source DiskEncryptionSettings
func (diskEncryptionSettings *DiskEncryptionSettings) AssignPropertiesFromDiskEncryptionSettings(source *v1alpha1api20201201storage.DiskEncryptionSettings) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference
		err := diskEncryptionKey.AssignPropertiesFromKeyVaultSecretReference(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionKey from DiskEncryptionKey, calling AssignPropertiesFromKeyVaultSecretReference()")
		}
		diskEncryptionSettings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		diskEncryptionSettings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diskEncryptionSettings.Enabled = &enabled
	} else {
		diskEncryptionSettings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference
		err := keyEncryptionKey.AssignPropertiesFromKeyVaultKeyReference(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating KeyEncryptionKey from KeyEncryptionKey, calling AssignPropertiesFromKeyVaultKeyReference()")
		}
		diskEncryptionSettings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		diskEncryptionSettings.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSettings populates the provided destination DiskEncryptionSettings from our DiskEncryptionSettings
func (diskEncryptionSettings *DiskEncryptionSettings) AssignPropertiesToDiskEncryptionSettings(destination *v1alpha1api20201201storage.DiskEncryptionSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionKey
	if diskEncryptionSettings.DiskEncryptionKey != nil {
		var diskEncryptionKey v1alpha1api20201201storage.KeyVaultSecretReference
		err := (*diskEncryptionSettings.DiskEncryptionKey).AssignPropertiesToKeyVaultSecretReference(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionKey from DiskEncryptionKey, calling AssignPropertiesToKeyVaultSecretReference()")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if diskEncryptionSettings.Enabled != nil {
		enabled := *diskEncryptionSettings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if diskEncryptionSettings.KeyEncryptionKey != nil {
		var keyEncryptionKey v1alpha1api20201201storage.KeyVaultKeyReference
		err := (*diskEncryptionSettings.KeyEncryptionKey).AssignPropertiesToKeyVaultKeyReference(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating KeyEncryptionKey from KeyEncryptionKey, calling AssignPropertiesToKeyVaultKeyReference()")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DiskEncryptionSettings_Status struct {
	//DiskEncryptionKey: Specifies the location of the disk encryption key, which is a
	//Key Vault Secret.
	DiskEncryptionKey *KeyVaultSecretReference_Status `json:"diskEncryptionKey,omitempty"`

	//Enabled: Specifies whether disk encryption should be enabled on the virtual
	//machine.
	Enabled *bool `json:"enabled,omitempty"`

	//KeyEncryptionKey: Specifies the location of the key encryption key in Key Vault.
	KeyEncryptionKey *KeyVaultKeyReference_Status `json:"keyEncryptionKey,omitempty"`
}

var _ genruntime.FromARMConverter = &DiskEncryptionSettings_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diskEncryptionSettingsStatus *DiskEncryptionSettings_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskEncryptionSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diskEncryptionSettingsStatus *DiskEncryptionSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiskEncryptionSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskEncryptionSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionKey’:
	if typedInput.DiskEncryptionKey != nil {
		var diskEncryptionKey1 KeyVaultSecretReference_Status
		err := diskEncryptionKey1.PopulateFromARM(owner, *typedInput.DiskEncryptionKey)
		if err != nil {
			return err
		}
		diskEncryptionKey := diskEncryptionKey1
		diskEncryptionSettingsStatus.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		diskEncryptionSettingsStatus.Enabled = &enabled
	}

	// Set property ‘KeyEncryptionKey’:
	if typedInput.KeyEncryptionKey != nil {
		var keyEncryptionKey1 KeyVaultKeyReference_Status
		err := keyEncryptionKey1.PopulateFromARM(owner, *typedInput.KeyEncryptionKey)
		if err != nil {
			return err
		}
		keyEncryptionKey := keyEncryptionKey1
		diskEncryptionSettingsStatus.KeyEncryptionKey = &keyEncryptionKey
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskEncryptionSettingsStatus populates our DiskEncryptionSettings_Status from the provided source DiskEncryptionSettings_Status
func (diskEncryptionSettingsStatus *DiskEncryptionSettings_Status) AssignPropertiesFromDiskEncryptionSettingsStatus(source *v1alpha1api20201201storage.DiskEncryptionSettings_Status) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference_Status
		err := diskEncryptionKey.AssignPropertiesFromKeyVaultSecretReferenceStatus(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionKey from DiskEncryptionKey, calling AssignPropertiesFromKeyVaultSecretReferenceStatus()")
		}
		diskEncryptionSettingsStatus.DiskEncryptionKey = &diskEncryptionKey
	} else {
		diskEncryptionSettingsStatus.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diskEncryptionSettingsStatus.Enabled = &enabled
	} else {
		diskEncryptionSettingsStatus.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference_Status
		err := keyEncryptionKey.AssignPropertiesFromKeyVaultKeyReferenceStatus(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating KeyEncryptionKey from KeyEncryptionKey, calling AssignPropertiesFromKeyVaultKeyReferenceStatus()")
		}
		diskEncryptionSettingsStatus.KeyEncryptionKey = &keyEncryptionKey
	} else {
		diskEncryptionSettingsStatus.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSettingsStatus populates the provided destination DiskEncryptionSettings_Status from our DiskEncryptionSettings_Status
func (diskEncryptionSettingsStatus *DiskEncryptionSettings_Status) AssignPropertiesToDiskEncryptionSettingsStatus(destination *v1alpha1api20201201storage.DiskEncryptionSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionKey
	if diskEncryptionSettingsStatus.DiskEncryptionKey != nil {
		var diskEncryptionKey v1alpha1api20201201storage.KeyVaultSecretReference_Status
		err := (*diskEncryptionSettingsStatus.DiskEncryptionKey).AssignPropertiesToKeyVaultSecretReferenceStatus(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionKey from DiskEncryptionKey, calling AssignPropertiesToKeyVaultSecretReferenceStatus()")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if diskEncryptionSettingsStatus.Enabled != nil {
		enabled := *diskEncryptionSettingsStatus.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if diskEncryptionSettingsStatus.KeyEncryptionKey != nil {
		var keyEncryptionKey v1alpha1api20201201storage.KeyVaultKeyReference_Status
		err := (*diskEncryptionSettingsStatus.KeyEncryptionKey).AssignPropertiesToKeyVaultKeyReferenceStatus(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating KeyEncryptionKey from KeyEncryptionKey, calling AssignPropertiesToKeyVaultKeyReferenceStatus()")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InstanceViewStatusStatusLevel string

const (
	InstanceViewStatusStatusLevelError   = InstanceViewStatusStatusLevel("Error")
	InstanceViewStatusStatusLevelInfo    = InstanceViewStatusStatusLevel("Info")
	InstanceViewStatusStatusLevelWarning = InstanceViewStatusStatusLevel("Warning")
)

type LastPatchInstallationSummary_Status struct {
	//Error: The errors that were encountered during execution of the operation. The
	//details array contains the list of them.
	Error *ApiError_Status `json:"error,omitempty"`

	//ExcludedPatchCount: The number of all available patches but excluded explicitly
	//by a customer-specified exclusion list match.
	ExcludedPatchCount *int `json:"excludedPatchCount,omitempty"`

	//FailedPatchCount: The count of patches that failed installation.
	FailedPatchCount *int `json:"failedPatchCount,omitempty"`

	//InstallationActivityId: The activity ID of the operation that produced this
	//result. It is used to correlate across CRP and extension logs.
	InstallationActivityId *string `json:"installationActivityId,omitempty"`

	//InstalledPatchCount: The count of patches that successfully installed.
	InstalledPatchCount *int `json:"installedPatchCount,omitempty"`

	//LastModifiedTime: The UTC timestamp when the operation began.
	LastModifiedTime *string `json:"lastModifiedTime,omitempty"`

	//MaintenanceWindowExceeded: Describes whether the operation ran out of time
	//before it completed all its intended actions
	MaintenanceWindowExceeded *bool `json:"maintenanceWindowExceeded,omitempty"`

	//NotSelectedPatchCount: The number of all available patches but not going to be
	//installed because it didn't match a classification or inclusion list entry.
	NotSelectedPatchCount *int `json:"notSelectedPatchCount,omitempty"`

	//PendingPatchCount: The number of all available patches expected to be installed
	//over the course of the patch installation operation.
	PendingPatchCount *int `json:"pendingPatchCount,omitempty"`

	//StartTime: The UTC timestamp when the operation began.
	StartTime *string `json:"startTime,omitempty"`

	//Status: The overall success or failure status of the operation. It remains
	//"InProgress" until the operation completes. At that point it will become
	//"Unknown", "Failed", "Succeeded", or "CompletedWithWarnings."
	Status *LastPatchInstallationSummaryStatusStatus `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &LastPatchInstallationSummary_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (lastPatchInstallationSummaryStatus *LastPatchInstallationSummary_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LastPatchInstallationSummary_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (lastPatchInstallationSummaryStatus *LastPatchInstallationSummary_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LastPatchInstallationSummary_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LastPatchInstallationSummary_StatusARM, got %T", armInput)
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error1 ApiError_Status
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		lastPatchInstallationSummaryStatus.Error = &error
	}

	// Set property ‘ExcludedPatchCount’:
	if typedInput.ExcludedPatchCount != nil {
		excludedPatchCount := *typedInput.ExcludedPatchCount
		lastPatchInstallationSummaryStatus.ExcludedPatchCount = &excludedPatchCount
	}

	// Set property ‘FailedPatchCount’:
	if typedInput.FailedPatchCount != nil {
		failedPatchCount := *typedInput.FailedPatchCount
		lastPatchInstallationSummaryStatus.FailedPatchCount = &failedPatchCount
	}

	// Set property ‘InstallationActivityId’:
	if typedInput.InstallationActivityId != nil {
		installationActivityId := *typedInput.InstallationActivityId
		lastPatchInstallationSummaryStatus.InstallationActivityId = &installationActivityId
	}

	// Set property ‘InstalledPatchCount’:
	if typedInput.InstalledPatchCount != nil {
		installedPatchCount := *typedInput.InstalledPatchCount
		lastPatchInstallationSummaryStatus.InstalledPatchCount = &installedPatchCount
	}

	// Set property ‘LastModifiedTime’:
	if typedInput.LastModifiedTime != nil {
		lastModifiedTime := *typedInput.LastModifiedTime
		lastPatchInstallationSummaryStatus.LastModifiedTime = &lastModifiedTime
	}

	// Set property ‘MaintenanceWindowExceeded’:
	if typedInput.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *typedInput.MaintenanceWindowExceeded
		lastPatchInstallationSummaryStatus.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	}

	// Set property ‘NotSelectedPatchCount’:
	if typedInput.NotSelectedPatchCount != nil {
		notSelectedPatchCount := *typedInput.NotSelectedPatchCount
		lastPatchInstallationSummaryStatus.NotSelectedPatchCount = &notSelectedPatchCount
	}

	// Set property ‘PendingPatchCount’:
	if typedInput.PendingPatchCount != nil {
		pendingPatchCount := *typedInput.PendingPatchCount
		lastPatchInstallationSummaryStatus.PendingPatchCount = &pendingPatchCount
	}

	// Set property ‘StartTime’:
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		lastPatchInstallationSummaryStatus.StartTime = &startTime
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		lastPatchInstallationSummaryStatus.Status = &status
	}

	// No error
	return nil
}

// AssignPropertiesFromLastPatchInstallationSummaryStatus populates our LastPatchInstallationSummary_Status from the provided source LastPatchInstallationSummary_Status
func (lastPatchInstallationSummaryStatus *LastPatchInstallationSummary_Status) AssignPropertiesFromLastPatchInstallationSummaryStatus(source *v1alpha1api20201201storage.LastPatchInstallationSummary_Status) error {

	// Error
	if source.Error != nil {
		var error ApiError_Status
		err := error.AssignPropertiesFromApiErrorStatus(source.Error)
		if err != nil {
			return errors.Wrap(err, "populating Error from Error, calling AssignPropertiesFromApiErrorStatus()")
		}
		lastPatchInstallationSummaryStatus.Error = &error
	} else {
		lastPatchInstallationSummaryStatus.Error = nil
	}

	// ExcludedPatchCount
	lastPatchInstallationSummaryStatus.ExcludedPatchCount = genruntime.ClonePointerToInt(source.ExcludedPatchCount)

	// FailedPatchCount
	lastPatchInstallationSummaryStatus.FailedPatchCount = genruntime.ClonePointerToInt(source.FailedPatchCount)

	// InstallationActivityId
	lastPatchInstallationSummaryStatus.InstallationActivityId = genruntime.ClonePointerToString(source.InstallationActivityId)

	// InstalledPatchCount
	lastPatchInstallationSummaryStatus.InstalledPatchCount = genruntime.ClonePointerToInt(source.InstalledPatchCount)

	// LastModifiedTime
	lastPatchInstallationSummaryStatus.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// MaintenanceWindowExceeded
	if source.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *source.MaintenanceWindowExceeded
		lastPatchInstallationSummaryStatus.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		lastPatchInstallationSummaryStatus.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	lastPatchInstallationSummaryStatus.NotSelectedPatchCount = genruntime.ClonePointerToInt(source.NotSelectedPatchCount)

	// PendingPatchCount
	lastPatchInstallationSummaryStatus.PendingPatchCount = genruntime.ClonePointerToInt(source.PendingPatchCount)

	// StartTime
	lastPatchInstallationSummaryStatus.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	if source.Status != nil {
		status := LastPatchInstallationSummaryStatusStatus(*source.Status)
		lastPatchInstallationSummaryStatus.Status = &status
	} else {
		lastPatchInstallationSummaryStatus.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLastPatchInstallationSummaryStatus populates the provided destination LastPatchInstallationSummary_Status from our LastPatchInstallationSummary_Status
func (lastPatchInstallationSummaryStatus *LastPatchInstallationSummary_Status) AssignPropertiesToLastPatchInstallationSummaryStatus(destination *v1alpha1api20201201storage.LastPatchInstallationSummary_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if lastPatchInstallationSummaryStatus.Error != nil {
		var error v1alpha1api20201201storage.ApiError_Status
		err := (*lastPatchInstallationSummaryStatus.Error).AssignPropertiesToApiErrorStatus(&error)
		if err != nil {
			return errors.Wrap(err, "populating Error from Error, calling AssignPropertiesToApiErrorStatus()")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// ExcludedPatchCount
	destination.ExcludedPatchCount = genruntime.ClonePointerToInt(lastPatchInstallationSummaryStatus.ExcludedPatchCount)

	// FailedPatchCount
	destination.FailedPatchCount = genruntime.ClonePointerToInt(lastPatchInstallationSummaryStatus.FailedPatchCount)

	// InstallationActivityId
	destination.InstallationActivityId = genruntime.ClonePointerToString(lastPatchInstallationSummaryStatus.InstallationActivityId)

	// InstalledPatchCount
	destination.InstalledPatchCount = genruntime.ClonePointerToInt(lastPatchInstallationSummaryStatus.InstalledPatchCount)

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(lastPatchInstallationSummaryStatus.LastModifiedTime)

	// MaintenanceWindowExceeded
	if lastPatchInstallationSummaryStatus.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *lastPatchInstallationSummaryStatus.MaintenanceWindowExceeded
		destination.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		destination.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	destination.NotSelectedPatchCount = genruntime.ClonePointerToInt(lastPatchInstallationSummaryStatus.NotSelectedPatchCount)

	// PendingPatchCount
	destination.PendingPatchCount = genruntime.ClonePointerToInt(lastPatchInstallationSummaryStatus.PendingPatchCount)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(lastPatchInstallationSummaryStatus.StartTime)

	// Status
	if lastPatchInstallationSummaryStatus.Status != nil {
		status := string(*lastPatchInstallationSummaryStatus.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/LinuxPatchSettings
type LinuxPatchSettings struct {
	//PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine.
	//Possible values are:
	//ImageDefault - The virtual machine's default patching configuration is used.
	//AutomaticByPlatform - The virtual machine will be automatically updated by the
	//platform. The property provisionVMAgent must be true.
	PatchMode *LinuxPatchSettingsPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxPatchSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (linuxPatchSettings *LinuxPatchSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if linuxPatchSettings == nil {
		return nil, nil
	}
	var result LinuxPatchSettingsARM

	// Set property ‘PatchMode’:
	if linuxPatchSettings.PatchMode != nil {
		patchMode := *linuxPatchSettings.PatchMode
		result.PatchMode = &patchMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (linuxPatchSettings *LinuxPatchSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxPatchSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (linuxPatchSettings *LinuxPatchSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxPatchSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxPatchSettingsARM, got %T", armInput)
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		linuxPatchSettings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxPatchSettings populates our LinuxPatchSettings from the provided source LinuxPatchSettings
func (linuxPatchSettings *LinuxPatchSettings) AssignPropertiesFromLinuxPatchSettings(source *v1alpha1api20201201storage.LinuxPatchSettings) error {

	// PatchMode
	if source.PatchMode != nil {
		patchMode := LinuxPatchSettingsPatchMode(*source.PatchMode)
		linuxPatchSettings.PatchMode = &patchMode
	} else {
		linuxPatchSettings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxPatchSettings populates the provided destination LinuxPatchSettings from our LinuxPatchSettings
func (linuxPatchSettings *LinuxPatchSettings) AssignPropertiesToLinuxPatchSettings(destination *v1alpha1api20201201storage.LinuxPatchSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PatchMode
	if linuxPatchSettings.PatchMode != nil {
		patchMode := string(*linuxPatchSettings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LinuxPatchSettings_Status struct {
	//PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine.
	//Possible values are:
	//ImageDefault - The virtual machine's default patching configuration is used.
	//AutomaticByPlatform - The virtual machine will be automatically updated by the
	//platform. The property provisionVMAgent must be true
	PatchMode *LinuxPatchSettingsStatusPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxPatchSettings_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (linuxPatchSettingsStatus *LinuxPatchSettings_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxPatchSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (linuxPatchSettingsStatus *LinuxPatchSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxPatchSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxPatchSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		linuxPatchSettingsStatus.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxPatchSettingsStatus populates our LinuxPatchSettings_Status from the provided source LinuxPatchSettings_Status
func (linuxPatchSettingsStatus *LinuxPatchSettings_Status) AssignPropertiesFromLinuxPatchSettingsStatus(source *v1alpha1api20201201storage.LinuxPatchSettings_Status) error {

	// PatchMode
	if source.PatchMode != nil {
		patchMode := LinuxPatchSettingsStatusPatchMode(*source.PatchMode)
		linuxPatchSettingsStatus.PatchMode = &patchMode
	} else {
		linuxPatchSettingsStatus.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxPatchSettingsStatus populates the provided destination LinuxPatchSettings_Status from our LinuxPatchSettings_Status
func (linuxPatchSettingsStatus *LinuxPatchSettings_Status) AssignPropertiesToLinuxPatchSettingsStatus(destination *v1alpha1api20201201storage.LinuxPatchSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PatchMode
	if linuxPatchSettingsStatus.PatchMode != nil {
		patchMode := string(*linuxPatchSettingsStatus.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MaintenanceRedeployStatusStatusLastOperationResultCode string

const (
	MaintenanceRedeployStatusStatusLastOperationResultCodeMaintenanceAborted   = MaintenanceRedeployStatusStatusLastOperationResultCode("MaintenanceAborted")
	MaintenanceRedeployStatusStatusLastOperationResultCodeMaintenanceCompleted = MaintenanceRedeployStatusStatusLastOperationResultCode("MaintenanceCompleted")
	MaintenanceRedeployStatusStatusLastOperationResultCodeNone                 = MaintenanceRedeployStatusStatusLastOperationResultCode("None")
	MaintenanceRedeployStatusStatusLastOperationResultCodeRetryLater           = MaintenanceRedeployStatusStatusLastOperationResultCode("RetryLater")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ManagedDiskParameters
type ManagedDiskParameters struct {
	//DiskEncryptionSet: Describes the parameter of customer managed disk encryption
	//set resource id that can be specified for disk.
	//NOTE: The disk encryption set resource id can only be specified for managed
	//disk. Please refer https://aka.ms/mdssewithcmkoverview for more details.
	DiskEncryptionSet *DiskEncryptionSetParameters `json:"diskEncryptionSet,omitempty"`

	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//StorageAccountType: Specifies the storage account type for the managed disk.
	//Managed OS disk storage account type can only be set when you create the scale
	//set. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with
	//OS Disk.
	StorageAccountType *ManagedDiskParametersStorageAccountType `json:"storageAccountType,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedDiskParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedDiskParameters *ManagedDiskParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedDiskParameters == nil {
		return nil, nil
	}
	var result ManagedDiskParametersARM

	// Set property ‘DiskEncryptionSet’:
	if managedDiskParameters.DiskEncryptionSet != nil {
		diskEncryptionSetARM, err := (*managedDiskParameters.DiskEncryptionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionSet := diskEncryptionSetARM.(DiskEncryptionSetParametersARM)
		result.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘Id’:
	if managedDiskParameters.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*managedDiskParameters.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘StorageAccountType’:
	if managedDiskParameters.StorageAccountType != nil {
		storageAccountType := *managedDiskParameters.StorageAccountType
		result.StorageAccountType = &storageAccountType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedDiskParameters *ManagedDiskParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedDiskParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedDiskParameters *ManagedDiskParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedDiskParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedDiskParametersARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 DiskEncryptionSetParameters
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		managedDiskParameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// no assignment for property ‘Reference’

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		managedDiskParameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedDiskParameters populates our ManagedDiskParameters from the provided source ManagedDiskParameters
func (managedDiskParameters *ManagedDiskParameters) AssignPropertiesFromManagedDiskParameters(source *v1alpha1api20201201storage.ManagedDiskParameters) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet DiskEncryptionSetParameters
		err := diskEncryptionSet.AssignPropertiesFromDiskEncryptionSetParameters(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionSet from DiskEncryptionSet, calling AssignPropertiesFromDiskEncryptionSetParameters()")
		}
		managedDiskParameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		managedDiskParameters.DiskEncryptionSet = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		managedDiskParameters.Reference = &reference
	} else {
		managedDiskParameters.Reference = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := ManagedDiskParametersStorageAccountType(*source.StorageAccountType)
		managedDiskParameters.StorageAccountType = &storageAccountType
	} else {
		managedDiskParameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedDiskParameters populates the provided destination ManagedDiskParameters from our ManagedDiskParameters
func (managedDiskParameters *ManagedDiskParameters) AssignPropertiesToManagedDiskParameters(destination *v1alpha1api20201201storage.ManagedDiskParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if managedDiskParameters.DiskEncryptionSet != nil {
		var diskEncryptionSet v1alpha1api20201201storage.DiskEncryptionSetParameters
		err := (*managedDiskParameters.DiskEncryptionSet).AssignPropertiesToDiskEncryptionSetParameters(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionSet from DiskEncryptionSet, calling AssignPropertiesToDiskEncryptionSetParameters()")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Reference
	if managedDiskParameters.Reference != nil {
		reference := managedDiskParameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// StorageAccountType
	if managedDiskParameters.StorageAccountType != nil {
		storageAccountType := string(*managedDiskParameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedDiskParameters_Status struct {
	//DiskEncryptionSet: Specifies the customer managed disk encryption set resource
	//id for the managed disk.
	DiskEncryptionSet *SubResource_Status `json:"diskEncryptionSet,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//StorageAccountType: Specifies the storage account type for the managed disk.
	//Managed OS disk storage account type can only be set when you create the scale
	//set. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with
	//OS Disk.
	StorageAccountType *StorageAccountType_Status `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedDiskParameters_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedDiskParametersStatus *ManagedDiskParameters_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedDiskParameters_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedDiskParametersStatus *ManagedDiskParameters_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedDiskParameters_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedDiskParameters_StatusARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_Status
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		managedDiskParametersStatus.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		managedDiskParametersStatus.Id = &id
	}

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		managedDiskParametersStatus.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedDiskParametersStatus populates our ManagedDiskParameters_Status from the provided source ManagedDiskParameters_Status
func (managedDiskParametersStatus *ManagedDiskParameters_Status) AssignPropertiesFromManagedDiskParametersStatus(source *v1alpha1api20201201storage.ManagedDiskParameters_Status) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_Status
		err := diskEncryptionSet.AssignPropertiesFromSubResourceStatus(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionSet from DiskEncryptionSet, calling AssignPropertiesFromSubResourceStatus()")
		}
		managedDiskParametersStatus.DiskEncryptionSet = &diskEncryptionSet
	} else {
		managedDiskParametersStatus.DiskEncryptionSet = nil
	}

	// Id
	managedDiskParametersStatus.Id = genruntime.ClonePointerToString(source.Id)

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := StorageAccountType_Status(*source.StorageAccountType)
		managedDiskParametersStatus.StorageAccountType = &storageAccountType
	} else {
		managedDiskParametersStatus.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedDiskParametersStatus populates the provided destination ManagedDiskParameters_Status from our ManagedDiskParameters_Status
func (managedDiskParametersStatus *ManagedDiskParameters_Status) AssignPropertiesToManagedDiskParametersStatus(destination *v1alpha1api20201201storage.ManagedDiskParameters_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if managedDiskParametersStatus.DiskEncryptionSet != nil {
		var diskEncryptionSet v1alpha1api20201201storage.SubResource_Status
		err := (*managedDiskParametersStatus.DiskEncryptionSet).AssignPropertiesToSubResourceStatus(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionSet from DiskEncryptionSet, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(managedDiskParametersStatus.Id)

	// StorageAccountType
	if managedDiskParametersStatus.StorageAccountType != nil {
		storageAccountType := string(*managedDiskParametersStatus.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type OSDiskCaching string

const (
	OSDiskCachingNone      = OSDiskCaching("None")
	OSDiskCachingReadOnly  = OSDiskCaching("ReadOnly")
	OSDiskCachingReadWrite = OSDiskCaching("ReadWrite")
)

// +kubebuilder:validation:Enum={"Attach","Empty","FromImage"}
type OSDiskCreateOption string

const (
	OSDiskCreateOptionAttach    = OSDiskCreateOption("Attach")
	OSDiskCreateOptionEmpty     = OSDiskCreateOption("Empty")
	OSDiskCreateOptionFromImage = OSDiskCreateOption("FromImage")
)

// +kubebuilder:validation:Enum={"Linux","Windows"}
type OSDiskOsType string

const (
	OSDiskOsTypeLinux   = OSDiskOsType("Linux")
	OSDiskOsTypeWindows = OSDiskOsType("Windows")
)

type OSDiskStatusOsType string

const (
	OSDiskStatusOsTypeLinux   = OSDiskStatusOsType("Linux")
	OSDiskStatusOsTypeWindows = OSDiskStatusOsType("Windows")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/PatchSettings
type PatchSettings struct {
	//EnableHotpatching: Enables customers to patch their Azure VMs without requiring
	//a reboot. For enableHotpatching, the 'provisionVMAgent' must be set to true and
	//'patchMode' must be set to 'AutomaticByPlatform'.
	EnableHotpatching *bool `json:"enableHotpatching,omitempty"`

	//PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine.
	//Possible values are:
	//Manual - You  control the application of patches to a virtual machine. You do
	//this by applying patches manually inside the VM. In this mode, automatic updates
	//are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
	//false
	//AutomaticByOS - The virtual machine will automatically be updated by the OS. The
	//property WindowsConfiguration.enableAutomaticUpdates must be true.
	//AutomaticByPlatform - the virtual machine will automatically updated by the
	//platform. The properties provisionVMAgent and
	//WindowsConfiguration.enableAutomaticUpdates must be true.
	PatchMode *PatchSettingsPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.ARMTransformer = &PatchSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (patchSettings *PatchSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if patchSettings == nil {
		return nil, nil
	}
	var result PatchSettingsARM

	// Set property ‘EnableHotpatching’:
	if patchSettings.EnableHotpatching != nil {
		enableHotpatching := *patchSettings.EnableHotpatching
		result.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if patchSettings.PatchMode != nil {
		patchMode := *patchSettings.PatchMode
		result.PatchMode = &patchMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (patchSettings *PatchSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PatchSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (patchSettings *PatchSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PatchSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PatchSettingsARM, got %T", armInput)
	}

	// Set property ‘EnableHotpatching’:
	if typedInput.EnableHotpatching != nil {
		enableHotpatching := *typedInput.EnableHotpatching
		patchSettings.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		patchSettings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromPatchSettings populates our PatchSettings from the provided source PatchSettings
func (patchSettings *PatchSettings) AssignPropertiesFromPatchSettings(source *v1alpha1api20201201storage.PatchSettings) error {

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		patchSettings.EnableHotpatching = &enableHotpatching
	} else {
		patchSettings.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := PatchSettingsPatchMode(*source.PatchMode)
		patchSettings.PatchMode = &patchMode
	} else {
		patchSettings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPatchSettings populates the provided destination PatchSettings from our PatchSettings
func (patchSettings *PatchSettings) AssignPropertiesToPatchSettings(destination *v1alpha1api20201201storage.PatchSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableHotpatching
	if patchSettings.EnableHotpatching != nil {
		enableHotpatching := *patchSettings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	if patchSettings.PatchMode != nil {
		patchMode := string(*patchSettings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PatchSettings_Status struct {
	//EnableHotpatching: Enables customers to patch their Azure VMs without requiring
	//a reboot. For enableHotpatching, the 'provisionVMAgent' must be set to true and
	//'patchMode' must be set to 'AutomaticByPlatform'.
	EnableHotpatching *bool `json:"enableHotpatching,omitempty"`

	//PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine.
	//Possible values are:
	//Manual - You  control the application of patches to a virtual machine. You do
	//this by applying patches manually inside the VM. In this mode, automatic updates
	//are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
	//false
	//AutomaticByOS - The virtual machine will automatically be updated by the OS. The
	//property WindowsConfiguration.enableAutomaticUpdates must be true.
	//AutomaticByPlatform - the virtual machine will automatically updated by the
	//platform. The properties provisionVMAgent and
	//WindowsConfiguration.enableAutomaticUpdates must be true
	PatchMode *PatchSettingsStatusPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.FromARMConverter = &PatchSettings_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (patchSettingsStatus *PatchSettings_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PatchSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (patchSettingsStatus *PatchSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PatchSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PatchSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘EnableHotpatching’:
	if typedInput.EnableHotpatching != nil {
		enableHotpatching := *typedInput.EnableHotpatching
		patchSettingsStatus.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		patchSettingsStatus.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromPatchSettingsStatus populates our PatchSettings_Status from the provided source PatchSettings_Status
func (patchSettingsStatus *PatchSettings_Status) AssignPropertiesFromPatchSettingsStatus(source *v1alpha1api20201201storage.PatchSettings_Status) error {

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		patchSettingsStatus.EnableHotpatching = &enableHotpatching
	} else {
		patchSettingsStatus.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := PatchSettingsStatusPatchMode(*source.PatchMode)
		patchSettingsStatus.PatchMode = &patchMode
	} else {
		patchSettingsStatus.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPatchSettingsStatus populates the provided destination PatchSettings_Status from our PatchSettings_Status
func (patchSettingsStatus *PatchSettings_Status) AssignPropertiesToPatchSettingsStatus(destination *v1alpha1api20201201storage.PatchSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableHotpatching
	if patchSettingsStatus.EnableHotpatching != nil {
		enableHotpatching := *patchSettingsStatus.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	if patchSettingsStatus.PatchMode != nil {
		patchMode := string(*patchSettingsStatus.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SshConfiguration
type SshConfiguration struct {
	//PublicKeys: The list of SSH public keys used to authenticate with linux based
	//VMs.
	PublicKeys []SshPublicKey `json:"publicKeys,omitempty"`
}

var _ genruntime.ARMTransformer = &SshConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sshConfiguration *SshConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sshConfiguration == nil {
		return nil, nil
	}
	var result SshConfigurationARM

	// Set property ‘PublicKeys’:
	for _, item := range sshConfiguration.PublicKeys {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicKeys = append(result.PublicKeys, itemARM.(SshPublicKeyARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sshConfiguration *SshConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sshConfiguration *SshConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshConfigurationARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 SshPublicKey
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sshConfiguration.PublicKeys = append(sshConfiguration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromSshConfiguration populates our SshConfiguration from the provided source SshConfiguration
func (sshConfiguration *SshConfiguration) AssignPropertiesFromSshConfiguration(source *v1alpha1api20201201storage.SshConfiguration) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey
			err := publicKey.AssignPropertiesFromSshPublicKey(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesFromSshPublicKey()")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		sshConfiguration.PublicKeys = publicKeyList
	} else {
		sshConfiguration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshConfiguration populates the provided destination SshConfiguration from our SshConfiguration
func (sshConfiguration *SshConfiguration) AssignPropertiesToSshConfiguration(destination *v1alpha1api20201201storage.SshConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if sshConfiguration.PublicKeys != nil {
		publicKeyList := make([]v1alpha1api20201201storage.SshPublicKey, len(sshConfiguration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range sshConfiguration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v1alpha1api20201201storage.SshPublicKey
			err := publicKeyItem.AssignPropertiesToSshPublicKey(&publicKey)
			if err != nil {
				return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesToSshPublicKey()")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SshConfiguration_Status struct {
	//PublicKeys: The list of SSH public keys used to authenticate with linux based
	//VMs.
	PublicKeys []SshPublicKey_Status `json:"publicKeys,omitempty"`
}

var _ genruntime.FromARMConverter = &SshConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sshConfigurationStatus *SshConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sshConfigurationStatus *SshConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 SshPublicKey_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sshConfigurationStatus.PublicKeys = append(sshConfigurationStatus.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromSshConfigurationStatus populates our SshConfiguration_Status from the provided source SshConfiguration_Status
func (sshConfigurationStatus *SshConfiguration_Status) AssignPropertiesFromSshConfigurationStatus(source *v1alpha1api20201201storage.SshConfiguration_Status) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey_Status, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey_Status
			err := publicKey.AssignPropertiesFromSshPublicKeyStatus(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesFromSshPublicKeyStatus()")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		sshConfigurationStatus.PublicKeys = publicKeyList
	} else {
		sshConfigurationStatus.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshConfigurationStatus populates the provided destination SshConfiguration_Status from our SshConfiguration_Status
func (sshConfigurationStatus *SshConfiguration_Status) AssignPropertiesToSshConfigurationStatus(destination *v1alpha1api20201201storage.SshConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if sshConfigurationStatus.PublicKeys != nil {
		publicKeyList := make([]v1alpha1api20201201storage.SshPublicKey_Status, len(sshConfigurationStatus.PublicKeys))
		for publicKeyIndex, publicKeyItem := range sshConfigurationStatus.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v1alpha1api20201201storage.SshPublicKey_Status
			err := publicKeyItem.AssignPropertiesToSshPublicKeyStatus(&publicKey)
			if err != nil {
				return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesToSshPublicKeyStatus()")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VaultCertificate
type VaultCertificate struct {
	//CertificateStore: For Windows VMs, specifies the certificate store on the
	//Virtual Machine to which the certificate should be added. The specified
	//certificate store is implicitly in the LocalMachine account.
	//For Linux VMs, the certificate file is placed under the /var/lib/waagent
	//directory, with the file name &lt;UppercaseThumbprint&gt;.crt for the X509
	//certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both of
	//these files are .pem formatted.
	CertificateStore *string `json:"certificateStore,omitempty"`

	//CertificateUrl: This is the URL of a certificate that has been uploaded to Key
	//Vault as a secret. For adding a secret to the Key Vault, see [Add a key or
	//secret to the key
	//vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	//In this case, your certificate needs to be It is the Base64 encoding of the
	//following JSON Object which is encoded in UTF-8:
	//{
	//"data":"<Base64-encoded-certificate>",
	//"dataType":"pfx",
	//"password":"<pfx-file-password>"
	//}
	CertificateUrl *string `json:"certificateUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultCertificate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vaultCertificate *VaultCertificate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vaultCertificate == nil {
		return nil, nil
	}
	var result VaultCertificateARM

	// Set property ‘CertificateStore’:
	if vaultCertificate.CertificateStore != nil {
		certificateStore := *vaultCertificate.CertificateStore
		result.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if vaultCertificate.CertificateUrl != nil {
		certificateUrl := *vaultCertificate.CertificateUrl
		result.CertificateUrl = &certificateUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultCertificate *VaultCertificate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultCertificateARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultCertificate *VaultCertificate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultCertificateARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultCertificateARM, got %T", armInput)
	}

	// Set property ‘CertificateStore’:
	if typedInput.CertificateStore != nil {
		certificateStore := *typedInput.CertificateStore
		vaultCertificate.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		vaultCertificate.CertificateUrl = &certificateUrl
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultCertificate populates our VaultCertificate from the provided source VaultCertificate
func (vaultCertificate *VaultCertificate) AssignPropertiesFromVaultCertificate(source *v1alpha1api20201201storage.VaultCertificate) error {

	// CertificateStore
	vaultCertificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	vaultCertificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// No error
	return nil
}

// AssignPropertiesToVaultCertificate populates the provided destination VaultCertificate from our VaultCertificate
func (vaultCertificate *VaultCertificate) AssignPropertiesToVaultCertificate(destination *v1alpha1api20201201storage.VaultCertificate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(vaultCertificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(vaultCertificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VaultCertificate_Status struct {
	//CertificateStore: For Windows VMs, specifies the certificate store on the
	//Virtual Machine to which the certificate should be added. The specified
	//certificate store is implicitly in the LocalMachine account.
	//For Linux VMs, the certificate file is placed under the /var/lib/waagent
	//directory, with the file name &lt;UppercaseThumbprint&gt;.crt for the X509
	//certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both of
	//these files are .pem formatted.
	CertificateStore *string `json:"certificateStore,omitempty"`

	//CertificateUrl: This is the URL of a certificate that has been uploaded to Key
	//Vault as a secret. For adding a secret to the Key Vault, see [Add a key or
	//secret to the key
	//vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	//In this case, your certificate needs to be It is the Base64 encoding of the
	//following JSON Object which is encoded in UTF-8:
	//{
	//"data":"<Base64-encoded-certificate>",
	//"dataType":"pfx",
	//"password":"<pfx-file-password>"
	//}
	CertificateUrl *string `json:"certificateUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &VaultCertificate_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultCertificateStatus *VaultCertificate_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultCertificate_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultCertificateStatus *VaultCertificate_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultCertificate_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultCertificate_StatusARM, got %T", armInput)
	}

	// Set property ‘CertificateStore’:
	if typedInput.CertificateStore != nil {
		certificateStore := *typedInput.CertificateStore
		vaultCertificateStatus.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		vaultCertificateStatus.CertificateUrl = &certificateUrl
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultCertificateStatus populates our VaultCertificate_Status from the provided source VaultCertificate_Status
func (vaultCertificateStatus *VaultCertificate_Status) AssignPropertiesFromVaultCertificateStatus(source *v1alpha1api20201201storage.VaultCertificate_Status) error {

	// CertificateStore
	vaultCertificateStatus.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	vaultCertificateStatus.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// No error
	return nil
}

// AssignPropertiesToVaultCertificateStatus populates the provided destination VaultCertificate_Status from our VaultCertificate_Status
func (vaultCertificateStatus *VaultCertificate_Status) AssignPropertiesToVaultCertificateStatus(destination *v1alpha1api20201201storage.VaultCertificate_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(vaultCertificateStatus.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(vaultCertificateStatus.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualHardDisk
type VirtualHardDisk struct {
	//Uri: Specifies the virtual hard disk's uri.
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualHardDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualHardDisk *VirtualHardDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualHardDisk == nil {
		return nil, nil
	}
	var result VirtualHardDiskARM

	// Set property ‘Uri’:
	if virtualHardDisk.Uri != nil {
		uri := *virtualHardDisk.Uri
		result.Uri = &uri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualHardDisk *VirtualHardDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualHardDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualHardDisk *VirtualHardDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualHardDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualHardDiskARM, got %T", armInput)
	}

	// Set property ‘Uri’:
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		virtualHardDisk.Uri = &uri
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualHardDisk populates our VirtualHardDisk from the provided source VirtualHardDisk
func (virtualHardDisk *VirtualHardDisk) AssignPropertiesFromVirtualHardDisk(source *v1alpha1api20201201storage.VirtualHardDisk) error {

	// Uri
	virtualHardDisk.Uri = genruntime.ClonePointerToString(source.Uri)

	// No error
	return nil
}

// AssignPropertiesToVirtualHardDisk populates the provided destination VirtualHardDisk from our VirtualHardDisk
func (virtualHardDisk *VirtualHardDisk) AssignPropertiesToVirtualHardDisk(destination *v1alpha1api20201201storage.VirtualHardDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Uri
	destination.Uri = genruntime.ClonePointerToString(virtualHardDisk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualHardDisk_Status struct {
	//Uri: Specifies the virtual hard disk's uri.
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualHardDisk_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualHardDiskStatus *VirtualHardDisk_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualHardDisk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualHardDiskStatus *VirtualHardDisk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualHardDisk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualHardDisk_StatusARM, got %T", armInput)
	}

	// Set property ‘Uri’:
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		virtualHardDiskStatus.Uri = &uri
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualHardDiskStatus populates our VirtualHardDisk_Status from the provided source VirtualHardDisk_Status
func (virtualHardDiskStatus *VirtualHardDisk_Status) AssignPropertiesFromVirtualHardDiskStatus(source *v1alpha1api20201201storage.VirtualHardDisk_Status) error {

	// Uri
	virtualHardDiskStatus.Uri = genruntime.ClonePointerToString(source.Uri)

	// No error
	return nil
}

// AssignPropertiesToVirtualHardDiskStatus populates the provided destination VirtualHardDisk_Status from our VirtualHardDisk_Status
func (virtualHardDiskStatus *VirtualHardDisk_Status) AssignPropertiesToVirtualHardDiskStatus(destination *v1alpha1api20201201storage.VirtualHardDisk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Uri
	destination.Uri = genruntime.ClonePointerToString(virtualHardDiskStatus.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineExtensionHandlerInstanceView_Status struct {
	//Status: The extension handler status.
	Status *InstanceViewStatus_Status `json:"status,omitempty"`

	//Type: Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`

	//TypeHandlerVersion: Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineExtensionHandlerInstanceView_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineExtensionHandlerInstanceViewStatus *VirtualMachineExtensionHandlerInstanceView_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineExtensionHandlerInstanceView_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineExtensionHandlerInstanceViewStatus *VirtualMachineExtensionHandlerInstanceView_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineExtensionHandlerInstanceView_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineExtensionHandlerInstanceView_StatusARM, got %T", armInput)
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		var status1 InstanceViewStatus_Status
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		virtualMachineExtensionHandlerInstanceViewStatus.Status = &status
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineExtensionHandlerInstanceViewStatus.Type = &typeVar
	}

	// Set property ‘TypeHandlerVersion’:
	if typedInput.TypeHandlerVersion != nil {
		typeHandlerVersion := *typedInput.TypeHandlerVersion
		virtualMachineExtensionHandlerInstanceViewStatus.TypeHandlerVersion = &typeHandlerVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewStatus populates our VirtualMachineExtensionHandlerInstanceView_Status from the provided source VirtualMachineExtensionHandlerInstanceView_Status
func (virtualMachineExtensionHandlerInstanceViewStatus *VirtualMachineExtensionHandlerInstanceView_Status) AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewStatus(source *v1alpha1api20201201storage.VirtualMachineExtensionHandlerInstanceView_Status) error {

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_Status
		err := status.AssignPropertiesFromInstanceViewStatusStatus(source.Status)
		if err != nil {
			return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromInstanceViewStatusStatus()")
		}
		virtualMachineExtensionHandlerInstanceViewStatus.Status = &status
	} else {
		virtualMachineExtensionHandlerInstanceViewStatus.Status = nil
	}

	// Type
	virtualMachineExtensionHandlerInstanceViewStatus.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	virtualMachineExtensionHandlerInstanceViewStatus.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewStatus populates the provided destination VirtualMachineExtensionHandlerInstanceView_Status from our VirtualMachineExtensionHandlerInstanceView_Status
func (virtualMachineExtensionHandlerInstanceViewStatus *VirtualMachineExtensionHandlerInstanceView_Status) AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewStatus(destination *v1alpha1api20201201storage.VirtualMachineExtensionHandlerInstanceView_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Status
	if virtualMachineExtensionHandlerInstanceViewStatus.Status != nil {
		var status v1alpha1api20201201storage.InstanceViewStatus_Status
		err := (*virtualMachineExtensionHandlerInstanceViewStatus.Status).AssignPropertiesToInstanceViewStatusStatus(&status)
		if err != nil {
			return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToInstanceViewStatusStatus()")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(virtualMachineExtensionHandlerInstanceViewStatus.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(virtualMachineExtensionHandlerInstanceViewStatus.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WinRMConfiguration
type WinRMConfiguration struct {
	//Listeners: The list of Windows Remote Management listeners
	Listeners []WinRMListener `json:"listeners,omitempty"`
}

var _ genruntime.ARMTransformer = &WinRMConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (winRMConfiguration *WinRMConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if winRMConfiguration == nil {
		return nil, nil
	}
	var result WinRMConfigurationARM

	// Set property ‘Listeners’:
	for _, item := range winRMConfiguration.Listeners {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Listeners = append(result.Listeners, itemARM.(WinRMListenerARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (winRMConfiguration *WinRMConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (winRMConfiguration *WinRMConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMConfigurationARM, got %T", armInput)
	}

	// Set property ‘Listeners’:
	for _, item := range typedInput.Listeners {
		var item1 WinRMListener
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		winRMConfiguration.Listeners = append(winRMConfiguration.Listeners, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMConfiguration populates our WinRMConfiguration from the provided source WinRMConfiguration
func (winRMConfiguration *WinRMConfiguration) AssignPropertiesFromWinRMConfiguration(source *v1alpha1api20201201storage.WinRMConfiguration) error {

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener
			err := listener.AssignPropertiesFromWinRMListener(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "populating Listeners from Listeners, calling AssignPropertiesFromWinRMListener()")
			}
			listenerList[listenerIndex] = listener
		}
		winRMConfiguration.Listeners = listenerList
	} else {
		winRMConfiguration.Listeners = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMConfiguration populates the provided destination WinRMConfiguration from our WinRMConfiguration
func (winRMConfiguration *WinRMConfiguration) AssignPropertiesToWinRMConfiguration(destination *v1alpha1api20201201storage.WinRMConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Listeners
	if winRMConfiguration.Listeners != nil {
		listenerList := make([]v1alpha1api20201201storage.WinRMListener, len(winRMConfiguration.Listeners))
		for listenerIndex, listenerItem := range winRMConfiguration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener v1alpha1api20201201storage.WinRMListener
			err := listenerItem.AssignPropertiesToWinRMListener(&listener)
			if err != nil {
				return errors.Wrap(err, "populating Listeners from Listeners, calling AssignPropertiesToWinRMListener()")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WinRMConfiguration_Status struct {
	//Listeners: The list of Windows Remote Management listeners
	Listeners []WinRMListener_Status `json:"listeners,omitempty"`
}

var _ genruntime.FromARMConverter = &WinRMConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (winRMConfigurationStatus *WinRMConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (winRMConfigurationStatus *WinRMConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘Listeners’:
	for _, item := range typedInput.Listeners {
		var item1 WinRMListener_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		winRMConfigurationStatus.Listeners = append(winRMConfigurationStatus.Listeners, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMConfigurationStatus populates our WinRMConfiguration_Status from the provided source WinRMConfiguration_Status
func (winRMConfigurationStatus *WinRMConfiguration_Status) AssignPropertiesFromWinRMConfigurationStatus(source *v1alpha1api20201201storage.WinRMConfiguration_Status) error {

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener_Status, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener_Status
			err := listener.AssignPropertiesFromWinRMListenerStatus(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "populating Listeners from Listeners, calling AssignPropertiesFromWinRMListenerStatus()")
			}
			listenerList[listenerIndex] = listener
		}
		winRMConfigurationStatus.Listeners = listenerList
	} else {
		winRMConfigurationStatus.Listeners = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMConfigurationStatus populates the provided destination WinRMConfiguration_Status from our WinRMConfiguration_Status
func (winRMConfigurationStatus *WinRMConfiguration_Status) AssignPropertiesToWinRMConfigurationStatus(destination *v1alpha1api20201201storage.WinRMConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Listeners
	if winRMConfigurationStatus.Listeners != nil {
		listenerList := make([]v1alpha1api20201201storage.WinRMListener_Status, len(winRMConfigurationStatus.Listeners))
		for listenerIndex, listenerItem := range winRMConfigurationStatus.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener v1alpha1api20201201storage.WinRMListener_Status
			err := listenerItem.AssignPropertiesToWinRMListenerStatus(&listener)
			if err != nil {
				return errors.Wrap(err, "populating Listeners from Listeners, calling AssignPropertiesToWinRMListenerStatus()")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft-Windows-Shell-Setup"}
type AdditionalUnattendContentComponentName string

const AdditionalUnattendContentComponentNameMicrosoftWindowsShellSetup = AdditionalUnattendContentComponentName("Microsoft-Windows-Shell-Setup")

// +kubebuilder:validation:Enum={"OobeSystem"}
type AdditionalUnattendContentPassName string

const AdditionalUnattendContentPassNameOobeSystem = AdditionalUnattendContentPassName("OobeSystem")

// +kubebuilder:validation:Enum={"AutoLogon","FirstLogonCommands"}
type AdditionalUnattendContentSettingName string

const (
	AdditionalUnattendContentSettingNameAutoLogon          = AdditionalUnattendContentSettingName("AutoLogon")
	AdditionalUnattendContentSettingNameFirstLogonCommands = AdditionalUnattendContentSettingName("FirstLogonCommands")
)

type AdditionalUnattendContentStatusComponentName string

const AdditionalUnattendContentStatusComponentNameMicrosoftWindowsShellSetup = AdditionalUnattendContentStatusComponentName("Microsoft-Windows-Shell-Setup")

type AdditionalUnattendContentStatusPassName string

const AdditionalUnattendContentStatusPassNameOobeSystem = AdditionalUnattendContentStatusPassName("OobeSystem")

type AdditionalUnattendContentStatusSettingName string

const (
	AdditionalUnattendContentStatusSettingNameAutoLogon          = AdditionalUnattendContentStatusSettingName("AutoLogon")
	AdditionalUnattendContentStatusSettingNameFirstLogonCommands = AdditionalUnattendContentStatusSettingName("FirstLogonCommands")
)

type ApiError_Status struct {
	//Code: The error code.
	Code *string `json:"code,omitempty"`

	//Details: The Api error details
	Details []ApiErrorBase_Status `json:"details,omitempty"`

	//Innererror: The Api inner error
	Innererror *InnerError_Status `json:"innererror,omitempty"`

	//Message: The error message.
	Message *string `json:"message,omitempty"`

	//Target: The target of the particular error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiError_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apiErrorStatus *ApiError_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiError_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apiErrorStatus *ApiError_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiError_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiError_StatusARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		apiErrorStatus.Code = &code
	}

	// Set property ‘Details’:
	for _, item := range typedInput.Details {
		var item1 ApiErrorBase_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		apiErrorStatus.Details = append(apiErrorStatus.Details, item1)
	}

	// Set property ‘Innererror’:
	if typedInput.Innererror != nil {
		var innererror1 InnerError_Status
		err := innererror1.PopulateFromARM(owner, *typedInput.Innererror)
		if err != nil {
			return err
		}
		innererror := innererror1
		apiErrorStatus.Innererror = &innererror
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		apiErrorStatus.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		apiErrorStatus.Target = &target
	}

	// No error
	return nil
}

// AssignPropertiesFromApiErrorStatus populates our ApiError_Status from the provided source ApiError_Status
func (apiErrorStatus *ApiError_Status) AssignPropertiesFromApiErrorStatus(source *v1alpha1api20201201storage.ApiError_Status) error {

	// Code
	apiErrorStatus.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ApiErrorBase_Status, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ApiErrorBase_Status
			err := detail.AssignPropertiesFromApiErrorBaseStatus(&detailItem)
			if err != nil {
				return errors.Wrap(err, "populating Details from Details, calling AssignPropertiesFromApiErrorBaseStatus()")
			}
			detailList[detailIndex] = detail
		}
		apiErrorStatus.Details = detailList
	} else {
		apiErrorStatus.Details = nil
	}

	// Innererror
	if source.Innererror != nil {
		var innererror InnerError_Status
		err := innererror.AssignPropertiesFromInnerErrorStatus(source.Innererror)
		if err != nil {
			return errors.Wrap(err, "populating Innererror from Innererror, calling AssignPropertiesFromInnerErrorStatus()")
		}
		apiErrorStatus.Innererror = &innererror
	} else {
		apiErrorStatus.Innererror = nil
	}

	// Message
	apiErrorStatus.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	apiErrorStatus.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignPropertiesToApiErrorStatus populates the provided destination ApiError_Status from our ApiError_Status
func (apiErrorStatus *ApiError_Status) AssignPropertiesToApiErrorStatus(destination *v1alpha1api20201201storage.ApiError_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(apiErrorStatus.Code)

	// Details
	if apiErrorStatus.Details != nil {
		detailList := make([]v1alpha1api20201201storage.ApiErrorBase_Status, len(apiErrorStatus.Details))
		for detailIndex, detailItem := range apiErrorStatus.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail v1alpha1api20201201storage.ApiErrorBase_Status
			err := detailItem.AssignPropertiesToApiErrorBaseStatus(&detail)
			if err != nil {
				return errors.Wrap(err, "populating Details from Details, calling AssignPropertiesToApiErrorBaseStatus()")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Innererror
	if apiErrorStatus.Innererror != nil {
		var innererror v1alpha1api20201201storage.InnerError_Status
		err := (*apiErrorStatus.Innererror).AssignPropertiesToInnerErrorStatus(&innererror)
		if err != nil {
			return errors.Wrap(err, "populating Innererror from Innererror, calling AssignPropertiesToInnerErrorStatus()")
		}
		destination.Innererror = &innererror
	} else {
		destination.Innererror = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(apiErrorStatus.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(apiErrorStatus.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AvailablePatchSummaryStatusStatus string

const (
	AvailablePatchSummaryStatusStatusCompletedWithWarnings = AvailablePatchSummaryStatusStatus("CompletedWithWarnings")
	AvailablePatchSummaryStatusStatusFailed                = AvailablePatchSummaryStatusStatus("Failed")
	AvailablePatchSummaryStatusStatusInProgress            = AvailablePatchSummaryStatusStatus("InProgress")
	AvailablePatchSummaryStatusStatusSucceeded             = AvailablePatchSummaryStatusStatus("Succeeded")
	AvailablePatchSummaryStatusStatusUnknown               = AvailablePatchSummaryStatusStatus("Unknown")
)

type DiffDiskOption_Status string

const DiffDiskOption_StatusLocal = DiffDiskOption_Status("Local")

type DiffDiskPlacement_Status string

const (
	DiffDiskPlacement_StatusCacheDisk    = DiffDiskPlacement_Status("CacheDisk")
	DiffDiskPlacement_StatusResourceDisk = DiffDiskPlacement_Status("ResourceDisk")
)

// +kubebuilder:validation:Enum={"Local"}
type DiffDiskSettingsOption string

const DiffDiskSettingsOptionLocal = DiffDiskSettingsOption("Local")

// +kubebuilder:validation:Enum={"CacheDisk","ResourceDisk"}
type DiffDiskSettingsPlacement string

const (
	DiffDiskSettingsPlacementCacheDisk    = DiffDiskSettingsPlacement("CacheDisk")
	DiffDiskSettingsPlacementResourceDisk = DiffDiskSettingsPlacement("ResourceDisk")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiskEncryptionSetParameters
type DiskEncryptionSetParameters struct {
	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &DiskEncryptionSetParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diskEncryptionSetParameters == nil {
		return nil, nil
	}
	var result DiskEncryptionSetParametersARM

	// Set property ‘Id’:
	if diskEncryptionSetParameters.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*diskEncryptionSetParameters.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskEncryptionSetParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(DiskEncryptionSetParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskEncryptionSetParametersARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromDiskEncryptionSetParameters populates our DiskEncryptionSetParameters from the provided source DiskEncryptionSetParameters
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) AssignPropertiesFromDiskEncryptionSetParameters(source *v1alpha1api20201201storage.DiskEncryptionSetParameters) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		diskEncryptionSetParameters.Reference = &reference
	} else {
		diskEncryptionSetParameters.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSetParameters populates the provided destination DiskEncryptionSetParameters from our DiskEncryptionSetParameters
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) AssignPropertiesToDiskEncryptionSetParameters(destination *v1alpha1api20201201storage.DiskEncryptionSetParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if diskEncryptionSetParameters.Reference != nil {
		reference := diskEncryptionSetParameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/KeyVaultKeyReference
type KeyVaultKeyReference struct {
	// +kubebuilder:validation:Required
	//KeyUrl: The URL referencing a key encryption key in Key Vault.
	KeyUrl string `json:"keyUrl"`

	// +kubebuilder:validation:Required
	SourceVault SubResource `json:"sourceVault"`
}

var _ genruntime.ARMTransformer = &KeyVaultKeyReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (keyVaultKeyReference *KeyVaultKeyReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if keyVaultKeyReference == nil {
		return nil, nil
	}
	var result KeyVaultKeyReferenceARM

	// Set property ‘KeyUrl’:
	result.KeyUrl = keyVaultKeyReference.KeyUrl

	// Set property ‘SourceVault’:
	sourceVaultARM, err := keyVaultKeyReference.SourceVault.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.SourceVault = sourceVaultARM.(SubResourceARM)
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keyVaultKeyReference *KeyVaultKeyReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultKeyReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keyVaultKeyReference *KeyVaultKeyReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultKeyReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultKeyReferenceARM, got %T", armInput)
	}

	// Set property ‘KeyUrl’:
	keyVaultKeyReference.KeyUrl = typedInput.KeyUrl

	// Set property ‘SourceVault’:
	var sourceVault SubResource
	err := sourceVault.PopulateFromARM(owner, typedInput.SourceVault)
	if err != nil {
		return err
	}
	keyVaultKeyReference.SourceVault = sourceVault

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultKeyReference populates our KeyVaultKeyReference from the provided source KeyVaultKeyReference
func (keyVaultKeyReference *KeyVaultKeyReference) AssignPropertiesFromKeyVaultKeyReference(source *v1alpha1api20201201storage.KeyVaultKeyReference) error {

	// KeyUrl
	keyVaultKeyReference.KeyUrl = genruntime.GetOptionalStringValue(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSubResource()")
		}
		keyVaultKeyReference.SourceVault = sourceVault
	} else {
		keyVaultKeyReference.SourceVault = SubResource{}
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultKeyReference populates the provided destination KeyVaultKeyReference from our KeyVaultKeyReference
func (keyVaultKeyReference *KeyVaultKeyReference) AssignPropertiesToKeyVaultKeyReference(destination *v1alpha1api20201201storage.KeyVaultKeyReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	keyUrl := keyVaultKeyReference.KeyUrl
	destination.KeyUrl = &keyUrl

	// SourceVault
	var sourceVault v1alpha1api20201201storage.SubResource
	err := keyVaultKeyReference.SourceVault.AssignPropertiesToSubResource(&sourceVault)
	if err != nil {
		return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSubResource()")
	}
	destination.SourceVault = &sourceVault

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type KeyVaultKeyReference_Status struct {
	// +kubebuilder:validation:Required
	//KeyUrl: The URL referencing a key encryption key in Key Vault.
	KeyUrl string `json:"keyUrl"`

	// +kubebuilder:validation:Required
	//SourceVault: The relative URL of the Key Vault containing the key.
	SourceVault SubResource_Status `json:"sourceVault"`
}

var _ genruntime.FromARMConverter = &KeyVaultKeyReference_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keyVaultKeyReferenceStatus *KeyVaultKeyReference_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultKeyReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keyVaultKeyReferenceStatus *KeyVaultKeyReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultKeyReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultKeyReference_StatusARM, got %T", armInput)
	}

	// Set property ‘KeyUrl’:
	keyVaultKeyReferenceStatus.KeyUrl = typedInput.KeyUrl

	// Set property ‘SourceVault’:
	var sourceVault SubResource_Status
	err := sourceVault.PopulateFromARM(owner, typedInput.SourceVault)
	if err != nil {
		return err
	}
	keyVaultKeyReferenceStatus.SourceVault = sourceVault

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultKeyReferenceStatus populates our KeyVaultKeyReference_Status from the provided source KeyVaultKeyReference_Status
func (keyVaultKeyReferenceStatus *KeyVaultKeyReference_Status) AssignPropertiesFromKeyVaultKeyReferenceStatus(source *v1alpha1api20201201storage.KeyVaultKeyReference_Status) error {

	// KeyUrl
	keyVaultKeyReferenceStatus.KeyUrl = genruntime.GetOptionalStringValue(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_Status
		err := sourceVault.AssignPropertiesFromSubResourceStatus(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSubResourceStatus()")
		}
		keyVaultKeyReferenceStatus.SourceVault = sourceVault
	} else {
		keyVaultKeyReferenceStatus.SourceVault = SubResource_Status{}
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultKeyReferenceStatus populates the provided destination KeyVaultKeyReference_Status from our KeyVaultKeyReference_Status
func (keyVaultKeyReferenceStatus *KeyVaultKeyReference_Status) AssignPropertiesToKeyVaultKeyReferenceStatus(destination *v1alpha1api20201201storage.KeyVaultKeyReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	keyUrl := keyVaultKeyReferenceStatus.KeyUrl
	destination.KeyUrl = &keyUrl

	// SourceVault
	var sourceVault v1alpha1api20201201storage.SubResource_Status
	err := keyVaultKeyReferenceStatus.SourceVault.AssignPropertiesToSubResourceStatus(&sourceVault)
	if err != nil {
		return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSubResourceStatus()")
	}
	destination.SourceVault = &sourceVault

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/KeyVaultSecretReference
type KeyVaultSecretReference struct {
	// +kubebuilder:validation:Required
	//SecretUrl: The URL referencing a secret in a Key Vault.
	SecretUrl string `json:"secretUrl"`

	// +kubebuilder:validation:Required
	SourceVault SubResource `json:"sourceVault"`
}

var _ genruntime.ARMTransformer = &KeyVaultSecretReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (keyVaultSecretReference *KeyVaultSecretReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if keyVaultSecretReference == nil {
		return nil, nil
	}
	var result KeyVaultSecretReferenceARM

	// Set property ‘SecretUrl’:
	result.SecretUrl = keyVaultSecretReference.SecretUrl

	// Set property ‘SourceVault’:
	sourceVaultARM, err := keyVaultSecretReference.SourceVault.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.SourceVault = sourceVaultARM.(SubResourceARM)
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keyVaultSecretReference *KeyVaultSecretReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultSecretReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keyVaultSecretReference *KeyVaultSecretReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultSecretReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultSecretReferenceARM, got %T", armInput)
	}

	// Set property ‘SecretUrl’:
	keyVaultSecretReference.SecretUrl = typedInput.SecretUrl

	// Set property ‘SourceVault’:
	var sourceVault SubResource
	err := sourceVault.PopulateFromARM(owner, typedInput.SourceVault)
	if err != nil {
		return err
	}
	keyVaultSecretReference.SourceVault = sourceVault

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultSecretReference populates our KeyVaultSecretReference from the provided source KeyVaultSecretReference
func (keyVaultSecretReference *KeyVaultSecretReference) AssignPropertiesFromKeyVaultSecretReference(source *v1alpha1api20201201storage.KeyVaultSecretReference) error {

	// SecretUrl
	keyVaultSecretReference.SecretUrl = genruntime.GetOptionalStringValue(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSubResource()")
		}
		keyVaultSecretReference.SourceVault = sourceVault
	} else {
		keyVaultSecretReference.SourceVault = SubResource{}
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSecretReference populates the provided destination KeyVaultSecretReference from our KeyVaultSecretReference
func (keyVaultSecretReference *KeyVaultSecretReference) AssignPropertiesToKeyVaultSecretReference(destination *v1alpha1api20201201storage.KeyVaultSecretReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretUrl
	secretUrl := keyVaultSecretReference.SecretUrl
	destination.SecretUrl = &secretUrl

	// SourceVault
	var sourceVault v1alpha1api20201201storage.SubResource
	err := keyVaultSecretReference.SourceVault.AssignPropertiesToSubResource(&sourceVault)
	if err != nil {
		return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSubResource()")
	}
	destination.SourceVault = &sourceVault

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type KeyVaultSecretReference_Status struct {
	// +kubebuilder:validation:Required
	//SecretUrl: The URL referencing a secret in a Key Vault.
	SecretUrl string `json:"secretUrl"`

	// +kubebuilder:validation:Required
	//SourceVault: The relative URL of the Key Vault containing the secret.
	SourceVault SubResource_Status `json:"sourceVault"`
}

var _ genruntime.FromARMConverter = &KeyVaultSecretReference_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keyVaultSecretReferenceStatus *KeyVaultSecretReference_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultSecretReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keyVaultSecretReferenceStatus *KeyVaultSecretReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultSecretReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultSecretReference_StatusARM, got %T", armInput)
	}

	// Set property ‘SecretUrl’:
	keyVaultSecretReferenceStatus.SecretUrl = typedInput.SecretUrl

	// Set property ‘SourceVault’:
	var sourceVault SubResource_Status
	err := sourceVault.PopulateFromARM(owner, typedInput.SourceVault)
	if err != nil {
		return err
	}
	keyVaultSecretReferenceStatus.SourceVault = sourceVault

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultSecretReferenceStatus populates our KeyVaultSecretReference_Status from the provided source KeyVaultSecretReference_Status
func (keyVaultSecretReferenceStatus *KeyVaultSecretReference_Status) AssignPropertiesFromKeyVaultSecretReferenceStatus(source *v1alpha1api20201201storage.KeyVaultSecretReference_Status) error {

	// SecretUrl
	keyVaultSecretReferenceStatus.SecretUrl = genruntime.GetOptionalStringValue(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_Status
		err := sourceVault.AssignPropertiesFromSubResourceStatus(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSubResourceStatus()")
		}
		keyVaultSecretReferenceStatus.SourceVault = sourceVault
	} else {
		keyVaultSecretReferenceStatus.SourceVault = SubResource_Status{}
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSecretReferenceStatus populates the provided destination KeyVaultSecretReference_Status from our KeyVaultSecretReference_Status
func (keyVaultSecretReferenceStatus *KeyVaultSecretReference_Status) AssignPropertiesToKeyVaultSecretReferenceStatus(destination *v1alpha1api20201201storage.KeyVaultSecretReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretUrl
	secretUrl := keyVaultSecretReferenceStatus.SecretUrl
	destination.SecretUrl = &secretUrl

	// SourceVault
	var sourceVault v1alpha1api20201201storage.SubResource_Status
	err := keyVaultSecretReferenceStatus.SourceVault.AssignPropertiesToSubResourceStatus(&sourceVault)
	if err != nil {
		return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSubResourceStatus()")
	}
	destination.SourceVault = &sourceVault

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LastPatchInstallationSummaryStatusStatus string

const (
	LastPatchInstallationSummaryStatusStatusCompletedWithWarnings = LastPatchInstallationSummaryStatusStatus("CompletedWithWarnings")
	LastPatchInstallationSummaryStatusStatusFailed                = LastPatchInstallationSummaryStatusStatus("Failed")
	LastPatchInstallationSummaryStatusStatusInProgress            = LastPatchInstallationSummaryStatusStatus("InProgress")
	LastPatchInstallationSummaryStatusStatusSucceeded             = LastPatchInstallationSummaryStatusStatus("Succeeded")
	LastPatchInstallationSummaryStatusStatusUnknown               = LastPatchInstallationSummaryStatusStatus("Unknown")
)

// +kubebuilder:validation:Enum={"AutomaticByPlatform","ImageDefault"}
type LinuxPatchSettingsPatchMode string

const (
	LinuxPatchSettingsPatchModeAutomaticByPlatform = LinuxPatchSettingsPatchMode("AutomaticByPlatform")
	LinuxPatchSettingsPatchModeImageDefault        = LinuxPatchSettingsPatchMode("ImageDefault")
)

type LinuxPatchSettingsStatusPatchMode string

const (
	LinuxPatchSettingsStatusPatchModeAutomaticByPlatform = LinuxPatchSettingsStatusPatchMode("AutomaticByPlatform")
	LinuxPatchSettingsStatusPatchModeImageDefault        = LinuxPatchSettingsStatusPatchMode("ImageDefault")
)

// +kubebuilder:validation:Enum={"Premium_LRS","Premium_ZRS","Standard_LRS","StandardSSD_LRS","StandardSSD_ZRS","UltraSSD_LRS"}
type ManagedDiskParametersStorageAccountType string

const (
	ManagedDiskParametersStorageAccountTypePremiumLRS     = ManagedDiskParametersStorageAccountType("Premium_LRS")
	ManagedDiskParametersStorageAccountTypePremiumZRS     = ManagedDiskParametersStorageAccountType("Premium_ZRS")
	ManagedDiskParametersStorageAccountTypeStandardLRS    = ManagedDiskParametersStorageAccountType("Standard_LRS")
	ManagedDiskParametersStorageAccountTypeStandardSSDLRS = ManagedDiskParametersStorageAccountType("StandardSSD_LRS")
	ManagedDiskParametersStorageAccountTypeStandardSSDZRS = ManagedDiskParametersStorageAccountType("StandardSSD_ZRS")
	ManagedDiskParametersStorageAccountTypeUltraSSDLRS    = ManagedDiskParametersStorageAccountType("UltraSSD_LRS")
)

// +kubebuilder:validation:Enum={"AutomaticByOS","AutomaticByPlatform","Manual"}
type PatchSettingsPatchMode string

const (
	PatchSettingsPatchModeAutomaticByOS       = PatchSettingsPatchMode("AutomaticByOS")
	PatchSettingsPatchModeAutomaticByPlatform = PatchSettingsPatchMode("AutomaticByPlatform")
	PatchSettingsPatchModeManual              = PatchSettingsPatchMode("Manual")
)

type PatchSettingsStatusPatchMode string

const (
	PatchSettingsStatusPatchModeAutomaticByOS       = PatchSettingsStatusPatchMode("AutomaticByOS")
	PatchSettingsStatusPatchModeAutomaticByPlatform = PatchSettingsStatusPatchMode("AutomaticByPlatform")
	PatchSettingsStatusPatchModeManual              = PatchSettingsStatusPatchMode("Manual")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SshPublicKey
type SshPublicKey struct {
	//KeyData: SSH public key certificate used to authenticate with the VM through
	//ssh. The key needs to be at least 2048-bit and in ssh-rsa format.
	//For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in
	//Azure](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	KeyData *string `json:"keyData,omitempty"`

	//Path: Specifies the full path on the created VM where ssh public key is stored.
	//If the file already exists, the specified key is appended to the file. Example:
	///home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

var _ genruntime.ARMTransformer = &SshPublicKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sshPublicKey *SshPublicKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sshPublicKey == nil {
		return nil, nil
	}
	var result SshPublicKeyARM

	// Set property ‘KeyData’:
	if sshPublicKey.KeyData != nil {
		keyData := *sshPublicKey.KeyData
		result.KeyData = &keyData
	}

	// Set property ‘Path’:
	if sshPublicKey.Path != nil {
		path := *sshPublicKey.Path
		result.Path = &path
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sshPublicKey *SshPublicKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshPublicKeyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sshPublicKey *SshPublicKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshPublicKeyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshPublicKeyARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		sshPublicKey.KeyData = &keyData
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		sshPublicKey.Path = &path
	}

	// No error
	return nil
}

// AssignPropertiesFromSshPublicKey populates our SshPublicKey from the provided source SshPublicKey
func (sshPublicKey *SshPublicKey) AssignPropertiesFromSshPublicKey(source *v1alpha1api20201201storage.SshPublicKey) error {

	// KeyData
	sshPublicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	sshPublicKey.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToSshPublicKey populates the provided destination SshPublicKey from our SshPublicKey
func (sshPublicKey *SshPublicKey) AssignPropertiesToSshPublicKey(destination *v1alpha1api20201201storage.SshPublicKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(sshPublicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(sshPublicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SshPublicKey_Status struct {
	//KeyData: SSH public key certificate used to authenticate with the VM through
	//ssh. The key needs to be at least 2048-bit and in ssh-rsa format.
	//For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in
	//Azure](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	KeyData *string `json:"keyData,omitempty"`

	//Path: Specifies the full path on the created VM where ssh public key is stored.
	//If the file already exists, the specified key is appended to the file. Example:
	///home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

var _ genruntime.FromARMConverter = &SshPublicKey_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sshPublicKeyStatus *SshPublicKey_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshPublicKey_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sshPublicKeyStatus *SshPublicKey_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshPublicKey_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshPublicKey_StatusARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		sshPublicKeyStatus.KeyData = &keyData
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		sshPublicKeyStatus.Path = &path
	}

	// No error
	return nil
}

// AssignPropertiesFromSshPublicKeyStatus populates our SshPublicKey_Status from the provided source SshPublicKey_Status
func (sshPublicKeyStatus *SshPublicKey_Status) AssignPropertiesFromSshPublicKeyStatus(source *v1alpha1api20201201storage.SshPublicKey_Status) error {

	// KeyData
	sshPublicKeyStatus.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	sshPublicKeyStatus.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToSshPublicKeyStatus populates the provided destination SshPublicKey_Status from our SshPublicKey_Status
func (sshPublicKeyStatus *SshPublicKey_Status) AssignPropertiesToSshPublicKeyStatus(destination *v1alpha1api20201201storage.SshPublicKey_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(sshPublicKeyStatus.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(sshPublicKeyStatus.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type StorageAccountType_Status string

const (
	StorageAccountType_StatusPremiumLRS     = StorageAccountType_Status("Premium_LRS")
	StorageAccountType_StatusPremiumZRS     = StorageAccountType_Status("Premium_ZRS")
	StorageAccountType_StatusStandardLRS    = StorageAccountType_Status("Standard_LRS")
	StorageAccountType_StatusStandardSSDLRS = StorageAccountType_Status("StandardSSD_LRS")
	StorageAccountType_StatusStandardSSDZRS = StorageAccountType_Status("StandardSSD_ZRS")
	StorageAccountType_StatusUltraSSDLRS    = StorageAccountType_Status("UltraSSD_LRS")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WinRMListener
type WinRMListener struct {
	//CertificateUrl: This is the URL of a certificate that has been uploaded to Key
	//Vault as a secret. For adding a secret to the Key Vault, see [Add a key or
	//secret to the key
	//vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	//In this case, your certificate needs to be It is the Base64 encoding of the
	//following JSON Object which is encoded in UTF-8:
	//{
	//"data":"<Base64-encoded-certificate>",
	//"dataType":"pfx",
	//"password":"<pfx-file-password>"
	//}
	CertificateUrl *string `json:"certificateUrl,omitempty"`

	//Protocol: Specifies the protocol of WinRM listener.
	//Possible values are:
	//http
	//https.
	Protocol *WinRMListenerProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &WinRMListener{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (winRMListener *WinRMListener) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if winRMListener == nil {
		return nil, nil
	}
	var result WinRMListenerARM

	// Set property ‘CertificateUrl’:
	if winRMListener.CertificateUrl != nil {
		certificateUrl := *winRMListener.CertificateUrl
		result.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if winRMListener.Protocol != nil {
		protocol := *winRMListener.Protocol
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (winRMListener *WinRMListener) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMListenerARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (winRMListener *WinRMListener) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMListenerARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMListenerARM, got %T", armInput)
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		winRMListener.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		winRMListener.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMListener populates our WinRMListener from the provided source WinRMListener
func (winRMListener *WinRMListener) AssignPropertiesFromWinRMListener(source *v1alpha1api20201201storage.WinRMListener) error {

	// CertificateUrl
	winRMListener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	if source.Protocol != nil {
		protocol := WinRMListenerProtocol(*source.Protocol)
		winRMListener.Protocol = &protocol
	} else {
		winRMListener.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMListener populates the provided destination WinRMListener from our WinRMListener
func (winRMListener *WinRMListener) AssignPropertiesToWinRMListener(destination *v1alpha1api20201201storage.WinRMListener) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(winRMListener.CertificateUrl)

	// Protocol
	if winRMListener.Protocol != nil {
		protocol := string(*winRMListener.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WinRMListener_Status struct {
	//CertificateUrl: This is the URL of a certificate that has been uploaded to Key
	//Vault as a secret. For adding a secret to the Key Vault, see [Add a key or
	//secret to the key
	//vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	//In this case, your certificate needs to be It is the Base64 encoding of the
	//following JSON Object which is encoded in UTF-8:
	//{
	//"data":"<Base64-encoded-certificate>",
	//"dataType":"pfx",
	//"password":"<pfx-file-password>"
	//}
	CertificateUrl *string `json:"certificateUrl,omitempty"`

	//Protocol: Specifies the protocol of WinRM listener.
	//Possible values are:
	//http
	//https
	Protocol *WinRMListenerStatusProtocol `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &WinRMListener_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (winRMListenerStatus *WinRMListener_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMListener_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (winRMListenerStatus *WinRMListener_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMListener_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMListener_StatusARM, got %T", armInput)
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		winRMListenerStatus.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		winRMListenerStatus.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMListenerStatus populates our WinRMListener_Status from the provided source WinRMListener_Status
func (winRMListenerStatus *WinRMListener_Status) AssignPropertiesFromWinRMListenerStatus(source *v1alpha1api20201201storage.WinRMListener_Status) error {

	// CertificateUrl
	winRMListenerStatus.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	if source.Protocol != nil {
		protocol := WinRMListenerStatusProtocol(*source.Protocol)
		winRMListenerStatus.Protocol = &protocol
	} else {
		winRMListenerStatus.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMListenerStatus populates the provided destination WinRMListener_Status from our WinRMListener_Status
func (winRMListenerStatus *WinRMListener_Status) AssignPropertiesToWinRMListenerStatus(destination *v1alpha1api20201201storage.WinRMListener_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(winRMListenerStatus.CertificateUrl)

	// Protocol
	if winRMListenerStatus.Protocol != nil {
		protocol := string(*winRMListenerStatus.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApiErrorBase_Status struct {
	//Code: The error code.
	Code *string `json:"code,omitempty"`

	//Message: The error message.
	Message *string `json:"message,omitempty"`

	//Target: The target of the particular error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiErrorBase_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apiErrorBaseStatus *ApiErrorBase_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiErrorBase_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apiErrorBaseStatus *ApiErrorBase_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiErrorBase_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiErrorBase_StatusARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		apiErrorBaseStatus.Code = &code
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		apiErrorBaseStatus.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		apiErrorBaseStatus.Target = &target
	}

	// No error
	return nil
}

// AssignPropertiesFromApiErrorBaseStatus populates our ApiErrorBase_Status from the provided source ApiErrorBase_Status
func (apiErrorBaseStatus *ApiErrorBase_Status) AssignPropertiesFromApiErrorBaseStatus(source *v1alpha1api20201201storage.ApiErrorBase_Status) error {

	// Code
	apiErrorBaseStatus.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	apiErrorBaseStatus.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	apiErrorBaseStatus.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignPropertiesToApiErrorBaseStatus populates the provided destination ApiErrorBase_Status from our ApiErrorBase_Status
func (apiErrorBaseStatus *ApiErrorBase_Status) AssignPropertiesToApiErrorBaseStatus(destination *v1alpha1api20201201storage.ApiErrorBase_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(apiErrorBaseStatus.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(apiErrorBaseStatus.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(apiErrorBaseStatus.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InnerError_Status struct {
	//Errordetail: The internal error message or exception dump.
	Errordetail *string `json:"errordetail,omitempty"`

	//Exceptiontype: The exception type.
	Exceptiontype *string `json:"exceptiontype,omitempty"`
}

var _ genruntime.FromARMConverter = &InnerError_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (innerErrorStatus *InnerError_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &InnerError_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (innerErrorStatus *InnerError_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(InnerError_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InnerError_StatusARM, got %T", armInput)
	}

	// Set property ‘Errordetail’:
	if typedInput.Errordetail != nil {
		errordetail := *typedInput.Errordetail
		innerErrorStatus.Errordetail = &errordetail
	}

	// Set property ‘Exceptiontype’:
	if typedInput.Exceptiontype != nil {
		exceptiontype := *typedInput.Exceptiontype
		innerErrorStatus.Exceptiontype = &exceptiontype
	}

	// No error
	return nil
}

// AssignPropertiesFromInnerErrorStatus populates our InnerError_Status from the provided source InnerError_Status
func (innerErrorStatus *InnerError_Status) AssignPropertiesFromInnerErrorStatus(source *v1alpha1api20201201storage.InnerError_Status) error {

	// Errordetail
	innerErrorStatus.Errordetail = genruntime.ClonePointerToString(source.Errordetail)

	// Exceptiontype
	innerErrorStatus.Exceptiontype = genruntime.ClonePointerToString(source.Exceptiontype)

	// No error
	return nil
}

// AssignPropertiesToInnerErrorStatus populates the provided destination InnerError_Status from our InnerError_Status
func (innerErrorStatus *InnerError_Status) AssignPropertiesToInnerErrorStatus(destination *v1alpha1api20201201storage.InnerError_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Errordetail
	destination.Errordetail = genruntime.ClonePointerToString(innerErrorStatus.Errordetail)

	// Exceptiontype
	destination.Exceptiontype = genruntime.ClonePointerToString(innerErrorStatus.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Http","Https"}
type WinRMListenerProtocol string

const (
	WinRMListenerProtocolHttp  = WinRMListenerProtocol("Http")
	WinRMListenerProtocolHttps = WinRMListenerProtocol("Https")
)

type WinRMListenerStatusProtocol string

const (
	WinRMListenerStatusProtocolHttp  = WinRMListenerStatusProtocol("Http")
	WinRMListenerStatusProtocolHttps = WinRMListenerStatusProtocol("Https")
)

func init() {
	SchemeBuilder.Register(&VirtualMachine{}, &VirtualMachineList{})
}
