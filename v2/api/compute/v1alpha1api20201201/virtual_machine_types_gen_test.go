// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachine to hub returns original",
		prop.ForAll(RunResourceConversionTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForVirtualMachine tests if a specific instance of VirtualMachine round trips to the hub storage version and back losslessly
func RunResourceConversionTestForVirtualMachine(subject VirtualMachine) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20201201storage.VirtualMachine
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual VirtualMachine
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachine_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachine to VirtualMachine via AssignPropertiesToVirtualMachine & AssignPropertiesFromVirtualMachine returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachine tests if a specific instance of VirtualMachine can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachine(subject VirtualMachine) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachine
	err := copied.AssignPropertiesToVirtualMachine(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachine
	err = actual.AssignPropertiesFromVirtualMachine(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachine_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine runs a test to see if a specific instance of VirtualMachine round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine(subject VirtualMachine) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine instances for property testing - lazily instantiated by VirtualMachineGenerator()
var virtualMachineGenerator gopter.Gen

// VirtualMachineGenerator returns a generator of VirtualMachine instances for property testing.
func VirtualMachineGenerator() gopter.Gen {
	if virtualMachineGenerator != nil {
		return virtualMachineGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachine(generators)
	virtualMachineGenerator = gen.Struct(reflect.TypeOf(VirtualMachine{}), generators)

	return virtualMachineGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachine is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualMachinesSPECGenerator()
	gens["Status"] = VirtualMachineStatusGenerator()
}

func Test_VirtualMachine_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachine_Status to VirtualMachine_Status via AssignPropertiesToVirtualMachineStatus & AssignPropertiesFromVirtualMachineStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineStatus, VirtualMachineStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineStatus tests if a specific instance of VirtualMachine_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineStatus(subject VirtualMachine_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachine_Status
	err := copied.AssignPropertiesToVirtualMachineStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachine_Status
	err = actual.AssignPropertiesFromVirtualMachineStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachine_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineStatus, VirtualMachineStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineStatus runs a test to see if a specific instance of VirtualMachine_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineStatus(subject VirtualMachine_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_Status instances for property testing - lazily instantiated by
//VirtualMachineStatusGenerator()
var virtualMachineStatusGenerator gopter.Gen

// VirtualMachineStatusGenerator returns a generator of VirtualMachine_Status instances for property testing.
// We first initialize virtualMachineStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineStatusGenerator() gopter.Gen {
	if virtualMachineStatusGenerator != nil {
		return virtualMachineStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineStatus(generators)
	virtualMachineStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineStatus(generators)
	virtualMachineStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	return virtualMachineStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineStatus(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_StatusDeallocate, EvictionPolicy_StatusDelete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_StatusLow, Priority_StatusRegular, Priority_StatusSpot))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineStatus(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesStatusGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileStatusGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileStatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileStatusGenerator())
	gens["Host"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentityStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceViewStatusGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileStatusGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileStatusGenerator())
	gens["Plan"] = gen.PtrOf(PlanStatusGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Resources"] = gen.SliceOf(VirtualMachineExtensionStatusGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileStatusGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileStatusGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_VirtualMachines_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachines_SPEC to VirtualMachines_SPEC via AssignPropertiesToVirtualMachinesSPEC & AssignPropertiesFromVirtualMachinesSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachinesSPEC, VirtualMachinesSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachinesSPEC tests if a specific instance of VirtualMachines_SPEC can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachinesSPEC(subject VirtualMachines_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachines_SPEC
	err := copied.AssignPropertiesToVirtualMachinesSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachines_SPEC
	err = actual.AssignPropertiesFromVirtualMachinesSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachines_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSPEC, VirtualMachinesSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSPEC runs a test to see if a specific instance of VirtualMachines_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSPEC(subject VirtualMachines_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_SPEC instances for property testing - lazily instantiated by
//VirtualMachinesSPECGenerator()
var virtualMachinesSPECGenerator gopter.Gen

// VirtualMachinesSPECGenerator returns a generator of VirtualMachines_SPEC instances for property testing.
// We first initialize virtualMachinesSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSPECGenerator() gopter.Gen {
	if virtualMachinesSPECGenerator != nil {
		return virtualMachinesSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSPEC(generators)
	virtualMachinesSPECGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSPEC(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSPEC(generators)
	virtualMachinesSPECGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPEC{}), generators)

	return virtualMachinesSPECGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_SpecDeallocate, EvictionPolicy_SpecDelete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.AlphaString()
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_SpecLow, Priority_SpecRegular, Priority_SpecSpot))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSPEC(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesSpecGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileSpecGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileSpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileSpecGenerator())
	gens["Host"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentitySpecGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileSpecGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileSpecGenerator())
	gens["Plan"] = gen.PtrOf(PlanSpecGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileSpecGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileSpecGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_AdditionalCapabilities_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalCapabilities_Spec to AdditionalCapabilities_Spec via AssignPropertiesToAdditionalCapabilitiesSpec & AssignPropertiesFromAdditionalCapabilitiesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalCapabilitiesSpec, AdditionalCapabilitiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalCapabilitiesSpec tests if a specific instance of AdditionalCapabilities_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAdditionalCapabilitiesSpec(subject AdditionalCapabilities_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AdditionalCapabilities_Spec
	err := copied.AssignPropertiesToAdditionalCapabilitiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalCapabilities_Spec
	err = actual.AssignPropertiesFromAdditionalCapabilitiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalCapabilities_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilitiesSpec, AdditionalCapabilitiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilitiesSpec runs a test to see if a specific instance of AdditionalCapabilities_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilitiesSpec(subject AdditionalCapabilities_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Spec instances for property testing - lazily instantiated by
//AdditionalCapabilitiesSpecGenerator()
var additionalCapabilitiesSpecGenerator gopter.Gen

// AdditionalCapabilitiesSpecGenerator returns a generator of AdditionalCapabilities_Spec instances for property testing.
func AdditionalCapabilitiesSpecGenerator() gopter.Gen {
	if additionalCapabilitiesSpecGenerator != nil {
		return additionalCapabilitiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilitiesSpec(generators)
	additionalCapabilitiesSpecGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Spec{}), generators)

	return additionalCapabilitiesSpecGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilitiesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilitiesSpec(gens map[string]gopter.Gen) {
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_AdditionalCapabilities_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalCapabilities_Status to AdditionalCapabilities_Status via AssignPropertiesToAdditionalCapabilitiesStatus & AssignPropertiesFromAdditionalCapabilitiesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalCapabilitiesStatus, AdditionalCapabilitiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalCapabilitiesStatus tests if a specific instance of AdditionalCapabilities_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAdditionalCapabilitiesStatus(subject AdditionalCapabilities_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AdditionalCapabilities_Status
	err := copied.AssignPropertiesToAdditionalCapabilitiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalCapabilities_Status
	err = actual.AssignPropertiesFromAdditionalCapabilitiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalCapabilities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilitiesStatus, AdditionalCapabilitiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilitiesStatus runs a test to see if a specific instance of AdditionalCapabilities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilitiesStatus(subject AdditionalCapabilities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Status instances for property testing - lazily instantiated by
//AdditionalCapabilitiesStatusGenerator()
var additionalCapabilitiesStatusGenerator gopter.Gen

// AdditionalCapabilitiesStatusGenerator returns a generator of AdditionalCapabilities_Status instances for property testing.
func AdditionalCapabilitiesStatusGenerator() gopter.Gen {
	if additionalCapabilitiesStatusGenerator != nil {
		return additionalCapabilitiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus(generators)
	additionalCapabilitiesStatusGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Status{}), generators)

	return additionalCapabilitiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus(gens map[string]gopter.Gen) {
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_BillingProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BillingProfile_Spec to BillingProfile_Spec via AssignPropertiesToBillingProfileSpec & AssignPropertiesFromBillingProfileSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBillingProfileSpec, BillingProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBillingProfileSpec tests if a specific instance of BillingProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBillingProfileSpec(subject BillingProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BillingProfile_Spec
	err := copied.AssignPropertiesToBillingProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BillingProfile_Spec
	err = actual.AssignPropertiesFromBillingProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BillingProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileSpec, BillingProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileSpec runs a test to see if a specific instance of BillingProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileSpec(subject BillingProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Spec instances for property testing - lazily instantiated by BillingProfileSpecGenerator()
var billingProfileSpecGenerator gopter.Gen

// BillingProfileSpecGenerator returns a generator of BillingProfile_Spec instances for property testing.
func BillingProfileSpecGenerator() gopter.Gen {
	if billingProfileSpecGenerator != nil {
		return billingProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileSpec(generators)
	billingProfileSpecGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Spec{}), generators)

	return billingProfileSpecGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileSpec(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_BillingProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BillingProfile_Status to BillingProfile_Status via AssignPropertiesToBillingProfileStatus & AssignPropertiesFromBillingProfileStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForBillingProfileStatus, BillingProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBillingProfileStatus tests if a specific instance of BillingProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBillingProfileStatus(subject BillingProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BillingProfile_Status
	err := copied.AssignPropertiesToBillingProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BillingProfile_Status
	err = actual.AssignPropertiesFromBillingProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BillingProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileStatus, BillingProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileStatus runs a test to see if a specific instance of BillingProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileStatus(subject BillingProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Status instances for property testing - lazily instantiated by
//BillingProfileStatusGenerator()
var billingProfileStatusGenerator gopter.Gen

// BillingProfileStatusGenerator returns a generator of BillingProfile_Status instances for property testing.
func BillingProfileStatusGenerator() gopter.Gen {
	if billingProfileStatusGenerator != nil {
		return billingProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileStatus(generators)
	billingProfileStatusGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Status{}), generators)

	return billingProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileStatus(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiagnosticsProfile_Spec to DiagnosticsProfile_Spec via AssignPropertiesToDiagnosticsProfileSpec & AssignPropertiesFromDiagnosticsProfileSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiagnosticsProfileSpec, DiagnosticsProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiagnosticsProfileSpec tests if a specific instance of DiagnosticsProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiagnosticsProfileSpec(subject DiagnosticsProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiagnosticsProfile_Spec
	err := copied.AssignPropertiesToDiagnosticsProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiagnosticsProfile_Spec
	err = actual.AssignPropertiesFromDiagnosticsProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiagnosticsProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileSpec, DiagnosticsProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileSpec runs a test to see if a specific instance of DiagnosticsProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileSpec(subject DiagnosticsProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Spec instances for property testing - lazily instantiated by
//DiagnosticsProfileSpecGenerator()
var diagnosticsProfileSpecGenerator gopter.Gen

// DiagnosticsProfileSpecGenerator returns a generator of DiagnosticsProfile_Spec instances for property testing.
func DiagnosticsProfileSpecGenerator() gopter.Gen {
	if diagnosticsProfileSpecGenerator != nil {
		return diagnosticsProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileSpec(generators)
	diagnosticsProfileSpecGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Spec{}), generators)

	return diagnosticsProfileSpecGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileSpec(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsSpecGenerator())
}

func Test_DiagnosticsProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiagnosticsProfile_Status to DiagnosticsProfile_Status via AssignPropertiesToDiagnosticsProfileStatus & AssignPropertiesFromDiagnosticsProfileStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiagnosticsProfileStatus, DiagnosticsProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiagnosticsProfileStatus tests if a specific instance of DiagnosticsProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiagnosticsProfileStatus(subject DiagnosticsProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiagnosticsProfile_Status
	err := copied.AssignPropertiesToDiagnosticsProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiagnosticsProfile_Status
	err = actual.AssignPropertiesFromDiagnosticsProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiagnosticsProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileStatus, DiagnosticsProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileStatus runs a test to see if a specific instance of DiagnosticsProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileStatus(subject DiagnosticsProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Status instances for property testing - lazily instantiated by
//DiagnosticsProfileStatusGenerator()
var diagnosticsProfileStatusGenerator gopter.Gen

// DiagnosticsProfileStatusGenerator returns a generator of DiagnosticsProfile_Status instances for property testing.
func DiagnosticsProfileStatusGenerator() gopter.Gen {
	if diagnosticsProfileStatusGenerator != nil {
		return diagnosticsProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus(generators)
	diagnosticsProfileStatusGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Status{}), generators)

	return diagnosticsProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsStatusGenerator())
}

func Test_ExtendedLocation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Spec to ExtendedLocation_Spec via AssignPropertiesToExtendedLocationSpec & AssignPropertiesFromExtendedLocationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocationSpec, ExtendedLocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocationSpec tests if a specific instance of ExtendedLocation_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocationSpec(subject ExtendedLocation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ExtendedLocation_Spec
	err := copied.AssignPropertiesToExtendedLocationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Spec
	err = actual.AssignPropertiesFromExtendedLocationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSpec, ExtendedLocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSpec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSpec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocationSpecGenerator()
var extendedLocationSpecGenerator gopter.Gen

// ExtendedLocationSpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocationSpecGenerator() gopter.Gen {
	if extendedLocationSpecGenerator != nil {
		return extendedLocationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSpec(generators)
	extendedLocationSpecGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocationSpecGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_ExtendedLocation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Status to ExtendedLocation_Status via AssignPropertiesToExtendedLocationStatus & AssignPropertiesFromExtendedLocationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocationStatus, ExtendedLocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocationStatus tests if a specific instance of ExtendedLocation_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocationStatus(subject ExtendedLocation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ExtendedLocation_Status
	err := copied.AssignPropertiesToExtendedLocationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Status
	err = actual.AssignPropertiesFromExtendedLocationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationStatus, ExtendedLocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationStatus runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationStatus(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocationStatusGenerator()
var extendedLocationStatusGenerator gopter.Gen

// ExtendedLocationStatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocationStatusGenerator() gopter.Gen {
	if extendedLocationStatusGenerator != nil {
		return extendedLocationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationStatus(generators)
	extendedLocationStatusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocationStatusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_StatusEdgeZone))
}

func Test_HardwareProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HardwareProfile_Spec to HardwareProfile_Spec via AssignPropertiesToHardwareProfileSpec & AssignPropertiesFromHardwareProfileSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForHardwareProfileSpec, HardwareProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHardwareProfileSpec tests if a specific instance of HardwareProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForHardwareProfileSpec(subject HardwareProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.HardwareProfile_Spec
	err := copied.AssignPropertiesToHardwareProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HardwareProfile_Spec
	err = actual.AssignPropertiesFromHardwareProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HardwareProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileSpec, HardwareProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileSpec runs a test to see if a specific instance of HardwareProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileSpec(subject HardwareProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Spec instances for property testing - lazily instantiated by
//HardwareProfileSpecGenerator()
var hardwareProfileSpecGenerator gopter.Gen

// HardwareProfileSpecGenerator returns a generator of HardwareProfile_Spec instances for property testing.
func HardwareProfileSpecGenerator() gopter.Gen {
	if hardwareProfileSpecGenerator != nil {
		return hardwareProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileSpec(generators)
	hardwareProfileSpecGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Spec{}), generators)

	return hardwareProfileSpecGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileSpec(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfileSpecVmSizeBasicA0,
		HardwareProfileSpecVmSizeBasicA1,
		HardwareProfileSpecVmSizeBasicA2,
		HardwareProfileSpecVmSizeBasicA3,
		HardwareProfileSpecVmSizeBasicA4,
		HardwareProfileSpecVmSizeStandardA0,
		HardwareProfileSpecVmSizeStandardA1,
		HardwareProfileSpecVmSizeStandardA10,
		HardwareProfileSpecVmSizeStandardA11,
		HardwareProfileSpecVmSizeStandardA1V2,
		HardwareProfileSpecVmSizeStandardA2,
		HardwareProfileSpecVmSizeStandardA2MV2,
		HardwareProfileSpecVmSizeStandardA2V2,
		HardwareProfileSpecVmSizeStandardA3,
		HardwareProfileSpecVmSizeStandardA4,
		HardwareProfileSpecVmSizeStandardA4MV2,
		HardwareProfileSpecVmSizeStandardA4V2,
		HardwareProfileSpecVmSizeStandardA5,
		HardwareProfileSpecVmSizeStandardA6,
		HardwareProfileSpecVmSizeStandardA7,
		HardwareProfileSpecVmSizeStandardA8,
		HardwareProfileSpecVmSizeStandardA8MV2,
		HardwareProfileSpecVmSizeStandardA8V2,
		HardwareProfileSpecVmSizeStandardA9,
		HardwareProfileSpecVmSizeStandardB1Ms,
		HardwareProfileSpecVmSizeStandardB1S,
		HardwareProfileSpecVmSizeStandardB2Ms,
		HardwareProfileSpecVmSizeStandardB2S,
		HardwareProfileSpecVmSizeStandardB4Ms,
		HardwareProfileSpecVmSizeStandardB8Ms,
		HardwareProfileSpecVmSizeStandardD1,
		HardwareProfileSpecVmSizeStandardD11,
		HardwareProfileSpecVmSizeStandardD11V2,
		HardwareProfileSpecVmSizeStandardD12,
		HardwareProfileSpecVmSizeStandardD12V2,
		HardwareProfileSpecVmSizeStandardD13,
		HardwareProfileSpecVmSizeStandardD13V2,
		HardwareProfileSpecVmSizeStandardD14,
		HardwareProfileSpecVmSizeStandardD14V2,
		HardwareProfileSpecVmSizeStandardD15V2,
		HardwareProfileSpecVmSizeStandardD16SV3,
		HardwareProfileSpecVmSizeStandardD16V3,
		HardwareProfileSpecVmSizeStandardD1V2,
		HardwareProfileSpecVmSizeStandardD2,
		HardwareProfileSpecVmSizeStandardD2SV3,
		HardwareProfileSpecVmSizeStandardD2V2,
		HardwareProfileSpecVmSizeStandardD2V3,
		HardwareProfileSpecVmSizeStandardD3,
		HardwareProfileSpecVmSizeStandardD32SV3,
		HardwareProfileSpecVmSizeStandardD32V3,
		HardwareProfileSpecVmSizeStandardD3V2,
		HardwareProfileSpecVmSizeStandardD4,
		HardwareProfileSpecVmSizeStandardD4SV3,
		HardwareProfileSpecVmSizeStandardD4V2,
		HardwareProfileSpecVmSizeStandardD4V3,
		HardwareProfileSpecVmSizeStandardD5V2,
		HardwareProfileSpecVmSizeStandardD64SV3,
		HardwareProfileSpecVmSizeStandardD64V3,
		HardwareProfileSpecVmSizeStandardD8SV3,
		HardwareProfileSpecVmSizeStandardD8V3,
		HardwareProfileSpecVmSizeStandardDS1,
		HardwareProfileSpecVmSizeStandardDS11,
		HardwareProfileSpecVmSizeStandardDS11V2,
		HardwareProfileSpecVmSizeStandardDS12,
		HardwareProfileSpecVmSizeStandardDS12V2,
		HardwareProfileSpecVmSizeStandardDS13,
		HardwareProfileSpecVmSizeStandardDS132V2,
		HardwareProfileSpecVmSizeStandardDS134V2,
		HardwareProfileSpecVmSizeStandardDS13V2,
		HardwareProfileSpecVmSizeStandardDS14,
		HardwareProfileSpecVmSizeStandardDS144V2,
		HardwareProfileSpecVmSizeStandardDS148V2,
		HardwareProfileSpecVmSizeStandardDS14V2,
		HardwareProfileSpecVmSizeStandardDS15V2,
		HardwareProfileSpecVmSizeStandardDS1V2,
		HardwareProfileSpecVmSizeStandardDS2,
		HardwareProfileSpecVmSizeStandardDS2V2,
		HardwareProfileSpecVmSizeStandardDS3,
		HardwareProfileSpecVmSizeStandardDS3V2,
		HardwareProfileSpecVmSizeStandardDS4,
		HardwareProfileSpecVmSizeStandardDS4V2,
		HardwareProfileSpecVmSizeStandardDS5V2,
		HardwareProfileSpecVmSizeStandardE16SV3,
		HardwareProfileSpecVmSizeStandardE16V3,
		HardwareProfileSpecVmSizeStandardE2SV3,
		HardwareProfileSpecVmSizeStandardE2V3,
		HardwareProfileSpecVmSizeStandardE3216V3,
		HardwareProfileSpecVmSizeStandardE328SV3,
		HardwareProfileSpecVmSizeStandardE32SV3,
		HardwareProfileSpecVmSizeStandardE32V3,
		HardwareProfileSpecVmSizeStandardE4SV3,
		HardwareProfileSpecVmSizeStandardE4V3,
		HardwareProfileSpecVmSizeStandardE6416SV3,
		HardwareProfileSpecVmSizeStandardE6432SV3,
		HardwareProfileSpecVmSizeStandardE64SV3,
		HardwareProfileSpecVmSizeStandardE64V3,
		HardwareProfileSpecVmSizeStandardE8SV3,
		HardwareProfileSpecVmSizeStandardE8V3,
		HardwareProfileSpecVmSizeStandardF1,
		HardwareProfileSpecVmSizeStandardF16,
		HardwareProfileSpecVmSizeStandardF16S,
		HardwareProfileSpecVmSizeStandardF16SV2,
		HardwareProfileSpecVmSizeStandardF1S,
		HardwareProfileSpecVmSizeStandardF2,
		HardwareProfileSpecVmSizeStandardF2S,
		HardwareProfileSpecVmSizeStandardF2SV2,
		HardwareProfileSpecVmSizeStandardF32SV2,
		HardwareProfileSpecVmSizeStandardF4,
		HardwareProfileSpecVmSizeStandardF4S,
		HardwareProfileSpecVmSizeStandardF4SV2,
		HardwareProfileSpecVmSizeStandardF64SV2,
		HardwareProfileSpecVmSizeStandardF72SV2,
		HardwareProfileSpecVmSizeStandardF8,
		HardwareProfileSpecVmSizeStandardF8S,
		HardwareProfileSpecVmSizeStandardF8SV2,
		HardwareProfileSpecVmSizeStandardG1,
		HardwareProfileSpecVmSizeStandardG2,
		HardwareProfileSpecVmSizeStandardG3,
		HardwareProfileSpecVmSizeStandardG4,
		HardwareProfileSpecVmSizeStandardG5,
		HardwareProfileSpecVmSizeStandardGS1,
		HardwareProfileSpecVmSizeStandardGS2,
		HardwareProfileSpecVmSizeStandardGS3,
		HardwareProfileSpecVmSizeStandardGS4,
		HardwareProfileSpecVmSizeStandardGS44,
		HardwareProfileSpecVmSizeStandardGS48,
		HardwareProfileSpecVmSizeStandardGS5,
		HardwareProfileSpecVmSizeStandardGS516,
		HardwareProfileSpecVmSizeStandardGS58,
		HardwareProfileSpecVmSizeStandardH16,
		HardwareProfileSpecVmSizeStandardH16M,
		HardwareProfileSpecVmSizeStandardH16Mr,
		HardwareProfileSpecVmSizeStandardH16R,
		HardwareProfileSpecVmSizeStandardH8,
		HardwareProfileSpecVmSizeStandardH8M,
		HardwareProfileSpecVmSizeStandardL16S,
		HardwareProfileSpecVmSizeStandardL32S,
		HardwareProfileSpecVmSizeStandardL4S,
		HardwareProfileSpecVmSizeStandardL8S,
		HardwareProfileSpecVmSizeStandardM12832Ms,
		HardwareProfileSpecVmSizeStandardM12864Ms,
		HardwareProfileSpecVmSizeStandardM128Ms,
		HardwareProfileSpecVmSizeStandardM128S,
		HardwareProfileSpecVmSizeStandardM6416Ms,
		HardwareProfileSpecVmSizeStandardM6432Ms,
		HardwareProfileSpecVmSizeStandardM64Ms,
		HardwareProfileSpecVmSizeStandardM64S,
		HardwareProfileSpecVmSizeStandardNC12,
		HardwareProfileSpecVmSizeStandardNC12SV2,
		HardwareProfileSpecVmSizeStandardNC12SV3,
		HardwareProfileSpecVmSizeStandardNC24,
		HardwareProfileSpecVmSizeStandardNC24R,
		HardwareProfileSpecVmSizeStandardNC24RsV2,
		HardwareProfileSpecVmSizeStandardNC24RsV3,
		HardwareProfileSpecVmSizeStandardNC24SV2,
		HardwareProfileSpecVmSizeStandardNC24SV3,
		HardwareProfileSpecVmSizeStandardNC6,
		HardwareProfileSpecVmSizeStandardNC6SV2,
		HardwareProfileSpecVmSizeStandardNC6SV3,
		HardwareProfileSpecVmSizeStandardND12S,
		HardwareProfileSpecVmSizeStandardND24Rs,
		HardwareProfileSpecVmSizeStandardND24S,
		HardwareProfileSpecVmSizeStandardND6S,
		HardwareProfileSpecVmSizeStandardNV12,
		HardwareProfileSpecVmSizeStandardNV24,
		HardwareProfileSpecVmSizeStandardNV6))
}

func Test_HardwareProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HardwareProfile_Status to HardwareProfile_Status via AssignPropertiesToHardwareProfileStatus & AssignPropertiesFromHardwareProfileStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForHardwareProfileStatus, HardwareProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHardwareProfileStatus tests if a specific instance of HardwareProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForHardwareProfileStatus(subject HardwareProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.HardwareProfile_Status
	err := copied.AssignPropertiesToHardwareProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HardwareProfile_Status
	err = actual.AssignPropertiesFromHardwareProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HardwareProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileStatus, HardwareProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileStatus runs a test to see if a specific instance of HardwareProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileStatus(subject HardwareProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Status instances for property testing - lazily instantiated by
//HardwareProfileStatusGenerator()
var hardwareProfileStatusGenerator gopter.Gen

// HardwareProfileStatusGenerator returns a generator of HardwareProfile_Status instances for property testing.
func HardwareProfileStatusGenerator() gopter.Gen {
	if hardwareProfileStatusGenerator != nil {
		return hardwareProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileStatus(generators)
	hardwareProfileStatusGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Status{}), generators)

	return hardwareProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileStatus(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfileStatusVmSizeBasicA0,
		HardwareProfileStatusVmSizeBasicA1,
		HardwareProfileStatusVmSizeBasicA2,
		HardwareProfileStatusVmSizeBasicA3,
		HardwareProfileStatusVmSizeBasicA4,
		HardwareProfileStatusVmSizeStandardA0,
		HardwareProfileStatusVmSizeStandardA1,
		HardwareProfileStatusVmSizeStandardA10,
		HardwareProfileStatusVmSizeStandardA11,
		HardwareProfileStatusVmSizeStandardA1V2,
		HardwareProfileStatusVmSizeStandardA2,
		HardwareProfileStatusVmSizeStandardA2MV2,
		HardwareProfileStatusVmSizeStandardA2V2,
		HardwareProfileStatusVmSizeStandardA3,
		HardwareProfileStatusVmSizeStandardA4,
		HardwareProfileStatusVmSizeStandardA4MV2,
		HardwareProfileStatusVmSizeStandardA4V2,
		HardwareProfileStatusVmSizeStandardA5,
		HardwareProfileStatusVmSizeStandardA6,
		HardwareProfileStatusVmSizeStandardA7,
		HardwareProfileStatusVmSizeStandardA8,
		HardwareProfileStatusVmSizeStandardA8MV2,
		HardwareProfileStatusVmSizeStandardA8V2,
		HardwareProfileStatusVmSizeStandardA9,
		HardwareProfileStatusVmSizeStandardB1Ms,
		HardwareProfileStatusVmSizeStandardB1S,
		HardwareProfileStatusVmSizeStandardB2Ms,
		HardwareProfileStatusVmSizeStandardB2S,
		HardwareProfileStatusVmSizeStandardB4Ms,
		HardwareProfileStatusVmSizeStandardB8Ms,
		HardwareProfileStatusVmSizeStandardD1,
		HardwareProfileStatusVmSizeStandardD11,
		HardwareProfileStatusVmSizeStandardD11V2,
		HardwareProfileStatusVmSizeStandardD12,
		HardwareProfileStatusVmSizeStandardD12V2,
		HardwareProfileStatusVmSizeStandardD13,
		HardwareProfileStatusVmSizeStandardD13V2,
		HardwareProfileStatusVmSizeStandardD14,
		HardwareProfileStatusVmSizeStandardD14V2,
		HardwareProfileStatusVmSizeStandardD15V2,
		HardwareProfileStatusVmSizeStandardD16SV3,
		HardwareProfileStatusVmSizeStandardD16V3,
		HardwareProfileStatusVmSizeStandardD1V2,
		HardwareProfileStatusVmSizeStandardD2,
		HardwareProfileStatusVmSizeStandardD2SV3,
		HardwareProfileStatusVmSizeStandardD2V2,
		HardwareProfileStatusVmSizeStandardD2V3,
		HardwareProfileStatusVmSizeStandardD3,
		HardwareProfileStatusVmSizeStandardD32SV3,
		HardwareProfileStatusVmSizeStandardD32V3,
		HardwareProfileStatusVmSizeStandardD3V2,
		HardwareProfileStatusVmSizeStandardD4,
		HardwareProfileStatusVmSizeStandardD4SV3,
		HardwareProfileStatusVmSizeStandardD4V2,
		HardwareProfileStatusVmSizeStandardD4V3,
		HardwareProfileStatusVmSizeStandardD5V2,
		HardwareProfileStatusVmSizeStandardD64SV3,
		HardwareProfileStatusVmSizeStandardD64V3,
		HardwareProfileStatusVmSizeStandardD8SV3,
		HardwareProfileStatusVmSizeStandardD8V3,
		HardwareProfileStatusVmSizeStandardDS1,
		HardwareProfileStatusVmSizeStandardDS11,
		HardwareProfileStatusVmSizeStandardDS11V2,
		HardwareProfileStatusVmSizeStandardDS12,
		HardwareProfileStatusVmSizeStandardDS12V2,
		HardwareProfileStatusVmSizeStandardDS13,
		HardwareProfileStatusVmSizeStandardDS132V2,
		HardwareProfileStatusVmSizeStandardDS134V2,
		HardwareProfileStatusVmSizeStandardDS13V2,
		HardwareProfileStatusVmSizeStandardDS14,
		HardwareProfileStatusVmSizeStandardDS144V2,
		HardwareProfileStatusVmSizeStandardDS148V2,
		HardwareProfileStatusVmSizeStandardDS14V2,
		HardwareProfileStatusVmSizeStandardDS15V2,
		HardwareProfileStatusVmSizeStandardDS1V2,
		HardwareProfileStatusVmSizeStandardDS2,
		HardwareProfileStatusVmSizeStandardDS2V2,
		HardwareProfileStatusVmSizeStandardDS3,
		HardwareProfileStatusVmSizeStandardDS3V2,
		HardwareProfileStatusVmSizeStandardDS4,
		HardwareProfileStatusVmSizeStandardDS4V2,
		HardwareProfileStatusVmSizeStandardDS5V2,
		HardwareProfileStatusVmSizeStandardE16SV3,
		HardwareProfileStatusVmSizeStandardE16V3,
		HardwareProfileStatusVmSizeStandardE2SV3,
		HardwareProfileStatusVmSizeStandardE2V3,
		HardwareProfileStatusVmSizeStandardE3216V3,
		HardwareProfileStatusVmSizeStandardE328SV3,
		HardwareProfileStatusVmSizeStandardE32SV3,
		HardwareProfileStatusVmSizeStandardE32V3,
		HardwareProfileStatusVmSizeStandardE4SV3,
		HardwareProfileStatusVmSizeStandardE4V3,
		HardwareProfileStatusVmSizeStandardE6416SV3,
		HardwareProfileStatusVmSizeStandardE6432SV3,
		HardwareProfileStatusVmSizeStandardE64SV3,
		HardwareProfileStatusVmSizeStandardE64V3,
		HardwareProfileStatusVmSizeStandardE8SV3,
		HardwareProfileStatusVmSizeStandardE8V3,
		HardwareProfileStatusVmSizeStandardF1,
		HardwareProfileStatusVmSizeStandardF16,
		HardwareProfileStatusVmSizeStandardF16S,
		HardwareProfileStatusVmSizeStandardF16SV2,
		HardwareProfileStatusVmSizeStandardF1S,
		HardwareProfileStatusVmSizeStandardF2,
		HardwareProfileStatusVmSizeStandardF2S,
		HardwareProfileStatusVmSizeStandardF2SV2,
		HardwareProfileStatusVmSizeStandardF32SV2,
		HardwareProfileStatusVmSizeStandardF4,
		HardwareProfileStatusVmSizeStandardF4S,
		HardwareProfileStatusVmSizeStandardF4SV2,
		HardwareProfileStatusVmSizeStandardF64SV2,
		HardwareProfileStatusVmSizeStandardF72SV2,
		HardwareProfileStatusVmSizeStandardF8,
		HardwareProfileStatusVmSizeStandardF8S,
		HardwareProfileStatusVmSizeStandardF8SV2,
		HardwareProfileStatusVmSizeStandardG1,
		HardwareProfileStatusVmSizeStandardG2,
		HardwareProfileStatusVmSizeStandardG3,
		HardwareProfileStatusVmSizeStandardG4,
		HardwareProfileStatusVmSizeStandardG5,
		HardwareProfileStatusVmSizeStandardGS1,
		HardwareProfileStatusVmSizeStandardGS2,
		HardwareProfileStatusVmSizeStandardGS3,
		HardwareProfileStatusVmSizeStandardGS4,
		HardwareProfileStatusVmSizeStandardGS44,
		HardwareProfileStatusVmSizeStandardGS48,
		HardwareProfileStatusVmSizeStandardGS5,
		HardwareProfileStatusVmSizeStandardGS516,
		HardwareProfileStatusVmSizeStandardGS58,
		HardwareProfileStatusVmSizeStandardH16,
		HardwareProfileStatusVmSizeStandardH16M,
		HardwareProfileStatusVmSizeStandardH16Mr,
		HardwareProfileStatusVmSizeStandardH16R,
		HardwareProfileStatusVmSizeStandardH8,
		HardwareProfileStatusVmSizeStandardH8M,
		HardwareProfileStatusVmSizeStandardL16S,
		HardwareProfileStatusVmSizeStandardL32S,
		HardwareProfileStatusVmSizeStandardL4S,
		HardwareProfileStatusVmSizeStandardL8S,
		HardwareProfileStatusVmSizeStandardM12832Ms,
		HardwareProfileStatusVmSizeStandardM12864Ms,
		HardwareProfileStatusVmSizeStandardM128Ms,
		HardwareProfileStatusVmSizeStandardM128S,
		HardwareProfileStatusVmSizeStandardM6416Ms,
		HardwareProfileStatusVmSizeStandardM6432Ms,
		HardwareProfileStatusVmSizeStandardM64Ms,
		HardwareProfileStatusVmSizeStandardM64S,
		HardwareProfileStatusVmSizeStandardNC12,
		HardwareProfileStatusVmSizeStandardNC12SV2,
		HardwareProfileStatusVmSizeStandardNC12SV3,
		HardwareProfileStatusVmSizeStandardNC24,
		HardwareProfileStatusVmSizeStandardNC24R,
		HardwareProfileStatusVmSizeStandardNC24RsV2,
		HardwareProfileStatusVmSizeStandardNC24RsV3,
		HardwareProfileStatusVmSizeStandardNC24SV2,
		HardwareProfileStatusVmSizeStandardNC24SV3,
		HardwareProfileStatusVmSizeStandardNC6,
		HardwareProfileStatusVmSizeStandardNC6SV2,
		HardwareProfileStatusVmSizeStandardNC6SV3,
		HardwareProfileStatusVmSizeStandardND12S,
		HardwareProfileStatusVmSizeStandardND24Rs,
		HardwareProfileStatusVmSizeStandardND24S,
		HardwareProfileStatusVmSizeStandardND6S,
		HardwareProfileStatusVmSizeStandardNV12,
		HardwareProfileStatusVmSizeStandardNV24,
		HardwareProfileStatusVmSizeStandardNV6))
}

func Test_NetworkProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkProfile_Spec to NetworkProfile_Spec via AssignPropertiesToNetworkProfileSpec & AssignPropertiesFromNetworkProfileSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkProfileSpec, NetworkProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkProfileSpec tests if a specific instance of NetworkProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForNetworkProfileSpec(subject NetworkProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.NetworkProfile_Spec
	err := copied.AssignPropertiesToNetworkProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkProfile_Spec
	err = actual.AssignPropertiesFromNetworkProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileSpec, NetworkProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileSpec runs a test to see if a specific instance of NetworkProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileSpec(subject NetworkProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Spec instances for property testing - lazily instantiated by NetworkProfileSpecGenerator()
var networkProfileSpecGenerator gopter.Gen

// NetworkProfileSpecGenerator returns a generator of NetworkProfile_Spec instances for property testing.
func NetworkProfileSpecGenerator() gopter.Gen {
	if networkProfileSpecGenerator != nil {
		return networkProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfileSpec(generators)
	networkProfileSpecGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Spec{}), generators)

	return networkProfileSpecGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileSpec(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceSpecGenerator())
}

func Test_NetworkProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkProfile_Status to NetworkProfile_Status via AssignPropertiesToNetworkProfileStatus & AssignPropertiesFromNetworkProfileStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkProfileStatus, NetworkProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkProfileStatus tests if a specific instance of NetworkProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForNetworkProfileStatus(subject NetworkProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.NetworkProfile_Status
	err := copied.AssignPropertiesToNetworkProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkProfile_Status
	err = actual.AssignPropertiesFromNetworkProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileStatus, NetworkProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileStatus runs a test to see if a specific instance of NetworkProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileStatus(subject NetworkProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Status instances for property testing - lazily instantiated by
//NetworkProfileStatusGenerator()
var networkProfileStatusGenerator gopter.Gen

// NetworkProfileStatusGenerator returns a generator of NetworkProfile_Status instances for property testing.
func NetworkProfileStatusGenerator() gopter.Gen {
	if networkProfileStatusGenerator != nil {
		return networkProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfileStatus(generators)
	networkProfileStatusGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Status{}), generators)

	return networkProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileStatus(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceStatusGenerator())
}

func Test_OSProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OSProfile_Spec to OSProfile_Spec via AssignPropertiesToOSProfileSpec & AssignPropertiesFromOSProfileSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForOSProfileSpec, OSProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOSProfileSpec tests if a specific instance of OSProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForOSProfileSpec(subject OSProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.OSProfile_Spec
	err := copied.AssignPropertiesToOSProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OSProfile_Spec
	err = actual.AssignPropertiesFromOSProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OSProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileSpec, OSProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileSpec runs a test to see if a specific instance of OSProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileSpec(subject OSProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Spec instances for property testing - lazily instantiated by OSProfileSpecGenerator()
var osProfileSpecGenerator gopter.Gen

// OSProfileSpecGenerator returns a generator of OSProfile_Spec instances for property testing.
// We first initialize osProfileSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileSpecGenerator() gopter.Gen {
	if osProfileSpecGenerator != nil {
		return osProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileSpec(generators)
	osProfileSpecGenerator = gen.Struct(reflect.TypeOf(OSProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileSpec(generators)
	AddRelatedPropertyGeneratorsForOSProfileSpec(generators)
	osProfileSpecGenerator = gen.Struct(reflect.TypeOf(OSProfile_Spec{}), generators)

	return osProfileSpecGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileSpec(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileSpec(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationSpecGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupSpecGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationSpecGenerator())
}

func Test_OSProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OSProfile_Status to OSProfile_Status via AssignPropertiesToOSProfileStatus & AssignPropertiesFromOSProfileStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForOSProfileStatus, OSProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOSProfileStatus tests if a specific instance of OSProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForOSProfileStatus(subject OSProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.OSProfile_Status
	err := copied.AssignPropertiesToOSProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OSProfile_Status
	err = actual.AssignPropertiesFromOSProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OSProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileStatus, OSProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileStatus runs a test to see if a specific instance of OSProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileStatus(subject OSProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Status instances for property testing - lazily instantiated by OSProfileStatusGenerator()
var osProfileStatusGenerator gopter.Gen

// OSProfileStatusGenerator returns a generator of OSProfile_Status instances for property testing.
// We first initialize osProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileStatusGenerator() gopter.Gen {
	if osProfileStatusGenerator != nil {
		return osProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileStatus(generators)
	osProfileStatusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileStatus(generators)
	AddRelatedPropertyGeneratorsForOSProfileStatus(generators)
	osProfileStatusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	return osProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileStatus(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileStatus(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationStatusGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupStatusGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationStatusGenerator())
}

func Test_Plan_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Plan_Spec to Plan_Spec via AssignPropertiesToPlanSpec & AssignPropertiesFromPlanSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlanSpec, PlanSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlanSpec tests if a specific instance of Plan_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForPlanSpec(subject Plan_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.Plan_Spec
	err := copied.AssignPropertiesToPlanSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Plan_Spec
	err = actual.AssignPropertiesFromPlanSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Plan_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlanSpec, PlanSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlanSpec runs a test to see if a specific instance of Plan_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPlanSpec(subject Plan_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Spec instances for property testing - lazily instantiated by PlanSpecGenerator()
var planSpecGenerator gopter.Gen

// PlanSpecGenerator returns a generator of Plan_Spec instances for property testing.
func PlanSpecGenerator() gopter.Gen {
	if planSpecGenerator != nil {
		return planSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlanSpec(generators)
	planSpecGenerator = gen.Struct(reflect.TypeOf(Plan_Spec{}), generators)

	return planSpecGenerator
}

// AddIndependentPropertyGeneratorsForPlanSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlanSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_Plan_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Plan_Status to Plan_Status via AssignPropertiesToPlanStatus & AssignPropertiesFromPlanStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlanStatus, PlanStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlanStatus tests if a specific instance of Plan_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForPlanStatus(subject Plan_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.Plan_Status
	err := copied.AssignPropertiesToPlanStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Plan_Status
	err = actual.AssignPropertiesFromPlanStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Plan_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlanStatus, PlanStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlanStatus runs a test to see if a specific instance of Plan_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPlanStatus(subject Plan_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Status instances for property testing - lazily instantiated by PlanStatusGenerator()
var planStatusGenerator gopter.Gen

// PlanStatusGenerator returns a generator of Plan_Status instances for property testing.
func PlanStatusGenerator() gopter.Gen {
	if planStatusGenerator != nil {
		return planStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlanStatus(generators)
	planStatusGenerator = gen.Struct(reflect.TypeOf(Plan_Status{}), generators)

	return planStatusGenerator
}

// AddIndependentPropertyGeneratorsForPlanStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlanStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecurityProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecurityProfile_Spec to SecurityProfile_Spec via AssignPropertiesToSecurityProfileSpec & AssignPropertiesFromSecurityProfileSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecurityProfileSpec, SecurityProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecurityProfileSpec tests if a specific instance of SecurityProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSecurityProfileSpec(subject SecurityProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SecurityProfile_Spec
	err := copied.AssignPropertiesToSecurityProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecurityProfile_Spec
	err = actual.AssignPropertiesFromSecurityProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecurityProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileSpec, SecurityProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileSpec runs a test to see if a specific instance of SecurityProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileSpec(subject SecurityProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Spec instances for property testing - lazily instantiated by
//SecurityProfileSpecGenerator()
var securityProfileSpecGenerator gopter.Gen

// SecurityProfileSpecGenerator returns a generator of SecurityProfile_Spec instances for property testing.
// We first initialize securityProfileSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileSpecGenerator() gopter.Gen {
	if securityProfileSpecGenerator != nil {
		return securityProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileSpec(generators)
	securityProfileSpecGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileSpec(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileSpec(generators)
	securityProfileSpecGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Spec{}), generators)

	return securityProfileSpecGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileSpec(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfileSpecSecurityTypeTrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileSpec(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsSpecGenerator())
}

func Test_SecurityProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecurityProfile_Status to SecurityProfile_Status via AssignPropertiesToSecurityProfileStatus & AssignPropertiesFromSecurityProfileStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecurityProfileStatus, SecurityProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecurityProfileStatus tests if a specific instance of SecurityProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSecurityProfileStatus(subject SecurityProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SecurityProfile_Status
	err := copied.AssignPropertiesToSecurityProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecurityProfile_Status
	err = actual.AssignPropertiesFromSecurityProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecurityProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileStatus, SecurityProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileStatus runs a test to see if a specific instance of SecurityProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileStatus(subject SecurityProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Status instances for property testing - lazily instantiated by
//SecurityProfileStatusGenerator()
var securityProfileStatusGenerator gopter.Gen

// SecurityProfileStatusGenerator returns a generator of SecurityProfile_Status instances for property testing.
// We first initialize securityProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileStatusGenerator() gopter.Gen {
	if securityProfileStatusGenerator != nil {
		return securityProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileStatus(generators)
	securityProfileStatusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileStatus(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileStatus(generators)
	securityProfileStatusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	return securityProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileStatus(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfileStatusSecurityTypeTrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileStatus(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsStatusGenerator())
}

func Test_StorageProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageProfile_Spec to StorageProfile_Spec via AssignPropertiesToStorageProfileSpec & AssignPropertiesFromStorageProfileSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageProfileSpec, StorageProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageProfileSpec tests if a specific instance of StorageProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForStorageProfileSpec(subject StorageProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.StorageProfile_Spec
	err := copied.AssignPropertiesToStorageProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageProfile_Spec
	err = actual.AssignPropertiesFromStorageProfileSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileSpec, StorageProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileSpec runs a test to see if a specific instance of StorageProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileSpec(subject StorageProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Spec instances for property testing - lazily instantiated by StorageProfileSpecGenerator()
var storageProfileSpecGenerator gopter.Gen

// StorageProfileSpecGenerator returns a generator of StorageProfile_Spec instances for property testing.
func StorageProfileSpecGenerator() gopter.Gen {
	if storageProfileSpecGenerator != nil {
		return storageProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileSpec(generators)
	storageProfileSpecGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Spec{}), generators)

	return storageProfileSpecGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileSpec(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskSpecGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceSpecGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskSpecGenerator())
}

func Test_StorageProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageProfile_Status to StorageProfile_Status via AssignPropertiesToStorageProfileStatus & AssignPropertiesFromStorageProfileStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageProfileStatus, StorageProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageProfileStatus tests if a specific instance of StorageProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForStorageProfileStatus(subject StorageProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.StorageProfile_Status
	err := copied.AssignPropertiesToStorageProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageProfile_Status
	err = actual.AssignPropertiesFromStorageProfileStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileStatus, StorageProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileStatus runs a test to see if a specific instance of StorageProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileStatus(subject StorageProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Status instances for property testing - lazily instantiated by
//StorageProfileStatusGenerator()
var storageProfileStatusGenerator gopter.Gen

// StorageProfileStatusGenerator returns a generator of StorageProfile_Status instances for property testing.
func StorageProfileStatusGenerator() gopter.Gen {
	if storageProfileStatusGenerator != nil {
		return storageProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileStatus(generators)
	storageProfileStatusGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Status{}), generators)

	return storageProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileStatus(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskStatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceStatusGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskStatusGenerator())
}

func Test_SubResource_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_Spec to SubResource_Spec via AssignPropertiesToSubResourceSpec & AssignPropertiesFromSubResourceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResourceSpec, SubResourceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResourceSpec tests if a specific instance of SubResource_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSubResourceSpec(subject SubResource_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SubResource_Spec
	err := copied.AssignPropertiesToSubResourceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_Spec
	err = actual.AssignPropertiesFromSubResourceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResourceSpec, SubResourceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResourceSpec runs a test to see if a specific instance of SubResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResourceSpec(subject SubResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Spec instances for property testing - lazily instantiated by SubResourceSpecGenerator()
var subResourceSpecGenerator gopter.Gen

// SubResourceSpecGenerator returns a generator of SubResource_Spec instances for property testing.
func SubResourceSpecGenerator() gopter.Gen {
	if subResourceSpecGenerator != nil {
		return subResourceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResourceSpecGenerator = gen.Struct(reflect.TypeOf(SubResource_Spec{}), generators)

	return subResourceSpecGenerator
}

func Test_SubResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_Status to SubResource_Status via AssignPropertiesToSubResourceStatus & AssignPropertiesFromSubResourceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResourceStatus, SubResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResourceStatus tests if a specific instance of SubResource_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSubResourceStatus(subject SubResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SubResource_Status
	err := copied.AssignPropertiesToSubResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_Status
	err = actual.AssignPropertiesFromSubResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResourceStatus, SubResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResourceStatus runs a test to see if a specific instance of SubResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResourceStatus(subject SubResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Status instances for property testing - lazily instantiated by SubResourceStatusGenerator()
var subResourceStatusGenerator gopter.Gen

// SubResourceStatusGenerator returns a generator of SubResource_Status instances for property testing.
func SubResourceStatusGenerator() gopter.Gen {
	if subResourceStatusGenerator != nil {
		return subResourceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResourceStatus(generators)
	subResourceStatusGenerator = gen.Struct(reflect.TypeOf(SubResource_Status{}), generators)

	return subResourceStatusGenerator
}

// AddIndependentPropertyGeneratorsForSubResourceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResourceStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtension_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineExtension_Status to VirtualMachineExtension_Status via AssignPropertiesToVirtualMachineExtensionStatus & AssignPropertiesFromVirtualMachineExtensionStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineExtensionStatus, VirtualMachineExtensionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineExtensionStatus tests if a specific instance of VirtualMachineExtension_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineExtensionStatus(subject VirtualMachineExtension_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineExtension_Status
	err := copied.AssignPropertiesToVirtualMachineExtensionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineExtension_Status
	err = actual.AssignPropertiesFromVirtualMachineExtensionStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineExtension_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtension_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionStatus, VirtualMachineExtensionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionStatus runs a test to see if a specific instance of VirtualMachineExtension_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionStatus(subject VirtualMachineExtension_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtension_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtension_Status instances for property testing - lazily instantiated by
//VirtualMachineExtensionStatusGenerator()
var virtualMachineExtensionStatusGenerator gopter.Gen

// VirtualMachineExtensionStatusGenerator returns a generator of VirtualMachineExtension_Status instances for property testing.
// We first initialize virtualMachineExtensionStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionStatusGenerator() gopter.Gen {
	if virtualMachineExtensionStatusGenerator != nil {
		return virtualMachineExtensionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	virtualMachineExtensionStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	virtualMachineExtensionStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	return virtualMachineExtensionStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["ForceUpdateTag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus(gens map[string]gopter.Gen) {
	gens["InstanceView"] = gen.PtrOf(VirtualMachineExtensionInstanceViewStatusGenerator())
}

func Test_VirtualMachineIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineIdentity_Spec to VirtualMachineIdentity_Spec via AssignPropertiesToVirtualMachineIdentitySpec & AssignPropertiesFromVirtualMachineIdentitySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineIdentitySpec, VirtualMachineIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineIdentitySpec tests if a specific instance of VirtualMachineIdentity_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineIdentitySpec(subject VirtualMachineIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineIdentity_Spec
	err := copied.AssignPropertiesToVirtualMachineIdentitySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineIdentity_Spec
	err = actual.AssignPropertiesFromVirtualMachineIdentitySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentitySpec, VirtualMachineIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentitySpec runs a test to see if a specific instance of VirtualMachineIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentitySpec(subject VirtualMachineIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Spec instances for property testing - lazily instantiated by
//VirtualMachineIdentitySpecGenerator()
var virtualMachineIdentitySpecGenerator gopter.Gen

// VirtualMachineIdentitySpecGenerator returns a generator of VirtualMachineIdentity_Spec instances for property testing.
func VirtualMachineIdentitySpecGenerator() gopter.Gen {
	if virtualMachineIdentitySpecGenerator != nil {
		return virtualMachineIdentitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpec(generators)
	virtualMachineIdentitySpecGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Spec{}), generators)

	return virtualMachineIdentitySpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentitySpecTypeNone,
		VirtualMachineIdentitySpecTypeSystemAssigned,
		VirtualMachineIdentitySpecTypeSystemAssignedUserAssigned,
		VirtualMachineIdentitySpecTypeUserAssigned))
}

func Test_VirtualMachineIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineIdentity_Status to VirtualMachineIdentity_Status via AssignPropertiesToVirtualMachineIdentityStatus & AssignPropertiesFromVirtualMachineIdentityStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineIdentityStatus, VirtualMachineIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineIdentityStatus tests if a specific instance of VirtualMachineIdentity_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineIdentityStatus(subject VirtualMachineIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineIdentity_Status
	err := copied.AssignPropertiesToVirtualMachineIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineIdentity_Status
	err = actual.AssignPropertiesFromVirtualMachineIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityStatus, VirtualMachineIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityStatus runs a test to see if a specific instance of VirtualMachineIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityStatus(subject VirtualMachineIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Status instances for property testing - lazily instantiated by
//VirtualMachineIdentityStatusGenerator()
var virtualMachineIdentityStatusGenerator gopter.Gen

// VirtualMachineIdentityStatusGenerator returns a generator of VirtualMachineIdentity_Status instances for property testing.
// We first initialize virtualMachineIdentityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineIdentityStatusGenerator() gopter.Gen {
	if virtualMachineIdentityStatusGenerator != nil {
		return virtualMachineIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus(generators)
	virtualMachineIdentityStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineIdentityStatus(generators)
	virtualMachineIdentityStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	return virtualMachineIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentityStatusTypeNone,
		VirtualMachineIdentityStatusTypeSystemAssigned,
		VirtualMachineIdentityStatusTypeSystemAssignedUserAssigned,
		VirtualMachineIdentityStatusTypeUserAssigned))
}

// AddRelatedPropertyGeneratorsForVirtualMachineIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator())
}

func Test_VirtualMachineInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineInstanceView_Status to VirtualMachineInstanceView_Status via AssignPropertiesToVirtualMachineInstanceViewStatus & AssignPropertiesFromVirtualMachineInstanceViewStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineInstanceViewStatus, VirtualMachineInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineInstanceViewStatus tests if a specific instance of VirtualMachineInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineInstanceViewStatus(subject VirtualMachineInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineInstanceView_Status
	err := copied.AssignPropertiesToVirtualMachineInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineInstanceView_Status
	err = actual.AssignPropertiesFromVirtualMachineInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceViewStatus, VirtualMachineInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceViewStatus runs a test to see if a specific instance of VirtualMachineInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceViewStatus(subject VirtualMachineInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineInstanceViewStatusGenerator()
var virtualMachineInstanceViewStatusGenerator gopter.Gen

// VirtualMachineInstanceViewStatusGenerator returns a generator of VirtualMachineInstanceView_Status instances for property testing.
// We first initialize virtualMachineInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineInstanceViewStatusGenerator != nil {
		return virtualMachineInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	virtualMachineInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	virtualMachineInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	return virtualMachineInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(VirtualMachineInstanceViewStatusHyperVGenerationV1, VirtualMachineInstanceViewStatusHyperVGenerationV2))
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceViewStatusGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceViewStatusGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceViewStatusGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatusStatusGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatusStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceViewStatusGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatusStatusGenerator())
}

func Test_BootDiagnosticsInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BootDiagnosticsInstanceView_Status to BootDiagnosticsInstanceView_Status via AssignPropertiesToBootDiagnosticsInstanceViewStatus & AssignPropertiesFromBootDiagnosticsInstanceViewStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForBootDiagnosticsInstanceViewStatus, BootDiagnosticsInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBootDiagnosticsInstanceViewStatus tests if a specific instance of BootDiagnosticsInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBootDiagnosticsInstanceViewStatus(subject BootDiagnosticsInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BootDiagnosticsInstanceView_Status
	err := copied.AssignPropertiesToBootDiagnosticsInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BootDiagnosticsInstanceView_Status
	err = actual.AssignPropertiesFromBootDiagnosticsInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BootDiagnosticsInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus, BootDiagnosticsInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus runs a test to see if a specific instance of BootDiagnosticsInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus(subject BootDiagnosticsInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceView_Status instances for property testing - lazily instantiated by
//BootDiagnosticsInstanceViewStatusGenerator()
var bootDiagnosticsInstanceViewStatusGenerator gopter.Gen

// BootDiagnosticsInstanceViewStatusGenerator returns a generator of BootDiagnosticsInstanceView_Status instances for property testing.
// We first initialize bootDiagnosticsInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceViewStatusGenerator() gopter.Gen {
	if bootDiagnosticsInstanceViewStatusGenerator != nil {
		return bootDiagnosticsInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	bootDiagnosticsInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	bootDiagnosticsInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	return bootDiagnosticsInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_BootDiagnostics_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BootDiagnostics_Spec to BootDiagnostics_Spec via AssignPropertiesToBootDiagnosticsSpec & AssignPropertiesFromBootDiagnosticsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBootDiagnosticsSpec, BootDiagnosticsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBootDiagnosticsSpec tests if a specific instance of BootDiagnostics_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBootDiagnosticsSpec(subject BootDiagnostics_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BootDiagnostics_Spec
	err := copied.AssignPropertiesToBootDiagnosticsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BootDiagnostics_Spec
	err = actual.AssignPropertiesFromBootDiagnosticsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BootDiagnostics_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsSpec, BootDiagnosticsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsSpec runs a test to see if a specific instance of BootDiagnostics_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsSpec(subject BootDiagnostics_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Spec instances for property testing - lazily instantiated by
//BootDiagnosticsSpecGenerator()
var bootDiagnosticsSpecGenerator gopter.Gen

// BootDiagnosticsSpecGenerator returns a generator of BootDiagnostics_Spec instances for property testing.
func BootDiagnosticsSpecGenerator() gopter.Gen {
	if bootDiagnosticsSpecGenerator != nil {
		return bootDiagnosticsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsSpec(generators)
	bootDiagnosticsSpecGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Spec{}), generators)

	return bootDiagnosticsSpecGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsSpec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_BootDiagnostics_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BootDiagnostics_Status to BootDiagnostics_Status via AssignPropertiesToBootDiagnosticsStatus & AssignPropertiesFromBootDiagnosticsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForBootDiagnosticsStatus, BootDiagnosticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBootDiagnosticsStatus tests if a specific instance of BootDiagnostics_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBootDiagnosticsStatus(subject BootDiagnostics_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BootDiagnostics_Status
	err := copied.AssignPropertiesToBootDiagnosticsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BootDiagnostics_Status
	err = actual.AssignPropertiesFromBootDiagnosticsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BootDiagnostics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsStatus, BootDiagnosticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsStatus runs a test to see if a specific instance of BootDiagnostics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsStatus(subject BootDiagnostics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Status instances for property testing - lazily instantiated by
//BootDiagnosticsStatusGenerator()
var bootDiagnosticsStatusGenerator gopter.Gen

// BootDiagnosticsStatusGenerator returns a generator of BootDiagnostics_Status instances for property testing.
func BootDiagnosticsStatusGenerator() gopter.Gen {
	if bootDiagnosticsStatusGenerator != nil {
		return bootDiagnosticsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsStatus(generators)
	bootDiagnosticsStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Status{}), generators)

	return bootDiagnosticsStatusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataDisk_Spec to DataDisk_Spec via AssignPropertiesToDataDiskSpec & AssignPropertiesFromDataDiskSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataDiskSpec, DataDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataDiskSpec tests if a specific instance of DataDisk_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDataDiskSpec(subject DataDisk_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DataDisk_Spec
	err := copied.AssignPropertiesToDataDiskSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataDisk_Spec
	err = actual.AssignPropertiesFromDataDiskSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskSpec, DataDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskSpec runs a test to see if a specific instance of DataDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskSpec(subject DataDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Spec instances for property testing - lazily instantiated by DataDiskSpecGenerator()
var dataDiskSpecGenerator gopter.Gen

// DataDiskSpecGenerator returns a generator of DataDisk_Spec instances for property testing.
// We first initialize dataDiskSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskSpecGenerator() gopter.Gen {
	if dataDiskSpecGenerator != nil {
		return dataDiskSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskSpec(generators)
	dataDiskSpecGenerator = gen.Struct(reflect.TypeOf(DataDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskSpec(generators)
	AddRelatedPropertyGeneratorsForDataDiskSpec(generators)
	dataDiskSpecGenerator = gen.Struct(reflect.TypeOf(DataDisk_Spec{}), generators)

	return dataDiskSpecGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskSpec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_SpecForceDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskSpec(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskSpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersSpecGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskSpecGenerator())
}

func Test_DataDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataDisk_Status to DataDisk_Status via AssignPropertiesToDataDiskStatus & AssignPropertiesFromDataDiskStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataDiskStatus, DataDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataDiskStatus tests if a specific instance of DataDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDataDiskStatus(subject DataDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DataDisk_Status
	err := copied.AssignPropertiesToDataDiskStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataDisk_Status
	err = actual.AssignPropertiesFromDataDiskStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskStatus, DataDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskStatus runs a test to see if a specific instance of DataDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskStatus(subject DataDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Status instances for property testing - lazily instantiated by DataDiskStatusGenerator()
var dataDiskStatusGenerator gopter.Gen

// DataDiskStatusGenerator returns a generator of DataDisk_Status instances for property testing.
// We first initialize dataDiskStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskStatusGenerator() gopter.Gen {
	if dataDiskStatusGenerator != nil {
		return dataDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskStatus(generators)
	dataDiskStatusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskStatus(generators)
	AddRelatedPropertyGeneratorsForDataDiskStatus(generators)
	dataDiskStatusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	return dataDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskStatus(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_StatusNone, Caching_StatusReadOnly, Caching_StatusReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_StatusAttach, CreateOption_StatusEmpty, CreateOption_StatusFromImage)
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_StatusForceDetach))
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskStatus(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersStatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
}

func Test_DiskInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiskInstanceView_Status to DiskInstanceView_Status via AssignPropertiesToDiskInstanceViewStatus & AssignPropertiesFromDiskInstanceViewStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiskInstanceViewStatus, DiskInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiskInstanceViewStatus tests if a specific instance of DiskInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiskInstanceViewStatus(subject DiskInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiskInstanceView_Status
	err := copied.AssignPropertiesToDiskInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiskInstanceView_Status
	err = actual.AssignPropertiesFromDiskInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiskInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceViewStatus, DiskInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceViewStatus runs a test to see if a specific instance of DiskInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceViewStatus(subject DiskInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceView_Status instances for property testing - lazily instantiated by
//DiskInstanceViewStatusGenerator()
var diskInstanceViewStatusGenerator gopter.Gen

// DiskInstanceViewStatusGenerator returns a generator of DiskInstanceView_Status instances for property testing.
// We first initialize diskInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceViewStatusGenerator() gopter.Gen {
	if diskInstanceViewStatusGenerator != nil {
		return diskInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(generators)
	diskInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceViewStatus(generators)
	diskInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	return diskInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettingsStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_ImageReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ImageReference_Spec to ImageReference_Spec via AssignPropertiesToImageReferenceSpec & AssignPropertiesFromImageReferenceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForImageReferenceSpec, ImageReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForImageReferenceSpec tests if a specific instance of ImageReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForImageReferenceSpec(subject ImageReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ImageReference_Spec
	err := copied.AssignPropertiesToImageReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ImageReference_Spec
	err = actual.AssignPropertiesFromImageReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ImageReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceSpec, ImageReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceSpec runs a test to see if a specific instance of ImageReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceSpec(subject ImageReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Spec instances for property testing - lazily instantiated by ImageReferenceSpecGenerator()
var imageReferenceSpecGenerator gopter.Gen

// ImageReferenceSpecGenerator returns a generator of ImageReference_Spec instances for property testing.
func ImageReferenceSpecGenerator() gopter.Gen {
	if imageReferenceSpecGenerator != nil {
		return imageReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceSpec(generators)
	imageReferenceSpecGenerator = gen.Struct(reflect.TypeOf(ImageReference_Spec{}), generators)

	return imageReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceSpec(gens map[string]gopter.Gen) {
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ImageReference_Status to ImageReference_Status via AssignPropertiesToImageReferenceStatus & AssignPropertiesFromImageReferenceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForImageReferenceStatus, ImageReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForImageReferenceStatus tests if a specific instance of ImageReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForImageReferenceStatus(subject ImageReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ImageReference_Status
	err := copied.AssignPropertiesToImageReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ImageReference_Status
	err = actual.AssignPropertiesFromImageReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ImageReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceStatus, ImageReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceStatus runs a test to see if a specific instance of ImageReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceStatus(subject ImageReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Status instances for property testing - lazily instantiated by
//ImageReferenceStatusGenerator()
var imageReferenceStatusGenerator gopter.Gen

// ImageReferenceStatusGenerator returns a generator of ImageReference_Status instances for property testing.
func ImageReferenceStatusGenerator() gopter.Gen {
	if imageReferenceStatusGenerator != nil {
		return imageReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceStatus(generators)
	imageReferenceStatusGenerator = gen.Struct(reflect.TypeOf(ImageReference_Status{}), generators)

	return imageReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceStatus(gens map[string]gopter.Gen) {
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatus_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InstanceViewStatus_Status to InstanceViewStatus_Status via AssignPropertiesToInstanceViewStatusStatus & AssignPropertiesFromInstanceViewStatusStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForInstanceViewStatusStatus, InstanceViewStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInstanceViewStatusStatus tests if a specific instance of InstanceViewStatus_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForInstanceViewStatusStatus(subject InstanceViewStatus_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.InstanceViewStatus_Status
	err := copied.AssignPropertiesToInstanceViewStatusStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InstanceViewStatus_Status
	err = actual.AssignPropertiesFromInstanceViewStatusStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InstanceViewStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatusStatus, InstanceViewStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatusStatus runs a test to see if a specific instance of InstanceViewStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatusStatus(subject InstanceViewStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_Status instances for property testing - lazily instantiated by
//InstanceViewStatusStatusGenerator()
var instanceViewStatusStatusGenerator gopter.Gen

// InstanceViewStatusStatusGenerator returns a generator of InstanceViewStatus_Status instances for property testing.
func InstanceViewStatusStatusGenerator() gopter.Gen {
	if instanceViewStatusStatusGenerator != nil {
		return instanceViewStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatusStatus(generators)
	instanceViewStatusStatusGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_Status{}), generators)

	return instanceViewStatusStatusGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatusStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatusStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.OneConstOf(InstanceViewStatusStatusLevelError, InstanceViewStatusStatusLevelInfo, InstanceViewStatusStatusLevelWarning))
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxConfiguration_Spec to LinuxConfiguration_Spec via AssignPropertiesToLinuxConfigurationSpec & AssignPropertiesFromLinuxConfigurationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxConfigurationSpec, LinuxConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxConfigurationSpec tests if a specific instance of LinuxConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLinuxConfigurationSpec(subject LinuxConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LinuxConfiguration_Spec
	err := copied.AssignPropertiesToLinuxConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxConfiguration_Spec
	err = actual.AssignPropertiesFromLinuxConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationSpec, LinuxConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationSpec runs a test to see if a specific instance of LinuxConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationSpec(subject LinuxConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Spec instances for property testing - lazily instantiated by
//LinuxConfigurationSpecGenerator()
var linuxConfigurationSpecGenerator gopter.Gen

// LinuxConfigurationSpecGenerator returns a generator of LinuxConfiguration_Spec instances for property testing.
// We first initialize linuxConfigurationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationSpecGenerator() gopter.Gen {
	if linuxConfigurationSpecGenerator != nil {
		return linuxConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationSpec(generators)
	linuxConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationSpec(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationSpec(generators)
	linuxConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Spec{}), generators)

	return linuxConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationSpec(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationSpec(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsSpecGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationSpecGenerator())
}

func Test_LinuxConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxConfiguration_Status to LinuxConfiguration_Status via AssignPropertiesToLinuxConfigurationStatus & AssignPropertiesFromLinuxConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxConfigurationStatus, LinuxConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxConfigurationStatus tests if a specific instance of LinuxConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLinuxConfigurationStatus(subject LinuxConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LinuxConfiguration_Status
	err := copied.AssignPropertiesToLinuxConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxConfiguration_Status
	err = actual.AssignPropertiesFromLinuxConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationStatus, LinuxConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationStatus runs a test to see if a specific instance of LinuxConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationStatus(subject LinuxConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Status instances for property testing - lazily instantiated by
//LinuxConfigurationStatusGenerator()
var linuxConfigurationStatusGenerator gopter.Gen

// LinuxConfigurationStatusGenerator returns a generator of LinuxConfiguration_Status instances for property testing.
// We first initialize linuxConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationStatusGenerator() gopter.Gen {
	if linuxConfigurationStatusGenerator != nil {
		return linuxConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(generators)
	linuxConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationStatus(generators)
	linuxConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	return linuxConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationStatus(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsStatusGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationStatusGenerator())
}

func Test_MaintenanceRedeployStatus_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MaintenanceRedeployStatus_Status to MaintenanceRedeployStatus_Status via AssignPropertiesToMaintenanceRedeployStatusStatus & AssignPropertiesFromMaintenanceRedeployStatusStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForMaintenanceRedeployStatusStatus, MaintenanceRedeployStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMaintenanceRedeployStatusStatus tests if a specific instance of MaintenanceRedeployStatus_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForMaintenanceRedeployStatusStatus(subject MaintenanceRedeployStatus_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.MaintenanceRedeployStatus_Status
	err := copied.AssignPropertiesToMaintenanceRedeployStatusStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MaintenanceRedeployStatus_Status
	err = actual.AssignPropertiesFromMaintenanceRedeployStatusStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MaintenanceRedeployStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatusStatus, MaintenanceRedeployStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatusStatus runs a test to see if a specific instance of MaintenanceRedeployStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatusStatus(subject MaintenanceRedeployStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatus_Status instances for property testing - lazily instantiated by
//MaintenanceRedeployStatusStatusGenerator()
var maintenanceRedeployStatusStatusGenerator gopter.Gen

// MaintenanceRedeployStatusStatusGenerator returns a generator of MaintenanceRedeployStatus_Status instances for property testing.
func MaintenanceRedeployStatusStatusGenerator() gopter.Gen {
	if maintenanceRedeployStatusStatusGenerator != nil {
		return maintenanceRedeployStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus(generators)
	maintenanceRedeployStatusStatusGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatus_Status{}), generators)

	return maintenanceRedeployStatusStatusGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.OneConstOf(
		MaintenanceRedeployStatusStatusLastOperationResultCodeMaintenanceAborted,
		MaintenanceRedeployStatusStatusLastOperationResultCodeMaintenanceCompleted,
		MaintenanceRedeployStatusStatusLastOperationResultCodeNone,
		MaintenanceRedeployStatusStatusLastOperationResultCodeRetryLater))
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceReference_Spec to NetworkInterfaceReference_Spec via AssignPropertiesToNetworkInterfaceReferenceSpec & AssignPropertiesFromNetworkInterfaceReferenceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceReferenceSpec, NetworkInterfaceReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceReferenceSpec tests if a specific instance of NetworkInterfaceReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceReferenceSpec(subject NetworkInterfaceReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.NetworkInterfaceReference_Spec
	err := copied.AssignPropertiesToNetworkInterfaceReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceReference_Spec
	err = actual.AssignPropertiesFromNetworkInterfaceReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceSpec, NetworkInterfaceReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceSpec runs a test to see if a specific instance of NetworkInterfaceReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceSpec(subject NetworkInterfaceReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Spec instances for property testing - lazily instantiated by
//NetworkInterfaceReferenceSpecGenerator()
var networkInterfaceReferenceSpecGenerator gopter.Gen

// NetworkInterfaceReferenceSpecGenerator returns a generator of NetworkInterfaceReference_Spec instances for property testing.
func NetworkInterfaceReferenceSpecGenerator() gopter.Gen {
	if networkInterfaceReferenceSpecGenerator != nil {
		return networkInterfaceReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpec(generators)
	networkInterfaceReferenceSpecGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Spec{}), generators)

	return networkInterfaceReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpec(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkInterfaceReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceReference_Status to NetworkInterfaceReference_Status via AssignPropertiesToNetworkInterfaceReferenceStatus & AssignPropertiesFromNetworkInterfaceReferenceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceReferenceStatus, NetworkInterfaceReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceReferenceStatus tests if a specific instance of NetworkInterfaceReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceReferenceStatus(subject NetworkInterfaceReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.NetworkInterfaceReference_Status
	err := copied.AssignPropertiesToNetworkInterfaceReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceReference_Status
	err = actual.AssignPropertiesFromNetworkInterfaceReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceStatus, NetworkInterfaceReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceStatus runs a test to see if a specific instance of NetworkInterfaceReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceStatus(subject NetworkInterfaceReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Status instances for property testing - lazily instantiated by
//NetworkInterfaceReferenceStatusGenerator()
var networkInterfaceReferenceStatusGenerator gopter.Gen

// NetworkInterfaceReferenceStatusGenerator returns a generator of NetworkInterfaceReference_Status instances for property testing.
func NetworkInterfaceReferenceStatusGenerator() gopter.Gen {
	if networkInterfaceReferenceStatusGenerator != nil {
		return networkInterfaceReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus(generators)
	networkInterfaceReferenceStatusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Status{}), generators)

	return networkInterfaceReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_OSDisk_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OSDisk_Spec to OSDisk_Spec via AssignPropertiesToOSDiskSpec & AssignPropertiesFromOSDiskSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForOSDiskSpec, OSDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOSDiskSpec tests if a specific instance of OSDisk_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForOSDiskSpec(subject OSDisk_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.OSDisk_Spec
	err := copied.AssignPropertiesToOSDiskSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OSDisk_Spec
	err = actual.AssignPropertiesFromOSDiskSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OSDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskSpec, OSDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskSpec runs a test to see if a specific instance of OSDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskSpec(subject OSDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Spec instances for property testing - lazily instantiated by OSDiskSpecGenerator()
var osDiskSpecGenerator gopter.Gen

// OSDiskSpecGenerator returns a generator of OSDisk_Spec instances for property testing.
// We first initialize osDiskSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskSpecGenerator() gopter.Gen {
	if osDiskSpecGenerator != nil {
		return osDiskSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskSpec(generators)
	osDiskSpecGenerator = gen.Struct(reflect.TypeOf(OSDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskSpec(generators)
	AddRelatedPropertyGeneratorsForOSDiskSpec(generators)
	osDiskSpecGenerator = gen.Struct(reflect.TypeOf(OSDisk_Spec{}), generators)

	return osDiskSpecGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskSpec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDiskSpecOsTypeLinux, OSDiskSpecOsTypeWindows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskSpec(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsSpecGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsSpecGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskSpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersSpecGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskSpecGenerator())
}

func Test_OSDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OSDisk_Status to OSDisk_Status via AssignPropertiesToOSDiskStatus & AssignPropertiesFromOSDiskStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForOSDiskStatus, OSDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOSDiskStatus tests if a specific instance of OSDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForOSDiskStatus(subject OSDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.OSDisk_Status
	err := copied.AssignPropertiesToOSDiskStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OSDisk_Status
	err = actual.AssignPropertiesFromOSDiskStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OSDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskStatus, OSDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskStatus runs a test to see if a specific instance of OSDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskStatus(subject OSDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Status instances for property testing - lazily instantiated by OSDiskStatusGenerator()
var osDiskStatusGenerator gopter.Gen

// OSDiskStatusGenerator returns a generator of OSDisk_Status instances for property testing.
// We first initialize osDiskStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskStatusGenerator() gopter.Gen {
	if osDiskStatusGenerator != nil {
		return osDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskStatus(generators)
	osDiskStatusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskStatus(generators)
	AddRelatedPropertyGeneratorsForOSDiskStatus(generators)
	osDiskStatusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	return osDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskStatus(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_StatusNone, Caching_StatusReadOnly, Caching_StatusReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_StatusAttach, CreateOption_StatusEmpty, CreateOption_StatusFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDiskStatusOsTypeLinux, OSDiskStatusOsTypeWindows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskStatus(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsStatusGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsStatusGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersStatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
}

func Test_UefiSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UefiSettings_Spec to UefiSettings_Spec via AssignPropertiesToUefiSettingsSpec & AssignPropertiesFromUefiSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUefiSettingsSpec, UefiSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUefiSettingsSpec tests if a specific instance of UefiSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForUefiSettingsSpec(subject UefiSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.UefiSettings_Spec
	err := copied.AssignPropertiesToUefiSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UefiSettings_Spec
	err = actual.AssignPropertiesFromUefiSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UefiSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsSpec, UefiSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsSpec runs a test to see if a specific instance of UefiSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsSpec(subject UefiSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Spec instances for property testing - lazily instantiated by UefiSettingsSpecGenerator()
var uefiSettingsSpecGenerator gopter.Gen

// UefiSettingsSpecGenerator returns a generator of UefiSettings_Spec instances for property testing.
func UefiSettingsSpecGenerator() gopter.Gen {
	if uefiSettingsSpecGenerator != nil {
		return uefiSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsSpec(generators)
	uefiSettingsSpecGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Spec{}), generators)

	return uefiSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsSpec(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_UefiSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UefiSettings_Status to UefiSettings_Status via AssignPropertiesToUefiSettingsStatus & AssignPropertiesFromUefiSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForUefiSettingsStatus, UefiSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUefiSettingsStatus tests if a specific instance of UefiSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForUefiSettingsStatus(subject UefiSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.UefiSettings_Status
	err := copied.AssignPropertiesToUefiSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UefiSettings_Status
	err = actual.AssignPropertiesFromUefiSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UefiSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsStatus, UefiSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsStatus runs a test to see if a specific instance of UefiSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsStatus(subject UefiSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Status instances for property testing - lazily instantiated by UefiSettingsStatusGenerator()
var uefiSettingsStatusGenerator gopter.Gen

// UefiSettingsStatusGenerator returns a generator of UefiSettings_Status instances for property testing.
func UefiSettingsStatusGenerator() gopter.Gen {
	if uefiSettingsStatusGenerator != nil {
		return uefiSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsStatus(generators)
	uefiSettingsStatusGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Status{}), generators)

	return uefiSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsStatus(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultSecretGroup_Spec to VaultSecretGroup_Spec via AssignPropertiesToVaultSecretGroupSpec & AssignPropertiesFromVaultSecretGroupSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultSecretGroupSpec, VaultSecretGroupSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultSecretGroupSpec tests if a specific instance of VaultSecretGroup_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVaultSecretGroupSpec(subject VaultSecretGroup_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VaultSecretGroup_Spec
	err := copied.AssignPropertiesToVaultSecretGroupSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultSecretGroup_Spec
	err = actual.AssignPropertiesFromVaultSecretGroupSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultSecretGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupSpec, VaultSecretGroupSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupSpec runs a test to see if a specific instance of VaultSecretGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupSpec(subject VaultSecretGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Spec instances for property testing - lazily instantiated by
//VaultSecretGroupSpecGenerator()
var vaultSecretGroupSpecGenerator gopter.Gen

// VaultSecretGroupSpecGenerator returns a generator of VaultSecretGroup_Spec instances for property testing.
func VaultSecretGroupSpecGenerator() gopter.Gen {
	if vaultSecretGroupSpecGenerator != nil {
		return vaultSecretGroupSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupSpec(generators)
	vaultSecretGroupSpecGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Spec{}), generators)

	return vaultSecretGroupSpecGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupSpec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateSpecGenerator())
}

func Test_VaultSecretGroup_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultSecretGroup_Status to VaultSecretGroup_Status via AssignPropertiesToVaultSecretGroupStatus & AssignPropertiesFromVaultSecretGroupStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultSecretGroupStatus, VaultSecretGroupStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultSecretGroupStatus tests if a specific instance of VaultSecretGroup_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVaultSecretGroupStatus(subject VaultSecretGroup_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VaultSecretGroup_Status
	err := copied.AssignPropertiesToVaultSecretGroupStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultSecretGroup_Status
	err = actual.AssignPropertiesFromVaultSecretGroupStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultSecretGroup_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupStatus, VaultSecretGroupStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupStatus runs a test to see if a specific instance of VaultSecretGroup_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupStatus(subject VaultSecretGroup_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Status instances for property testing - lazily instantiated by
//VaultSecretGroupStatusGenerator()
var vaultSecretGroupStatusGenerator gopter.Gen

// VaultSecretGroupStatusGenerator returns a generator of VaultSecretGroup_Status instances for property testing.
func VaultSecretGroupStatusGenerator() gopter.Gen {
	if vaultSecretGroupStatusGenerator != nil {
		return vaultSecretGroupStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupStatus(generators)
	vaultSecretGroupStatusGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Status{}), generators)

	return vaultSecretGroupStatusGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateStatusGenerator())
}

func Test_VirtualMachineAgentInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineAgentInstanceView_Status to VirtualMachineAgentInstanceView_Status via AssignPropertiesToVirtualMachineAgentInstanceViewStatus & AssignPropertiesFromVirtualMachineAgentInstanceViewStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineAgentInstanceViewStatus, VirtualMachineAgentInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineAgentInstanceViewStatus tests if a specific instance of VirtualMachineAgentInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineAgentInstanceViewStatus(subject VirtualMachineAgentInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineAgentInstanceView_Status
	err := copied.AssignPropertiesToVirtualMachineAgentInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineAgentInstanceView_Status
	err = actual.AssignPropertiesFromVirtualMachineAgentInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineAgentInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus, VirtualMachineAgentInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus runs a test to see if a specific instance of VirtualMachineAgentInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus(subject VirtualMachineAgentInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineAgentInstanceViewStatusGenerator()
var virtualMachineAgentInstanceViewStatusGenerator gopter.Gen

// VirtualMachineAgentInstanceViewStatusGenerator returns a generator of VirtualMachineAgentInstanceView_Status instances for property testing.
// We first initialize virtualMachineAgentInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineAgentInstanceViewStatusGenerator != nil {
		return virtualMachineAgentInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	virtualMachineAgentInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	virtualMachineAgentInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	return virtualMachineAgentInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceViewStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineExtensionInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineExtensionInstanceView_Status to VirtualMachineExtensionInstanceView_Status via AssignPropertiesToVirtualMachineExtensionInstanceViewStatus & AssignPropertiesFromVirtualMachineExtensionInstanceViewStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineExtensionInstanceViewStatus, VirtualMachineExtensionInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineExtensionInstanceViewStatus tests if a specific instance of VirtualMachineExtensionInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineExtensionInstanceViewStatus(subject VirtualMachineExtensionInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineExtensionInstanceView_Status
	err := copied.AssignPropertiesToVirtualMachineExtensionInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineExtensionInstanceView_Status
	err = actual.AssignPropertiesFromVirtualMachineExtensionInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineExtensionInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus, VirtualMachineExtensionInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus runs a test to see if a specific instance of VirtualMachineExtensionInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus(subject VirtualMachineExtensionInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineExtensionInstanceViewStatusGenerator()
var virtualMachineExtensionInstanceViewStatusGenerator gopter.Gen

// VirtualMachineExtensionInstanceViewStatusGenerator returns a generator of VirtualMachineExtensionInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceViewStatusGenerator != nil {
		return virtualMachineExtensionInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	virtualMachineExtensionInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	virtualMachineExtensionInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	return virtualMachineExtensionInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineHealthStatus_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineHealthStatus_Status to VirtualMachineHealthStatus_Status via AssignPropertiesToVirtualMachineHealthStatusStatus & AssignPropertiesFromVirtualMachineHealthStatusStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineHealthStatusStatus, VirtualMachineHealthStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineHealthStatusStatus tests if a specific instance of VirtualMachineHealthStatus_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineHealthStatusStatus(subject VirtualMachineHealthStatus_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineHealthStatus_Status
	err := copied.AssignPropertiesToVirtualMachineHealthStatusStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineHealthStatus_Status
	err = actual.AssignPropertiesFromVirtualMachineHealthStatusStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineHealthStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatusStatus, VirtualMachineHealthStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatusStatus runs a test to see if a specific instance of VirtualMachineHealthStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatusStatus(subject VirtualMachineHealthStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatus_Status instances for property testing - lazily instantiated by
//VirtualMachineHealthStatusStatusGenerator()
var virtualMachineHealthStatusStatusGenerator gopter.Gen

// VirtualMachineHealthStatusStatusGenerator returns a generator of VirtualMachineHealthStatus_Status instances for property testing.
func VirtualMachineHealthStatusStatusGenerator() gopter.Gen {
	if virtualMachineHealthStatusStatusGenerator != nil {
		return virtualMachineHealthStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus(generators)
	virtualMachineHealthStatusStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatus_Status{}), generators)

	return virtualMachineHealthStatusStatusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineIdentity_Status_UserAssignedIdentities_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineIdentity_Status_UserAssignedIdentities to VirtualMachineIdentity_Status_UserAssignedIdentities via AssignPropertiesToVirtualMachineIdentityStatusUserAssignedIdentities & AssignPropertiesFromVirtualMachineIdentityStatusUserAssignedIdentities returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineIdentityStatusUserAssignedIdentities, VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineIdentityStatusUserAssignedIdentities tests if a specific instance of VirtualMachineIdentity_Status_UserAssignedIdentities can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineIdentityStatusUserAssignedIdentities(subject VirtualMachineIdentity_Status_UserAssignedIdentities) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineIdentity_Status_UserAssignedIdentities
	err := copied.AssignPropertiesToVirtualMachineIdentityStatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineIdentity_Status_UserAssignedIdentities
	err = actual.AssignPropertiesFromVirtualMachineIdentityStatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineIdentity_Status_UserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Status_UserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityStatusUserAssignedIdentities, VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityStatusUserAssignedIdentities runs a test to see if a specific instance of VirtualMachineIdentity_Status_UserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityStatusUserAssignedIdentities(subject VirtualMachineIdentity_Status_UserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Status_UserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Status_UserAssignedIdentities instances for property testing - lazily
//instantiated by VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator()
var virtualMachineIdentityStatusUserAssignedIdentitiesGenerator gopter.Gen

// VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator returns a generator of VirtualMachineIdentity_Status_UserAssignedIdentities instances for property testing.
func VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if virtualMachineIdentityStatusUserAssignedIdentitiesGenerator != nil {
		return virtualMachineIdentityStatusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatusUserAssignedIdentities(generators)
	virtualMachineIdentityStatusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status_UserAssignedIdentities{}), generators)

	return virtualMachineIdentityStatusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinePatchStatus_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachinePatchStatus_Status to VirtualMachinePatchStatus_Status via AssignPropertiesToVirtualMachinePatchStatusStatus & AssignPropertiesFromVirtualMachinePatchStatusStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachinePatchStatusStatus, VirtualMachinePatchStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachinePatchStatusStatus tests if a specific instance of VirtualMachinePatchStatus_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachinePatchStatusStatus(subject VirtualMachinePatchStatus_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachinePatchStatus_Status
	err := copied.AssignPropertiesToVirtualMachinePatchStatusStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachinePatchStatus_Status
	err = actual.AssignPropertiesFromVirtualMachinePatchStatusStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachinePatchStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatusStatus, VirtualMachinePatchStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatusStatus runs a test to see if a specific instance of VirtualMachinePatchStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatusStatus(subject VirtualMachinePatchStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatus_Status instances for property testing - lazily instantiated by
//VirtualMachinePatchStatusStatusGenerator()
var virtualMachinePatchStatusStatusGenerator gopter.Gen

// VirtualMachinePatchStatusStatusGenerator returns a generator of VirtualMachinePatchStatus_Status instances for property testing.
func VirtualMachinePatchStatusStatusGenerator() gopter.Gen {
	if virtualMachinePatchStatusStatusGenerator != nil {
		return virtualMachinePatchStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus(generators)
	virtualMachinePatchStatusStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatus_Status{}), generators)

	return virtualMachinePatchStatusStatusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummaryStatusGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummaryStatusGenerator())
}

func Test_WindowsConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WindowsConfiguration_Spec to WindowsConfiguration_Spec via AssignPropertiesToWindowsConfigurationSpec & AssignPropertiesFromWindowsConfigurationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWindowsConfigurationSpec, WindowsConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWindowsConfigurationSpec tests if a specific instance of WindowsConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWindowsConfigurationSpec(subject WindowsConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WindowsConfiguration_Spec
	err := copied.AssignPropertiesToWindowsConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WindowsConfiguration_Spec
	err = actual.AssignPropertiesFromWindowsConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WindowsConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationSpec, WindowsConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationSpec runs a test to see if a specific instance of WindowsConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationSpec(subject WindowsConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Spec instances for property testing - lazily instantiated by
//WindowsConfigurationSpecGenerator()
var windowsConfigurationSpecGenerator gopter.Gen

// WindowsConfigurationSpecGenerator returns a generator of WindowsConfiguration_Spec instances for property testing.
// We first initialize windowsConfigurationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationSpecGenerator() gopter.Gen {
	if windowsConfigurationSpecGenerator != nil {
		return windowsConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationSpec(generators)
	windowsConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationSpec(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationSpec(generators)
	windowsConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Spec{}), generators)

	return windowsConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationSpec(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationSpec(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentSpecGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsSpecGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationSpecGenerator())
}

func Test_WindowsConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WindowsConfiguration_Status to WindowsConfiguration_Status via AssignPropertiesToWindowsConfigurationStatus & AssignPropertiesFromWindowsConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForWindowsConfigurationStatus, WindowsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWindowsConfigurationStatus tests if a specific instance of WindowsConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWindowsConfigurationStatus(subject WindowsConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WindowsConfiguration_Status
	err := copied.AssignPropertiesToWindowsConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WindowsConfiguration_Status
	err = actual.AssignPropertiesFromWindowsConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WindowsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationStatus, WindowsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationStatus runs a test to see if a specific instance of WindowsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationStatus(subject WindowsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Status instances for property testing - lazily instantiated by
//WindowsConfigurationStatusGenerator()
var windowsConfigurationStatusGenerator gopter.Gen

// WindowsConfigurationStatusGenerator returns a generator of WindowsConfiguration_Status instances for property testing.
// We first initialize windowsConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationStatusGenerator() gopter.Gen {
	if windowsConfigurationStatusGenerator != nil {
		return windowsConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(generators)
	windowsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationStatus(generators)
	windowsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	return windowsConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentStatusGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsStatusGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationStatusGenerator())
}

func Test_AdditionalUnattendContent_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalUnattendContent_Spec to AdditionalUnattendContent_Spec via AssignPropertiesToAdditionalUnattendContentSpec & AssignPropertiesFromAdditionalUnattendContentSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalUnattendContentSpec, AdditionalUnattendContentSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalUnattendContentSpec tests if a specific instance of AdditionalUnattendContent_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAdditionalUnattendContentSpec(subject AdditionalUnattendContent_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AdditionalUnattendContent_Spec
	err := copied.AssignPropertiesToAdditionalUnattendContentSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalUnattendContent_Spec
	err = actual.AssignPropertiesFromAdditionalUnattendContentSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalUnattendContent_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentSpec, AdditionalUnattendContentSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentSpec runs a test to see if a specific instance of AdditionalUnattendContent_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentSpec(subject AdditionalUnattendContent_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Spec instances for property testing - lazily instantiated by
//AdditionalUnattendContentSpecGenerator()
var additionalUnattendContentSpecGenerator gopter.Gen

// AdditionalUnattendContentSpecGenerator returns a generator of AdditionalUnattendContent_Spec instances for property testing.
func AdditionalUnattendContentSpecGenerator() gopter.Gen {
	if additionalUnattendContentSpecGenerator != nil {
		return additionalUnattendContentSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpec(generators)
	additionalUnattendContentSpecGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Spec{}), generators)

	return additionalUnattendContentSpecGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpec(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSpecComponentNameMicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSpecPassNameOobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSpecSettingNameAutoLogon, AdditionalUnattendContentSpecSettingNameFirstLogonCommands))
}

func Test_AdditionalUnattendContent_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalUnattendContent_Status to AdditionalUnattendContent_Status via AssignPropertiesToAdditionalUnattendContentStatus & AssignPropertiesFromAdditionalUnattendContentStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalUnattendContentStatus, AdditionalUnattendContentStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalUnattendContentStatus tests if a specific instance of AdditionalUnattendContent_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAdditionalUnattendContentStatus(subject AdditionalUnattendContent_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AdditionalUnattendContent_Status
	err := copied.AssignPropertiesToAdditionalUnattendContentStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalUnattendContent_Status
	err = actual.AssignPropertiesFromAdditionalUnattendContentStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalUnattendContent_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentStatus, AdditionalUnattendContentStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentStatus runs a test to see if a specific instance of AdditionalUnattendContent_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentStatus(subject AdditionalUnattendContent_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Status instances for property testing - lazily instantiated by
//AdditionalUnattendContentStatusGenerator()
var additionalUnattendContentStatusGenerator gopter.Gen

// AdditionalUnattendContentStatusGenerator returns a generator of AdditionalUnattendContent_Status instances for property testing.
func AdditionalUnattendContentStatusGenerator() gopter.Gen {
	if additionalUnattendContentStatusGenerator != nil {
		return additionalUnattendContentStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus(generators)
	additionalUnattendContentStatusGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Status{}), generators)

	return additionalUnattendContentStatusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentStatusComponentNameMicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentStatusPassNameOobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentStatusSettingNameAutoLogon, AdditionalUnattendContentStatusSettingNameFirstLogonCommands))
}

func Test_AvailablePatchSummary_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AvailablePatchSummary_Status to AvailablePatchSummary_Status via AssignPropertiesToAvailablePatchSummaryStatus & AssignPropertiesFromAvailablePatchSummaryStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAvailablePatchSummaryStatus, AvailablePatchSummaryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAvailablePatchSummaryStatus tests if a specific instance of AvailablePatchSummary_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAvailablePatchSummaryStatus(subject AvailablePatchSummary_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AvailablePatchSummary_Status
	err := copied.AssignPropertiesToAvailablePatchSummaryStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AvailablePatchSummary_Status
	err = actual.AssignPropertiesFromAvailablePatchSummaryStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AvailablePatchSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummaryStatus, AvailablePatchSummaryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummaryStatus runs a test to see if a specific instance of AvailablePatchSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummaryStatus(subject AvailablePatchSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummary_Status instances for property testing - lazily instantiated by
//AvailablePatchSummaryStatusGenerator()
var availablePatchSummaryStatusGenerator gopter.Gen

// AvailablePatchSummaryStatusGenerator returns a generator of AvailablePatchSummary_Status instances for property testing.
// We first initialize availablePatchSummaryStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummaryStatusGenerator() gopter.Gen {
	if availablePatchSummaryStatusGenerator != nil {
		return availablePatchSummaryStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	availablePatchSummaryStatusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	availablePatchSummaryStatusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	return availablePatchSummaryStatusGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		AvailablePatchSummaryStatusStatusCompletedWithWarnings,
		AvailablePatchSummaryStatusStatusFailed,
		AvailablePatchSummaryStatusStatusInProgress,
		AvailablePatchSummaryStatusStatusSucceeded,
		AvailablePatchSummaryStatusStatusUnknown))
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorStatusGenerator())
}

func Test_DiffDiskSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiffDiskSettings_Spec to DiffDiskSettings_Spec via AssignPropertiesToDiffDiskSettingsSpec & AssignPropertiesFromDiffDiskSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiffDiskSettingsSpec, DiffDiskSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiffDiskSettingsSpec tests if a specific instance of DiffDiskSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiffDiskSettingsSpec(subject DiffDiskSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiffDiskSettings_Spec
	err := copied.AssignPropertiesToDiffDiskSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiffDiskSettings_Spec
	err = actual.AssignPropertiesFromDiffDiskSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiffDiskSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsSpec, DiffDiskSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsSpec runs a test to see if a specific instance of DiffDiskSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsSpec(subject DiffDiskSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Spec instances for property testing - lazily instantiated by
//DiffDiskSettingsSpecGenerator()
var diffDiskSettingsSpecGenerator gopter.Gen

// DiffDiskSettingsSpecGenerator returns a generator of DiffDiskSettings_Spec instances for property testing.
func DiffDiskSettingsSpecGenerator() gopter.Gen {
	if diffDiskSettingsSpecGenerator != nil {
		return diffDiskSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsSpec(generators)
	diffDiskSettingsSpecGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Spec{}), generators)

	return diffDiskSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsSpec(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_SpecLocal))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_SpecCacheDisk, DiffDiskPlacement_SpecResourceDisk))
}

func Test_DiffDiskSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiffDiskSettings_Status to DiffDiskSettings_Status via AssignPropertiesToDiffDiskSettingsStatus & AssignPropertiesFromDiffDiskSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiffDiskSettingsStatus, DiffDiskSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiffDiskSettingsStatus tests if a specific instance of DiffDiskSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiffDiskSettingsStatus(subject DiffDiskSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiffDiskSettings_Status
	err := copied.AssignPropertiesToDiffDiskSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiffDiskSettings_Status
	err = actual.AssignPropertiesFromDiffDiskSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiffDiskSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsStatus, DiffDiskSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsStatus runs a test to see if a specific instance of DiffDiskSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsStatus(subject DiffDiskSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Status instances for property testing - lazily instantiated by
//DiffDiskSettingsStatusGenerator()
var diffDiskSettingsStatusGenerator gopter.Gen

// DiffDiskSettingsStatusGenerator returns a generator of DiffDiskSettings_Status instances for property testing.
func DiffDiskSettingsStatusGenerator() gopter.Gen {
	if diffDiskSettingsStatusGenerator != nil {
		return diffDiskSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus(generators)
	diffDiskSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Status{}), generators)

	return diffDiskSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_StatusLocal))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_StatusCacheDisk, DiffDiskPlacement_StatusResourceDisk))
}

func Test_DiskEncryptionSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiskEncryptionSettings_Spec to DiskEncryptionSettings_Spec via AssignPropertiesToDiskEncryptionSettingsSpec & AssignPropertiesFromDiskEncryptionSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiskEncryptionSettingsSpec, DiskEncryptionSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiskEncryptionSettingsSpec tests if a specific instance of DiskEncryptionSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiskEncryptionSettingsSpec(subject DiskEncryptionSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiskEncryptionSettings_Spec
	err := copied.AssignPropertiesToDiskEncryptionSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiskEncryptionSettings_Spec
	err = actual.AssignPropertiesFromDiskEncryptionSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiskEncryptionSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsSpec, DiskEncryptionSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsSpec runs a test to see if a specific instance of DiskEncryptionSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsSpec(subject DiskEncryptionSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Spec instances for property testing - lazily instantiated by
//DiskEncryptionSettingsSpecGenerator()
var diskEncryptionSettingsSpecGenerator gopter.Gen

// DiskEncryptionSettingsSpecGenerator returns a generator of DiskEncryptionSettings_Spec instances for property testing.
// We first initialize diskEncryptionSettingsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsSpecGenerator() gopter.Gen {
	if diskEncryptionSettingsSpecGenerator != nil {
		return diskEncryptionSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpec(generators)
	diskEncryptionSettingsSpecGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpec(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpec(generators)
	diskEncryptionSettingsSpecGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Spec{}), generators)

	return diskEncryptionSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceSpecGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceSpecGenerator())
}

func Test_DiskEncryptionSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiskEncryptionSettings_Status to DiskEncryptionSettings_Status via AssignPropertiesToDiskEncryptionSettingsStatus & AssignPropertiesFromDiskEncryptionSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiskEncryptionSettingsStatus, DiskEncryptionSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiskEncryptionSettingsStatus tests if a specific instance of DiskEncryptionSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiskEncryptionSettingsStatus(subject DiskEncryptionSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiskEncryptionSettings_Status
	err := copied.AssignPropertiesToDiskEncryptionSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiskEncryptionSettings_Status
	err = actual.AssignPropertiesFromDiskEncryptionSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiskEncryptionSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsStatus, DiskEncryptionSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsStatus runs a test to see if a specific instance of DiskEncryptionSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsStatus(subject DiskEncryptionSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Status instances for property testing - lazily instantiated by
//DiskEncryptionSettingsStatusGenerator()
var diskEncryptionSettingsStatusGenerator gopter.Gen

// DiskEncryptionSettingsStatusGenerator returns a generator of DiskEncryptionSettings_Status instances for property testing.
// We first initialize diskEncryptionSettingsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsStatusGenerator() gopter.Gen {
	if diskEncryptionSettingsStatusGenerator != nil {
		return diskEncryptionSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	diskEncryptionSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	diskEncryptionSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	return diskEncryptionSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceStatusGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceStatusGenerator())
}

func Test_LastPatchInstallationSummary_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LastPatchInstallationSummary_Status to LastPatchInstallationSummary_Status via AssignPropertiesToLastPatchInstallationSummaryStatus & AssignPropertiesFromLastPatchInstallationSummaryStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForLastPatchInstallationSummaryStatus, LastPatchInstallationSummaryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLastPatchInstallationSummaryStatus tests if a specific instance of LastPatchInstallationSummary_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLastPatchInstallationSummaryStatus(subject LastPatchInstallationSummary_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LastPatchInstallationSummary_Status
	err := copied.AssignPropertiesToLastPatchInstallationSummaryStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LastPatchInstallationSummary_Status
	err = actual.AssignPropertiesFromLastPatchInstallationSummaryStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LastPatchInstallationSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummaryStatus, LastPatchInstallationSummaryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummaryStatus runs a test to see if a specific instance of LastPatchInstallationSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummaryStatus(subject LastPatchInstallationSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummary_Status instances for property testing - lazily instantiated by
//LastPatchInstallationSummaryStatusGenerator()
var lastPatchInstallationSummaryStatusGenerator gopter.Gen

// LastPatchInstallationSummaryStatusGenerator returns a generator of LastPatchInstallationSummary_Status instances for property testing.
// We first initialize lastPatchInstallationSummaryStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummaryStatusGenerator() gopter.Gen {
	if lastPatchInstallationSummaryStatusGenerator != nil {
		return lastPatchInstallationSummaryStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	lastPatchInstallationSummaryStatusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	lastPatchInstallationSummaryStatusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	return lastPatchInstallationSummaryStatusGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		LastPatchInstallationSummaryStatusStatusCompletedWithWarnings,
		LastPatchInstallationSummaryStatusStatusFailed,
		LastPatchInstallationSummaryStatusStatusInProgress,
		LastPatchInstallationSummaryStatusStatusSucceeded,
		LastPatchInstallationSummaryStatusStatusUnknown))
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorStatusGenerator())
}

func Test_LinuxPatchSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxPatchSettings_Spec to LinuxPatchSettings_Spec via AssignPropertiesToLinuxPatchSettingsSpec & AssignPropertiesFromLinuxPatchSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxPatchSettingsSpec, LinuxPatchSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxPatchSettingsSpec tests if a specific instance of LinuxPatchSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLinuxPatchSettingsSpec(subject LinuxPatchSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LinuxPatchSettings_Spec
	err := copied.AssignPropertiesToLinuxPatchSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxPatchSettings_Spec
	err = actual.AssignPropertiesFromLinuxPatchSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxPatchSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsSpec, LinuxPatchSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsSpec runs a test to see if a specific instance of LinuxPatchSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsSpec(subject LinuxPatchSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Spec instances for property testing - lazily instantiated by
//LinuxPatchSettingsSpecGenerator()
var linuxPatchSettingsSpecGenerator gopter.Gen

// LinuxPatchSettingsSpecGenerator returns a generator of LinuxPatchSettings_Spec instances for property testing.
func LinuxPatchSettingsSpecGenerator() gopter.Gen {
	if linuxPatchSettingsSpecGenerator != nil {
		return linuxPatchSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpec(generators)
	linuxPatchSettingsSpecGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Spec{}), generators)

	return linuxPatchSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpec(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettingsSpecPatchModeAutomaticByPlatform, LinuxPatchSettingsSpecPatchModeImageDefault))
}

func Test_LinuxPatchSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxPatchSettings_Status to LinuxPatchSettings_Status via AssignPropertiesToLinuxPatchSettingsStatus & AssignPropertiesFromLinuxPatchSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxPatchSettingsStatus, LinuxPatchSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxPatchSettingsStatus tests if a specific instance of LinuxPatchSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLinuxPatchSettingsStatus(subject LinuxPatchSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LinuxPatchSettings_Status
	err := copied.AssignPropertiesToLinuxPatchSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxPatchSettings_Status
	err = actual.AssignPropertiesFromLinuxPatchSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxPatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsStatus, LinuxPatchSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsStatus runs a test to see if a specific instance of LinuxPatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsStatus(subject LinuxPatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Status instances for property testing - lazily instantiated by
//LinuxPatchSettingsStatusGenerator()
var linuxPatchSettingsStatusGenerator gopter.Gen

// LinuxPatchSettingsStatusGenerator returns a generator of LinuxPatchSettings_Status instances for property testing.
func LinuxPatchSettingsStatusGenerator() gopter.Gen {
	if linuxPatchSettingsStatusGenerator != nil {
		return linuxPatchSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus(generators)
	linuxPatchSettingsStatusGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Status{}), generators)

	return linuxPatchSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettingsStatusPatchModeAutomaticByPlatform, LinuxPatchSettingsStatusPatchModeImageDefault))
}

func Test_ManagedDiskParameters_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedDiskParameters_Spec to ManagedDiskParameters_Spec via AssignPropertiesToManagedDiskParametersSpec & AssignPropertiesFromManagedDiskParametersSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedDiskParametersSpec, ManagedDiskParametersSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedDiskParametersSpec tests if a specific instance of ManagedDiskParameters_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForManagedDiskParametersSpec(subject ManagedDiskParameters_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ManagedDiskParameters_Spec
	err := copied.AssignPropertiesToManagedDiskParametersSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedDiskParameters_Spec
	err = actual.AssignPropertiesFromManagedDiskParametersSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedDiskParameters_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersSpec, ManagedDiskParametersSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersSpec runs a test to see if a specific instance of ManagedDiskParameters_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersSpec(subject ManagedDiskParameters_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Spec instances for property testing - lazily instantiated by
//ManagedDiskParametersSpecGenerator()
var managedDiskParametersSpecGenerator gopter.Gen

// ManagedDiskParametersSpecGenerator returns a generator of ManagedDiskParameters_Spec instances for property testing.
// We first initialize managedDiskParametersSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersSpecGenerator() gopter.Gen {
	if managedDiskParametersSpecGenerator != nil {
		return managedDiskParametersSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersSpec(generators)
	managedDiskParametersSpecGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersSpec(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersSpec(generators)
	managedDiskParametersSpecGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Spec{}), generators)

	return managedDiskParametersSpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersSpec(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_SpecPremiumLRS,
		StorageAccountType_SpecPremiumZRS,
		StorageAccountType_SpecStandardLRS,
		StorageAccountType_SpecStandardSSDLRS,
		StorageAccountType_SpecStandardSSDZRS,
		StorageAccountType_SpecUltraSSDLRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersSpec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_ManagedDiskParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedDiskParameters_Status to ManagedDiskParameters_Status via AssignPropertiesToManagedDiskParametersStatus & AssignPropertiesFromManagedDiskParametersStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedDiskParametersStatus, ManagedDiskParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedDiskParametersStatus tests if a specific instance of ManagedDiskParameters_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForManagedDiskParametersStatus(subject ManagedDiskParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ManagedDiskParameters_Status
	err := copied.AssignPropertiesToManagedDiskParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedDiskParameters_Status
	err = actual.AssignPropertiesFromManagedDiskParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedDiskParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersStatus, ManagedDiskParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersStatus runs a test to see if a specific instance of ManagedDiskParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersStatus(subject ManagedDiskParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Status instances for property testing - lazily instantiated by
//ManagedDiskParametersStatusGenerator()
var managedDiskParametersStatusGenerator gopter.Gen

// ManagedDiskParametersStatusGenerator returns a generator of ManagedDiskParameters_Status instances for property testing.
// We first initialize managedDiskParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersStatusGenerator() gopter.Gen {
	if managedDiskParametersStatusGenerator != nil {
		return managedDiskParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(generators)
	managedDiskParametersStatusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersStatus(generators)
	managedDiskParametersStatusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	return managedDiskParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_StatusPremiumLRS,
		StorageAccountType_StatusPremiumZRS,
		StorageAccountType_StatusStandardLRS,
		StorageAccountType_StatusStandardSSDLRS,
		StorageAccountType_StatusStandardSSDZRS,
		StorageAccountType_StatusUltraSSDLRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersStatus(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_PatchSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PatchSettings_Spec to PatchSettings_Spec via AssignPropertiesToPatchSettingsSpec & AssignPropertiesFromPatchSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPatchSettingsSpec, PatchSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPatchSettingsSpec tests if a specific instance of PatchSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForPatchSettingsSpec(subject PatchSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.PatchSettings_Spec
	err := copied.AssignPropertiesToPatchSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PatchSettings_Spec
	err = actual.AssignPropertiesFromPatchSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PatchSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsSpec, PatchSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsSpec runs a test to see if a specific instance of PatchSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsSpec(subject PatchSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Spec instances for property testing - lazily instantiated by PatchSettingsSpecGenerator()
var patchSettingsSpecGenerator gopter.Gen

// PatchSettingsSpecGenerator returns a generator of PatchSettings_Spec instances for property testing.
func PatchSettingsSpecGenerator() gopter.Gen {
	if patchSettingsSpecGenerator != nil {
		return patchSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsSpec(generators)
	patchSettingsSpecGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Spec{}), generators)

	return patchSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsSpec(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettingsSpecPatchModeAutomaticByOS, PatchSettingsSpecPatchModeAutomaticByPlatform, PatchSettingsSpecPatchModeManual))
}

func Test_PatchSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PatchSettings_Status to PatchSettings_Status via AssignPropertiesToPatchSettingsStatus & AssignPropertiesFromPatchSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForPatchSettingsStatus, PatchSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPatchSettingsStatus tests if a specific instance of PatchSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForPatchSettingsStatus(subject PatchSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.PatchSettings_Status
	err := copied.AssignPropertiesToPatchSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PatchSettings_Status
	err = actual.AssignPropertiesFromPatchSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsStatus, PatchSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsStatus runs a test to see if a specific instance of PatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsStatus(subject PatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Status instances for property testing - lazily instantiated by
//PatchSettingsStatusGenerator()
var patchSettingsStatusGenerator gopter.Gen

// PatchSettingsStatusGenerator returns a generator of PatchSettings_Status instances for property testing.
func PatchSettingsStatusGenerator() gopter.Gen {
	if patchSettingsStatusGenerator != nil {
		return patchSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsStatus(generators)
	patchSettingsStatusGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Status{}), generators)

	return patchSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsStatus(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettingsStatusPatchModeAutomaticByOS, PatchSettingsStatusPatchModeAutomaticByPlatform, PatchSettingsStatusPatchModeManual))
}

func Test_SshConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SshConfiguration_Spec to SshConfiguration_Spec via AssignPropertiesToSshConfigurationSpec & AssignPropertiesFromSshConfigurationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSshConfigurationSpec, SshConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSshConfigurationSpec tests if a specific instance of SshConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSshConfigurationSpec(subject SshConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SshConfiguration_Spec
	err := copied.AssignPropertiesToSshConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SshConfiguration_Spec
	err = actual.AssignPropertiesFromSshConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SshConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationSpec, SshConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationSpec runs a test to see if a specific instance of SshConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationSpec(subject SshConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Spec instances for property testing - lazily instantiated by
//SshConfigurationSpecGenerator()
var sshConfigurationSpecGenerator gopter.Gen

// SshConfigurationSpecGenerator returns a generator of SshConfiguration_Spec instances for property testing.
func SshConfigurationSpecGenerator() gopter.Gen {
	if sshConfigurationSpecGenerator != nil {
		return sshConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationSpec(generators)
	sshConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Spec{}), generators)

	return sshConfigurationSpecGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationSpec(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeySpecGenerator())
}

func Test_SshConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SshConfiguration_Status to SshConfiguration_Status via AssignPropertiesToSshConfigurationStatus & AssignPropertiesFromSshConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSshConfigurationStatus, SshConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSshConfigurationStatus tests if a specific instance of SshConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSshConfigurationStatus(subject SshConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SshConfiguration_Status
	err := copied.AssignPropertiesToSshConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SshConfiguration_Status
	err = actual.AssignPropertiesFromSshConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SshConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationStatus, SshConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationStatus runs a test to see if a specific instance of SshConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationStatus(subject SshConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Status instances for property testing - lazily instantiated by
//SshConfigurationStatusGenerator()
var sshConfigurationStatusGenerator gopter.Gen

// SshConfigurationStatusGenerator returns a generator of SshConfiguration_Status instances for property testing.
func SshConfigurationStatusGenerator() gopter.Gen {
	if sshConfigurationStatusGenerator != nil {
		return sshConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationStatus(generators)
	sshConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Status{}), generators)

	return sshConfigurationStatusGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationStatus(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeyStatusGenerator())
}

func Test_VaultCertificate_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultCertificate_Spec to VaultCertificate_Spec via AssignPropertiesToVaultCertificateSpec & AssignPropertiesFromVaultCertificateSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultCertificateSpec, VaultCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultCertificateSpec tests if a specific instance of VaultCertificate_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVaultCertificateSpec(subject VaultCertificate_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VaultCertificate_Spec
	err := copied.AssignPropertiesToVaultCertificateSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultCertificate_Spec
	err = actual.AssignPropertiesFromVaultCertificateSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultCertificate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateSpec, VaultCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateSpec runs a test to see if a specific instance of VaultCertificate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateSpec(subject VaultCertificate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Spec instances for property testing - lazily instantiated by
//VaultCertificateSpecGenerator()
var vaultCertificateSpecGenerator gopter.Gen

// VaultCertificateSpecGenerator returns a generator of VaultCertificate_Spec instances for property testing.
func VaultCertificateSpecGenerator() gopter.Gen {
	if vaultCertificateSpecGenerator != nil {
		return vaultCertificateSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateSpec(generators)
	vaultCertificateSpecGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Spec{}), generators)

	return vaultCertificateSpecGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateSpec(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VaultCertificate_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultCertificate_Status to VaultCertificate_Status via AssignPropertiesToVaultCertificateStatus & AssignPropertiesFromVaultCertificateStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultCertificateStatus, VaultCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultCertificateStatus tests if a specific instance of VaultCertificate_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVaultCertificateStatus(subject VaultCertificate_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VaultCertificate_Status
	err := copied.AssignPropertiesToVaultCertificateStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultCertificate_Status
	err = actual.AssignPropertiesFromVaultCertificateStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateStatus, VaultCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateStatus runs a test to see if a specific instance of VaultCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateStatus(subject VaultCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Status instances for property testing - lazily instantiated by
//VaultCertificateStatusGenerator()
var vaultCertificateStatusGenerator gopter.Gen

// VaultCertificateStatusGenerator returns a generator of VaultCertificate_Status instances for property testing.
func VaultCertificateStatusGenerator() gopter.Gen {
	if vaultCertificateStatusGenerator != nil {
		return vaultCertificateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateStatus(generators)
	vaultCertificateStatusGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Status{}), generators)

	return vaultCertificateStatusGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateStatus(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualHardDisk_Spec to VirtualHardDisk_Spec via AssignPropertiesToVirtualHardDiskSpec & AssignPropertiesFromVirtualHardDiskSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualHardDiskSpec, VirtualHardDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualHardDiskSpec tests if a specific instance of VirtualHardDisk_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualHardDiskSpec(subject VirtualHardDisk_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualHardDisk_Spec
	err := copied.AssignPropertiesToVirtualHardDiskSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualHardDisk_Spec
	err = actual.AssignPropertiesFromVirtualHardDiskSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualHardDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskSpec, VirtualHardDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskSpec runs a test to see if a specific instance of VirtualHardDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskSpec(subject VirtualHardDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Spec instances for property testing - lazily instantiated by
//VirtualHardDiskSpecGenerator()
var virtualHardDiskSpecGenerator gopter.Gen

// VirtualHardDiskSpecGenerator returns a generator of VirtualHardDisk_Spec instances for property testing.
func VirtualHardDiskSpecGenerator() gopter.Gen {
	if virtualHardDiskSpecGenerator != nil {
		return virtualHardDiskSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskSpec(generators)
	virtualHardDiskSpecGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Spec{}), generators)

	return virtualHardDiskSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskSpec(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualHardDisk_Status to VirtualHardDisk_Status via AssignPropertiesToVirtualHardDiskStatus & AssignPropertiesFromVirtualHardDiskStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualHardDiskStatus, VirtualHardDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualHardDiskStatus tests if a specific instance of VirtualHardDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualHardDiskStatus(subject VirtualHardDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualHardDisk_Status
	err := copied.AssignPropertiesToVirtualHardDiskStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualHardDisk_Status
	err = actual.AssignPropertiesFromVirtualHardDiskStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualHardDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskStatus, VirtualHardDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskStatus runs a test to see if a specific instance of VirtualHardDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskStatus(subject VirtualHardDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Status instances for property testing - lazily instantiated by
//VirtualHardDiskStatusGenerator()
var virtualHardDiskStatusGenerator gopter.Gen

// VirtualHardDiskStatusGenerator returns a generator of VirtualHardDisk_Status instances for property testing.
func VirtualHardDiskStatusGenerator() gopter.Gen {
	if virtualHardDiskStatusGenerator != nil {
		return virtualHardDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskStatus(generators)
	virtualHardDiskStatusGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Status{}), generators)

	return virtualHardDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskStatus(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineExtensionHandlerInstanceView_Status to VirtualMachineExtensionHandlerInstanceView_Status via AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewStatus & AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineExtensionHandlerInstanceViewStatus, VirtualMachineExtensionHandlerInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineExtensionHandlerInstanceViewStatus tests if a specific instance of VirtualMachineExtensionHandlerInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineExtensionHandlerInstanceViewStatus(subject VirtualMachineExtensionHandlerInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineExtensionHandlerInstanceView_Status
	err := copied.AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineExtensionHandlerInstanceView_Status
	err = actual.AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineExtensionHandlerInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus, VirtualMachineExtensionHandlerInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus(subject VirtualMachineExtensionHandlerInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing - lazily instantiated
//by VirtualMachineExtensionHandlerInstanceViewStatusGenerator()
var virtualMachineExtensionHandlerInstanceViewStatusGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceViewStatusGenerator returns a generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceViewStatusGenerator != nil {
		return virtualMachineExtensionHandlerInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	virtualMachineExtensionHandlerInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	virtualMachineExtensionHandlerInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	return virtualMachineExtensionHandlerInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_WinRMConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WinRMConfiguration_Spec to WinRMConfiguration_Spec via AssignPropertiesToWinRMConfigurationSpec & AssignPropertiesFromWinRMConfigurationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWinRMConfigurationSpec, WinRMConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWinRMConfigurationSpec tests if a specific instance of WinRMConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWinRMConfigurationSpec(subject WinRMConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WinRMConfiguration_Spec
	err := copied.AssignPropertiesToWinRMConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WinRMConfiguration_Spec
	err = actual.AssignPropertiesFromWinRMConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WinRMConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationSpec, WinRMConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationSpec runs a test to see if a specific instance of WinRMConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationSpec(subject WinRMConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Spec instances for property testing - lazily instantiated by
//WinRMConfigurationSpecGenerator()
var winRMConfigurationSpecGenerator gopter.Gen

// WinRMConfigurationSpecGenerator returns a generator of WinRMConfiguration_Spec instances for property testing.
func WinRMConfigurationSpecGenerator() gopter.Gen {
	if winRMConfigurationSpecGenerator != nil {
		return winRMConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationSpec(generators)
	winRMConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Spec{}), generators)

	return winRMConfigurationSpecGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationSpec(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerSpecGenerator())
}

func Test_WinRMConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WinRMConfiguration_Status to WinRMConfiguration_Status via AssignPropertiesToWinRMConfigurationStatus & AssignPropertiesFromWinRMConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForWinRMConfigurationStatus, WinRMConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWinRMConfigurationStatus tests if a specific instance of WinRMConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWinRMConfigurationStatus(subject WinRMConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WinRMConfiguration_Status
	err := copied.AssignPropertiesToWinRMConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WinRMConfiguration_Status
	err = actual.AssignPropertiesFromWinRMConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WinRMConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationStatus, WinRMConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationStatus runs a test to see if a specific instance of WinRMConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationStatus(subject WinRMConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Status instances for property testing - lazily instantiated by
//WinRMConfigurationStatusGenerator()
var winRMConfigurationStatusGenerator gopter.Gen

// WinRMConfigurationStatusGenerator returns a generator of WinRMConfiguration_Status instances for property testing.
func WinRMConfigurationStatusGenerator() gopter.Gen {
	if winRMConfigurationStatusGenerator != nil {
		return winRMConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationStatus(generators)
	winRMConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Status{}), generators)

	return winRMConfigurationStatusGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationStatus(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerStatusGenerator())
}

func Test_ApiError_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiError_Status to ApiError_Status via AssignPropertiesToApiErrorStatus & AssignPropertiesFromApiErrorStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiErrorStatus, ApiErrorStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiErrorStatus tests if a specific instance of ApiError_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForApiErrorStatus(subject ApiError_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ApiError_Status
	err := copied.AssignPropertiesToApiErrorStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiError_Status
	err = actual.AssignPropertiesFromApiErrorStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorStatus, ApiErrorStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorStatus runs a test to see if a specific instance of ApiError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorStatus(subject ApiError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiError_Status instances for property testing - lazily instantiated by ApiErrorStatusGenerator()
var apiErrorStatusGenerator gopter.Gen

// ApiErrorStatusGenerator returns a generator of ApiError_Status instances for property testing.
// We first initialize apiErrorStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiErrorStatusGenerator() gopter.Gen {
	if apiErrorStatusGenerator != nil {
		return apiErrorStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorStatus(generators)
	apiErrorStatusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorStatus(generators)
	AddRelatedPropertyGeneratorsForApiErrorStatus(generators)
	apiErrorStatusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	return apiErrorStatusGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiErrorStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiErrorStatus(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBaseStatusGenerator())
	gens["Innererror"] = gen.PtrOf(InnerErrorStatusGenerator())
}

func Test_KeyVaultKeyReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultKeyReference_Spec to KeyVaultKeyReference_Spec via AssignPropertiesToKeyVaultKeyReferenceSpec & AssignPropertiesFromKeyVaultKeyReferenceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultKeyReferenceSpec, KeyVaultKeyReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultKeyReferenceSpec tests if a specific instance of KeyVaultKeyReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultKeyReferenceSpec(subject KeyVaultKeyReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.KeyVaultKeyReference_Spec
	err := copied.AssignPropertiesToKeyVaultKeyReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultKeyReference_Spec
	err = actual.AssignPropertiesFromKeyVaultKeyReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultKeyReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceSpec, KeyVaultKeyReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceSpec runs a test to see if a specific instance of KeyVaultKeyReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceSpec(subject KeyVaultKeyReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Spec instances for property testing - lazily instantiated by
//KeyVaultKeyReferenceSpecGenerator()
var keyVaultKeyReferenceSpecGenerator gopter.Gen

// KeyVaultKeyReferenceSpecGenerator returns a generator of KeyVaultKeyReference_Spec instances for property testing.
// We first initialize keyVaultKeyReferenceSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceSpecGenerator() gopter.Gen {
	if keyVaultKeyReferenceSpecGenerator != nil {
		return keyVaultKeyReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpec(generators)
	keyVaultKeyReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpec(generators)
	keyVaultKeyReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Spec{}), generators)

	return keyVaultKeyReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpec(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResourceSpecGenerator()
}

func Test_KeyVaultKeyReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultKeyReference_Status to KeyVaultKeyReference_Status via AssignPropertiesToKeyVaultKeyReferenceStatus & AssignPropertiesFromKeyVaultKeyReferenceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultKeyReferenceStatus, KeyVaultKeyReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultKeyReferenceStatus tests if a specific instance of KeyVaultKeyReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultKeyReferenceStatus(subject KeyVaultKeyReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.KeyVaultKeyReference_Status
	err := copied.AssignPropertiesToKeyVaultKeyReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultKeyReference_Status
	err = actual.AssignPropertiesFromKeyVaultKeyReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultKeyReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceStatus, KeyVaultKeyReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceStatus runs a test to see if a specific instance of KeyVaultKeyReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceStatus(subject KeyVaultKeyReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Status instances for property testing - lazily instantiated by
//KeyVaultKeyReferenceStatusGenerator()
var keyVaultKeyReferenceStatusGenerator gopter.Gen

// KeyVaultKeyReferenceStatusGenerator returns a generator of KeyVaultKeyReference_Status instances for property testing.
// We first initialize keyVaultKeyReferenceStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceStatusGenerator() gopter.Gen {
	if keyVaultKeyReferenceStatusGenerator != nil {
		return keyVaultKeyReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	keyVaultKeyReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	keyVaultKeyReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	return keyVaultKeyReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResourceStatusGenerator()
}

func Test_KeyVaultSecretReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSecretReference_Spec to KeyVaultSecretReference_Spec via AssignPropertiesToKeyVaultSecretReferenceSpec & AssignPropertiesFromKeyVaultSecretReferenceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSecretReferenceSpec, KeyVaultSecretReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSecretReferenceSpec tests if a specific instance of KeyVaultSecretReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSecretReferenceSpec(subject KeyVaultSecretReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.KeyVaultSecretReference_Spec
	err := copied.AssignPropertiesToKeyVaultSecretReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSecretReference_Spec
	err = actual.AssignPropertiesFromKeyVaultSecretReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSecretReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceSpec, KeyVaultSecretReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceSpec runs a test to see if a specific instance of KeyVaultSecretReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceSpec(subject KeyVaultSecretReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Spec instances for property testing - lazily instantiated by
//KeyVaultSecretReferenceSpecGenerator()
var keyVaultSecretReferenceSpecGenerator gopter.Gen

// KeyVaultSecretReferenceSpecGenerator returns a generator of KeyVaultSecretReference_Spec instances for property testing.
// We first initialize keyVaultSecretReferenceSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceSpecGenerator() gopter.Gen {
	if keyVaultSecretReferenceSpecGenerator != nil {
		return keyVaultSecretReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpec(generators)
	keyVaultSecretReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpec(generators)
	keyVaultSecretReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Spec{}), generators)

	return keyVaultSecretReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpec(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResourceSpecGenerator()
}

func Test_KeyVaultSecretReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSecretReference_Status to KeyVaultSecretReference_Status via AssignPropertiesToKeyVaultSecretReferenceStatus & AssignPropertiesFromKeyVaultSecretReferenceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSecretReferenceStatus, KeyVaultSecretReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSecretReferenceStatus tests if a specific instance of KeyVaultSecretReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSecretReferenceStatus(subject KeyVaultSecretReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.KeyVaultSecretReference_Status
	err := copied.AssignPropertiesToKeyVaultSecretReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSecretReference_Status
	err = actual.AssignPropertiesFromKeyVaultSecretReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSecretReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceStatus, KeyVaultSecretReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceStatus runs a test to see if a specific instance of KeyVaultSecretReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceStatus(subject KeyVaultSecretReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Status instances for property testing - lazily instantiated by
//KeyVaultSecretReferenceStatusGenerator()
var keyVaultSecretReferenceStatusGenerator gopter.Gen

// KeyVaultSecretReferenceStatusGenerator returns a generator of KeyVaultSecretReference_Status instances for property testing.
// We first initialize keyVaultSecretReferenceStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceStatusGenerator() gopter.Gen {
	if keyVaultSecretReferenceStatusGenerator != nil {
		return keyVaultSecretReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	keyVaultSecretReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	keyVaultSecretReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	return keyVaultSecretReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResourceStatusGenerator()
}

func Test_SshPublicKey_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SshPublicKey_Spec to SshPublicKey_Spec via AssignPropertiesToSshPublicKeySpec & AssignPropertiesFromSshPublicKeySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSshPublicKeySpec, SshPublicKeySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSshPublicKeySpec tests if a specific instance of SshPublicKey_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSshPublicKeySpec(subject SshPublicKey_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SshPublicKey_Spec
	err := copied.AssignPropertiesToSshPublicKeySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SshPublicKey_Spec
	err = actual.AssignPropertiesFromSshPublicKeySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SshPublicKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeySpec, SshPublicKeySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeySpec runs a test to see if a specific instance of SshPublicKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeySpec(subject SshPublicKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Spec instances for property testing - lazily instantiated by SshPublicKeySpecGenerator()
var sshPublicKeySpecGenerator gopter.Gen

// SshPublicKeySpecGenerator returns a generator of SshPublicKey_Spec instances for property testing.
func SshPublicKeySpecGenerator() gopter.Gen {
	if sshPublicKeySpecGenerator != nil {
		return sshPublicKeySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeySpec(generators)
	sshPublicKeySpecGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Spec{}), generators)

	return sshPublicKeySpecGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeySpec(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_SshPublicKey_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SshPublicKey_Status to SshPublicKey_Status via AssignPropertiesToSshPublicKeyStatus & AssignPropertiesFromSshPublicKeyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSshPublicKeyStatus, SshPublicKeyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSshPublicKeyStatus tests if a specific instance of SshPublicKey_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSshPublicKeyStatus(subject SshPublicKey_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SshPublicKey_Status
	err := copied.AssignPropertiesToSshPublicKeyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SshPublicKey_Status
	err = actual.AssignPropertiesFromSshPublicKeyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SshPublicKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeyStatus, SshPublicKeyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeyStatus runs a test to see if a specific instance of SshPublicKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeyStatus(subject SshPublicKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Status instances for property testing - lazily instantiated by SshPublicKeyStatusGenerator()
var sshPublicKeyStatusGenerator gopter.Gen

// SshPublicKeyStatusGenerator returns a generator of SshPublicKey_Status instances for property testing.
func SshPublicKeyStatusGenerator() gopter.Gen {
	if sshPublicKeyStatusGenerator != nil {
		return sshPublicKeyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeyStatus(generators)
	sshPublicKeyStatusGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Status{}), generators)

	return sshPublicKeyStatusGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeyStatus(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WinRMListener_Spec to WinRMListener_Spec via AssignPropertiesToWinRMListenerSpec & AssignPropertiesFromWinRMListenerSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWinRMListenerSpec, WinRMListenerSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWinRMListenerSpec tests if a specific instance of WinRMListener_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWinRMListenerSpec(subject WinRMListener_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WinRMListener_Spec
	err := copied.AssignPropertiesToWinRMListenerSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WinRMListener_Spec
	err = actual.AssignPropertiesFromWinRMListenerSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WinRMListener_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerSpec, WinRMListenerSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerSpec runs a test to see if a specific instance of WinRMListener_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerSpec(subject WinRMListener_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Spec instances for property testing - lazily instantiated by WinRMListenerSpecGenerator()
var winRMListenerSpecGenerator gopter.Gen

// WinRMListenerSpecGenerator returns a generator of WinRMListener_Spec instances for property testing.
func WinRMListenerSpecGenerator() gopter.Gen {
	if winRMListenerSpecGenerator != nil {
		return winRMListenerSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerSpec(generators)
	winRMListenerSpecGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Spec{}), generators)

	return winRMListenerSpecGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerSpec(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListenerSpecProtocolHttp, WinRMListenerSpecProtocolHttps))
}

func Test_WinRMListener_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WinRMListener_Status to WinRMListener_Status via AssignPropertiesToWinRMListenerStatus & AssignPropertiesFromWinRMListenerStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForWinRMListenerStatus, WinRMListenerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWinRMListenerStatus tests if a specific instance of WinRMListener_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWinRMListenerStatus(subject WinRMListener_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WinRMListener_Status
	err := copied.AssignPropertiesToWinRMListenerStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WinRMListener_Status
	err = actual.AssignPropertiesFromWinRMListenerStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WinRMListener_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerStatus, WinRMListenerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerStatus runs a test to see if a specific instance of WinRMListener_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerStatus(subject WinRMListener_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Status instances for property testing - lazily instantiated by
//WinRMListenerStatusGenerator()
var winRMListenerStatusGenerator gopter.Gen

// WinRMListenerStatusGenerator returns a generator of WinRMListener_Status instances for property testing.
func WinRMListenerStatusGenerator() gopter.Gen {
	if winRMListenerStatusGenerator != nil {
		return winRMListenerStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerStatus(generators)
	winRMListenerStatusGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Status{}), generators)

	return winRMListenerStatusGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerStatus(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListenerStatusProtocolHttp, WinRMListenerStatusProtocolHttps))
}

func Test_ApiErrorBase_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiErrorBase_Status to ApiErrorBase_Status via AssignPropertiesToApiErrorBaseStatus & AssignPropertiesFromApiErrorBaseStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiErrorBaseStatus, ApiErrorBaseStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiErrorBaseStatus tests if a specific instance of ApiErrorBase_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForApiErrorBaseStatus(subject ApiErrorBase_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ApiErrorBase_Status
	err := copied.AssignPropertiesToApiErrorBaseStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiErrorBase_Status
	err = actual.AssignPropertiesFromApiErrorBaseStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiErrorBase_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBase_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBaseStatus, ApiErrorBaseStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBaseStatus runs a test to see if a specific instance of ApiErrorBase_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBaseStatus(subject ApiErrorBase_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBase_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBase_Status instances for property testing - lazily instantiated by ApiErrorBaseStatusGenerator()
var apiErrorBaseStatusGenerator gopter.Gen

// ApiErrorBaseStatusGenerator returns a generator of ApiErrorBase_Status instances for property testing.
func ApiErrorBaseStatusGenerator() gopter.Gen {
	if apiErrorBaseStatusGenerator != nil {
		return apiErrorBaseStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBaseStatus(generators)
	apiErrorBaseStatusGenerator = gen.Struct(reflect.TypeOf(ApiErrorBase_Status{}), generators)

	return apiErrorBaseStatusGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBaseStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBaseStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerError_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InnerError_Status to InnerError_Status via AssignPropertiesToInnerErrorStatus & AssignPropertiesFromInnerErrorStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForInnerErrorStatus, InnerErrorStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInnerErrorStatus tests if a specific instance of InnerError_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForInnerErrorStatus(subject InnerError_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.InnerError_Status
	err := copied.AssignPropertiesToInnerErrorStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InnerError_Status
	err = actual.AssignPropertiesFromInnerErrorStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InnerError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerErrorStatus, InnerErrorStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerErrorStatus runs a test to see if a specific instance of InnerError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerErrorStatus(subject InnerError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_Status instances for property testing - lazily instantiated by InnerErrorStatusGenerator()
var innerErrorStatusGenerator gopter.Gen

// InnerErrorStatusGenerator returns a generator of InnerError_Status instances for property testing.
func InnerErrorStatusGenerator() gopter.Gen {
	if innerErrorStatusGenerator != nil {
		return innerErrorStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerErrorStatus(generators)
	innerErrorStatusGenerator = gen.Struct(reflect.TypeOf(InnerError_Status{}), generators)

	return innerErrorStatusGenerator
}

// AddIndependentPropertyGeneratorsForInnerErrorStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerErrorStatus(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}
