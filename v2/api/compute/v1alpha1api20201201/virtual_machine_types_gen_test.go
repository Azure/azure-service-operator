// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachine to hub returns original",
		prop.ForAll(RunResourceConversionTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForVirtualMachine tests if a specific instance of VirtualMachine round trips to the hub storage version and back losslessly
func RunResourceConversionTestForVirtualMachine(subject VirtualMachine) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20201201storage.VirtualMachine
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual VirtualMachine
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachine_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachine to VirtualMachine via AssignPropertiesToVirtualMachine & AssignPropertiesFromVirtualMachine returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachine tests if a specific instance of VirtualMachine can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachine(subject VirtualMachine) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachine
	err := copied.AssignPropertiesToVirtualMachine(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachine
	err = actual.AssignPropertiesFromVirtualMachine(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachine_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine runs a test to see if a specific instance of VirtualMachine round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine(subject VirtualMachine) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine instances for property testing - lazily instantiated by VirtualMachineGenerator()
var virtualMachineGenerator gopter.Gen

// VirtualMachineGenerator returns a generator of VirtualMachine instances for property testing.
func VirtualMachineGenerator() gopter.Gen {
	if virtualMachineGenerator != nil {
		return virtualMachineGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachine(generators)
	virtualMachineGenerator = gen.Struct(reflect.TypeOf(VirtualMachine{}), generators)

	return virtualMachineGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachine is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualMachines_SPECGenerator()
	gens["Status"] = VirtualMachine_StatusGenerator()
}

func Test_VirtualMachine_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachine_Status to VirtualMachine_Status via AssignPropertiesToVirtualMachine_Status & AssignPropertiesFromVirtualMachine_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachine_Status, VirtualMachine_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachine_Status tests if a specific instance of VirtualMachine_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachine_Status(subject VirtualMachine_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachine_Status
	err := copied.AssignPropertiesToVirtualMachine_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachine_Status
	err = actual.AssignPropertiesFromVirtualMachine_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachine_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_Status, VirtualMachine_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_Status runs a test to see if a specific instance of VirtualMachine_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_Status(subject VirtualMachine_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_Status instances for property testing - lazily instantiated by
//VirtualMachine_StatusGenerator()
var virtualMachine_statusGenerator gopter.Gen

// VirtualMachine_StatusGenerator returns a generator of VirtualMachine_Status instances for property testing.
// We first initialize virtualMachine_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_StatusGenerator() gopter.Gen {
	if virtualMachine_statusGenerator != nil {
		return virtualMachine_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_Status(generators)
	virtualMachine_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_Status(generators)
	virtualMachine_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	return virtualMachine_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_Status(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_StatusDeallocate, EvictionPolicy_StatusDelete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_StatusLow, Priority_StatusRegular, Priority_StatusSpot))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_Status(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_StatusGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_StatusGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfile_StatusGenerator())
	gens["Host"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentity_StatusGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceView_StatusGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_StatusGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfile_StatusGenerator())
	gens["Plan"] = gen.PtrOf(Plan_StatusGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["Resources"] = gen.SliceOf(VirtualMachineExtension_StatusGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_StatusGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfile_StatusGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_VirtualMachines_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachines_SPEC to VirtualMachines_SPEC via AssignPropertiesToVirtualMachines_SPEC & AssignPropertiesFromVirtualMachines_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachines_SPEC, VirtualMachines_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachines_SPEC tests if a specific instance of VirtualMachines_SPEC can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachines_SPEC(subject VirtualMachines_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachines_SPEC
	err := copied.AssignPropertiesToVirtualMachines_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachines_SPEC
	err = actual.AssignPropertiesFromVirtualMachines_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachines_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachines_SPEC, VirtualMachines_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachines_SPEC runs a test to see if a specific instance of VirtualMachines_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachines_SPEC(subject VirtualMachines_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_SPEC instances for property testing - lazily instantiated by
//VirtualMachines_SPECGenerator()
var virtualMachines_specGenerator gopter.Gen

// VirtualMachines_SPECGenerator returns a generator of VirtualMachines_SPEC instances for property testing.
// We first initialize virtualMachines_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachines_SPECGenerator() gopter.Gen {
	if virtualMachines_specGenerator != nil {
		return virtualMachines_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachines_SPEC(generators)
	virtualMachines_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachines_SPEC(generators)
	AddRelatedPropertyGeneratorsForVirtualMachines_SPEC(generators)
	virtualMachines_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPEC{}), generators)

	return virtualMachines_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachines_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachines_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_SpecDeallocate, EvictionPolicy_SpecDelete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.AlphaString()
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_SpecLow, Priority_SpecRegular, Priority_SpecSpot))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachines_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachines_SPEC(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_SpecGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_SpecGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfile_SpecGenerator())
	gens["Host"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentity_SpecGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_SpecGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfile_SpecGenerator())
	gens["Plan"] = gen.PtrOf(Plan_SpecGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_SpecGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfile_SpecGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_AdditionalCapabilities_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalCapabilities_Spec to AdditionalCapabilities_Spec via AssignPropertiesToAdditionalCapabilities_Spec & AssignPropertiesFromAdditionalCapabilities_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalCapabilities_Spec, AdditionalCapabilities_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalCapabilities_Spec tests if a specific instance of AdditionalCapabilities_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAdditionalCapabilities_Spec(subject AdditionalCapabilities_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AdditionalCapabilities_Spec
	err := copied.AssignPropertiesToAdditionalCapabilities_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalCapabilities_Spec
	err = actual.AssignPropertiesFromAdditionalCapabilities_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalCapabilities_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilities_Spec, AdditionalCapabilities_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilities_Spec runs a test to see if a specific instance of AdditionalCapabilities_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilities_Spec(subject AdditionalCapabilities_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Spec instances for property testing - lazily instantiated by
//AdditionalCapabilities_SpecGenerator()
var additionalCapabilities_specGenerator gopter.Gen

// AdditionalCapabilities_SpecGenerator returns a generator of AdditionalCapabilities_Spec instances for property testing.
func AdditionalCapabilities_SpecGenerator() gopter.Gen {
	if additionalCapabilities_specGenerator != nil {
		return additionalCapabilities_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilities_Spec(generators)
	additionalCapabilities_specGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Spec{}), generators)

	return additionalCapabilities_specGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilities_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilities_Spec(gens map[string]gopter.Gen) {
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_AdditionalCapabilities_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalCapabilities_Status to AdditionalCapabilities_Status via AssignPropertiesToAdditionalCapabilities_Status & AssignPropertiesFromAdditionalCapabilities_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalCapabilities_Status, AdditionalCapabilities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalCapabilities_Status tests if a specific instance of AdditionalCapabilities_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAdditionalCapabilities_Status(subject AdditionalCapabilities_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AdditionalCapabilities_Status
	err := copied.AssignPropertiesToAdditionalCapabilities_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalCapabilities_Status
	err = actual.AssignPropertiesFromAdditionalCapabilities_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalCapabilities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilities_Status, AdditionalCapabilities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilities_Status runs a test to see if a specific instance of AdditionalCapabilities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilities_Status(subject AdditionalCapabilities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Status instances for property testing - lazily instantiated by
//AdditionalCapabilities_StatusGenerator()
var additionalCapabilities_statusGenerator gopter.Gen

// AdditionalCapabilities_StatusGenerator returns a generator of AdditionalCapabilities_Status instances for property testing.
func AdditionalCapabilities_StatusGenerator() gopter.Gen {
	if additionalCapabilities_statusGenerator != nil {
		return additionalCapabilities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilities_Status(generators)
	additionalCapabilities_statusGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Status{}), generators)

	return additionalCapabilities_statusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilities_Status(gens map[string]gopter.Gen) {
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_BillingProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BillingProfile_Spec to BillingProfile_Spec via AssignPropertiesToBillingProfile_Spec & AssignPropertiesFromBillingProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBillingProfile_Spec, BillingProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBillingProfile_Spec tests if a specific instance of BillingProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBillingProfile_Spec(subject BillingProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BillingProfile_Spec
	err := copied.AssignPropertiesToBillingProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BillingProfile_Spec
	err = actual.AssignPropertiesFromBillingProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BillingProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile_Spec, BillingProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile_Spec runs a test to see if a specific instance of BillingProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile_Spec(subject BillingProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Spec instances for property testing - lazily instantiated by
//BillingProfile_SpecGenerator()
var billingProfile_specGenerator gopter.Gen

// BillingProfile_SpecGenerator returns a generator of BillingProfile_Spec instances for property testing.
func BillingProfile_SpecGenerator() gopter.Gen {
	if billingProfile_specGenerator != nil {
		return billingProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile_Spec(generators)
	billingProfile_specGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Spec{}), generators)

	return billingProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile_Spec(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_BillingProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BillingProfile_Status to BillingProfile_Status via AssignPropertiesToBillingProfile_Status & AssignPropertiesFromBillingProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForBillingProfile_Status, BillingProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBillingProfile_Status tests if a specific instance of BillingProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBillingProfile_Status(subject BillingProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BillingProfile_Status
	err := copied.AssignPropertiesToBillingProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BillingProfile_Status
	err = actual.AssignPropertiesFromBillingProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BillingProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile_Status, BillingProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile_Status runs a test to see if a specific instance of BillingProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile_Status(subject BillingProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Status instances for property testing - lazily instantiated by
//BillingProfile_StatusGenerator()
var billingProfile_statusGenerator gopter.Gen

// BillingProfile_StatusGenerator returns a generator of BillingProfile_Status instances for property testing.
func BillingProfile_StatusGenerator() gopter.Gen {
	if billingProfile_statusGenerator != nil {
		return billingProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile_Status(generators)
	billingProfile_statusGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Status{}), generators)

	return billingProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile_Status(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiagnosticsProfile_Spec to DiagnosticsProfile_Spec via AssignPropertiesToDiagnosticsProfile_Spec & AssignPropertiesFromDiagnosticsProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiagnosticsProfile_Spec, DiagnosticsProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiagnosticsProfile_Spec tests if a specific instance of DiagnosticsProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiagnosticsProfile_Spec(subject DiagnosticsProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiagnosticsProfile_Spec
	err := copied.AssignPropertiesToDiagnosticsProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiagnosticsProfile_Spec
	err = actual.AssignPropertiesFromDiagnosticsProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiagnosticsProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile_Spec, DiagnosticsProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile_Spec runs a test to see if a specific instance of DiagnosticsProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile_Spec(subject DiagnosticsProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Spec instances for property testing - lazily instantiated by
//DiagnosticsProfile_SpecGenerator()
var diagnosticsProfile_specGenerator gopter.Gen

// DiagnosticsProfile_SpecGenerator returns a generator of DiagnosticsProfile_Spec instances for property testing.
func DiagnosticsProfile_SpecGenerator() gopter.Gen {
	if diagnosticsProfile_specGenerator != nil {
		return diagnosticsProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile_Spec(generators)
	diagnosticsProfile_specGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Spec{}), generators)

	return diagnosticsProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile_Spec(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnostics_SpecGenerator())
}

func Test_DiagnosticsProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiagnosticsProfile_Status to DiagnosticsProfile_Status via AssignPropertiesToDiagnosticsProfile_Status & AssignPropertiesFromDiagnosticsProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiagnosticsProfile_Status, DiagnosticsProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiagnosticsProfile_Status tests if a specific instance of DiagnosticsProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiagnosticsProfile_Status(subject DiagnosticsProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiagnosticsProfile_Status
	err := copied.AssignPropertiesToDiagnosticsProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiagnosticsProfile_Status
	err = actual.AssignPropertiesFromDiagnosticsProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiagnosticsProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile_Status, DiagnosticsProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile_Status runs a test to see if a specific instance of DiagnosticsProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile_Status(subject DiagnosticsProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Status instances for property testing - lazily instantiated by
//DiagnosticsProfile_StatusGenerator()
var diagnosticsProfile_statusGenerator gopter.Gen

// DiagnosticsProfile_StatusGenerator returns a generator of DiagnosticsProfile_Status instances for property testing.
func DiagnosticsProfile_StatusGenerator() gopter.Gen {
	if diagnosticsProfile_statusGenerator != nil {
		return diagnosticsProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile_Status(generators)
	diagnosticsProfile_statusGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Status{}), generators)

	return diagnosticsProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile_Status(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnostics_StatusGenerator())
}

func Test_ExtendedLocation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Spec to ExtendedLocation_Spec via AssignPropertiesToExtendedLocation_Spec & AssignPropertiesFromExtendedLocation_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Spec tests if a specific instance of ExtendedLocation_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ExtendedLocation_Spec
	err := copied.AssignPropertiesToExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Spec
	err = actual.AssignPropertiesFromExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Spec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocation_SpecGenerator()
var extendedLocation_specGenerator gopter.Gen

// ExtendedLocation_SpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocation_SpecGenerator() gopter.Gen {
	if extendedLocation_specGenerator != nil {
		return extendedLocation_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Spec(generators)
	extendedLocation_specGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocation_specGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_ExtendedLocation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Status to ExtendedLocation_Status via AssignPropertiesToExtendedLocation_Status & AssignPropertiesFromExtendedLocation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Status tests if a specific instance of ExtendedLocation_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ExtendedLocation_Status
	err := copied.AssignPropertiesToExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Status
	err = actual.AssignPropertiesFromExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Status runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocation_StatusGenerator()
var extendedLocation_statusGenerator gopter.Gen

// ExtendedLocation_StatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocation_StatusGenerator() gopter.Gen {
	if extendedLocation_statusGenerator != nil {
		return extendedLocation_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Status(generators)
	extendedLocation_statusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocation_statusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_StatusEdgeZone))
}

func Test_HardwareProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HardwareProfile_Spec to HardwareProfile_Spec via AssignPropertiesToHardwareProfile_Spec & AssignPropertiesFromHardwareProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForHardwareProfile_Spec, HardwareProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHardwareProfile_Spec tests if a specific instance of HardwareProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForHardwareProfile_Spec(subject HardwareProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.HardwareProfile_Spec
	err := copied.AssignPropertiesToHardwareProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HardwareProfile_Spec
	err = actual.AssignPropertiesFromHardwareProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HardwareProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile_Spec, HardwareProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile_Spec runs a test to see if a specific instance of HardwareProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile_Spec(subject HardwareProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Spec instances for property testing - lazily instantiated by
//HardwareProfile_SpecGenerator()
var hardwareProfile_specGenerator gopter.Gen

// HardwareProfile_SpecGenerator returns a generator of HardwareProfile_Spec instances for property testing.
func HardwareProfile_SpecGenerator() gopter.Gen {
	if hardwareProfile_specGenerator != nil {
		return hardwareProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile_Spec(generators)
	hardwareProfile_specGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Spec{}), generators)

	return hardwareProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile_Spec(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfile_VmSize_SpecBasic_A0,
		HardwareProfile_VmSize_SpecBasic_A1,
		HardwareProfile_VmSize_SpecBasic_A2,
		HardwareProfile_VmSize_SpecBasic_A3,
		HardwareProfile_VmSize_SpecBasic_A4,
		HardwareProfile_VmSize_SpecStandard_A0,
		HardwareProfile_VmSize_SpecStandard_A1,
		HardwareProfile_VmSize_SpecStandard_A10,
		HardwareProfile_VmSize_SpecStandard_A11,
		HardwareProfile_VmSize_SpecStandard_A1_V2,
		HardwareProfile_VmSize_SpecStandard_A2,
		HardwareProfile_VmSize_SpecStandard_A2M_V2,
		HardwareProfile_VmSize_SpecStandard_A2_V2,
		HardwareProfile_VmSize_SpecStandard_A3,
		HardwareProfile_VmSize_SpecStandard_A4,
		HardwareProfile_VmSize_SpecStandard_A4M_V2,
		HardwareProfile_VmSize_SpecStandard_A4_V2,
		HardwareProfile_VmSize_SpecStandard_A5,
		HardwareProfile_VmSize_SpecStandard_A6,
		HardwareProfile_VmSize_SpecStandard_A7,
		HardwareProfile_VmSize_SpecStandard_A8,
		HardwareProfile_VmSize_SpecStandard_A8M_V2,
		HardwareProfile_VmSize_SpecStandard_A8_V2,
		HardwareProfile_VmSize_SpecStandard_A9,
		HardwareProfile_VmSize_SpecStandard_B1Ms,
		HardwareProfile_VmSize_SpecStandard_B1S,
		HardwareProfile_VmSize_SpecStandard_B2Ms,
		HardwareProfile_VmSize_SpecStandard_B2S,
		HardwareProfile_VmSize_SpecStandard_B4Ms,
		HardwareProfile_VmSize_SpecStandard_B8Ms,
		HardwareProfile_VmSize_SpecStandard_D1,
		HardwareProfile_VmSize_SpecStandard_D11,
		HardwareProfile_VmSize_SpecStandard_D11_V2,
		HardwareProfile_VmSize_SpecStandard_D12,
		HardwareProfile_VmSize_SpecStandard_D12_V2,
		HardwareProfile_VmSize_SpecStandard_D13,
		HardwareProfile_VmSize_SpecStandard_D13_V2,
		HardwareProfile_VmSize_SpecStandard_D14,
		HardwareProfile_VmSize_SpecStandard_D14_V2,
		HardwareProfile_VmSize_SpecStandard_D15_V2,
		HardwareProfile_VmSize_SpecStandard_D16S_V3,
		HardwareProfile_VmSize_SpecStandard_D16_V3,
		HardwareProfile_VmSize_SpecStandard_D1_V2,
		HardwareProfile_VmSize_SpecStandard_D2,
		HardwareProfile_VmSize_SpecStandard_D2S_V3,
		HardwareProfile_VmSize_SpecStandard_D2_V2,
		HardwareProfile_VmSize_SpecStandard_D2_V3,
		HardwareProfile_VmSize_SpecStandard_D3,
		HardwareProfile_VmSize_SpecStandard_D32S_V3,
		HardwareProfile_VmSize_SpecStandard_D32_V3,
		HardwareProfile_VmSize_SpecStandard_D3_V2,
		HardwareProfile_VmSize_SpecStandard_D4,
		HardwareProfile_VmSize_SpecStandard_D4S_V3,
		HardwareProfile_VmSize_SpecStandard_D4_V2,
		HardwareProfile_VmSize_SpecStandard_D4_V3,
		HardwareProfile_VmSize_SpecStandard_D5_V2,
		HardwareProfile_VmSize_SpecStandard_D64S_V3,
		HardwareProfile_VmSize_SpecStandard_D64_V3,
		HardwareProfile_VmSize_SpecStandard_D8S_V3,
		HardwareProfile_VmSize_SpecStandard_D8_V3,
		HardwareProfile_VmSize_SpecStandard_DS1,
		HardwareProfile_VmSize_SpecStandard_DS11,
		HardwareProfile_VmSize_SpecStandard_DS11_V2,
		HardwareProfile_VmSize_SpecStandard_DS12,
		HardwareProfile_VmSize_SpecStandard_DS12_V2,
		HardwareProfile_VmSize_SpecStandard_DS13,
		HardwareProfile_VmSize_SpecStandard_DS132_V2,
		HardwareProfile_VmSize_SpecStandard_DS134_V2,
		HardwareProfile_VmSize_SpecStandard_DS13_V2,
		HardwareProfile_VmSize_SpecStandard_DS14,
		HardwareProfile_VmSize_SpecStandard_DS144_V2,
		HardwareProfile_VmSize_SpecStandard_DS148_V2,
		HardwareProfile_VmSize_SpecStandard_DS14_V2,
		HardwareProfile_VmSize_SpecStandard_DS15_V2,
		HardwareProfile_VmSize_SpecStandard_DS1_V2,
		HardwareProfile_VmSize_SpecStandard_DS2,
		HardwareProfile_VmSize_SpecStandard_DS2_V2,
		HardwareProfile_VmSize_SpecStandard_DS3,
		HardwareProfile_VmSize_SpecStandard_DS3_V2,
		HardwareProfile_VmSize_SpecStandard_DS4,
		HardwareProfile_VmSize_SpecStandard_DS4_V2,
		HardwareProfile_VmSize_SpecStandard_DS5_V2,
		HardwareProfile_VmSize_SpecStandard_E16S_V3,
		HardwareProfile_VmSize_SpecStandard_E16_V3,
		HardwareProfile_VmSize_SpecStandard_E2S_V3,
		HardwareProfile_VmSize_SpecStandard_E2_V3,
		HardwareProfile_VmSize_SpecStandard_E3216_V3,
		HardwareProfile_VmSize_SpecStandard_E328S_V3,
		HardwareProfile_VmSize_SpecStandard_E32S_V3,
		HardwareProfile_VmSize_SpecStandard_E32_V3,
		HardwareProfile_VmSize_SpecStandard_E4S_V3,
		HardwareProfile_VmSize_SpecStandard_E4_V3,
		HardwareProfile_VmSize_SpecStandard_E6416S_V3,
		HardwareProfile_VmSize_SpecStandard_E6432S_V3,
		HardwareProfile_VmSize_SpecStandard_E64S_V3,
		HardwareProfile_VmSize_SpecStandard_E64_V3,
		HardwareProfile_VmSize_SpecStandard_E8S_V3,
		HardwareProfile_VmSize_SpecStandard_E8_V3,
		HardwareProfile_VmSize_SpecStandard_F1,
		HardwareProfile_VmSize_SpecStandard_F16,
		HardwareProfile_VmSize_SpecStandard_F16S,
		HardwareProfile_VmSize_SpecStandard_F16S_V2,
		HardwareProfile_VmSize_SpecStandard_F1S,
		HardwareProfile_VmSize_SpecStandard_F2,
		HardwareProfile_VmSize_SpecStandard_F2S,
		HardwareProfile_VmSize_SpecStandard_F2S_V2,
		HardwareProfile_VmSize_SpecStandard_F32S_V2,
		HardwareProfile_VmSize_SpecStandard_F4,
		HardwareProfile_VmSize_SpecStandard_F4S,
		HardwareProfile_VmSize_SpecStandard_F4S_V2,
		HardwareProfile_VmSize_SpecStandard_F64S_V2,
		HardwareProfile_VmSize_SpecStandard_F72S_V2,
		HardwareProfile_VmSize_SpecStandard_F8,
		HardwareProfile_VmSize_SpecStandard_F8S,
		HardwareProfile_VmSize_SpecStandard_F8S_V2,
		HardwareProfile_VmSize_SpecStandard_G1,
		HardwareProfile_VmSize_SpecStandard_G2,
		HardwareProfile_VmSize_SpecStandard_G3,
		HardwareProfile_VmSize_SpecStandard_G4,
		HardwareProfile_VmSize_SpecStandard_G5,
		HardwareProfile_VmSize_SpecStandard_GS1,
		HardwareProfile_VmSize_SpecStandard_GS2,
		HardwareProfile_VmSize_SpecStandard_GS3,
		HardwareProfile_VmSize_SpecStandard_GS4,
		HardwareProfile_VmSize_SpecStandard_GS44,
		HardwareProfile_VmSize_SpecStandard_GS48,
		HardwareProfile_VmSize_SpecStandard_GS5,
		HardwareProfile_VmSize_SpecStandard_GS516,
		HardwareProfile_VmSize_SpecStandard_GS58,
		HardwareProfile_VmSize_SpecStandard_H16,
		HardwareProfile_VmSize_SpecStandard_H16M,
		HardwareProfile_VmSize_SpecStandard_H16Mr,
		HardwareProfile_VmSize_SpecStandard_H16R,
		HardwareProfile_VmSize_SpecStandard_H8,
		HardwareProfile_VmSize_SpecStandard_H8M,
		HardwareProfile_VmSize_SpecStandard_L16S,
		HardwareProfile_VmSize_SpecStandard_L32S,
		HardwareProfile_VmSize_SpecStandard_L4S,
		HardwareProfile_VmSize_SpecStandard_L8S,
		HardwareProfile_VmSize_SpecStandard_M12832Ms,
		HardwareProfile_VmSize_SpecStandard_M12864Ms,
		HardwareProfile_VmSize_SpecStandard_M128Ms,
		HardwareProfile_VmSize_SpecStandard_M128S,
		HardwareProfile_VmSize_SpecStandard_M6416Ms,
		HardwareProfile_VmSize_SpecStandard_M6432Ms,
		HardwareProfile_VmSize_SpecStandard_M64Ms,
		HardwareProfile_VmSize_SpecStandard_M64S,
		HardwareProfile_VmSize_SpecStandard_NC12,
		HardwareProfile_VmSize_SpecStandard_NC12S_V2,
		HardwareProfile_VmSize_SpecStandard_NC12S_V3,
		HardwareProfile_VmSize_SpecStandard_NC24,
		HardwareProfile_VmSize_SpecStandard_NC24R,
		HardwareProfile_VmSize_SpecStandard_NC24Rs_V2,
		HardwareProfile_VmSize_SpecStandard_NC24Rs_V3,
		HardwareProfile_VmSize_SpecStandard_NC24S_V2,
		HardwareProfile_VmSize_SpecStandard_NC24S_V3,
		HardwareProfile_VmSize_SpecStandard_NC6,
		HardwareProfile_VmSize_SpecStandard_NC6S_V2,
		HardwareProfile_VmSize_SpecStandard_NC6S_V3,
		HardwareProfile_VmSize_SpecStandard_ND12S,
		HardwareProfile_VmSize_SpecStandard_ND24Rs,
		HardwareProfile_VmSize_SpecStandard_ND24S,
		HardwareProfile_VmSize_SpecStandard_ND6S,
		HardwareProfile_VmSize_SpecStandard_NV12,
		HardwareProfile_VmSize_SpecStandard_NV24,
		HardwareProfile_VmSize_SpecStandard_NV6))
}

func Test_HardwareProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HardwareProfile_Status to HardwareProfile_Status via AssignPropertiesToHardwareProfile_Status & AssignPropertiesFromHardwareProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForHardwareProfile_Status, HardwareProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHardwareProfile_Status tests if a specific instance of HardwareProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForHardwareProfile_Status(subject HardwareProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.HardwareProfile_Status
	err := copied.AssignPropertiesToHardwareProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HardwareProfile_Status
	err = actual.AssignPropertiesFromHardwareProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HardwareProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile_Status, HardwareProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile_Status runs a test to see if a specific instance of HardwareProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile_Status(subject HardwareProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Status instances for property testing - lazily instantiated by
//HardwareProfile_StatusGenerator()
var hardwareProfile_statusGenerator gopter.Gen

// HardwareProfile_StatusGenerator returns a generator of HardwareProfile_Status instances for property testing.
func HardwareProfile_StatusGenerator() gopter.Gen {
	if hardwareProfile_statusGenerator != nil {
		return hardwareProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile_Status(generators)
	hardwareProfile_statusGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Status{}), generators)

	return hardwareProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile_Status(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfile_VmSize_StatusBasic_A0,
		HardwareProfile_VmSize_StatusBasic_A1,
		HardwareProfile_VmSize_StatusBasic_A2,
		HardwareProfile_VmSize_StatusBasic_A3,
		HardwareProfile_VmSize_StatusBasic_A4,
		HardwareProfile_VmSize_StatusStandard_A0,
		HardwareProfile_VmSize_StatusStandard_A1,
		HardwareProfile_VmSize_StatusStandard_A10,
		HardwareProfile_VmSize_StatusStandard_A11,
		HardwareProfile_VmSize_StatusStandard_A1_V2,
		HardwareProfile_VmSize_StatusStandard_A2,
		HardwareProfile_VmSize_StatusStandard_A2M_V2,
		HardwareProfile_VmSize_StatusStandard_A2_V2,
		HardwareProfile_VmSize_StatusStandard_A3,
		HardwareProfile_VmSize_StatusStandard_A4,
		HardwareProfile_VmSize_StatusStandard_A4M_V2,
		HardwareProfile_VmSize_StatusStandard_A4_V2,
		HardwareProfile_VmSize_StatusStandard_A5,
		HardwareProfile_VmSize_StatusStandard_A6,
		HardwareProfile_VmSize_StatusStandard_A7,
		HardwareProfile_VmSize_StatusStandard_A8,
		HardwareProfile_VmSize_StatusStandard_A8M_V2,
		HardwareProfile_VmSize_StatusStandard_A8_V2,
		HardwareProfile_VmSize_StatusStandard_A9,
		HardwareProfile_VmSize_StatusStandard_B1Ms,
		HardwareProfile_VmSize_StatusStandard_B1S,
		HardwareProfile_VmSize_StatusStandard_B2Ms,
		HardwareProfile_VmSize_StatusStandard_B2S,
		HardwareProfile_VmSize_StatusStandard_B4Ms,
		HardwareProfile_VmSize_StatusStandard_B8Ms,
		HardwareProfile_VmSize_StatusStandard_D1,
		HardwareProfile_VmSize_StatusStandard_D11,
		HardwareProfile_VmSize_StatusStandard_D11_V2,
		HardwareProfile_VmSize_StatusStandard_D12,
		HardwareProfile_VmSize_StatusStandard_D12_V2,
		HardwareProfile_VmSize_StatusStandard_D13,
		HardwareProfile_VmSize_StatusStandard_D13_V2,
		HardwareProfile_VmSize_StatusStandard_D14,
		HardwareProfile_VmSize_StatusStandard_D14_V2,
		HardwareProfile_VmSize_StatusStandard_D15_V2,
		HardwareProfile_VmSize_StatusStandard_D16S_V3,
		HardwareProfile_VmSize_StatusStandard_D16_V3,
		HardwareProfile_VmSize_StatusStandard_D1_V2,
		HardwareProfile_VmSize_StatusStandard_D2,
		HardwareProfile_VmSize_StatusStandard_D2S_V3,
		HardwareProfile_VmSize_StatusStandard_D2_V2,
		HardwareProfile_VmSize_StatusStandard_D2_V3,
		HardwareProfile_VmSize_StatusStandard_D3,
		HardwareProfile_VmSize_StatusStandard_D32S_V3,
		HardwareProfile_VmSize_StatusStandard_D32_V3,
		HardwareProfile_VmSize_StatusStandard_D3_V2,
		HardwareProfile_VmSize_StatusStandard_D4,
		HardwareProfile_VmSize_StatusStandard_D4S_V3,
		HardwareProfile_VmSize_StatusStandard_D4_V2,
		HardwareProfile_VmSize_StatusStandard_D4_V3,
		HardwareProfile_VmSize_StatusStandard_D5_V2,
		HardwareProfile_VmSize_StatusStandard_D64S_V3,
		HardwareProfile_VmSize_StatusStandard_D64_V3,
		HardwareProfile_VmSize_StatusStandard_D8S_V3,
		HardwareProfile_VmSize_StatusStandard_D8_V3,
		HardwareProfile_VmSize_StatusStandard_DS1,
		HardwareProfile_VmSize_StatusStandard_DS11,
		HardwareProfile_VmSize_StatusStandard_DS11_V2,
		HardwareProfile_VmSize_StatusStandard_DS12,
		HardwareProfile_VmSize_StatusStandard_DS12_V2,
		HardwareProfile_VmSize_StatusStandard_DS13,
		HardwareProfile_VmSize_StatusStandard_DS132_V2,
		HardwareProfile_VmSize_StatusStandard_DS134_V2,
		HardwareProfile_VmSize_StatusStandard_DS13_V2,
		HardwareProfile_VmSize_StatusStandard_DS14,
		HardwareProfile_VmSize_StatusStandard_DS144_V2,
		HardwareProfile_VmSize_StatusStandard_DS148_V2,
		HardwareProfile_VmSize_StatusStandard_DS14_V2,
		HardwareProfile_VmSize_StatusStandard_DS15_V2,
		HardwareProfile_VmSize_StatusStandard_DS1_V2,
		HardwareProfile_VmSize_StatusStandard_DS2,
		HardwareProfile_VmSize_StatusStandard_DS2_V2,
		HardwareProfile_VmSize_StatusStandard_DS3,
		HardwareProfile_VmSize_StatusStandard_DS3_V2,
		HardwareProfile_VmSize_StatusStandard_DS4,
		HardwareProfile_VmSize_StatusStandard_DS4_V2,
		HardwareProfile_VmSize_StatusStandard_DS5_V2,
		HardwareProfile_VmSize_StatusStandard_E16S_V3,
		HardwareProfile_VmSize_StatusStandard_E16_V3,
		HardwareProfile_VmSize_StatusStandard_E2S_V3,
		HardwareProfile_VmSize_StatusStandard_E2_V3,
		HardwareProfile_VmSize_StatusStandard_E3216_V3,
		HardwareProfile_VmSize_StatusStandard_E328S_V3,
		HardwareProfile_VmSize_StatusStandard_E32S_V3,
		HardwareProfile_VmSize_StatusStandard_E32_V3,
		HardwareProfile_VmSize_StatusStandard_E4S_V3,
		HardwareProfile_VmSize_StatusStandard_E4_V3,
		HardwareProfile_VmSize_StatusStandard_E6416S_V3,
		HardwareProfile_VmSize_StatusStandard_E6432S_V3,
		HardwareProfile_VmSize_StatusStandard_E64S_V3,
		HardwareProfile_VmSize_StatusStandard_E64_V3,
		HardwareProfile_VmSize_StatusStandard_E8S_V3,
		HardwareProfile_VmSize_StatusStandard_E8_V3,
		HardwareProfile_VmSize_StatusStandard_F1,
		HardwareProfile_VmSize_StatusStandard_F16,
		HardwareProfile_VmSize_StatusStandard_F16S,
		HardwareProfile_VmSize_StatusStandard_F16S_V2,
		HardwareProfile_VmSize_StatusStandard_F1S,
		HardwareProfile_VmSize_StatusStandard_F2,
		HardwareProfile_VmSize_StatusStandard_F2S,
		HardwareProfile_VmSize_StatusStandard_F2S_V2,
		HardwareProfile_VmSize_StatusStandard_F32S_V2,
		HardwareProfile_VmSize_StatusStandard_F4,
		HardwareProfile_VmSize_StatusStandard_F4S,
		HardwareProfile_VmSize_StatusStandard_F4S_V2,
		HardwareProfile_VmSize_StatusStandard_F64S_V2,
		HardwareProfile_VmSize_StatusStandard_F72S_V2,
		HardwareProfile_VmSize_StatusStandard_F8,
		HardwareProfile_VmSize_StatusStandard_F8S,
		HardwareProfile_VmSize_StatusStandard_F8S_V2,
		HardwareProfile_VmSize_StatusStandard_G1,
		HardwareProfile_VmSize_StatusStandard_G2,
		HardwareProfile_VmSize_StatusStandard_G3,
		HardwareProfile_VmSize_StatusStandard_G4,
		HardwareProfile_VmSize_StatusStandard_G5,
		HardwareProfile_VmSize_StatusStandard_GS1,
		HardwareProfile_VmSize_StatusStandard_GS2,
		HardwareProfile_VmSize_StatusStandard_GS3,
		HardwareProfile_VmSize_StatusStandard_GS4,
		HardwareProfile_VmSize_StatusStandard_GS44,
		HardwareProfile_VmSize_StatusStandard_GS48,
		HardwareProfile_VmSize_StatusStandard_GS5,
		HardwareProfile_VmSize_StatusStandard_GS516,
		HardwareProfile_VmSize_StatusStandard_GS58,
		HardwareProfile_VmSize_StatusStandard_H16,
		HardwareProfile_VmSize_StatusStandard_H16M,
		HardwareProfile_VmSize_StatusStandard_H16Mr,
		HardwareProfile_VmSize_StatusStandard_H16R,
		HardwareProfile_VmSize_StatusStandard_H8,
		HardwareProfile_VmSize_StatusStandard_H8M,
		HardwareProfile_VmSize_StatusStandard_L16S,
		HardwareProfile_VmSize_StatusStandard_L32S,
		HardwareProfile_VmSize_StatusStandard_L4S,
		HardwareProfile_VmSize_StatusStandard_L8S,
		HardwareProfile_VmSize_StatusStandard_M12832Ms,
		HardwareProfile_VmSize_StatusStandard_M12864Ms,
		HardwareProfile_VmSize_StatusStandard_M128Ms,
		HardwareProfile_VmSize_StatusStandard_M128S,
		HardwareProfile_VmSize_StatusStandard_M6416Ms,
		HardwareProfile_VmSize_StatusStandard_M6432Ms,
		HardwareProfile_VmSize_StatusStandard_M64Ms,
		HardwareProfile_VmSize_StatusStandard_M64S,
		HardwareProfile_VmSize_StatusStandard_NC12,
		HardwareProfile_VmSize_StatusStandard_NC12S_V2,
		HardwareProfile_VmSize_StatusStandard_NC12S_V3,
		HardwareProfile_VmSize_StatusStandard_NC24,
		HardwareProfile_VmSize_StatusStandard_NC24R,
		HardwareProfile_VmSize_StatusStandard_NC24Rs_V2,
		HardwareProfile_VmSize_StatusStandard_NC24Rs_V3,
		HardwareProfile_VmSize_StatusStandard_NC24S_V2,
		HardwareProfile_VmSize_StatusStandard_NC24S_V3,
		HardwareProfile_VmSize_StatusStandard_NC6,
		HardwareProfile_VmSize_StatusStandard_NC6S_V2,
		HardwareProfile_VmSize_StatusStandard_NC6S_V3,
		HardwareProfile_VmSize_StatusStandard_ND12S,
		HardwareProfile_VmSize_StatusStandard_ND24Rs,
		HardwareProfile_VmSize_StatusStandard_ND24S,
		HardwareProfile_VmSize_StatusStandard_ND6S,
		HardwareProfile_VmSize_StatusStandard_NV12,
		HardwareProfile_VmSize_StatusStandard_NV24,
		HardwareProfile_VmSize_StatusStandard_NV6))
}

func Test_NetworkProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkProfile_Spec to NetworkProfile_Spec via AssignPropertiesToNetworkProfile_Spec & AssignPropertiesFromNetworkProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkProfile_Spec, NetworkProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkProfile_Spec tests if a specific instance of NetworkProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForNetworkProfile_Spec(subject NetworkProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.NetworkProfile_Spec
	err := copied.AssignPropertiesToNetworkProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkProfile_Spec
	err = actual.AssignPropertiesFromNetworkProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_Spec, NetworkProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_Spec runs a test to see if a specific instance of NetworkProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_Spec(subject NetworkProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Spec instances for property testing - lazily instantiated by
//NetworkProfile_SpecGenerator()
var networkProfile_specGenerator gopter.Gen

// NetworkProfile_SpecGenerator returns a generator of NetworkProfile_Spec instances for property testing.
func NetworkProfile_SpecGenerator() gopter.Gen {
	if networkProfile_specGenerator != nil {
		return networkProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfile_Spec(generators)
	networkProfile_specGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Spec{}), generators)

	return networkProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_Spec(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReference_SpecGenerator())
}

func Test_NetworkProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkProfile_Status to NetworkProfile_Status via AssignPropertiesToNetworkProfile_Status & AssignPropertiesFromNetworkProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkProfile_Status, NetworkProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkProfile_Status tests if a specific instance of NetworkProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForNetworkProfile_Status(subject NetworkProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.NetworkProfile_Status
	err := copied.AssignPropertiesToNetworkProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkProfile_Status
	err = actual.AssignPropertiesFromNetworkProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_Status, NetworkProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_Status runs a test to see if a specific instance of NetworkProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_Status(subject NetworkProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Status instances for property testing - lazily instantiated by
//NetworkProfile_StatusGenerator()
var networkProfile_statusGenerator gopter.Gen

// NetworkProfile_StatusGenerator returns a generator of NetworkProfile_Status instances for property testing.
func NetworkProfile_StatusGenerator() gopter.Gen {
	if networkProfile_statusGenerator != nil {
		return networkProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfile_Status(generators)
	networkProfile_statusGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Status{}), generators)

	return networkProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_Status(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReference_StatusGenerator())
}

func Test_OSProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OSProfile_Spec to OSProfile_Spec via AssignPropertiesToOSProfile_Spec & AssignPropertiesFromOSProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForOSProfile_Spec, OSProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOSProfile_Spec tests if a specific instance of OSProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForOSProfile_Spec(subject OSProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.OSProfile_Spec
	err := copied.AssignPropertiesToOSProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OSProfile_Spec
	err = actual.AssignPropertiesFromOSProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OSProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfile_Spec, OSProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfile_Spec runs a test to see if a specific instance of OSProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfile_Spec(subject OSProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Spec instances for property testing - lazily instantiated by OSProfile_SpecGenerator()
var osProfile_specGenerator gopter.Gen

// OSProfile_SpecGenerator returns a generator of OSProfile_Spec instances for property testing.
// We first initialize osProfile_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfile_SpecGenerator() gopter.Gen {
	if osProfile_specGenerator != nil {
		return osProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_Spec(generators)
	osProfile_specGenerator = gen.Struct(reflect.TypeOf(OSProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_Spec(generators)
	AddRelatedPropertyGeneratorsForOSProfile_Spec(generators)
	osProfile_specGenerator = gen.Struct(reflect.TypeOf(OSProfile_Spec{}), generators)

	return osProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForOSProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfile_Spec(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfile_Spec(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_SpecGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_SpecGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_SpecGenerator())
}

func Test_OSProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OSProfile_Status to OSProfile_Status via AssignPropertiesToOSProfile_Status & AssignPropertiesFromOSProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForOSProfile_Status, OSProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOSProfile_Status tests if a specific instance of OSProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForOSProfile_Status(subject OSProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.OSProfile_Status
	err := copied.AssignPropertiesToOSProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OSProfile_Status
	err = actual.AssignPropertiesFromOSProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OSProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfile_Status, OSProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfile_Status runs a test to see if a specific instance of OSProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfile_Status(subject OSProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Status instances for property testing - lazily instantiated by OSProfile_StatusGenerator()
var osProfile_statusGenerator gopter.Gen

// OSProfile_StatusGenerator returns a generator of OSProfile_Status instances for property testing.
// We first initialize osProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfile_StatusGenerator() gopter.Gen {
	if osProfile_statusGenerator != nil {
		return osProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_Status(generators)
	osProfile_statusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_Status(generators)
	AddRelatedPropertyGeneratorsForOSProfile_Status(generators)
	osProfile_statusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	return osProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForOSProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfile_Status(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfile_Status(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_StatusGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_StatusGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_StatusGenerator())
}

func Test_Plan_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Plan_Spec to Plan_Spec via AssignPropertiesToPlan_Spec & AssignPropertiesFromPlan_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlan_Spec, Plan_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlan_Spec tests if a specific instance of Plan_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForPlan_Spec(subject Plan_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.Plan_Spec
	err := copied.AssignPropertiesToPlan_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Plan_Spec
	err = actual.AssignPropertiesFromPlan_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Plan_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan_Spec, Plan_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan_Spec runs a test to see if a specific instance of Plan_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan_Spec(subject Plan_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Spec instances for property testing - lazily instantiated by Plan_SpecGenerator()
var plan_specGenerator gopter.Gen

// Plan_SpecGenerator returns a generator of Plan_Spec instances for property testing.
func Plan_SpecGenerator() gopter.Gen {
	if plan_specGenerator != nil {
		return plan_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan_Spec(generators)
	plan_specGenerator = gen.Struct(reflect.TypeOf(Plan_Spec{}), generators)

	return plan_specGenerator
}

// AddIndependentPropertyGeneratorsForPlan_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_Plan_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Plan_Status to Plan_Status via AssignPropertiesToPlan_Status & AssignPropertiesFromPlan_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlan_Status, Plan_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlan_Status tests if a specific instance of Plan_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForPlan_Status(subject Plan_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.Plan_Status
	err := copied.AssignPropertiesToPlan_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Plan_Status
	err = actual.AssignPropertiesFromPlan_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Plan_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan_Status, Plan_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan_Status runs a test to see if a specific instance of Plan_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan_Status(subject Plan_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Status instances for property testing - lazily instantiated by Plan_StatusGenerator()
var plan_statusGenerator gopter.Gen

// Plan_StatusGenerator returns a generator of Plan_Status instances for property testing.
func Plan_StatusGenerator() gopter.Gen {
	if plan_statusGenerator != nil {
		return plan_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan_Status(generators)
	plan_statusGenerator = gen.Struct(reflect.TypeOf(Plan_Status{}), generators)

	return plan_statusGenerator
}

// AddIndependentPropertyGeneratorsForPlan_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecurityProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecurityProfile_Spec to SecurityProfile_Spec via AssignPropertiesToSecurityProfile_Spec & AssignPropertiesFromSecurityProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecurityProfile_Spec, SecurityProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecurityProfile_Spec tests if a specific instance of SecurityProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSecurityProfile_Spec(subject SecurityProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SecurityProfile_Spec
	err := copied.AssignPropertiesToSecurityProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecurityProfile_Spec
	err = actual.AssignPropertiesFromSecurityProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecurityProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile_Spec, SecurityProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile_Spec runs a test to see if a specific instance of SecurityProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile_Spec(subject SecurityProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Spec instances for property testing - lazily instantiated by
//SecurityProfile_SpecGenerator()
var securityProfile_specGenerator gopter.Gen

// SecurityProfile_SpecGenerator returns a generator of SecurityProfile_Spec instances for property testing.
// We first initialize securityProfile_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfile_SpecGenerator() gopter.Gen {
	if securityProfile_specGenerator != nil {
		return securityProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_Spec(generators)
	securityProfile_specGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_Spec(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile_Spec(generators)
	securityProfile_specGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Spec{}), generators)

	return securityProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile_Spec(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfile_SecurityType_SpecTrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile_Spec(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettings_SpecGenerator())
}

func Test_SecurityProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecurityProfile_Status to SecurityProfile_Status via AssignPropertiesToSecurityProfile_Status & AssignPropertiesFromSecurityProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecurityProfile_Status, SecurityProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecurityProfile_Status tests if a specific instance of SecurityProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSecurityProfile_Status(subject SecurityProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SecurityProfile_Status
	err := copied.AssignPropertiesToSecurityProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecurityProfile_Status
	err = actual.AssignPropertiesFromSecurityProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecurityProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile_Status, SecurityProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile_Status runs a test to see if a specific instance of SecurityProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile_Status(subject SecurityProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Status instances for property testing - lazily instantiated by
//SecurityProfile_StatusGenerator()
var securityProfile_statusGenerator gopter.Gen

// SecurityProfile_StatusGenerator returns a generator of SecurityProfile_Status instances for property testing.
// We first initialize securityProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfile_StatusGenerator() gopter.Gen {
	if securityProfile_statusGenerator != nil {
		return securityProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_Status(generators)
	securityProfile_statusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_Status(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile_Status(generators)
	securityProfile_statusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	return securityProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile_Status(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfile_SecurityType_StatusTrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile_Status(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettings_StatusGenerator())
}

func Test_StorageProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageProfile_Spec to StorageProfile_Spec via AssignPropertiesToStorageProfile_Spec & AssignPropertiesFromStorageProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageProfile_Spec, StorageProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageProfile_Spec tests if a specific instance of StorageProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForStorageProfile_Spec(subject StorageProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.StorageProfile_Spec
	err := copied.AssignPropertiesToStorageProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageProfile_Spec
	err = actual.AssignPropertiesFromStorageProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile_Spec, StorageProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile_Spec runs a test to see if a specific instance of StorageProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile_Spec(subject StorageProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Spec instances for property testing - lazily instantiated by
//StorageProfile_SpecGenerator()
var storageProfile_specGenerator gopter.Gen

// StorageProfile_SpecGenerator returns a generator of StorageProfile_Spec instances for property testing.
func StorageProfile_SpecGenerator() gopter.Gen {
	if storageProfile_specGenerator != nil {
		return storageProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile_Spec(generators)
	storageProfile_specGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Spec{}), generators)

	return storageProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile_Spec(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDisk_SpecGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_SpecGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDisk_SpecGenerator())
}

func Test_StorageProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageProfile_Status to StorageProfile_Status via AssignPropertiesToStorageProfile_Status & AssignPropertiesFromStorageProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageProfile_Status, StorageProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageProfile_Status tests if a specific instance of StorageProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForStorageProfile_Status(subject StorageProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.StorageProfile_Status
	err := copied.AssignPropertiesToStorageProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageProfile_Status
	err = actual.AssignPropertiesFromStorageProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile_Status, StorageProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile_Status runs a test to see if a specific instance of StorageProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile_Status(subject StorageProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Status instances for property testing - lazily instantiated by
//StorageProfile_StatusGenerator()
var storageProfile_statusGenerator gopter.Gen

// StorageProfile_StatusGenerator returns a generator of StorageProfile_Status instances for property testing.
func StorageProfile_StatusGenerator() gopter.Gen {
	if storageProfile_statusGenerator != nil {
		return storageProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile_Status(generators)
	storageProfile_statusGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Status{}), generators)

	return storageProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile_Status(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDisk_StatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_StatusGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDisk_StatusGenerator())
}

func Test_SubResource_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_Spec to SubResource_Spec via AssignPropertiesToSubResource_Spec & AssignPropertiesFromSubResource_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource_Spec, SubResource_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource_Spec tests if a specific instance of SubResource_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSubResource_Spec(subject SubResource_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SubResource_Spec
	err := copied.AssignPropertiesToSubResource_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_Spec
	err = actual.AssignPropertiesFromSubResource_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_Spec, SubResource_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_Spec runs a test to see if a specific instance of SubResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_Spec(subject SubResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Spec instances for property testing - lazily instantiated by SubResource_SpecGenerator()
var subResource_specGenerator gopter.Gen

// SubResource_SpecGenerator returns a generator of SubResource_Spec instances for property testing.
func SubResource_SpecGenerator() gopter.Gen {
	if subResource_specGenerator != nil {
		return subResource_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResource_specGenerator = gen.Struct(reflect.TypeOf(SubResource_Spec{}), generators)

	return subResource_specGenerator
}

func Test_SubResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_Status to SubResource_Status via AssignPropertiesToSubResource_Status & AssignPropertiesFromSubResource_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource_Status, SubResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource_Status tests if a specific instance of SubResource_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSubResource_Status(subject SubResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SubResource_Status
	err := copied.AssignPropertiesToSubResource_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_Status
	err = actual.AssignPropertiesFromSubResource_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_Status, SubResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_Status runs a test to see if a specific instance of SubResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_Status(subject SubResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Status instances for property testing - lazily instantiated by SubResource_StatusGenerator()
var subResource_statusGenerator gopter.Gen

// SubResource_StatusGenerator returns a generator of SubResource_Status instances for property testing.
func SubResource_StatusGenerator() gopter.Gen {
	if subResource_statusGenerator != nil {
		return subResource_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_Status(generators)
	subResource_statusGenerator = gen.Struct(reflect.TypeOf(SubResource_Status{}), generators)

	return subResource_statusGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtension_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineExtension_Status to VirtualMachineExtension_Status via AssignPropertiesToVirtualMachineExtension_Status & AssignPropertiesFromVirtualMachineExtension_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineExtension_Status, VirtualMachineExtension_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineExtension_Status tests if a specific instance of VirtualMachineExtension_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineExtension_Status(subject VirtualMachineExtension_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineExtension_Status
	err := copied.AssignPropertiesToVirtualMachineExtension_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineExtension_Status
	err = actual.AssignPropertiesFromVirtualMachineExtension_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineExtension_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtension_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtension_Status, VirtualMachineExtension_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtension_Status runs a test to see if a specific instance of VirtualMachineExtension_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtension_Status(subject VirtualMachineExtension_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtension_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtension_Status instances for property testing - lazily instantiated by
//VirtualMachineExtension_StatusGenerator()
var virtualMachineExtension_statusGenerator gopter.Gen

// VirtualMachineExtension_StatusGenerator returns a generator of VirtualMachineExtension_Status instances for property testing.
// We first initialize virtualMachineExtension_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtension_StatusGenerator() gopter.Gen {
	if virtualMachineExtension_statusGenerator != nil {
		return virtualMachineExtension_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtension_Status(generators)
	virtualMachineExtension_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtension_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtension_Status(generators)
	virtualMachineExtension_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	return virtualMachineExtension_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtension_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtension_Status(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["ForceUpdateTag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtension_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtension_Status(gens map[string]gopter.Gen) {
	gens["InstanceView"] = gen.PtrOf(VirtualMachineExtensionInstanceView_StatusGenerator())
}

func Test_VirtualMachineIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineIdentity_Spec to VirtualMachineIdentity_Spec via AssignPropertiesToVirtualMachineIdentity_Spec & AssignPropertiesFromVirtualMachineIdentity_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineIdentity_Spec, VirtualMachineIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineIdentity_Spec tests if a specific instance of VirtualMachineIdentity_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineIdentity_Spec(subject VirtualMachineIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineIdentity_Spec
	err := copied.AssignPropertiesToVirtualMachineIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineIdentity_Spec
	err = actual.AssignPropertiesFromVirtualMachineIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_Spec, VirtualMachineIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_Spec runs a test to see if a specific instance of VirtualMachineIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_Spec(subject VirtualMachineIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Spec instances for property testing - lazily instantiated by
//VirtualMachineIdentity_SpecGenerator()
var virtualMachineIdentity_specGenerator gopter.Gen

// VirtualMachineIdentity_SpecGenerator returns a generator of VirtualMachineIdentity_Spec instances for property testing.
func VirtualMachineIdentity_SpecGenerator() gopter.Gen {
	if virtualMachineIdentity_specGenerator != nil {
		return virtualMachineIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Spec(generators)
	virtualMachineIdentity_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Spec{}), generators)

	return virtualMachineIdentity_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentity_Type_SpecNone,
		VirtualMachineIdentity_Type_SpecSystemAssigned,
		VirtualMachineIdentity_Type_SpecSystemAssignedUserAssigned,
		VirtualMachineIdentity_Type_SpecUserAssigned))
}

func Test_VirtualMachineIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineIdentity_Status to VirtualMachineIdentity_Status via AssignPropertiesToVirtualMachineIdentity_Status & AssignPropertiesFromVirtualMachineIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineIdentity_Status, VirtualMachineIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineIdentity_Status tests if a specific instance of VirtualMachineIdentity_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineIdentity_Status(subject VirtualMachineIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineIdentity_Status
	err := copied.AssignPropertiesToVirtualMachineIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineIdentity_Status
	err = actual.AssignPropertiesFromVirtualMachineIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_Status, VirtualMachineIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_Status runs a test to see if a specific instance of VirtualMachineIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_Status(subject VirtualMachineIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Status instances for property testing - lazily instantiated by
//VirtualMachineIdentity_StatusGenerator()
var virtualMachineIdentity_statusGenerator gopter.Gen

// VirtualMachineIdentity_StatusGenerator returns a generator of VirtualMachineIdentity_Status instances for property testing.
// We first initialize virtualMachineIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineIdentity_StatusGenerator() gopter.Gen {
	if virtualMachineIdentity_statusGenerator != nil {
		return virtualMachineIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Status(generators)
	virtualMachineIdentity_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineIdentity_Status(generators)
	virtualMachineIdentity_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	return virtualMachineIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentity_Type_StatusNone,
		VirtualMachineIdentity_Type_StatusSystemAssigned,
		VirtualMachineIdentity_Type_StatusSystemAssignedUserAssigned,
		VirtualMachineIdentity_Type_StatusUserAssigned))
}

// AddRelatedPropertyGeneratorsForVirtualMachineIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator())
}

func Test_VirtualMachineInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineInstanceView_Status to VirtualMachineInstanceView_Status via AssignPropertiesToVirtualMachineInstanceView_Status & AssignPropertiesFromVirtualMachineInstanceView_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineInstanceView_Status, VirtualMachineInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineInstanceView_Status tests if a specific instance of VirtualMachineInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineInstanceView_Status(subject VirtualMachineInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineInstanceView_Status
	err := copied.AssignPropertiesToVirtualMachineInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineInstanceView_Status
	err = actual.AssignPropertiesFromVirtualMachineInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceView_Status, VirtualMachineInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceView_Status runs a test to see if a specific instance of VirtualMachineInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceView_Status(subject VirtualMachineInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineInstanceView_StatusGenerator()
var virtualMachineInstanceView_statusGenerator gopter.Gen

// VirtualMachineInstanceView_StatusGenerator returns a generator of VirtualMachineInstanceView_Status instances for property testing.
// We first initialize virtualMachineInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceView_StatusGenerator() gopter.Gen {
	if virtualMachineInstanceView_statusGenerator != nil {
		return virtualMachineInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_Status(generators)
	virtualMachineInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_Status(generators)
	virtualMachineInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	return virtualMachineInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_Status(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(VirtualMachineInstanceView_HyperVGeneration_StatusV1, VirtualMachineInstanceView_HyperVGeneration_StatusV2))
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_Status(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceView_StatusGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceView_StatusGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceView_StatusGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatus_StatusGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatus_StatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceView_StatusGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatus_StatusGenerator())
}

func Test_BootDiagnosticsInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BootDiagnosticsInstanceView_Status to BootDiagnosticsInstanceView_Status via AssignPropertiesToBootDiagnosticsInstanceView_Status & AssignPropertiesFromBootDiagnosticsInstanceView_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForBootDiagnosticsInstanceView_Status, BootDiagnosticsInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBootDiagnosticsInstanceView_Status tests if a specific instance of BootDiagnosticsInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBootDiagnosticsInstanceView_Status(subject BootDiagnosticsInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BootDiagnosticsInstanceView_Status
	err := copied.AssignPropertiesToBootDiagnosticsInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BootDiagnosticsInstanceView_Status
	err = actual.AssignPropertiesFromBootDiagnosticsInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BootDiagnosticsInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceView_Status, BootDiagnosticsInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceView_Status runs a test to see if a specific instance of BootDiagnosticsInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceView_Status(subject BootDiagnosticsInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceView_Status instances for property testing - lazily instantiated by
//BootDiagnosticsInstanceView_StatusGenerator()
var bootDiagnosticsInstanceView_statusGenerator gopter.Gen

// BootDiagnosticsInstanceView_StatusGenerator returns a generator of BootDiagnosticsInstanceView_Status instances for property testing.
// We first initialize bootDiagnosticsInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceView_StatusGenerator() gopter.Gen {
	if bootDiagnosticsInstanceView_statusGenerator != nil {
		return bootDiagnosticsInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_Status(generators)
	bootDiagnosticsInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_Status(generators)
	bootDiagnosticsInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	return bootDiagnosticsInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_Status(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusGenerator())
}

func Test_BootDiagnostics_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BootDiagnostics_Spec to BootDiagnostics_Spec via AssignPropertiesToBootDiagnostics_Spec & AssignPropertiesFromBootDiagnostics_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBootDiagnostics_Spec, BootDiagnostics_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBootDiagnostics_Spec tests if a specific instance of BootDiagnostics_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBootDiagnostics_Spec(subject BootDiagnostics_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BootDiagnostics_Spec
	err := copied.AssignPropertiesToBootDiagnostics_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BootDiagnostics_Spec
	err = actual.AssignPropertiesFromBootDiagnostics_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BootDiagnostics_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics_Spec, BootDiagnostics_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics_Spec runs a test to see if a specific instance of BootDiagnostics_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics_Spec(subject BootDiagnostics_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Spec instances for property testing - lazily instantiated by
//BootDiagnostics_SpecGenerator()
var bootDiagnostics_specGenerator gopter.Gen

// BootDiagnostics_SpecGenerator returns a generator of BootDiagnostics_Spec instances for property testing.
func BootDiagnostics_SpecGenerator() gopter.Gen {
	if bootDiagnostics_specGenerator != nil {
		return bootDiagnostics_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics_Spec(generators)
	bootDiagnostics_specGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Spec{}), generators)

	return bootDiagnostics_specGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_BootDiagnostics_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BootDiagnostics_Status to BootDiagnostics_Status via AssignPropertiesToBootDiagnostics_Status & AssignPropertiesFromBootDiagnostics_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForBootDiagnostics_Status, BootDiagnostics_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBootDiagnostics_Status tests if a specific instance of BootDiagnostics_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForBootDiagnostics_Status(subject BootDiagnostics_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.BootDiagnostics_Status
	err := copied.AssignPropertiesToBootDiagnostics_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BootDiagnostics_Status
	err = actual.AssignPropertiesFromBootDiagnostics_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BootDiagnostics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics_Status, BootDiagnostics_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics_Status runs a test to see if a specific instance of BootDiagnostics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics_Status(subject BootDiagnostics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Status instances for property testing - lazily instantiated by
//BootDiagnostics_StatusGenerator()
var bootDiagnostics_statusGenerator gopter.Gen

// BootDiagnostics_StatusGenerator returns a generator of BootDiagnostics_Status instances for property testing.
func BootDiagnostics_StatusGenerator() gopter.Gen {
	if bootDiagnostics_statusGenerator != nil {
		return bootDiagnostics_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics_Status(generators)
	bootDiagnostics_statusGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Status{}), generators)

	return bootDiagnostics_statusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataDisk_Spec to DataDisk_Spec via AssignPropertiesToDataDisk_Spec & AssignPropertiesFromDataDisk_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataDisk_Spec, DataDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataDisk_Spec tests if a specific instance of DataDisk_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDataDisk_Spec(subject DataDisk_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DataDisk_Spec
	err := copied.AssignPropertiesToDataDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataDisk_Spec
	err = actual.AssignPropertiesFromDataDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk_Spec, DataDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk_Spec runs a test to see if a specific instance of DataDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk_Spec(subject DataDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Spec instances for property testing - lazily instantiated by DataDisk_SpecGenerator()
var dataDisk_specGenerator gopter.Gen

// DataDisk_SpecGenerator returns a generator of DataDisk_Spec instances for property testing.
// We first initialize dataDisk_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDisk_SpecGenerator() gopter.Gen {
	if dataDisk_specGenerator != nil {
		return dataDisk_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_Spec(generators)
	dataDisk_specGenerator = gen.Struct(reflect.TypeOf(DataDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_Spec(generators)
	AddRelatedPropertyGeneratorsForDataDisk_Spec(generators)
	dataDisk_specGenerator = gen.Struct(reflect.TypeOf(DataDisk_Spec{}), generators)

	return dataDisk_specGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk_Spec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_SpecForceDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk_Spec(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_SpecGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
}

func Test_DataDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataDisk_Status to DataDisk_Status via AssignPropertiesToDataDisk_Status & AssignPropertiesFromDataDisk_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataDisk_Status, DataDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataDisk_Status tests if a specific instance of DataDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDataDisk_Status(subject DataDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DataDisk_Status
	err := copied.AssignPropertiesToDataDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataDisk_Status
	err = actual.AssignPropertiesFromDataDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk_Status, DataDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk_Status runs a test to see if a specific instance of DataDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk_Status(subject DataDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Status instances for property testing - lazily instantiated by DataDisk_StatusGenerator()
var dataDisk_statusGenerator gopter.Gen

// DataDisk_StatusGenerator returns a generator of DataDisk_Status instances for property testing.
// We first initialize dataDisk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDisk_StatusGenerator() gopter.Gen {
	if dataDisk_statusGenerator != nil {
		return dataDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_Status(generators)
	dataDisk_statusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_Status(generators)
	AddRelatedPropertyGeneratorsForDataDisk_Status(generators)
	dataDisk_statusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	return dataDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk_Status(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_StatusNone, Caching_StatusReadOnly, Caching_StatusReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_StatusAttach, CreateOption_StatusEmpty, CreateOption_StatusFromImage)
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_StatusForceDetach))
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk_Status(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_StatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
}

func Test_DiskInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiskInstanceView_Status to DiskInstanceView_Status via AssignPropertiesToDiskInstanceView_Status & AssignPropertiesFromDiskInstanceView_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiskInstanceView_Status, DiskInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiskInstanceView_Status tests if a specific instance of DiskInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiskInstanceView_Status(subject DiskInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiskInstanceView_Status
	err := copied.AssignPropertiesToDiskInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiskInstanceView_Status
	err = actual.AssignPropertiesFromDiskInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiskInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceView_Status, DiskInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceView_Status runs a test to see if a specific instance of DiskInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceView_Status(subject DiskInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceView_Status instances for property testing - lazily instantiated by
//DiskInstanceView_StatusGenerator()
var diskInstanceView_statusGenerator gopter.Gen

// DiskInstanceView_StatusGenerator returns a generator of DiskInstanceView_Status instances for property testing.
// We first initialize diskInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceView_StatusGenerator() gopter.Gen {
	if diskInstanceView_statusGenerator != nil {
		return diskInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceView_Status(generators)
	diskInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceView_Status(generators)
	diskInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	return diskInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceView_Status(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettings_StatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
}

func Test_ImageReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ImageReference_Spec to ImageReference_Spec via AssignPropertiesToImageReference_Spec & AssignPropertiesFromImageReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForImageReference_Spec, ImageReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForImageReference_Spec tests if a specific instance of ImageReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForImageReference_Spec(subject ImageReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ImageReference_Spec
	err := copied.AssignPropertiesToImageReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ImageReference_Spec
	err = actual.AssignPropertiesFromImageReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ImageReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference_Spec, ImageReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference_Spec runs a test to see if a specific instance of ImageReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference_Spec(subject ImageReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Spec instances for property testing - lazily instantiated by
//ImageReference_SpecGenerator()
var imageReference_specGenerator gopter.Gen

// ImageReference_SpecGenerator returns a generator of ImageReference_Spec instances for property testing.
func ImageReference_SpecGenerator() gopter.Gen {
	if imageReference_specGenerator != nil {
		return imageReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference_Spec(generators)
	imageReference_specGenerator = gen.Struct(reflect.TypeOf(ImageReference_Spec{}), generators)

	return imageReference_specGenerator
}

// AddIndependentPropertyGeneratorsForImageReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference_Spec(gens map[string]gopter.Gen) {
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ImageReference_Status to ImageReference_Status via AssignPropertiesToImageReference_Status & AssignPropertiesFromImageReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForImageReference_Status, ImageReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForImageReference_Status tests if a specific instance of ImageReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForImageReference_Status(subject ImageReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ImageReference_Status
	err := copied.AssignPropertiesToImageReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ImageReference_Status
	err = actual.AssignPropertiesFromImageReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ImageReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference_Status, ImageReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference_Status runs a test to see if a specific instance of ImageReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference_Status(subject ImageReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Status instances for property testing - lazily instantiated by
//ImageReference_StatusGenerator()
var imageReference_statusGenerator gopter.Gen

// ImageReference_StatusGenerator returns a generator of ImageReference_Status instances for property testing.
func ImageReference_StatusGenerator() gopter.Gen {
	if imageReference_statusGenerator != nil {
		return imageReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference_Status(generators)
	imageReference_statusGenerator = gen.Struct(reflect.TypeOf(ImageReference_Status{}), generators)

	return imageReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForImageReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference_Status(gens map[string]gopter.Gen) {
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatus_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InstanceViewStatus_Status to InstanceViewStatus_Status via AssignPropertiesToInstanceViewStatus_Status & AssignPropertiesFromInstanceViewStatus_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForInstanceViewStatus_Status, InstanceViewStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInstanceViewStatus_Status tests if a specific instance of InstanceViewStatus_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForInstanceViewStatus_Status(subject InstanceViewStatus_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.InstanceViewStatus_Status
	err := copied.AssignPropertiesToInstanceViewStatus_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InstanceViewStatus_Status
	err = actual.AssignPropertiesFromInstanceViewStatus_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InstanceViewStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatus_Status, InstanceViewStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatus_Status runs a test to see if a specific instance of InstanceViewStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatus_Status(subject InstanceViewStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_Status instances for property testing - lazily instantiated by
//InstanceViewStatus_StatusGenerator()
var instanceViewStatus_statusGenerator gopter.Gen

// InstanceViewStatus_StatusGenerator returns a generator of InstanceViewStatus_Status instances for property testing.
func InstanceViewStatus_StatusGenerator() gopter.Gen {
	if instanceViewStatus_statusGenerator != nil {
		return instanceViewStatus_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatus_Status(generators)
	instanceViewStatus_statusGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_Status{}), generators)

	return instanceViewStatus_statusGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatus_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatus_Status(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.OneConstOf(InstanceViewStatus_Level_StatusError, InstanceViewStatus_Level_StatusInfo, InstanceViewStatus_Level_StatusWarning))
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxConfiguration_Spec to LinuxConfiguration_Spec via AssignPropertiesToLinuxConfiguration_Spec & AssignPropertiesFromLinuxConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxConfiguration_Spec, LinuxConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxConfiguration_Spec tests if a specific instance of LinuxConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLinuxConfiguration_Spec(subject LinuxConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LinuxConfiguration_Spec
	err := copied.AssignPropertiesToLinuxConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxConfiguration_Spec
	err = actual.AssignPropertiesFromLinuxConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration_Spec, LinuxConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration_Spec runs a test to see if a specific instance of LinuxConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration_Spec(subject LinuxConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Spec instances for property testing - lazily instantiated by
//LinuxConfiguration_SpecGenerator()
var linuxConfiguration_specGenerator gopter.Gen

// LinuxConfiguration_SpecGenerator returns a generator of LinuxConfiguration_Spec instances for property testing.
// We first initialize linuxConfiguration_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfiguration_SpecGenerator() gopter.Gen {
	if linuxConfiguration_specGenerator != nil {
		return linuxConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_Spec(generators)
	linuxConfiguration_specGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_Spec(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration_Spec(generators)
	linuxConfiguration_specGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Spec{}), generators)

	return linuxConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettings_SpecGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfiguration_SpecGenerator())
}

func Test_LinuxConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxConfiguration_Status to LinuxConfiguration_Status via AssignPropertiesToLinuxConfiguration_Status & AssignPropertiesFromLinuxConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxConfiguration_Status, LinuxConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxConfiguration_Status tests if a specific instance of LinuxConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLinuxConfiguration_Status(subject LinuxConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LinuxConfiguration_Status
	err := copied.AssignPropertiesToLinuxConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxConfiguration_Status
	err = actual.AssignPropertiesFromLinuxConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration_Status, LinuxConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration_Status runs a test to see if a specific instance of LinuxConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration_Status(subject LinuxConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Status instances for property testing - lazily instantiated by
//LinuxConfiguration_StatusGenerator()
var linuxConfiguration_statusGenerator gopter.Gen

// LinuxConfiguration_StatusGenerator returns a generator of LinuxConfiguration_Status instances for property testing.
// We first initialize linuxConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfiguration_StatusGenerator() gopter.Gen {
	if linuxConfiguration_statusGenerator != nil {
		return linuxConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_Status(generators)
	linuxConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration_Status(generators)
	linuxConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	return linuxConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration_Status(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration_Status(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettings_StatusGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfiguration_StatusGenerator())
}

func Test_MaintenanceRedeployStatus_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MaintenanceRedeployStatus_Status to MaintenanceRedeployStatus_Status via AssignPropertiesToMaintenanceRedeployStatus_Status & AssignPropertiesFromMaintenanceRedeployStatus_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForMaintenanceRedeployStatus_Status, MaintenanceRedeployStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMaintenanceRedeployStatus_Status tests if a specific instance of MaintenanceRedeployStatus_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForMaintenanceRedeployStatus_Status(subject MaintenanceRedeployStatus_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.MaintenanceRedeployStatus_Status
	err := copied.AssignPropertiesToMaintenanceRedeployStatus_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MaintenanceRedeployStatus_Status
	err = actual.AssignPropertiesFromMaintenanceRedeployStatus_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MaintenanceRedeployStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatus_Status, MaintenanceRedeployStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatus_Status runs a test to see if a specific instance of MaintenanceRedeployStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatus_Status(subject MaintenanceRedeployStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatus_Status instances for property testing - lazily instantiated by
//MaintenanceRedeployStatus_StatusGenerator()
var maintenanceRedeployStatus_statusGenerator gopter.Gen

// MaintenanceRedeployStatus_StatusGenerator returns a generator of MaintenanceRedeployStatus_Status instances for property testing.
func MaintenanceRedeployStatus_StatusGenerator() gopter.Gen {
	if maintenanceRedeployStatus_statusGenerator != nil {
		return maintenanceRedeployStatus_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_Status(generators)
	maintenanceRedeployStatus_statusGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatus_Status{}), generators)

	return maintenanceRedeployStatus_statusGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_Status(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.OneConstOf(
		MaintenanceRedeployStatus_LastOperationResultCode_StatusMaintenanceAborted,
		MaintenanceRedeployStatus_LastOperationResultCode_StatusMaintenanceCompleted,
		MaintenanceRedeployStatus_LastOperationResultCode_StatusNone,
		MaintenanceRedeployStatus_LastOperationResultCode_StatusRetryLater))
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceReference_Spec to NetworkInterfaceReference_Spec via AssignPropertiesToNetworkInterfaceReference_Spec & AssignPropertiesFromNetworkInterfaceReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceReference_Spec, NetworkInterfaceReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceReference_Spec tests if a specific instance of NetworkInterfaceReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceReference_Spec(subject NetworkInterfaceReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.NetworkInterfaceReference_Spec
	err := copied.AssignPropertiesToNetworkInterfaceReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceReference_Spec
	err = actual.AssignPropertiesFromNetworkInterfaceReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReference_Spec, NetworkInterfaceReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReference_Spec runs a test to see if a specific instance of NetworkInterfaceReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReference_Spec(subject NetworkInterfaceReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Spec instances for property testing - lazily instantiated by
//NetworkInterfaceReference_SpecGenerator()
var networkInterfaceReference_specGenerator gopter.Gen

// NetworkInterfaceReference_SpecGenerator returns a generator of NetworkInterfaceReference_Spec instances for property testing.
func NetworkInterfaceReference_SpecGenerator() gopter.Gen {
	if networkInterfaceReference_specGenerator != nil {
		return networkInterfaceReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Spec(generators)
	networkInterfaceReference_specGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Spec{}), generators)

	return networkInterfaceReference_specGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Spec(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkInterfaceReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkInterfaceReference_Status to NetworkInterfaceReference_Status via AssignPropertiesToNetworkInterfaceReference_Status & AssignPropertiesFromNetworkInterfaceReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkInterfaceReference_Status, NetworkInterfaceReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkInterfaceReference_Status tests if a specific instance of NetworkInterfaceReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForNetworkInterfaceReference_Status(subject NetworkInterfaceReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.NetworkInterfaceReference_Status
	err := copied.AssignPropertiesToNetworkInterfaceReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkInterfaceReference_Status
	err = actual.AssignPropertiesFromNetworkInterfaceReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkInterfaceReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReference_Status, NetworkInterfaceReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReference_Status runs a test to see if a specific instance of NetworkInterfaceReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReference_Status(subject NetworkInterfaceReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Status instances for property testing - lazily instantiated by
//NetworkInterfaceReference_StatusGenerator()
var networkInterfaceReference_statusGenerator gopter.Gen

// NetworkInterfaceReference_StatusGenerator returns a generator of NetworkInterfaceReference_Status instances for property testing.
func NetworkInterfaceReference_StatusGenerator() gopter.Gen {
	if networkInterfaceReference_statusGenerator != nil {
		return networkInterfaceReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Status(generators)
	networkInterfaceReference_statusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Status{}), generators)

	return networkInterfaceReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_OSDisk_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OSDisk_Spec to OSDisk_Spec via AssignPropertiesToOSDisk_Spec & AssignPropertiesFromOSDisk_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForOSDisk_Spec, OSDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOSDisk_Spec tests if a specific instance of OSDisk_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForOSDisk_Spec(subject OSDisk_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.OSDisk_Spec
	err := copied.AssignPropertiesToOSDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OSDisk_Spec
	err = actual.AssignPropertiesFromOSDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OSDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk_Spec, OSDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk_Spec runs a test to see if a specific instance of OSDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk_Spec(subject OSDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Spec instances for property testing - lazily instantiated by OSDisk_SpecGenerator()
var osDisk_specGenerator gopter.Gen

// OSDisk_SpecGenerator returns a generator of OSDisk_Spec instances for property testing.
// We first initialize osDisk_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDisk_SpecGenerator() gopter.Gen {
	if osDisk_specGenerator != nil {
		return osDisk_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_Spec(generators)
	osDisk_specGenerator = gen.Struct(reflect.TypeOf(OSDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_Spec(generators)
	AddRelatedPropertyGeneratorsForOSDisk_Spec(generators)
	osDisk_specGenerator = gen.Struct(reflect.TypeOf(OSDisk_Spec{}), generators)

	return osDisk_specGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk_Spec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDisk_OsType_SpecLinux, OSDisk_OsType_SpecWindows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk_Spec(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_SpecGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettings_SpecGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_SpecGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
}

func Test_OSDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OSDisk_Status to OSDisk_Status via AssignPropertiesToOSDisk_Status & AssignPropertiesFromOSDisk_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForOSDisk_Status, OSDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOSDisk_Status tests if a specific instance of OSDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForOSDisk_Status(subject OSDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.OSDisk_Status
	err := copied.AssignPropertiesToOSDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OSDisk_Status
	err = actual.AssignPropertiesFromOSDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OSDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk_Status, OSDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk_Status runs a test to see if a specific instance of OSDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk_Status(subject OSDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Status instances for property testing - lazily instantiated by OSDisk_StatusGenerator()
var osDisk_statusGenerator gopter.Gen

// OSDisk_StatusGenerator returns a generator of OSDisk_Status instances for property testing.
// We first initialize osDisk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDisk_StatusGenerator() gopter.Gen {
	if osDisk_statusGenerator != nil {
		return osDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_Status(generators)
	osDisk_statusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_Status(generators)
	AddRelatedPropertyGeneratorsForOSDisk_Status(generators)
	osDisk_statusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	return osDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk_Status(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_StatusNone, Caching_StatusReadOnly, Caching_StatusReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_StatusAttach, CreateOption_StatusEmpty, CreateOption_StatusFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDisk_OsType_StatusLinux, OSDisk_OsType_StatusWindows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk_Status(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_StatusGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettings_StatusGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_StatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
}

func Test_UefiSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UefiSettings_Spec to UefiSettings_Spec via AssignPropertiesToUefiSettings_Spec & AssignPropertiesFromUefiSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUefiSettings_Spec, UefiSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUefiSettings_Spec tests if a specific instance of UefiSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForUefiSettings_Spec(subject UefiSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.UefiSettings_Spec
	err := copied.AssignPropertiesToUefiSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UefiSettings_Spec
	err = actual.AssignPropertiesFromUefiSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UefiSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings_Spec, UefiSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings_Spec runs a test to see if a specific instance of UefiSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings_Spec(subject UefiSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Spec instances for property testing - lazily instantiated by UefiSettings_SpecGenerator()
var uefiSettings_specGenerator gopter.Gen

// UefiSettings_SpecGenerator returns a generator of UefiSettings_Spec instances for property testing.
func UefiSettings_SpecGenerator() gopter.Gen {
	if uefiSettings_specGenerator != nil {
		return uefiSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings_Spec(generators)
	uefiSettings_specGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Spec{}), generators)

	return uefiSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings_Spec(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_UefiSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UefiSettings_Status to UefiSettings_Status via AssignPropertiesToUefiSettings_Status & AssignPropertiesFromUefiSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUefiSettings_Status, UefiSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUefiSettings_Status tests if a specific instance of UefiSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForUefiSettings_Status(subject UefiSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.UefiSettings_Status
	err := copied.AssignPropertiesToUefiSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UefiSettings_Status
	err = actual.AssignPropertiesFromUefiSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UefiSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings_Status, UefiSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings_Status runs a test to see if a specific instance of UefiSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings_Status(subject UefiSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Status instances for property testing - lazily instantiated by
//UefiSettings_StatusGenerator()
var uefiSettings_statusGenerator gopter.Gen

// UefiSettings_StatusGenerator returns a generator of UefiSettings_Status instances for property testing.
func UefiSettings_StatusGenerator() gopter.Gen {
	if uefiSettings_statusGenerator != nil {
		return uefiSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings_Status(generators)
	uefiSettings_statusGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Status{}), generators)

	return uefiSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings_Status(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultSecretGroup_Spec to VaultSecretGroup_Spec via AssignPropertiesToVaultSecretGroup_Spec & AssignPropertiesFromVaultSecretGroup_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultSecretGroup_Spec, VaultSecretGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultSecretGroup_Spec tests if a specific instance of VaultSecretGroup_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVaultSecretGroup_Spec(subject VaultSecretGroup_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VaultSecretGroup_Spec
	err := copied.AssignPropertiesToVaultSecretGroup_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultSecretGroup_Spec
	err = actual.AssignPropertiesFromVaultSecretGroup_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultSecretGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup_Spec, VaultSecretGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup_Spec runs a test to see if a specific instance of VaultSecretGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup_Spec(subject VaultSecretGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Spec instances for property testing - lazily instantiated by
//VaultSecretGroup_SpecGenerator()
var vaultSecretGroup_specGenerator gopter.Gen

// VaultSecretGroup_SpecGenerator returns a generator of VaultSecretGroup_Spec instances for property testing.
func VaultSecretGroup_SpecGenerator() gopter.Gen {
	if vaultSecretGroup_specGenerator != nil {
		return vaultSecretGroup_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup_Spec(generators)
	vaultSecretGroup_specGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Spec{}), generators)

	return vaultSecretGroup_specGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificate_SpecGenerator())
}

func Test_VaultSecretGroup_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultSecretGroup_Status to VaultSecretGroup_Status via AssignPropertiesToVaultSecretGroup_Status & AssignPropertiesFromVaultSecretGroup_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultSecretGroup_Status, VaultSecretGroup_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultSecretGroup_Status tests if a specific instance of VaultSecretGroup_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVaultSecretGroup_Status(subject VaultSecretGroup_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VaultSecretGroup_Status
	err := copied.AssignPropertiesToVaultSecretGroup_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultSecretGroup_Status
	err = actual.AssignPropertiesFromVaultSecretGroup_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultSecretGroup_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup_Status, VaultSecretGroup_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup_Status runs a test to see if a specific instance of VaultSecretGroup_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup_Status(subject VaultSecretGroup_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Status instances for property testing - lazily instantiated by
//VaultSecretGroup_StatusGenerator()
var vaultSecretGroup_statusGenerator gopter.Gen

// VaultSecretGroup_StatusGenerator returns a generator of VaultSecretGroup_Status instances for property testing.
func VaultSecretGroup_StatusGenerator() gopter.Gen {
	if vaultSecretGroup_statusGenerator != nil {
		return vaultSecretGroup_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup_Status(generators)
	vaultSecretGroup_statusGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Status{}), generators)

	return vaultSecretGroup_statusGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificate_StatusGenerator())
}

func Test_VirtualMachineAgentInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineAgentInstanceView_Status to VirtualMachineAgentInstanceView_Status via AssignPropertiesToVirtualMachineAgentInstanceView_Status & AssignPropertiesFromVirtualMachineAgentInstanceView_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineAgentInstanceView_Status, VirtualMachineAgentInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineAgentInstanceView_Status tests if a specific instance of VirtualMachineAgentInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineAgentInstanceView_Status(subject VirtualMachineAgentInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineAgentInstanceView_Status
	err := copied.AssignPropertiesToVirtualMachineAgentInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineAgentInstanceView_Status
	err = actual.AssignPropertiesFromVirtualMachineAgentInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineAgentInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceView_Status, VirtualMachineAgentInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceView_Status runs a test to see if a specific instance of VirtualMachineAgentInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceView_Status(subject VirtualMachineAgentInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineAgentInstanceView_StatusGenerator()
var virtualMachineAgentInstanceView_statusGenerator gopter.Gen

// VirtualMachineAgentInstanceView_StatusGenerator returns a generator of VirtualMachineAgentInstanceView_Status instances for property testing.
// We first initialize virtualMachineAgentInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceView_StatusGenerator() gopter.Gen {
	if virtualMachineAgentInstanceView_statusGenerator != nil {
		return virtualMachineAgentInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(generators)
	virtualMachineAgentInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(generators)
	virtualMachineAgentInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	return virtualMachineAgentInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceView_StatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
}

func Test_VirtualMachineExtensionInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineExtensionInstanceView_Status to VirtualMachineExtensionInstanceView_Status via AssignPropertiesToVirtualMachineExtensionInstanceView_Status & AssignPropertiesFromVirtualMachineExtensionInstanceView_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineExtensionInstanceView_Status, VirtualMachineExtensionInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineExtensionInstanceView_Status tests if a specific instance of VirtualMachineExtensionInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineExtensionInstanceView_Status(subject VirtualMachineExtensionInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineExtensionInstanceView_Status
	err := copied.AssignPropertiesToVirtualMachineExtensionInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineExtensionInstanceView_Status
	err = actual.AssignPropertiesFromVirtualMachineExtensionInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineExtensionInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceView_Status, VirtualMachineExtensionInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceView_Status runs a test to see if a specific instance of VirtualMachineExtensionInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceView_Status(subject VirtualMachineExtensionInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineExtensionInstanceView_StatusGenerator()
var virtualMachineExtensionInstanceView_statusGenerator gopter.Gen

// VirtualMachineExtensionInstanceView_StatusGenerator returns a generator of VirtualMachineExtensionInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceView_StatusGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceView_statusGenerator != nil {
		return virtualMachineExtensionInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(generators)
	virtualMachineExtensionInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(generators)
	virtualMachineExtensionInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	return virtualMachineExtensionInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
}

func Test_VirtualMachineHealthStatus_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineHealthStatus_Status to VirtualMachineHealthStatus_Status via AssignPropertiesToVirtualMachineHealthStatus_Status & AssignPropertiesFromVirtualMachineHealthStatus_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineHealthStatus_Status, VirtualMachineHealthStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineHealthStatus_Status tests if a specific instance of VirtualMachineHealthStatus_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineHealthStatus_Status(subject VirtualMachineHealthStatus_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineHealthStatus_Status
	err := copied.AssignPropertiesToVirtualMachineHealthStatus_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineHealthStatus_Status
	err = actual.AssignPropertiesFromVirtualMachineHealthStatus_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineHealthStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatus_Status, VirtualMachineHealthStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatus_Status runs a test to see if a specific instance of VirtualMachineHealthStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatus_Status(subject VirtualMachineHealthStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatus_Status instances for property testing - lazily instantiated by
//VirtualMachineHealthStatus_StatusGenerator()
var virtualMachineHealthStatus_statusGenerator gopter.Gen

// VirtualMachineHealthStatus_StatusGenerator returns a generator of VirtualMachineHealthStatus_Status instances for property testing.
func VirtualMachineHealthStatus_StatusGenerator() gopter.Gen {
	if virtualMachineHealthStatus_statusGenerator != nil {
		return virtualMachineHealthStatus_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_Status(generators)
	virtualMachineHealthStatus_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatus_Status{}), generators)

	return virtualMachineHealthStatus_statusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_Status(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusGenerator())
}

func Test_VirtualMachineIdentity_UserAssignedIdentities_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineIdentity_UserAssignedIdentities_Status to VirtualMachineIdentity_UserAssignedIdentities_Status via AssignPropertiesToVirtualMachineIdentity_UserAssignedIdentities_Status & AssignPropertiesFromVirtualMachineIdentity_UserAssignedIdentities_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineIdentity_UserAssignedIdentities_Status, VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineIdentity_UserAssignedIdentities_Status tests if a specific instance of VirtualMachineIdentity_UserAssignedIdentities_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineIdentity_UserAssignedIdentities_Status(subject VirtualMachineIdentity_UserAssignedIdentities_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineIdentity_UserAssignedIdentities_Status
	err := copied.AssignPropertiesToVirtualMachineIdentity_UserAssignedIdentities_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineIdentity_UserAssignedIdentities_Status
	err = actual.AssignPropertiesFromVirtualMachineIdentity_UserAssignedIdentities_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineIdentity_UserAssignedIdentities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_UserAssignedIdentities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_Status, VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_Status runs a test to see if a specific instance of VirtualMachineIdentity_UserAssignedIdentities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_Status(subject VirtualMachineIdentity_UserAssignedIdentities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_UserAssignedIdentities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_UserAssignedIdentities_Status instances for property testing - lazily
//instantiated by VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator()
var virtualMachineIdentity_userAssignedIdentities_statusGenerator gopter.Gen

// VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator returns a generator of VirtualMachineIdentity_UserAssignedIdentities_Status instances for property testing.
func VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator() gopter.Gen {
	if virtualMachineIdentity_userAssignedIdentities_statusGenerator != nil {
		return virtualMachineIdentity_userAssignedIdentities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_Status(generators)
	virtualMachineIdentity_userAssignedIdentities_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_UserAssignedIdentities_Status{}), generators)

	return virtualMachineIdentity_userAssignedIdentities_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinePatchStatus_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachinePatchStatus_Status to VirtualMachinePatchStatus_Status via AssignPropertiesToVirtualMachinePatchStatus_Status & AssignPropertiesFromVirtualMachinePatchStatus_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachinePatchStatus_Status, VirtualMachinePatchStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachinePatchStatus_Status tests if a specific instance of VirtualMachinePatchStatus_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachinePatchStatus_Status(subject VirtualMachinePatchStatus_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachinePatchStatus_Status
	err := copied.AssignPropertiesToVirtualMachinePatchStatus_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachinePatchStatus_Status
	err = actual.AssignPropertiesFromVirtualMachinePatchStatus_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachinePatchStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatus_Status, VirtualMachinePatchStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatus_Status runs a test to see if a specific instance of VirtualMachinePatchStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatus_Status(subject VirtualMachinePatchStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatus_Status instances for property testing - lazily instantiated by
//VirtualMachinePatchStatus_StatusGenerator()
var virtualMachinePatchStatus_statusGenerator gopter.Gen

// VirtualMachinePatchStatus_StatusGenerator returns a generator of VirtualMachinePatchStatus_Status instances for property testing.
func VirtualMachinePatchStatus_StatusGenerator() gopter.Gen {
	if virtualMachinePatchStatus_statusGenerator != nil {
		return virtualMachinePatchStatus_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_Status(generators)
	virtualMachinePatchStatus_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatus_Status{}), generators)

	return virtualMachinePatchStatus_statusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_Status(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummary_StatusGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummary_StatusGenerator())
}

func Test_WindowsConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WindowsConfiguration_Spec to WindowsConfiguration_Spec via AssignPropertiesToWindowsConfiguration_Spec & AssignPropertiesFromWindowsConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWindowsConfiguration_Spec, WindowsConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWindowsConfiguration_Spec tests if a specific instance of WindowsConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWindowsConfiguration_Spec(subject WindowsConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WindowsConfiguration_Spec
	err := copied.AssignPropertiesToWindowsConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WindowsConfiguration_Spec
	err = actual.AssignPropertiesFromWindowsConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WindowsConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration_Spec, WindowsConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration_Spec runs a test to see if a specific instance of WindowsConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration_Spec(subject WindowsConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Spec instances for property testing - lazily instantiated by
//WindowsConfiguration_SpecGenerator()
var windowsConfiguration_specGenerator gopter.Gen

// WindowsConfiguration_SpecGenerator returns a generator of WindowsConfiguration_Spec instances for property testing.
// We first initialize windowsConfiguration_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfiguration_SpecGenerator() gopter.Gen {
	if windowsConfiguration_specGenerator != nil {
		return windowsConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_Spec(generators)
	windowsConfiguration_specGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_Spec(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration_Spec(generators)
	windowsConfiguration_specGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Spec{}), generators)

	return windowsConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContent_SpecGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettings_SpecGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfiguration_SpecGenerator())
}

func Test_WindowsConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WindowsConfiguration_Status to WindowsConfiguration_Status via AssignPropertiesToWindowsConfiguration_Status & AssignPropertiesFromWindowsConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWindowsConfiguration_Status, WindowsConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWindowsConfiguration_Status tests if a specific instance of WindowsConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWindowsConfiguration_Status(subject WindowsConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WindowsConfiguration_Status
	err := copied.AssignPropertiesToWindowsConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WindowsConfiguration_Status
	err = actual.AssignPropertiesFromWindowsConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WindowsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration_Status, WindowsConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration_Status runs a test to see if a specific instance of WindowsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration_Status(subject WindowsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Status instances for property testing - lazily instantiated by
//WindowsConfiguration_StatusGenerator()
var windowsConfiguration_statusGenerator gopter.Gen

// WindowsConfiguration_StatusGenerator returns a generator of WindowsConfiguration_Status instances for property testing.
// We first initialize windowsConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfiguration_StatusGenerator() gopter.Gen {
	if windowsConfiguration_statusGenerator != nil {
		return windowsConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_Status(generators)
	windowsConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration_Status(generators)
	windowsConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	return windowsConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration_Status(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration_Status(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContent_StatusGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettings_StatusGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfiguration_StatusGenerator())
}

func Test_AdditionalUnattendContent_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalUnattendContent_Spec to AdditionalUnattendContent_Spec via AssignPropertiesToAdditionalUnattendContent_Spec & AssignPropertiesFromAdditionalUnattendContent_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalUnattendContent_Spec, AdditionalUnattendContent_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalUnattendContent_Spec tests if a specific instance of AdditionalUnattendContent_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAdditionalUnattendContent_Spec(subject AdditionalUnattendContent_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AdditionalUnattendContent_Spec
	err := copied.AssignPropertiesToAdditionalUnattendContent_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalUnattendContent_Spec
	err = actual.AssignPropertiesFromAdditionalUnattendContent_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalUnattendContent_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent_Spec, AdditionalUnattendContent_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent_Spec runs a test to see if a specific instance of AdditionalUnattendContent_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent_Spec(subject AdditionalUnattendContent_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Spec instances for property testing - lazily instantiated by
//AdditionalUnattendContent_SpecGenerator()
var additionalUnattendContent_specGenerator gopter.Gen

// AdditionalUnattendContent_SpecGenerator returns a generator of AdditionalUnattendContent_Spec instances for property testing.
func AdditionalUnattendContent_SpecGenerator() gopter.Gen {
	if additionalUnattendContent_specGenerator != nil {
		return additionalUnattendContent_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Spec(generators)
	additionalUnattendContent_specGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Spec{}), generators)

	return additionalUnattendContent_specGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Spec(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_ComponentName_SpecMicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_PassName_SpecOobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_SettingName_SpecAutoLogon, AdditionalUnattendContent_SettingName_SpecFirstLogonCommands))
}

func Test_AdditionalUnattendContent_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalUnattendContent_Status to AdditionalUnattendContent_Status via AssignPropertiesToAdditionalUnattendContent_Status & AssignPropertiesFromAdditionalUnattendContent_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalUnattendContent_Status, AdditionalUnattendContent_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalUnattendContent_Status tests if a specific instance of AdditionalUnattendContent_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAdditionalUnattendContent_Status(subject AdditionalUnattendContent_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AdditionalUnattendContent_Status
	err := copied.AssignPropertiesToAdditionalUnattendContent_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalUnattendContent_Status
	err = actual.AssignPropertiesFromAdditionalUnattendContent_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalUnattendContent_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent_Status, AdditionalUnattendContent_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent_Status runs a test to see if a specific instance of AdditionalUnattendContent_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent_Status(subject AdditionalUnattendContent_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Status instances for property testing - lazily instantiated by
//AdditionalUnattendContent_StatusGenerator()
var additionalUnattendContent_statusGenerator gopter.Gen

// AdditionalUnattendContent_StatusGenerator returns a generator of AdditionalUnattendContent_Status instances for property testing.
func AdditionalUnattendContent_StatusGenerator() gopter.Gen {
	if additionalUnattendContent_statusGenerator != nil {
		return additionalUnattendContent_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Status(generators)
	additionalUnattendContent_statusGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Status{}), generators)

	return additionalUnattendContent_statusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Status(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_ComponentName_StatusMicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_PassName_StatusOobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_SettingName_StatusAutoLogon, AdditionalUnattendContent_SettingName_StatusFirstLogonCommands))
}

func Test_AvailablePatchSummary_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AvailablePatchSummary_Status to AvailablePatchSummary_Status via AssignPropertiesToAvailablePatchSummary_Status & AssignPropertiesFromAvailablePatchSummary_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAvailablePatchSummary_Status, AvailablePatchSummary_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAvailablePatchSummary_Status tests if a specific instance of AvailablePatchSummary_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAvailablePatchSummary_Status(subject AvailablePatchSummary_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AvailablePatchSummary_Status
	err := copied.AssignPropertiesToAvailablePatchSummary_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AvailablePatchSummary_Status
	err = actual.AssignPropertiesFromAvailablePatchSummary_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AvailablePatchSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummary_Status, AvailablePatchSummary_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummary_Status runs a test to see if a specific instance of AvailablePatchSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummary_Status(subject AvailablePatchSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummary_Status instances for property testing - lazily instantiated by
//AvailablePatchSummary_StatusGenerator()
var availablePatchSummary_statusGenerator gopter.Gen

// AvailablePatchSummary_StatusGenerator returns a generator of AvailablePatchSummary_Status instances for property testing.
// We first initialize availablePatchSummary_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummary_StatusGenerator() gopter.Gen {
	if availablePatchSummary_statusGenerator != nil {
		return availablePatchSummary_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummary_Status(generators)
	availablePatchSummary_statusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummary_Status(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummary_Status(generators)
	availablePatchSummary_statusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	return availablePatchSummary_statusGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummary_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummary_Status(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		AvailablePatchSummary_Status_StatusCompletedWithWarnings,
		AvailablePatchSummary_Status_StatusFailed,
		AvailablePatchSummary_Status_StatusInProgress,
		AvailablePatchSummary_Status_StatusSucceeded,
		AvailablePatchSummary_Status_StatusUnknown))
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummary_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummary_Status(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiError_StatusGenerator())
}

func Test_DiffDiskSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiffDiskSettings_Spec to DiffDiskSettings_Spec via AssignPropertiesToDiffDiskSettings_Spec & AssignPropertiesFromDiffDiskSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiffDiskSettings_Spec, DiffDiskSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiffDiskSettings_Spec tests if a specific instance of DiffDiskSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiffDiskSettings_Spec(subject DiffDiskSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiffDiskSettings_Spec
	err := copied.AssignPropertiesToDiffDiskSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiffDiskSettings_Spec
	err = actual.AssignPropertiesFromDiffDiskSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiffDiskSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings_Spec, DiffDiskSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings_Spec runs a test to see if a specific instance of DiffDiskSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings_Spec(subject DiffDiskSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Spec instances for property testing - lazily instantiated by
//DiffDiskSettings_SpecGenerator()
var diffDiskSettings_specGenerator gopter.Gen

// DiffDiskSettings_SpecGenerator returns a generator of DiffDiskSettings_Spec instances for property testing.
func DiffDiskSettings_SpecGenerator() gopter.Gen {
	if diffDiskSettings_specGenerator != nil {
		return diffDiskSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings_Spec(generators)
	diffDiskSettings_specGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Spec{}), generators)

	return diffDiskSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings_Spec(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_SpecLocal))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_SpecCacheDisk, DiffDiskPlacement_SpecResourceDisk))
}

func Test_DiffDiskSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiffDiskSettings_Status to DiffDiskSettings_Status via AssignPropertiesToDiffDiskSettings_Status & AssignPropertiesFromDiffDiskSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiffDiskSettings_Status, DiffDiskSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiffDiskSettings_Status tests if a specific instance of DiffDiskSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiffDiskSettings_Status(subject DiffDiskSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiffDiskSettings_Status
	err := copied.AssignPropertiesToDiffDiskSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiffDiskSettings_Status
	err = actual.AssignPropertiesFromDiffDiskSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiffDiskSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings_Status, DiffDiskSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings_Status runs a test to see if a specific instance of DiffDiskSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings_Status(subject DiffDiskSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Status instances for property testing - lazily instantiated by
//DiffDiskSettings_StatusGenerator()
var diffDiskSettings_statusGenerator gopter.Gen

// DiffDiskSettings_StatusGenerator returns a generator of DiffDiskSettings_Status instances for property testing.
func DiffDiskSettings_StatusGenerator() gopter.Gen {
	if diffDiskSettings_statusGenerator != nil {
		return diffDiskSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings_Status(generators)
	diffDiskSettings_statusGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Status{}), generators)

	return diffDiskSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings_Status(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_StatusLocal))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_StatusCacheDisk, DiffDiskPlacement_StatusResourceDisk))
}

func Test_DiskEncryptionSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiskEncryptionSettings_Spec to DiskEncryptionSettings_Spec via AssignPropertiesToDiskEncryptionSettings_Spec & AssignPropertiesFromDiskEncryptionSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiskEncryptionSettings_Spec, DiskEncryptionSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiskEncryptionSettings_Spec tests if a specific instance of DiskEncryptionSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiskEncryptionSettings_Spec(subject DiskEncryptionSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiskEncryptionSettings_Spec
	err := copied.AssignPropertiesToDiskEncryptionSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiskEncryptionSettings_Spec
	err = actual.AssignPropertiesFromDiskEncryptionSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiskEncryptionSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings_Spec, DiskEncryptionSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings_Spec runs a test to see if a specific instance of DiskEncryptionSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings_Spec(subject DiskEncryptionSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Spec instances for property testing - lazily instantiated by
//DiskEncryptionSettings_SpecGenerator()
var diskEncryptionSettings_specGenerator gopter.Gen

// DiskEncryptionSettings_SpecGenerator returns a generator of DiskEncryptionSettings_Spec instances for property testing.
// We first initialize diskEncryptionSettings_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettings_SpecGenerator() gopter.Gen {
	if diskEncryptionSettings_specGenerator != nil {
		return diskEncryptionSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Spec(generators)
	diskEncryptionSettings_specGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Spec(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Spec(generators)
	diskEncryptionSettings_specGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Spec{}), generators)

	return diskEncryptionSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Spec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReference_SpecGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReference_SpecGenerator())
}

func Test_DiskEncryptionSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiskEncryptionSettings_Status to DiskEncryptionSettings_Status via AssignPropertiesToDiskEncryptionSettings_Status & AssignPropertiesFromDiskEncryptionSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiskEncryptionSettings_Status, DiskEncryptionSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiskEncryptionSettings_Status tests if a specific instance of DiskEncryptionSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForDiskEncryptionSettings_Status(subject DiskEncryptionSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.DiskEncryptionSettings_Status
	err := copied.AssignPropertiesToDiskEncryptionSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiskEncryptionSettings_Status
	err = actual.AssignPropertiesFromDiskEncryptionSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiskEncryptionSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings_Status, DiskEncryptionSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings_Status runs a test to see if a specific instance of DiskEncryptionSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings_Status(subject DiskEncryptionSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Status instances for property testing - lazily instantiated by
//DiskEncryptionSettings_StatusGenerator()
var diskEncryptionSettings_statusGenerator gopter.Gen

// DiskEncryptionSettings_StatusGenerator returns a generator of DiskEncryptionSettings_Status instances for property testing.
// We first initialize diskEncryptionSettings_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettings_StatusGenerator() gopter.Gen {
	if diskEncryptionSettings_statusGenerator != nil {
		return diskEncryptionSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Status(generators)
	diskEncryptionSettings_statusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Status(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Status(generators)
	diskEncryptionSettings_statusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	return diskEncryptionSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReference_StatusGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReference_StatusGenerator())
}

func Test_LastPatchInstallationSummary_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LastPatchInstallationSummary_Status to LastPatchInstallationSummary_Status via AssignPropertiesToLastPatchInstallationSummary_Status & AssignPropertiesFromLastPatchInstallationSummary_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLastPatchInstallationSummary_Status, LastPatchInstallationSummary_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLastPatchInstallationSummary_Status tests if a specific instance of LastPatchInstallationSummary_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLastPatchInstallationSummary_Status(subject LastPatchInstallationSummary_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LastPatchInstallationSummary_Status
	err := copied.AssignPropertiesToLastPatchInstallationSummary_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LastPatchInstallationSummary_Status
	err = actual.AssignPropertiesFromLastPatchInstallationSummary_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LastPatchInstallationSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummary_Status, LastPatchInstallationSummary_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummary_Status runs a test to see if a specific instance of LastPatchInstallationSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummary_Status(subject LastPatchInstallationSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummary_Status instances for property testing - lazily instantiated by
//LastPatchInstallationSummary_StatusGenerator()
var lastPatchInstallationSummary_statusGenerator gopter.Gen

// LastPatchInstallationSummary_StatusGenerator returns a generator of LastPatchInstallationSummary_Status instances for property testing.
// We first initialize lastPatchInstallationSummary_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummary_StatusGenerator() gopter.Gen {
	if lastPatchInstallationSummary_statusGenerator != nil {
		return lastPatchInstallationSummary_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_Status(generators)
	lastPatchInstallationSummary_statusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_Status(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_Status(generators)
	lastPatchInstallationSummary_statusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	return lastPatchInstallationSummary_statusGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_Status(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		LastPatchInstallationSummary_Status_StatusCompletedWithWarnings,
		LastPatchInstallationSummary_Status_StatusFailed,
		LastPatchInstallationSummary_Status_StatusInProgress,
		LastPatchInstallationSummary_Status_StatusSucceeded,
		LastPatchInstallationSummary_Status_StatusUnknown))
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_Status(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiError_StatusGenerator())
}

func Test_LinuxPatchSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxPatchSettings_Spec to LinuxPatchSettings_Spec via AssignPropertiesToLinuxPatchSettings_Spec & AssignPropertiesFromLinuxPatchSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxPatchSettings_Spec, LinuxPatchSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxPatchSettings_Spec tests if a specific instance of LinuxPatchSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLinuxPatchSettings_Spec(subject LinuxPatchSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LinuxPatchSettings_Spec
	err := copied.AssignPropertiesToLinuxPatchSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxPatchSettings_Spec
	err = actual.AssignPropertiesFromLinuxPatchSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxPatchSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings_Spec, LinuxPatchSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings_Spec runs a test to see if a specific instance of LinuxPatchSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings_Spec(subject LinuxPatchSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Spec instances for property testing - lazily instantiated by
//LinuxPatchSettings_SpecGenerator()
var linuxPatchSettings_specGenerator gopter.Gen

// LinuxPatchSettings_SpecGenerator returns a generator of LinuxPatchSettings_Spec instances for property testing.
func LinuxPatchSettings_SpecGenerator() gopter.Gen {
	if linuxPatchSettings_specGenerator != nil {
		return linuxPatchSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings_Spec(generators)
	linuxPatchSettings_specGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Spec{}), generators)

	return linuxPatchSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings_Spec(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_PatchMode_SpecAutomaticByPlatform, LinuxPatchSettings_PatchMode_SpecImageDefault))
}

func Test_LinuxPatchSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LinuxPatchSettings_Status to LinuxPatchSettings_Status via AssignPropertiesToLinuxPatchSettings_Status & AssignPropertiesFromLinuxPatchSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLinuxPatchSettings_Status, LinuxPatchSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLinuxPatchSettings_Status tests if a specific instance of LinuxPatchSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForLinuxPatchSettings_Status(subject LinuxPatchSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.LinuxPatchSettings_Status
	err := copied.AssignPropertiesToLinuxPatchSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LinuxPatchSettings_Status
	err = actual.AssignPropertiesFromLinuxPatchSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LinuxPatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings_Status, LinuxPatchSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings_Status runs a test to see if a specific instance of LinuxPatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings_Status(subject LinuxPatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Status instances for property testing - lazily instantiated by
//LinuxPatchSettings_StatusGenerator()
var linuxPatchSettings_statusGenerator gopter.Gen

// LinuxPatchSettings_StatusGenerator returns a generator of LinuxPatchSettings_Status instances for property testing.
func LinuxPatchSettings_StatusGenerator() gopter.Gen {
	if linuxPatchSettings_statusGenerator != nil {
		return linuxPatchSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings_Status(generators)
	linuxPatchSettings_statusGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Status{}), generators)

	return linuxPatchSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings_Status(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_PatchMode_StatusAutomaticByPlatform, LinuxPatchSettings_PatchMode_StatusImageDefault))
}

func Test_ManagedDiskParameters_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedDiskParameters_Spec to ManagedDiskParameters_Spec via AssignPropertiesToManagedDiskParameters_Spec & AssignPropertiesFromManagedDiskParameters_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedDiskParameters_Spec, ManagedDiskParameters_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedDiskParameters_Spec tests if a specific instance of ManagedDiskParameters_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForManagedDiskParameters_Spec(subject ManagedDiskParameters_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ManagedDiskParameters_Spec
	err := copied.AssignPropertiesToManagedDiskParameters_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedDiskParameters_Spec
	err = actual.AssignPropertiesFromManagedDiskParameters_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedDiskParameters_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters_Spec, ManagedDiskParameters_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters_Spec runs a test to see if a specific instance of ManagedDiskParameters_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters_Spec(subject ManagedDiskParameters_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Spec instances for property testing - lazily instantiated by
//ManagedDiskParameters_SpecGenerator()
var managedDiskParameters_specGenerator gopter.Gen

// ManagedDiskParameters_SpecGenerator returns a generator of ManagedDiskParameters_Spec instances for property testing.
// We first initialize managedDiskParameters_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParameters_SpecGenerator() gopter.Gen {
	if managedDiskParameters_specGenerator != nil {
		return managedDiskParameters_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_Spec(generators)
	managedDiskParameters_specGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_Spec(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters_Spec(generators)
	managedDiskParameters_specGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Spec{}), generators)

	return managedDiskParameters_specGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters_Spec(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_SpecPremium_LRS,
		StorageAccountType_SpecPremium_ZRS,
		StorageAccountType_SpecStandardSSD_LRS,
		StorageAccountType_SpecStandardSSD_ZRS,
		StorageAccountType_SpecStandard_LRS,
		StorageAccountType_SpecUltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters_Spec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_ManagedDiskParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedDiskParameters_Status to ManagedDiskParameters_Status via AssignPropertiesToManagedDiskParameters_Status & AssignPropertiesFromManagedDiskParameters_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedDiskParameters_Status, ManagedDiskParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedDiskParameters_Status tests if a specific instance of ManagedDiskParameters_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForManagedDiskParameters_Status(subject ManagedDiskParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ManagedDiskParameters_Status
	err := copied.AssignPropertiesToManagedDiskParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedDiskParameters_Status
	err = actual.AssignPropertiesFromManagedDiskParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedDiskParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters_Status, ManagedDiskParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters_Status runs a test to see if a specific instance of ManagedDiskParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters_Status(subject ManagedDiskParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Status instances for property testing - lazily instantiated by
//ManagedDiskParameters_StatusGenerator()
var managedDiskParameters_statusGenerator gopter.Gen

// ManagedDiskParameters_StatusGenerator returns a generator of ManagedDiskParameters_Status instances for property testing.
// We first initialize managedDiskParameters_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParameters_StatusGenerator() gopter.Gen {
	if managedDiskParameters_statusGenerator != nil {
		return managedDiskParameters_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_Status(generators)
	managedDiskParameters_statusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_Status(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters_Status(generators)
	managedDiskParameters_statusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	return managedDiskParameters_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_StatusPremium_LRS,
		StorageAccountType_StatusPremium_ZRS,
		StorageAccountType_StatusStandardSSD_LRS,
		StorageAccountType_StatusStandardSSD_ZRS,
		StorageAccountType_StatusStandard_LRS,
		StorageAccountType_StatusUltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_PatchSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PatchSettings_Spec to PatchSettings_Spec via AssignPropertiesToPatchSettings_Spec & AssignPropertiesFromPatchSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPatchSettings_Spec, PatchSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPatchSettings_Spec tests if a specific instance of PatchSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForPatchSettings_Spec(subject PatchSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.PatchSettings_Spec
	err := copied.AssignPropertiesToPatchSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PatchSettings_Spec
	err = actual.AssignPropertiesFromPatchSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PatchSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings_Spec, PatchSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings_Spec runs a test to see if a specific instance of PatchSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings_Spec(subject PatchSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Spec instances for property testing - lazily instantiated by PatchSettings_SpecGenerator()
var patchSettings_specGenerator gopter.Gen

// PatchSettings_SpecGenerator returns a generator of PatchSettings_Spec instances for property testing.
func PatchSettings_SpecGenerator() gopter.Gen {
	if patchSettings_specGenerator != nil {
		return patchSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings_Spec(generators)
	patchSettings_specGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Spec{}), generators)

	return patchSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings_Spec(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_PatchMode_SpecAutomaticByOS, PatchSettings_PatchMode_SpecAutomaticByPlatform, PatchSettings_PatchMode_SpecManual))
}

func Test_PatchSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PatchSettings_Status to PatchSettings_Status via AssignPropertiesToPatchSettings_Status & AssignPropertiesFromPatchSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForPatchSettings_Status, PatchSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPatchSettings_Status tests if a specific instance of PatchSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForPatchSettings_Status(subject PatchSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.PatchSettings_Status
	err := copied.AssignPropertiesToPatchSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PatchSettings_Status
	err = actual.AssignPropertiesFromPatchSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings_Status, PatchSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings_Status runs a test to see if a specific instance of PatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings_Status(subject PatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Status instances for property testing - lazily instantiated by
//PatchSettings_StatusGenerator()
var patchSettings_statusGenerator gopter.Gen

// PatchSettings_StatusGenerator returns a generator of PatchSettings_Status instances for property testing.
func PatchSettings_StatusGenerator() gopter.Gen {
	if patchSettings_statusGenerator != nil {
		return patchSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings_Status(generators)
	patchSettings_statusGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Status{}), generators)

	return patchSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings_Status(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_PatchMode_StatusAutomaticByOS, PatchSettings_PatchMode_StatusAutomaticByPlatform, PatchSettings_PatchMode_StatusManual))
}

func Test_SshConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SshConfiguration_Spec to SshConfiguration_Spec via AssignPropertiesToSshConfiguration_Spec & AssignPropertiesFromSshConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSshConfiguration_Spec, SshConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSshConfiguration_Spec tests if a specific instance of SshConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSshConfiguration_Spec(subject SshConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SshConfiguration_Spec
	err := copied.AssignPropertiesToSshConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SshConfiguration_Spec
	err = actual.AssignPropertiesFromSshConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SshConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration_Spec, SshConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration_Spec runs a test to see if a specific instance of SshConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration_Spec(subject SshConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Spec instances for property testing - lazily instantiated by
//SshConfiguration_SpecGenerator()
var sshConfiguration_specGenerator gopter.Gen

// SshConfiguration_SpecGenerator returns a generator of SshConfiguration_Spec instances for property testing.
func SshConfiguration_SpecGenerator() gopter.Gen {
	if sshConfiguration_specGenerator != nil {
		return sshConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration_Spec(generators)
	sshConfiguration_specGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Spec{}), generators)

	return sshConfiguration_specGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKey_SpecGenerator())
}

func Test_SshConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SshConfiguration_Status to SshConfiguration_Status via AssignPropertiesToSshConfiguration_Status & AssignPropertiesFromSshConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSshConfiguration_Status, SshConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSshConfiguration_Status tests if a specific instance of SshConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSshConfiguration_Status(subject SshConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SshConfiguration_Status
	err := copied.AssignPropertiesToSshConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SshConfiguration_Status
	err = actual.AssignPropertiesFromSshConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SshConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration_Status, SshConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration_Status runs a test to see if a specific instance of SshConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration_Status(subject SshConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Status instances for property testing - lazily instantiated by
//SshConfiguration_StatusGenerator()
var sshConfiguration_statusGenerator gopter.Gen

// SshConfiguration_StatusGenerator returns a generator of SshConfiguration_Status instances for property testing.
func SshConfiguration_StatusGenerator() gopter.Gen {
	if sshConfiguration_statusGenerator != nil {
		return sshConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration_Status(generators)
	sshConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Status{}), generators)

	return sshConfiguration_statusGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration_Status(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKey_StatusGenerator())
}

func Test_VaultCertificate_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultCertificate_Spec to VaultCertificate_Spec via AssignPropertiesToVaultCertificate_Spec & AssignPropertiesFromVaultCertificate_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultCertificate_Spec, VaultCertificate_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultCertificate_Spec tests if a specific instance of VaultCertificate_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVaultCertificate_Spec(subject VaultCertificate_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VaultCertificate_Spec
	err := copied.AssignPropertiesToVaultCertificate_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultCertificate_Spec
	err = actual.AssignPropertiesFromVaultCertificate_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultCertificate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate_Spec, VaultCertificate_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate_Spec runs a test to see if a specific instance of VaultCertificate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate_Spec(subject VaultCertificate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Spec instances for property testing - lazily instantiated by
//VaultCertificate_SpecGenerator()
var vaultCertificate_specGenerator gopter.Gen

// VaultCertificate_SpecGenerator returns a generator of VaultCertificate_Spec instances for property testing.
func VaultCertificate_SpecGenerator() gopter.Gen {
	if vaultCertificate_specGenerator != nil {
		return vaultCertificate_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate_Spec(generators)
	vaultCertificate_specGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Spec{}), generators)

	return vaultCertificate_specGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate_Spec(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VaultCertificate_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultCertificate_Status to VaultCertificate_Status via AssignPropertiesToVaultCertificate_Status & AssignPropertiesFromVaultCertificate_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultCertificate_Status, VaultCertificate_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultCertificate_Status tests if a specific instance of VaultCertificate_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVaultCertificate_Status(subject VaultCertificate_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VaultCertificate_Status
	err := copied.AssignPropertiesToVaultCertificate_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultCertificate_Status
	err = actual.AssignPropertiesFromVaultCertificate_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate_Status, VaultCertificate_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate_Status runs a test to see if a specific instance of VaultCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate_Status(subject VaultCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Status instances for property testing - lazily instantiated by
//VaultCertificate_StatusGenerator()
var vaultCertificate_statusGenerator gopter.Gen

// VaultCertificate_StatusGenerator returns a generator of VaultCertificate_Status instances for property testing.
func VaultCertificate_StatusGenerator() gopter.Gen {
	if vaultCertificate_statusGenerator != nil {
		return vaultCertificate_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate_Status(generators)
	vaultCertificate_statusGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Status{}), generators)

	return vaultCertificate_statusGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate_Status(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualHardDisk_Spec to VirtualHardDisk_Spec via AssignPropertiesToVirtualHardDisk_Spec & AssignPropertiesFromVirtualHardDisk_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualHardDisk_Spec, VirtualHardDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualHardDisk_Spec tests if a specific instance of VirtualHardDisk_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualHardDisk_Spec(subject VirtualHardDisk_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualHardDisk_Spec
	err := copied.AssignPropertiesToVirtualHardDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualHardDisk_Spec
	err = actual.AssignPropertiesFromVirtualHardDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualHardDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk_Spec, VirtualHardDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk_Spec runs a test to see if a specific instance of VirtualHardDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk_Spec(subject VirtualHardDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Spec instances for property testing - lazily instantiated by
//VirtualHardDisk_SpecGenerator()
var virtualHardDisk_specGenerator gopter.Gen

// VirtualHardDisk_SpecGenerator returns a generator of VirtualHardDisk_Spec instances for property testing.
func VirtualHardDisk_SpecGenerator() gopter.Gen {
	if virtualHardDisk_specGenerator != nil {
		return virtualHardDisk_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk_Spec(generators)
	virtualHardDisk_specGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Spec{}), generators)

	return virtualHardDisk_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk_Spec(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualHardDisk_Status to VirtualHardDisk_Status via AssignPropertiesToVirtualHardDisk_Status & AssignPropertiesFromVirtualHardDisk_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualHardDisk_Status, VirtualHardDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualHardDisk_Status tests if a specific instance of VirtualHardDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualHardDisk_Status(subject VirtualHardDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualHardDisk_Status
	err := copied.AssignPropertiesToVirtualHardDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualHardDisk_Status
	err = actual.AssignPropertiesFromVirtualHardDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualHardDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk_Status, VirtualHardDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk_Status runs a test to see if a specific instance of VirtualHardDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk_Status(subject VirtualHardDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Status instances for property testing - lazily instantiated by
//VirtualHardDisk_StatusGenerator()
var virtualHardDisk_statusGenerator gopter.Gen

// VirtualHardDisk_StatusGenerator returns a generator of VirtualHardDisk_Status instances for property testing.
func VirtualHardDisk_StatusGenerator() gopter.Gen {
	if virtualHardDisk_statusGenerator != nil {
		return virtualHardDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk_Status(generators)
	virtualHardDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Status{}), generators)

	return virtualHardDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk_Status(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceView_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineExtensionHandlerInstanceView_Status to VirtualMachineExtensionHandlerInstanceView_Status via AssignPropertiesToVirtualMachineExtensionHandlerInstanceView_Status & AssignPropertiesFromVirtualMachineExtensionHandlerInstanceView_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineExtensionHandlerInstanceView_Status, VirtualMachineExtensionHandlerInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineExtensionHandlerInstanceView_Status tests if a specific instance of VirtualMachineExtensionHandlerInstanceView_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineExtensionHandlerInstanceView_Status(subject VirtualMachineExtensionHandlerInstanceView_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineExtensionHandlerInstanceView_Status
	err := copied.AssignPropertiesToVirtualMachineExtensionHandlerInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineExtensionHandlerInstanceView_Status
	err = actual.AssignPropertiesFromVirtualMachineExtensionHandlerInstanceView_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineExtensionHandlerInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_Status, VirtualMachineExtensionHandlerInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_Status runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_Status(subject VirtualMachineExtensionHandlerInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing - lazily instantiated
//by VirtualMachineExtensionHandlerInstanceView_StatusGenerator()
var virtualMachineExtensionHandlerInstanceView_statusGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceView_StatusGenerator returns a generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceView_StatusGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceView_statusGenerator != nil {
		return virtualMachineExtensionHandlerInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(generators)
	virtualMachineExtensionHandlerInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(generators)
	virtualMachineExtensionHandlerInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	return virtualMachineExtensionHandlerInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusGenerator())
}

func Test_WinRMConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WinRMConfiguration_Spec to WinRMConfiguration_Spec via AssignPropertiesToWinRMConfiguration_Spec & AssignPropertiesFromWinRMConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWinRMConfiguration_Spec, WinRMConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWinRMConfiguration_Spec tests if a specific instance of WinRMConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWinRMConfiguration_Spec(subject WinRMConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WinRMConfiguration_Spec
	err := copied.AssignPropertiesToWinRMConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WinRMConfiguration_Spec
	err = actual.AssignPropertiesFromWinRMConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WinRMConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration_Spec, WinRMConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration_Spec runs a test to see if a specific instance of WinRMConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration_Spec(subject WinRMConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Spec instances for property testing - lazily instantiated by
//WinRMConfiguration_SpecGenerator()
var winRMConfiguration_specGenerator gopter.Gen

// WinRMConfiguration_SpecGenerator returns a generator of WinRMConfiguration_Spec instances for property testing.
func WinRMConfiguration_SpecGenerator() gopter.Gen {
	if winRMConfiguration_specGenerator != nil {
		return winRMConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration_Spec(generators)
	winRMConfiguration_specGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Spec{}), generators)

	return winRMConfiguration_specGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListener_SpecGenerator())
}

func Test_WinRMConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WinRMConfiguration_Status to WinRMConfiguration_Status via AssignPropertiesToWinRMConfiguration_Status & AssignPropertiesFromWinRMConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWinRMConfiguration_Status, WinRMConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWinRMConfiguration_Status tests if a specific instance of WinRMConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWinRMConfiguration_Status(subject WinRMConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WinRMConfiguration_Status
	err := copied.AssignPropertiesToWinRMConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WinRMConfiguration_Status
	err = actual.AssignPropertiesFromWinRMConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WinRMConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration_Status, WinRMConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration_Status runs a test to see if a specific instance of WinRMConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration_Status(subject WinRMConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Status instances for property testing - lazily instantiated by
//WinRMConfiguration_StatusGenerator()
var winRMConfiguration_statusGenerator gopter.Gen

// WinRMConfiguration_StatusGenerator returns a generator of WinRMConfiguration_Status instances for property testing.
func WinRMConfiguration_StatusGenerator() gopter.Gen {
	if winRMConfiguration_statusGenerator != nil {
		return winRMConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration_Status(generators)
	winRMConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Status{}), generators)

	return winRMConfiguration_statusGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration_Status(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListener_StatusGenerator())
}

func Test_ApiError_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiError_Status to ApiError_Status via AssignPropertiesToApiError_Status & AssignPropertiesFromApiError_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiError_Status, ApiError_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiError_Status tests if a specific instance of ApiError_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForApiError_Status(subject ApiError_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ApiError_Status
	err := copied.AssignPropertiesToApiError_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiError_Status
	err = actual.AssignPropertiesFromApiError_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiError_Status, ApiError_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiError_Status runs a test to see if a specific instance of ApiError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiError_Status(subject ApiError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiError_Status instances for property testing - lazily instantiated by ApiError_StatusGenerator()
var apiError_statusGenerator gopter.Gen

// ApiError_StatusGenerator returns a generator of ApiError_Status instances for property testing.
// We first initialize apiError_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiError_StatusGenerator() gopter.Gen {
	if apiError_statusGenerator != nil {
		return apiError_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiError_Status(generators)
	apiError_statusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiError_Status(generators)
	AddRelatedPropertyGeneratorsForApiError_Status(generators)
	apiError_statusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	return apiError_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiError_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiError_Status(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiError_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiError_Status(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBase_StatusGenerator())
	gens["Innererror"] = gen.PtrOf(InnerError_StatusGenerator())
}

func Test_KeyVaultKeyReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultKeyReference_Spec to KeyVaultKeyReference_Spec via AssignPropertiesToKeyVaultKeyReference_Spec & AssignPropertiesFromKeyVaultKeyReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultKeyReference_Spec, KeyVaultKeyReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultKeyReference_Spec tests if a specific instance of KeyVaultKeyReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultKeyReference_Spec(subject KeyVaultKeyReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.KeyVaultKeyReference_Spec
	err := copied.AssignPropertiesToKeyVaultKeyReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultKeyReference_Spec
	err = actual.AssignPropertiesFromKeyVaultKeyReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultKeyReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference_Spec, KeyVaultKeyReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference_Spec runs a test to see if a specific instance of KeyVaultKeyReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference_Spec(subject KeyVaultKeyReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Spec instances for property testing - lazily instantiated by
//KeyVaultKeyReference_SpecGenerator()
var keyVaultKeyReference_specGenerator gopter.Gen

// KeyVaultKeyReference_SpecGenerator returns a generator of KeyVaultKeyReference_Spec instances for property testing.
// We first initialize keyVaultKeyReference_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReference_SpecGenerator() gopter.Gen {
	if keyVaultKeyReference_specGenerator != nil {
		return keyVaultKeyReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Spec(generators)
	keyVaultKeyReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Spec(generators)
	keyVaultKeyReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Spec{}), generators)

	return keyVaultKeyReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Spec(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResource_SpecGenerator()
}

func Test_KeyVaultKeyReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultKeyReference_Status to KeyVaultKeyReference_Status via AssignPropertiesToKeyVaultKeyReference_Status & AssignPropertiesFromKeyVaultKeyReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultKeyReference_Status, KeyVaultKeyReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultKeyReference_Status tests if a specific instance of KeyVaultKeyReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultKeyReference_Status(subject KeyVaultKeyReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.KeyVaultKeyReference_Status
	err := copied.AssignPropertiesToKeyVaultKeyReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultKeyReference_Status
	err = actual.AssignPropertiesFromKeyVaultKeyReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultKeyReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference_Status, KeyVaultKeyReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference_Status runs a test to see if a specific instance of KeyVaultKeyReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference_Status(subject KeyVaultKeyReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Status instances for property testing - lazily instantiated by
//KeyVaultKeyReference_StatusGenerator()
var keyVaultKeyReference_statusGenerator gopter.Gen

// KeyVaultKeyReference_StatusGenerator returns a generator of KeyVaultKeyReference_Status instances for property testing.
// We first initialize keyVaultKeyReference_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReference_StatusGenerator() gopter.Gen {
	if keyVaultKeyReference_statusGenerator != nil {
		return keyVaultKeyReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Status(generators)
	keyVaultKeyReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Status(generators)
	keyVaultKeyReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	return keyVaultKeyReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Status(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResource_StatusGenerator()
}

func Test_KeyVaultSecretReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSecretReference_Spec to KeyVaultSecretReference_Spec via AssignPropertiesToKeyVaultSecretReference_Spec & AssignPropertiesFromKeyVaultSecretReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSecretReference_Spec, KeyVaultSecretReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSecretReference_Spec tests if a specific instance of KeyVaultSecretReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSecretReference_Spec(subject KeyVaultSecretReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.KeyVaultSecretReference_Spec
	err := copied.AssignPropertiesToKeyVaultSecretReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSecretReference_Spec
	err = actual.AssignPropertiesFromKeyVaultSecretReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSecretReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference_Spec, KeyVaultSecretReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference_Spec runs a test to see if a specific instance of KeyVaultSecretReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference_Spec(subject KeyVaultSecretReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Spec instances for property testing - lazily instantiated by
//KeyVaultSecretReference_SpecGenerator()
var keyVaultSecretReference_specGenerator gopter.Gen

// KeyVaultSecretReference_SpecGenerator returns a generator of KeyVaultSecretReference_Spec instances for property testing.
// We first initialize keyVaultSecretReference_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReference_SpecGenerator() gopter.Gen {
	if keyVaultSecretReference_specGenerator != nil {
		return keyVaultSecretReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Spec(generators)
	keyVaultSecretReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Spec(generators)
	keyVaultSecretReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Spec{}), generators)

	return keyVaultSecretReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Spec(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResource_SpecGenerator()
}

func Test_KeyVaultSecretReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSecretReference_Status to KeyVaultSecretReference_Status via AssignPropertiesToKeyVaultSecretReference_Status & AssignPropertiesFromKeyVaultSecretReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSecretReference_Status, KeyVaultSecretReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSecretReference_Status tests if a specific instance of KeyVaultSecretReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSecretReference_Status(subject KeyVaultSecretReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.KeyVaultSecretReference_Status
	err := copied.AssignPropertiesToKeyVaultSecretReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSecretReference_Status
	err = actual.AssignPropertiesFromKeyVaultSecretReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSecretReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference_Status, KeyVaultSecretReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference_Status runs a test to see if a specific instance of KeyVaultSecretReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference_Status(subject KeyVaultSecretReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Status instances for property testing - lazily instantiated by
//KeyVaultSecretReference_StatusGenerator()
var keyVaultSecretReference_statusGenerator gopter.Gen

// KeyVaultSecretReference_StatusGenerator returns a generator of KeyVaultSecretReference_Status instances for property testing.
// We first initialize keyVaultSecretReference_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReference_StatusGenerator() gopter.Gen {
	if keyVaultSecretReference_statusGenerator != nil {
		return keyVaultSecretReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Status(generators)
	keyVaultSecretReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Status(generators)
	keyVaultSecretReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	return keyVaultSecretReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Status(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResource_StatusGenerator()
}

func Test_SshPublicKey_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SshPublicKey_Spec to SshPublicKey_Spec via AssignPropertiesToSshPublicKey_Spec & AssignPropertiesFromSshPublicKey_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSshPublicKey_Spec, SshPublicKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSshPublicKey_Spec tests if a specific instance of SshPublicKey_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSshPublicKey_Spec(subject SshPublicKey_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SshPublicKey_Spec
	err := copied.AssignPropertiesToSshPublicKey_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SshPublicKey_Spec
	err = actual.AssignPropertiesFromSshPublicKey_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SshPublicKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKey_Spec, SshPublicKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKey_Spec runs a test to see if a specific instance of SshPublicKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKey_Spec(subject SshPublicKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Spec instances for property testing - lazily instantiated by SshPublicKey_SpecGenerator()
var sshPublicKey_specGenerator gopter.Gen

// SshPublicKey_SpecGenerator returns a generator of SshPublicKey_Spec instances for property testing.
func SshPublicKey_SpecGenerator() gopter.Gen {
	if sshPublicKey_specGenerator != nil {
		return sshPublicKey_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKey_Spec(generators)
	sshPublicKey_specGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Spec{}), generators)

	return sshPublicKey_specGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKey_Spec(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_SshPublicKey_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SshPublicKey_Status to SshPublicKey_Status via AssignPropertiesToSshPublicKey_Status & AssignPropertiesFromSshPublicKey_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSshPublicKey_Status, SshPublicKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSshPublicKey_Status tests if a specific instance of SshPublicKey_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSshPublicKey_Status(subject SshPublicKey_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.SshPublicKey_Status
	err := copied.AssignPropertiesToSshPublicKey_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SshPublicKey_Status
	err = actual.AssignPropertiesFromSshPublicKey_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SshPublicKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKey_Status, SshPublicKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKey_Status runs a test to see if a specific instance of SshPublicKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKey_Status(subject SshPublicKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Status instances for property testing - lazily instantiated by
//SshPublicKey_StatusGenerator()
var sshPublicKey_statusGenerator gopter.Gen

// SshPublicKey_StatusGenerator returns a generator of SshPublicKey_Status instances for property testing.
func SshPublicKey_StatusGenerator() gopter.Gen {
	if sshPublicKey_statusGenerator != nil {
		return sshPublicKey_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKey_Status(generators)
	sshPublicKey_statusGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Status{}), generators)

	return sshPublicKey_statusGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKey_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKey_Status(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WinRMListener_Spec to WinRMListener_Spec via AssignPropertiesToWinRMListener_Spec & AssignPropertiesFromWinRMListener_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWinRMListener_Spec, WinRMListener_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWinRMListener_Spec tests if a specific instance of WinRMListener_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWinRMListener_Spec(subject WinRMListener_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WinRMListener_Spec
	err := copied.AssignPropertiesToWinRMListener_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WinRMListener_Spec
	err = actual.AssignPropertiesFromWinRMListener_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WinRMListener_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener_Spec, WinRMListener_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener_Spec runs a test to see if a specific instance of WinRMListener_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener_Spec(subject WinRMListener_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Spec instances for property testing - lazily instantiated by WinRMListener_SpecGenerator()
var winRMListener_specGenerator gopter.Gen

// WinRMListener_SpecGenerator returns a generator of WinRMListener_Spec instances for property testing.
func WinRMListener_SpecGenerator() gopter.Gen {
	if winRMListener_specGenerator != nil {
		return winRMListener_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener_Spec(generators)
	winRMListener_specGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Spec{}), generators)

	return winRMListener_specGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener_Spec(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListener_Protocol_SpecHttp, WinRMListener_Protocol_SpecHttps))
}

func Test_WinRMListener_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WinRMListener_Status to WinRMListener_Status via AssignPropertiesToWinRMListener_Status & AssignPropertiesFromWinRMListener_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWinRMListener_Status, WinRMListener_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWinRMListener_Status tests if a specific instance of WinRMListener_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForWinRMListener_Status(subject WinRMListener_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.WinRMListener_Status
	err := copied.AssignPropertiesToWinRMListener_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WinRMListener_Status
	err = actual.AssignPropertiesFromWinRMListener_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WinRMListener_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener_Status, WinRMListener_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener_Status runs a test to see if a specific instance of WinRMListener_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener_Status(subject WinRMListener_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Status instances for property testing - lazily instantiated by
//WinRMListener_StatusGenerator()
var winRMListener_statusGenerator gopter.Gen

// WinRMListener_StatusGenerator returns a generator of WinRMListener_Status instances for property testing.
func WinRMListener_StatusGenerator() gopter.Gen {
	if winRMListener_statusGenerator != nil {
		return winRMListener_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener_Status(generators)
	winRMListener_statusGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Status{}), generators)

	return winRMListener_statusGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener_Status(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListener_Protocol_StatusHttp, WinRMListener_Protocol_StatusHttps))
}

func Test_ApiErrorBase_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiErrorBase_Status to ApiErrorBase_Status via AssignPropertiesToApiErrorBase_Status & AssignPropertiesFromApiErrorBase_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiErrorBase_Status, ApiErrorBase_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiErrorBase_Status tests if a specific instance of ApiErrorBase_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForApiErrorBase_Status(subject ApiErrorBase_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ApiErrorBase_Status
	err := copied.AssignPropertiesToApiErrorBase_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiErrorBase_Status
	err = actual.AssignPropertiesFromApiErrorBase_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiErrorBase_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBase_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBase_Status, ApiErrorBase_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBase_Status runs a test to see if a specific instance of ApiErrorBase_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBase_Status(subject ApiErrorBase_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBase_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBase_Status instances for property testing - lazily instantiated by
//ApiErrorBase_StatusGenerator()
var apiErrorBase_statusGenerator gopter.Gen

// ApiErrorBase_StatusGenerator returns a generator of ApiErrorBase_Status instances for property testing.
func ApiErrorBase_StatusGenerator() gopter.Gen {
	if apiErrorBase_statusGenerator != nil {
		return apiErrorBase_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBase_Status(generators)
	apiErrorBase_statusGenerator = gen.Struct(reflect.TypeOf(ApiErrorBase_Status{}), generators)

	return apiErrorBase_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBase_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBase_Status(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerError_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InnerError_Status to InnerError_Status via AssignPropertiesToInnerError_Status & AssignPropertiesFromInnerError_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForInnerError_Status, InnerError_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInnerError_Status tests if a specific instance of InnerError_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForInnerError_Status(subject InnerError_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.InnerError_Status
	err := copied.AssignPropertiesToInnerError_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InnerError_Status
	err = actual.AssignPropertiesFromInnerError_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InnerError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerError_Status, InnerError_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerError_Status runs a test to see if a specific instance of InnerError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerError_Status(subject InnerError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_Status instances for property testing - lazily instantiated by InnerError_StatusGenerator()
var innerError_statusGenerator gopter.Gen

// InnerError_StatusGenerator returns a generator of InnerError_Status instances for property testing.
func InnerError_StatusGenerator() gopter.Gen {
	if innerError_statusGenerator != nil {
		return innerError_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_Status(generators)
	innerError_statusGenerator = gen.Struct(reflect.TypeOf(InnerError_Status{}), generators)

	return innerError_statusGenerator
}

// AddIndependentPropertyGeneratorsForInnerError_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerError_Status(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}
