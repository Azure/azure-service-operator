// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachineScaleSet_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSet to hub returns original",
		prop.ForAll(RunResourceConversionTestForVirtualMachineScaleSet, VirtualMachineScaleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForVirtualMachineScaleSet tests if a specific instance of VirtualMachineScaleSet round trips to the hub storage version and back losslessly
func RunResourceConversionTestForVirtualMachineScaleSet(subject VirtualMachineScaleSet) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20201201storage.VirtualMachineScaleSet
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual VirtualMachineScaleSet
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSet to VirtualMachineScaleSet via AssignPropertiesToVirtualMachineScaleSet & AssignPropertiesFromVirtualMachineScaleSet returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSet, VirtualMachineScaleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSet tests if a specific instance of VirtualMachineScaleSet can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSet(subject VirtualMachineScaleSet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSet
	err := copied.AssignPropertiesToVirtualMachineScaleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSet
	err = actual.AssignPropertiesFromVirtualMachineScaleSet(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSet, VirtualMachineScaleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSet runs a test to see if a specific instance of VirtualMachineScaleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSet(subject VirtualMachineScaleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSet instances for property testing - lazily instantiated by
//VirtualMachineScaleSetGenerator()
var virtualMachineScaleSetGenerator gopter.Gen

// VirtualMachineScaleSetGenerator returns a generator of VirtualMachineScaleSet instances for property testing.
func VirtualMachineScaleSetGenerator() gopter.Gen {
	if virtualMachineScaleSetGenerator != nil {
		return virtualMachineScaleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSet(generators)
	virtualMachineScaleSetGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSet{}), generators)

	return virtualMachineScaleSetGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSet(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualMachineScaleSets_SPECGenerator()
	gens["Status"] = VirtualMachineScaleSet_StatusGenerator()
}

func Test_VirtualMachineScaleSet_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSet_Status to VirtualMachineScaleSet_Status via AssignPropertiesToVirtualMachineScaleSet_Status & AssignPropertiesFromVirtualMachineScaleSet_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSet_Status, VirtualMachineScaleSet_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSet_Status tests if a specific instance of VirtualMachineScaleSet_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSet_Status(subject VirtualMachineScaleSet_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSet_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSet_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSet_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSet_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSet_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSet_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSet_Status, VirtualMachineScaleSet_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSet_Status runs a test to see if a specific instance of VirtualMachineScaleSet_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSet_Status(subject VirtualMachineScaleSet_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSet_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSet_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSet_StatusGenerator()
var virtualMachineScaleSet_statusGenerator gopter.Gen

// VirtualMachineScaleSet_StatusGenerator returns a generator of VirtualMachineScaleSet_Status instances for property testing.
// We first initialize virtualMachineScaleSet_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSet_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSet_statusGenerator != nil {
		return virtualMachineScaleSet_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Status(generators)
	virtualMachineScaleSet_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSet_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Status(generators)
	virtualMachineScaleSet_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSet_Status{}), generators)

	return virtualMachineScaleSet_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Status(gens map[string]gopter.Gen) {
	gens["DoNotRunExtensionsOnOverprovisionedVMs"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OrchestrationMode"] = gen.PtrOf(gen.OneConstOf(OrchestrationMode_StatusFlexible, OrchestrationMode_StatusUniform))
	gens["Overprovision"] = gen.PtrOf(gen.Bool())
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["SinglePlacementGroup"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneBalance"] = gen.PtrOf(gen.Bool())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Status(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_StatusGenerator())
	gens["AutomaticRepairsPolicy"] = gen.PtrOf(AutomaticRepairsPolicy_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineScaleSetIdentity_StatusGenerator())
	gens["Plan"] = gen.PtrOf(Plan_StatusGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["ScaleInPolicy"] = gen.PtrOf(ScaleInPolicy_StatusGenerator())
	gens["Sku"] = gen.PtrOf(Sku_StatusGenerator())
	gens["UpgradePolicy"] = gen.PtrOf(UpgradePolicy_StatusGenerator())
	gens["VirtualMachineProfile"] = gen.PtrOf(VirtualMachineScaleSetVMProfile_StatusGenerator())
}

func Test_VirtualMachineScaleSets_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSets_SPEC to VirtualMachineScaleSets_SPEC via AssignPropertiesToVirtualMachineScaleSets_SPEC & AssignPropertiesFromVirtualMachineScaleSets_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSets_SPEC, VirtualMachineScaleSets_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSets_SPEC tests if a specific instance of VirtualMachineScaleSets_SPEC can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSets_SPEC(subject VirtualMachineScaleSets_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSets_SPEC
	err := copied.AssignPropertiesToVirtualMachineScaleSets_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSets_SPEC
	err = actual.AssignPropertiesFromVirtualMachineScaleSets_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSets_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSets_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSets_SPEC, VirtualMachineScaleSets_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSets_SPEC runs a test to see if a specific instance of VirtualMachineScaleSets_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSets_SPEC(subject VirtualMachineScaleSets_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSets_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSets_SPEC instances for property testing - lazily instantiated by
//VirtualMachineScaleSets_SPECGenerator()
var virtualMachineScaleSets_specGenerator gopter.Gen

// VirtualMachineScaleSets_SPECGenerator returns a generator of VirtualMachineScaleSets_SPEC instances for property testing.
// We first initialize virtualMachineScaleSets_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSets_SPECGenerator() gopter.Gen {
	if virtualMachineScaleSets_specGenerator != nil {
		return virtualMachineScaleSets_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSets_SPEC(generators)
	virtualMachineScaleSets_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSets_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSets_SPEC(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSets_SPEC(generators)
	virtualMachineScaleSets_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSets_SPEC{}), generators)

	return virtualMachineScaleSets_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSets_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSets_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["DoNotRunExtensionsOnOverprovisionedVMs"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.AlphaString()
	gens["OrchestrationMode"] = gen.PtrOf(gen.OneConstOf(OrchestrationMode_SpecFlexible, OrchestrationMode_SpecUniform))
	gens["Overprovision"] = gen.PtrOf(gen.Bool())
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["SinglePlacementGroup"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ZoneBalance"] = gen.PtrOf(gen.Bool())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSets_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSets_SPEC(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_SpecGenerator())
	gens["AutomaticRepairsPolicy"] = gen.PtrOf(AutomaticRepairsPolicy_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineScaleSetIdentity_SpecGenerator())
	gens["Plan"] = gen.PtrOf(Plan_SpecGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["ScaleInPolicy"] = gen.PtrOf(ScaleInPolicy_SpecGenerator())
	gens["Sku"] = gen.PtrOf(Sku_SpecGenerator())
	gens["UpgradePolicy"] = gen.PtrOf(UpgradePolicy_SpecGenerator())
	gens["VirtualMachineProfile"] = gen.PtrOf(VirtualMachineScaleSetVMProfile_SpecGenerator())
}

func Test_AutomaticRepairsPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomaticRepairsPolicy_Spec to AutomaticRepairsPolicy_Spec via AssignPropertiesToAutomaticRepairsPolicy_Spec & AssignPropertiesFromAutomaticRepairsPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomaticRepairsPolicy_Spec, AutomaticRepairsPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomaticRepairsPolicy_Spec tests if a specific instance of AutomaticRepairsPolicy_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAutomaticRepairsPolicy_Spec(subject AutomaticRepairsPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AutomaticRepairsPolicy_Spec
	err := copied.AssignPropertiesToAutomaticRepairsPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomaticRepairsPolicy_Spec
	err = actual.AssignPropertiesFromAutomaticRepairsPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomaticRepairsPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomaticRepairsPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomaticRepairsPolicy_Spec, AutomaticRepairsPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomaticRepairsPolicy_Spec runs a test to see if a specific instance of AutomaticRepairsPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomaticRepairsPolicy_Spec(subject AutomaticRepairsPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomaticRepairsPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomaticRepairsPolicy_Spec instances for property testing - lazily instantiated by
//AutomaticRepairsPolicy_SpecGenerator()
var automaticRepairsPolicy_specGenerator gopter.Gen

// AutomaticRepairsPolicy_SpecGenerator returns a generator of AutomaticRepairsPolicy_Spec instances for property testing.
func AutomaticRepairsPolicy_SpecGenerator() gopter.Gen {
	if automaticRepairsPolicy_specGenerator != nil {
		return automaticRepairsPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Spec(generators)
	automaticRepairsPolicy_specGenerator = gen.Struct(reflect.TypeOf(AutomaticRepairsPolicy_Spec{}), generators)

	return automaticRepairsPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GracePeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutomaticRepairsPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomaticRepairsPolicy_Status to AutomaticRepairsPolicy_Status via AssignPropertiesToAutomaticRepairsPolicy_Status & AssignPropertiesFromAutomaticRepairsPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomaticRepairsPolicy_Status, AutomaticRepairsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomaticRepairsPolicy_Status tests if a specific instance of AutomaticRepairsPolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAutomaticRepairsPolicy_Status(subject AutomaticRepairsPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AutomaticRepairsPolicy_Status
	err := copied.AssignPropertiesToAutomaticRepairsPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomaticRepairsPolicy_Status
	err = actual.AssignPropertiesFromAutomaticRepairsPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomaticRepairsPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomaticRepairsPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomaticRepairsPolicy_Status, AutomaticRepairsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomaticRepairsPolicy_Status runs a test to see if a specific instance of AutomaticRepairsPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomaticRepairsPolicy_Status(subject AutomaticRepairsPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomaticRepairsPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomaticRepairsPolicy_Status instances for property testing - lazily instantiated by
//AutomaticRepairsPolicy_StatusGenerator()
var automaticRepairsPolicy_statusGenerator gopter.Gen

// AutomaticRepairsPolicy_StatusGenerator returns a generator of AutomaticRepairsPolicy_Status instances for property testing.
func AutomaticRepairsPolicy_StatusGenerator() gopter.Gen {
	if automaticRepairsPolicy_statusGenerator != nil {
		return automaticRepairsPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Status(generators)
	automaticRepairsPolicy_statusGenerator = gen.Struct(reflect.TypeOf(AutomaticRepairsPolicy_Status{}), generators)

	return automaticRepairsPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GracePeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleInPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleInPolicy_Spec to ScaleInPolicy_Spec via AssignPropertiesToScaleInPolicy_Spec & AssignPropertiesFromScaleInPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleInPolicy_Spec, ScaleInPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleInPolicy_Spec tests if a specific instance of ScaleInPolicy_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForScaleInPolicy_Spec(subject ScaleInPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ScaleInPolicy_Spec
	err := copied.AssignPropertiesToScaleInPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleInPolicy_Spec
	err = actual.AssignPropertiesFromScaleInPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleInPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleInPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleInPolicy_Spec, ScaleInPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleInPolicy_Spec runs a test to see if a specific instance of ScaleInPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleInPolicy_Spec(subject ScaleInPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleInPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleInPolicy_Spec instances for property testing - lazily instantiated by ScaleInPolicy_SpecGenerator()
var scaleInPolicy_specGenerator gopter.Gen

// ScaleInPolicy_SpecGenerator returns a generator of ScaleInPolicy_Spec instances for property testing.
func ScaleInPolicy_SpecGenerator() gopter.Gen {
	if scaleInPolicy_specGenerator != nil {
		return scaleInPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleInPolicy_Spec(generators)
	scaleInPolicy_specGenerator = gen.Struct(reflect.TypeOf(ScaleInPolicy_Spec{}), generators)

	return scaleInPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForScaleInPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleInPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(gen.OneConstOf(ScaleInPolicy_Rules_SpecDefault, ScaleInPolicy_Rules_SpecNewestVM, ScaleInPolicy_Rules_SpecOldestVM))
}

func Test_ScaleInPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleInPolicy_Status to ScaleInPolicy_Status via AssignPropertiesToScaleInPolicy_Status & AssignPropertiesFromScaleInPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleInPolicy_Status, ScaleInPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleInPolicy_Status tests if a specific instance of ScaleInPolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForScaleInPolicy_Status(subject ScaleInPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ScaleInPolicy_Status
	err := copied.AssignPropertiesToScaleInPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleInPolicy_Status
	err = actual.AssignPropertiesFromScaleInPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleInPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleInPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleInPolicy_Status, ScaleInPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleInPolicy_Status runs a test to see if a specific instance of ScaleInPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleInPolicy_Status(subject ScaleInPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleInPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleInPolicy_Status instances for property testing - lazily instantiated by
//ScaleInPolicy_StatusGenerator()
var scaleInPolicy_statusGenerator gopter.Gen

// ScaleInPolicy_StatusGenerator returns a generator of ScaleInPolicy_Status instances for property testing.
func ScaleInPolicy_StatusGenerator() gopter.Gen {
	if scaleInPolicy_statusGenerator != nil {
		return scaleInPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleInPolicy_Status(generators)
	scaleInPolicy_statusGenerator = gen.Struct(reflect.TypeOf(ScaleInPolicy_Status{}), generators)

	return scaleInPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForScaleInPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleInPolicy_Status(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(gen.OneConstOf(ScaleInPolicy_Rules_StatusDefault, ScaleInPolicy_Rules_StatusNewestVM, ScaleInPolicy_Rules_StatusOldestVM))
}

func Test_Sku_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_Spec to Sku_Spec via AssignPropertiesToSku_Spec & AssignPropertiesFromSku_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_Spec, Sku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_Spec tests if a specific instance of Sku_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSku_Spec(subject Sku_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.Sku_Spec
	err := copied.AssignPropertiesToSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_Spec
	err = actual.AssignPropertiesFromSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_Spec, Sku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_Spec runs a test to see if a specific instance of Sku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_Spec(subject Sku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_Spec instances for property testing - lazily instantiated by Sku_SpecGenerator()
var sku_specGenerator gopter.Gen

// Sku_SpecGenerator returns a generator of Sku_Spec instances for property testing.
func Sku_SpecGenerator() gopter.Gen {
	if sku_specGenerator != nil {
		return sku_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_Spec(generators)
	sku_specGenerator = gen.Struct(reflect.TypeOf(Sku_Spec{}), generators)

	return sku_specGenerator
}

// AddIndependentPropertyGeneratorsForSku_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_Spec(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_Status to Sku_Status via AssignPropertiesToSku_Status & AssignPropertiesFromSku_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_Status, Sku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_Status tests if a specific instance of Sku_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSku_Status(subject Sku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.Sku_Status
	err := copied.AssignPropertiesToSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_Status
	err = actual.AssignPropertiesFromSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_Status, Sku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_Status runs a test to see if a specific instance of Sku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_Status(subject Sku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_Status instances for property testing - lazily instantiated by Sku_StatusGenerator()
var sku_statusGenerator gopter.Gen

// Sku_StatusGenerator returns a generator of Sku_Status instances for property testing.
func Sku_StatusGenerator() gopter.Gen {
	if sku_statusGenerator != nil {
		return sku_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_Status(generators)
	sku_statusGenerator = gen.Struct(reflect.TypeOf(Sku_Status{}), generators)

	return sku_statusGenerator
}

// AddIndependentPropertyGeneratorsForSku_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_Status(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpgradePolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpgradePolicy_Spec to UpgradePolicy_Spec via AssignPropertiesToUpgradePolicy_Spec & AssignPropertiesFromUpgradePolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpgradePolicy_Spec, UpgradePolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpgradePolicy_Spec tests if a specific instance of UpgradePolicy_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForUpgradePolicy_Spec(subject UpgradePolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.UpgradePolicy_Spec
	err := copied.AssignPropertiesToUpgradePolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpgradePolicy_Spec
	err = actual.AssignPropertiesFromUpgradePolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpgradePolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpgradePolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpgradePolicy_Spec, UpgradePolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpgradePolicy_Spec runs a test to see if a specific instance of UpgradePolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUpgradePolicy_Spec(subject UpgradePolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpgradePolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpgradePolicy_Spec instances for property testing - lazily instantiated by UpgradePolicy_SpecGenerator()
var upgradePolicy_specGenerator gopter.Gen

// UpgradePolicy_SpecGenerator returns a generator of UpgradePolicy_Spec instances for property testing.
// We first initialize upgradePolicy_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpgradePolicy_SpecGenerator() gopter.Gen {
	if upgradePolicy_specGenerator != nil {
		return upgradePolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpgradePolicy_Spec(generators)
	upgradePolicy_specGenerator = gen.Struct(reflect.TypeOf(UpgradePolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpgradePolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForUpgradePolicy_Spec(generators)
	upgradePolicy_specGenerator = gen.Struct(reflect.TypeOf(UpgradePolicy_Spec{}), generators)

	return upgradePolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForUpgradePolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpgradePolicy_Spec(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(UpgradePolicy_Mode_SpecAutomatic, UpgradePolicy_Mode_SpecManual, UpgradePolicy_Mode_SpecRolling))
}

// AddRelatedPropertyGeneratorsForUpgradePolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpgradePolicy_Spec(gens map[string]gopter.Gen) {
	gens["AutomaticOSUpgradePolicy"] = gen.PtrOf(AutomaticOSUpgradePolicy_SpecGenerator())
	gens["RollingUpgradePolicy"] = gen.PtrOf(RollingUpgradePolicy_SpecGenerator())
}

func Test_UpgradePolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpgradePolicy_Status to UpgradePolicy_Status via AssignPropertiesToUpgradePolicy_Status & AssignPropertiesFromUpgradePolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpgradePolicy_Status, UpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpgradePolicy_Status tests if a specific instance of UpgradePolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForUpgradePolicy_Status(subject UpgradePolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.UpgradePolicy_Status
	err := copied.AssignPropertiesToUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpgradePolicy_Status
	err = actual.AssignPropertiesFromUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpgradePolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpgradePolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpgradePolicy_Status, UpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpgradePolicy_Status runs a test to see if a specific instance of UpgradePolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUpgradePolicy_Status(subject UpgradePolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpgradePolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpgradePolicy_Status instances for property testing - lazily instantiated by
//UpgradePolicy_StatusGenerator()
var upgradePolicy_statusGenerator gopter.Gen

// UpgradePolicy_StatusGenerator returns a generator of UpgradePolicy_Status instances for property testing.
// We first initialize upgradePolicy_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpgradePolicy_StatusGenerator() gopter.Gen {
	if upgradePolicy_statusGenerator != nil {
		return upgradePolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpgradePolicy_Status(generators)
	upgradePolicy_statusGenerator = gen.Struct(reflect.TypeOf(UpgradePolicy_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpgradePolicy_Status(generators)
	AddRelatedPropertyGeneratorsForUpgradePolicy_Status(generators)
	upgradePolicy_statusGenerator = gen.Struct(reflect.TypeOf(UpgradePolicy_Status{}), generators)

	return upgradePolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForUpgradePolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpgradePolicy_Status(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(UpgradePolicy_Mode_StatusAutomatic, UpgradePolicy_Mode_StatusManual, UpgradePolicy_Mode_StatusRolling))
}

// AddRelatedPropertyGeneratorsForUpgradePolicy_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpgradePolicy_Status(gens map[string]gopter.Gen) {
	gens["AutomaticOSUpgradePolicy"] = gen.PtrOf(AutomaticOSUpgradePolicy_StatusGenerator())
	gens["RollingUpgradePolicy"] = gen.PtrOf(RollingUpgradePolicy_StatusGenerator())
}

func Test_VirtualMachineScaleSetIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIdentity_Spec to VirtualMachineScaleSetIdentity_Spec via AssignPropertiesToVirtualMachineScaleSetIdentity_Spec & AssignPropertiesFromVirtualMachineScaleSetIdentity_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Spec, VirtualMachineScaleSetIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Spec tests if a specific instance of VirtualMachineScaleSetIdentity_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Spec(subject VirtualMachineScaleSetIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIdentity_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Spec, VirtualMachineScaleSetIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Spec runs a test to see if a specific instance of VirtualMachineScaleSetIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Spec(subject VirtualMachineScaleSetIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIdentity_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIdentity_SpecGenerator()
var virtualMachineScaleSetIdentity_specGenerator gopter.Gen

// VirtualMachineScaleSetIdentity_SpecGenerator returns a generator of VirtualMachineScaleSetIdentity_Spec instances for property testing.
func VirtualMachineScaleSetIdentity_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetIdentity_specGenerator != nil {
		return virtualMachineScaleSetIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Spec(generators)
	virtualMachineScaleSetIdentity_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIdentity_Spec{}), generators)

	return virtualMachineScaleSetIdentity_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineScaleSetIdentity_Type_SpecNone,
		VirtualMachineScaleSetIdentity_Type_SpecSystemAssigned,
		VirtualMachineScaleSetIdentity_Type_SpecSystemAssignedUserAssigned,
		VirtualMachineScaleSetIdentity_Type_SpecUserAssigned))
}

func Test_VirtualMachineScaleSetIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIdentity_Status to VirtualMachineScaleSetIdentity_Status via AssignPropertiesToVirtualMachineScaleSetIdentity_Status & AssignPropertiesFromVirtualMachineScaleSetIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Status, VirtualMachineScaleSetIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Status tests if a specific instance of VirtualMachineScaleSetIdentity_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Status(subject VirtualMachineScaleSetIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIdentity_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Status, VirtualMachineScaleSetIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Status runs a test to see if a specific instance of VirtualMachineScaleSetIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Status(subject VirtualMachineScaleSetIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIdentity_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIdentity_StatusGenerator()
var virtualMachineScaleSetIdentity_statusGenerator gopter.Gen

// VirtualMachineScaleSetIdentity_StatusGenerator returns a generator of VirtualMachineScaleSetIdentity_Status instances for property testing.
// We first initialize virtualMachineScaleSetIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetIdentity_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetIdentity_statusGenerator != nil {
		return virtualMachineScaleSetIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(generators)
	virtualMachineScaleSetIdentity_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(generators)
	virtualMachineScaleSetIdentity_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIdentity_Status{}), generators)

	return virtualMachineScaleSetIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineScaleSetIdentity_Type_StatusNone,
		VirtualMachineScaleSetIdentity_Type_StatusSystemAssigned,
		VirtualMachineScaleSetIdentity_Type_StatusSystemAssignedUserAssigned,
		VirtualMachineScaleSetIdentity_Type_StatusUserAssigned))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), VirtualMachineScaleSetIdentity_UserAssignedIdentities_StatusGenerator())
}

func Test_VirtualMachineScaleSetVMProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetVMProfile_Spec to VirtualMachineScaleSetVMProfile_Spec via AssignPropertiesToVirtualMachineScaleSetVMProfile_Spec & AssignPropertiesFromVirtualMachineScaleSetVMProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Spec, VirtualMachineScaleSetVMProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Spec tests if a specific instance of VirtualMachineScaleSetVMProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Spec(subject VirtualMachineScaleSetVMProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetVMProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetVMProfile_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetVMProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetVMProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetVMProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Spec, VirtualMachineScaleSetVMProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Spec runs a test to see if a specific instance of VirtualMachineScaleSetVMProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Spec(subject VirtualMachineScaleSetVMProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetVMProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetVMProfile_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetVMProfile_SpecGenerator()
var virtualMachineScaleSetVMProfile_specGenerator gopter.Gen

// VirtualMachineScaleSetVMProfile_SpecGenerator returns a generator of VirtualMachineScaleSetVMProfile_Spec instances for property testing.
// We first initialize virtualMachineScaleSetVMProfile_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetVMProfile_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetVMProfile_specGenerator != nil {
		return virtualMachineScaleSetVMProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Spec(generators)
	virtualMachineScaleSetVMProfile_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetVMProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Spec(generators)
	virtualMachineScaleSetVMProfile_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetVMProfile_Spec{}), generators)

	return virtualMachineScaleSetVMProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Spec(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_SpecDeallocate, EvictionPolicy_SpecDelete))
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_SpecLow, Priority_SpecRegular, Priority_SpecSpot))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Spec(gens map[string]gopter.Gen) {
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_SpecGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_SpecGenerator())
	gens["ExtensionProfile"] = gen.PtrOf(VirtualMachineScaleSetExtensionProfile_SpecGenerator())
	gens["NetworkProfile"] = gen.PtrOf(VirtualMachineScaleSetNetworkProfile_SpecGenerator())
	gens["OsProfile"] = gen.PtrOf(VirtualMachineScaleSetOSProfile_SpecGenerator())
	gens["ScheduledEventsProfile"] = gen.PtrOf(ScheduledEventsProfile_SpecGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_SpecGenerator())
	gens["StorageProfile"] = gen.PtrOf(VirtualMachineScaleSetStorageProfile_SpecGenerator())
}

func Test_VirtualMachineScaleSetVMProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetVMProfile_Status to VirtualMachineScaleSetVMProfile_Status via AssignPropertiesToVirtualMachineScaleSetVMProfile_Status & AssignPropertiesFromVirtualMachineScaleSetVMProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Status, VirtualMachineScaleSetVMProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Status tests if a specific instance of VirtualMachineScaleSetVMProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Status(subject VirtualMachineScaleSetVMProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetVMProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetVMProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetVMProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetVMProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetVMProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Status, VirtualMachineScaleSetVMProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetVMProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Status(subject VirtualMachineScaleSetVMProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetVMProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetVMProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetVMProfile_StatusGenerator()
var virtualMachineScaleSetVMProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetVMProfile_StatusGenerator returns a generator of VirtualMachineScaleSetVMProfile_Status instances for property testing.
// We first initialize virtualMachineScaleSetVMProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetVMProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetVMProfile_statusGenerator != nil {
		return virtualMachineScaleSetVMProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(generators)
	virtualMachineScaleSetVMProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetVMProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(generators)
	virtualMachineScaleSetVMProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetVMProfile_Status{}), generators)

	return virtualMachineScaleSetVMProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_StatusDeallocate, EvictionPolicy_StatusDelete))
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_StatusLow, Priority_StatusRegular, Priority_StatusSpot))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(gens map[string]gopter.Gen) {
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_StatusGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_StatusGenerator())
	gens["ExtensionProfile"] = gen.PtrOf(VirtualMachineScaleSetExtensionProfile_StatusGenerator())
	gens["NetworkProfile"] = gen.PtrOf(VirtualMachineScaleSetNetworkProfile_StatusGenerator())
	gens["OsProfile"] = gen.PtrOf(VirtualMachineScaleSetOSProfile_StatusGenerator())
	gens["ScheduledEventsProfile"] = gen.PtrOf(ScheduledEventsProfile_StatusGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_StatusGenerator())
	gens["StorageProfile"] = gen.PtrOf(VirtualMachineScaleSetStorageProfile_StatusGenerator())
}

func Test_AutomaticOSUpgradePolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomaticOSUpgradePolicy_Spec to AutomaticOSUpgradePolicy_Spec via AssignPropertiesToAutomaticOSUpgradePolicy_Spec & AssignPropertiesFromAutomaticOSUpgradePolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Spec, AutomaticOSUpgradePolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Spec tests if a specific instance of AutomaticOSUpgradePolicy_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Spec(subject AutomaticOSUpgradePolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Spec
	err := copied.AssignPropertiesToAutomaticOSUpgradePolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomaticOSUpgradePolicy_Spec
	err = actual.AssignPropertiesFromAutomaticOSUpgradePolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomaticOSUpgradePolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomaticOSUpgradePolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomaticOSUpgradePolicy_Spec, AutomaticOSUpgradePolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomaticOSUpgradePolicy_Spec runs a test to see if a specific instance of AutomaticOSUpgradePolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomaticOSUpgradePolicy_Spec(subject AutomaticOSUpgradePolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomaticOSUpgradePolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomaticOSUpgradePolicy_Spec instances for property testing - lazily instantiated by
//AutomaticOSUpgradePolicy_SpecGenerator()
var automaticOSUpgradePolicy_specGenerator gopter.Gen

// AutomaticOSUpgradePolicy_SpecGenerator returns a generator of AutomaticOSUpgradePolicy_Spec instances for property testing.
func AutomaticOSUpgradePolicy_SpecGenerator() gopter.Gen {
	if automaticOSUpgradePolicy_specGenerator != nil {
		return automaticOSUpgradePolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Spec(generators)
	automaticOSUpgradePolicy_specGenerator = gen.Struct(reflect.TypeOf(AutomaticOSUpgradePolicy_Spec{}), generators)

	return automaticOSUpgradePolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Spec(gens map[string]gopter.Gen) {
	gens["DisableAutomaticRollback"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticOSUpgrade"] = gen.PtrOf(gen.Bool())
}

func Test_AutomaticOSUpgradePolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomaticOSUpgradePolicy_Status to AutomaticOSUpgradePolicy_Status via AssignPropertiesToAutomaticOSUpgradePolicy_Status & AssignPropertiesFromAutomaticOSUpgradePolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Status, AutomaticOSUpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Status tests if a specific instance of AutomaticOSUpgradePolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Status(subject AutomaticOSUpgradePolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Status
	err := copied.AssignPropertiesToAutomaticOSUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomaticOSUpgradePolicy_Status
	err = actual.AssignPropertiesFromAutomaticOSUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomaticOSUpgradePolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomaticOSUpgradePolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomaticOSUpgradePolicy_Status, AutomaticOSUpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomaticOSUpgradePolicy_Status runs a test to see if a specific instance of AutomaticOSUpgradePolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomaticOSUpgradePolicy_Status(subject AutomaticOSUpgradePolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomaticOSUpgradePolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomaticOSUpgradePolicy_Status instances for property testing - lazily instantiated by
//AutomaticOSUpgradePolicy_StatusGenerator()
var automaticOSUpgradePolicy_statusGenerator gopter.Gen

// AutomaticOSUpgradePolicy_StatusGenerator returns a generator of AutomaticOSUpgradePolicy_Status instances for property testing.
func AutomaticOSUpgradePolicy_StatusGenerator() gopter.Gen {
	if automaticOSUpgradePolicy_statusGenerator != nil {
		return automaticOSUpgradePolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Status(generators)
	automaticOSUpgradePolicy_statusGenerator = gen.Struct(reflect.TypeOf(AutomaticOSUpgradePolicy_Status{}), generators)

	return automaticOSUpgradePolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Status(gens map[string]gopter.Gen) {
	gens["DisableAutomaticRollback"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticOSUpgrade"] = gen.PtrOf(gen.Bool())
}

func Test_RollingUpgradePolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RollingUpgradePolicy_Spec to RollingUpgradePolicy_Spec via AssignPropertiesToRollingUpgradePolicy_Spec & AssignPropertiesFromRollingUpgradePolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForRollingUpgradePolicy_Spec, RollingUpgradePolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRollingUpgradePolicy_Spec tests if a specific instance of RollingUpgradePolicy_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForRollingUpgradePolicy_Spec(subject RollingUpgradePolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.RollingUpgradePolicy_Spec
	err := copied.AssignPropertiesToRollingUpgradePolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RollingUpgradePolicy_Spec
	err = actual.AssignPropertiesFromRollingUpgradePolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RollingUpgradePolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RollingUpgradePolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRollingUpgradePolicy_Spec, RollingUpgradePolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRollingUpgradePolicy_Spec runs a test to see if a specific instance of RollingUpgradePolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRollingUpgradePolicy_Spec(subject RollingUpgradePolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RollingUpgradePolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RollingUpgradePolicy_Spec instances for property testing - lazily instantiated by
//RollingUpgradePolicy_SpecGenerator()
var rollingUpgradePolicy_specGenerator gopter.Gen

// RollingUpgradePolicy_SpecGenerator returns a generator of RollingUpgradePolicy_Spec instances for property testing.
func RollingUpgradePolicy_SpecGenerator() gopter.Gen {
	if rollingUpgradePolicy_specGenerator != nil {
		return rollingUpgradePolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Spec(generators)
	rollingUpgradePolicy_specGenerator = gen.Struct(reflect.TypeOf(RollingUpgradePolicy_Spec{}), generators)

	return rollingUpgradePolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Spec(gens map[string]gopter.Gen) {
	gens["EnableCrossZoneUpgrade"] = gen.PtrOf(gen.Bool())
	gens["MaxBatchInstancePercent"] = gen.PtrOf(gen.Int())
	gens["MaxUnhealthyInstancePercent"] = gen.PtrOf(gen.Int())
	gens["MaxUnhealthyUpgradedInstancePercent"] = gen.PtrOf(gen.Int())
	gens["PauseTimeBetweenBatches"] = gen.PtrOf(gen.AlphaString())
	gens["PrioritizeUnhealthyInstances"] = gen.PtrOf(gen.Bool())
}

func Test_RollingUpgradePolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RollingUpgradePolicy_Status to RollingUpgradePolicy_Status via AssignPropertiesToRollingUpgradePolicy_Status & AssignPropertiesFromRollingUpgradePolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForRollingUpgradePolicy_Status, RollingUpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRollingUpgradePolicy_Status tests if a specific instance of RollingUpgradePolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForRollingUpgradePolicy_Status(subject RollingUpgradePolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.RollingUpgradePolicy_Status
	err := copied.AssignPropertiesToRollingUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RollingUpgradePolicy_Status
	err = actual.AssignPropertiesFromRollingUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RollingUpgradePolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RollingUpgradePolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRollingUpgradePolicy_Status, RollingUpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRollingUpgradePolicy_Status runs a test to see if a specific instance of RollingUpgradePolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRollingUpgradePolicy_Status(subject RollingUpgradePolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RollingUpgradePolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RollingUpgradePolicy_Status instances for property testing - lazily instantiated by
//RollingUpgradePolicy_StatusGenerator()
var rollingUpgradePolicy_statusGenerator gopter.Gen

// RollingUpgradePolicy_StatusGenerator returns a generator of RollingUpgradePolicy_Status instances for property testing.
func RollingUpgradePolicy_StatusGenerator() gopter.Gen {
	if rollingUpgradePolicy_statusGenerator != nil {
		return rollingUpgradePolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Status(generators)
	rollingUpgradePolicy_statusGenerator = gen.Struct(reflect.TypeOf(RollingUpgradePolicy_Status{}), generators)

	return rollingUpgradePolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Status(gens map[string]gopter.Gen) {
	gens["EnableCrossZoneUpgrade"] = gen.PtrOf(gen.Bool())
	gens["MaxBatchInstancePercent"] = gen.PtrOf(gen.Int())
	gens["MaxUnhealthyInstancePercent"] = gen.PtrOf(gen.Int())
	gens["MaxUnhealthyUpgradedInstancePercent"] = gen.PtrOf(gen.Int())
	gens["PauseTimeBetweenBatches"] = gen.PtrOf(gen.AlphaString())
	gens["PrioritizeUnhealthyInstances"] = gen.PtrOf(gen.Bool())
}

func Test_ScheduledEventsProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScheduledEventsProfile_Spec to ScheduledEventsProfile_Spec via AssignPropertiesToScheduledEventsProfile_Spec & AssignPropertiesFromScheduledEventsProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForScheduledEventsProfile_Spec, ScheduledEventsProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScheduledEventsProfile_Spec tests if a specific instance of ScheduledEventsProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForScheduledEventsProfile_Spec(subject ScheduledEventsProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ScheduledEventsProfile_Spec
	err := copied.AssignPropertiesToScheduledEventsProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScheduledEventsProfile_Spec
	err = actual.AssignPropertiesFromScheduledEventsProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScheduledEventsProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsProfile_Spec, ScheduledEventsProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsProfile_Spec runs a test to see if a specific instance of ScheduledEventsProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsProfile_Spec(subject ScheduledEventsProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsProfile_Spec instances for property testing - lazily instantiated by
//ScheduledEventsProfile_SpecGenerator()
var scheduledEventsProfile_specGenerator gopter.Gen

// ScheduledEventsProfile_SpecGenerator returns a generator of ScheduledEventsProfile_Spec instances for property testing.
func ScheduledEventsProfile_SpecGenerator() gopter.Gen {
	if scheduledEventsProfile_specGenerator != nil {
		return scheduledEventsProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsProfile_Spec(generators)
	scheduledEventsProfile_specGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsProfile_Spec{}), generators)

	return scheduledEventsProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsProfile_Spec(gens map[string]gopter.Gen) {
	gens["TerminateNotificationProfile"] = gen.PtrOf(TerminateNotificationProfile_SpecGenerator())
}

func Test_ScheduledEventsProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScheduledEventsProfile_Status to ScheduledEventsProfile_Status via AssignPropertiesToScheduledEventsProfile_Status & AssignPropertiesFromScheduledEventsProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForScheduledEventsProfile_Status, ScheduledEventsProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScheduledEventsProfile_Status tests if a specific instance of ScheduledEventsProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForScheduledEventsProfile_Status(subject ScheduledEventsProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ScheduledEventsProfile_Status
	err := copied.AssignPropertiesToScheduledEventsProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScheduledEventsProfile_Status
	err = actual.AssignPropertiesFromScheduledEventsProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScheduledEventsProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsProfile_Status, ScheduledEventsProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsProfile_Status runs a test to see if a specific instance of ScheduledEventsProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsProfile_Status(subject ScheduledEventsProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsProfile_Status instances for property testing - lazily instantiated by
//ScheduledEventsProfile_StatusGenerator()
var scheduledEventsProfile_statusGenerator gopter.Gen

// ScheduledEventsProfile_StatusGenerator returns a generator of ScheduledEventsProfile_Status instances for property testing.
func ScheduledEventsProfile_StatusGenerator() gopter.Gen {
	if scheduledEventsProfile_statusGenerator != nil {
		return scheduledEventsProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsProfile_Status(generators)
	scheduledEventsProfile_statusGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsProfile_Status{}), generators)

	return scheduledEventsProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsProfile_Status(gens map[string]gopter.Gen) {
	gens["TerminateNotificationProfile"] = gen.PtrOf(TerminateNotificationProfile_StatusGenerator())
}

func Test_VirtualMachineScaleSetExtensionProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetExtensionProfile_Spec to VirtualMachineScaleSetExtensionProfile_Spec via AssignPropertiesToVirtualMachineScaleSetExtensionProfile_Spec & AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Spec, VirtualMachineScaleSetExtensionProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Spec tests if a specific instance of VirtualMachineScaleSetExtensionProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Spec(subject VirtualMachineScaleSetExtensionProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetExtensionProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetExtensionProfile_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetExtensionProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetExtensionProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Spec, VirtualMachineScaleSetExtensionProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Spec runs a test to see if a specific instance of VirtualMachineScaleSetExtensionProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Spec(subject VirtualMachineScaleSetExtensionProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetExtensionProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetExtensionProfile_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetExtensionProfile_SpecGenerator()
var virtualMachineScaleSetExtensionProfile_specGenerator gopter.Gen

// VirtualMachineScaleSetExtensionProfile_SpecGenerator returns a generator of VirtualMachineScaleSetExtensionProfile_Spec instances for property testing.
func VirtualMachineScaleSetExtensionProfile_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetExtensionProfile_specGenerator != nil {
		return virtualMachineScaleSetExtensionProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Spec(generators)
	virtualMachineScaleSetExtensionProfile_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetExtensionProfile_Spec{}), generators)

	return virtualMachineScaleSetExtensionProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Spec(gens map[string]gopter.Gen) {
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetExtensionProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetExtensionProfile_Status to VirtualMachineScaleSetExtensionProfile_Status via AssignPropertiesToVirtualMachineScaleSetExtensionProfile_Status & AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Status, VirtualMachineScaleSetExtensionProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Status tests if a specific instance of VirtualMachineScaleSetExtensionProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Status(subject VirtualMachineScaleSetExtensionProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetExtensionProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetExtensionProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetExtensionProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetExtensionProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Status, VirtualMachineScaleSetExtensionProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetExtensionProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Status(subject VirtualMachineScaleSetExtensionProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetExtensionProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetExtensionProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetExtensionProfile_StatusGenerator()
var virtualMachineScaleSetExtensionProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetExtensionProfile_StatusGenerator returns a generator of VirtualMachineScaleSetExtensionProfile_Status instances for property testing.
// We first initialize virtualMachineScaleSetExtensionProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetExtensionProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetExtensionProfile_statusGenerator != nil {
		return virtualMachineScaleSetExtensionProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(generators)
	virtualMachineScaleSetExtensionProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetExtensionProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(generators)
	virtualMachineScaleSetExtensionProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetExtensionProfile_Status{}), generators)

	return virtualMachineScaleSetExtensionProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(gens map[string]gopter.Gen) {
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(gens map[string]gopter.Gen) {
	gens["Extensions"] = gen.SliceOf(VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator())
}

func Test_VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status to VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status via AssignPropertiesToVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status & AssignPropertiesFromVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status, VirtualMachineScaleSetIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status tests if a specific instance of VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status(subject VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status, VirtualMachineScaleSetIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status runs a test to see if a specific instance of VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status(subject VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status instances for property testing - lazily
//instantiated by VirtualMachineScaleSetIdentity_UserAssignedIdentities_StatusGenerator()
var virtualMachineScaleSetIdentity_userAssignedIdentities_statusGenerator gopter.Gen

// VirtualMachineScaleSetIdentity_UserAssignedIdentities_StatusGenerator returns a generator of VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status instances for property testing.
func VirtualMachineScaleSetIdentity_UserAssignedIdentities_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetIdentity_userAssignedIdentities_statusGenerator != nil {
		return virtualMachineScaleSetIdentity_userAssignedIdentities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status(generators)
	virtualMachineScaleSetIdentity_userAssignedIdentities_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIdentity_UserAssignedIdentities_Status{}), generators)

	return virtualMachineScaleSetIdentity_userAssignedIdentities_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_UserAssignedIdentities_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetNetworkProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkProfile_Spec to VirtualMachineScaleSetNetworkProfile_Spec via AssignPropertiesToVirtualMachineScaleSetNetworkProfile_Spec & AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Spec, VirtualMachineScaleSetNetworkProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Spec tests if a specific instance of VirtualMachineScaleSetNetworkProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Spec(subject VirtualMachineScaleSetNetworkProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkProfile_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Spec, VirtualMachineScaleSetNetworkProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Spec runs a test to see if a specific instance of VirtualMachineScaleSetNetworkProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Spec(subject VirtualMachineScaleSetNetworkProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkProfile_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetNetworkProfile_SpecGenerator()
var virtualMachineScaleSetNetworkProfile_specGenerator gopter.Gen

// VirtualMachineScaleSetNetworkProfile_SpecGenerator returns a generator of VirtualMachineScaleSetNetworkProfile_Spec instances for property testing.
func VirtualMachineScaleSetNetworkProfile_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkProfile_specGenerator != nil {
		return virtualMachineScaleSetNetworkProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Spec(generators)
	virtualMachineScaleSetNetworkProfile_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkProfile_Spec{}), generators)

	return virtualMachineScaleSetNetworkProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Spec(gens map[string]gopter.Gen) {
	gens["HealthProbe"] = gen.PtrOf(ApiEntityReference_SpecGenerator())
	gens["NetworkInterfaceConfigurations"] = gen.SliceOf(VirtualMachineScaleSetNetworkConfiguration_SpecGenerator())
}

func Test_VirtualMachineScaleSetNetworkProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkProfile_Status to VirtualMachineScaleSetNetworkProfile_Status via AssignPropertiesToVirtualMachineScaleSetNetworkProfile_Status & AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Status, VirtualMachineScaleSetNetworkProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Status tests if a specific instance of VirtualMachineScaleSetNetworkProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Status(subject VirtualMachineScaleSetNetworkProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Status, VirtualMachineScaleSetNetworkProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetNetworkProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Status(subject VirtualMachineScaleSetNetworkProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetNetworkProfile_StatusGenerator()
var virtualMachineScaleSetNetworkProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetNetworkProfile_StatusGenerator returns a generator of VirtualMachineScaleSetNetworkProfile_Status instances for property testing.
func VirtualMachineScaleSetNetworkProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkProfile_statusGenerator != nil {
		return virtualMachineScaleSetNetworkProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Status(generators)
	virtualMachineScaleSetNetworkProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkProfile_Status{}), generators)

	return virtualMachineScaleSetNetworkProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Status(gens map[string]gopter.Gen) {
	gens["HealthProbe"] = gen.PtrOf(ApiEntityReference_StatusGenerator())
	gens["NetworkInterfaceConfigurations"] = gen.SliceOf(VirtualMachineScaleSetNetworkConfiguration_StatusGenerator())
}

func Test_VirtualMachineScaleSetOSProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetOSProfile_Spec to VirtualMachineScaleSetOSProfile_Spec via AssignPropertiesToVirtualMachineScaleSetOSProfile_Spec & AssignPropertiesFromVirtualMachineScaleSetOSProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Spec, VirtualMachineScaleSetOSProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Spec tests if a specific instance of VirtualMachineScaleSetOSProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Spec(subject VirtualMachineScaleSetOSProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetOSProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetOSProfile_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetOSProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetOSProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetOSProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Spec, VirtualMachineScaleSetOSProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Spec runs a test to see if a specific instance of VirtualMachineScaleSetOSProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Spec(subject VirtualMachineScaleSetOSProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetOSProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetOSProfile_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetOSProfile_SpecGenerator()
var virtualMachineScaleSetOSProfile_specGenerator gopter.Gen

// VirtualMachineScaleSetOSProfile_SpecGenerator returns a generator of VirtualMachineScaleSetOSProfile_Spec instances for property testing.
// We first initialize virtualMachineScaleSetOSProfile_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetOSProfile_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetOSProfile_specGenerator != nil {
		return virtualMachineScaleSetOSProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Spec(generators)
	virtualMachineScaleSetOSProfile_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Spec(generators)
	virtualMachineScaleSetOSProfile_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSProfile_Spec{}), generators)

	return virtualMachineScaleSetOSProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Spec(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Spec(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_SpecGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_SpecGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_SpecGenerator())
}

func Test_VirtualMachineScaleSetOSProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetOSProfile_Status to VirtualMachineScaleSetOSProfile_Status via AssignPropertiesToVirtualMachineScaleSetOSProfile_Status & AssignPropertiesFromVirtualMachineScaleSetOSProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Status, VirtualMachineScaleSetOSProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Status tests if a specific instance of VirtualMachineScaleSetOSProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Status(subject VirtualMachineScaleSetOSProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetOSProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetOSProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetOSProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetOSProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetOSProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Status, VirtualMachineScaleSetOSProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetOSProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Status(subject VirtualMachineScaleSetOSProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetOSProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetOSProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetOSProfile_StatusGenerator()
var virtualMachineScaleSetOSProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetOSProfile_StatusGenerator returns a generator of VirtualMachineScaleSetOSProfile_Status instances for property testing.
// We first initialize virtualMachineScaleSetOSProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetOSProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetOSProfile_statusGenerator != nil {
		return virtualMachineScaleSetOSProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(generators)
	virtualMachineScaleSetOSProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(generators)
	virtualMachineScaleSetOSProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSProfile_Status{}), generators)

	return virtualMachineScaleSetOSProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_StatusGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_StatusGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_StatusGenerator())
}

func Test_VirtualMachineScaleSetStorageProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetStorageProfile_Spec to VirtualMachineScaleSetStorageProfile_Spec via AssignPropertiesToVirtualMachineScaleSetStorageProfile_Spec & AssignPropertiesFromVirtualMachineScaleSetStorageProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Spec, VirtualMachineScaleSetStorageProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Spec tests if a specific instance of VirtualMachineScaleSetStorageProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Spec(subject VirtualMachineScaleSetStorageProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetStorageProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetStorageProfile_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetStorageProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetStorageProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetStorageProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Spec, VirtualMachineScaleSetStorageProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Spec runs a test to see if a specific instance of VirtualMachineScaleSetStorageProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Spec(subject VirtualMachineScaleSetStorageProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetStorageProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetStorageProfile_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetStorageProfile_SpecGenerator()
var virtualMachineScaleSetStorageProfile_specGenerator gopter.Gen

// VirtualMachineScaleSetStorageProfile_SpecGenerator returns a generator of VirtualMachineScaleSetStorageProfile_Spec instances for property testing.
func VirtualMachineScaleSetStorageProfile_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetStorageProfile_specGenerator != nil {
		return virtualMachineScaleSetStorageProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Spec(generators)
	virtualMachineScaleSetStorageProfile_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetStorageProfile_Spec{}), generators)

	return virtualMachineScaleSetStorageProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Spec(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(VirtualMachineScaleSetDataDisk_SpecGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_SpecGenerator())
	gens["OsDisk"] = gen.PtrOf(VirtualMachineScaleSetOSDisk_SpecGenerator())
}

func Test_VirtualMachineScaleSetStorageProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetStorageProfile_Status to VirtualMachineScaleSetStorageProfile_Status via AssignPropertiesToVirtualMachineScaleSetStorageProfile_Status & AssignPropertiesFromVirtualMachineScaleSetStorageProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Status, VirtualMachineScaleSetStorageProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Status tests if a specific instance of VirtualMachineScaleSetStorageProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Status(subject VirtualMachineScaleSetStorageProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetStorageProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetStorageProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetStorageProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetStorageProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetStorageProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Status, VirtualMachineScaleSetStorageProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetStorageProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Status(subject VirtualMachineScaleSetStorageProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetStorageProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetStorageProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetStorageProfile_StatusGenerator()
var virtualMachineScaleSetStorageProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetStorageProfile_StatusGenerator returns a generator of VirtualMachineScaleSetStorageProfile_Status instances for property testing.
func VirtualMachineScaleSetStorageProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetStorageProfile_statusGenerator != nil {
		return virtualMachineScaleSetStorageProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Status(generators)
	virtualMachineScaleSetStorageProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetStorageProfile_Status{}), generators)

	return virtualMachineScaleSetStorageProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Status(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(VirtualMachineScaleSetDataDisk_StatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_StatusGenerator())
	gens["OsDisk"] = gen.PtrOf(VirtualMachineScaleSetOSDisk_StatusGenerator())
}

func Test_ApiEntityReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiEntityReference_Spec to ApiEntityReference_Spec via AssignPropertiesToApiEntityReference_Spec & AssignPropertiesFromApiEntityReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiEntityReference_Spec, ApiEntityReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiEntityReference_Spec tests if a specific instance of ApiEntityReference_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForApiEntityReference_Spec(subject ApiEntityReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ApiEntityReference_Spec
	err := copied.AssignPropertiesToApiEntityReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiEntityReference_Spec
	err = actual.AssignPropertiesFromApiEntityReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiEntityReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiEntityReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiEntityReference_Spec, ApiEntityReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiEntityReference_Spec runs a test to see if a specific instance of ApiEntityReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApiEntityReference_Spec(subject ApiEntityReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiEntityReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiEntityReference_Spec instances for property testing - lazily instantiated by
//ApiEntityReference_SpecGenerator()
var apiEntityReference_specGenerator gopter.Gen

// ApiEntityReference_SpecGenerator returns a generator of ApiEntityReference_Spec instances for property testing.
func ApiEntityReference_SpecGenerator() gopter.Gen {
	if apiEntityReference_specGenerator != nil {
		return apiEntityReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	apiEntityReference_specGenerator = gen.Struct(reflect.TypeOf(ApiEntityReference_Spec{}), generators)

	return apiEntityReference_specGenerator
}

func Test_ApiEntityReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiEntityReference_Status to ApiEntityReference_Status via AssignPropertiesToApiEntityReference_Status & AssignPropertiesFromApiEntityReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiEntityReference_Status, ApiEntityReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiEntityReference_Status tests if a specific instance of ApiEntityReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForApiEntityReference_Status(subject ApiEntityReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ApiEntityReference_Status
	err := copied.AssignPropertiesToApiEntityReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiEntityReference_Status
	err = actual.AssignPropertiesFromApiEntityReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiEntityReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiEntityReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiEntityReference_Status, ApiEntityReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiEntityReference_Status runs a test to see if a specific instance of ApiEntityReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiEntityReference_Status(subject ApiEntityReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiEntityReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiEntityReference_Status instances for property testing - lazily instantiated by
//ApiEntityReference_StatusGenerator()
var apiEntityReference_statusGenerator gopter.Gen

// ApiEntityReference_StatusGenerator returns a generator of ApiEntityReference_Status instances for property testing.
func ApiEntityReference_StatusGenerator() gopter.Gen {
	if apiEntityReference_statusGenerator != nil {
		return apiEntityReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiEntityReference_Status(generators)
	apiEntityReference_statusGenerator = gen.Struct(reflect.TypeOf(ApiEntityReference_Status{}), generators)

	return apiEntityReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiEntityReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiEntityReference_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_TerminateNotificationProfile_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TerminateNotificationProfile_Spec to TerminateNotificationProfile_Spec via AssignPropertiesToTerminateNotificationProfile_Spec & AssignPropertiesFromTerminateNotificationProfile_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForTerminateNotificationProfile_Spec, TerminateNotificationProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTerminateNotificationProfile_Spec tests if a specific instance of TerminateNotificationProfile_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForTerminateNotificationProfile_Spec(subject TerminateNotificationProfile_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.TerminateNotificationProfile_Spec
	err := copied.AssignPropertiesToTerminateNotificationProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TerminateNotificationProfile_Spec
	err = actual.AssignPropertiesFromTerminateNotificationProfile_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TerminateNotificationProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TerminateNotificationProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTerminateNotificationProfile_Spec, TerminateNotificationProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTerminateNotificationProfile_Spec runs a test to see if a specific instance of TerminateNotificationProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForTerminateNotificationProfile_Spec(subject TerminateNotificationProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TerminateNotificationProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TerminateNotificationProfile_Spec instances for property testing - lazily instantiated by
//TerminateNotificationProfile_SpecGenerator()
var terminateNotificationProfile_specGenerator gopter.Gen

// TerminateNotificationProfile_SpecGenerator returns a generator of TerminateNotificationProfile_Spec instances for property testing.
func TerminateNotificationProfile_SpecGenerator() gopter.Gen {
	if terminateNotificationProfile_specGenerator != nil {
		return terminateNotificationProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Spec(generators)
	terminateNotificationProfile_specGenerator = gen.Struct(reflect.TypeOf(TerminateNotificationProfile_Spec{}), generators)

	return terminateNotificationProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Spec(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
	gens["NotBeforeTimeout"] = gen.PtrOf(gen.AlphaString())
}

func Test_TerminateNotificationProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TerminateNotificationProfile_Status to TerminateNotificationProfile_Status via AssignPropertiesToTerminateNotificationProfile_Status & AssignPropertiesFromTerminateNotificationProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForTerminateNotificationProfile_Status, TerminateNotificationProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTerminateNotificationProfile_Status tests if a specific instance of TerminateNotificationProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForTerminateNotificationProfile_Status(subject TerminateNotificationProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.TerminateNotificationProfile_Status
	err := copied.AssignPropertiesToTerminateNotificationProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TerminateNotificationProfile_Status
	err = actual.AssignPropertiesFromTerminateNotificationProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TerminateNotificationProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TerminateNotificationProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTerminateNotificationProfile_Status, TerminateNotificationProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTerminateNotificationProfile_Status runs a test to see if a specific instance of TerminateNotificationProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForTerminateNotificationProfile_Status(subject TerminateNotificationProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TerminateNotificationProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TerminateNotificationProfile_Status instances for property testing - lazily instantiated by
//TerminateNotificationProfile_StatusGenerator()
var terminateNotificationProfile_statusGenerator gopter.Gen

// TerminateNotificationProfile_StatusGenerator returns a generator of TerminateNotificationProfile_Status instances for property testing.
func TerminateNotificationProfile_StatusGenerator() gopter.Gen {
	if terminateNotificationProfile_statusGenerator != nil {
		return terminateNotificationProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Status(generators)
	terminateNotificationProfile_statusGenerator = gen.Struct(reflect.TypeOf(TerminateNotificationProfile_Status{}), generators)

	return terminateNotificationProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Status(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
	gens["NotBeforeTimeout"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetDataDisk_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetDataDisk_Spec to VirtualMachineScaleSetDataDisk_Spec via AssignPropertiesToVirtualMachineScaleSetDataDisk_Spec & AssignPropertiesFromVirtualMachineScaleSetDataDisk_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Spec, VirtualMachineScaleSetDataDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Spec tests if a specific instance of VirtualMachineScaleSetDataDisk_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Spec(subject VirtualMachineScaleSetDataDisk_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetDataDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetDataDisk_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetDataDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetDataDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetDataDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Spec, VirtualMachineScaleSetDataDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Spec runs a test to see if a specific instance of VirtualMachineScaleSetDataDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Spec(subject VirtualMachineScaleSetDataDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetDataDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetDataDisk_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetDataDisk_SpecGenerator()
var virtualMachineScaleSetDataDisk_specGenerator gopter.Gen

// VirtualMachineScaleSetDataDisk_SpecGenerator returns a generator of VirtualMachineScaleSetDataDisk_Spec instances for property testing.
// We first initialize virtualMachineScaleSetDataDisk_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetDataDisk_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetDataDisk_specGenerator != nil {
		return virtualMachineScaleSetDataDisk_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Spec(generators)
	virtualMachineScaleSetDataDisk_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetDataDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Spec(generators)
	virtualMachineScaleSetDataDisk_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetDataDisk_Spec{}), generators)

	return virtualMachineScaleSetDataDisk_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Spec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Spec(gens map[string]gopter.Gen) {
	gens["ManagedDisk"] = gen.PtrOf(VirtualMachineScaleSetManagedDiskParameters_SpecGenerator())
}

func Test_VirtualMachineScaleSetDataDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetDataDisk_Status to VirtualMachineScaleSetDataDisk_Status via AssignPropertiesToVirtualMachineScaleSetDataDisk_Status & AssignPropertiesFromVirtualMachineScaleSetDataDisk_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Status, VirtualMachineScaleSetDataDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Status tests if a specific instance of VirtualMachineScaleSetDataDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Status(subject VirtualMachineScaleSetDataDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetDataDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetDataDisk_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetDataDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetDataDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetDataDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Status, VirtualMachineScaleSetDataDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Status runs a test to see if a specific instance of VirtualMachineScaleSetDataDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Status(subject VirtualMachineScaleSetDataDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetDataDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetDataDisk_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetDataDisk_StatusGenerator()
var virtualMachineScaleSetDataDisk_statusGenerator gopter.Gen

// VirtualMachineScaleSetDataDisk_StatusGenerator returns a generator of VirtualMachineScaleSetDataDisk_Status instances for property testing.
// We first initialize virtualMachineScaleSetDataDisk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetDataDisk_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetDataDisk_statusGenerator != nil {
		return virtualMachineScaleSetDataDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(generators)
	virtualMachineScaleSetDataDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetDataDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(generators)
	virtualMachineScaleSetDataDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetDataDisk_Status{}), generators)

	return virtualMachineScaleSetDataDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_StatusNone, Caching_StatusReadOnly, Caching_StatusReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_StatusAttach, CreateOption_StatusEmpty, CreateOption_StatusFromImage)
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(gens map[string]gopter.Gen) {
	gens["ManagedDisk"] = gen.PtrOf(VirtualMachineScaleSetManagedDiskParameters_StatusGenerator())
}

func Test_VirtualMachineScaleSetExtension_Status_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetExtension_Status_SubResourceEmbedded to VirtualMachineScaleSetExtension_Status_SubResourceEmbedded via AssignPropertiesToVirtualMachineScaleSetExtension_Status_SubResourceEmbedded & AssignPropertiesFromVirtualMachineScaleSetExtension_Status_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded, VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded tests if a specific instance of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(subject VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
	err := copied.AssignPropertiesToVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
	err = actual.AssignPropertiesFromVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetExtension_Status_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded, VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded runs a test to see if a specific instance of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(subject VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded instances for property testing - lazily
//instantiated by VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator()
var virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator gopter.Gen

// VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator returns a generator of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded instances for property testing.
func VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator() gopter.Gen {
	if virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator != nil {
		return virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(generators)
	virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetExtension_Status_SubResourceEmbedded{}), generators)

	return virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetNetworkConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkConfiguration_Spec to VirtualMachineScaleSetNetworkConfiguration_Spec via AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_Spec & AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Spec, VirtualMachineScaleSetNetworkConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Spec tests if a specific instance of VirtualMachineScaleSetNetworkConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Spec(subject VirtualMachineScaleSetNetworkConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkConfiguration_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Spec, VirtualMachineScaleSetNetworkConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Spec runs a test to see if a specific instance of VirtualMachineScaleSetNetworkConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Spec(subject VirtualMachineScaleSetNetworkConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkConfiguration_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetNetworkConfiguration_SpecGenerator()
var virtualMachineScaleSetNetworkConfiguration_specGenerator gopter.Gen

// VirtualMachineScaleSetNetworkConfiguration_SpecGenerator returns a generator of VirtualMachineScaleSetNetworkConfiguration_Spec instances for property testing.
// We first initialize virtualMachineScaleSetNetworkConfiguration_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetNetworkConfiguration_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkConfiguration_specGenerator != nil {
		return virtualMachineScaleSetNetworkConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Spec(generators)
	virtualMachineScaleSetNetworkConfiguration_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Spec(generators)
	virtualMachineScaleSetNetworkConfiguration_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfiguration_Spec{}), generators)

	return virtualMachineScaleSetNetworkConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableFpga"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.AlphaString()
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualMachineScaleSetIPConfiguration_SpecGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_VirtualMachineScaleSetNetworkConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkConfiguration_Status to VirtualMachineScaleSetNetworkConfiguration_Status via AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_Status & AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Status, VirtualMachineScaleSetNetworkConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Status tests if a specific instance of VirtualMachineScaleSetNetworkConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Status(subject VirtualMachineScaleSetNetworkConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkConfiguration_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Status, VirtualMachineScaleSetNetworkConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Status runs a test to see if a specific instance of VirtualMachineScaleSetNetworkConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Status(subject VirtualMachineScaleSetNetworkConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkConfiguration_Status instances for property testing - lazily instantiated
//by VirtualMachineScaleSetNetworkConfiguration_StatusGenerator()
var virtualMachineScaleSetNetworkConfiguration_statusGenerator gopter.Gen

// VirtualMachineScaleSetNetworkConfiguration_StatusGenerator returns a generator of VirtualMachineScaleSetNetworkConfiguration_Status instances for property testing.
// We first initialize virtualMachineScaleSetNetworkConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetNetworkConfiguration_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkConfiguration_statusGenerator != nil {
		return virtualMachineScaleSetNetworkConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(generators)
	virtualMachineScaleSetNetworkConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(generators)
	virtualMachineScaleSetNetworkConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfiguration_Status{}), generators)

	return virtualMachineScaleSetNetworkConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableFpga"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualMachineScaleSetIPConfiguration_StatusGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_VirtualMachineScaleSetOSDisk_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetOSDisk_Spec to VirtualMachineScaleSetOSDisk_Spec via AssignPropertiesToVirtualMachineScaleSetOSDisk_Spec & AssignPropertiesFromVirtualMachineScaleSetOSDisk_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Spec, VirtualMachineScaleSetOSDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Spec tests if a specific instance of VirtualMachineScaleSetOSDisk_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Spec(subject VirtualMachineScaleSetOSDisk_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetOSDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetOSDisk_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetOSDisk_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetOSDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetOSDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Spec, VirtualMachineScaleSetOSDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Spec runs a test to see if a specific instance of VirtualMachineScaleSetOSDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Spec(subject VirtualMachineScaleSetOSDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetOSDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetOSDisk_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetOSDisk_SpecGenerator()
var virtualMachineScaleSetOSDisk_specGenerator gopter.Gen

// VirtualMachineScaleSetOSDisk_SpecGenerator returns a generator of VirtualMachineScaleSetOSDisk_Spec instances for property testing.
// We first initialize virtualMachineScaleSetOSDisk_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetOSDisk_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetOSDisk_specGenerator != nil {
		return virtualMachineScaleSetOSDisk_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Spec(generators)
	virtualMachineScaleSetOSDisk_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Spec(generators)
	virtualMachineScaleSetOSDisk_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSDisk_Spec{}), generators)

	return virtualMachineScaleSetOSDisk_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Spec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_SpecNone, Caching_SpecReadOnly, Caching_SpecReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_SpecAttach, CreateOption_SpecEmpty, CreateOption_SpecFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetOSDisk_OsType_SpecLinux, VirtualMachineScaleSetOSDisk_OsType_SpecWindows))
	gens["VhdContainers"] = gen.SliceOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Spec(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_SpecGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(VirtualMachineScaleSetManagedDiskParameters_SpecGenerator())
}

func Test_VirtualMachineScaleSetOSDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetOSDisk_Status to VirtualMachineScaleSetOSDisk_Status via AssignPropertiesToVirtualMachineScaleSetOSDisk_Status & AssignPropertiesFromVirtualMachineScaleSetOSDisk_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Status, VirtualMachineScaleSetOSDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Status tests if a specific instance of VirtualMachineScaleSetOSDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Status(subject VirtualMachineScaleSetOSDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetOSDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetOSDisk_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetOSDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetOSDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetOSDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Status, VirtualMachineScaleSetOSDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Status runs a test to see if a specific instance of VirtualMachineScaleSetOSDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Status(subject VirtualMachineScaleSetOSDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetOSDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetOSDisk_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetOSDisk_StatusGenerator()
var virtualMachineScaleSetOSDisk_statusGenerator gopter.Gen

// VirtualMachineScaleSetOSDisk_StatusGenerator returns a generator of VirtualMachineScaleSetOSDisk_Status instances for property testing.
// We first initialize virtualMachineScaleSetOSDisk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetOSDisk_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetOSDisk_statusGenerator != nil {
		return virtualMachineScaleSetOSDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(generators)
	virtualMachineScaleSetOSDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(generators)
	virtualMachineScaleSetOSDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSDisk_Status{}), generators)

	return virtualMachineScaleSetOSDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_StatusNone, Caching_StatusReadOnly, Caching_StatusReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_StatusAttach, CreateOption_StatusEmpty, CreateOption_StatusFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetOSDisk_OsType_StatusLinux, VirtualMachineScaleSetOSDisk_OsType_StatusWindows))
	gens["VhdContainers"] = gen.SliceOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_StatusGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(VirtualMachineScaleSetManagedDiskParameters_StatusGenerator())
}

func Test_VirtualMachineScaleSetIPConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIPConfiguration_Spec to VirtualMachineScaleSetIPConfiguration_Spec via AssignPropertiesToVirtualMachineScaleSetIPConfiguration_Spec & AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Spec, VirtualMachineScaleSetIPConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Spec tests if a specific instance of VirtualMachineScaleSetIPConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Spec(subject VirtualMachineScaleSetIPConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetIPConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIPConfiguration_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIPConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIPConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Spec, VirtualMachineScaleSetIPConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Spec runs a test to see if a specific instance of VirtualMachineScaleSetIPConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Spec(subject VirtualMachineScaleSetIPConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIPConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIPConfiguration_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIPConfiguration_SpecGenerator()
var virtualMachineScaleSetIPConfiguration_specGenerator gopter.Gen

// VirtualMachineScaleSetIPConfiguration_SpecGenerator returns a generator of VirtualMachineScaleSetIPConfiguration_Spec instances for property testing.
// We first initialize virtualMachineScaleSetIPConfiguration_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetIPConfiguration_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetIPConfiguration_specGenerator != nil {
		return virtualMachineScaleSetIPConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Spec(generators)
	virtualMachineScaleSetIPConfiguration_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIPConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Spec(generators)
	virtualMachineScaleSetIPConfiguration_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIPConfiguration_Spec{}), generators)

	return virtualMachineScaleSetIPConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_SpecIPv4, VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_SpecIPv6))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(SubResource_SpecGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(SubResource_SpecGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(SubResource_SpecGenerator())
	gens["LoadBalancerInboundNatPools"] = gen.SliceOf(SubResource_SpecGenerator())
	gens["PublicIPAddressConfiguration"] = gen.PtrOf(VirtualMachineScaleSetPublicIPAddressConfiguration_SpecGenerator())
	gens["Subnet"] = gen.PtrOf(ApiEntityReference_SpecGenerator())
}

func Test_VirtualMachineScaleSetIPConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIPConfiguration_Status to VirtualMachineScaleSetIPConfiguration_Status via AssignPropertiesToVirtualMachineScaleSetIPConfiguration_Status & AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Status, VirtualMachineScaleSetIPConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Status tests if a specific instance of VirtualMachineScaleSetIPConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Status(subject VirtualMachineScaleSetIPConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetIPConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIPConfiguration_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIPConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIPConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Status, VirtualMachineScaleSetIPConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Status runs a test to see if a specific instance of VirtualMachineScaleSetIPConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Status(subject VirtualMachineScaleSetIPConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIPConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIPConfiguration_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIPConfiguration_StatusGenerator()
var virtualMachineScaleSetIPConfiguration_statusGenerator gopter.Gen

// VirtualMachineScaleSetIPConfiguration_StatusGenerator returns a generator of VirtualMachineScaleSetIPConfiguration_Status instances for property testing.
// We first initialize virtualMachineScaleSetIPConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetIPConfiguration_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetIPConfiguration_statusGenerator != nil {
		return virtualMachineScaleSetIPConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(generators)
	virtualMachineScaleSetIPConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIPConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(generators)
	virtualMachineScaleSetIPConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIPConfiguration_Status{}), generators)

	return virtualMachineScaleSetIPConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_StatusIPv4, VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_StatusIPv6))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["LoadBalancerInboundNatPools"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["PublicIPAddressConfiguration"] = gen.PtrOf(VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator())
	gens["Subnet"] = gen.PtrOf(ApiEntityReference_StatusGenerator())
}

func Test_VirtualMachineScaleSetManagedDiskParameters_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetManagedDiskParameters_Spec to VirtualMachineScaleSetManagedDiskParameters_Spec via AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_Spec & AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Spec, VirtualMachineScaleSetManagedDiskParameters_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Spec tests if a specific instance of VirtualMachineScaleSetManagedDiskParameters_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Spec(subject VirtualMachineScaleSetManagedDiskParameters_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetManagedDiskParameters_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetManagedDiskParameters_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetManagedDiskParameters_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Spec, VirtualMachineScaleSetManagedDiskParameters_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Spec runs a test to see if a specific instance of VirtualMachineScaleSetManagedDiskParameters_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Spec(subject VirtualMachineScaleSetManagedDiskParameters_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetManagedDiskParameters_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetManagedDiskParameters_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetManagedDiskParameters_SpecGenerator()
var virtualMachineScaleSetManagedDiskParameters_specGenerator gopter.Gen

// VirtualMachineScaleSetManagedDiskParameters_SpecGenerator returns a generator of VirtualMachineScaleSetManagedDiskParameters_Spec instances for property testing.
// We first initialize virtualMachineScaleSetManagedDiskParameters_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetManagedDiskParameters_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetManagedDiskParameters_specGenerator != nil {
		return virtualMachineScaleSetManagedDiskParameters_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Spec(generators)
	virtualMachineScaleSetManagedDiskParameters_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetManagedDiskParameters_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Spec(generators)
	virtualMachineScaleSetManagedDiskParameters_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetManagedDiskParameters_Spec{}), generators)

	return virtualMachineScaleSetManagedDiskParameters_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Spec(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_SpecPremium_LRS,
		StorageAccountType_SpecPremium_ZRS,
		StorageAccountType_SpecStandardSSD_LRS,
		StorageAccountType_SpecStandardSSD_ZRS,
		StorageAccountType_SpecStandard_LRS,
		StorageAccountType_SpecUltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Spec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_VirtualMachineScaleSetManagedDiskParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetManagedDiskParameters_Status to VirtualMachineScaleSetManagedDiskParameters_Status via AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_Status & AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Status, VirtualMachineScaleSetManagedDiskParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Status tests if a specific instance of VirtualMachineScaleSetManagedDiskParameters_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Status(subject VirtualMachineScaleSetManagedDiskParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetManagedDiskParameters_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetManagedDiskParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetManagedDiskParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Status, VirtualMachineScaleSetManagedDiskParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Status runs a test to see if a specific instance of VirtualMachineScaleSetManagedDiskParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Status(subject VirtualMachineScaleSetManagedDiskParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetManagedDiskParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetManagedDiskParameters_Status instances for property testing - lazily instantiated
//by VirtualMachineScaleSetManagedDiskParameters_StatusGenerator()
var virtualMachineScaleSetManagedDiskParameters_statusGenerator gopter.Gen

// VirtualMachineScaleSetManagedDiskParameters_StatusGenerator returns a generator of VirtualMachineScaleSetManagedDiskParameters_Status instances for property testing.
// We first initialize virtualMachineScaleSetManagedDiskParameters_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetManagedDiskParameters_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetManagedDiskParameters_statusGenerator != nil {
		return virtualMachineScaleSetManagedDiskParameters_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(generators)
	virtualMachineScaleSetManagedDiskParameters_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetManagedDiskParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(generators)
	virtualMachineScaleSetManagedDiskParameters_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetManagedDiskParameters_Status{}), generators)

	return virtualMachineScaleSetManagedDiskParameters_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_StatusPremium_LRS,
		StorageAccountType_StatusPremium_ZRS,
		StorageAccountType_StatusStandardSSD_LRS,
		StorageAccountType_StatusStandardSSD_ZRS,
		StorageAccountType_StatusStandard_LRS,
		StorageAccountType_StatusUltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec to VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec via AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec & AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec, VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec tests if a specific instance of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec(subject VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec, VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec runs a test to see if a specific instance of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec(subject VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec instances for property testing - lazily
//instantiated by VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecGenerator()
var virtualMachineScaleSetNetworkConfigurationDnsSettings_specGenerator gopter.Gen

// VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecGenerator returns a generator of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec instances for property testing.
func VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkConfigurationDnsSettings_specGenerator != nil {
		return virtualMachineScaleSetNetworkConfigurationDnsSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec(generators)
	virtualMachineScaleSetNetworkConfigurationDnsSettings_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec{}), generators)

	return virtualMachineScaleSetNetworkConfigurationDnsSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status to VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status via AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status & AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status, VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status tests if a specific instance of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(subject VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status, VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status runs a test to see if a specific instance of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(subject VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status instances for property testing - lazily
//instantiated by VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator()
var virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator gopter.Gen

// VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator returns a generator of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status instances for property testing.
func VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator != nil {
		return virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(generators)
	virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status{}), generators)

	return virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetPublicIPAddressConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetPublicIPAddressConfiguration_Spec to VirtualMachineScaleSetPublicIPAddressConfiguration_Spec via AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_Spec & AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec, VirtualMachineScaleSetPublicIPAddressConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec tests if a specific instance of VirtualMachineScaleSetPublicIPAddressConfiguration_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(subject VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetPublicIPAddressConfiguration_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetPublicIPAddressConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetPublicIPAddressConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec, VirtualMachineScaleSetPublicIPAddressConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec runs a test to see if a specific instance of VirtualMachineScaleSetPublicIPAddressConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(subject VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetPublicIPAddressConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetPublicIPAddressConfiguration_Spec instances for property testing - lazily
//instantiated by VirtualMachineScaleSetPublicIPAddressConfiguration_SpecGenerator()
var virtualMachineScaleSetPublicIPAddressConfiguration_specGenerator gopter.Gen

// VirtualMachineScaleSetPublicIPAddressConfiguration_SpecGenerator returns a generator of VirtualMachineScaleSetPublicIPAddressConfiguration_Spec instances for property testing.
// We first initialize virtualMachineScaleSetPublicIPAddressConfiguration_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetPublicIPAddressConfiguration_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetPublicIPAddressConfiguration_specGenerator != nil {
		return virtualMachineScaleSetPublicIPAddressConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(generators)
	virtualMachineScaleSetPublicIPAddressConfiguration_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(generators)
	virtualMachineScaleSetPublicIPAddressConfiguration_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfiguration_Spec{}), generators)

	return virtualMachineScaleSetPublicIPAddressConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.AlphaString()
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_SpecIPv4, VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_SpecIPv6))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecGenerator())
	gens["IpTags"] = gen.SliceOf(VirtualMachineScaleSetIpTag_SpecGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_VirtualMachineScaleSetPublicIPAddressConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetPublicIPAddressConfiguration_Status to VirtualMachineScaleSetPublicIPAddressConfiguration_Status via AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_Status & AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status, VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status tests if a specific instance of VirtualMachineScaleSetPublicIPAddressConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(subject VirtualMachineScaleSetPublicIPAddressConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetPublicIPAddressConfiguration_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetPublicIPAddressConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetPublicIPAddressConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status, VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status runs a test to see if a specific instance of VirtualMachineScaleSetPublicIPAddressConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(subject VirtualMachineScaleSetPublicIPAddressConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetPublicIPAddressConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetPublicIPAddressConfiguration_Status instances for property testing - lazily
//instantiated by VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator()
var virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator gopter.Gen

// VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator returns a generator of VirtualMachineScaleSetPublicIPAddressConfiguration_Status instances for property testing.
// We first initialize virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator != nil {
		return virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(generators)
	virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(generators)
	virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfiguration_Status{}), generators)

	return virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.AlphaString()
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_StatusIPv4, VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_StatusIPv6))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator())
	gens["IpTags"] = gen.SliceOf(VirtualMachineScaleSetIpTag_StatusGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_VirtualMachineScaleSetIpTag_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIpTag_Spec to VirtualMachineScaleSetIpTag_Spec via AssignPropertiesToVirtualMachineScaleSetIpTag_Spec & AssignPropertiesFromVirtualMachineScaleSetIpTag_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Spec, VirtualMachineScaleSetIpTag_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Spec tests if a specific instance of VirtualMachineScaleSetIpTag_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Spec(subject VirtualMachineScaleSetIpTag_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetIpTag_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIpTag_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIpTag_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIpTag_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIpTag_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Spec, VirtualMachineScaleSetIpTag_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Spec runs a test to see if a specific instance of VirtualMachineScaleSetIpTag_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Spec(subject VirtualMachineScaleSetIpTag_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIpTag_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIpTag_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIpTag_SpecGenerator()
var virtualMachineScaleSetIpTag_specGenerator gopter.Gen

// VirtualMachineScaleSetIpTag_SpecGenerator returns a generator of VirtualMachineScaleSetIpTag_Spec instances for property testing.
func VirtualMachineScaleSetIpTag_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetIpTag_specGenerator != nil {
		return virtualMachineScaleSetIpTag_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Spec(generators)
	virtualMachineScaleSetIpTag_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIpTag_Spec{}), generators)

	return virtualMachineScaleSetIpTag_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Spec(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetIpTag_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIpTag_Status to VirtualMachineScaleSetIpTag_Status via AssignPropertiesToVirtualMachineScaleSetIpTag_Status & AssignPropertiesFromVirtualMachineScaleSetIpTag_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Status, VirtualMachineScaleSetIpTag_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Status tests if a specific instance of VirtualMachineScaleSetIpTag_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Status(subject VirtualMachineScaleSetIpTag_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetIpTag_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIpTag_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIpTag_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIpTag_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIpTag_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Status, VirtualMachineScaleSetIpTag_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Status runs a test to see if a specific instance of VirtualMachineScaleSetIpTag_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Status(subject VirtualMachineScaleSetIpTag_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIpTag_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIpTag_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIpTag_StatusGenerator()
var virtualMachineScaleSetIpTag_statusGenerator gopter.Gen

// VirtualMachineScaleSetIpTag_StatusGenerator returns a generator of VirtualMachineScaleSetIpTag_Status instances for property testing.
func VirtualMachineScaleSetIpTag_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetIpTag_statusGenerator != nil {
		return virtualMachineScaleSetIpTag_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Status(generators)
	virtualMachineScaleSetIpTag_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIpTag_Status{}), generators)

	return virtualMachineScaleSetIpTag_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Status(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec to VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec via AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec & AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec, VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec tests if a specific instance of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec(subject VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec, VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec runs a test to see if a specific instance of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec(subject VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec instances for property testing -
//lazily instantiated by VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecGenerator()
var virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_specGenerator gopter.Gen

// VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecGenerator returns a generator of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec instances for property testing.
func VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_specGenerator != nil {
		return virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec(generators)
	virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec{}), generators)

	return virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.AlphaString()
}

func Test_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status to VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status via AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status & AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status, VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status tests if a specific instance of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(subject VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status, VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status runs a test to see if a specific instance of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(subject VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status instances for property testing -
//lazily instantiated by VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator()
var virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator gopter.Gen

// VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator returns a generator of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status instances for property testing.
func VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator != nil {
		return virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(generators)
	virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status{}), generators)

	return virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.AlphaString()
}
