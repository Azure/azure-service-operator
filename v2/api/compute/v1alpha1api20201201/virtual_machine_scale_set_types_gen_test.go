// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachineScaleSet_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSet to hub returns original",
		prop.ForAll(RunResourceConversionTestForVirtualMachineScaleSet, VirtualMachineScaleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForVirtualMachineScaleSet tests if a specific instance of VirtualMachineScaleSet round trips to the hub storage version and back losslessly
func RunResourceConversionTestForVirtualMachineScaleSet(subject VirtualMachineScaleSet) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20201201storage.VirtualMachineScaleSet
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual VirtualMachineScaleSet
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSet to VirtualMachineScaleSet via AssignPropertiesToVirtualMachineScaleSet & AssignPropertiesFromVirtualMachineScaleSet returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSet, VirtualMachineScaleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSet tests if a specific instance of VirtualMachineScaleSet can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSet(subject VirtualMachineScaleSet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSet
	err := copied.AssignPropertiesToVirtualMachineScaleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSet
	err = actual.AssignPropertiesFromVirtualMachineScaleSet(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSet, VirtualMachineScaleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSet runs a test to see if a specific instance of VirtualMachineScaleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSet(subject VirtualMachineScaleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSet instances for property testing - lazily instantiated by
//VirtualMachineScaleSetGenerator()
var virtualMachineScaleSetGenerator gopter.Gen

// VirtualMachineScaleSetGenerator returns a generator of VirtualMachineScaleSet instances for property testing.
func VirtualMachineScaleSetGenerator() gopter.Gen {
	if virtualMachineScaleSetGenerator != nil {
		return virtualMachineScaleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSet(generators)
	virtualMachineScaleSetGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSet{}), generators)

	return virtualMachineScaleSetGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSet(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualMachineScaleSet_SpecGenerator()
	gens["Status"] = VirtualMachineScaleSet_StatusGenerator()
}

func Test_VirtualMachineScaleSet_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSet_Spec to VirtualMachineScaleSet_Spec via AssignPropertiesToVirtualMachineScaleSet_Spec & AssignPropertiesFromVirtualMachineScaleSet_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSet_Spec, VirtualMachineScaleSet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSet_Spec tests if a specific instance of VirtualMachineScaleSet_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSet_Spec(subject VirtualMachineScaleSet_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSet_Spec
	err := copied.AssignPropertiesToVirtualMachineScaleSet_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSet_Spec
	err = actual.AssignPropertiesFromVirtualMachineScaleSet_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSet_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSet_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSet_Spec, VirtualMachineScaleSet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSet_Spec runs a test to see if a specific instance of VirtualMachineScaleSet_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSet_Spec(subject VirtualMachineScaleSet_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSet_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSet_Spec instances for property testing - lazily instantiated by
//VirtualMachineScaleSet_SpecGenerator()
var virtualMachineScaleSet_specGenerator gopter.Gen

// VirtualMachineScaleSet_SpecGenerator returns a generator of VirtualMachineScaleSet_Spec instances for property testing.
// We first initialize virtualMachineScaleSet_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSet_SpecGenerator() gopter.Gen {
	if virtualMachineScaleSet_specGenerator != nil {
		return virtualMachineScaleSet_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Spec(generators)
	virtualMachineScaleSet_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSet_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Spec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Spec(generators)
	virtualMachineScaleSet_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSet_Spec{}), generators)

	return virtualMachineScaleSet_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["DoNotRunExtensionsOnOverprovisionedVMs"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.AlphaString()
	gens["OrchestrationMode"] = gen.PtrOf(gen.OneConstOf(OrchestrationModeFlexible, OrchestrationModeUniform))
	gens["Overprovision"] = gen.PtrOf(gen.Bool())
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["SinglePlacementGroup"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ZoneBalance"] = gen.PtrOf(gen.Bool())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Spec(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesGenerator())
	gens["AutomaticRepairsPolicy"] = gen.PtrOf(AutomaticRepairsPolicyGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineScaleSetIdentityGenerator())
	gens["Plan"] = gen.PtrOf(PlanGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceGenerator())
	gens["ScaleInPolicy"] = gen.PtrOf(ScaleInPolicyGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
	gens["UpgradePolicy"] = gen.PtrOf(UpgradePolicyGenerator())
	gens["VirtualMachineProfile"] = gen.PtrOf(VirtualMachineScaleSetVMProfileGenerator())
}

func Test_VirtualMachineScaleSet_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSet_Status to VirtualMachineScaleSet_Status via AssignPropertiesToVirtualMachineScaleSet_Status & AssignPropertiesFromVirtualMachineScaleSet_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSet_Status, VirtualMachineScaleSet_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSet_Status tests if a specific instance of VirtualMachineScaleSet_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSet_Status(subject VirtualMachineScaleSet_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSet_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSet_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSet_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSet_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSet_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSet_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSet_Status, VirtualMachineScaleSet_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSet_Status runs a test to see if a specific instance of VirtualMachineScaleSet_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSet_Status(subject VirtualMachineScaleSet_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSet_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSet_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSet_StatusGenerator()
var virtualMachineScaleSet_statusGenerator gopter.Gen

// VirtualMachineScaleSet_StatusGenerator returns a generator of VirtualMachineScaleSet_Status instances for property testing.
// We first initialize virtualMachineScaleSet_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSet_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSet_statusGenerator != nil {
		return virtualMachineScaleSet_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Status(generators)
	virtualMachineScaleSet_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSet_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Status(generators)
	virtualMachineScaleSet_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSet_Status{}), generators)

	return virtualMachineScaleSet_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSet_Status(gens map[string]gopter.Gen) {
	gens["DoNotRunExtensionsOnOverprovisionedVMs"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OrchestrationMode"] = gen.PtrOf(gen.AlphaString())
	gens["Overprovision"] = gen.PtrOf(gen.Bool())
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["SinglePlacementGroup"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneBalance"] = gen.PtrOf(gen.Bool())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSet_Status(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_StatusGenerator())
	gens["AutomaticRepairsPolicy"] = gen.PtrOf(AutomaticRepairsPolicy_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineScaleSetIdentity_StatusGenerator())
	gens["Plan"] = gen.PtrOf(Plan_StatusGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["ScaleInPolicy"] = gen.PtrOf(ScaleInPolicy_StatusGenerator())
	gens["Sku"] = gen.PtrOf(Sku_StatusGenerator())
	gens["UpgradePolicy"] = gen.PtrOf(UpgradePolicy_StatusGenerator())
	gens["VirtualMachineProfile"] = gen.PtrOf(VirtualMachineScaleSetVMProfile_StatusGenerator())
}

func Test_AutomaticRepairsPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomaticRepairsPolicy to AutomaticRepairsPolicy via AssignPropertiesToAutomaticRepairsPolicy & AssignPropertiesFromAutomaticRepairsPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomaticRepairsPolicy, AutomaticRepairsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomaticRepairsPolicy tests if a specific instance of AutomaticRepairsPolicy can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAutomaticRepairsPolicy(subject AutomaticRepairsPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AutomaticRepairsPolicy
	err := copied.AssignPropertiesToAutomaticRepairsPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomaticRepairsPolicy
	err = actual.AssignPropertiesFromAutomaticRepairsPolicy(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomaticRepairsPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomaticRepairsPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomaticRepairsPolicy, AutomaticRepairsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomaticRepairsPolicy runs a test to see if a specific instance of AutomaticRepairsPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomaticRepairsPolicy(subject AutomaticRepairsPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomaticRepairsPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomaticRepairsPolicy instances for property testing - lazily instantiated by
//AutomaticRepairsPolicyGenerator()
var automaticRepairsPolicyGenerator gopter.Gen

// AutomaticRepairsPolicyGenerator returns a generator of AutomaticRepairsPolicy instances for property testing.
func AutomaticRepairsPolicyGenerator() gopter.Gen {
	if automaticRepairsPolicyGenerator != nil {
		return automaticRepairsPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy(generators)
	automaticRepairsPolicyGenerator = gen.Struct(reflect.TypeOf(AutomaticRepairsPolicy{}), generators)

	return automaticRepairsPolicyGenerator
}

// AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GracePeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutomaticRepairsPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomaticRepairsPolicy_Status to AutomaticRepairsPolicy_Status via AssignPropertiesToAutomaticRepairsPolicy_Status & AssignPropertiesFromAutomaticRepairsPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomaticRepairsPolicy_Status, AutomaticRepairsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomaticRepairsPolicy_Status tests if a specific instance of AutomaticRepairsPolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAutomaticRepairsPolicy_Status(subject AutomaticRepairsPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AutomaticRepairsPolicy_Status
	err := copied.AssignPropertiesToAutomaticRepairsPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomaticRepairsPolicy_Status
	err = actual.AssignPropertiesFromAutomaticRepairsPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomaticRepairsPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomaticRepairsPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomaticRepairsPolicy_Status, AutomaticRepairsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomaticRepairsPolicy_Status runs a test to see if a specific instance of AutomaticRepairsPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomaticRepairsPolicy_Status(subject AutomaticRepairsPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomaticRepairsPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomaticRepairsPolicy_Status instances for property testing - lazily instantiated by
//AutomaticRepairsPolicy_StatusGenerator()
var automaticRepairsPolicy_statusGenerator gopter.Gen

// AutomaticRepairsPolicy_StatusGenerator returns a generator of AutomaticRepairsPolicy_Status instances for property testing.
func AutomaticRepairsPolicy_StatusGenerator() gopter.Gen {
	if automaticRepairsPolicy_statusGenerator != nil {
		return automaticRepairsPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Status(generators)
	automaticRepairsPolicy_statusGenerator = gen.Struct(reflect.TypeOf(AutomaticRepairsPolicy_Status{}), generators)

	return automaticRepairsPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomaticRepairsPolicy_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GracePeriod"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleInPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleInPolicy to ScaleInPolicy via AssignPropertiesToScaleInPolicy & AssignPropertiesFromScaleInPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleInPolicy, ScaleInPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleInPolicy tests if a specific instance of ScaleInPolicy can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForScaleInPolicy(subject ScaleInPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ScaleInPolicy
	err := copied.AssignPropertiesToScaleInPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleInPolicy
	err = actual.AssignPropertiesFromScaleInPolicy(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleInPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleInPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleInPolicy, ScaleInPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleInPolicy runs a test to see if a specific instance of ScaleInPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleInPolicy(subject ScaleInPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleInPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleInPolicy instances for property testing - lazily instantiated by ScaleInPolicyGenerator()
var scaleInPolicyGenerator gopter.Gen

// ScaleInPolicyGenerator returns a generator of ScaleInPolicy instances for property testing.
func ScaleInPolicyGenerator() gopter.Gen {
	if scaleInPolicyGenerator != nil {
		return scaleInPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleInPolicy(generators)
	scaleInPolicyGenerator = gen.Struct(reflect.TypeOf(ScaleInPolicy{}), generators)

	return scaleInPolicyGenerator
}

// AddIndependentPropertyGeneratorsForScaleInPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleInPolicy(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(gen.OneConstOf(ScaleInPolicyRulesDefault, ScaleInPolicyRulesNewestVM, ScaleInPolicyRulesOldestVM))
}

func Test_ScaleInPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleInPolicy_Status to ScaleInPolicy_Status via AssignPropertiesToScaleInPolicy_Status & AssignPropertiesFromScaleInPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleInPolicy_Status, ScaleInPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleInPolicy_Status tests if a specific instance of ScaleInPolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForScaleInPolicy_Status(subject ScaleInPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ScaleInPolicy_Status
	err := copied.AssignPropertiesToScaleInPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleInPolicy_Status
	err = actual.AssignPropertiesFromScaleInPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleInPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleInPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleInPolicy_Status, ScaleInPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleInPolicy_Status runs a test to see if a specific instance of ScaleInPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleInPolicy_Status(subject ScaleInPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleInPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleInPolicy_Status instances for property testing - lazily instantiated by
//ScaleInPolicy_StatusGenerator()
var scaleInPolicy_statusGenerator gopter.Gen

// ScaleInPolicy_StatusGenerator returns a generator of ScaleInPolicy_Status instances for property testing.
func ScaleInPolicy_StatusGenerator() gopter.Gen {
	if scaleInPolicy_statusGenerator != nil {
		return scaleInPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleInPolicy_Status(generators)
	scaleInPolicy_statusGenerator = gen.Struct(reflect.TypeOf(ScaleInPolicy_Status{}), generators)

	return scaleInPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForScaleInPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleInPolicy_Status(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(gen.AlphaString())
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignPropertiesToSku & AssignPropertiesFromSku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.Sku
	err := copied.AssignPropertiesToSku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignPropertiesFromSku(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_Status to Sku_Status via AssignPropertiesToSku_Status & AssignPropertiesFromSku_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_Status, Sku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_Status tests if a specific instance of Sku_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForSku_Status(subject Sku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.Sku_Status
	err := copied.AssignPropertiesToSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_Status
	err = actual.AssignPropertiesFromSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_Status, Sku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_Status runs a test to see if a specific instance of Sku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_Status(subject Sku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_Status instances for property testing - lazily instantiated by Sku_StatusGenerator()
var sku_statusGenerator gopter.Gen

// Sku_StatusGenerator returns a generator of Sku_Status instances for property testing.
func Sku_StatusGenerator() gopter.Gen {
	if sku_statusGenerator != nil {
		return sku_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_Status(generators)
	sku_statusGenerator = gen.Struct(reflect.TypeOf(Sku_Status{}), generators)

	return sku_statusGenerator
}

// AddIndependentPropertyGeneratorsForSku_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_Status(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpgradePolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpgradePolicy to UpgradePolicy via AssignPropertiesToUpgradePolicy & AssignPropertiesFromUpgradePolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpgradePolicy, UpgradePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpgradePolicy tests if a specific instance of UpgradePolicy can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForUpgradePolicy(subject UpgradePolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.UpgradePolicy
	err := copied.AssignPropertiesToUpgradePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpgradePolicy
	err = actual.AssignPropertiesFromUpgradePolicy(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpgradePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpgradePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpgradePolicy, UpgradePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpgradePolicy runs a test to see if a specific instance of UpgradePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForUpgradePolicy(subject UpgradePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpgradePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpgradePolicy instances for property testing - lazily instantiated by UpgradePolicyGenerator()
var upgradePolicyGenerator gopter.Gen

// UpgradePolicyGenerator returns a generator of UpgradePolicy instances for property testing.
// We first initialize upgradePolicyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpgradePolicyGenerator() gopter.Gen {
	if upgradePolicyGenerator != nil {
		return upgradePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpgradePolicy(generators)
	upgradePolicyGenerator = gen.Struct(reflect.TypeOf(UpgradePolicy{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpgradePolicy(generators)
	AddRelatedPropertyGeneratorsForUpgradePolicy(generators)
	upgradePolicyGenerator = gen.Struct(reflect.TypeOf(UpgradePolicy{}), generators)

	return upgradePolicyGenerator
}

// AddIndependentPropertyGeneratorsForUpgradePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpgradePolicy(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(UpgradePolicyModeAutomatic, UpgradePolicyModeManual, UpgradePolicyModeRolling))
}

// AddRelatedPropertyGeneratorsForUpgradePolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpgradePolicy(gens map[string]gopter.Gen) {
	gens["AutomaticOSUpgradePolicy"] = gen.PtrOf(AutomaticOSUpgradePolicyGenerator())
	gens["RollingUpgradePolicy"] = gen.PtrOf(RollingUpgradePolicyGenerator())
}

func Test_UpgradePolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpgradePolicy_Status to UpgradePolicy_Status via AssignPropertiesToUpgradePolicy_Status & AssignPropertiesFromUpgradePolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpgradePolicy_Status, UpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpgradePolicy_Status tests if a specific instance of UpgradePolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForUpgradePolicy_Status(subject UpgradePolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.UpgradePolicy_Status
	err := copied.AssignPropertiesToUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpgradePolicy_Status
	err = actual.AssignPropertiesFromUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpgradePolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpgradePolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpgradePolicy_Status, UpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpgradePolicy_Status runs a test to see if a specific instance of UpgradePolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUpgradePolicy_Status(subject UpgradePolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpgradePolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpgradePolicy_Status instances for property testing - lazily instantiated by
//UpgradePolicy_StatusGenerator()
var upgradePolicy_statusGenerator gopter.Gen

// UpgradePolicy_StatusGenerator returns a generator of UpgradePolicy_Status instances for property testing.
// We first initialize upgradePolicy_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpgradePolicy_StatusGenerator() gopter.Gen {
	if upgradePolicy_statusGenerator != nil {
		return upgradePolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpgradePolicy_Status(generators)
	upgradePolicy_statusGenerator = gen.Struct(reflect.TypeOf(UpgradePolicy_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpgradePolicy_Status(generators)
	AddRelatedPropertyGeneratorsForUpgradePolicy_Status(generators)
	upgradePolicy_statusGenerator = gen.Struct(reflect.TypeOf(UpgradePolicy_Status{}), generators)

	return upgradePolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForUpgradePolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpgradePolicy_Status(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpgradePolicy_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpgradePolicy_Status(gens map[string]gopter.Gen) {
	gens["AutomaticOSUpgradePolicy"] = gen.PtrOf(AutomaticOSUpgradePolicy_StatusGenerator())
	gens["RollingUpgradePolicy"] = gen.PtrOf(RollingUpgradePolicy_StatusGenerator())
}

func Test_VirtualMachineScaleSetIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIdentity to VirtualMachineScaleSetIdentity via AssignPropertiesToVirtualMachineScaleSetIdentity & AssignPropertiesFromVirtualMachineScaleSetIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity, VirtualMachineScaleSetIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity tests if a specific instance of VirtualMachineScaleSetIdentity can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity(subject VirtualMachineScaleSetIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIdentity
	err := copied.AssignPropertiesToVirtualMachineScaleSetIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIdentity
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIdentity(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIdentity, VirtualMachineScaleSetIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIdentity runs a test to see if a specific instance of VirtualMachineScaleSetIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIdentity(subject VirtualMachineScaleSetIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIdentity instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIdentityGenerator()
var virtualMachineScaleSetIdentityGenerator gopter.Gen

// VirtualMachineScaleSetIdentityGenerator returns a generator of VirtualMachineScaleSetIdentity instances for property testing.
func VirtualMachineScaleSetIdentityGenerator() gopter.Gen {
	if virtualMachineScaleSetIdentityGenerator != nil {
		return virtualMachineScaleSetIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity(generators)
	virtualMachineScaleSetIdentityGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIdentity{}), generators)

	return virtualMachineScaleSetIdentityGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineScaleSetIdentityTypeNone,
		VirtualMachineScaleSetIdentityTypeSystemAssigned,
		VirtualMachineScaleSetIdentityTypeSystemAssignedUserAssigned,
		VirtualMachineScaleSetIdentityTypeUserAssigned))
}

func Test_VirtualMachineScaleSetIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIdentity_Status to VirtualMachineScaleSetIdentity_Status via AssignPropertiesToVirtualMachineScaleSetIdentity_Status & AssignPropertiesFromVirtualMachineScaleSetIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Status, VirtualMachineScaleSetIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Status tests if a specific instance of VirtualMachineScaleSetIdentity_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_Status(subject VirtualMachineScaleSetIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIdentity_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Status, VirtualMachineScaleSetIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Status runs a test to see if a specific instance of VirtualMachineScaleSetIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIdentity_Status(subject VirtualMachineScaleSetIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIdentity_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIdentity_StatusGenerator()
var virtualMachineScaleSetIdentity_statusGenerator gopter.Gen

// VirtualMachineScaleSetIdentity_StatusGenerator returns a generator of VirtualMachineScaleSetIdentity_Status instances for property testing.
// We first initialize virtualMachineScaleSetIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetIdentity_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetIdentity_statusGenerator != nil {
		return virtualMachineScaleSetIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(generators)
	virtualMachineScaleSetIdentity_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(generators)
	virtualMachineScaleSetIdentity_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIdentity_Status{}), generators)

	return virtualMachineScaleSetIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), VirtualMachineScaleSetIdentity_StatusUserAssignedIdentitiesGenerator())
}

func Test_VirtualMachineScaleSetVMProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetVMProfile to VirtualMachineScaleSetVMProfile via AssignPropertiesToVirtualMachineScaleSetVMProfile & AssignPropertiesFromVirtualMachineScaleSetVMProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile, VirtualMachineScaleSetVMProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile tests if a specific instance of VirtualMachineScaleSetVMProfile can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile(subject VirtualMachineScaleSetVMProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile
	err := copied.AssignPropertiesToVirtualMachineScaleSetVMProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetVMProfile
	err = actual.AssignPropertiesFromVirtualMachineScaleSetVMProfile(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetVMProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetVMProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetVMProfile, VirtualMachineScaleSetVMProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetVMProfile runs a test to see if a specific instance of VirtualMachineScaleSetVMProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetVMProfile(subject VirtualMachineScaleSetVMProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetVMProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetVMProfile instances for property testing - lazily instantiated by
//VirtualMachineScaleSetVMProfileGenerator()
var virtualMachineScaleSetVMProfileGenerator gopter.Gen

// VirtualMachineScaleSetVMProfileGenerator returns a generator of VirtualMachineScaleSetVMProfile instances for property testing.
// We first initialize virtualMachineScaleSetVMProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetVMProfileGenerator() gopter.Gen {
	if virtualMachineScaleSetVMProfileGenerator != nil {
		return virtualMachineScaleSetVMProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile(generators)
	virtualMachineScaleSetVMProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetVMProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile(generators)
	virtualMachineScaleSetVMProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetVMProfile{}), generators)

	return virtualMachineScaleSetVMProfileGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicyDeallocate, EvictionPolicyDelete))
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(PriorityLow, PriorityRegular, PrioritySpot))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile(gens map[string]gopter.Gen) {
	gens["BillingProfile"] = gen.PtrOf(BillingProfileGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileGenerator())
	gens["ExtensionProfile"] = gen.PtrOf(VirtualMachineScaleSetExtensionProfileGenerator())
	gens["NetworkProfile"] = gen.PtrOf(VirtualMachineScaleSetNetworkProfileGenerator())
	gens["OsProfile"] = gen.PtrOf(VirtualMachineScaleSetOSProfileGenerator())
	gens["ScheduledEventsProfile"] = gen.PtrOf(ScheduledEventsProfileGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileGenerator())
	gens["StorageProfile"] = gen.PtrOf(VirtualMachineScaleSetStorageProfileGenerator())
}

func Test_VirtualMachineScaleSetVMProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetVMProfile_Status to VirtualMachineScaleSetVMProfile_Status via AssignPropertiesToVirtualMachineScaleSetVMProfile_Status & AssignPropertiesFromVirtualMachineScaleSetVMProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Status, VirtualMachineScaleSetVMProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Status tests if a specific instance of VirtualMachineScaleSetVMProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetVMProfile_Status(subject VirtualMachineScaleSetVMProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetVMProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetVMProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetVMProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetVMProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetVMProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Status, VirtualMachineScaleSetVMProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetVMProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetVMProfile_Status(subject VirtualMachineScaleSetVMProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetVMProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetVMProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetVMProfile_StatusGenerator()
var virtualMachineScaleSetVMProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetVMProfile_StatusGenerator returns a generator of VirtualMachineScaleSetVMProfile_Status instances for property testing.
// We first initialize virtualMachineScaleSetVMProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetVMProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetVMProfile_statusGenerator != nil {
		return virtualMachineScaleSetVMProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(generators)
	virtualMachineScaleSetVMProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetVMProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(generators)
	virtualMachineScaleSetVMProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetVMProfile_Status{}), generators)

	return virtualMachineScaleSetVMProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetVMProfile_Status(gens map[string]gopter.Gen) {
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_StatusGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_StatusGenerator())
	gens["ExtensionProfile"] = gen.PtrOf(VirtualMachineScaleSetExtensionProfile_StatusGenerator())
	gens["NetworkProfile"] = gen.PtrOf(VirtualMachineScaleSetNetworkProfile_StatusGenerator())
	gens["OsProfile"] = gen.PtrOf(VirtualMachineScaleSetOSProfile_StatusGenerator())
	gens["ScheduledEventsProfile"] = gen.PtrOf(ScheduledEventsProfile_StatusGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_StatusGenerator())
	gens["StorageProfile"] = gen.PtrOf(VirtualMachineScaleSetStorageProfile_StatusGenerator())
}

func Test_AutomaticOSUpgradePolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomaticOSUpgradePolicy to AutomaticOSUpgradePolicy via AssignPropertiesToAutomaticOSUpgradePolicy & AssignPropertiesFromAutomaticOSUpgradePolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomaticOSUpgradePolicy, AutomaticOSUpgradePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomaticOSUpgradePolicy tests if a specific instance of AutomaticOSUpgradePolicy can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAutomaticOSUpgradePolicy(subject AutomaticOSUpgradePolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AutomaticOSUpgradePolicy
	err := copied.AssignPropertiesToAutomaticOSUpgradePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomaticOSUpgradePolicy
	err = actual.AssignPropertiesFromAutomaticOSUpgradePolicy(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomaticOSUpgradePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomaticOSUpgradePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomaticOSUpgradePolicy, AutomaticOSUpgradePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomaticOSUpgradePolicy runs a test to see if a specific instance of AutomaticOSUpgradePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomaticOSUpgradePolicy(subject AutomaticOSUpgradePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomaticOSUpgradePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomaticOSUpgradePolicy instances for property testing - lazily instantiated by
//AutomaticOSUpgradePolicyGenerator()
var automaticOSUpgradePolicyGenerator gopter.Gen

// AutomaticOSUpgradePolicyGenerator returns a generator of AutomaticOSUpgradePolicy instances for property testing.
func AutomaticOSUpgradePolicyGenerator() gopter.Gen {
	if automaticOSUpgradePolicyGenerator != nil {
		return automaticOSUpgradePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy(generators)
	automaticOSUpgradePolicyGenerator = gen.Struct(reflect.TypeOf(AutomaticOSUpgradePolicy{}), generators)

	return automaticOSUpgradePolicyGenerator
}

// AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy(gens map[string]gopter.Gen) {
	gens["DisableAutomaticRollback"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticOSUpgrade"] = gen.PtrOf(gen.Bool())
}

func Test_AutomaticOSUpgradePolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomaticOSUpgradePolicy_Status to AutomaticOSUpgradePolicy_Status via AssignPropertiesToAutomaticOSUpgradePolicy_Status & AssignPropertiesFromAutomaticOSUpgradePolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Status, AutomaticOSUpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Status tests if a specific instance of AutomaticOSUpgradePolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForAutomaticOSUpgradePolicy_Status(subject AutomaticOSUpgradePolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Status
	err := copied.AssignPropertiesToAutomaticOSUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomaticOSUpgradePolicy_Status
	err = actual.AssignPropertiesFromAutomaticOSUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomaticOSUpgradePolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomaticOSUpgradePolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomaticOSUpgradePolicy_Status, AutomaticOSUpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomaticOSUpgradePolicy_Status runs a test to see if a specific instance of AutomaticOSUpgradePolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomaticOSUpgradePolicy_Status(subject AutomaticOSUpgradePolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomaticOSUpgradePolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomaticOSUpgradePolicy_Status instances for property testing - lazily instantiated by
//AutomaticOSUpgradePolicy_StatusGenerator()
var automaticOSUpgradePolicy_statusGenerator gopter.Gen

// AutomaticOSUpgradePolicy_StatusGenerator returns a generator of AutomaticOSUpgradePolicy_Status instances for property testing.
func AutomaticOSUpgradePolicy_StatusGenerator() gopter.Gen {
	if automaticOSUpgradePolicy_statusGenerator != nil {
		return automaticOSUpgradePolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Status(generators)
	automaticOSUpgradePolicy_statusGenerator = gen.Struct(reflect.TypeOf(AutomaticOSUpgradePolicy_Status{}), generators)

	return automaticOSUpgradePolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomaticOSUpgradePolicy_Status(gens map[string]gopter.Gen) {
	gens["DisableAutomaticRollback"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticOSUpgrade"] = gen.PtrOf(gen.Bool())
}

func Test_RollingUpgradePolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RollingUpgradePolicy to RollingUpgradePolicy via AssignPropertiesToRollingUpgradePolicy & AssignPropertiesFromRollingUpgradePolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForRollingUpgradePolicy, RollingUpgradePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRollingUpgradePolicy tests if a specific instance of RollingUpgradePolicy can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForRollingUpgradePolicy(subject RollingUpgradePolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.RollingUpgradePolicy
	err := copied.AssignPropertiesToRollingUpgradePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RollingUpgradePolicy
	err = actual.AssignPropertiesFromRollingUpgradePolicy(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RollingUpgradePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RollingUpgradePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRollingUpgradePolicy, RollingUpgradePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRollingUpgradePolicy runs a test to see if a specific instance of RollingUpgradePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForRollingUpgradePolicy(subject RollingUpgradePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RollingUpgradePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RollingUpgradePolicy instances for property testing - lazily instantiated by
//RollingUpgradePolicyGenerator()
var rollingUpgradePolicyGenerator gopter.Gen

// RollingUpgradePolicyGenerator returns a generator of RollingUpgradePolicy instances for property testing.
func RollingUpgradePolicyGenerator() gopter.Gen {
	if rollingUpgradePolicyGenerator != nil {
		return rollingUpgradePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRollingUpgradePolicy(generators)
	rollingUpgradePolicyGenerator = gen.Struct(reflect.TypeOf(RollingUpgradePolicy{}), generators)

	return rollingUpgradePolicyGenerator
}

// AddIndependentPropertyGeneratorsForRollingUpgradePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRollingUpgradePolicy(gens map[string]gopter.Gen) {
	gens["EnableCrossZoneUpgrade"] = gen.PtrOf(gen.Bool())
	gens["MaxBatchInstancePercent"] = gen.PtrOf(gen.Int())
	gens["MaxUnhealthyInstancePercent"] = gen.PtrOf(gen.Int())
	gens["MaxUnhealthyUpgradedInstancePercent"] = gen.PtrOf(gen.Int())
	gens["PauseTimeBetweenBatches"] = gen.PtrOf(gen.AlphaString())
	gens["PrioritizeUnhealthyInstances"] = gen.PtrOf(gen.Bool())
}

func Test_RollingUpgradePolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RollingUpgradePolicy_Status to RollingUpgradePolicy_Status via AssignPropertiesToRollingUpgradePolicy_Status & AssignPropertiesFromRollingUpgradePolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForRollingUpgradePolicy_Status, RollingUpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRollingUpgradePolicy_Status tests if a specific instance of RollingUpgradePolicy_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForRollingUpgradePolicy_Status(subject RollingUpgradePolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.RollingUpgradePolicy_Status
	err := copied.AssignPropertiesToRollingUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RollingUpgradePolicy_Status
	err = actual.AssignPropertiesFromRollingUpgradePolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RollingUpgradePolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RollingUpgradePolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRollingUpgradePolicy_Status, RollingUpgradePolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRollingUpgradePolicy_Status runs a test to see if a specific instance of RollingUpgradePolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRollingUpgradePolicy_Status(subject RollingUpgradePolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RollingUpgradePolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RollingUpgradePolicy_Status instances for property testing - lazily instantiated by
//RollingUpgradePolicy_StatusGenerator()
var rollingUpgradePolicy_statusGenerator gopter.Gen

// RollingUpgradePolicy_StatusGenerator returns a generator of RollingUpgradePolicy_Status instances for property testing.
func RollingUpgradePolicy_StatusGenerator() gopter.Gen {
	if rollingUpgradePolicy_statusGenerator != nil {
		return rollingUpgradePolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Status(generators)
	rollingUpgradePolicy_statusGenerator = gen.Struct(reflect.TypeOf(RollingUpgradePolicy_Status{}), generators)

	return rollingUpgradePolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRollingUpgradePolicy_Status(gens map[string]gopter.Gen) {
	gens["EnableCrossZoneUpgrade"] = gen.PtrOf(gen.Bool())
	gens["MaxBatchInstancePercent"] = gen.PtrOf(gen.Int())
	gens["MaxUnhealthyInstancePercent"] = gen.PtrOf(gen.Int())
	gens["MaxUnhealthyUpgradedInstancePercent"] = gen.PtrOf(gen.Int())
	gens["PauseTimeBetweenBatches"] = gen.PtrOf(gen.AlphaString())
	gens["PrioritizeUnhealthyInstances"] = gen.PtrOf(gen.Bool())
}

func Test_ScheduledEventsProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScheduledEventsProfile to ScheduledEventsProfile via AssignPropertiesToScheduledEventsProfile & AssignPropertiesFromScheduledEventsProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForScheduledEventsProfile, ScheduledEventsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScheduledEventsProfile tests if a specific instance of ScheduledEventsProfile can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForScheduledEventsProfile(subject ScheduledEventsProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ScheduledEventsProfile
	err := copied.AssignPropertiesToScheduledEventsProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScheduledEventsProfile
	err = actual.AssignPropertiesFromScheduledEventsProfile(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScheduledEventsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsProfile, ScheduledEventsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsProfile runs a test to see if a specific instance of ScheduledEventsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsProfile(subject ScheduledEventsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsProfile instances for property testing - lazily instantiated by
//ScheduledEventsProfileGenerator()
var scheduledEventsProfileGenerator gopter.Gen

// ScheduledEventsProfileGenerator returns a generator of ScheduledEventsProfile instances for property testing.
func ScheduledEventsProfileGenerator() gopter.Gen {
	if scheduledEventsProfileGenerator != nil {
		return scheduledEventsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsProfile(generators)
	scheduledEventsProfileGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsProfile{}), generators)

	return scheduledEventsProfileGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsProfile(gens map[string]gopter.Gen) {
	gens["TerminateNotificationProfile"] = gen.PtrOf(TerminateNotificationProfileGenerator())
}

func Test_ScheduledEventsProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScheduledEventsProfile_Status to ScheduledEventsProfile_Status via AssignPropertiesToScheduledEventsProfile_Status & AssignPropertiesFromScheduledEventsProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForScheduledEventsProfile_Status, ScheduledEventsProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScheduledEventsProfile_Status tests if a specific instance of ScheduledEventsProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForScheduledEventsProfile_Status(subject ScheduledEventsProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ScheduledEventsProfile_Status
	err := copied.AssignPropertiesToScheduledEventsProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScheduledEventsProfile_Status
	err = actual.AssignPropertiesFromScheduledEventsProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScheduledEventsProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsProfile_Status, ScheduledEventsProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsProfile_Status runs a test to see if a specific instance of ScheduledEventsProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsProfile_Status(subject ScheduledEventsProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsProfile_Status instances for property testing - lazily instantiated by
//ScheduledEventsProfile_StatusGenerator()
var scheduledEventsProfile_statusGenerator gopter.Gen

// ScheduledEventsProfile_StatusGenerator returns a generator of ScheduledEventsProfile_Status instances for property testing.
func ScheduledEventsProfile_StatusGenerator() gopter.Gen {
	if scheduledEventsProfile_statusGenerator != nil {
		return scheduledEventsProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsProfile_Status(generators)
	scheduledEventsProfile_statusGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsProfile_Status{}), generators)

	return scheduledEventsProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsProfile_Status(gens map[string]gopter.Gen) {
	gens["TerminateNotificationProfile"] = gen.PtrOf(TerminateNotificationProfile_StatusGenerator())
}

func Test_VirtualMachineScaleSetExtensionProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetExtensionProfile to VirtualMachineScaleSetExtensionProfile via AssignPropertiesToVirtualMachineScaleSetExtensionProfile & AssignPropertiesFromVirtualMachineScaleSetExtensionProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile, VirtualMachineScaleSetExtensionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile tests if a specific instance of VirtualMachineScaleSetExtensionProfile can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile(subject VirtualMachineScaleSetExtensionProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile
	err := copied.AssignPropertiesToVirtualMachineScaleSetExtensionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetExtensionProfile
	err = actual.AssignPropertiesFromVirtualMachineScaleSetExtensionProfile(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetExtensionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetExtensionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile, VirtualMachineScaleSetExtensionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile runs a test to see if a specific instance of VirtualMachineScaleSetExtensionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile(subject VirtualMachineScaleSetExtensionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetExtensionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetExtensionProfile instances for property testing - lazily instantiated by
//VirtualMachineScaleSetExtensionProfileGenerator()
var virtualMachineScaleSetExtensionProfileGenerator gopter.Gen

// VirtualMachineScaleSetExtensionProfileGenerator returns a generator of VirtualMachineScaleSetExtensionProfile instances for property testing.
func VirtualMachineScaleSetExtensionProfileGenerator() gopter.Gen {
	if virtualMachineScaleSetExtensionProfileGenerator != nil {
		return virtualMachineScaleSetExtensionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile(generators)
	virtualMachineScaleSetExtensionProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetExtensionProfile{}), generators)

	return virtualMachineScaleSetExtensionProfileGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile(gens map[string]gopter.Gen) {
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetExtensionProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetExtensionProfile_Status to VirtualMachineScaleSetExtensionProfile_Status via AssignPropertiesToVirtualMachineScaleSetExtensionProfile_Status & AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Status, VirtualMachineScaleSetExtensionProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Status tests if a specific instance of VirtualMachineScaleSetExtensionProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetExtensionProfile_Status(subject VirtualMachineScaleSetExtensionProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetExtensionProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetExtensionProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetExtensionProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetExtensionProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Status, VirtualMachineScaleSetExtensionProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetExtensionProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetExtensionProfile_Status(subject VirtualMachineScaleSetExtensionProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetExtensionProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetExtensionProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetExtensionProfile_StatusGenerator()
var virtualMachineScaleSetExtensionProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetExtensionProfile_StatusGenerator returns a generator of VirtualMachineScaleSetExtensionProfile_Status instances for property testing.
// We first initialize virtualMachineScaleSetExtensionProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetExtensionProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetExtensionProfile_statusGenerator != nil {
		return virtualMachineScaleSetExtensionProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(generators)
	virtualMachineScaleSetExtensionProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetExtensionProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(generators)
	virtualMachineScaleSetExtensionProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetExtensionProfile_Status{}), generators)

	return virtualMachineScaleSetExtensionProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(gens map[string]gopter.Gen) {
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetExtensionProfile_Status(gens map[string]gopter.Gen) {
	gens["Extensions"] = gen.SliceOf(VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator())
}

func Test_VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities to VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities via AssignPropertiesToVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities & AssignPropertiesFromVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities, VirtualMachineScaleSetIdentity_StatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities tests if a specific instance of VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities(subject VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities
	err := copied.AssignPropertiesToVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities, VirtualMachineScaleSetIdentity_StatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities runs a test to see if a specific instance of VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities(subject VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities instances for property testing - lazily
//instantiated by VirtualMachineScaleSetIdentity_StatusUserAssignedIdentitiesGenerator()
var virtualMachineScaleSetIdentity_statusUserAssignedIdentitiesGenerator gopter.Gen

// VirtualMachineScaleSetIdentity_StatusUserAssignedIdentitiesGenerator returns a generator of VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities instances for property testing.
func VirtualMachineScaleSetIdentity_StatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if virtualMachineScaleSetIdentity_statusUserAssignedIdentitiesGenerator != nil {
		return virtualMachineScaleSetIdentity_statusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities(generators)
	virtualMachineScaleSetIdentity_statusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIdentity_StatusUserAssignedIdentities{}), generators)

	return virtualMachineScaleSetIdentity_statusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIdentity_StatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetNetworkProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkProfile to VirtualMachineScaleSetNetworkProfile via AssignPropertiesToVirtualMachineScaleSetNetworkProfile & AssignPropertiesFromVirtualMachineScaleSetNetworkProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile, VirtualMachineScaleSetNetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile tests if a specific instance of VirtualMachineScaleSetNetworkProfile can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile(subject VirtualMachineScaleSetNetworkProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkProfile
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile, VirtualMachineScaleSetNetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile runs a test to see if a specific instance of VirtualMachineScaleSetNetworkProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile(subject VirtualMachineScaleSetNetworkProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkProfile instances for property testing - lazily instantiated by
//VirtualMachineScaleSetNetworkProfileGenerator()
var virtualMachineScaleSetNetworkProfileGenerator gopter.Gen

// VirtualMachineScaleSetNetworkProfileGenerator returns a generator of VirtualMachineScaleSetNetworkProfile instances for property testing.
func VirtualMachineScaleSetNetworkProfileGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkProfileGenerator != nil {
		return virtualMachineScaleSetNetworkProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile(generators)
	virtualMachineScaleSetNetworkProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkProfile{}), generators)

	return virtualMachineScaleSetNetworkProfileGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile(gens map[string]gopter.Gen) {
	gens["HealthProbe"] = gen.PtrOf(ApiEntityReferenceGenerator())
	gens["NetworkInterfaceConfigurations"] = gen.SliceOf(VirtualMachineScaleSetNetworkConfigurationGenerator())
}

func Test_VirtualMachineScaleSetNetworkProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkProfile_Status to VirtualMachineScaleSetNetworkProfile_Status via AssignPropertiesToVirtualMachineScaleSetNetworkProfile_Status & AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Status, VirtualMachineScaleSetNetworkProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Status tests if a specific instance of VirtualMachineScaleSetNetworkProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkProfile_Status(subject VirtualMachineScaleSetNetworkProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Status, VirtualMachineScaleSetNetworkProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetNetworkProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkProfile_Status(subject VirtualMachineScaleSetNetworkProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetNetworkProfile_StatusGenerator()
var virtualMachineScaleSetNetworkProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetNetworkProfile_StatusGenerator returns a generator of VirtualMachineScaleSetNetworkProfile_Status instances for property testing.
func VirtualMachineScaleSetNetworkProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkProfile_statusGenerator != nil {
		return virtualMachineScaleSetNetworkProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Status(generators)
	virtualMachineScaleSetNetworkProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkProfile_Status{}), generators)

	return virtualMachineScaleSetNetworkProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkProfile_Status(gens map[string]gopter.Gen) {
	gens["HealthProbe"] = gen.PtrOf(ApiEntityReference_StatusGenerator())
	gens["NetworkInterfaceConfigurations"] = gen.SliceOf(VirtualMachineScaleSetNetworkConfiguration_StatusGenerator())
}

func Test_VirtualMachineScaleSetOSProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetOSProfile to VirtualMachineScaleSetOSProfile via AssignPropertiesToVirtualMachineScaleSetOSProfile & AssignPropertiesFromVirtualMachineScaleSetOSProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile, VirtualMachineScaleSetOSProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile tests if a specific instance of VirtualMachineScaleSetOSProfile can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile(subject VirtualMachineScaleSetOSProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile
	err := copied.AssignPropertiesToVirtualMachineScaleSetOSProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetOSProfile
	err = actual.AssignPropertiesFromVirtualMachineScaleSetOSProfile(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetOSProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetOSProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetOSProfile, VirtualMachineScaleSetOSProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetOSProfile runs a test to see if a specific instance of VirtualMachineScaleSetOSProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetOSProfile(subject VirtualMachineScaleSetOSProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetOSProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetOSProfile instances for property testing - lazily instantiated by
//VirtualMachineScaleSetOSProfileGenerator()
var virtualMachineScaleSetOSProfileGenerator gopter.Gen

// VirtualMachineScaleSetOSProfileGenerator returns a generator of VirtualMachineScaleSetOSProfile instances for property testing.
// We first initialize virtualMachineScaleSetOSProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetOSProfileGenerator() gopter.Gen {
	if virtualMachineScaleSetOSProfileGenerator != nil {
		return virtualMachineScaleSetOSProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile(generators)
	virtualMachineScaleSetOSProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile(generators)
	virtualMachineScaleSetOSProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSProfile{}), generators)

	return virtualMachineScaleSetOSProfileGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile(gens map[string]gopter.Gen) {
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationGenerator())
}

func Test_VirtualMachineScaleSetOSProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetOSProfile_Status to VirtualMachineScaleSetOSProfile_Status via AssignPropertiesToVirtualMachineScaleSetOSProfile_Status & AssignPropertiesFromVirtualMachineScaleSetOSProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Status, VirtualMachineScaleSetOSProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Status tests if a specific instance of VirtualMachineScaleSetOSProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetOSProfile_Status(subject VirtualMachineScaleSetOSProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetOSProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetOSProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetOSProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetOSProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetOSProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Status, VirtualMachineScaleSetOSProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetOSProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetOSProfile_Status(subject VirtualMachineScaleSetOSProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetOSProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetOSProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetOSProfile_StatusGenerator()
var virtualMachineScaleSetOSProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetOSProfile_StatusGenerator returns a generator of VirtualMachineScaleSetOSProfile_Status instances for property testing.
// We first initialize virtualMachineScaleSetOSProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetOSProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetOSProfile_statusGenerator != nil {
		return virtualMachineScaleSetOSProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(generators)
	virtualMachineScaleSetOSProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(generators)
	virtualMachineScaleSetOSProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSProfile_Status{}), generators)

	return virtualMachineScaleSetOSProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSProfile_Status(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_StatusGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_StatusGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_StatusGenerator())
}

func Test_VirtualMachineScaleSetStorageProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetStorageProfile to VirtualMachineScaleSetStorageProfile via AssignPropertiesToVirtualMachineScaleSetStorageProfile & AssignPropertiesFromVirtualMachineScaleSetStorageProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile, VirtualMachineScaleSetStorageProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile tests if a specific instance of VirtualMachineScaleSetStorageProfile can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile(subject VirtualMachineScaleSetStorageProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile
	err := copied.AssignPropertiesToVirtualMachineScaleSetStorageProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetStorageProfile
	err = actual.AssignPropertiesFromVirtualMachineScaleSetStorageProfile(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetStorageProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetStorageProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile, VirtualMachineScaleSetStorageProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile runs a test to see if a specific instance of VirtualMachineScaleSetStorageProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile(subject VirtualMachineScaleSetStorageProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetStorageProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetStorageProfile instances for property testing - lazily instantiated by
//VirtualMachineScaleSetStorageProfileGenerator()
var virtualMachineScaleSetStorageProfileGenerator gopter.Gen

// VirtualMachineScaleSetStorageProfileGenerator returns a generator of VirtualMachineScaleSetStorageProfile instances for property testing.
func VirtualMachineScaleSetStorageProfileGenerator() gopter.Gen {
	if virtualMachineScaleSetStorageProfileGenerator != nil {
		return virtualMachineScaleSetStorageProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile(generators)
	virtualMachineScaleSetStorageProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetStorageProfile{}), generators)

	return virtualMachineScaleSetStorageProfileGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(VirtualMachineScaleSetDataDiskGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceGenerator())
	gens["OsDisk"] = gen.PtrOf(VirtualMachineScaleSetOSDiskGenerator())
}

func Test_VirtualMachineScaleSetStorageProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetStorageProfile_Status to VirtualMachineScaleSetStorageProfile_Status via AssignPropertiesToVirtualMachineScaleSetStorageProfile_Status & AssignPropertiesFromVirtualMachineScaleSetStorageProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Status, VirtualMachineScaleSetStorageProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Status tests if a specific instance of VirtualMachineScaleSetStorageProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetStorageProfile_Status(subject VirtualMachineScaleSetStorageProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetStorageProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetStorageProfile_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetStorageProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetStorageProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetStorageProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Status, VirtualMachineScaleSetStorageProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Status runs a test to see if a specific instance of VirtualMachineScaleSetStorageProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetStorageProfile_Status(subject VirtualMachineScaleSetStorageProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetStorageProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetStorageProfile_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetStorageProfile_StatusGenerator()
var virtualMachineScaleSetStorageProfile_statusGenerator gopter.Gen

// VirtualMachineScaleSetStorageProfile_StatusGenerator returns a generator of VirtualMachineScaleSetStorageProfile_Status instances for property testing.
func VirtualMachineScaleSetStorageProfile_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetStorageProfile_statusGenerator != nil {
		return virtualMachineScaleSetStorageProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Status(generators)
	virtualMachineScaleSetStorageProfile_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetStorageProfile_Status{}), generators)

	return virtualMachineScaleSetStorageProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetStorageProfile_Status(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(VirtualMachineScaleSetDataDisk_StatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_StatusGenerator())
	gens["OsDisk"] = gen.PtrOf(VirtualMachineScaleSetOSDisk_StatusGenerator())
}

func Test_ApiEntityReference_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiEntityReference to ApiEntityReference via AssignPropertiesToApiEntityReference & AssignPropertiesFromApiEntityReference returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiEntityReference, ApiEntityReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiEntityReference tests if a specific instance of ApiEntityReference can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForApiEntityReference(subject ApiEntityReference) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ApiEntityReference
	err := copied.AssignPropertiesToApiEntityReference(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiEntityReference
	err = actual.AssignPropertiesFromApiEntityReference(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiEntityReference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiEntityReference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiEntityReference, ApiEntityReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiEntityReference runs a test to see if a specific instance of ApiEntityReference round trips to JSON and back losslessly
func RunJSONSerializationTestForApiEntityReference(subject ApiEntityReference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiEntityReference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiEntityReference instances for property testing - lazily instantiated by ApiEntityReferenceGenerator()
var apiEntityReferenceGenerator gopter.Gen

// ApiEntityReferenceGenerator returns a generator of ApiEntityReference instances for property testing.
func ApiEntityReferenceGenerator() gopter.Gen {
	if apiEntityReferenceGenerator != nil {
		return apiEntityReferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiEntityReference(generators)
	apiEntityReferenceGenerator = gen.Struct(reflect.TypeOf(ApiEntityReference{}), generators)

	return apiEntityReferenceGenerator
}

// AddIndependentPropertyGeneratorsForApiEntityReference is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiEntityReference(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiEntityReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiEntityReference_Status to ApiEntityReference_Status via AssignPropertiesToApiEntityReference_Status & AssignPropertiesFromApiEntityReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiEntityReference_Status, ApiEntityReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiEntityReference_Status tests if a specific instance of ApiEntityReference_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForApiEntityReference_Status(subject ApiEntityReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ApiEntityReference_Status
	err := copied.AssignPropertiesToApiEntityReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiEntityReference_Status
	err = actual.AssignPropertiesFromApiEntityReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiEntityReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiEntityReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiEntityReference_Status, ApiEntityReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiEntityReference_Status runs a test to see if a specific instance of ApiEntityReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiEntityReference_Status(subject ApiEntityReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiEntityReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiEntityReference_Status instances for property testing - lazily instantiated by
//ApiEntityReference_StatusGenerator()
var apiEntityReference_statusGenerator gopter.Gen

// ApiEntityReference_StatusGenerator returns a generator of ApiEntityReference_Status instances for property testing.
func ApiEntityReference_StatusGenerator() gopter.Gen {
	if apiEntityReference_statusGenerator != nil {
		return apiEntityReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiEntityReference_Status(generators)
	apiEntityReference_statusGenerator = gen.Struct(reflect.TypeOf(ApiEntityReference_Status{}), generators)

	return apiEntityReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiEntityReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiEntityReference_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_TerminateNotificationProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TerminateNotificationProfile to TerminateNotificationProfile via AssignPropertiesToTerminateNotificationProfile & AssignPropertiesFromTerminateNotificationProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForTerminateNotificationProfile, TerminateNotificationProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTerminateNotificationProfile tests if a specific instance of TerminateNotificationProfile can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForTerminateNotificationProfile(subject TerminateNotificationProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.TerminateNotificationProfile
	err := copied.AssignPropertiesToTerminateNotificationProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TerminateNotificationProfile
	err = actual.AssignPropertiesFromTerminateNotificationProfile(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TerminateNotificationProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TerminateNotificationProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTerminateNotificationProfile, TerminateNotificationProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTerminateNotificationProfile runs a test to see if a specific instance of TerminateNotificationProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForTerminateNotificationProfile(subject TerminateNotificationProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TerminateNotificationProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TerminateNotificationProfile instances for property testing - lazily instantiated by
//TerminateNotificationProfileGenerator()
var terminateNotificationProfileGenerator gopter.Gen

// TerminateNotificationProfileGenerator returns a generator of TerminateNotificationProfile instances for property testing.
func TerminateNotificationProfileGenerator() gopter.Gen {
	if terminateNotificationProfileGenerator != nil {
		return terminateNotificationProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTerminateNotificationProfile(generators)
	terminateNotificationProfileGenerator = gen.Struct(reflect.TypeOf(TerminateNotificationProfile{}), generators)

	return terminateNotificationProfileGenerator
}

// AddIndependentPropertyGeneratorsForTerminateNotificationProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTerminateNotificationProfile(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
	gens["NotBeforeTimeout"] = gen.PtrOf(gen.AlphaString())
}

func Test_TerminateNotificationProfile_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TerminateNotificationProfile_Status to TerminateNotificationProfile_Status via AssignPropertiesToTerminateNotificationProfile_Status & AssignPropertiesFromTerminateNotificationProfile_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForTerminateNotificationProfile_Status, TerminateNotificationProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTerminateNotificationProfile_Status tests if a specific instance of TerminateNotificationProfile_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForTerminateNotificationProfile_Status(subject TerminateNotificationProfile_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.TerminateNotificationProfile_Status
	err := copied.AssignPropertiesToTerminateNotificationProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TerminateNotificationProfile_Status
	err = actual.AssignPropertiesFromTerminateNotificationProfile_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TerminateNotificationProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TerminateNotificationProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTerminateNotificationProfile_Status, TerminateNotificationProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTerminateNotificationProfile_Status runs a test to see if a specific instance of TerminateNotificationProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForTerminateNotificationProfile_Status(subject TerminateNotificationProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TerminateNotificationProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TerminateNotificationProfile_Status instances for property testing - lazily instantiated by
//TerminateNotificationProfile_StatusGenerator()
var terminateNotificationProfile_statusGenerator gopter.Gen

// TerminateNotificationProfile_StatusGenerator returns a generator of TerminateNotificationProfile_Status instances for property testing.
func TerminateNotificationProfile_StatusGenerator() gopter.Gen {
	if terminateNotificationProfile_statusGenerator != nil {
		return terminateNotificationProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Status(generators)
	terminateNotificationProfile_statusGenerator = gen.Struct(reflect.TypeOf(TerminateNotificationProfile_Status{}), generators)

	return terminateNotificationProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTerminateNotificationProfile_Status(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
	gens["NotBeforeTimeout"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetDataDisk_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetDataDisk to VirtualMachineScaleSetDataDisk via AssignPropertiesToVirtualMachineScaleSetDataDisk & AssignPropertiesFromVirtualMachineScaleSetDataDisk returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk, VirtualMachineScaleSetDataDiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk tests if a specific instance of VirtualMachineScaleSetDataDisk can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk(subject VirtualMachineScaleSetDataDisk) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk
	err := copied.AssignPropertiesToVirtualMachineScaleSetDataDisk(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetDataDisk
	err = actual.AssignPropertiesFromVirtualMachineScaleSetDataDisk(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetDataDisk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetDataDisk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetDataDisk, VirtualMachineScaleSetDataDiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetDataDisk runs a test to see if a specific instance of VirtualMachineScaleSetDataDisk round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetDataDisk(subject VirtualMachineScaleSetDataDisk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetDataDisk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetDataDisk instances for property testing - lazily instantiated by
//VirtualMachineScaleSetDataDiskGenerator()
var virtualMachineScaleSetDataDiskGenerator gopter.Gen

// VirtualMachineScaleSetDataDiskGenerator returns a generator of VirtualMachineScaleSetDataDisk instances for property testing.
// We first initialize virtualMachineScaleSetDataDiskGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetDataDiskGenerator() gopter.Gen {
	if virtualMachineScaleSetDataDiskGenerator != nil {
		return virtualMachineScaleSetDataDiskGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk(generators)
	virtualMachineScaleSetDataDiskGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetDataDisk{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk(generators)
	virtualMachineScaleSetDataDiskGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetDataDisk{}), generators)

	return virtualMachineScaleSetDataDiskGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(CachingNone, CachingReadOnly, CachingReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOptionAttach, CreateOptionEmpty, CreateOptionFromImage)
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk(gens map[string]gopter.Gen) {
	gens["ManagedDisk"] = gen.PtrOf(VirtualMachineScaleSetManagedDiskParametersGenerator())
}

func Test_VirtualMachineScaleSetDataDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetDataDisk_Status to VirtualMachineScaleSetDataDisk_Status via AssignPropertiesToVirtualMachineScaleSetDataDisk_Status & AssignPropertiesFromVirtualMachineScaleSetDataDisk_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Status, VirtualMachineScaleSetDataDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Status tests if a specific instance of VirtualMachineScaleSetDataDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetDataDisk_Status(subject VirtualMachineScaleSetDataDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetDataDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetDataDisk_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetDataDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetDataDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetDataDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Status, VirtualMachineScaleSetDataDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Status runs a test to see if a specific instance of VirtualMachineScaleSetDataDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetDataDisk_Status(subject VirtualMachineScaleSetDataDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetDataDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetDataDisk_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetDataDisk_StatusGenerator()
var virtualMachineScaleSetDataDisk_statusGenerator gopter.Gen

// VirtualMachineScaleSetDataDisk_StatusGenerator returns a generator of VirtualMachineScaleSetDataDisk_Status instances for property testing.
// We first initialize virtualMachineScaleSetDataDisk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetDataDisk_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetDataDisk_statusGenerator != nil {
		return virtualMachineScaleSetDataDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(generators)
	virtualMachineScaleSetDataDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetDataDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(generators)
	virtualMachineScaleSetDataDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetDataDisk_Status{}), generators)

	return virtualMachineScaleSetDataDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.AlphaString()
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetDataDisk_Status(gens map[string]gopter.Gen) {
	gens["ManagedDisk"] = gen.PtrOf(VirtualMachineScaleSetManagedDiskParameters_StatusGenerator())
}

func Test_VirtualMachineScaleSetExtension_Status_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetExtension_Status_SubResourceEmbedded to VirtualMachineScaleSetExtension_Status_SubResourceEmbedded via AssignPropertiesToVirtualMachineScaleSetExtension_Status_SubResourceEmbedded & AssignPropertiesFromVirtualMachineScaleSetExtension_Status_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded, VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded tests if a specific instance of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(subject VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
	err := copied.AssignPropertiesToVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
	err = actual.AssignPropertiesFromVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetExtension_Status_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded, VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded runs a test to see if a specific instance of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(subject VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded instances for property testing - lazily
//instantiated by VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator()
var virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator gopter.Gen

// VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator returns a generator of VirtualMachineScaleSetExtension_Status_SubResourceEmbedded instances for property testing.
func VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedGenerator() gopter.Gen {
	if virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator != nil {
		return virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(generators)
	virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetExtension_Status_SubResourceEmbedded{}), generators)

	return virtualMachineScaleSetExtension_status_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetExtension_Status_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetNetworkConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkConfiguration to VirtualMachineScaleSetNetworkConfiguration via AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration & AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration, VirtualMachineScaleSetNetworkConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration tests if a specific instance of VirtualMachineScaleSetNetworkConfiguration can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration(subject VirtualMachineScaleSetNetworkConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkConfiguration
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration, VirtualMachineScaleSetNetworkConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration runs a test to see if a specific instance of VirtualMachineScaleSetNetworkConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration(subject VirtualMachineScaleSetNetworkConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkConfiguration instances for property testing - lazily instantiated by
//VirtualMachineScaleSetNetworkConfigurationGenerator()
var virtualMachineScaleSetNetworkConfigurationGenerator gopter.Gen

// VirtualMachineScaleSetNetworkConfigurationGenerator returns a generator of VirtualMachineScaleSetNetworkConfiguration instances for property testing.
// We first initialize virtualMachineScaleSetNetworkConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetNetworkConfigurationGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkConfigurationGenerator != nil {
		return virtualMachineScaleSetNetworkConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration(generators)
	virtualMachineScaleSetNetworkConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration(generators)
	virtualMachineScaleSetNetworkConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfiguration{}), generators)

	return virtualMachineScaleSetNetworkConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableFpga"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualMachineScaleSetIPConfigurationGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(SubResourceGenerator())
}

func Test_VirtualMachineScaleSetNetworkConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkConfiguration_Status to VirtualMachineScaleSetNetworkConfiguration_Status via AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_Status & AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Status, VirtualMachineScaleSetNetworkConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Status tests if a specific instance of VirtualMachineScaleSetNetworkConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfiguration_Status(subject VirtualMachineScaleSetNetworkConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkConfiguration_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Status, VirtualMachineScaleSetNetworkConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Status runs a test to see if a specific instance of VirtualMachineScaleSetNetworkConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfiguration_Status(subject VirtualMachineScaleSetNetworkConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkConfiguration_Status instances for property testing - lazily instantiated
//by VirtualMachineScaleSetNetworkConfiguration_StatusGenerator()
var virtualMachineScaleSetNetworkConfiguration_statusGenerator gopter.Gen

// VirtualMachineScaleSetNetworkConfiguration_StatusGenerator returns a generator of VirtualMachineScaleSetNetworkConfiguration_Status instances for property testing.
// We first initialize virtualMachineScaleSetNetworkConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetNetworkConfiguration_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkConfiguration_statusGenerator != nil {
		return virtualMachineScaleSetNetworkConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(generators)
	virtualMachineScaleSetNetworkConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(generators)
	virtualMachineScaleSetNetworkConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfiguration_Status{}), generators)

	return virtualMachineScaleSetNetworkConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(gens map[string]gopter.Gen) {
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableFpga"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetNetworkConfiguration_Status(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualMachineScaleSetIPConfiguration_StatusGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_VirtualMachineScaleSetOSDisk_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetOSDisk to VirtualMachineScaleSetOSDisk via AssignPropertiesToVirtualMachineScaleSetOSDisk & AssignPropertiesFromVirtualMachineScaleSetOSDisk returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk, VirtualMachineScaleSetOSDiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk tests if a specific instance of VirtualMachineScaleSetOSDisk can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk(subject VirtualMachineScaleSetOSDisk) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk
	err := copied.AssignPropertiesToVirtualMachineScaleSetOSDisk(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetOSDisk
	err = actual.AssignPropertiesFromVirtualMachineScaleSetOSDisk(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetOSDisk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetOSDisk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetOSDisk, VirtualMachineScaleSetOSDiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetOSDisk runs a test to see if a specific instance of VirtualMachineScaleSetOSDisk round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetOSDisk(subject VirtualMachineScaleSetOSDisk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetOSDisk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetOSDisk instances for property testing - lazily instantiated by
//VirtualMachineScaleSetOSDiskGenerator()
var virtualMachineScaleSetOSDiskGenerator gopter.Gen

// VirtualMachineScaleSetOSDiskGenerator returns a generator of VirtualMachineScaleSetOSDisk instances for property testing.
// We first initialize virtualMachineScaleSetOSDiskGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetOSDiskGenerator() gopter.Gen {
	if virtualMachineScaleSetOSDiskGenerator != nil {
		return virtualMachineScaleSetOSDiskGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk(generators)
	virtualMachineScaleSetOSDiskGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSDisk{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk(generators)
	virtualMachineScaleSetOSDiskGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSDisk{}), generators)

	return virtualMachineScaleSetOSDiskGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(CachingNone, CachingReadOnly, CachingReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOptionAttach, CreateOptionEmpty, CreateOptionFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetOSDiskOsTypeLinux, VirtualMachineScaleSetOSDiskOsTypeWindows))
	gens["VhdContainers"] = gen.SliceOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskGenerator())
	gens["ManagedDisk"] = gen.PtrOf(VirtualMachineScaleSetManagedDiskParametersGenerator())
}

func Test_VirtualMachineScaleSetOSDisk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetOSDisk_Status to VirtualMachineScaleSetOSDisk_Status via AssignPropertiesToVirtualMachineScaleSetOSDisk_Status & AssignPropertiesFromVirtualMachineScaleSetOSDisk_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Status, VirtualMachineScaleSetOSDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Status tests if a specific instance of VirtualMachineScaleSetOSDisk_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetOSDisk_Status(subject VirtualMachineScaleSetOSDisk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetOSDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetOSDisk_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetOSDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetOSDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetOSDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Status, VirtualMachineScaleSetOSDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Status runs a test to see if a specific instance of VirtualMachineScaleSetOSDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetOSDisk_Status(subject VirtualMachineScaleSetOSDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetOSDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetOSDisk_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetOSDisk_StatusGenerator()
var virtualMachineScaleSetOSDisk_statusGenerator gopter.Gen

// VirtualMachineScaleSetOSDisk_StatusGenerator returns a generator of VirtualMachineScaleSetOSDisk_Status instances for property testing.
// We first initialize virtualMachineScaleSetOSDisk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetOSDisk_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetOSDisk_statusGenerator != nil {
		return virtualMachineScaleSetOSDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(generators)
	virtualMachineScaleSetOSDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(generators)
	virtualMachineScaleSetOSDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetOSDisk_Status{}), generators)

	return virtualMachineScaleSetOSDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.AlphaString()
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["VhdContainers"] = gen.SliceOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetOSDisk_Status(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_StatusGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(VirtualMachineScaleSetManagedDiskParameters_StatusGenerator())
}

func Test_VirtualMachineScaleSetIPConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIPConfiguration to VirtualMachineScaleSetIPConfiguration via AssignPropertiesToVirtualMachineScaleSetIPConfiguration & AssignPropertiesFromVirtualMachineScaleSetIPConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration, VirtualMachineScaleSetIPConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration tests if a specific instance of VirtualMachineScaleSetIPConfiguration can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration(subject VirtualMachineScaleSetIPConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration
	err := copied.AssignPropertiesToVirtualMachineScaleSetIPConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIPConfiguration
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIPConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIPConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIPConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration, VirtualMachineScaleSetIPConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration runs a test to see if a specific instance of VirtualMachineScaleSetIPConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration(subject VirtualMachineScaleSetIPConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIPConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIPConfiguration instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIPConfigurationGenerator()
var virtualMachineScaleSetIPConfigurationGenerator gopter.Gen

// VirtualMachineScaleSetIPConfigurationGenerator returns a generator of VirtualMachineScaleSetIPConfiguration instances for property testing.
// We first initialize virtualMachineScaleSetIPConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetIPConfigurationGenerator() gopter.Gen {
	if virtualMachineScaleSetIPConfigurationGenerator != nil {
		return virtualMachineScaleSetIPConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration(generators)
	virtualMachineScaleSetIPConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIPConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration(generators)
	virtualMachineScaleSetIPConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIPConfiguration{}), generators)

	return virtualMachineScaleSetIPConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetIPConfigurationPropertiesPrivateIPAddressVersionIPv4, VirtualMachineScaleSetIPConfigurationPropertiesPrivateIPAddressVersionIPv6))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(SubResourceGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(SubResourceGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(SubResourceGenerator())
	gens["LoadBalancerInboundNatPools"] = gen.SliceOf(SubResourceGenerator())
	gens["PublicIPAddressConfiguration"] = gen.PtrOf(VirtualMachineScaleSetPublicIPAddressConfigurationGenerator())
	gens["Subnet"] = gen.PtrOf(ApiEntityReferenceGenerator())
}

func Test_VirtualMachineScaleSetIPConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIPConfiguration_Status to VirtualMachineScaleSetIPConfiguration_Status via AssignPropertiesToVirtualMachineScaleSetIPConfiguration_Status & AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Status, VirtualMachineScaleSetIPConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Status tests if a specific instance of VirtualMachineScaleSetIPConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIPConfiguration_Status(subject VirtualMachineScaleSetIPConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetIPConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIPConfiguration_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIPConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIPConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Status, VirtualMachineScaleSetIPConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Status runs a test to see if a specific instance of VirtualMachineScaleSetIPConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIPConfiguration_Status(subject VirtualMachineScaleSetIPConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIPConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIPConfiguration_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIPConfiguration_StatusGenerator()
var virtualMachineScaleSetIPConfiguration_statusGenerator gopter.Gen

// VirtualMachineScaleSetIPConfiguration_StatusGenerator returns a generator of VirtualMachineScaleSetIPConfiguration_Status instances for property testing.
// We first initialize virtualMachineScaleSetIPConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetIPConfiguration_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetIPConfiguration_statusGenerator != nil {
		return virtualMachineScaleSetIPConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(generators)
	virtualMachineScaleSetIPConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIPConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(generators)
	virtualMachineScaleSetIPConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIPConfiguration_Status{}), generators)

	return virtualMachineScaleSetIPConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetIPConfiguration_Status(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["LoadBalancerInboundNatPools"] = gen.SliceOf(SubResource_StatusGenerator())
	gens["PublicIPAddressConfiguration"] = gen.PtrOf(VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator())
	gens["Subnet"] = gen.PtrOf(ApiEntityReference_StatusGenerator())
}

func Test_VirtualMachineScaleSetManagedDiskParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetManagedDiskParameters to VirtualMachineScaleSetManagedDiskParameters via AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters & AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters, VirtualMachineScaleSetManagedDiskParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters tests if a specific instance of VirtualMachineScaleSetManagedDiskParameters can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters(subject VirtualMachineScaleSetManagedDiskParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters
	err := copied.AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetManagedDiskParameters
	err = actual.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetManagedDiskParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetManagedDiskParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters, VirtualMachineScaleSetManagedDiskParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters runs a test to see if a specific instance of VirtualMachineScaleSetManagedDiskParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters(subject VirtualMachineScaleSetManagedDiskParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetManagedDiskParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetManagedDiskParameters instances for property testing - lazily instantiated by
//VirtualMachineScaleSetManagedDiskParametersGenerator()
var virtualMachineScaleSetManagedDiskParametersGenerator gopter.Gen

// VirtualMachineScaleSetManagedDiskParametersGenerator returns a generator of VirtualMachineScaleSetManagedDiskParameters instances for property testing.
// We first initialize virtualMachineScaleSetManagedDiskParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetManagedDiskParametersGenerator() gopter.Gen {
	if virtualMachineScaleSetManagedDiskParametersGenerator != nil {
		return virtualMachineScaleSetManagedDiskParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters(generators)
	virtualMachineScaleSetManagedDiskParametersGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetManagedDiskParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters(generators)
	virtualMachineScaleSetManagedDiskParametersGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetManagedDiskParameters{}), generators)

	return virtualMachineScaleSetManagedDiskParametersGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountTypePremium_LRS,
		StorageAccountTypePremium_ZRS,
		StorageAccountTypeStandardSSD_LRS,
		StorageAccountTypeStandardSSD_ZRS,
		StorageAccountTypeStandard_LRS,
		StorageAccountTypeUltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceGenerator())
}

func Test_VirtualMachineScaleSetManagedDiskParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetManagedDiskParameters_Status to VirtualMachineScaleSetManagedDiskParameters_Status via AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_Status & AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Status, VirtualMachineScaleSetManagedDiskParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Status tests if a specific instance of VirtualMachineScaleSetManagedDiskParameters_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetManagedDiskParameters_Status(subject VirtualMachineScaleSetManagedDiskParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetManagedDiskParameters_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetManagedDiskParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetManagedDiskParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Status, VirtualMachineScaleSetManagedDiskParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Status runs a test to see if a specific instance of VirtualMachineScaleSetManagedDiskParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetManagedDiskParameters_Status(subject VirtualMachineScaleSetManagedDiskParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetManagedDiskParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetManagedDiskParameters_Status instances for property testing - lazily instantiated
//by VirtualMachineScaleSetManagedDiskParameters_StatusGenerator()
var virtualMachineScaleSetManagedDiskParameters_statusGenerator gopter.Gen

// VirtualMachineScaleSetManagedDiskParameters_StatusGenerator returns a generator of VirtualMachineScaleSetManagedDiskParameters_Status instances for property testing.
// We first initialize virtualMachineScaleSetManagedDiskParameters_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetManagedDiskParameters_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetManagedDiskParameters_statusGenerator != nil {
		return virtualMachineScaleSetManagedDiskParameters_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(generators)
	virtualMachineScaleSetManagedDiskParameters_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetManagedDiskParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(generators)
	virtualMachineScaleSetManagedDiskParameters_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetManagedDiskParameters_Status{}), generators)

	return virtualMachineScaleSetManagedDiskParameters_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetManagedDiskParameters_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_VirtualMachineScaleSetNetworkConfigurationDnsSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkConfigurationDnsSettings to VirtualMachineScaleSetNetworkConfigurationDnsSettings via AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings & AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings, VirtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings tests if a specific instance of VirtualMachineScaleSetNetworkConfigurationDnsSettings can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings(subject VirtualMachineScaleSetNetworkConfigurationDnsSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkConfigurationDnsSettings
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkConfigurationDnsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkConfigurationDnsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings, VirtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings runs a test to see if a specific instance of VirtualMachineScaleSetNetworkConfigurationDnsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings(subject VirtualMachineScaleSetNetworkConfigurationDnsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkConfigurationDnsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkConfigurationDnsSettings instances for property testing - lazily
//instantiated by VirtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator()
var virtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator gopter.Gen

// VirtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator returns a generator of VirtualMachineScaleSetNetworkConfigurationDnsSettings instances for property testing.
func VirtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator != nil {
		return virtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings(generators)
	virtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfigurationDnsSettings{}), generators)

	return virtualMachineScaleSetNetworkConfigurationDnsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status to VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status via AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status & AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status, VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status tests if a specific instance of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(subject VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status, VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status runs a test to see if a specific instance of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(subject VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status instances for property testing - lazily
//instantiated by VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator()
var virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator gopter.Gen

// VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator returns a generator of VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status instances for property testing.
func VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator != nil {
		return virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(generators)
	virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status{}), generators)

	return virtualMachineScaleSetNetworkConfigurationDnsSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetNetworkConfigurationDnsSettings_Status(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetPublicIPAddressConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetPublicIPAddressConfiguration to VirtualMachineScaleSetPublicIPAddressConfiguration via AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration & AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration, VirtualMachineScaleSetPublicIPAddressConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration tests if a specific instance of VirtualMachineScaleSetPublicIPAddressConfiguration can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration(subject VirtualMachineScaleSetPublicIPAddressConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration
	err := copied.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetPublicIPAddressConfiguration
	err = actual.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetPublicIPAddressConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetPublicIPAddressConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration, VirtualMachineScaleSetPublicIPAddressConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration runs a test to see if a specific instance of VirtualMachineScaleSetPublicIPAddressConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration(subject VirtualMachineScaleSetPublicIPAddressConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetPublicIPAddressConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetPublicIPAddressConfiguration instances for property testing - lazily instantiated
//by VirtualMachineScaleSetPublicIPAddressConfigurationGenerator()
var virtualMachineScaleSetPublicIPAddressConfigurationGenerator gopter.Gen

// VirtualMachineScaleSetPublicIPAddressConfigurationGenerator returns a generator of VirtualMachineScaleSetPublicIPAddressConfiguration instances for property testing.
// We first initialize virtualMachineScaleSetPublicIPAddressConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetPublicIPAddressConfigurationGenerator() gopter.Gen {
	if virtualMachineScaleSetPublicIPAddressConfigurationGenerator != nil {
		return virtualMachineScaleSetPublicIPAddressConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration(generators)
	virtualMachineScaleSetPublicIPAddressConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration(generators)
	virtualMachineScaleSetPublicIPAddressConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfiguration{}), generators)

	return virtualMachineScaleSetPublicIPAddressConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.AlphaString()
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersionIPv4, VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersionIPv6))
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator())
	gens["IpTags"] = gen.SliceOf(VirtualMachineScaleSetIpTagGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceGenerator())
}

func Test_VirtualMachineScaleSetPublicIPAddressConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetPublicIPAddressConfiguration_Status to VirtualMachineScaleSetPublicIPAddressConfiguration_Status via AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_Status & AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status, VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status tests if a specific instance of VirtualMachineScaleSetPublicIPAddressConfiguration_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(subject VirtualMachineScaleSetPublicIPAddressConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetPublicIPAddressConfiguration_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetPublicIPAddressConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetPublicIPAddressConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status, VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status runs a test to see if a specific instance of VirtualMachineScaleSetPublicIPAddressConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(subject VirtualMachineScaleSetPublicIPAddressConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetPublicIPAddressConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetPublicIPAddressConfiguration_Status instances for property testing - lazily
//instantiated by VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator()
var virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator gopter.Gen

// VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator returns a generator of VirtualMachineScaleSetPublicIPAddressConfiguration_Status instances for property testing.
// We first initialize virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineScaleSetPublicIPAddressConfiguration_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator != nil {
		return virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(generators)
	virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(generators)
	virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfiguration_Status{}), generators)

	return virtualMachineScaleSetPublicIPAddressConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(gens map[string]gopter.Gen) {
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.AlphaString()
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfiguration_Status(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator())
	gens["IpTags"] = gen.SliceOf(VirtualMachineScaleSetIpTag_StatusGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_VirtualMachineScaleSetIpTag_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIpTag to VirtualMachineScaleSetIpTag via AssignPropertiesToVirtualMachineScaleSetIpTag & AssignPropertiesFromVirtualMachineScaleSetIpTag returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag, VirtualMachineScaleSetIpTagGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag tests if a specific instance of VirtualMachineScaleSetIpTag can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag(subject VirtualMachineScaleSetIpTag) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIpTag
	err := copied.AssignPropertiesToVirtualMachineScaleSetIpTag(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIpTag
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIpTag(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIpTag_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIpTag via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIpTag, VirtualMachineScaleSetIpTagGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIpTag runs a test to see if a specific instance of VirtualMachineScaleSetIpTag round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIpTag(subject VirtualMachineScaleSetIpTag) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIpTag
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIpTag instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIpTagGenerator()
var virtualMachineScaleSetIpTagGenerator gopter.Gen

// VirtualMachineScaleSetIpTagGenerator returns a generator of VirtualMachineScaleSetIpTag instances for property testing.
func VirtualMachineScaleSetIpTagGenerator() gopter.Gen {
	if virtualMachineScaleSetIpTagGenerator != nil {
		return virtualMachineScaleSetIpTagGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag(generators)
	virtualMachineScaleSetIpTagGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIpTag{}), generators)

	return virtualMachineScaleSetIpTagGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetIpTag_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetIpTag_Status to VirtualMachineScaleSetIpTag_Status via AssignPropertiesToVirtualMachineScaleSetIpTag_Status & AssignPropertiesFromVirtualMachineScaleSetIpTag_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Status, VirtualMachineScaleSetIpTag_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Status tests if a specific instance of VirtualMachineScaleSetIpTag_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetIpTag_Status(subject VirtualMachineScaleSetIpTag_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetIpTag_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetIpTag_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetIpTag_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetIpTag_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetIpTag_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Status, VirtualMachineScaleSetIpTag_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Status runs a test to see if a specific instance of VirtualMachineScaleSetIpTag_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetIpTag_Status(subject VirtualMachineScaleSetIpTag_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetIpTag_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetIpTag_Status instances for property testing - lazily instantiated by
//VirtualMachineScaleSetIpTag_StatusGenerator()
var virtualMachineScaleSetIpTag_statusGenerator gopter.Gen

// VirtualMachineScaleSetIpTag_StatusGenerator returns a generator of VirtualMachineScaleSetIpTag_Status instances for property testing.
func VirtualMachineScaleSetIpTag_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetIpTag_statusGenerator != nil {
		return virtualMachineScaleSetIpTag_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Status(generators)
	virtualMachineScaleSetIpTag_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetIpTag_Status{}), generators)

	return virtualMachineScaleSetIpTag_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetIpTag_Status(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings to VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings via AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings & AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings, VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings tests if a specific instance of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(subject VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
	err := copied.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
	err = actual.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings, VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings runs a test to see if a specific instance of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(subject VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings instances for property testing - lazily
//instantiated by VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator()
var virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator gopter.Gen

// VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator returns a generator of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings instances for property testing.
func VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator() gopter.Gen {
	if virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator != nil {
		return virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(generators)
	virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings{}), generators)

	return virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.AlphaString()
}

func Test_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status to VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status via AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status & AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status, VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status tests if a specific instance of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(subject VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
	err := copied.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
	err = actual.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status, VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status runs a test to see if a specific instance of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(subject VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status instances for property testing -
//lazily instantiated by VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator()
var virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator gopter.Gen

// VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator returns a generator of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status instances for property testing.
func VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusGenerator() gopter.Gen {
	if virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator != nil {
		return virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(generators)
	virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status{}), generators)

	return virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.AlphaString()
}
