// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
type VirtualMachineScaleSet struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachineScaleSets_SPEC  `json:"spec,omitempty"`
	Status            VirtualMachineScaleSet_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachineScaleSet{}

// GetConditions returns the conditions of the resource
func (scaleSet *VirtualMachineScaleSet) GetConditions() conditions.Conditions {
	return scaleSet.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (scaleSet *VirtualMachineScaleSet) SetConditions(conditions conditions.Conditions) {
	scaleSet.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachineScaleSet{}

// ConvertFrom populates our VirtualMachineScaleSet from the provided hub VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v1alpha1api20201201storage.VirtualMachineScaleSet)
	if !ok {
		return fmt.Errorf("expected storage:compute/v1alpha1api20201201storage/VirtualMachineScaleSet but received %T instead", hub)
	}

	return scaleSet.AssignPropertiesFromVirtualMachineScaleSet(source)
}

// ConvertTo populates the provided hub VirtualMachineScaleSet from our VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v1alpha1api20201201storage.VirtualMachineScaleSet)
	if !ok {
		return fmt.Errorf("expected storage:compute/v1alpha1api20201201storage/VirtualMachineScaleSet but received %T instead", hub)
	}

	return scaleSet.AssignPropertiesToVirtualMachineScaleSet(destination)
}

// +kubebuilder:webhook:path=/mutate-compute-azure-com-v1alpha1api20201201-virtualmachinescaleset,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachinescalesets,verbs=create;update,versions=v1alpha1api20201201,name=default.v1alpha1api20201201.virtualmachinescalesets.compute.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &VirtualMachineScaleSet{}

// Default applies defaults to the VirtualMachineScaleSet resource
func (scaleSet *VirtualMachineScaleSet) Default() {
	scaleSet.defaultImpl()
	var temp interface{} = scaleSet
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (scaleSet *VirtualMachineScaleSet) defaultAzureName() {
	if scaleSet.Spec.AzureName == "" {
		scaleSet.Spec.AzureName = scaleSet.Name
	}
}

// defaultImpl applies the code generated defaults to the VirtualMachineScaleSet resource
func (scaleSet *VirtualMachineScaleSet) defaultImpl() { scaleSet.defaultAzureName() }

var _ genruntime.KubernetesResource = &VirtualMachineScaleSet{}

// AzureName returns the Azure name of the resource
func (scaleSet *VirtualMachineScaleSet) AzureName() string {
	return scaleSet.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-12-01"
func (scaleSet VirtualMachineScaleSet) GetAPIVersion() string {
	return "2020-12-01"
}

// GetResourceKind returns the kind of the resource
func (scaleSet *VirtualMachineScaleSet) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (scaleSet *VirtualMachineScaleSet) GetSpec() genruntime.ConvertibleSpec {
	return &scaleSet.Spec
}

// GetStatus returns the status of this resource
func (scaleSet *VirtualMachineScaleSet) GetStatus() genruntime.ConvertibleStatus {
	return &scaleSet.Status
}

// GetType returns the ARM Type of the resource. This is always ""
func (scaleSet *VirtualMachineScaleSet) GetType() string {
	return ""
}

// NewEmptyStatus returns a new empty (blank) status
func (scaleSet *VirtualMachineScaleSet) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachineScaleSet_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (scaleSet *VirtualMachineScaleSet) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(scaleSet.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  scaleSet.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (scaleSet *VirtualMachineScaleSet) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachineScaleSet_Status); ok {
		scaleSet.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachineScaleSet_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	scaleSet.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-compute-azure-com-v1alpha1api20201201-virtualmachinescaleset,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachinescalesets,verbs=create;update,versions=v1alpha1api20201201,name=validate.v1alpha1api20201201.virtualmachinescalesets.compute.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &VirtualMachineScaleSet{}

// ValidateCreate validates the creation of the resource
func (scaleSet *VirtualMachineScaleSet) ValidateCreate() error {
	validations := scaleSet.createValidations()
	var temp interface{} = scaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (scaleSet *VirtualMachineScaleSet) ValidateDelete() error {
	validations := scaleSet.deleteValidations()
	var temp interface{} = scaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (scaleSet *VirtualMachineScaleSet) ValidateUpdate(old runtime.Object) error {
	validations := scaleSet.updateValidations()
	var temp interface{} = scaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (scaleSet *VirtualMachineScaleSet) createValidations() []func() error {
	return []func() error{scaleSet.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (scaleSet *VirtualMachineScaleSet) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (scaleSet *VirtualMachineScaleSet) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return scaleSet.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (scaleSet *VirtualMachineScaleSet) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&scaleSet.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromVirtualMachineScaleSet populates our VirtualMachineScaleSet from the provided source VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) AssignPropertiesFromVirtualMachineScaleSet(source *v1alpha1api20201201storage.VirtualMachineScaleSet) error {

	// ObjectMeta
	scaleSet.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachineScaleSets_SPEC
	err := spec.AssignPropertiesFromVirtualMachineScaleSetsSPEC(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetsSPEC() to populate field Spec")
	}
	scaleSet.Spec = spec

	// Status
	var status VirtualMachineScaleSet_Status
	err = status.AssignPropertiesFromVirtualMachineScaleSetStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetStatus() to populate field Status")
	}
	scaleSet.Status = status

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSet populates the provided destination VirtualMachineScaleSet from our VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) AssignPropertiesToVirtualMachineScaleSet(destination *v1alpha1api20201201storage.VirtualMachineScaleSet) error {

	// ObjectMeta
	destination.ObjectMeta = *scaleSet.ObjectMeta.DeepCopy()

	// Spec
	var spec v1alpha1api20201201storage.VirtualMachineScaleSets_SPEC
	err := scaleSet.Spec.AssignPropertiesToVirtualMachineScaleSetsSPEC(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetsSPEC() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20201201storage.VirtualMachineScaleSet_Status
	err = scaleSet.Status.AssignPropertiesToVirtualMachineScaleSetStatus(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetStatus() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (scaleSet *VirtualMachineScaleSet) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: scaleSet.Spec.OriginalVersion(),
		Kind:    "VirtualMachineScaleSet",
	}
}

// +kubebuilder:object:root=true
type VirtualMachineScaleSetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachineScaleSet `json:"items"`
}

type VirtualMachineScaleSet_Status struct {
	//AdditionalCapabilities: Specifies additional capabilities enabled or disabled on
	//the Virtual Machines in the Virtual Machine Scale Set. For instance: whether the
	//Virtual Machines have the capability to support attaching managed data disks
	//with UltraSSD_LRS storage account type.
	AdditionalCapabilities *AdditionalCapabilities_Status `json:"additionalCapabilities,omitempty"`

	//AutomaticRepairsPolicy: Policy for automatic repairs.
	AutomaticRepairsPolicy *AutomaticRepairsPolicy_Status `json:"automaticRepairsPolicy,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//DoNotRunExtensionsOnOverprovisionedVMs: When Overprovision is enabled,
	//extensions are launched only on the requested number of VMs which are finally
	//kept. This property will hence ensure that the extensions do not run on the
	//extra overprovisioned VMs.
	DoNotRunExtensionsOnOverprovisionedVMs *bool `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`

	//ExtendedLocation: The extended location of the Virtual Machine Scale Set.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//HostGroup: Specifies information about the dedicated host group that the virtual
	//machine scale set resides in.
	//Minimum api-version: 2020-06-01.
	HostGroup *SubResource_Status `json:"hostGroup,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Identity: The identity of the virtual machine scale set, if configured.
	Identity *VirtualMachineScaleSetIdentity_Status `json:"identity,omitempty"`

	//Location: Resource location
	Location *string `json:"location,omitempty"`

	//Name: Resource name
	Name *string `json:"name,omitempty"`

	//OrchestrationMode: Specifies the orchestration mode for the virtual machine
	//scale set.
	OrchestrationMode *OrchestrationMode_Status `json:"orchestrationMode,omitempty"`

	//Overprovision: Specifies whether the Virtual Machine Scale Set should be
	//overprovisioned.
	Overprovision *bool `json:"overprovision,omitempty"`

	//Plan: Specifies information about the marketplace image used to create the
	//virtual machine. This element is only used for marketplace images. Before you
	//can use a marketplace image from an API, you must enable the image for
	//programmatic use.  In the Azure portal, find the marketplace image that you want
	//to use and then click Want to deploy programmatically, Get Started ->. Enter any
	//required information and then click Save.
	Plan *Plan_Status `json:"plan,omitempty"`

	//PlatformFaultDomainCount: Fault Domain count for each placement group.
	PlatformFaultDomainCount *int `json:"platformFaultDomainCount,omitempty"`

	//ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//ProximityPlacementGroup: Specifies information about the proximity placement
	//group that the virtual machine scale set should be assigned to.
	//Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource_Status `json:"proximityPlacementGroup,omitempty"`

	//ScaleInPolicy: Specifies the scale-in policy that decides which virtual machines
	//are chosen for removal when a Virtual Machine Scale Set is scaled-in.
	ScaleInPolicy *ScaleInPolicy_Status `json:"scaleInPolicy,omitempty"`

	//SinglePlacementGroup: When true this limits the scale set to a single placement
	//group, of max size 100 virtual machines. NOTE: If singlePlacementGroup is true,
	//it may be modified to false. However, if singlePlacementGroup is false, it may
	//not be modified to true.
	SinglePlacementGroup *bool `json:"singlePlacementGroup,omitempty"`

	//Sku: The virtual machine scale set sku.
	Sku *Sku_Status `json:"sku,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type
	Type *string `json:"type,omitempty"`

	//UniqueId: Specifies the ID which uniquely identifies a Virtual Machine Scale Set.
	UniqueId *string `json:"uniqueId,omitempty"`

	//UpgradePolicy: The upgrade policy.
	UpgradePolicy *UpgradePolicy_Status `json:"upgradePolicy,omitempty"`

	//VirtualMachineProfile: The virtual machine profile.
	VirtualMachineProfile *VirtualMachineScaleSetVMProfile_Status `json:"virtualMachineProfile,omitempty"`

	//ZoneBalance: Whether to force strictly even Virtual Machine distribution cross
	//x-zones in case there is zone outage.
	ZoneBalance *bool `json:"zoneBalance,omitempty"`

	//Zones: The virtual machine scale set zones. NOTE: Availability zones can only be
	//set when you create the scale set
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachineScaleSet_Status{}

// ConvertStatusFrom populates our VirtualMachineScaleSet_Status from the provided source
func (scaleSet *VirtualMachineScaleSet_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20201201storage.VirtualMachineScaleSet_Status)
	if ok {
		// Populate our instance from source
		return scaleSet.AssignPropertiesFromVirtualMachineScaleSetStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201201storage.VirtualMachineScaleSet_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = scaleSet.AssignPropertiesFromVirtualMachineScaleSetStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachineScaleSet_Status
func (scaleSet *VirtualMachineScaleSet_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20201201storage.VirtualMachineScaleSet_Status)
	if ok {
		// Populate destination from our instance
		return scaleSet.AssignPropertiesToVirtualMachineScaleSetStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201201storage.VirtualMachineScaleSet_Status{}
	err := scaleSet.AssignPropertiesToVirtualMachineScaleSetStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSet_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaleSet *VirtualMachineScaleSet_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSet_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaleSet *VirtualMachineScaleSet_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSet_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSet_StatusARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities_Status
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			scaleSet.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property ‘AutomaticRepairsPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticRepairsPolicy != nil {
			var automaticRepairsPolicy1 AutomaticRepairsPolicy_Status
			err := automaticRepairsPolicy1.PopulateFromARM(owner, *typedInput.Properties.AutomaticRepairsPolicy)
			if err != nil {
				return err
			}
			automaticRepairsPolicy := automaticRepairsPolicy1
			scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DoNotRunExtensionsOnOverprovisionedVMs’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs != nil {
			doNotRunExtensionsOnOverprovisionedVMs := *typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs
			scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		scaleSet.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource_Status
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			scaleSet.HostGroup = &hostGroup
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		scaleSet.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineScaleSetIdentity_Status
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		scaleSet.Identity = &identity
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		scaleSet.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		scaleSet.Name = &name
	}

	// Set property ‘OrchestrationMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OrchestrationMode != nil {
			orchestrationMode := *typedInput.Properties.OrchestrationMode
			scaleSet.OrchestrationMode = &orchestrationMode
		}
	}

	// Set property ‘Overprovision’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Overprovision != nil {
			overprovision := *typedInput.Properties.Overprovision
			scaleSet.Overprovision = &overprovision
		}
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan_Status
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		scaleSet.Plan = &plan
	}

	// Set property ‘PlatformFaultDomainCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomainCount != nil {
			platformFaultDomainCount := *typedInput.Properties.PlatformFaultDomainCount
			scaleSet.PlatformFaultDomainCount = &platformFaultDomainCount
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			scaleSet.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource_Status
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property ‘ScaleInPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScaleInPolicy != nil {
			var scaleInPolicy1 ScaleInPolicy_Status
			err := scaleInPolicy1.PopulateFromARM(owner, *typedInput.Properties.ScaleInPolicy)
			if err != nil {
				return err
			}
			scaleInPolicy := scaleInPolicy1
			scaleSet.ScaleInPolicy = &scaleInPolicy
		}
	}

	// Set property ‘SinglePlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SinglePlacementGroup != nil {
			singlePlacementGroup := *typedInput.Properties.SinglePlacementGroup
			scaleSet.SinglePlacementGroup = &singlePlacementGroup
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		scaleSet.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		scaleSet.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			scaleSet.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		scaleSet.Type = &typeVar
	}

	// Set property ‘UniqueId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UniqueId != nil {
			uniqueId := *typedInput.Properties.UniqueId
			scaleSet.UniqueId = &uniqueId
		}
	}

	// Set property ‘UpgradePolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradePolicy != nil {
			var upgradePolicy1 UpgradePolicy_Status
			err := upgradePolicy1.PopulateFromARM(owner, *typedInput.Properties.UpgradePolicy)
			if err != nil {
				return err
			}
			upgradePolicy := upgradePolicy1
			scaleSet.UpgradePolicy = &upgradePolicy
		}
	}

	// Set property ‘VirtualMachineProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineProfile != nil {
			var virtualMachineProfile1 VirtualMachineScaleSetVMProfile_Status
			err := virtualMachineProfile1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineProfile)
			if err != nil {
				return err
			}
			virtualMachineProfile := virtualMachineProfile1
			scaleSet.VirtualMachineProfile = &virtualMachineProfile
		}
	}

	// Set property ‘ZoneBalance’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneBalance != nil {
			zoneBalance := *typedInput.Properties.ZoneBalance
			scaleSet.ZoneBalance = &zoneBalance
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		scaleSet.Zones = append(scaleSet.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetStatus populates our VirtualMachineScaleSet_Status from the provided source VirtualMachineScaleSet_Status
func (scaleSet *VirtualMachineScaleSet_Status) AssignPropertiesFromVirtualMachineScaleSetStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSet_Status) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_Status
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilitiesStatus(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilitiesStatus() to populate field AdditionalCapabilities")
		}
		scaleSet.AdditionalCapabilities = &additionalCapability
	} else {
		scaleSet.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy_Status
		err := automaticRepairsPolicy.AssignPropertiesFromAutomaticRepairsPolicyStatus(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticRepairsPolicyStatus() to populate field AutomaticRepairsPolicy")
		}
		scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		scaleSet.AutomaticRepairsPolicy = nil
	}

	// Conditions
	scaleSet.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationStatus() to populate field ExtendedLocation")
		}
		scaleSet.ExtendedLocation = &extendedLocation
	} else {
		scaleSet.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_Status
		err := hostGroup.AssignPropertiesFromSubResourceStatus(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field HostGroup")
		}
		scaleSet.HostGroup = &hostGroup
	} else {
		scaleSet.HostGroup = nil
	}

	// Id
	scaleSet.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity_Status
		err := identity.AssignPropertiesFromVirtualMachineScaleSetIdentityStatus(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIdentityStatus() to populate field Identity")
		}
		scaleSet.Identity = &identity
	} else {
		scaleSet.Identity = nil
	}

	// Location
	scaleSet.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	scaleSet.Name = genruntime.ClonePointerToString(source.Name)

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := OrchestrationMode_Status(*source.OrchestrationMode)
		scaleSet.OrchestrationMode = &orchestrationMode
	} else {
		scaleSet.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		scaleSet.Overprovision = &overprovision
	} else {
		scaleSet.Overprovision = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_Status
		err := plan.AssignPropertiesFromPlanStatus(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlanStatus() to populate field Plan")
		}
		scaleSet.Plan = &plan
	} else {
		scaleSet.Plan = nil
	}

	// PlatformFaultDomainCount
	scaleSet.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProvisioningState
	scaleSet.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_Status
		err := proximityPlacementGroup.AssignPropertiesFromSubResourceStatus(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field ProximityPlacementGroup")
		}
		scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		scaleSet.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy_Status
		err := scaleInPolicy.AssignPropertiesFromScaleInPolicyStatus(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScaleInPolicyStatus() to populate field ScaleInPolicy")
		}
		scaleSet.ScaleInPolicy = &scaleInPolicy
	} else {
		scaleSet.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		scaleSet.SinglePlacementGroup = &singlePlacementGroup
	} else {
		scaleSet.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_Status
		err := sku.AssignPropertiesFromSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSkuStatus() to populate field Sku")
		}
		scaleSet.Sku = &sku
	} else {
		scaleSet.Sku = nil
	}

	// Tags
	scaleSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	scaleSet.Type = genruntime.ClonePointerToString(source.Type)

	// UniqueId
	scaleSet.UniqueId = genruntime.ClonePointerToString(source.UniqueId)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy_Status
		err := upgradePolicy.AssignPropertiesFromUpgradePolicyStatus(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUpgradePolicyStatus() to populate field UpgradePolicy")
		}
		scaleSet.UpgradePolicy = &upgradePolicy
	} else {
		scaleSet.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile_Status
		err := virtualMachineProfile.AssignPropertiesFromVirtualMachineScaleSetVMProfileStatus(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetVMProfileStatus() to populate field VirtualMachineProfile")
		}
		scaleSet.VirtualMachineProfile = &virtualMachineProfile
	} else {
		scaleSet.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		scaleSet.ZoneBalance = &zoneBalance
	} else {
		scaleSet.ZoneBalance = nil
	}

	// Zones
	scaleSet.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetStatus populates the provided destination VirtualMachineScaleSet_Status from our VirtualMachineScaleSet_Status
func (scaleSet *VirtualMachineScaleSet_Status) AssignPropertiesToVirtualMachineScaleSetStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSet_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if scaleSet.AdditionalCapabilities != nil {
		var additionalCapability v1alpha1api20201201storage.AdditionalCapabilities_Status
		err := scaleSet.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilitiesStatus(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilitiesStatus() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if scaleSet.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy v1alpha1api20201201storage.AutomaticRepairsPolicy_Status
		err := scaleSet.AutomaticRepairsPolicy.AssignPropertiesToAutomaticRepairsPolicyStatus(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticRepairsPolicyStatus() to populate field AutomaticRepairsPolicy")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(scaleSet.Conditions)

	// DoNotRunExtensionsOnOverprovisionedVMs
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if scaleSet.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201201storage.ExtendedLocation_Status
		err := scaleSet.ExtendedLocation.AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationStatus() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if scaleSet.HostGroup != nil {
		var hostGroup v1alpha1api20201201storage.SubResource_Status
		err := scaleSet.HostGroup.AssignPropertiesToSubResourceStatus(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(scaleSet.Id)

	// Identity
	if scaleSet.Identity != nil {
		var identity v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status
		err := scaleSet.Identity.AssignPropertiesToVirtualMachineScaleSetIdentityStatus(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIdentityStatus() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(scaleSet.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(scaleSet.Name)

	// OrchestrationMode
	if scaleSet.OrchestrationMode != nil {
		orchestrationMode := string(*scaleSet.OrchestrationMode)
		destination.OrchestrationMode = &orchestrationMode
	} else {
		destination.OrchestrationMode = nil
	}

	// Overprovision
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Plan
	if scaleSet.Plan != nil {
		var plan v1alpha1api20201201storage.Plan_Status
		err := scaleSet.Plan.AssignPropertiesToPlanStatus(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlanStatus() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	destination.PlatformFaultDomainCount = genruntime.ClonePointerToInt(scaleSet.PlatformFaultDomainCount)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(scaleSet.ProvisioningState)

	// ProximityPlacementGroup
	if scaleSet.ProximityPlacementGroup != nil {
		var proximityPlacementGroup v1alpha1api20201201storage.SubResource_Status
		err := scaleSet.ProximityPlacementGroup.AssignPropertiesToSubResourceStatus(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if scaleSet.ScaleInPolicy != nil {
		var scaleInPolicy v1alpha1api20201201storage.ScaleInPolicy_Status
		err := scaleSet.ScaleInPolicy.AssignPropertiesToScaleInPolicyStatus(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScaleInPolicyStatus() to populate field ScaleInPolicy")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if scaleSet.Sku != nil {
		var sku v1alpha1api20201201storage.Sku_Status
		err := scaleSet.Sku.AssignPropertiesToSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSkuStatus() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(scaleSet.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(scaleSet.Type)

	// UniqueId
	destination.UniqueId = genruntime.ClonePointerToString(scaleSet.UniqueId)

	// UpgradePolicy
	if scaleSet.UpgradePolicy != nil {
		var upgradePolicy v1alpha1api20201201storage.UpgradePolicy_Status
		err := scaleSet.UpgradePolicy.AssignPropertiesToUpgradePolicyStatus(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUpgradePolicyStatus() to populate field UpgradePolicy")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if scaleSet.VirtualMachineProfile != nil {
		var virtualMachineProfile v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Status
		err := scaleSet.VirtualMachineProfile.AssignPropertiesToVirtualMachineScaleSetVMProfileStatus(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetVMProfileStatus() to populate field VirtualMachineProfile")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(scaleSet.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSets_SPEC struct {
	//AdditionalCapabilities: Specifies additional capabilities enabled or disabled on
	//the Virtual Machines in the Virtual Machine Scale Set. For instance: whether the
	//Virtual Machines have the capability to support attaching managed data disks
	//with UltraSSD_LRS storage account type.
	AdditionalCapabilities *AdditionalCapabilities_Spec `json:"additionalCapabilities,omitempty"`

	//AutomaticRepairsPolicy: Policy for automatic repairs.
	AutomaticRepairsPolicy *AutomaticRepairsPolicy_Spec `json:"automaticRepairsPolicy,omitempty"`

	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//DoNotRunExtensionsOnOverprovisionedVMs: When Overprovision is enabled,
	//extensions are launched only on the requested number of VMs which are finally
	//kept. This property will hence ensure that the extensions do not run on the
	//extra overprovisioned VMs.
	DoNotRunExtensionsOnOverprovisionedVMs *bool `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`

	//ExtendedLocation: The extended location of the Virtual Machine Scale Set.
	ExtendedLocation *ExtendedLocation_Spec `json:"extendedLocation,omitempty"`

	//HostGroup: Specifies information about the dedicated host group that the virtual
	//machine scale set resides in.
	//Minimum api-version: 2020-06-01.
	HostGroup *SubResource_Spec `json:"hostGroup,omitempty"`

	//Identity: The identity of the virtual machine scale set, if configured.
	Identity *VirtualMachineScaleSetIdentity_Spec `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	//Location: Resource location
	Location string `json:"location"`

	//OrchestrationMode: Specifies the orchestration mode for the virtual machine
	//scale set.
	OrchestrationMode *OrchestrationMode_Spec `json:"orchestrationMode,omitempty"`

	//Overprovision: Specifies whether the Virtual Machine Scale Set should be
	//overprovisioned.
	Overprovision *bool `json:"overprovision,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//Plan: Specifies information about the marketplace image used to create the
	//virtual machine. This element is only used for marketplace images. Before you
	//can use a marketplace image from an API, you must enable the image for
	//programmatic use.  In the Azure portal, find the marketplace image that you want
	//to use and then click Want to deploy programmatically, Get Started ->. Enter any
	//required information and then click Save.
	Plan *Plan_Spec `json:"plan,omitempty"`

	//PlatformFaultDomainCount: Fault Domain count for each placement group.
	PlatformFaultDomainCount *int `json:"platformFaultDomainCount,omitempty"`

	//ProximityPlacementGroup: Specifies information about the proximity placement
	//group that the virtual machine scale set should be assigned to.
	//Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource_Spec `json:"proximityPlacementGroup,omitempty"`

	//ScaleInPolicy: Specifies the scale-in policy that decides which virtual machines
	//are chosen for removal when a Virtual Machine Scale Set is scaled-in.
	ScaleInPolicy *ScaleInPolicy_Spec `json:"scaleInPolicy,omitempty"`

	//SinglePlacementGroup: When true this limits the scale set to a single placement
	//group, of max size 100 virtual machines. NOTE: If singlePlacementGroup is true,
	//it may be modified to false. However, if singlePlacementGroup is false, it may
	//not be modified to true.
	SinglePlacementGroup *bool `json:"singlePlacementGroup,omitempty"`

	//Sku: The virtual machine scale set sku.
	Sku *Sku_Spec `json:"sku,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//UpgradePolicy: The upgrade policy.
	UpgradePolicy *UpgradePolicy_Spec `json:"upgradePolicy,omitempty"`

	//VirtualMachineProfile: The virtual machine profile.
	VirtualMachineProfile *VirtualMachineScaleSetVMProfile_Spec `json:"virtualMachineProfile,omitempty"`

	//ZoneBalance: Whether to force strictly even Virtual Machine distribution cross
	//x-zones in case there is zone outage.
	ZoneBalance *bool `json:"zoneBalance,omitempty"`

	//Zones: The virtual machine scale set zones. NOTE: Availability zones can only be
	//set when you create the scale set
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_SPEC{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spec *VirtualMachineScaleSets_SPEC) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spec == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_SPECARM

	// Set property ‘AzureName’:
	result.AzureName = spec.AzureName

	// Set property ‘ExtendedLocation’:
	if spec.ExtendedLocation != nil {
		extendedLocationARM, err := (*spec.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocation_SpecARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Identity’:
	if spec.Identity != nil {
		identityARM, err := (*spec.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := identityARM.(VirtualMachineScaleSetIdentity_SpecARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	result.Location = spec.Location

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Plan’:
	if spec.Plan != nil {
		planARM, err := (*spec.Plan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plan := planARM.(Plan_SpecARM)
		result.Plan = &plan
	}

	// Set property ‘Properties’:
	if spec.AdditionalCapabilities != nil ||
		spec.AutomaticRepairsPolicy != nil ||
		spec.DoNotRunExtensionsOnOverprovisionedVMs != nil ||
		spec.HostGroup != nil ||
		spec.OrchestrationMode != nil ||
		spec.Overprovision != nil ||
		spec.PlatformFaultDomainCount != nil ||
		spec.ProximityPlacementGroup != nil ||
		spec.ScaleInPolicy != nil ||
		spec.SinglePlacementGroup != nil ||
		spec.UpgradePolicy != nil ||
		spec.VirtualMachineProfile != nil ||
		spec.ZoneBalance != nil {
		result.Properties = &VirtualMachineScaleSetProperties_SpecARM{}
	}
	if spec.AdditionalCapabilities != nil {
		additionalCapabilitiesARM, err := (*spec.AdditionalCapabilities).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		additionalCapabilities := additionalCapabilitiesARM.(AdditionalCapabilities_SpecARM)
		result.Properties.AdditionalCapabilities = &additionalCapabilities
	}
	if spec.AutomaticRepairsPolicy != nil {
		automaticRepairsPolicyARM, err := (*spec.AutomaticRepairsPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticRepairsPolicy := automaticRepairsPolicyARM.(AutomaticRepairsPolicy_SpecARM)
		result.Properties.AutomaticRepairsPolicy = &automaticRepairsPolicy
	}
	if spec.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVMs := *spec.DoNotRunExtensionsOnOverprovisionedVMs
		result.Properties.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
	}
	if spec.HostGroup != nil {
		hostGroupARM, err := (*spec.HostGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostGroup := hostGroupARM.(SubResource_SpecARM)
		result.Properties.HostGroup = &hostGroup
	}
	if spec.OrchestrationMode != nil {
		orchestrationMode := *spec.OrchestrationMode
		result.Properties.OrchestrationMode = &orchestrationMode
	}
	if spec.Overprovision != nil {
		overprovision := *spec.Overprovision
		result.Properties.Overprovision = &overprovision
	}
	if spec.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *spec.PlatformFaultDomainCount
		result.Properties.PlatformFaultDomainCount = &platformFaultDomainCount
	}
	if spec.ProximityPlacementGroup != nil {
		proximityPlacementGroupARM, err := (*spec.ProximityPlacementGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proximityPlacementGroup := proximityPlacementGroupARM.(SubResource_SpecARM)
		result.Properties.ProximityPlacementGroup = &proximityPlacementGroup
	}
	if spec.ScaleInPolicy != nil {
		scaleInPolicyARM, err := (*spec.ScaleInPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleInPolicy := scaleInPolicyARM.(ScaleInPolicy_SpecARM)
		result.Properties.ScaleInPolicy = &scaleInPolicy
	}
	if spec.SinglePlacementGroup != nil {
		singlePlacementGroup := *spec.SinglePlacementGroup
		result.Properties.SinglePlacementGroup = &singlePlacementGroup
	}
	if spec.UpgradePolicy != nil {
		upgradePolicyARM, err := (*spec.UpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradePolicy := upgradePolicyARM.(UpgradePolicy_SpecARM)
		result.Properties.UpgradePolicy = &upgradePolicy
	}
	if spec.VirtualMachineProfile != nil {
		virtualMachineProfileARM, err := (*spec.VirtualMachineProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineProfile := virtualMachineProfileARM.(VirtualMachineScaleSetVMProfile_SpecARM)
		result.Properties.VirtualMachineProfile = &virtualMachineProfile
	}
	if spec.ZoneBalance != nil {
		zoneBalance := *spec.ZoneBalance
		result.Properties.ZoneBalance = &zoneBalance
	}

	// Set property ‘Sku’:
	if spec.Sku != nil {
		skuARM, err := (*spec.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(Sku_SpecARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if spec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range spec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range spec.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spec *VirtualMachineScaleSets_SPEC) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_SPECARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spec *VirtualMachineScaleSets_SPEC) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_SPECARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_SPECARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities_Spec
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			spec.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property ‘AutomaticRepairsPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticRepairsPolicy != nil {
			var automaticRepairsPolicy1 AutomaticRepairsPolicy_Spec
			err := automaticRepairsPolicy1.PopulateFromARM(owner, *typedInput.Properties.AutomaticRepairsPolicy)
			if err != nil {
				return err
			}
			automaticRepairsPolicy := automaticRepairsPolicy1
			spec.AutomaticRepairsPolicy = &automaticRepairsPolicy
		}
	}

	// Set property ‘AzureName’:
	spec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DoNotRunExtensionsOnOverprovisionedVMs’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs != nil {
			doNotRunExtensionsOnOverprovisionedVMs := *typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs
			spec.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Spec
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		spec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource_Spec
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			spec.HostGroup = &hostGroup
		}
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineScaleSetIdentity_Spec
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		spec.Identity = &identity
	}

	// Set property ‘Location’:
	spec.Location = typedInput.Location

	// Set property ‘OrchestrationMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OrchestrationMode != nil {
			orchestrationMode := *typedInput.Properties.OrchestrationMode
			spec.OrchestrationMode = &orchestrationMode
		}
	}

	// Set property ‘Overprovision’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Overprovision != nil {
			overprovision := *typedInput.Properties.Overprovision
			spec.Overprovision = &overprovision
		}
	}

	// Set property ‘Owner’:
	spec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan_Spec
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		spec.Plan = &plan
	}

	// Set property ‘PlatformFaultDomainCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomainCount != nil {
			platformFaultDomainCount := *typedInput.Properties.PlatformFaultDomainCount
			spec.PlatformFaultDomainCount = &platformFaultDomainCount
		}
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource_Spec
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			spec.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property ‘ScaleInPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScaleInPolicy != nil {
			var scaleInPolicy1 ScaleInPolicy_Spec
			err := scaleInPolicy1.PopulateFromARM(owner, *typedInput.Properties.ScaleInPolicy)
			if err != nil {
				return err
			}
			scaleInPolicy := scaleInPolicy1
			spec.ScaleInPolicy = &scaleInPolicy
		}
	}

	// Set property ‘SinglePlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SinglePlacementGroup != nil {
			singlePlacementGroup := *typedInput.Properties.SinglePlacementGroup
			spec.SinglePlacementGroup = &singlePlacementGroup
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_Spec
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		spec.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		spec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			spec.Tags[key] = value
		}
	}

	// Set property ‘UpgradePolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradePolicy != nil {
			var upgradePolicy1 UpgradePolicy_Spec
			err := upgradePolicy1.PopulateFromARM(owner, *typedInput.Properties.UpgradePolicy)
			if err != nil {
				return err
			}
			upgradePolicy := upgradePolicy1
			spec.UpgradePolicy = &upgradePolicy
		}
	}

	// Set property ‘VirtualMachineProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineProfile != nil {
			var virtualMachineProfile1 VirtualMachineScaleSetVMProfile_Spec
			err := virtualMachineProfile1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineProfile)
			if err != nil {
				return err
			}
			virtualMachineProfile := virtualMachineProfile1
			spec.VirtualMachineProfile = &virtualMachineProfile
		}
	}

	// Set property ‘ZoneBalance’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneBalance != nil {
			zoneBalance := *typedInput.Properties.ZoneBalance
			spec.ZoneBalance = &zoneBalance
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		spec.Zones = append(spec.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualMachineScaleSets_SPEC{}

// ConvertSpecFrom populates our VirtualMachineScaleSets_SPEC from the provided source
func (spec *VirtualMachineScaleSets_SPEC) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20201201storage.VirtualMachineScaleSets_SPEC)
	if ok {
		// Populate our instance from source
		return spec.AssignPropertiesFromVirtualMachineScaleSetsSPEC(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201201storage.VirtualMachineScaleSets_SPEC{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = spec.AssignPropertiesFromVirtualMachineScaleSetsSPEC(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachineScaleSets_SPEC
func (spec *VirtualMachineScaleSets_SPEC) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20201201storage.VirtualMachineScaleSets_SPEC)
	if ok {
		// Populate destination from our instance
		return spec.AssignPropertiesToVirtualMachineScaleSetsSPEC(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201201storage.VirtualMachineScaleSets_SPEC{}
	err := spec.AssignPropertiesToVirtualMachineScaleSetsSPEC(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSPEC populates our VirtualMachineScaleSets_SPEC from the provided source VirtualMachineScaleSets_SPEC
func (spec *VirtualMachineScaleSets_SPEC) AssignPropertiesFromVirtualMachineScaleSetsSPEC(source *v1alpha1api20201201storage.VirtualMachineScaleSets_SPEC) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_Spec
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilitiesSpec(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilitiesSpec() to populate field AdditionalCapabilities")
		}
		spec.AdditionalCapabilities = &additionalCapability
	} else {
		spec.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy_Spec
		err := automaticRepairsPolicy.AssignPropertiesFromAutomaticRepairsPolicySpec(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticRepairsPolicySpec() to populate field AutomaticRepairsPolicy")
		}
		spec.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		spec.AutomaticRepairsPolicy = nil
	}

	// AzureName
	spec.AzureName = source.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		spec.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		spec.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Spec
		err := extendedLocation.AssignPropertiesFromExtendedLocationSpec(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationSpec() to populate field ExtendedLocation")
		}
		spec.ExtendedLocation = &extendedLocation
	} else {
		spec.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_Spec
		err := hostGroup.AssignPropertiesFromSubResourceSpec(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field HostGroup")
		}
		spec.HostGroup = &hostGroup
	} else {
		spec.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity_Spec
		err := identity.AssignPropertiesFromVirtualMachineScaleSetIdentitySpec(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIdentitySpec() to populate field Identity")
		}
		spec.Identity = &identity
	} else {
		spec.Identity = nil
	}

	// Location
	spec.Location = genruntime.GetOptionalStringValue(source.Location)

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := OrchestrationMode_Spec(*source.OrchestrationMode)
		spec.OrchestrationMode = &orchestrationMode
	} else {
		spec.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		spec.Overprovision = &overprovision
	} else {
		spec.Overprovision = nil
	}

	// Owner
	spec.Owner = source.Owner.Copy()

	// Plan
	if source.Plan != nil {
		var plan Plan_Spec
		err := plan.AssignPropertiesFromPlanSpec(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlanSpec() to populate field Plan")
		}
		spec.Plan = &plan
	} else {
		spec.Plan = nil
	}

	// PlatformFaultDomainCount
	spec.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_Spec
		err := proximityPlacementGroup.AssignPropertiesFromSubResourceSpec(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field ProximityPlacementGroup")
		}
		spec.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		spec.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy_Spec
		err := scaleInPolicy.AssignPropertiesFromScaleInPolicySpec(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScaleInPolicySpec() to populate field ScaleInPolicy")
		}
		spec.ScaleInPolicy = &scaleInPolicy
	} else {
		spec.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		spec.SinglePlacementGroup = &singlePlacementGroup
	} else {
		spec.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_Spec
		err := sku.AssignPropertiesFromSkuSpec(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSkuSpec() to populate field Sku")
		}
		spec.Sku = &sku
	} else {
		spec.Sku = nil
	}

	// Tags
	spec.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy_Spec
		err := upgradePolicy.AssignPropertiesFromUpgradePolicySpec(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUpgradePolicySpec() to populate field UpgradePolicy")
		}
		spec.UpgradePolicy = &upgradePolicy
	} else {
		spec.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile_Spec
		err := virtualMachineProfile.AssignPropertiesFromVirtualMachineScaleSetVMProfileSpec(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetVMProfileSpec() to populate field VirtualMachineProfile")
		}
		spec.VirtualMachineProfile = &virtualMachineProfile
	} else {
		spec.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		spec.ZoneBalance = &zoneBalance
	} else {
		spec.ZoneBalance = nil
	}

	// Zones
	spec.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSPEC populates the provided destination VirtualMachineScaleSets_SPEC from our VirtualMachineScaleSets_SPEC
func (spec *VirtualMachineScaleSets_SPEC) AssignPropertiesToVirtualMachineScaleSetsSPEC(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_SPEC) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if spec.AdditionalCapabilities != nil {
		var additionalCapability v1alpha1api20201201storage.AdditionalCapabilities_Spec
		err := spec.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilitiesSpec(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilitiesSpec() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if spec.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy v1alpha1api20201201storage.AutomaticRepairsPolicy_Spec
		err := spec.AutomaticRepairsPolicy.AssignPropertiesToAutomaticRepairsPolicySpec(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticRepairsPolicySpec() to populate field AutomaticRepairsPolicy")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// AzureName
	destination.AzureName = spec.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if spec.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *spec.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if spec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201201storage.ExtendedLocation_Spec
		err := spec.ExtendedLocation.AssignPropertiesToExtendedLocationSpec(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationSpec() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if spec.HostGroup != nil {
		var hostGroup v1alpha1api20201201storage.SubResource_Spec
		err := spec.HostGroup.AssignPropertiesToSubResourceSpec(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if spec.Identity != nil {
		var identity v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Spec
		err := spec.Identity.AssignPropertiesToVirtualMachineScaleSetIdentitySpec(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIdentitySpec() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	location := spec.Location
	destination.Location = &location

	// OrchestrationMode
	if spec.OrchestrationMode != nil {
		orchestrationMode := string(*spec.OrchestrationMode)
		destination.OrchestrationMode = &orchestrationMode
	} else {
		destination.OrchestrationMode = nil
	}

	// OriginalVersion
	destination.OriginalVersion = spec.OriginalVersion()

	// Overprovision
	if spec.Overprovision != nil {
		overprovision := *spec.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Owner
	destination.Owner = spec.Owner.Copy()

	// Plan
	if spec.Plan != nil {
		var plan v1alpha1api20201201storage.Plan_Spec
		err := spec.Plan.AssignPropertiesToPlanSpec(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlanSpec() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	destination.PlatformFaultDomainCount = genruntime.ClonePointerToInt(spec.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if spec.ProximityPlacementGroup != nil {
		var proximityPlacementGroup v1alpha1api20201201storage.SubResource_Spec
		err := spec.ProximityPlacementGroup.AssignPropertiesToSubResourceSpec(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if spec.ScaleInPolicy != nil {
		var scaleInPolicy v1alpha1api20201201storage.ScaleInPolicy_Spec
		err := spec.ScaleInPolicy.AssignPropertiesToScaleInPolicySpec(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScaleInPolicySpec() to populate field ScaleInPolicy")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if spec.SinglePlacementGroup != nil {
		singlePlacementGroup := *spec.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if spec.Sku != nil {
		var sku v1alpha1api20201201storage.Sku_Spec
		err := spec.Sku.AssignPropertiesToSkuSpec(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSkuSpec() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(spec.Tags)

	// UpgradePolicy
	if spec.UpgradePolicy != nil {
		var upgradePolicy v1alpha1api20201201storage.UpgradePolicy_Spec
		err := spec.UpgradePolicy.AssignPropertiesToUpgradePolicySpec(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUpgradePolicySpec() to populate field UpgradePolicy")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if spec.VirtualMachineProfile != nil {
		var virtualMachineProfile v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Spec
		err := spec.VirtualMachineProfile.AssignPropertiesToVirtualMachineScaleSetVMProfileSpec(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetVMProfileSpec() to populate field VirtualMachineProfile")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if spec.ZoneBalance != nil {
		zoneBalance := *spec.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(spec.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (spec *VirtualMachineScaleSets_SPEC) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (spec *VirtualMachineScaleSets_SPEC) SetAzureName(azureName string) { spec.AzureName = azureName }

type AutomaticRepairsPolicy_Spec struct {
	//Enabled: Specifies whether automatic repairs should be enabled on the virtual
	//machine scale set. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`

	//GracePeriod: The amount of time for which automatic repairs are suspended due to
	//a state change on VM. The grace time starts after the state change has
	//completed. This helps avoid premature or accidental repairs. The time duration
	//should be specified in ISO 8601 format. The minimum allowed grace period is 30
	//minutes (PT30M), which is also the default value. The maximum allowed grace
	//period is 90 minutes (PT90M).
	GracePeriod *string `json:"gracePeriod,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticRepairsPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *AutomaticRepairsPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	var result AutomaticRepairsPolicy_SpecARM

	// Set property ‘Enabled’:
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if policy.GracePeriod != nil {
		gracePeriod := *policy.GracePeriod
		result.GracePeriod = &gracePeriod
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticRepairsPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticRepairsPolicy_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticRepairsPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticRepairsPolicy_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticRepairsPolicy_SpecARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		policy.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if typedInput.GracePeriod != nil {
		gracePeriod := *typedInput.GracePeriod
		policy.GracePeriod = &gracePeriod
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticRepairsPolicySpec populates our AutomaticRepairsPolicy_Spec from the provided source AutomaticRepairsPolicy_Spec
func (policy *AutomaticRepairsPolicy_Spec) AssignPropertiesFromAutomaticRepairsPolicySpec(source *v1alpha1api20201201storage.AutomaticRepairsPolicy_Spec) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// No error
	return nil
}

// AssignPropertiesToAutomaticRepairsPolicySpec populates the provided destination AutomaticRepairsPolicy_Spec from our AutomaticRepairsPolicy_Spec
func (policy *AutomaticRepairsPolicy_Spec) AssignPropertiesToAutomaticRepairsPolicySpec(destination *v1alpha1api20201201storage.AutomaticRepairsPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	destination.GracePeriod = genruntime.ClonePointerToString(policy.GracePeriod)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AutomaticRepairsPolicy_Status struct {
	//Enabled: Specifies whether automatic repairs should be enabled on the virtual
	//machine scale set. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`

	//GracePeriod: The amount of time for which automatic repairs are suspended due to
	//a state change on VM. The grace time starts after the state change has
	//completed. This helps avoid premature or accidental repairs. The time duration
	//should be specified in ISO 8601 format. The minimum allowed grace period is 30
	//minutes (PT30M), which is also the default value. The maximum allowed grace
	//period is 90 minutes (PT90M).
	GracePeriod *string `json:"gracePeriod,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticRepairsPolicy_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticRepairsPolicy_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticRepairsPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticRepairsPolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticRepairsPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticRepairsPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		policy.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if typedInput.GracePeriod != nil {
		gracePeriod := *typedInput.GracePeriod
		policy.GracePeriod = &gracePeriod
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticRepairsPolicyStatus populates our AutomaticRepairsPolicy_Status from the provided source AutomaticRepairsPolicy_Status
func (policy *AutomaticRepairsPolicy_Status) AssignPropertiesFromAutomaticRepairsPolicyStatus(source *v1alpha1api20201201storage.AutomaticRepairsPolicy_Status) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// No error
	return nil
}

// AssignPropertiesToAutomaticRepairsPolicyStatus populates the provided destination AutomaticRepairsPolicy_Status from our AutomaticRepairsPolicy_Status
func (policy *AutomaticRepairsPolicy_Status) AssignPropertiesToAutomaticRepairsPolicyStatus(destination *v1alpha1api20201201storage.AutomaticRepairsPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	destination.GracePeriod = genruntime.ClonePointerToString(policy.GracePeriod)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Flexible","Uniform"}
type OrchestrationMode_Spec string

const (
	OrchestrationMode_SpecFlexible = OrchestrationMode_Spec("Flexible")
	OrchestrationMode_SpecUniform  = OrchestrationMode_Spec("Uniform")
)

type OrchestrationMode_Status string

const (
	OrchestrationMode_StatusFlexible = OrchestrationMode_Status("Flexible")
	OrchestrationMode_StatusUniform  = OrchestrationMode_Status("Uniform")
)

type ScaleInPolicy_Spec struct {
	//Rules: The rules to be followed when scaling-in a virtual machine scale set.
	//Possible values are:
	//Default When a virtual machine scale set is scaled in, the scale set will first
	//be balanced across zones if it is a zonal scale set. Then, it will be balanced
	//across Fault Domains as far as possible. Within each Fault Domain, the virtual
	//machines chosen for removal will be the newest ones that are not protected from
	//scale-in.
	//OldestVM When a virtual machine scale set is being scaled-in, the oldest virtual
	//machines that are not protected from scale-in will be chosen for removal. For
	//zonal virtual machine scale sets, the scale set will first be balanced across
	//zones. Within each zone, the oldest virtual machines that are not protected will
	//be chosen for removal.
	//NewestVM When a virtual machine scale set is being scaled-in, the newest virtual
	//machines that are not protected from scale-in will be chosen for removal. For
	//zonal virtual machine scale sets, the scale set will first be balanced across
	//zones. Within each zone, the newest virtual machines that are not protected will
	//be chosen for removal.
	Rules []ScaleInPolicySpecRules `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleInPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *ScaleInPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	var result ScaleInPolicy_SpecARM

	// Set property ‘Rules’:
	for _, item := range policy.Rules {
		result.Rules = append(result.Rules, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ScaleInPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScaleInPolicy_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ScaleInPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScaleInPolicy_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScaleInPolicy_SpecARM, got %T", armInput)
	}

	// Set property ‘Rules’:
	for _, item := range typedInput.Rules {
		policy.Rules = append(policy.Rules, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromScaleInPolicySpec populates our ScaleInPolicy_Spec from the provided source ScaleInPolicy_Spec
func (policy *ScaleInPolicy_Spec) AssignPropertiesFromScaleInPolicySpec(source *v1alpha1api20201201storage.ScaleInPolicy_Spec) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleInPolicySpecRules, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ScaleInPolicySpecRules(ruleItem)
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignPropertiesToScaleInPolicySpec populates the provided destination ScaleInPolicy_Spec from our ScaleInPolicy_Spec
func (policy *ScaleInPolicy_Spec) AssignPropertiesToScaleInPolicySpec(destination *v1alpha1api20201201storage.ScaleInPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if policy.Rules != nil {
		ruleList := make([]string, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = string(ruleItem)
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ScaleInPolicy_Status struct {
	//Rules: The rules to be followed when scaling-in a virtual machine scale set.
	//Possible values are:
	//Default When a virtual machine scale set is scaled in, the scale set will first
	//be balanced across zones if it is a zonal scale set. Then, it will be balanced
	//across Fault Domains as far as possible. Within each Fault Domain, the virtual
	//machines chosen for removal will be the newest ones that are not protected from
	//scale-in.
	//OldestVM When a virtual machine scale set is being scaled-in, the oldest virtual
	//machines that are not protected from scale-in will be chosen for removal. For
	//zonal virtual machine scale sets, the scale set will first be balanced across
	//zones. Within each zone, the oldest virtual machines that are not protected will
	//be chosen for removal.
	//NewestVM When a virtual machine scale set is being scaled-in, the newest virtual
	//machines that are not protected from scale-in will be chosen for removal. For
	//zonal virtual machine scale sets, the scale set will first be balanced across
	//zones. Within each zone, the newest virtual machines that are not protected will
	//be chosen for removal.
	Rules []ScaleInPolicyStatusRules `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleInPolicy_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ScaleInPolicy_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScaleInPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ScaleInPolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScaleInPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScaleInPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘Rules’:
	for _, item := range typedInput.Rules {
		policy.Rules = append(policy.Rules, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromScaleInPolicyStatus populates our ScaleInPolicy_Status from the provided source ScaleInPolicy_Status
func (policy *ScaleInPolicy_Status) AssignPropertiesFromScaleInPolicyStatus(source *v1alpha1api20201201storage.ScaleInPolicy_Status) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleInPolicyStatusRules, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ScaleInPolicyStatusRules(ruleItem)
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignPropertiesToScaleInPolicyStatus populates the provided destination ScaleInPolicy_Status from our ScaleInPolicy_Status
func (policy *ScaleInPolicy_Status) AssignPropertiesToScaleInPolicyStatus(destination *v1alpha1api20201201storage.ScaleInPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if policy.Rules != nil {
		ruleList := make([]string, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = string(ruleItem)
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Sku_Spec struct {
	//Capacity: Specifies the number of virtual machines in the scale set.
	Capacity *int `json:"capacity,omitempty"`

	//Name: The sku name.
	Name *string `json:"name,omitempty"`

	//Tier: Specifies the tier of virtual machines in a scale set.
	//Possible Values:
	//Standard
	//Basic
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	var result Sku_SpecARM

	// Set property ‘Capacity’:
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property ‘Name’:
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_SpecARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromSkuSpec populates our Sku_Spec from the provided source Sku_Spec
func (sku *Sku_Spec) AssignPropertiesFromSkuSpec(source *v1alpha1api20201201storage.Sku_Spec) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignPropertiesToSkuSpec populates the provided destination Sku_Spec from our Sku_Spec
func (sku *Sku_Spec) AssignPropertiesToSkuSpec(destination *v1alpha1api20201201storage.Sku_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Sku_Status struct {
	//Capacity: Specifies the number of virtual machines in the scale set.
	Capacity *int `json:"capacity,omitempty"`

	//Name: The sku name.
	Name *string `json:"name,omitempty"`

	//Tier: Specifies the tier of virtual machines in a scale set.
	//Possible Values:
	//Standard
	//Basic
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_StatusARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromSkuStatus populates our Sku_Status from the provided source Sku_Status
func (sku *Sku_Status) AssignPropertiesFromSkuStatus(source *v1alpha1api20201201storage.Sku_Status) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignPropertiesToSkuStatus populates the provided destination Sku_Status from our Sku_Status
func (sku *Sku_Status) AssignPropertiesToSkuStatus(destination *v1alpha1api20201201storage.Sku_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UpgradePolicy_Spec struct {
	//AutomaticOSUpgradePolicy: Configuration parameters used for performing automatic
	//OS Upgrade.
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy_Spec `json:"automaticOSUpgradePolicy,omitempty"`

	//Mode: Specifies the mode of an upgrade to virtual machines in the scale set.
	//Possible values are:
	//Manual - You  control the application of updates to virtual machines in the
	//scale set. You do this by using the manualUpgrade action.
	//Automatic - All virtual machines in the scale set are  automatically updated at
	//the same time.
	Mode *UpgradePolicySpecMode `json:"mode,omitempty"`

	//RollingUpgradePolicy: The configuration parameters used while performing a
	//rolling upgrade.
	RollingUpgradePolicy *RollingUpgradePolicy_Spec `json:"rollingUpgradePolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &UpgradePolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *UpgradePolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	var result UpgradePolicy_SpecARM

	// Set property ‘AutomaticOSUpgradePolicy’:
	if policy.AutomaticOSUpgradePolicy != nil {
		automaticOSUpgradePolicyARM, err := (*policy.AutomaticOSUpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicyARM.(AutomaticOSUpgradePolicy_SpecARM)
		result.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if policy.Mode != nil {
		mode := *policy.Mode
		result.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if policy.RollingUpgradePolicy != nil {
		rollingUpgradePolicyARM, err := (*policy.RollingUpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		rollingUpgradePolicy := rollingUpgradePolicyARM.(RollingUpgradePolicy_SpecARM)
		result.RollingUpgradePolicy = &rollingUpgradePolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *UpgradePolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UpgradePolicy_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *UpgradePolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UpgradePolicy_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UpgradePolicy_SpecARM, got %T", armInput)
	}

	// Set property ‘AutomaticOSUpgradePolicy’:
	if typedInput.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy1 AutomaticOSUpgradePolicy_Spec
		err := automaticOSUpgradePolicy1.PopulateFromARM(owner, *typedInput.AutomaticOSUpgradePolicy)
		if err != nil {
			return err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicy1
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		policy.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if typedInput.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy1 RollingUpgradePolicy_Spec
		err := rollingUpgradePolicy1.PopulateFromARM(owner, *typedInput.RollingUpgradePolicy)
		if err != nil {
			return err
		}
		rollingUpgradePolicy := rollingUpgradePolicy1
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignPropertiesFromUpgradePolicySpec populates our UpgradePolicy_Spec from the provided source UpgradePolicy_Spec
func (policy *UpgradePolicy_Spec) AssignPropertiesFromUpgradePolicySpec(source *v1alpha1api20201201storage.UpgradePolicy_Spec) error {

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy_Spec
		err := automaticOSUpgradePolicy.AssignPropertiesFromAutomaticOSUpgradePolicySpec(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticOSUpgradePolicySpec() to populate field AutomaticOSUpgradePolicy")
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
		mode := UpgradePolicySpecMode(*source.Mode)
		policy.Mode = &mode
	} else {
		policy.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy_Spec
		err := rollingUpgradePolicy.AssignPropertiesFromRollingUpgradePolicySpec(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRollingUpgradePolicySpec() to populate field RollingUpgradePolicy")
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUpgradePolicySpec populates the provided destination UpgradePolicy_Spec from our UpgradePolicy_Spec
func (policy *UpgradePolicy_Spec) AssignPropertiesToUpgradePolicySpec(destination *v1alpha1api20201201storage.UpgradePolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticOSUpgradePolicy
	if policy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Spec
		err := policy.AutomaticOSUpgradePolicy.AssignPropertiesToAutomaticOSUpgradePolicySpec(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticOSUpgradePolicySpec() to populate field AutomaticOSUpgradePolicy")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if policy.Mode != nil {
		mode := string(*policy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RollingUpgradePolicy
	if policy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy v1alpha1api20201201storage.RollingUpgradePolicy_Spec
		err := policy.RollingUpgradePolicy.AssignPropertiesToRollingUpgradePolicySpec(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRollingUpgradePolicySpec() to populate field RollingUpgradePolicy")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UpgradePolicy_Status struct {
	//AutomaticOSUpgradePolicy: Configuration parameters used for performing automatic
	//OS Upgrade.
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy_Status `json:"automaticOSUpgradePolicy,omitempty"`

	//Mode: Specifies the mode of an upgrade to virtual machines in the scale set.
	//Possible values are:
	//Manual - You  control the application of updates to virtual machines in the
	//scale set. You do this by using the manualUpgrade action.
	//Automatic - All virtual machines in the scale set are  automatically updated at
	//the same time.
	Mode *UpgradePolicyStatusMode `json:"mode,omitempty"`

	//RollingUpgradePolicy: The configuration parameters used while performing a
	//rolling upgrade.
	RollingUpgradePolicy *RollingUpgradePolicy_Status `json:"rollingUpgradePolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &UpgradePolicy_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *UpgradePolicy_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UpgradePolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *UpgradePolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UpgradePolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UpgradePolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘AutomaticOSUpgradePolicy’:
	if typedInput.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy1 AutomaticOSUpgradePolicy_Status
		err := automaticOSUpgradePolicy1.PopulateFromARM(owner, *typedInput.AutomaticOSUpgradePolicy)
		if err != nil {
			return err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicy1
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		policy.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if typedInput.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy1 RollingUpgradePolicy_Status
		err := rollingUpgradePolicy1.PopulateFromARM(owner, *typedInput.RollingUpgradePolicy)
		if err != nil {
			return err
		}
		rollingUpgradePolicy := rollingUpgradePolicy1
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignPropertiesFromUpgradePolicyStatus populates our UpgradePolicy_Status from the provided source UpgradePolicy_Status
func (policy *UpgradePolicy_Status) AssignPropertiesFromUpgradePolicyStatus(source *v1alpha1api20201201storage.UpgradePolicy_Status) error {

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy_Status
		err := automaticOSUpgradePolicy.AssignPropertiesFromAutomaticOSUpgradePolicyStatus(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticOSUpgradePolicyStatus() to populate field AutomaticOSUpgradePolicy")
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
		mode := UpgradePolicyStatusMode(*source.Mode)
		policy.Mode = &mode
	} else {
		policy.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy_Status
		err := rollingUpgradePolicy.AssignPropertiesFromRollingUpgradePolicyStatus(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRollingUpgradePolicyStatus() to populate field RollingUpgradePolicy")
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUpgradePolicyStatus populates the provided destination UpgradePolicy_Status from our UpgradePolicy_Status
func (policy *UpgradePolicy_Status) AssignPropertiesToUpgradePolicyStatus(destination *v1alpha1api20201201storage.UpgradePolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticOSUpgradePolicy
	if policy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Status
		err := policy.AutomaticOSUpgradePolicy.AssignPropertiesToAutomaticOSUpgradePolicyStatus(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticOSUpgradePolicyStatus() to populate field AutomaticOSUpgradePolicy")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if policy.Mode != nil {
		mode := string(*policy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RollingUpgradePolicy
	if policy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy v1alpha1api20201201storage.RollingUpgradePolicy_Status
		err := policy.RollingUpgradePolicy.AssignPropertiesToRollingUpgradePolicyStatus(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRollingUpgradePolicyStatus() to populate field RollingUpgradePolicy")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetIdentity_Spec struct {
	//Type: The type of identity used for the virtual machine scale set. The type
	//'SystemAssigned, UserAssigned' includes both an implicitly created identity and
	//a set of user assigned identities. The type 'None' will remove any identities
	//from the virtual machine scale set.
	Type *VirtualMachineScaleSetIdentitySpecType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIdentity_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *VirtualMachineScaleSetIdentity_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetIdentity_SpecARM

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineScaleSetIdentity_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIdentity_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineScaleSetIdentity_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIdentity_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIdentity_SpecARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIdentitySpec populates our VirtualMachineScaleSetIdentity_Spec from the provided source VirtualMachineScaleSetIdentity_Spec
func (identity *VirtualMachineScaleSetIdentity_Spec) AssignPropertiesFromVirtualMachineScaleSetIdentitySpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Spec) error {

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineScaleSetIdentitySpecType(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIdentitySpec populates the provided destination VirtualMachineScaleSetIdentity_Spec from our VirtualMachineScaleSetIdentity_Spec
func (identity *VirtualMachineScaleSetIdentity_Spec) AssignPropertiesToVirtualMachineScaleSetIdentitySpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetIdentity_Status struct {
	//PrincipalId: The principal id of virtual machine scale set identity. This
	//property will only be provided for a system assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	//TenantId: The tenant id associated with the virtual machine scale set. This
	//property will only be provided for a system assigned identity.
	TenantId *string `json:"tenantId,omitempty"`

	//Type: The type of identity used for the virtual machine scale set. The type
	//'SystemAssigned, UserAssigned' includes both an implicitly created identity and
	//a set of user assigned identities. The type 'None' will remove any identities
	//from the virtual machine scale set.
	Type *VirtualMachineScaleSetIdentityStatusType `json:"type,omitempty"`

	//UserAssignedIdentities: The list of user identities associated with the virtual
	//machine scale set. The user identity dictionary key references will be ARM
	//resource ids in the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIdentity_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineScaleSetIdentity_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineScaleSetIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities)
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIdentityStatus populates our VirtualMachineScaleSetIdentity_Status from the provided source VirtualMachineScaleSetIdentity_Status
func (identity *VirtualMachineScaleSetIdentity_Status) AssignPropertiesFromVirtualMachineScaleSetIdentityStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineScaleSetIdentityStatusType(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
			err := userAssignedIdentity.AssignPropertiesFromVirtualMachineScaleSetIdentityStatusUserAssignedIdentities(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIdentityStatusUserAssignedIdentities() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIdentityStatus populates the provided destination VirtualMachineScaleSetIdentity_Status from our VirtualMachineScaleSetIdentity_Status
func (identity *VirtualMachineScaleSetIdentity_Status) AssignPropertiesToVirtualMachineScaleSetIdentityStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
			err := userAssignedIdentityValue.AssignPropertiesToVirtualMachineScaleSetIdentityStatusUserAssignedIdentities(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIdentityStatusUserAssignedIdentities() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetVMProfile_Spec struct {
	//BillingProfile: Specifies the billing related details of a Azure Spot VMSS.
	//Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile_Spec `json:"billingProfile,omitempty"`

	//DiagnosticsProfile: Specifies the boot diagnostic settings state.
	//Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile_Spec `json:"diagnosticsProfile,omitempty"`

	//EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine
	//and Azure Spot scale set.
	//For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported
	//and the minimum api-version is 2019-03-01.
	//For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the
	//minimum api-version is 2017-10-30-preview.
	EvictionPolicy *EvictionPolicy_Spec `json:"evictionPolicy,omitempty"`

	//ExtensionProfile: Specifies a collection of settings for extensions installed on
	//virtual machines in the scale set.
	ExtensionProfile *VirtualMachineScaleSetExtensionProfile_Spec `json:"extensionProfile,omitempty"`

	//LicenseType: Specifies that the image or disk that is being used was licensed
	//on-premises.
	//Possible values for Windows Server operating system are:
	//Windows_Client
	//Windows_Server
	//Possible values for Linux Server operating system are:
	//RHEL_BYOS (for RHEL)
	//SLES_BYOS (for SUSE)
	//For more information, see [Azure Hybrid Use Benefit for Windows
	//Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	//[Azure Hybrid Use Benefit for Linux
	//Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	//Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	//NetworkProfile: Specifies properties of the network interfaces of the virtual
	//machines in the scale set.
	NetworkProfile *VirtualMachineScaleSetNetworkProfile_Spec `json:"networkProfile,omitempty"`

	//OsProfile: Specifies the operating system settings for the virtual machines in
	//the scale set.
	OsProfile *VirtualMachineScaleSetOSProfile_Spec `json:"osProfile,omitempty"`

	//Priority: Specifies the priority for the virtual machines in the scale set.
	//Minimum api-version: 2017-10-30-preview
	Priority *Priority_Spec `json:"priority,omitempty"`

	//ScheduledEventsProfile: Specifies Scheduled Event related configurations.
	ScheduledEventsProfile *ScheduledEventsProfile_Spec `json:"scheduledEventsProfile,omitempty"`

	//SecurityProfile: Specifies the Security related profile settings for the virtual
	//machines in the scale set.
	SecurityProfile *SecurityProfile_Spec `json:"securityProfile,omitempty"`

	//StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *VirtualMachineScaleSetStorageProfile_Spec `json:"storageProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetVMProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetVMProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetVMProfile_SpecARM

	// Set property ‘BillingProfile’:
	if profile.BillingProfile != nil {
		billingProfileARM, err := (*profile.BillingProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		billingProfile := billingProfileARM.(BillingProfile_SpecARM)
		result.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if profile.DiagnosticsProfile != nil {
		diagnosticsProfileARM, err := (*profile.DiagnosticsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnosticsProfile := diagnosticsProfileARM.(DiagnosticsProfile_SpecARM)
		result.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if profile.EvictionPolicy != nil {
		evictionPolicy := *profile.EvictionPolicy
		result.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if profile.ExtensionProfile != nil {
		extensionProfileARM, err := (*profile.ExtensionProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extensionProfile := extensionProfileARM.(VirtualMachineScaleSetExtensionProfile_SpecARM)
		result.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if profile.LicenseType != nil {
		licenseType := *profile.LicenseType
		result.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if profile.NetworkProfile != nil {
		networkProfileARM, err := (*profile.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := networkProfileARM.(VirtualMachineScaleSetNetworkProfile_SpecARM)
		result.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if profile.OsProfile != nil {
		osProfileARM, err := (*profile.OsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osProfile := osProfileARM.(VirtualMachineScaleSetOSProfile_SpecARM)
		result.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if profile.Priority != nil {
		priority := *profile.Priority
		result.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if profile.ScheduledEventsProfile != nil {
		scheduledEventsProfileARM, err := (*profile.ScheduledEventsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scheduledEventsProfile := scheduledEventsProfileARM.(ScheduledEventsProfile_SpecARM)
		result.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if profile.SecurityProfile != nil {
		securityProfileARM, err := (*profile.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := securityProfileARM.(SecurityProfile_SpecARM)
		result.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if profile.StorageProfile != nil {
		storageProfileARM, err := (*profile.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := storageProfileARM.(VirtualMachineScaleSetStorageProfile_SpecARM)
		result.StorageProfile = &storageProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetVMProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetVMProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetVMProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetVMProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetVMProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘BillingProfile’:
	if typedInput.BillingProfile != nil {
		var billingProfile1 BillingProfile_Spec
		err := billingProfile1.PopulateFromARM(owner, *typedInput.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		profile.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if typedInput.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile_Spec
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		profile.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if typedInput.EvictionPolicy != nil {
		evictionPolicy := *typedInput.EvictionPolicy
		profile.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if typedInput.ExtensionProfile != nil {
		var extensionProfile1 VirtualMachineScaleSetExtensionProfile_Spec
		err := extensionProfile1.PopulateFromARM(owner, *typedInput.ExtensionProfile)
		if err != nil {
			return err
		}
		extensionProfile := extensionProfile1
		profile.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		profile.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if typedInput.NetworkProfile != nil {
		var networkProfile1 VirtualMachineScaleSetNetworkProfile_Spec
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		profile.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if typedInput.OsProfile != nil {
		var osProfile1 VirtualMachineScaleSetOSProfile_Spec
		err := osProfile1.PopulateFromARM(owner, *typedInput.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		profile.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		profile.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if typedInput.ScheduledEventsProfile != nil {
		var scheduledEventsProfile1 ScheduledEventsProfile_Spec
		err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.ScheduledEventsProfile)
		if err != nil {
			return err
		}
		scheduledEventsProfile := scheduledEventsProfile1
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if typedInput.SecurityProfile != nil {
		var securityProfile1 SecurityProfile_Spec
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		profile.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if typedInput.StorageProfile != nil {
		var storageProfile1 VirtualMachineScaleSetStorageProfile_Spec
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		profile.StorageProfile = &storageProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetVMProfileSpec populates our VirtualMachineScaleSetVMProfile_Spec from the provided source VirtualMachineScaleSetVMProfile_Spec
func (profile *VirtualMachineScaleSetVMProfile_Spec) AssignPropertiesFromVirtualMachineScaleSetVMProfileSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Spec) error {

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_Spec
		err := billingProfile.AssignPropertiesFromBillingProfileSpec(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfileSpec() to populate field BillingProfile")
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_Spec
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfileSpec(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfileSpec() to populate field DiagnosticsProfile")
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := EvictionPolicy_Spec(*source.EvictionPolicy)
		profile.EvictionPolicy = &evictionPolicy
	} else {
		profile.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile_Spec
		err := extensionProfile.AssignPropertiesFromVirtualMachineScaleSetExtensionProfileSpec(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetExtensionProfileSpec() to populate field ExtensionProfile")
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile_Spec
		err := networkProfile.AssignPropertiesFromVirtualMachineScaleSetNetworkProfileSpec(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkProfileSpec() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile_Spec
		err := osProfile.AssignPropertiesFromVirtualMachineScaleSetOSProfileSpec(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSProfileSpec() to populate field OsProfile")
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := Priority_Spec(*source.Priority)
		profile.Priority = &priority
	} else {
		profile.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile_Spec
		err := scheduledEventsProfile.AssignPropertiesFromScheduledEventsProfileSpec(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScheduledEventsProfileSpec() to populate field ScheduledEventsProfile")
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_Spec
		err := securityProfile.AssignPropertiesFromSecurityProfileSpec(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfileSpec() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile_Spec
		err := storageProfile.AssignPropertiesFromVirtualMachineScaleSetStorageProfileSpec(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetStorageProfileSpec() to populate field StorageProfile")
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetVMProfileSpec populates the provided destination VirtualMachineScaleSetVMProfile_Spec from our VirtualMachineScaleSetVMProfile_Spec
func (profile *VirtualMachineScaleSetVMProfile_Spec) AssignPropertiesToVirtualMachineScaleSetVMProfileSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BillingProfile
	if profile.BillingProfile != nil {
		var billingProfile v1alpha1api20201201storage.BillingProfile_Spec
		err := profile.BillingProfile.AssignPropertiesToBillingProfileSpec(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfileSpec() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// DiagnosticsProfile
	if profile.DiagnosticsProfile != nil {
		var diagnosticsProfile v1alpha1api20201201storage.DiagnosticsProfile_Spec
		err := profile.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfileSpec(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfileSpec() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if profile.EvictionPolicy != nil {
		evictionPolicy := string(*profile.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtensionProfile
	if profile.ExtensionProfile != nil {
		var extensionProfile v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Spec
		err := profile.ExtensionProfile.AssignPropertiesToVirtualMachineScaleSetExtensionProfileSpec(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetExtensionProfileSpec() to populate field ExtensionProfile")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Spec
		err := profile.NetworkProfile.AssignPropertiesToVirtualMachineScaleSetNetworkProfileSpec(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkProfileSpec() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if profile.OsProfile != nil {
		var osProfile v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Spec
		err := profile.OsProfile.AssignPropertiesToVirtualMachineScaleSetOSProfileSpec(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSProfileSpec() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	if profile.Priority != nil {
		priority := string(*profile.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ScheduledEventsProfile
	if profile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile v1alpha1api20201201storage.ScheduledEventsProfile_Spec
		err := profile.ScheduledEventsProfile.AssignPropertiesToScheduledEventsProfileSpec(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScheduledEventsProfileSpec() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile v1alpha1api20201201storage.SecurityProfile_Spec
		err := profile.SecurityProfile.AssignPropertiesToSecurityProfileSpec(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfileSpec() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if profile.StorageProfile != nil {
		var storageProfile v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Spec
		err := profile.StorageProfile.AssignPropertiesToVirtualMachineScaleSetStorageProfileSpec(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetStorageProfileSpec() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetVMProfile_Status struct {
	//BillingProfile: Specifies the billing related details of a Azure Spot VMSS.
	//Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile_Status `json:"billingProfile,omitempty"`

	//DiagnosticsProfile: Specifies the boot diagnostic settings state.
	//Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile_Status `json:"diagnosticsProfile,omitempty"`

	//EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine
	//and Azure Spot scale set.
	//For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported
	//and the minimum api-version is 2019-03-01.
	//For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the
	//minimum api-version is 2017-10-30-preview.
	EvictionPolicy *EvictionPolicy_Status `json:"evictionPolicy,omitempty"`

	//ExtensionProfile: Specifies a collection of settings for extensions installed on
	//virtual machines in the scale set.
	ExtensionProfile *VirtualMachineScaleSetExtensionProfile_Status `json:"extensionProfile,omitempty"`

	//LicenseType: Specifies that the image or disk that is being used was licensed
	//on-premises.
	//Possible values for Windows Server operating system are:
	//Windows_Client
	//Windows_Server
	//Possible values for Linux Server operating system are:
	//RHEL_BYOS (for RHEL)
	//SLES_BYOS (for SUSE)
	//For more information, see [Azure Hybrid Use Benefit for Windows
	//Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	//[Azure Hybrid Use Benefit for Linux
	//Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	//Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	//NetworkProfile: Specifies properties of the network interfaces of the virtual
	//machines in the scale set.
	NetworkProfile *VirtualMachineScaleSetNetworkProfile_Status `json:"networkProfile,omitempty"`

	//OsProfile: Specifies the operating system settings for the virtual machines in
	//the scale set.
	OsProfile *VirtualMachineScaleSetOSProfile_Status `json:"osProfile,omitempty"`

	//Priority: Specifies the priority for the virtual machines in the scale set.
	//Minimum api-version: 2017-10-30-preview
	Priority *Priority_Status `json:"priority,omitempty"`

	//ScheduledEventsProfile: Specifies Scheduled Event related configurations.
	ScheduledEventsProfile *ScheduledEventsProfile_Status `json:"scheduledEventsProfile,omitempty"`

	//SecurityProfile: Specifies the Security related profile settings for the virtual
	//machines in the scale set.
	SecurityProfile *SecurityProfile_Status `json:"securityProfile,omitempty"`

	//StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *VirtualMachineScaleSetStorageProfile_Status `json:"storageProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetVMProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetVMProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetVMProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetVMProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetVMProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetVMProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘BillingProfile’:
	if typedInput.BillingProfile != nil {
		var billingProfile1 BillingProfile_Status
		err := billingProfile1.PopulateFromARM(owner, *typedInput.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		profile.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if typedInput.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile_Status
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		profile.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if typedInput.EvictionPolicy != nil {
		evictionPolicy := *typedInput.EvictionPolicy
		profile.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if typedInput.ExtensionProfile != nil {
		var extensionProfile1 VirtualMachineScaleSetExtensionProfile_Status
		err := extensionProfile1.PopulateFromARM(owner, *typedInput.ExtensionProfile)
		if err != nil {
			return err
		}
		extensionProfile := extensionProfile1
		profile.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		profile.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if typedInput.NetworkProfile != nil {
		var networkProfile1 VirtualMachineScaleSetNetworkProfile_Status
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		profile.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if typedInput.OsProfile != nil {
		var osProfile1 VirtualMachineScaleSetOSProfile_Status
		err := osProfile1.PopulateFromARM(owner, *typedInput.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		profile.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		profile.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if typedInput.ScheduledEventsProfile != nil {
		var scheduledEventsProfile1 ScheduledEventsProfile_Status
		err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.ScheduledEventsProfile)
		if err != nil {
			return err
		}
		scheduledEventsProfile := scheduledEventsProfile1
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if typedInput.SecurityProfile != nil {
		var securityProfile1 SecurityProfile_Status
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		profile.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if typedInput.StorageProfile != nil {
		var storageProfile1 VirtualMachineScaleSetStorageProfile_Status
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		profile.StorageProfile = &storageProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetVMProfileStatus populates our VirtualMachineScaleSetVMProfile_Status from the provided source VirtualMachineScaleSetVMProfile_Status
func (profile *VirtualMachineScaleSetVMProfile_Status) AssignPropertiesFromVirtualMachineScaleSetVMProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Status) error {

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_Status
		err := billingProfile.AssignPropertiesFromBillingProfileStatus(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfileStatus() to populate field BillingProfile")
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_Status
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfileStatus(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfileStatus() to populate field DiagnosticsProfile")
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := EvictionPolicy_Status(*source.EvictionPolicy)
		profile.EvictionPolicy = &evictionPolicy
	} else {
		profile.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile_Status
		err := extensionProfile.AssignPropertiesFromVirtualMachineScaleSetExtensionProfileStatus(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetExtensionProfileStatus() to populate field ExtensionProfile")
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile_Status
		err := networkProfile.AssignPropertiesFromVirtualMachineScaleSetNetworkProfileStatus(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkProfileStatus() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile_Status
		err := osProfile.AssignPropertiesFromVirtualMachineScaleSetOSProfileStatus(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSProfileStatus() to populate field OsProfile")
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := Priority_Status(*source.Priority)
		profile.Priority = &priority
	} else {
		profile.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile_Status
		err := scheduledEventsProfile.AssignPropertiesFromScheduledEventsProfileStatus(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScheduledEventsProfileStatus() to populate field ScheduledEventsProfile")
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_Status
		err := securityProfile.AssignPropertiesFromSecurityProfileStatus(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfileStatus() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile_Status
		err := storageProfile.AssignPropertiesFromVirtualMachineScaleSetStorageProfileStatus(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetStorageProfileStatus() to populate field StorageProfile")
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetVMProfileStatus populates the provided destination VirtualMachineScaleSetVMProfile_Status from our VirtualMachineScaleSetVMProfile_Status
func (profile *VirtualMachineScaleSetVMProfile_Status) AssignPropertiesToVirtualMachineScaleSetVMProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BillingProfile
	if profile.BillingProfile != nil {
		var billingProfile v1alpha1api20201201storage.BillingProfile_Status
		err := profile.BillingProfile.AssignPropertiesToBillingProfileStatus(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfileStatus() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// DiagnosticsProfile
	if profile.DiagnosticsProfile != nil {
		var diagnosticsProfile v1alpha1api20201201storage.DiagnosticsProfile_Status
		err := profile.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfileStatus(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfileStatus() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if profile.EvictionPolicy != nil {
		evictionPolicy := string(*profile.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtensionProfile
	if profile.ExtensionProfile != nil {
		var extensionProfile v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Status
		err := profile.ExtensionProfile.AssignPropertiesToVirtualMachineScaleSetExtensionProfileStatus(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetExtensionProfileStatus() to populate field ExtensionProfile")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Status
		err := profile.NetworkProfile.AssignPropertiesToVirtualMachineScaleSetNetworkProfileStatus(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkProfileStatus() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if profile.OsProfile != nil {
		var osProfile v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Status
		err := profile.OsProfile.AssignPropertiesToVirtualMachineScaleSetOSProfileStatus(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSProfileStatus() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	if profile.Priority != nil {
		priority := string(*profile.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ScheduledEventsProfile
	if profile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile v1alpha1api20201201storage.ScheduledEventsProfile_Status
		err := profile.ScheduledEventsProfile.AssignPropertiesToScheduledEventsProfileStatus(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScheduledEventsProfileStatus() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile v1alpha1api20201201storage.SecurityProfile_Status
		err := profile.SecurityProfile.AssignPropertiesToSecurityProfileStatus(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfileStatus() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if profile.StorageProfile != nil {
		var storageProfile v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Status
		err := profile.StorageProfile.AssignPropertiesToVirtualMachineScaleSetStorageProfileStatus(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetStorageProfileStatus() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AutomaticOSUpgradePolicy_Spec struct {
	//DisableAutomaticRollback: Whether OS image rollback feature should be disabled.
	//Default value is false.
	DisableAutomaticRollback *bool `json:"disableAutomaticRollback,omitempty"`

	//EnableAutomaticOSUpgrade: Indicates whether OS upgrades should automatically be
	//applied to scale set instances in a rolling fashion when a newer version of the
	//OS image becomes available. Default value is false.
	//If this is set to true for Windows based scale sets,
	//[enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet)
	//is automatically set to false and cannot be set to true.
	EnableAutomaticOSUpgrade *bool `json:"enableAutomaticOSUpgrade,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticOSUpgradePolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *AutomaticOSUpgradePolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	var result AutomaticOSUpgradePolicy_SpecARM

	// Set property ‘DisableAutomaticRollback’:
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		result.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		result.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticOSUpgradePolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticOSUpgradePolicy_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticOSUpgradePolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticOSUpgradePolicy_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticOSUpgradePolicy_SpecARM, got %T", armInput)
	}

	// Set property ‘DisableAutomaticRollback’:
	if typedInput.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *typedInput.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if typedInput.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *typedInput.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticOSUpgradePolicySpec populates our AutomaticOSUpgradePolicy_Spec from the provided source AutomaticOSUpgradePolicy_Spec
func (policy *AutomaticOSUpgradePolicy_Spec) AssignPropertiesFromAutomaticOSUpgradePolicySpec(source *v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Spec) error {

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutomaticOSUpgradePolicySpec populates the provided destination AutomaticOSUpgradePolicy_Spec from our AutomaticOSUpgradePolicy_Spec
func (policy *AutomaticOSUpgradePolicy_Spec) AssignPropertiesToAutomaticOSUpgradePolicySpec(destination *v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableAutomaticRollback
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AutomaticOSUpgradePolicy_Status struct {
	//DisableAutomaticRollback: Whether OS image rollback feature should be disabled.
	//Default value is false.
	DisableAutomaticRollback *bool `json:"disableAutomaticRollback,omitempty"`

	//EnableAutomaticOSUpgrade: Indicates whether OS upgrades should automatically be
	//applied to scale set instances in a rolling fashion when a newer version of the
	//OS image becomes available. Default value is false.
	//If this is set to true for Windows based scale sets,
	//[enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet)
	//is automatically set to false and cannot be set to true.
	EnableAutomaticOSUpgrade *bool `json:"enableAutomaticOSUpgrade,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticOSUpgradePolicy_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticOSUpgradePolicy_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticOSUpgradePolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticOSUpgradePolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticOSUpgradePolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticOSUpgradePolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘DisableAutomaticRollback’:
	if typedInput.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *typedInput.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if typedInput.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *typedInput.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticOSUpgradePolicyStatus populates our AutomaticOSUpgradePolicy_Status from the provided source AutomaticOSUpgradePolicy_Status
func (policy *AutomaticOSUpgradePolicy_Status) AssignPropertiesFromAutomaticOSUpgradePolicyStatus(source *v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Status) error {

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutomaticOSUpgradePolicyStatus populates the provided destination AutomaticOSUpgradePolicy_Status from our AutomaticOSUpgradePolicy_Status
func (policy *AutomaticOSUpgradePolicy_Status) AssignPropertiesToAutomaticOSUpgradePolicyStatus(destination *v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableAutomaticRollback
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type RollingUpgradePolicy_Spec struct {
	//EnableCrossZoneUpgrade: Allow VMSS to ignore AZ boundaries when constructing
	//upgrade batches. Take into consideration the Update Domain and
	//maxBatchInstancePercent to determine the batch size.
	EnableCrossZoneUpgrade *bool `json:"enableCrossZoneUpgrade,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=5
	//MaxBatchInstancePercent: The maximum percent of total virtual machine instances
	//that will be upgraded simultaneously by the rolling upgrade in one batch. As
	//this is a maximum, unhealthy instances in previous or future batches can cause
	//the percentage of instances in a batch to decrease to ensure higher reliability.
	//The default value for this parameter is 20%.
	MaxBatchInstancePercent *int `json:"maxBatchInstancePercent,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=5
	//MaxUnhealthyInstancePercent: The maximum percentage of the total virtual machine
	//instances in the scale set that can be simultaneously unhealthy, either as a
	//result of being upgraded, or by being found in an unhealthy state by the virtual
	//machine health checks before the rolling upgrade aborts. This constraint will be
	//checked prior to starting any batch. The default value for this parameter is 20%.
	MaxUnhealthyInstancePercent *int `json:"maxUnhealthyInstancePercent,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=0
	//MaxUnhealthyUpgradedInstancePercent: The maximum percentage of upgraded virtual
	//machine instances that can be found to be in an unhealthy state. This check will
	//happen after each batch is upgraded. If this percentage is ever exceeded, the
	//rolling update aborts. The default value for this parameter is 20%.
	MaxUnhealthyUpgradedInstancePercent *int `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`

	//PauseTimeBetweenBatches: The wait time between completing the update for all
	//virtual machines in one batch and starting the next batch. The time duration
	//should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
	PauseTimeBetweenBatches *string `json:"pauseTimeBetweenBatches,omitempty"`

	//PrioritizeUnhealthyInstances: Upgrade all unhealthy instances in a scale set
	//before any healthy instances.
	PrioritizeUnhealthyInstances *bool `json:"prioritizeUnhealthyInstances,omitempty"`
}

var _ genruntime.ARMTransformer = &RollingUpgradePolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *RollingUpgradePolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	var result RollingUpgradePolicy_SpecARM

	// Set property ‘EnableCrossZoneUpgrade’:
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		result.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if policy.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *policy.MaxBatchInstancePercent
		result.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if policy.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *policy.MaxUnhealthyInstancePercent
		result.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if policy.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *policy.MaxUnhealthyUpgradedInstancePercent
		result.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if policy.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *policy.PauseTimeBetweenBatches
		result.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *policy.PrioritizeUnhealthyInstances
		result.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *RollingUpgradePolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RollingUpgradePolicy_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *RollingUpgradePolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RollingUpgradePolicy_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RollingUpgradePolicy_SpecARM, got %T", armInput)
	}

	// Set property ‘EnableCrossZoneUpgrade’:
	if typedInput.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *typedInput.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if typedInput.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *typedInput.MaxBatchInstancePercent
		policy.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if typedInput.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *typedInput.MaxUnhealthyInstancePercent
		policy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if typedInput.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *typedInput.MaxUnhealthyUpgradedInstancePercent
		policy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if typedInput.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *typedInput.PauseTimeBetweenBatches
		policy.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if typedInput.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *typedInput.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}

	// No error
	return nil
}

// AssignPropertiesFromRollingUpgradePolicySpec populates our RollingUpgradePolicy_Spec from the provided source RollingUpgradePolicy_Spec
func (policy *RollingUpgradePolicy_Spec) AssignPropertiesFromRollingUpgradePolicySpec(source *v1alpha1api20201201storage.RollingUpgradePolicy_Spec) error {

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	if source.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *source.MaxBatchInstancePercent
		policy.MaxBatchInstancePercent = &maxBatchInstancePercent
	} else {
		policy.MaxBatchInstancePercent = nil
	}

	// MaxUnhealthyInstancePercent
	if source.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *source.MaxUnhealthyInstancePercent
		policy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	} else {
		policy.MaxUnhealthyInstancePercent = nil
	}

	// MaxUnhealthyUpgradedInstancePercent
	if source.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *source.MaxUnhealthyUpgradedInstancePercent
		policy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	} else {
		policy.MaxUnhealthyUpgradedInstancePercent = nil
	}

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRollingUpgradePolicySpec populates the provided destination RollingUpgradePolicy_Spec from our RollingUpgradePolicy_Spec
func (policy *RollingUpgradePolicy_Spec) AssignPropertiesToRollingUpgradePolicySpec(destination *v1alpha1api20201201storage.RollingUpgradePolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableCrossZoneUpgrade
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	if policy.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *policy.MaxBatchInstancePercent
		destination.MaxBatchInstancePercent = &maxBatchInstancePercent
	} else {
		destination.MaxBatchInstancePercent = nil
	}

	// MaxUnhealthyInstancePercent
	if policy.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *policy.MaxUnhealthyInstancePercent
		destination.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	} else {
		destination.MaxUnhealthyInstancePercent = nil
	}

	// MaxUnhealthyUpgradedInstancePercent
	if policy.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *policy.MaxUnhealthyUpgradedInstancePercent
		destination.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	} else {
		destination.MaxUnhealthyUpgradedInstancePercent = nil
	}

	// PauseTimeBetweenBatches
	destination.PauseTimeBetweenBatches = genruntime.ClonePointerToString(policy.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *policy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type RollingUpgradePolicy_Status struct {
	//EnableCrossZoneUpgrade: Allow VMSS to ignore AZ boundaries when constructing
	//upgrade batches. Take into consideration the Update Domain and
	//maxBatchInstancePercent to determine the batch size.
	EnableCrossZoneUpgrade *bool `json:"enableCrossZoneUpgrade,omitempty"`

	//MaxBatchInstancePercent: The maximum percent of total virtual machine instances
	//that will be upgraded simultaneously by the rolling upgrade in one batch. As
	//this is a maximum, unhealthy instances in previous or future batches can cause
	//the percentage of instances in a batch to decrease to ensure higher reliability.
	//The default value for this parameter is 20%.
	MaxBatchInstancePercent *int `json:"maxBatchInstancePercent,omitempty"`

	//MaxUnhealthyInstancePercent: The maximum percentage of the total virtual machine
	//instances in the scale set that can be simultaneously unhealthy, either as a
	//result of being upgraded, or by being found in an unhealthy state by the virtual
	//machine health checks before the rolling upgrade aborts. This constraint will be
	//checked prior to starting any batch. The default value for this parameter is 20%.
	MaxUnhealthyInstancePercent *int `json:"maxUnhealthyInstancePercent,omitempty"`

	//MaxUnhealthyUpgradedInstancePercent: The maximum percentage of upgraded virtual
	//machine instances that can be found to be in an unhealthy state. This check will
	//happen after each batch is upgraded. If this percentage is ever exceeded, the
	//rolling update aborts. The default value for this parameter is 20%.
	MaxUnhealthyUpgradedInstancePercent *int `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`

	//PauseTimeBetweenBatches: The wait time between completing the update for all
	//virtual machines in one batch and starting the next batch. The time duration
	//should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
	PauseTimeBetweenBatches *string `json:"pauseTimeBetweenBatches,omitempty"`

	//PrioritizeUnhealthyInstances: Upgrade all unhealthy instances in a scale set
	//before any healthy instances.
	PrioritizeUnhealthyInstances *bool `json:"prioritizeUnhealthyInstances,omitempty"`
}

var _ genruntime.FromARMConverter = &RollingUpgradePolicy_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *RollingUpgradePolicy_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RollingUpgradePolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *RollingUpgradePolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RollingUpgradePolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RollingUpgradePolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘EnableCrossZoneUpgrade’:
	if typedInput.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *typedInput.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if typedInput.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *typedInput.MaxBatchInstancePercent
		policy.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if typedInput.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *typedInput.MaxUnhealthyInstancePercent
		policy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if typedInput.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *typedInput.MaxUnhealthyUpgradedInstancePercent
		policy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if typedInput.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *typedInput.PauseTimeBetweenBatches
		policy.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if typedInput.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *typedInput.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}

	// No error
	return nil
}

// AssignPropertiesFromRollingUpgradePolicyStatus populates our RollingUpgradePolicy_Status from the provided source RollingUpgradePolicy_Status
func (policy *RollingUpgradePolicy_Status) AssignPropertiesFromRollingUpgradePolicyStatus(source *v1alpha1api20201201storage.RollingUpgradePolicy_Status) error {

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	policy.MaxBatchInstancePercent = genruntime.ClonePointerToInt(source.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	policy.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	policy.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRollingUpgradePolicyStatus populates the provided destination RollingUpgradePolicy_Status from our RollingUpgradePolicy_Status
func (policy *RollingUpgradePolicy_Status) AssignPropertiesToRollingUpgradePolicyStatus(destination *v1alpha1api20201201storage.RollingUpgradePolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableCrossZoneUpgrade
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	destination.MaxBatchInstancePercent = genruntime.ClonePointerToInt(policy.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	destination.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	destination.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	destination.PauseTimeBetweenBatches = genruntime.ClonePointerToString(policy.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *policy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Default","NewestVM","OldestVM"}
type ScaleInPolicySpecRules string

const (
	ScaleInPolicySpecRulesDefault  = ScaleInPolicySpecRules("Default")
	ScaleInPolicySpecRulesNewestVM = ScaleInPolicySpecRules("NewestVM")
	ScaleInPolicySpecRulesOldestVM = ScaleInPolicySpecRules("OldestVM")
)

type ScaleInPolicyStatusRules string

const (
	ScaleInPolicyStatusRulesDefault  = ScaleInPolicyStatusRules("Default")
	ScaleInPolicyStatusRulesNewestVM = ScaleInPolicyStatusRules("NewestVM")
	ScaleInPolicyStatusRulesOldestVM = ScaleInPolicyStatusRules("OldestVM")
)

type ScheduledEventsProfile_Spec struct {
	//TerminateNotificationProfile: Specifies Terminate Scheduled Event related
	//configurations.
	TerminateNotificationProfile *TerminateNotificationProfile_Spec `json:"terminateNotificationProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduledEventsProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ScheduledEventsProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result ScheduledEventsProfile_SpecARM

	// Set property ‘TerminateNotificationProfile’:
	if profile.TerminateNotificationProfile != nil {
		terminateNotificationProfileARM, err := (*profile.TerminateNotificationProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		terminateNotificationProfile := terminateNotificationProfileARM.(TerminateNotificationProfile_SpecARM)
		result.TerminateNotificationProfile = &terminateNotificationProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ScheduledEventsProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduledEventsProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ScheduledEventsProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduledEventsProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduledEventsProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘TerminateNotificationProfile’:
	if typedInput.TerminateNotificationProfile != nil {
		var terminateNotificationProfile1 TerminateNotificationProfile_Spec
		err := terminateNotificationProfile1.PopulateFromARM(owner, *typedInput.TerminateNotificationProfile)
		if err != nil {
			return err
		}
		terminateNotificationProfile := terminateNotificationProfile1
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromScheduledEventsProfileSpec populates our ScheduledEventsProfile_Spec from the provided source ScheduledEventsProfile_Spec
func (profile *ScheduledEventsProfile_Spec) AssignPropertiesFromScheduledEventsProfileSpec(source *v1alpha1api20201201storage.ScheduledEventsProfile_Spec) error {

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile_Spec
		err := terminateNotificationProfile.AssignPropertiesFromTerminateNotificationProfileSpec(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromTerminateNotificationProfileSpec() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToScheduledEventsProfileSpec populates the provided destination ScheduledEventsProfile_Spec from our ScheduledEventsProfile_Spec
func (profile *ScheduledEventsProfile_Spec) AssignPropertiesToScheduledEventsProfileSpec(destination *v1alpha1api20201201storage.ScheduledEventsProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile v1alpha1api20201201storage.TerminateNotificationProfile_Spec
		err := profile.TerminateNotificationProfile.AssignPropertiesToTerminateNotificationProfileSpec(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToTerminateNotificationProfileSpec() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ScheduledEventsProfile_Status struct {
	//TerminateNotificationProfile: Specifies Terminate Scheduled Event related
	//configurations.
	TerminateNotificationProfile *TerminateNotificationProfile_Status `json:"terminateNotificationProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduledEventsProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ScheduledEventsProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduledEventsProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ScheduledEventsProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduledEventsProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduledEventsProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘TerminateNotificationProfile’:
	if typedInput.TerminateNotificationProfile != nil {
		var terminateNotificationProfile1 TerminateNotificationProfile_Status
		err := terminateNotificationProfile1.PopulateFromARM(owner, *typedInput.TerminateNotificationProfile)
		if err != nil {
			return err
		}
		terminateNotificationProfile := terminateNotificationProfile1
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromScheduledEventsProfileStatus populates our ScheduledEventsProfile_Status from the provided source ScheduledEventsProfile_Status
func (profile *ScheduledEventsProfile_Status) AssignPropertiesFromScheduledEventsProfileStatus(source *v1alpha1api20201201storage.ScheduledEventsProfile_Status) error {

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile_Status
		err := terminateNotificationProfile.AssignPropertiesFromTerminateNotificationProfileStatus(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromTerminateNotificationProfileStatus() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToScheduledEventsProfileStatus populates the provided destination ScheduledEventsProfile_Status from our ScheduledEventsProfile_Status
func (profile *ScheduledEventsProfile_Status) AssignPropertiesToScheduledEventsProfileStatus(destination *v1alpha1api20201201storage.ScheduledEventsProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile v1alpha1api20201201storage.TerminateNotificationProfile_Status
		err := profile.TerminateNotificationProfile.AssignPropertiesToTerminateNotificationProfileStatus(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToTerminateNotificationProfileStatus() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Automatic","Manual","Rolling"}
type UpgradePolicySpecMode string

const (
	UpgradePolicySpecModeAutomatic = UpgradePolicySpecMode("Automatic")
	UpgradePolicySpecModeManual    = UpgradePolicySpecMode("Manual")
	UpgradePolicySpecModeRolling   = UpgradePolicySpecMode("Rolling")
)

type UpgradePolicyStatusMode string

const (
	UpgradePolicyStatusModeAutomatic = UpgradePolicyStatusMode("Automatic")
	UpgradePolicyStatusModeManual    = UpgradePolicyStatusMode("Manual")
	UpgradePolicyStatusModeRolling   = UpgradePolicyStatusMode("Rolling")
)

type VirtualMachineScaleSetExtensionProfile_Spec struct {
	//ExtensionsTimeBudget: Specifies the time alloted for all extensions to start.
	//The time duration should be between 15 minutes and 120 minutes (inclusive) and
	//should be specified in ISO 8601 format. The default value is 90 minutes
	//(PT1H30M).
	//Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetExtensionProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetExtensionProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetExtensionProfile_SpecARM

	// Set property ‘ExtensionsTimeBudget’:
	if profile.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *profile.ExtensionsTimeBudget
		result.ExtensionsTimeBudget = &extensionsTimeBudget
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetExtensionProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtensionProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetExtensionProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtensionProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetExtensionProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘ExtensionsTimeBudget’:
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		profile.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetExtensionProfileSpec populates our VirtualMachineScaleSetExtensionProfile_Spec from the provided source VirtualMachineScaleSetExtensionProfile_Spec
func (profile *VirtualMachineScaleSetExtensionProfile_Spec) AssignPropertiesFromVirtualMachineScaleSetExtensionProfileSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Spec) error {

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetExtensionProfileSpec populates the provided destination VirtualMachineScaleSetExtensionProfile_Spec from our VirtualMachineScaleSetExtensionProfile_Spec
func (profile *VirtualMachineScaleSetExtensionProfile_Spec) AssignPropertiesToVirtualMachineScaleSetExtensionProfileSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetExtensionProfile_Status struct {
	//Extensions: The virtual machine scale set child extension resources.
	Extensions []VirtualMachineScaleSetExtension_Status_SubResourceEmbedded `json:"extensions,omitempty"`

	//ExtensionsTimeBudget: Specifies the time alloted for all extensions to start.
	//The time duration should be between 15 minutes and 120 minutes (inclusive) and
	//should be specified in ISO 8601 format. The default value is 90 minutes
	//(PT1H30M).
	//Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtensionProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetExtensionProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtensionProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetExtensionProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtensionProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetExtensionProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘Extensions’:
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Extensions = append(profile.Extensions, item1)
	}

	// Set property ‘ExtensionsTimeBudget’:
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		profile.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetExtensionProfileStatus populates our VirtualMachineScaleSetExtensionProfile_Status from the provided source VirtualMachineScaleSetExtensionProfile_Status
func (profile *VirtualMachineScaleSetExtensionProfile_Status) AssignPropertiesFromVirtualMachineScaleSetExtensionProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Status) error {

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineScaleSetExtension_Status_SubResourceEmbedded, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
			err := extension.AssignPropertiesFromVirtualMachineScaleSetExtensionStatusSubResourceEmbedded(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetExtensionStatusSubResourceEmbedded() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		profile.Extensions = extensionList
	} else {
		profile.Extensions = nil
	}

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetExtensionProfileStatus populates the provided destination VirtualMachineScaleSetExtensionProfile_Status from our VirtualMachineScaleSetExtensionProfile_Status
func (profile *VirtualMachineScaleSetExtensionProfile_Status) AssignPropertiesToVirtualMachineScaleSetExtensionProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Extensions
	if profile.Extensions != nil {
		extensionList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status_SubResourceEmbedded, len(profile.Extensions))
		for extensionIndex, extensionItem := range profile.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
			err := extensionItem.AssignPropertiesToVirtualMachineScaleSetExtensionStatusSubResourceEmbedded(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetExtensionStatusSubResourceEmbedded() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities struct {
	//ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIdentity_Status_UserAssignedIdentitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIdentity_Status_UserAssignedIdentitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIdentity_Status_UserAssignedIdentitiesARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIdentityStatusUserAssignedIdentities populates our VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities from the provided source VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
func (identities *VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) AssignPropertiesFromVirtualMachineScaleSetIdentityStatusUserAssignedIdentities(source *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIdentityStatusUserAssignedIdentities populates the provided destination VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities from our VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
func (identities *VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) AssignPropertiesToVirtualMachineScaleSetIdentityStatusUserAssignedIdentities(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetNetworkProfile_Spec struct {
	//HealthProbe: A reference to a load balancer probe used to determine the health
	//of an instance in the virtual machine scale set. The reference will be in the
	//form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}'.
	HealthProbe *ApiEntityReference_Spec `json:"healthProbe,omitempty"`

	//NetworkInterfaceConfigurations: The list of network configurations.
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration_Spec `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetNetworkProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetNetworkProfile_SpecARM

	// Set property ‘HealthProbe’:
	if profile.HealthProbe != nil {
		healthProbeARM, err := (*profile.HealthProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		healthProbe := healthProbeARM.(ApiEntityReference_SpecARM)
		result.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range profile.NetworkInterfaceConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaceConfigurations = append(result.NetworkInterfaceConfigurations, itemARM.(VirtualMachineScaleSetNetworkConfiguration_SpecARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetNetworkProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetNetworkProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘HealthProbe’:
	if typedInput.HealthProbe != nil {
		var healthProbe1 ApiEntityReference_Spec
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		profile.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineScaleSetNetworkConfiguration_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkProfileSpec populates our VirtualMachineScaleSetNetworkProfile_Spec from the provided source VirtualMachineScaleSetNetworkProfile_Spec
func (profile *VirtualMachineScaleSetNetworkProfile_Spec) AssignPropertiesFromVirtualMachineScaleSetNetworkProfileSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Spec) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference_Spec
		err := healthProbe.AssignPropertiesFromApiEntityReferenceSpec(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReferenceSpec() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration_Spec, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration_Spec
			err := networkInterfaceConfiguration.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationSpec(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationSpec() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkProfileSpec populates the provided destination VirtualMachineScaleSetNetworkProfile_Spec from our VirtualMachineScaleSetNetworkProfile_Spec
func (profile *VirtualMachineScaleSetNetworkProfile_Spec) AssignPropertiesToVirtualMachineScaleSetNetworkProfileSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if profile.HealthProbe != nil {
		var healthProbe v1alpha1api20201201storage.ApiEntityReference_Spec
		err := profile.HealthProbe.AssignPropertiesToApiEntityReferenceSpec(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReferenceSpec() to populate field HealthProbe")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Spec, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Spec
			err := networkInterfaceConfigurationItem.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationSpec(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationSpec() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetNetworkProfile_Status struct {
	//HealthProbe: A reference to a load balancer probe used to determine the health
	//of an instance in the virtual machine scale set. The reference will be in the
	//form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}'.
	HealthProbe *ApiEntityReference_Status `json:"healthProbe,omitempty"`

	//NetworkInterfaceConfigurations: The list of network configurations.
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration_Status `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetNetworkProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetNetworkProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘HealthProbe’:
	if typedInput.HealthProbe != nil {
		var healthProbe1 ApiEntityReference_Status
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		profile.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineScaleSetNetworkConfiguration_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkProfileStatus populates our VirtualMachineScaleSetNetworkProfile_Status from the provided source VirtualMachineScaleSetNetworkProfile_Status
func (profile *VirtualMachineScaleSetNetworkProfile_Status) AssignPropertiesFromVirtualMachineScaleSetNetworkProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Status) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference_Status
		err := healthProbe.AssignPropertiesFromApiEntityReferenceStatus(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReferenceStatus() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration_Status, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration_Status
			err := networkInterfaceConfiguration.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationStatus(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationStatus() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkProfileStatus populates the provided destination VirtualMachineScaleSetNetworkProfile_Status from our VirtualMachineScaleSetNetworkProfile_Status
func (profile *VirtualMachineScaleSetNetworkProfile_Status) AssignPropertiesToVirtualMachineScaleSetNetworkProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if profile.HealthProbe != nil {
		var healthProbe v1alpha1api20201201storage.ApiEntityReference_Status
		err := profile.HealthProbe.AssignPropertiesToApiEntityReferenceStatus(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReferenceStatus() to populate field HealthProbe")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status
			err := networkInterfaceConfigurationItem.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationStatus(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationStatus() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetOSProfile_Spec struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length (Windows): 8 characters
	//Minimum-length (Linux): 6 characters
	//Max-length (Windows): 123 characters
	//Max-length (Linux): 72 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	//For resetting the password, see [How to reset the Remote Desktop service or its
	//login password in a Windows
	//VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)
	//For resetting root password, see [Manage users, SSH, and check or repair disks
	//on Azure Linux VMs using the VMAccess
	//Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
	AdminPassword *string `json:"adminPassword,omitempty"`

	//AdminUsername: Specifies the name of the administrator account.
	//Windows-only restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length (Linux): 1  character
	//Max-length (Linux): 64 characters
	//Max-length (Windows): 20 characters
	//<li> For root access to the Linux VM, see [Using root privileges on Linux
	//virtual machines in
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//<li> For a list of built-in system users on Linux that should not be used in
	//this field, see [Selecting User Names for Linux on
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	AdminUsername *string `json:"adminUsername,omitempty"`

	//ComputerNamePrefix: Specifies the computer name prefix for all of the virtual
	//machines in the scale set. Computer name prefixes must be 1 to 15 characters
	//long.
	ComputerNamePrefix *string `json:"computerNamePrefix,omitempty"`

	//CustomData: Specifies a base-64 encoded string of custom data. The base-64
	//encoded string is decoded to a binary array that is saved as a file on the
	//Virtual Machine. The maximum length of the binary array is 65535 bytes.
	//For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM
	//during
	//creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	CustomData *string `json:"customData,omitempty"`

	//LinuxConfiguration: Specifies the Linux operating system settings on the virtual
	//machine.
	//For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//For running non-endorsed distributions, see [Information for Non-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	LinuxConfiguration *LinuxConfiguration_Spec `json:"linuxConfiguration,omitempty"`

	//Secrets: Specifies set of certificates that should be installed onto the virtual
	//machines in the scale set.
	Secrets []VaultSecretGroup_Spec `json:"secrets,omitempty"`

	//WindowsConfiguration: Specifies Windows operating system settings on the virtual
	//machine.
	WindowsConfiguration *WindowsConfiguration_Spec `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetOSProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetOSProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetOSProfile_SpecARM

	// Set property ‘AdminPassword’:
	if profile.AdminPassword != nil {
		adminPassword := *profile.AdminPassword
		result.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if profile.ComputerNamePrefix != nil {
		computerNamePrefix := *profile.ComputerNamePrefix
		result.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if profile.CustomData != nil {
		customData := *profile.CustomData
		result.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if profile.LinuxConfiguration != nil {
		linuxConfigurationARM, err := (*profile.LinuxConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxConfiguration := linuxConfigurationARM.(LinuxConfiguration_SpecARM)
		result.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range profile.Secrets {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, itemARM.(VaultSecretGroup_SpecARM))
	}

	// Set property ‘WindowsConfiguration’:
	if profile.WindowsConfiguration != nil {
		windowsConfigurationARM, err := (*profile.WindowsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsConfiguration := windowsConfigurationARM.(WindowsConfiguration_SpecARM)
		result.WindowsConfiguration = &windowsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetOSProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetOSProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		profile.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		profile.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration_Spec
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration_Spec
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSProfileSpec populates our VirtualMachineScaleSetOSProfile_Spec from the provided source VirtualMachineScaleSetOSProfile_Spec
func (profile *VirtualMachineScaleSetOSProfile_Spec) AssignPropertiesFromVirtualMachineScaleSetOSProfileSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Spec) error {

	// AdminPassword
	profile.AdminPassword = genruntime.ClonePointerToString(source.AdminPassword)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_Spec
		err := linuxConfiguration.AssignPropertiesFromLinuxConfigurationSpec(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfigurationSpec() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_Spec, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_Spec
			err := secret.AssignPropertiesFromVaultSecretGroupSpec(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroupSpec() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_Spec
		err := windowsConfiguration.AssignPropertiesFromWindowsConfigurationSpec(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfigurationSpec() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSProfileSpec populates the provided destination VirtualMachineScaleSetOSProfile_Spec from our VirtualMachineScaleSetOSProfile_Spec
func (profile *VirtualMachineScaleSetOSProfile_Spec) AssignPropertiesToVirtualMachineScaleSetOSProfileSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	destination.AdminPassword = genruntime.ClonePointerToString(profile.AdminPassword)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v1alpha1api20201201storage.LinuxConfiguration_Spec
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfigurationSpec(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfigurationSpec() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v1alpha1api20201201storage.VaultSecretGroup_Spec, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v1alpha1api20201201storage.VaultSecretGroup_Spec
			err := secretItem.AssignPropertiesToVaultSecretGroupSpec(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroupSpec() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v1alpha1api20201201storage.WindowsConfiguration_Spec
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfigurationSpec(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfigurationSpec() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetOSProfile_Status struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length (Windows): 8 characters
	//Minimum-length (Linux): 6 characters
	//Max-length (Windows): 123 characters
	//Max-length (Linux): 72 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	//For resetting the password, see [How to reset the Remote Desktop service or its
	//login password in a Windows
	//VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)
	//For resetting root password, see [Manage users, SSH, and check or repair disks
	//on Azure Linux VMs using the VMAccess
	//Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
	AdminPassword *string `json:"adminPassword,omitempty"`

	//AdminUsername: Specifies the name of the administrator account.
	//Windows-only restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length (Linux): 1  character
	//Max-length (Linux): 64 characters
	//Max-length (Windows): 20 characters
	//<li> For root access to the Linux VM, see [Using root privileges on Linux
	//virtual machines in
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//<li> For a list of built-in system users on Linux that should not be used in
	//this field, see [Selecting User Names for Linux on
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	AdminUsername *string `json:"adminUsername,omitempty"`

	//ComputerNamePrefix: Specifies the computer name prefix for all of the virtual
	//machines in the scale set. Computer name prefixes must be 1 to 15 characters
	//long.
	ComputerNamePrefix *string `json:"computerNamePrefix,omitempty"`

	//CustomData: Specifies a base-64 encoded string of custom data. The base-64
	//encoded string is decoded to a binary array that is saved as a file on the
	//Virtual Machine. The maximum length of the binary array is 65535 bytes.
	//For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM
	//during
	//creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	CustomData *string `json:"customData,omitempty"`

	//LinuxConfiguration: Specifies the Linux operating system settings on the virtual
	//machine.
	//For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//For running non-endorsed distributions, see [Information for Non-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	LinuxConfiguration *LinuxConfiguration_Status `json:"linuxConfiguration,omitempty"`

	//Secrets: Specifies set of certificates that should be installed onto the virtual
	//machines in the scale set.
	Secrets []VaultSecretGroup_Status `json:"secrets,omitempty"`

	//WindowsConfiguration: Specifies Windows operating system settings on the virtual
	//machine.
	WindowsConfiguration *WindowsConfiguration_Status `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetOSProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetOSProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		profile.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		profile.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration_Status
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration_Status
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSProfileStatus populates our VirtualMachineScaleSetOSProfile_Status from the provided source VirtualMachineScaleSetOSProfile_Status
func (profile *VirtualMachineScaleSetOSProfile_Status) AssignPropertiesFromVirtualMachineScaleSetOSProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Status) error {

	// AdminPassword
	profile.AdminPassword = genruntime.ClonePointerToString(source.AdminPassword)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_Status
		err := linuxConfiguration.AssignPropertiesFromLinuxConfigurationStatus(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfigurationStatus() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_Status, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_Status
			err := secret.AssignPropertiesFromVaultSecretGroupStatus(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroupStatus() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_Status
		err := windowsConfiguration.AssignPropertiesFromWindowsConfigurationStatus(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfigurationStatus() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSProfileStatus populates the provided destination VirtualMachineScaleSetOSProfile_Status from our VirtualMachineScaleSetOSProfile_Status
func (profile *VirtualMachineScaleSetOSProfile_Status) AssignPropertiesToVirtualMachineScaleSetOSProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	destination.AdminPassword = genruntime.ClonePointerToString(profile.AdminPassword)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v1alpha1api20201201storage.LinuxConfiguration_Status
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfigurationStatus(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfigurationStatus() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v1alpha1api20201201storage.VaultSecretGroup_Status, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v1alpha1api20201201storage.VaultSecretGroup_Status
			err := secretItem.AssignPropertiesToVaultSecretGroupStatus(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroupStatus() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v1alpha1api20201201storage.WindowsConfiguration_Status
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfigurationStatus(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfigurationStatus() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetStorageProfile_Spec struct {
	//DataDisks: Specifies the parameters that are used to add data disks to the
	//virtual machines in the scale set.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	DataDisks []VirtualMachineScaleSetDataDisk_Spec `json:"dataDisks,omitempty"`

	//ImageReference: Specifies information about the image to use. You can specify
	//information about platform images, marketplace images, or virtual machine
	//images. This element is required when you want to use a platform image,
	//marketplace image, or virtual machine image, but is not used in other creation
	//operations.
	ImageReference *ImageReference_Spec `json:"imageReference,omitempty"`

	//OsDisk: Specifies information about the operating system disk used by the
	//virtual machines in the scale set.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	OsDisk *VirtualMachineScaleSetOSDisk_Spec `json:"osDisk,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetStorageProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetStorageProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetStorageProfile_SpecARM

	// Set property ‘DataDisks’:
	for _, item := range profile.DataDisks {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DataDisks = append(result.DataDisks, itemARM.(VirtualMachineScaleSetDataDisk_SpecARM))
	}

	// Set property ‘ImageReference’:
	if profile.ImageReference != nil {
		imageReferenceARM, err := (*profile.ImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageReference := imageReferenceARM.(ImageReference_SpecARM)
		result.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if profile.OsDisk != nil {
		osDiskARM, err := (*profile.OsDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osDisk := osDiskARM.(VirtualMachineScaleSetOSDisk_SpecARM)
		result.OsDisk = &osDisk
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetStorageProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetStorageProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetStorageProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetStorageProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetStorageProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 VirtualMachineScaleSetDataDisk_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference_Spec
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 VirtualMachineScaleSetOSDisk_Spec
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetStorageProfileSpec populates our VirtualMachineScaleSetStorageProfile_Spec from the provided source VirtualMachineScaleSetStorageProfile_Spec
func (profile *VirtualMachineScaleSetStorageProfile_Spec) AssignPropertiesFromVirtualMachineScaleSetStorageProfileSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Spec) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk_Spec, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk_Spec
			err := dataDisk.AssignPropertiesFromVirtualMachineScaleSetDataDiskSpec(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetDataDiskSpec() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_Spec
		err := imageReference.AssignPropertiesFromImageReferenceSpec(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReferenceSpec() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk_Spec
		err := osDisk.AssignPropertiesFromVirtualMachineScaleSetOSDiskSpec(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSDiskSpec() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetStorageProfileSpec populates the provided destination VirtualMachineScaleSetStorageProfile_Spec from our VirtualMachineScaleSetStorageProfile_Spec
func (profile *VirtualMachineScaleSetStorageProfile_Spec) AssignPropertiesToVirtualMachineScaleSetStorageProfileSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Spec, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Spec
			err := dataDiskItem.AssignPropertiesToVirtualMachineScaleSetDataDiskSpec(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetDataDiskSpec() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v1alpha1api20201201storage.ImageReference_Spec
		err := profile.ImageReference.AssignPropertiesToImageReferenceSpec(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReferenceSpec() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Spec
		err := profile.OsDisk.AssignPropertiesToVirtualMachineScaleSetOSDiskSpec(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSDiskSpec() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetStorageProfile_Status struct {
	//DataDisks: Specifies the parameters that are used to add data disks to the
	//virtual machines in the scale set.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	DataDisks []VirtualMachineScaleSetDataDisk_Status `json:"dataDisks,omitempty"`

	//ImageReference: Specifies information about the image to use. You can specify
	//information about platform images, marketplace images, or virtual machine
	//images. This element is required when you want to use a platform image,
	//marketplace image, or virtual machine image, but is not used in other creation
	//operations.
	ImageReference *ImageReference_Status `json:"imageReference,omitempty"`

	//OsDisk: Specifies information about the operating system disk used by the
	//virtual machines in the scale set.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	OsDisk *VirtualMachineScaleSetOSDisk_Status `json:"osDisk,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetStorageProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetStorageProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetStorageProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetStorageProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetStorageProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetStorageProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 VirtualMachineScaleSetDataDisk_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference_Status
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 VirtualMachineScaleSetOSDisk_Status
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetStorageProfileStatus populates our VirtualMachineScaleSetStorageProfile_Status from the provided source VirtualMachineScaleSetStorageProfile_Status
func (profile *VirtualMachineScaleSetStorageProfile_Status) AssignPropertiesFromVirtualMachineScaleSetStorageProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Status) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk_Status, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk_Status
			err := dataDisk.AssignPropertiesFromVirtualMachineScaleSetDataDiskStatus(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetDataDiskStatus() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_Status
		err := imageReference.AssignPropertiesFromImageReferenceStatus(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReferenceStatus() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk_Status
		err := osDisk.AssignPropertiesFromVirtualMachineScaleSetOSDiskStatus(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSDiskStatus() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetStorageProfileStatus populates the provided destination VirtualMachineScaleSetStorageProfile_Status from our VirtualMachineScaleSetStorageProfile_Status
func (profile *VirtualMachineScaleSetStorageProfile_Status) AssignPropertiesToVirtualMachineScaleSetStorageProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status
			err := dataDiskItem.AssignPropertiesToVirtualMachineScaleSetDataDiskStatus(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetDataDiskStatus() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v1alpha1api20201201storage.ImageReference_Status
		err := profile.ImageReference.AssignPropertiesToImageReferenceStatus(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReferenceStatus() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Status
		err := profile.OsDisk.AssignPropertiesToVirtualMachineScaleSetOSDiskStatus(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSDiskStatus() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApiEntityReference_Spec struct {
	//Reference: The ARM resource id in the form of
	///subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiEntityReference_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ApiEntityReference_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	var result ApiEntityReference_SpecARM

	// Set property ‘Id’:
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ApiEntityReference_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiEntityReference_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ApiEntityReference_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ApiEntityReference_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiEntityReference_SpecARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromApiEntityReferenceSpec populates our ApiEntityReference_Spec from the provided source ApiEntityReference_Spec
func (reference *ApiEntityReference_Spec) AssignPropertiesFromApiEntityReferenceSpec(source *v1alpha1api20201201storage.ApiEntityReference_Spec) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApiEntityReferenceSpec populates the provided destination ApiEntityReference_Spec from our ApiEntityReference_Spec
func (reference *ApiEntityReference_Spec) AssignPropertiesToApiEntityReferenceSpec(destination *v1alpha1api20201201storage.ApiEntityReference_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApiEntityReference_Status struct {
	//Id: The ARM resource id in the form of
	///subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiEntityReference_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ApiEntityReference_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiEntityReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ApiEntityReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiEntityReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiEntityReference_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromApiEntityReferenceStatus populates our ApiEntityReference_Status from the provided source ApiEntityReference_Status
func (reference *ApiEntityReference_Status) AssignPropertiesFromApiEntityReferenceStatus(source *v1alpha1api20201201storage.ApiEntityReference_Status) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToApiEntityReferenceStatus populates the provided destination ApiEntityReference_Status from our ApiEntityReference_Status
func (reference *ApiEntityReference_Status) AssignPropertiesToApiEntityReferenceStatus(destination *v1alpha1api20201201storage.ApiEntityReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type TerminateNotificationProfile_Spec struct {
	//Enable: Specifies whether the Terminate Scheduled event is enabled or disabled.
	Enable *bool `json:"enable,omitempty"`

	//NotBeforeTimeout: Configurable length of time a Virtual Machine being deleted
	//will have to potentially approve the Terminate Scheduled Event before the event
	//is auto approved (timed out). The configuration must be specified in ISO 8601
	//format, the default value is 5 minutes (PT5M)
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

var _ genruntime.ARMTransformer = &TerminateNotificationProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *TerminateNotificationProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	var result TerminateNotificationProfile_SpecARM

	// Set property ‘Enable’:
	if profile.Enable != nil {
		enable := *profile.Enable
		result.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if profile.NotBeforeTimeout != nil {
		notBeforeTimeout := *profile.NotBeforeTimeout
		result.NotBeforeTimeout = &notBeforeTimeout
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TerminateNotificationProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TerminateNotificationProfile_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TerminateNotificationProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TerminateNotificationProfile_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TerminateNotificationProfile_SpecARM, got %T", armInput)
	}

	// Set property ‘Enable’:
	if typedInput.Enable != nil {
		enable := *typedInput.Enable
		profile.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if typedInput.NotBeforeTimeout != nil {
		notBeforeTimeout := *typedInput.NotBeforeTimeout
		profile.NotBeforeTimeout = &notBeforeTimeout
	}

	// No error
	return nil
}

// AssignPropertiesFromTerminateNotificationProfileSpec populates our TerminateNotificationProfile_Spec from the provided source TerminateNotificationProfile_Spec
func (profile *TerminateNotificationProfile_Spec) AssignPropertiesFromTerminateNotificationProfileSpec(source *v1alpha1api20201201storage.TerminateNotificationProfile_Spec) error {

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// No error
	return nil
}

// AssignPropertiesToTerminateNotificationProfileSpec populates the provided destination TerminateNotificationProfile_Spec from our TerminateNotificationProfile_Spec
func (profile *TerminateNotificationProfile_Spec) AssignPropertiesToTerminateNotificationProfileSpec(destination *v1alpha1api20201201storage.TerminateNotificationProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type TerminateNotificationProfile_Status struct {
	//Enable: Specifies whether the Terminate Scheduled event is enabled or disabled.
	Enable *bool `json:"enable,omitempty"`

	//NotBeforeTimeout: Configurable length of time a Virtual Machine being deleted
	//will have to potentially approve the Terminate Scheduled Event before the event
	//is auto approved (timed out). The configuration must be specified in ISO 8601
	//format, the default value is 5 minutes (PT5M)
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

var _ genruntime.FromARMConverter = &TerminateNotificationProfile_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TerminateNotificationProfile_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TerminateNotificationProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TerminateNotificationProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TerminateNotificationProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TerminateNotificationProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘Enable’:
	if typedInput.Enable != nil {
		enable := *typedInput.Enable
		profile.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if typedInput.NotBeforeTimeout != nil {
		notBeforeTimeout := *typedInput.NotBeforeTimeout
		profile.NotBeforeTimeout = &notBeforeTimeout
	}

	// No error
	return nil
}

// AssignPropertiesFromTerminateNotificationProfileStatus populates our TerminateNotificationProfile_Status from the provided source TerminateNotificationProfile_Status
func (profile *TerminateNotificationProfile_Status) AssignPropertiesFromTerminateNotificationProfileStatus(source *v1alpha1api20201201storage.TerminateNotificationProfile_Status) error {

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// No error
	return nil
}

// AssignPropertiesToTerminateNotificationProfileStatus populates the provided destination TerminateNotificationProfile_Status from our TerminateNotificationProfile_Status
func (profile *TerminateNotificationProfile_Status) AssignPropertiesToTerminateNotificationProfileStatus(destination *v1alpha1api20201201storage.TerminateNotificationProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetDataDisk_Spec struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_Spec `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: The create option.
	CreateOption CreateOption_Spec `json:"createOption"`

	//DiskIOPSReadWrite: Specifies the Read-Write IOPS for the managed disk. Should be
	//used only when StorageAccountType is UltraSSD_LRS. If not specified, a default
	//value would be assigned based on diskSizeGB.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	//DiskMBpsReadWrite: Specifies the bandwidth in MB per second for the managed
	//disk. Should be used only when StorageAccountType is UltraSSD_LRS. If not
	//specified, a default value would be assigned based on diskSizeGB.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	//DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element
	//can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// +kubebuilder:validation:Required
	//Lun: Specifies the logical unit number of the data disk. This value is used to
	//identify data disks within the VM and therefore must be unique for each data
	//disk attached to a VM.
	Lun int `json:"lun"`

	//ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters_Spec `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetDataDisk_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *VirtualMachineScaleSetDataDisk_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetDataDisk_SpecARM

	// Set property ‘Caching’:
	if disk.Caching != nil {
		caching := *disk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	result.CreateOption = disk.CreateOption

	// Set property ‘DiskIOPSReadWrite’:
	if disk.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *disk.DiskIOPSReadWrite
		result.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if disk.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *disk.DiskMBpsReadWrite
		result.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	result.Lun = disk.Lun

	// Set property ‘ManagedDisk’:
	if disk.ManagedDisk != nil {
		managedDiskARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := managedDiskARM.(VirtualMachineScaleSetManagedDiskParameters_SpecARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetDataDisk_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetDataDisk_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetDataDisk_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetDataDisk_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetDataDisk_SpecARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	disk.CreateOption = typedInput.CreateOption

	// Set property ‘DiskIOPSReadWrite’:
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		disk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		disk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	disk.Lun = typedInput.Lun

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_Spec
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetDataDiskSpec populates our VirtualMachineScaleSetDataDisk_Spec from the provided source VirtualMachineScaleSetDataDisk_Spec
func (disk *VirtualMachineScaleSetDataDisk_Spec) AssignPropertiesFromVirtualMachineScaleSetDataDiskSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Spec) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_Spec(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		disk.CreateOption = CreateOption_Spec(*source.CreateOption)
	} else {
		disk.CreateOption = ""
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.GetOptionalIntValue(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_Spec
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSpec(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSpec() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetDataDiskSpec populates the provided destination VirtualMachineScaleSetDataDisk_Spec from our VirtualMachineScaleSetDataDisk_Spec
func (disk *VirtualMachineScaleSetDataDisk_Spec) AssignPropertiesToVirtualMachineScaleSetDataDiskSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(disk.CreateOption)
	destination.CreateOption = &createOption

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	lun := disk.Lun
	destination.Lun = &lun

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Spec
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSpec(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSpec() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetDataDisk_Status struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_Status `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: The create option.
	CreateOption CreateOption_Status `json:"createOption"`

	//DiskIOPSReadWrite: Specifies the Read-Write IOPS for the managed disk. Should be
	//used only when StorageAccountType is UltraSSD_LRS. If not specified, a default
	//value would be assigned based on diskSizeGB.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	//DiskMBpsReadWrite: Specifies the bandwidth in MB per second for the managed
	//disk. Should be used only when StorageAccountType is UltraSSD_LRS. If not
	//specified, a default value would be assigned based on diskSizeGB.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	//DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element
	//can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// +kubebuilder:validation:Required
	//Lun: Specifies the logical unit number of the data disk. This value is used to
	//identify data disks within the VM and therefore must be unique for each data
	//disk attached to a VM.
	Lun int `json:"lun"`

	//ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters_Status `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetDataDisk_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetDataDisk_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetDataDisk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetDataDisk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetDataDisk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetDataDisk_StatusARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	disk.CreateOption = typedInput.CreateOption

	// Set property ‘DiskIOPSReadWrite’:
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		disk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		disk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	disk.Lun = typedInput.Lun

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_Status
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetDataDiskStatus populates our VirtualMachineScaleSetDataDisk_Status from the provided source VirtualMachineScaleSetDataDisk_Status
func (disk *VirtualMachineScaleSetDataDisk_Status) AssignPropertiesFromVirtualMachineScaleSetDataDiskStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_Status(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		disk.CreateOption = CreateOption_Status(*source.CreateOption)
	} else {
		disk.CreateOption = ""
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.GetOptionalIntValue(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_Status
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetDataDiskStatus populates the provided destination VirtualMachineScaleSetDataDisk_Status from our VirtualMachineScaleSetDataDisk_Status
func (disk *VirtualMachineScaleSetDataDisk_Status) AssignPropertiesToVirtualMachineScaleSetDataDiskStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(disk.CreateOption)
	destination.CreateOption = &createOption

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	lun := disk.Lun
	destination.Lun = &lun

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetExtension_Status_SubResourceEmbedded struct {
	//Id: Resource Id
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtension_Status_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetExtension_Status_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetExtensionStatusSubResourceEmbedded populates our VirtualMachineScaleSetExtension_Status_SubResourceEmbedded from the provided source VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
func (embedded *VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) AssignPropertiesFromVirtualMachineScaleSetExtensionStatusSubResourceEmbedded(source *v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetExtensionStatusSubResourceEmbedded populates the provided destination VirtualMachineScaleSetExtension_Status_SubResourceEmbedded from our VirtualMachineScaleSetExtension_Status_SubResourceEmbedded
func (embedded *VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) AssignPropertiesToVirtualMachineScaleSetExtensionStatusSubResourceEmbedded(destination *v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetNetworkConfiguration_Spec struct {
	//DnsSettings: The dns settings to be applied on the network interfaces.
	DnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec `json:"dnsSettings,omitempty"`

	//EnableAcceleratedNetworking: Specifies whether the network interface is
	//accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	//EnableFpga: Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	//EnableIPForwarding: Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	//IpConfigurations: Specifies the IP configurations of the network interface.
	IpConfigurations []VirtualMachineScaleSetIPConfiguration_Spec `json:"ipConfigurations,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The network configuration name.
	Name string `json:"name"`

	//NetworkSecurityGroup: The network security group.
	NetworkSecurityGroup *SubResource_Spec `json:"networkSecurityGroup,omitempty"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkConfiguration_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetNetworkConfiguration_SpecARM

	// Set property ‘Id’:
	if configuration.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*configuration.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	result.Name = configuration.Name

	// Set property ‘Properties’:
	if configuration.DnsSettings != nil ||
		configuration.EnableAcceleratedNetworking != nil ||
		configuration.EnableFpga != nil ||
		configuration.EnableIPForwarding != nil ||
		configuration.IpConfigurations != nil ||
		configuration.NetworkSecurityGroup != nil ||
		configuration.Primary != nil {
		result.Properties = &VirtualMachineScaleSetNetworkConfigurationProperties_SpecARM{}
	}
	if configuration.DnsSettings != nil {
		dnsSettingsARM, err := (*configuration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := dnsSettingsARM.(VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		result.Properties.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	}
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		result.Properties.EnableFpga = &enableFpga
	}
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		result.Properties.EnableIPForwarding = &enableIPForwarding
	}
	for _, item := range configuration.IpConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, itemARM.(VirtualMachineScaleSetIPConfiguration_SpecARM))
	}
	if configuration.NetworkSecurityGroup != nil {
		networkSecurityGroupARM, err := (*configuration.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := networkSecurityGroupARM.(SubResource_SpecARM)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if configuration.Primary != nil {
		primary := *configuration.Primary
		result.Properties.Primary = &primary
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfiguration_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfiguration_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfiguration_SpecARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableFpga’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configuration.EnableFpga = &enableFpga
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configuration.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSetIPConfiguration_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	configuration.Name = typedInput.Name

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource_Spec
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configuration.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationSpec populates our VirtualMachineScaleSetNetworkConfiguration_Spec from the provided source VirtualMachineScaleSetNetworkConfiguration_Spec
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Spec) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Spec) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsSpec(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsSpec() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration_Spec, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration_Spec
			err := ipConfiguration.AssignPropertiesFromVirtualMachineScaleSetIPConfigurationSpec(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIPConfigurationSpec() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.GetOptionalStringValue(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource_Spec
		err := networkSecurityGroup.AssignPropertiesFromSubResourceSpec(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationSpec populates the provided destination VirtualMachineScaleSetNetworkConfiguration_Spec from our VirtualMachineScaleSetNetworkConfiguration_Spec
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Spec) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsSpec(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsSpec() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Spec, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Spec
			err := ipConfigurationItem.AssignPropertiesToVirtualMachineScaleSetIPConfigurationSpec(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIPConfigurationSpec() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	name := configuration.Name
	destination.Name = &name

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var networkSecurityGroup v1alpha1api20201201storage.SubResource_Spec
		err := configuration.NetworkSecurityGroup.AssignPropertiesToSubResourceSpec(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetNetworkConfiguration_Status struct {
	//DnsSettings: The dns settings to be applied on the network interfaces.
	DnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status `json:"dnsSettings,omitempty"`

	//EnableAcceleratedNetworking: Specifies whether the network interface is
	//accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	//EnableFpga: Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	//EnableIPForwarding: Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//IpConfigurations: Specifies the IP configurations of the network interface.
	IpConfigurations []VirtualMachineScaleSetIPConfiguration_Status `json:"ipConfigurations,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The network configuration name.
	Name string `json:"name"`

	//NetworkSecurityGroup: The network security group.
	NetworkSecurityGroup *SubResource_Status `json:"networkSecurityGroup,omitempty"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableFpga’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configuration.EnableFpga = &enableFpga
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configuration.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSetIPConfiguration_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	configuration.Name = typedInput.Name

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource_Status
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configuration.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationStatus populates our VirtualMachineScaleSetNetworkConfiguration_Status from the provided source VirtualMachineScaleSetNetworkConfiguration_Status
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Status) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration_Status, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration_Status
			err := ipConfiguration.AssignPropertiesFromVirtualMachineScaleSetIPConfigurationStatus(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIPConfigurationStatus() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.GetOptionalStringValue(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource_Status
		err := networkSecurityGroup.AssignPropertiesFromSubResourceStatus(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationStatus populates the provided destination VirtualMachineScaleSetNetworkConfiguration_Status from our VirtualMachineScaleSetNetworkConfiguration_Status
func (configuration *VirtualMachineScaleSetNetworkConfiguration_Status) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status
			err := ipConfigurationItem.AssignPropertiesToVirtualMachineScaleSetIPConfigurationStatus(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIPConfigurationStatus() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	name := configuration.Name
	destination.Name = &name

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var networkSecurityGroup v1alpha1api20201201storage.SubResource_Status
		err := configuration.NetworkSecurityGroup.AssignPropertiesToSubResourceStatus(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetOSDisk_Spec struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_Spec `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: Specifies how the virtual machines in the scale set should be
	//created.
	//The only allowed value is: FromImage \u2013 This value is used when you are
	//using an image to create the virtual machine. If you are using a platform image,
	//you also use the imageReference element described above. If you are using a
	//marketplace image, you  also use the plan element previously described.
	CreateOption CreateOption_Spec `json:"createOption"`

	//DiffDiskSettings: Specifies the ephemeral disk Settings for the operating system
	//disk used by the virtual machine scale set.
	DiffDiskSettings *DiffDiskSettings_Spec `json:"diffDiskSettings,omitempty"`

	//DiskSizeGB: Specifies the size of the operating system disk in gigabytes. This
	//element can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//Image: Specifies information about the unmanaged user image to base the scale
	//set on.
	Image *VirtualHardDisk_Spec `json:"image,omitempty"`

	//ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters_Spec `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//OsType: This property allows you to specify the type of the OS that is included
	//in the disk if creating a VM from user-image or a specialized VHD.
	//Possible values are:
	//Windows
	//Linux
	OsType *VirtualMachineScaleSetOSDiskSpecOsType `json:"osType,omitempty"`

	//VhdContainers: Specifies the container urls that are used to store operating
	//system disks for the scale set.
	VhdContainers []string `json:"vhdContainers,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetOSDisk_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *VirtualMachineScaleSetOSDisk_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetOSDisk_SpecARM

	// Set property ‘Caching’:
	if disk.Caching != nil {
		caching := *disk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	result.CreateOption = disk.CreateOption

	// Set property ‘DiffDiskSettings’:
	if disk.DiffDiskSettings != nil {
		diffDiskSettingsARM, err := (*disk.DiffDiskSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diffDiskSettings := diffDiskSettingsARM.(DiffDiskSettings_SpecARM)
		result.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if disk.Image != nil {
		imageARM, err := (*disk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := imageARM.(VirtualHardDisk_SpecARM)
		result.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if disk.ManagedDisk != nil {
		managedDiskARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := managedDiskARM.(VirtualMachineScaleSetManagedDiskParameters_SpecARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property ‘OsType’:
	if disk.OsType != nil {
		osType := *disk.OsType
		result.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range disk.VhdContainers {
		result.VhdContainers = append(result.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetOSDisk_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSDisk_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetOSDisk_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSDisk_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSDisk_SpecARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	disk.CreateOption = typedInput.CreateOption

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings_Spec
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_Spec
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_Spec
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		disk.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range typedInput.VhdContainers {
		disk.VhdContainers = append(disk.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSDiskSpec populates our VirtualMachineScaleSetOSDisk_Spec from the provided source VirtualMachineScaleSetOSDisk_Spec
func (disk *VirtualMachineScaleSetOSDisk_Spec) AssignPropertiesFromVirtualMachineScaleSetOSDiskSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Spec) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_Spec(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		disk.CreateOption = CreateOption_Spec(*source.CreateOption)
	} else {
		disk.CreateOption = ""
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_Spec
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettingsSpec(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettingsSpec() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_Spec
		err := image.AssignPropertiesFromVirtualHardDiskSpec(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSpec() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_Spec
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSpec(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSpec() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := VirtualMachineScaleSetOSDiskSpecOsType(*source.OsType)
		disk.OsType = &osType
	} else {
		disk.OsType = nil
	}

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSDiskSpec populates the provided destination VirtualMachineScaleSetOSDisk_Spec from our VirtualMachineScaleSetOSDisk_Spec
func (disk *VirtualMachineScaleSetOSDisk_Spec) AssignPropertiesToVirtualMachineScaleSetOSDiskSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(disk.CreateOption)
	destination.CreateOption = &createOption

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v1alpha1api20201201storage.DiffDiskSettings_Spec
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettingsSpec(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettingsSpec() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v1alpha1api20201201storage.VirtualHardDisk_Spec
		err := disk.Image.AssignPropertiesToVirtualHardDiskSpec(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSpec() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Spec
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSpec(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSpec() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// VhdContainers
	destination.VhdContainers = genruntime.CloneSliceOfString(disk.VhdContainers)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetOSDisk_Status struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_Status `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: Specifies how the virtual machines in the scale set should be
	//created.
	//The only allowed value is: FromImage \u2013 This value is used when you are
	//using an image to create the virtual machine. If you are using a platform image,
	//you also use the imageReference element described above. If you are using a
	//marketplace image, you  also use the plan element previously described.
	CreateOption CreateOption_Status `json:"createOption"`

	//DiffDiskSettings: Specifies the ephemeral disk Settings for the operating system
	//disk used by the virtual machine scale set.
	DiffDiskSettings *DiffDiskSettings_Status `json:"diffDiskSettings,omitempty"`

	//DiskSizeGB: Specifies the size of the operating system disk in gigabytes. This
	//element can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//Image: Specifies information about the unmanaged user image to base the scale
	//set on.
	Image *VirtualHardDisk_Status `json:"image,omitempty"`

	//ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters_Status `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//OsType: This property allows you to specify the type of the OS that is included
	//in the disk if creating a VM from user-image or a specialized VHD.
	//Possible values are:
	//Windows
	//Linux
	OsType *VirtualMachineScaleSetOSDiskStatusOsType `json:"osType,omitempty"`

	//VhdContainers: Specifies the container urls that are used to store operating
	//system disks for the scale set.
	VhdContainers []string `json:"vhdContainers,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSDisk_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetOSDisk_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSDisk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetOSDisk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSDisk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSDisk_StatusARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	disk.CreateOption = typedInput.CreateOption

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings_Status
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_Status
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_Status
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		disk.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range typedInput.VhdContainers {
		disk.VhdContainers = append(disk.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSDiskStatus populates our VirtualMachineScaleSetOSDisk_Status from the provided source VirtualMachineScaleSetOSDisk_Status
func (disk *VirtualMachineScaleSetOSDisk_Status) AssignPropertiesFromVirtualMachineScaleSetOSDiskStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Status) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_Status(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		disk.CreateOption = CreateOption_Status(*source.CreateOption)
	} else {
		disk.CreateOption = ""
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_Status
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettingsStatus(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettingsStatus() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_Status
		err := image.AssignPropertiesFromVirtualHardDiskStatus(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskStatus() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_Status
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := VirtualMachineScaleSetOSDiskStatusOsType(*source.OsType)
		disk.OsType = &osType
	} else {
		disk.OsType = nil
	}

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSDiskStatus populates the provided destination VirtualMachineScaleSetOSDisk_Status from our VirtualMachineScaleSetOSDisk_Status
func (disk *VirtualMachineScaleSetOSDisk_Status) AssignPropertiesToVirtualMachineScaleSetOSDiskStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(disk.CreateOption)
	destination.CreateOption = &createOption

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v1alpha1api20201201storage.DiffDiskSettings_Status
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettingsStatus(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettingsStatus() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v1alpha1api20201201storage.VirtualHardDisk_Status
		err := disk.Image.AssignPropertiesToVirtualHardDiskStatus(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskStatus() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// VhdContainers
	destination.VhdContainers = genruntime.CloneSliceOfString(disk.VhdContainers)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetIPConfiguration_Spec struct {
	//ApplicationGatewayBackendAddressPools: Specifies an array of references to
	//backend address pools of application gateways. A scale set can reference backend
	//address pools of multiple application gateways. Multiple scale sets cannot use
	//the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource_Spec `json:"applicationGatewayBackendAddressPools,omitempty"`

	//ApplicationSecurityGroups: Specifies an array of references to application
	//security group.
	ApplicationSecurityGroups []SubResource_Spec `json:"applicationSecurityGroups,omitempty"`

	//LoadBalancerBackendAddressPools: Specifies an array of references to backend
	//address pools of load balancers. A scale set can reference backend address pools
	//of one public and one internal load balancer. Multiple scale sets cannot use the
	//same basic sku load balancer.
	LoadBalancerBackendAddressPools []SubResource_Spec `json:"loadBalancerBackendAddressPools,omitempty"`

	//LoadBalancerInboundNatPools: Specifies an array of references to inbound Nat
	//pools of the load balancers. A scale set can reference inbound nat pools of one
	//public and one internal load balancer. Multiple scale sets cannot use the same
	//basic sku load balancer.
	LoadBalancerInboundNatPools []SubResource_Spec `json:"loadBalancerInboundNatPools,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The IP configuration name.
	Name string `json:"name"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	//PrivateIPAddressVersion: Available from Api-Version 2017-03-30 onwards, it
	//represents whether the specific ipconfiguration is IPv4 or IPv6. Default is
	//taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *VirtualMachineScaleSetIPConfigurationPropertiesSpecPrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`

	//PublicIPAddressConfiguration: The publicIPAddressConfiguration.
	PublicIPAddressConfiguration *VirtualMachineScaleSetPublicIPAddressConfiguration_Spec `json:"publicIPAddressConfiguration,omitempty"`

	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Subnet: Specifies the identifier of the subnet.
	Subnet *ApiEntityReference_Spec `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIPConfiguration_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetIPConfiguration_SpecARM

	// Set property ‘Id’:
	if configuration.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*configuration.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	result.Name = configuration.Name

	// Set property ‘Properties’:
	if configuration.ApplicationGatewayBackendAddressPools != nil ||
		configuration.ApplicationSecurityGroups != nil ||
		configuration.LoadBalancerBackendAddressPools != nil ||
		configuration.LoadBalancerInboundNatPools != nil ||
		configuration.Primary != nil ||
		configuration.PrivateIPAddressVersion != nil ||
		configuration.PublicIPAddressConfiguration != nil ||
		configuration.Subnet != nil {
		result.Properties = &VirtualMachineScaleSetIPConfigurationProperties_SpecARM{}
	}
	for _, item := range configuration.ApplicationGatewayBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayBackendAddressPools = append(result.Properties.ApplicationGatewayBackendAddressPools, itemARM.(SubResource_SpecARM))
	}
	for _, item := range configuration.ApplicationSecurityGroups {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationSecurityGroups = append(result.Properties.ApplicationSecurityGroups, itemARM.(SubResource_SpecARM))
	}
	for _, item := range configuration.LoadBalancerBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddressPools = append(result.Properties.LoadBalancerBackendAddressPools, itemARM.(SubResource_SpecARM))
	}
	for _, item := range configuration.LoadBalancerInboundNatPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerInboundNatPools = append(result.Properties.LoadBalancerInboundNatPools, itemARM.(SubResource_SpecARM))
	}
	if configuration.Primary != nil {
		primary := *configuration.Primary
		result.Properties.Primary = &primary
	}
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *configuration.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if configuration.PublicIPAddressConfiguration != nil {
		publicIPAddressConfigurationARM, err := (*configuration.PublicIPAddressConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddressConfiguration := publicIPAddressConfigurationARM.(VirtualMachineScaleSetPublicIPAddressConfiguration_SpecARM)
		result.Properties.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	}
	if configuration.Subnet != nil {
		subnetARM, err := (*configuration.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(ApiEntityReference_SpecARM)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetIPConfiguration_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIPConfiguration_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIPConfiguration_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIPConfiguration_SpecARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationGatewayBackendAddressPools = append(configuration.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationSecurityGroups = append(configuration.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerBackendAddressPools = append(configuration.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
			var item1 SubResource_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerInboundNatPools = append(configuration.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property ‘Name’:
	configuration.Name = typedInput.Name

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PublicIPAddressConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachineScaleSetPublicIPAddressConfiguration_Spec
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 ApiEntityReference_Spec
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIPConfigurationSpec populates our VirtualMachineScaleSetIPConfiguration_Spec from the provided source VirtualMachineScaleSetIPConfiguration_Spec
func (configuration *VirtualMachineScaleSetIPConfiguration_Spec) AssignPropertiesFromVirtualMachineScaleSetIPConfigurationSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Spec) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource_Spec, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource_Spec
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromSubResourceSpec(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource_Spec, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource_Spec
			err := applicationSecurityGroup.AssignPropertiesFromSubResourceSpec(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource_Spec, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource_Spec
			err := loadBalancerBackendAddressPool.AssignPropertiesFromSubResourceSpec(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource_Spec, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource_Spec
			err := loadBalancerInboundNatPool.AssignPropertiesFromSubResourceSpec(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.GetOptionalStringValue(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := VirtualMachineScaleSetIPConfigurationPropertiesSpecPrivateIPAddressVersion(*source.PrivateIPAddressVersion)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration_Spec
		err := publicIPAddressConfiguration.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationSpec(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationSpec() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference_Spec
		err := subnet.AssignPropertiesFromApiEntityReferenceSpec(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReferenceSpec() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIPConfigurationSpec populates the provided destination VirtualMachineScaleSetIPConfiguration_Spec from our VirtualMachineScaleSetIPConfiguration_Spec
func (configuration *VirtualMachineScaleSetIPConfiguration_Spec) AssignPropertiesToVirtualMachineScaleSetIPConfigurationSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v1alpha1api20201201storage.SubResource_Spec, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool v1alpha1api20201201storage.SubResource_Spec
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToSubResourceSpec(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v1alpha1api20201201storage.SubResource_Spec, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup v1alpha1api20201201storage.SubResource_Spec
			err := applicationSecurityGroupItem.AssignPropertiesToSubResourceSpec(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v1alpha1api20201201storage.SubResource_Spec, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool v1alpha1api20201201storage.SubResource_Spec
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToSubResourceSpec(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configuration.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]v1alpha1api20201201storage.SubResource_Spec, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool v1alpha1api20201201storage.SubResource_Spec
			err := loadBalancerInboundNatPoolItem.AssignPropertiesToSubResourceSpec(&loadBalancerInboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	name := configuration.Name
	destination.Name = &name

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Spec
		err := configuration.PublicIPAddressConfiguration.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationSpec(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationSpec() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet v1alpha1api20201201storage.ApiEntityReference_Spec
		err := configuration.Subnet.AssignPropertiesToApiEntityReferenceSpec(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReferenceSpec() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetIPConfiguration_Status struct {
	//ApplicationGatewayBackendAddressPools: Specifies an array of references to
	//backend address pools of application gateways. A scale set can reference backend
	//address pools of multiple application gateways. Multiple scale sets cannot use
	//the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource_Status `json:"applicationGatewayBackendAddressPools,omitempty"`

	//ApplicationSecurityGroups: Specifies an array of references to application
	//security group.
	ApplicationSecurityGroups []SubResource_Status `json:"applicationSecurityGroups,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//LoadBalancerBackendAddressPools: Specifies an array of references to backend
	//address pools of load balancers. A scale set can reference backend address pools
	//of one public and one internal load balancer. Multiple scale sets cannot use the
	//same basic sku load balancer.
	LoadBalancerBackendAddressPools []SubResource_Status `json:"loadBalancerBackendAddressPools,omitempty"`

	//LoadBalancerInboundNatPools: Specifies an array of references to inbound Nat
	//pools of the load balancers. A scale set can reference inbound nat pools of one
	//public and one internal load balancer. Multiple scale sets cannot use the same
	//basic sku load balancer.
	LoadBalancerInboundNatPools []SubResource_Status `json:"loadBalancerInboundNatPools,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The IP configuration name.
	Name string `json:"name"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	//PrivateIPAddressVersion: Available from Api-Version 2017-03-30 onwards, it
	//represents whether the specific ipconfiguration is IPv4 or IPv6. Default is
	//taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`

	//PublicIPAddressConfiguration: The publicIPAddressConfiguration.
	PublicIPAddressConfiguration *VirtualMachineScaleSetPublicIPAddressConfiguration_Status `json:"publicIPAddressConfiguration,omitempty"`

	//Subnet: Specifies the identifier of the subnet.
	Subnet *ApiEntityReference_Status `json:"subnet,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIPConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetIPConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIPConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIPConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIPConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationGatewayBackendAddressPools = append(configuration.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationSecurityGroups = append(configuration.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerBackendAddressPools = append(configuration.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerInboundNatPools = append(configuration.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property ‘Name’:
	configuration.Name = typedInput.Name

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PublicIPAddressConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachineScaleSetPublicIPAddressConfiguration_Status
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 ApiEntityReference_Status
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIPConfigurationStatus populates our VirtualMachineScaleSetIPConfiguration_Status from the provided source VirtualMachineScaleSetIPConfiguration_Status
func (configuration *VirtualMachineScaleSetIPConfiguration_Status) AssignPropertiesFromVirtualMachineScaleSetIPConfigurationStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource_Status, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource_Status
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromSubResourceStatus(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource_Status, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource_Status
			err := applicationSecurityGroup.AssignPropertiesFromSubResourceStatus(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource_Status, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource_Status
			err := loadBalancerBackendAddressPool.AssignPropertiesFromSubResourceStatus(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource_Status, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource_Status
			err := loadBalancerInboundNatPool.AssignPropertiesFromSubResourceStatus(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.GetOptionalStringValue(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion(*source.PrivateIPAddressVersion)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration_Status
		err := publicIPAddressConfiguration.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationStatus(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationStatus() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference_Status
		err := subnet.AssignPropertiesFromApiEntityReferenceStatus(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReferenceStatus() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIPConfigurationStatus populates the provided destination VirtualMachineScaleSetIPConfiguration_Status from our VirtualMachineScaleSetIPConfiguration_Status
func (configuration *VirtualMachineScaleSetIPConfiguration_Status) AssignPropertiesToVirtualMachineScaleSetIPConfigurationStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v1alpha1api20201201storage.SubResource_Status, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool v1alpha1api20201201storage.SubResource_Status
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToSubResourceStatus(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v1alpha1api20201201storage.SubResource_Status, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup v1alpha1api20201201storage.SubResource_Status
			err := applicationSecurityGroupItem.AssignPropertiesToSubResourceStatus(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v1alpha1api20201201storage.SubResource_Status, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool v1alpha1api20201201storage.SubResource_Status
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToSubResourceStatus(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configuration.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]v1alpha1api20201201storage.SubResource_Status, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool v1alpha1api20201201storage.SubResource_Status
			err := loadBalancerInboundNatPoolItem.AssignPropertiesToSubResourceStatus(&loadBalancerInboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	name := configuration.Name
	destination.Name = &name

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Status
		err := configuration.PublicIPAddressConfiguration.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationStatus(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationStatus() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet v1alpha1api20201201storage.ApiEntityReference_Status
		err := configuration.Subnet.AssignPropertiesToApiEntityReferenceStatus(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReferenceStatus() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetManagedDiskParameters_Spec struct {
	//DiskEncryptionSet: Specifies the customer managed disk encryption set resource
	//id for the managed disk.
	DiskEncryptionSet *SubResource_Spec `json:"diskEncryptionSet,omitempty"`

	//StorageAccountType: Specifies the storage account type for the managed disk.
	//NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS
	//Disk.
	StorageAccountType *StorageAccountType_Spec `json:"storageAccountType,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetManagedDiskParameters_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetManagedDiskParameters_SpecARM

	// Set property ‘DiskEncryptionSet’:
	if parameters.DiskEncryptionSet != nil {
		diskEncryptionSetARM, err := (*parameters.DiskEncryptionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionSet := diskEncryptionSetARM.(SubResource_SpecARM)
		result.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if parameters.StorageAccountType != nil {
		storageAccountType := *parameters.StorageAccountType
		result.StorageAccountType = &storageAccountType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetManagedDiskParameters_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetManagedDiskParameters_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetManagedDiskParameters_SpecARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_Spec
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSpec populates our VirtualMachineScaleSetManagedDiskParameters_Spec from the provided source VirtualMachineScaleSetManagedDiskParameters_Spec
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Spec) AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Spec) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_Spec
		err := diskEncryptionSet.AssignPropertiesFromSubResourceSpec(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := StorageAccountType_Spec(*source.StorageAccountType)
		parameters.StorageAccountType = &storageAccountType
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSpec populates the provided destination VirtualMachineScaleSetManagedDiskParameters_Spec from our VirtualMachineScaleSetManagedDiskParameters_Spec
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Spec) AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet v1alpha1api20201201storage.SubResource_Spec
		err := parameters.DiskEncryptionSet.AssignPropertiesToSubResourceSpec(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetManagedDiskParameters_Status struct {
	//DiskEncryptionSet: Specifies the customer managed disk encryption set resource
	//id for the managed disk.
	DiskEncryptionSet *SubResource_Status `json:"diskEncryptionSet,omitempty"`

	//StorageAccountType: Specifies the storage account type for the managed disk.
	//NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS
	//Disk.
	StorageAccountType *StorageAccountType_Status `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetManagedDiskParameters_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetManagedDiskParameters_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetManagedDiskParameters_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetManagedDiskParameters_StatusARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_Status
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus populates our VirtualMachineScaleSetManagedDiskParameters_Status from the provided source VirtualMachineScaleSetManagedDiskParameters_Status
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Status) AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_Status
		err := diskEncryptionSet.AssignPropertiesFromSubResourceStatus(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := StorageAccountType_Status(*source.StorageAccountType)
		parameters.StorageAccountType = &storageAccountType
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus populates the provided destination VirtualMachineScaleSetManagedDiskParameters_Status from our VirtualMachineScaleSetManagedDiskParameters_Status
func (parameters *VirtualMachineScaleSetManagedDiskParameters_Status) AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet v1alpha1api20201201storage.SubResource_Status
		err := parameters.DiskEncryptionSet.AssignPropertiesToSubResourceStatus(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec struct {
	//DnsServers: List of DNS servers IP addresses
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecARM

	// Set property ‘DnsServers’:
	for _, item := range settings.DnsServers {
		result.DnsServers = append(result.DnsServers, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfigurationDnsSettings_SpecARM, got %T", armInput)
	}

	// Set property ‘DnsServers’:
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsSpec populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsSpec populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec from our VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status struct {
	//DnsServers: List of DNS servers IP addresses
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsServers’:
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status from our VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type VirtualMachineScaleSetOSDiskSpecOsType string

const (
	VirtualMachineScaleSetOSDiskSpecOsTypeLinux   = VirtualMachineScaleSetOSDiskSpecOsType("Linux")
	VirtualMachineScaleSetOSDiskSpecOsTypeWindows = VirtualMachineScaleSetOSDiskSpecOsType("Windows")
)

type VirtualMachineScaleSetOSDiskStatusOsType string

const (
	VirtualMachineScaleSetOSDiskStatusOsTypeLinux   = VirtualMachineScaleSetOSDiskStatusOsType("Linux")
	VirtualMachineScaleSetOSDiskStatusOsTypeWindows = VirtualMachineScaleSetOSDiskStatusOsType("Windows")
)

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetIPConfigurationPropertiesSpecPrivateIPAddressVersion string

const (
	VirtualMachineScaleSetIPConfigurationPropertiesSpecPrivateIPAddressVersionIPv4 = VirtualMachineScaleSetIPConfigurationPropertiesSpecPrivateIPAddressVersion("IPv4")
	VirtualMachineScaleSetIPConfigurationPropertiesSpecPrivateIPAddressVersionIPv6 = VirtualMachineScaleSetIPConfigurationPropertiesSpecPrivateIPAddressVersion("IPv6")
)

type VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion string

const (
	VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersionIPv4 = VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion("IPv4")
	VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersionIPv6 = VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion("IPv6")
)

type VirtualMachineScaleSetPublicIPAddressConfiguration_Spec struct {
	//DnsSettings: The dns settings to be applied on the publicIP addresses .
	DnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec `json:"dnsSettings,omitempty"`

	//IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//IpTags: The list of IP tags associated with the public IP address.
	IpTags []VirtualMachineScaleSetIpTag_Spec `json:"ipTags,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The publicIP address configuration name.
	Name string `json:"name"`

	//PublicIPAddressVersion: Available from Api-Version 2019-07-01 onwards, it
	//represents whether the specific ipconfiguration is IPv4 or IPv6. Default is
	//taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSpecPublicIPAddressVersion `json:"publicIPAddressVersion,omitempty"`

	//PublicIPPrefix: The PublicIPPrefix from which to allocate publicIP addresses.
	PublicIPPrefix *SubResource_Spec `json:"publicIPPrefix,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetPublicIPAddressConfiguration_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetPublicIPAddressConfiguration_SpecARM

	// Set property ‘Name’:
	result.Name = configuration.Name

	// Set property ‘Properties’:
	if configuration.DnsSettings != nil ||
		configuration.IdleTimeoutInMinutes != nil ||
		configuration.IpTags != nil ||
		configuration.PublicIPAddressVersion != nil ||
		configuration.PublicIPPrefix != nil {
		result.Properties = &VirtualMachineScaleSetPublicIPAddressConfigurationProperties_SpecARM{}
	}
	if configuration.DnsSettings != nil {
		dnsSettingsARM, err := (*configuration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := dnsSettingsARM.(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if configuration.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *configuration.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	for _, item := range configuration.IpTags {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpTags = append(result.Properties.IpTags, itemARM.(VirtualMachineScaleSetIpTag_SpecARM))
	}
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *configuration.PublicIPAddressVersion
		result.Properties.PublicIPAddressVersion = &publicIPAddressVersion
	}
	if configuration.PublicIPPrefix != nil {
		publicIPPrefixARM, err := (*configuration.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := publicIPPrefixARM.(SubResource_SpecARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfiguration_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfiguration_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfiguration_SpecARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag_Spec
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property ‘Name’:
	configuration.Name = typedInput.Name

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Spec
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationSpec populates our VirtualMachineScaleSetPublicIPAddressConfiguration_Spec from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration_Spec
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSpec(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSpec() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag_Spec, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag_Spec
			err := ipTag.AssignPropertiesFromVirtualMachineScaleSetIpTagSpec(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIpTagSpec() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.GetOptionalStringValue(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSpecPublicIPAddressVersion(*source.PublicIPAddressVersion)
		configuration.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Spec
		err := publicIPPrefix.AssignPropertiesFromSubResourceSpec(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSpec() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationSpec populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration_Spec from our VirtualMachineScaleSetPublicIPAddressConfiguration_Spec
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSpec(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSpec() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Spec, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Spec
			err := ipTagItem.AssignPropertiesToVirtualMachineScaleSetIpTagSpec(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIpTagSpec() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	name := configuration.Name
	destination.Name = &name

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201201storage.SubResource_Spec
		err := configuration.PublicIPPrefix.AssignPropertiesToSubResourceSpec(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSpec() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetPublicIPAddressConfiguration_Status struct {
	//DnsSettings: The dns settings to be applied on the publicIP addresses .
	DnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status `json:"dnsSettings,omitempty"`

	//IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//IpTags: The list of IP tags associated with the public IP address.
	IpTags []VirtualMachineScaleSetIpTag_Status `json:"ipTags,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The publicIP address configuration name.
	Name string `json:"name"`

	//PublicIPAddressVersion: Available from Api-Version 2019-07-01 onwards, it
	//represents whether the specific ipconfiguration is IPv4 or IPv6. Default is
	//taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion `json:"publicIPAddressVersion,omitempty"`

	//PublicIPPrefix: The PublicIPPrefix from which to allocate publicIP addresses.
	PublicIPPrefix *SubResource_Status `json:"publicIPPrefix,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfiguration_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property ‘Name’:
	configuration.Name = typedInput.Name

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Status
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationStatus populates our VirtualMachineScaleSetPublicIPAddressConfiguration_Status from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration_Status
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Status) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Status) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag_Status, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag_Status
			err := ipTag.AssignPropertiesFromVirtualMachineScaleSetIpTagStatus(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIpTagStatus() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.GetOptionalStringValue(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion(*source.PublicIPAddressVersion)
		configuration.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Status
		err := publicIPPrefix.AssignPropertiesFromSubResourceStatus(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceStatus() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationStatus populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration_Status from our VirtualMachineScaleSetPublicIPAddressConfiguration_Status
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_Status) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status
			err := ipTagItem.AssignPropertiesToVirtualMachineScaleSetIpTagStatus(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIpTagStatus() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	name := configuration.Name
	destination.Name = &name

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201201storage.SubResource_Status
		err := configuration.PublicIPPrefix.AssignPropertiesToSubResourceStatus(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceStatus() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetIpTag_Spec struct {
	//IpTagType: IP tag type. Example: FirstPartyUsage.
	IpTagType *string `json:"ipTagType,omitempty"`

	//Tag: IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIpTag_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ipTag *VirtualMachineScaleSetIpTag_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ipTag == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetIpTag_SpecARM

	// Set property ‘IpTagType’:
	if ipTag.IpTagType != nil {
		ipTagType := *ipTag.IpTagType
		result.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if ipTag.Tag != nil {
		tag := *ipTag.Tag
		result.Tag = &tag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipTag *VirtualMachineScaleSetIpTag_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIpTag_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipTag *VirtualMachineScaleSetIpTag_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIpTag_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIpTag_SpecARM, got %T", armInput)
	}

	// Set property ‘IpTagType’:
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		ipTag.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		ipTag.Tag = &tag
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIpTagSpec populates our VirtualMachineScaleSetIpTag_Spec from the provided source VirtualMachineScaleSetIpTag_Spec
func (ipTag *VirtualMachineScaleSetIpTag_Spec) AssignPropertiesFromVirtualMachineScaleSetIpTagSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Spec) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIpTagSpec populates the provided destination VirtualMachineScaleSetIpTag_Spec from our VirtualMachineScaleSetIpTag_Spec
func (ipTag *VirtualMachineScaleSetIpTag_Spec) AssignPropertiesToVirtualMachineScaleSetIpTagSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetIpTag_Status struct {
	//IpTagType: IP tag type. Example: FirstPartyUsage.
	IpTagType *string `json:"ipTagType,omitempty"`

	//Tag: IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIpTag_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipTag *VirtualMachineScaleSetIpTag_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIpTag_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipTag *VirtualMachineScaleSetIpTag_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIpTag_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIpTag_StatusARM, got %T", armInput)
	}

	// Set property ‘IpTagType’:
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		ipTag.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		ipTag.Tag = &tag
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIpTagStatus populates our VirtualMachineScaleSetIpTag_Status from the provided source VirtualMachineScaleSetIpTag_Status
func (ipTag *VirtualMachineScaleSetIpTag_Status) AssignPropertiesFromVirtualMachineScaleSetIpTagStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIpTagStatus populates the provided destination VirtualMachineScaleSetIpTag_Status from our VirtualMachineScaleSetIpTag_Status
func (ipTag *VirtualMachineScaleSetIpTag_Status) AssignPropertiesToVirtualMachineScaleSetIpTagStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec struct {
	// +kubebuilder:validation:Required
	//DomainNameLabel: The Domain name label.The concatenation of the domain name
	//label and vm index will be the domain name labels of the PublicIPAddress
	//resources that will be created
	DomainNameLabel string `json:"domainNameLabel"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecARM

	// Set property ‘DomainNameLabel’:
	result.DomainNameLabel = settings.DomainNameLabel
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_SpecARM, got %T", armInput)
	}

	// Set property ‘DomainNameLabel’:
	settings.DomainNameLabel = typedInput.DomainNameLabel

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSpec populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) error {

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.GetOptionalStringValue(source.DomainNameLabel)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSpec populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	domainNameLabel := settings.DomainNameLabel
	destination.DomainNameLabel = &domainNameLabel

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status struct {
	// +kubebuilder:validation:Required
	//DomainNameLabel: The Domain name label.The concatenation of the domain name
	//label and vm index will be the domain name labels of the PublicIPAddress
	//resources that will be created
	DomainNameLabel string `json:"domainNameLabel"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘DomainNameLabel’:
	settings.DomainNameLabel = typedInput.DomainNameLabel

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) error {

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.GetOptionalStringValue(source.DomainNameLabel)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	domainNameLabel := settings.DomainNameLabel
	destination.DomainNameLabel = &domainNameLabel

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSpecPublicIPAddressVersion string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSpecPublicIPAddressVersionIPv4 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSpecPublicIPAddressVersion("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSpecPublicIPAddressVersionIPv6 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSpecPublicIPAddressVersion("IPv6")
)

type VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersionIPv4 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersionIPv6 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion("IPv6")
)

func init() {
	SchemeBuilder.Register(&VirtualMachineScaleSet{}, &VirtualMachineScaleSetList{})
}
