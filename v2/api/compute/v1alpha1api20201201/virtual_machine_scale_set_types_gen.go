// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"fmt"
	alpha20201201s "github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Deprecated version of VirtualMachineScaleSet. Use v1beta20201201.VirtualMachineScaleSet instead
type VirtualMachineScaleSet struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
<<<<<<< HEAD
	Spec              VirtualMachineScaleSet_Spec   `json:"spec,omitempty"`
=======
	Spec              VirtualMachineScaleSets_Spec  `json:"spec,omitempty"`
>>>>>>> main
	Status            VirtualMachineScaleSet_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachineScaleSet{}

// GetConditions returns the conditions of the resource
func (scaleSet *VirtualMachineScaleSet) GetConditions() conditions.Conditions {
	return scaleSet.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (scaleSet *VirtualMachineScaleSet) SetConditions(conditions conditions.Conditions) {
	scaleSet.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachineScaleSet{}

// ConvertFrom populates our VirtualMachineScaleSet from the provided hub VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source alpha20201201s.VirtualMachineScaleSet

	err := source.ConvertFrom(hub)
	if err != nil {
		return errors.Wrap(err, "converting from hub to source")
	}

	err = scaleSet.AssignPropertiesFromVirtualMachineScaleSet(&source)
	if err != nil {
		return errors.Wrap(err, "converting from source to scaleSet")
	}

	return nil
}

// ConvertTo populates the provided hub VirtualMachineScaleSet from our VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination alpha20201201s.VirtualMachineScaleSet
	err := scaleSet.AssignPropertiesToVirtualMachineScaleSet(&destination)
	if err != nil {
		return errors.Wrap(err, "converting to destination from scaleSet")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return errors.Wrap(err, "converting from destination to hub")
	}

	return nil
}

// +kubebuilder:webhook:path=/mutate-compute-azure-com-v1alpha1api20201201-virtualmachinescaleset,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachinescalesets,verbs=create;update,versions=v1alpha1api20201201,name=default.v1alpha1api20201201.virtualmachinescalesets.compute.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &VirtualMachineScaleSet{}

// Default applies defaults to the VirtualMachineScaleSet resource
func (scaleSet *VirtualMachineScaleSet) Default() {
	scaleSet.defaultImpl()
	var temp interface{} = scaleSet
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (scaleSet *VirtualMachineScaleSet) defaultAzureName() {
	if scaleSet.Spec.AzureName == "" {
		scaleSet.Spec.AzureName = scaleSet.Name
	}
}

// defaultImpl applies the code generated defaults to the VirtualMachineScaleSet resource
func (scaleSet *VirtualMachineScaleSet) defaultImpl() { scaleSet.defaultAzureName() }

var _ genruntime.KubernetesResource = &VirtualMachineScaleSet{}

// AzureName returns the Azure name of the resource
func (scaleSet *VirtualMachineScaleSet) AzureName() string {
	return scaleSet.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-12-01"
func (scaleSet VirtualMachineScaleSet) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (scaleSet *VirtualMachineScaleSet) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (scaleSet *VirtualMachineScaleSet) GetSpec() genruntime.ConvertibleSpec {
	return &scaleSet.Spec
}

// GetStatus returns the status of this resource
func (scaleSet *VirtualMachineScaleSet) GetStatus() genruntime.ConvertibleStatus {
	return &scaleSet.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachineScaleSets"
func (scaleSet *VirtualMachineScaleSet) GetType() string {
	return "Microsoft.Compute/virtualMachineScaleSets"
}

// NewEmptyStatus returns a new empty (blank) status
func (scaleSet *VirtualMachineScaleSet) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachineScaleSet_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (scaleSet *VirtualMachineScaleSet) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(scaleSet.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  scaleSet.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (scaleSet *VirtualMachineScaleSet) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachineScaleSet_STATUS); ok {
		scaleSet.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachineScaleSet_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	scaleSet.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-compute-azure-com-v1alpha1api20201201-virtualmachinescaleset,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachinescalesets,verbs=create;update,versions=v1alpha1api20201201,name=validate.v1alpha1api20201201.virtualmachinescalesets.compute.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &VirtualMachineScaleSet{}

// ValidateCreate validates the creation of the resource
func (scaleSet *VirtualMachineScaleSet) ValidateCreate() error {
	validations := scaleSet.createValidations()
	var temp interface{} = scaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (scaleSet *VirtualMachineScaleSet) ValidateDelete() error {
	validations := scaleSet.deleteValidations()
	var temp interface{} = scaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (scaleSet *VirtualMachineScaleSet) ValidateUpdate(old runtime.Object) error {
	validations := scaleSet.updateValidations()
	var temp interface{} = scaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (scaleSet *VirtualMachineScaleSet) createValidations() []func() error {
	return []func() error{scaleSet.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (scaleSet *VirtualMachineScaleSet) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (scaleSet *VirtualMachineScaleSet) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return scaleSet.validateResourceReferences()
		},
		scaleSet.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (scaleSet *VirtualMachineScaleSet) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&scaleSet.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (scaleSet *VirtualMachineScaleSet) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*VirtualMachineScaleSet)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, scaleSet)
}

// AssignPropertiesFromVirtualMachineScaleSet populates our VirtualMachineScaleSet from the provided source VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) AssignPropertiesFromVirtualMachineScaleSet(source *alpha20201201s.VirtualMachineScaleSet) error {

	// ObjectMeta
	scaleSet.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachineScaleSet_Spec
	err := spec.AssignPropertiesFromVirtualMachineScaleSet_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSet_Spec() to populate field Spec")
	}
	scaleSet.Spec = spec

	// Status
	var status VirtualMachineScaleSet_STATUS
<<<<<<< HEAD
	err = status.AssignPropertiesFromVirtualMachineScaleSet_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSet_STATUS() to populate field Status")
=======
	err = status.AssignPropertiesFromVirtualMachineScaleSetSTATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetSTATUS() to populate field Status")
>>>>>>> main
	}
	scaleSet.Status = status

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSet populates the provided destination VirtualMachineScaleSet from our VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) AssignPropertiesToVirtualMachineScaleSet(destination *alpha20201201s.VirtualMachineScaleSet) error {

	// ObjectMeta
	destination.ObjectMeta = *scaleSet.ObjectMeta.DeepCopy()

	// Spec
	var spec alpha20201201s.VirtualMachineScaleSet_Spec
	err := scaleSet.Spec.AssignPropertiesToVirtualMachineScaleSet_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSet_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status alpha20201201s.VirtualMachineScaleSet_STATUS
<<<<<<< HEAD
	err = scaleSet.Status.AssignPropertiesToVirtualMachineScaleSet_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSet_STATUS() to populate field Status")
=======
	err = scaleSet.Status.AssignPropertiesToVirtualMachineScaleSetSTATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetSTATUS() to populate field Status")
>>>>>>> main
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (scaleSet *VirtualMachineScaleSet) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: scaleSet.Spec.OriginalVersion(),
		Kind:    "VirtualMachineScaleSet",
	}
}

// +kubebuilder:object:root=true
// Deprecated version of VirtualMachineScaleSet. Use v1beta20201201.VirtualMachineScaleSet instead
type VirtualMachineScaleSetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachineScaleSet `json:"items"`
}

// Deprecated version of VirtualMachineScaleSet_STATUS. Use v1beta20201201.VirtualMachineScaleSet_STATUS instead
type VirtualMachineScaleSet_STATUS struct {
	AdditionalCapabilities *AdditionalCapabilities_STATUS `json:"additionalCapabilities,omitempty"`
	AutomaticRepairsPolicy *AutomaticRepairsPolicy_STATUS `json:"automaticRepairsPolicy,omitempty"`

	// Conditions: The observed state of the resource
	Conditions                             []conditions.Condition                  `json:"conditions,omitempty"`
	DoNotRunExtensionsOnOverprovisionedVMs *bool                                   `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`
	ExtendedLocation                       *ExtendedLocation_STATUS                `json:"extendedLocation,omitempty"`
	HostGroup                              *SubResource_STATUS                     `json:"hostGroup,omitempty"`
	Id                                     *string                                 `json:"id,omitempty"`
	Identity                               *VirtualMachineScaleSetIdentity_STATUS  `json:"identity,omitempty"`
	Location                               *string                                 `json:"location,omitempty"`
	Name                                   *string                                 `json:"name,omitempty"`
	OrchestrationMode                      *OrchestrationMode_STATUS               `json:"orchestrationMode,omitempty"`
	Overprovision                          *bool                                   `json:"overprovision,omitempty"`
	Plan                                   *Plan_STATUS                            `json:"plan,omitempty"`
	PlatformFaultDomainCount               *int                                    `json:"platformFaultDomainCount,omitempty"`
	ProvisioningState                      *string                                 `json:"provisioningState,omitempty"`
	ProximityPlacementGroup                *SubResource_STATUS                     `json:"proximityPlacementGroup,omitempty"`
	ScaleInPolicy                          *ScaleInPolicy_STATUS                   `json:"scaleInPolicy,omitempty"`
	SinglePlacementGroup                   *bool                                   `json:"singlePlacementGroup,omitempty"`
	Sku                                    *Sku_STATUS                             `json:"sku,omitempty"`
	Tags                                   map[string]string                       `json:"tags,omitempty"`
	Type                                   *string                                 `json:"type,omitempty"`
	UniqueId                               *string                                 `json:"uniqueId,omitempty"`
	UpgradePolicy                          *UpgradePolicy_STATUS                   `json:"upgradePolicy,omitempty"`
	VirtualMachineProfile                  *VirtualMachineScaleSetVMProfile_STATUS `json:"virtualMachineProfile,omitempty"`
	ZoneBalance                            *bool                                   `json:"zoneBalance,omitempty"`
	Zones                                  []string                                `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachineScaleSet_STATUS{}

// ConvertStatusFrom populates our VirtualMachineScaleSet_STATUS from the provided source
func (scaleSet *VirtualMachineScaleSet_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*alpha20201201s.VirtualMachineScaleSet_STATUS)
	if ok {
		// Populate our instance from source
<<<<<<< HEAD
		return scaleSet.AssignPropertiesFromVirtualMachineScaleSet_STATUS(src)
=======
		return scaleSet.AssignPropertiesFromVirtualMachineScaleSetSTATUS(src)
>>>>>>> main
	}

	// Convert to an intermediate form
	src = &alpha20201201s.VirtualMachineScaleSet_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
<<<<<<< HEAD
	err = scaleSet.AssignPropertiesFromVirtualMachineScaleSet_STATUS(src)
=======
	err = scaleSet.AssignPropertiesFromVirtualMachineScaleSetSTATUS(src)
>>>>>>> main
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*alpha20201201s.VirtualMachineScaleSet_STATUS)
	if ok {
		// Populate destination from our instance
<<<<<<< HEAD
		return scaleSet.AssignPropertiesToVirtualMachineScaleSet_STATUS(dst)
=======
		return scaleSet.AssignPropertiesToVirtualMachineScaleSetSTATUS(dst)
>>>>>>> main
	}

	// Convert to an intermediate form
	dst = &alpha20201201s.VirtualMachineScaleSet_STATUS{}
<<<<<<< HEAD
	err := scaleSet.AssignPropertiesToVirtualMachineScaleSet_STATUS(dst)
=======
	err := scaleSet.AssignPropertiesToVirtualMachineScaleSetSTATUS(dst)
>>>>>>> main
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaleSet *VirtualMachineScaleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSet_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaleSet *VirtualMachineScaleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSet_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSet_STATUSARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities_STATUS
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			scaleSet.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property ‘AutomaticRepairsPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticRepairsPolicy != nil {
			var automaticRepairsPolicy1 AutomaticRepairsPolicy_STATUS
			err := automaticRepairsPolicy1.PopulateFromARM(owner, *typedInput.Properties.AutomaticRepairsPolicy)
			if err != nil {
				return err
			}
			automaticRepairsPolicy := automaticRepairsPolicy1
			scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DoNotRunExtensionsOnOverprovisionedVMs’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs != nil {
			doNotRunExtensionsOnOverprovisionedVMs := *typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs
			scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		scaleSet.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource_STATUS
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			scaleSet.HostGroup = &hostGroup
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		scaleSet.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineScaleSetIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		scaleSet.Identity = &identity
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		scaleSet.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		scaleSet.Name = &name
	}

	// Set property ‘OrchestrationMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OrchestrationMode != nil {
			orchestrationMode := *typedInput.Properties.OrchestrationMode
			scaleSet.OrchestrationMode = &orchestrationMode
		}
	}

	// Set property ‘Overprovision’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Overprovision != nil {
			overprovision := *typedInput.Properties.Overprovision
			scaleSet.Overprovision = &overprovision
		}
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan_STATUS
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		scaleSet.Plan = &plan
	}

	// Set property ‘PlatformFaultDomainCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomainCount != nil {
			platformFaultDomainCount := *typedInput.Properties.PlatformFaultDomainCount
			scaleSet.PlatformFaultDomainCount = &platformFaultDomainCount
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			scaleSet.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource_STATUS
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property ‘ScaleInPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScaleInPolicy != nil {
			var scaleInPolicy1 ScaleInPolicy_STATUS
			err := scaleInPolicy1.PopulateFromARM(owner, *typedInput.Properties.ScaleInPolicy)
			if err != nil {
				return err
			}
			scaleInPolicy := scaleInPolicy1
			scaleSet.ScaleInPolicy = &scaleInPolicy
		}
	}

	// Set property ‘SinglePlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SinglePlacementGroup != nil {
			singlePlacementGroup := *typedInput.Properties.SinglePlacementGroup
			scaleSet.SinglePlacementGroup = &singlePlacementGroup
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		scaleSet.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		scaleSet.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			scaleSet.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		scaleSet.Type = &typeVar
	}

	// Set property ‘UniqueId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UniqueId != nil {
			uniqueId := *typedInput.Properties.UniqueId
			scaleSet.UniqueId = &uniqueId
		}
	}

	// Set property ‘UpgradePolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradePolicy != nil {
			var upgradePolicy1 UpgradePolicy_STATUS
			err := upgradePolicy1.PopulateFromARM(owner, *typedInput.Properties.UpgradePolicy)
			if err != nil {
				return err
			}
			upgradePolicy := upgradePolicy1
			scaleSet.UpgradePolicy = &upgradePolicy
		}
	}

	// Set property ‘VirtualMachineProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineProfile != nil {
			var virtualMachineProfile1 VirtualMachineScaleSetVMProfile_STATUS
			err := virtualMachineProfile1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineProfile)
			if err != nil {
				return err
			}
			virtualMachineProfile := virtualMachineProfile1
			scaleSet.VirtualMachineProfile = &virtualMachineProfile
		}
	}

	// Set property ‘ZoneBalance’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneBalance != nil {
			zoneBalance := *typedInput.Properties.ZoneBalance
			scaleSet.ZoneBalance = &zoneBalance
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		scaleSet.Zones = append(scaleSet.Zones, item)
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSet_STATUS populates our VirtualMachineScaleSet_STATUS from the provided source VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) AssignPropertiesFromVirtualMachineScaleSet_STATUS(source *alpha20201201s.VirtualMachineScaleSet_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetSTATUS populates our VirtualMachineScaleSet_STATUS from the provided source VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) AssignPropertiesFromVirtualMachineScaleSetSTATUS(source *alpha20201201s.VirtualMachineScaleSet_STATUS) error {
>>>>>>> main

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_STATUS
<<<<<<< HEAD
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilities_STATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
=======
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilitiesSTATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilitiesSTATUS() to populate field AdditionalCapabilities")
>>>>>>> main
		}
		scaleSet.AdditionalCapabilities = &additionalCapability
	} else {
		scaleSet.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy_STATUS
<<<<<<< HEAD
		err := automaticRepairsPolicy.AssignPropertiesFromAutomaticRepairsPolicy_STATUS(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticRepairsPolicy_STATUS() to populate field AutomaticRepairsPolicy")
=======
		err := automaticRepairsPolicy.AssignPropertiesFromAutomaticRepairsPolicySTATUS(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticRepairsPolicySTATUS() to populate field AutomaticRepairsPolicy")
>>>>>>> main
		}
		scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		scaleSet.AutomaticRepairsPolicy = nil
	}

	// Conditions
	scaleSet.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
<<<<<<< HEAD
		err := extendedLocation.AssignPropertiesFromExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_STATUS() to populate field ExtendedLocation")
=======
		err := extendedLocation.AssignPropertiesFromExtendedLocationSTATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationSTATUS() to populate field ExtendedLocation")
>>>>>>> main
		}
		scaleSet.ExtendedLocation = &extendedLocation
	} else {
		scaleSet.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_STATUS
<<<<<<< HEAD
		err := hostGroup.AssignPropertiesFromSubResource_STATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field HostGroup")
=======
		err := hostGroup.AssignPropertiesFromSubResourceSTATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field HostGroup")
>>>>>>> main
		}
		scaleSet.HostGroup = &hostGroup
	} else {
		scaleSet.HostGroup = nil
	}

	// Id
	scaleSet.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity_STATUS
<<<<<<< HEAD
		err := identity.AssignPropertiesFromVirtualMachineScaleSetIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIdentity_STATUS() to populate field Identity")
=======
		err := identity.AssignPropertiesFromVirtualMachineScaleSetIdentitySTATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIdentitySTATUS() to populate field Identity")
>>>>>>> main
		}
		scaleSet.Identity = &identity
	} else {
		scaleSet.Identity = nil
	}

	// Location
	scaleSet.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	scaleSet.Name = genruntime.ClonePointerToString(source.Name)

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := OrchestrationMode_STATUS(*source.OrchestrationMode)
		scaleSet.OrchestrationMode = &orchestrationMode
	} else {
		scaleSet.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		scaleSet.Overprovision = &overprovision
	} else {
		scaleSet.Overprovision = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
<<<<<<< HEAD
		err := plan.AssignPropertiesFromPlan_STATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlan_STATUS() to populate field Plan")
=======
		err := plan.AssignPropertiesFromPlanSTATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlanSTATUS() to populate field Plan")
>>>>>>> main
		}
		scaleSet.Plan = &plan
	} else {
		scaleSet.Plan = nil
	}

	// PlatformFaultDomainCount
	scaleSet.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProvisioningState
	scaleSet.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_STATUS
<<<<<<< HEAD
		err := proximityPlacementGroup.AssignPropertiesFromSubResource_STATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field ProximityPlacementGroup")
=======
		err := proximityPlacementGroup.AssignPropertiesFromSubResourceSTATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field ProximityPlacementGroup")
>>>>>>> main
		}
		scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		scaleSet.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy_STATUS
<<<<<<< HEAD
		err := scaleInPolicy.AssignPropertiesFromScaleInPolicy_STATUS(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScaleInPolicy_STATUS() to populate field ScaleInPolicy")
=======
		err := scaleInPolicy.AssignPropertiesFromScaleInPolicySTATUS(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScaleInPolicySTATUS() to populate field ScaleInPolicy")
>>>>>>> main
		}
		scaleSet.ScaleInPolicy = &scaleInPolicy
	} else {
		scaleSet.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		scaleSet.SinglePlacementGroup = &singlePlacementGroup
	} else {
		scaleSet.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
<<<<<<< HEAD
		err := sku.AssignPropertiesFromSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSku_STATUS() to populate field Sku")
=======
		err := sku.AssignPropertiesFromSkuSTATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSkuSTATUS() to populate field Sku")
>>>>>>> main
		}
		scaleSet.Sku = &sku
	} else {
		scaleSet.Sku = nil
	}

	// Tags
	scaleSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	scaleSet.Type = genruntime.ClonePointerToString(source.Type)

	// UniqueId
	scaleSet.UniqueId = genruntime.ClonePointerToString(source.UniqueId)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy_STATUS
<<<<<<< HEAD
		err := upgradePolicy.AssignPropertiesFromUpgradePolicy_STATUS(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUpgradePolicy_STATUS() to populate field UpgradePolicy")
=======
		err := upgradePolicy.AssignPropertiesFromUpgradePolicySTATUS(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUpgradePolicySTATUS() to populate field UpgradePolicy")
>>>>>>> main
		}
		scaleSet.UpgradePolicy = &upgradePolicy
	} else {
		scaleSet.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile_STATUS
<<<<<<< HEAD
		err := virtualMachineProfile.AssignPropertiesFromVirtualMachineScaleSetVMProfile_STATUS(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetVMProfile_STATUS() to populate field VirtualMachineProfile")
=======
		err := virtualMachineProfile.AssignPropertiesFromVirtualMachineScaleSetVMProfileSTATUS(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetVMProfileSTATUS() to populate field VirtualMachineProfile")
>>>>>>> main
		}
		scaleSet.VirtualMachineProfile = &virtualMachineProfile
	} else {
		scaleSet.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		scaleSet.ZoneBalance = &zoneBalance
	} else {
		scaleSet.ZoneBalance = nil
	}

	// Zones
	scaleSet.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSet_STATUS populates the provided destination VirtualMachineScaleSet_STATUS from our VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) AssignPropertiesToVirtualMachineScaleSet_STATUS(destination *alpha20201201s.VirtualMachineScaleSet_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetSTATUS populates the provided destination VirtualMachineScaleSet_STATUS from our VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) AssignPropertiesToVirtualMachineScaleSetSTATUS(destination *alpha20201201s.VirtualMachineScaleSet_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if scaleSet.AdditionalCapabilities != nil {
		var additionalCapability alpha20201201s.AdditionalCapabilities_STATUS
<<<<<<< HEAD
		err := scaleSet.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilities_STATUS(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
=======
		err := scaleSet.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilitiesSTATUS(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilitiesSTATUS() to populate field AdditionalCapabilities")
>>>>>>> main
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if scaleSet.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy alpha20201201s.AutomaticRepairsPolicy_STATUS
<<<<<<< HEAD
		err := scaleSet.AutomaticRepairsPolicy.AssignPropertiesToAutomaticRepairsPolicy_STATUS(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticRepairsPolicy_STATUS() to populate field AutomaticRepairsPolicy")
=======
		err := scaleSet.AutomaticRepairsPolicy.AssignPropertiesToAutomaticRepairsPolicySTATUS(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticRepairsPolicySTATUS() to populate field AutomaticRepairsPolicy")
>>>>>>> main
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(scaleSet.Conditions)

	// DoNotRunExtensionsOnOverprovisionedVMs
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if scaleSet.ExtendedLocation != nil {
		var extendedLocation alpha20201201s.ExtendedLocation_STATUS
<<<<<<< HEAD
		err := scaleSet.ExtendedLocation.AssignPropertiesToExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_STATUS() to populate field ExtendedLocation")
=======
		err := scaleSet.ExtendedLocation.AssignPropertiesToExtendedLocationSTATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationSTATUS() to populate field ExtendedLocation")
>>>>>>> main
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if scaleSet.HostGroup != nil {
		var hostGroup alpha20201201s.SubResource_STATUS
<<<<<<< HEAD
		err := scaleSet.HostGroup.AssignPropertiesToSubResource_STATUS(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field HostGroup")
=======
		err := scaleSet.HostGroup.AssignPropertiesToSubResourceSTATUS(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field HostGroup")
>>>>>>> main
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(scaleSet.Id)

	// Identity
	if scaleSet.Identity != nil {
		var identity alpha20201201s.VirtualMachineScaleSetIdentity_STATUS
<<<<<<< HEAD
		err := scaleSet.Identity.AssignPropertiesToVirtualMachineScaleSetIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIdentity_STATUS() to populate field Identity")
=======
		err := scaleSet.Identity.AssignPropertiesToVirtualMachineScaleSetIdentitySTATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIdentitySTATUS() to populate field Identity")
>>>>>>> main
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(scaleSet.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(scaleSet.Name)

	// OrchestrationMode
	if scaleSet.OrchestrationMode != nil {
		orchestrationMode := string(*scaleSet.OrchestrationMode)
		destination.OrchestrationMode = &orchestrationMode
	} else {
		destination.OrchestrationMode = nil
	}

	// Overprovision
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Plan
	if scaleSet.Plan != nil {
		var plan alpha20201201s.Plan_STATUS
<<<<<<< HEAD
		err := scaleSet.Plan.AssignPropertiesToPlan_STATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlan_STATUS() to populate field Plan")
=======
		err := scaleSet.Plan.AssignPropertiesToPlanSTATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlanSTATUS() to populate field Plan")
>>>>>>> main
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	destination.PlatformFaultDomainCount = genruntime.ClonePointerToInt(scaleSet.PlatformFaultDomainCount)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(scaleSet.ProvisioningState)

	// ProximityPlacementGroup
	if scaleSet.ProximityPlacementGroup != nil {
		var proximityPlacementGroup alpha20201201s.SubResource_STATUS
<<<<<<< HEAD
		err := scaleSet.ProximityPlacementGroup.AssignPropertiesToSubResource_STATUS(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field ProximityPlacementGroup")
=======
		err := scaleSet.ProximityPlacementGroup.AssignPropertiesToSubResourceSTATUS(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field ProximityPlacementGroup")
>>>>>>> main
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if scaleSet.ScaleInPolicy != nil {
		var scaleInPolicy alpha20201201s.ScaleInPolicy_STATUS
<<<<<<< HEAD
		err := scaleSet.ScaleInPolicy.AssignPropertiesToScaleInPolicy_STATUS(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScaleInPolicy_STATUS() to populate field ScaleInPolicy")
=======
		err := scaleSet.ScaleInPolicy.AssignPropertiesToScaleInPolicySTATUS(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScaleInPolicySTATUS() to populate field ScaleInPolicy")
>>>>>>> main
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if scaleSet.Sku != nil {
		var sku alpha20201201s.Sku_STATUS
<<<<<<< HEAD
		err := scaleSet.Sku.AssignPropertiesToSku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSku_STATUS() to populate field Sku")
=======
		err := scaleSet.Sku.AssignPropertiesToSkuSTATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSkuSTATUS() to populate field Sku")
>>>>>>> main
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(scaleSet.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(scaleSet.Type)

	// UniqueId
	destination.UniqueId = genruntime.ClonePointerToString(scaleSet.UniqueId)

	// UpgradePolicy
	if scaleSet.UpgradePolicy != nil {
		var upgradePolicy alpha20201201s.UpgradePolicy_STATUS
<<<<<<< HEAD
		err := scaleSet.UpgradePolicy.AssignPropertiesToUpgradePolicy_STATUS(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUpgradePolicy_STATUS() to populate field UpgradePolicy")
=======
		err := scaleSet.UpgradePolicy.AssignPropertiesToUpgradePolicySTATUS(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUpgradePolicySTATUS() to populate field UpgradePolicy")
>>>>>>> main
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if scaleSet.VirtualMachineProfile != nil {
		var virtualMachineProfile alpha20201201s.VirtualMachineScaleSetVMProfile_STATUS
<<<<<<< HEAD
		err := scaleSet.VirtualMachineProfile.AssignPropertiesToVirtualMachineScaleSetVMProfile_STATUS(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetVMProfile_STATUS() to populate field VirtualMachineProfile")
=======
		err := scaleSet.VirtualMachineProfile.AssignPropertiesToVirtualMachineScaleSetVMProfileSTATUS(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetVMProfileSTATUS() to populate field VirtualMachineProfile")
>>>>>>> main
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(scaleSet.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineScaleSet_Spec struct {
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`
	AutomaticRepairsPolicy *AutomaticRepairsPolicy `json:"automaticRepairsPolicy,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                              string                          `json:"azureName,omitempty"`
	DoNotRunExtensionsOnOverprovisionedVMs *bool                           `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`
	ExtendedLocation                       *ExtendedLocation               `json:"extendedLocation,omitempty"`
	HostGroup                              *SubResource                    `json:"hostGroup,omitempty"`
	Identity                               *VirtualMachineScaleSetIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	Location          *string            `json:"location,omitempty"`
	OrchestrationMode *OrchestrationMode `json:"orchestrationMode,omitempty"`
	Overprovision     *bool              `json:"overprovision,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                    *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Plan                     *Plan                              `json:"plan,omitempty"`
	PlatformFaultDomainCount *int                               `json:"platformFaultDomainCount,omitempty"`
	ProximityPlacementGroup  *SubResource                       `json:"proximityPlacementGroup,omitempty"`
	ScaleInPolicy            *ScaleInPolicy                     `json:"scaleInPolicy,omitempty"`
	SinglePlacementGroup     *bool                              `json:"singlePlacementGroup,omitempty"`
	Sku                      *Sku                               `json:"sku,omitempty"`
	Tags                     map[string]string                  `json:"tags,omitempty"`
	UpgradePolicy            *UpgradePolicy                     `json:"upgradePolicy,omitempty"`
	VirtualMachineProfile    *VirtualMachineScaleSetVMProfile   `json:"virtualMachineProfile,omitempty"`
	ZoneBalance              *bool                              `json:"zoneBalance,omitempty"`
	Zones                    []string                           `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSet_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scaleSet *VirtualMachineScaleSet_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scaleSet == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSet_SpecARM{}

	// Set property ‘AzureName’:
	result.AzureName = scaleSet.AzureName

	// Set property ‘ExtendedLocation’:
	if scaleSet.ExtendedLocation != nil {
		extendedLocationARM, err := (*scaleSet.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocationARM.(*ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Identity’:
	if scaleSet.Identity != nil {
		identityARM, err := (*scaleSet.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identityARM.(*VirtualMachineScaleSetIdentityARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	if scaleSet.Location != nil {
		location := *scaleSet.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Plan’:
	if scaleSet.Plan != nil {
		planARM, err := (*scaleSet.Plan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plan := *planARM.(*PlanARM)
		result.Plan = &plan
	}

	// Set property ‘Properties’:
	if scaleSet.AdditionalCapabilities != nil ||
		scaleSet.AutomaticRepairsPolicy != nil ||
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil ||
		scaleSet.HostGroup != nil ||
		scaleSet.OrchestrationMode != nil ||
		scaleSet.Overprovision != nil ||
		scaleSet.PlatformFaultDomainCount != nil ||
		scaleSet.ProximityPlacementGroup != nil ||
		scaleSet.ScaleInPolicy != nil ||
		scaleSet.SinglePlacementGroup != nil ||
		scaleSet.UpgradePolicy != nil ||
		scaleSet.VirtualMachineProfile != nil ||
		scaleSet.ZoneBalance != nil {
		result.Properties = &VirtualMachineScaleSetPropertiesARM{}
	}
	if scaleSet.AdditionalCapabilities != nil {
		additionalCapabilitiesARM, err := (*scaleSet.AdditionalCapabilities).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		additionalCapabilities := *additionalCapabilitiesARM.(*AdditionalCapabilitiesARM)
		result.Properties.AdditionalCapabilities = &additionalCapabilities
	}
	if scaleSet.AutomaticRepairsPolicy != nil {
		automaticRepairsPolicyARM, err := (*scaleSet.AutomaticRepairsPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticRepairsPolicy := *automaticRepairsPolicyARM.(*AutomaticRepairsPolicyARM)
		result.Properties.AutomaticRepairsPolicy = &automaticRepairsPolicy
	}
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVMs := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		result.Properties.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
	}
	if scaleSet.HostGroup != nil {
		hostGroupARM, err := (*scaleSet.HostGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostGroup := *hostGroupARM.(*SubResourceARM)
		result.Properties.HostGroup = &hostGroup
	}
	if scaleSet.OrchestrationMode != nil {
		orchestrationMode := *scaleSet.OrchestrationMode
		result.Properties.OrchestrationMode = &orchestrationMode
	}
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		result.Properties.Overprovision = &overprovision
	}
	if scaleSet.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *scaleSet.PlatformFaultDomainCount
		result.Properties.PlatformFaultDomainCount = &platformFaultDomainCount
	}
	if scaleSet.ProximityPlacementGroup != nil {
		proximityPlacementGroupARM, err := (*scaleSet.ProximityPlacementGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proximityPlacementGroup := *proximityPlacementGroupARM.(*SubResourceARM)
		result.Properties.ProximityPlacementGroup = &proximityPlacementGroup
	}
	if scaleSet.ScaleInPolicy != nil {
		scaleInPolicyARM, err := (*scaleSet.ScaleInPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleInPolicy := *scaleInPolicyARM.(*ScaleInPolicyARM)
		result.Properties.ScaleInPolicy = &scaleInPolicy
	}
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		result.Properties.SinglePlacementGroup = &singlePlacementGroup
	}
	if scaleSet.UpgradePolicy != nil {
		upgradePolicyARM, err := (*scaleSet.UpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradePolicy := *upgradePolicyARM.(*UpgradePolicyARM)
		result.Properties.UpgradePolicy = &upgradePolicy
	}
	if scaleSet.VirtualMachineProfile != nil {
		virtualMachineProfileARM, err := (*scaleSet.VirtualMachineProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineProfile := *virtualMachineProfileARM.(*VirtualMachineScaleSetVMProfileARM)
		result.Properties.VirtualMachineProfile = &virtualMachineProfile
	}
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		result.Properties.ZoneBalance = &zoneBalance
	}

	// Set property ‘Sku’:
	if scaleSet.Sku != nil {
		skuARM, err := (*scaleSet.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *skuARM.(*SkuARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if scaleSet.Tags != nil {
		result.Tags = make(map[string]string, len(scaleSet.Tags))
		for key, value := range scaleSet.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Zones’:
	for _, item := range scaleSet.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaleSet *VirtualMachineScaleSet_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSet_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaleSet *VirtualMachineScaleSet_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSet_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSet_SpecARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			scaleSet.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property ‘AutomaticRepairsPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticRepairsPolicy != nil {
			var automaticRepairsPolicy1 AutomaticRepairsPolicy
			err := automaticRepairsPolicy1.PopulateFromARM(owner, *typedInput.Properties.AutomaticRepairsPolicy)
			if err != nil {
				return err
			}
			automaticRepairsPolicy := automaticRepairsPolicy1
			scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
		}
	}

	// Set property ‘AzureName’:
	scaleSet.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DoNotRunExtensionsOnOverprovisionedVMs’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs != nil {
			doNotRunExtensionsOnOverprovisionedVMs := *typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs
			scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		scaleSet.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			scaleSet.HostGroup = &hostGroup
		}
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineScaleSetIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		scaleSet.Identity = &identity
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		scaleSet.Location = &location
	}

	// Set property ‘OrchestrationMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OrchestrationMode != nil {
			orchestrationMode := *typedInput.Properties.OrchestrationMode
			scaleSet.OrchestrationMode = &orchestrationMode
		}
	}

	// Set property ‘Overprovision’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Overprovision != nil {
			overprovision := *typedInput.Properties.Overprovision
			scaleSet.Overprovision = &overprovision
		}
	}

	// Set property ‘Owner’:
	scaleSet.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		scaleSet.Plan = &plan
	}

	// Set property ‘PlatformFaultDomainCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomainCount != nil {
			platformFaultDomainCount := *typedInput.Properties.PlatformFaultDomainCount
			scaleSet.PlatformFaultDomainCount = &platformFaultDomainCount
		}
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property ‘ScaleInPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScaleInPolicy != nil {
			var scaleInPolicy1 ScaleInPolicy
			err := scaleInPolicy1.PopulateFromARM(owner, *typedInput.Properties.ScaleInPolicy)
			if err != nil {
				return err
			}
			scaleInPolicy := scaleInPolicy1
			scaleSet.ScaleInPolicy = &scaleInPolicy
		}
	}

	// Set property ‘SinglePlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SinglePlacementGroup != nil {
			singlePlacementGroup := *typedInput.Properties.SinglePlacementGroup
			scaleSet.SinglePlacementGroup = &singlePlacementGroup
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		scaleSet.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		scaleSet.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			scaleSet.Tags[key] = value
		}
	}

	// Set property ‘UpgradePolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradePolicy != nil {
			var upgradePolicy1 UpgradePolicy
			err := upgradePolicy1.PopulateFromARM(owner, *typedInput.Properties.UpgradePolicy)
			if err != nil {
				return err
			}
			upgradePolicy := upgradePolicy1
			scaleSet.UpgradePolicy = &upgradePolicy
		}
	}

	// Set property ‘VirtualMachineProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineProfile != nil {
			var virtualMachineProfile1 VirtualMachineScaleSetVMProfile
			err := virtualMachineProfile1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineProfile)
			if err != nil {
				return err
			}
			virtualMachineProfile := virtualMachineProfile1
			scaleSet.VirtualMachineProfile = &virtualMachineProfile
		}
	}

	// Set property ‘ZoneBalance’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneBalance != nil {
			zoneBalance := *typedInput.Properties.ZoneBalance
			scaleSet.ZoneBalance = &zoneBalance
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		scaleSet.Zones = append(scaleSet.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualMachineScaleSet_Spec{}

// ConvertSpecFrom populates our VirtualMachineScaleSet_Spec from the provided source
func (scaleSet *VirtualMachineScaleSet_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*alpha20201201s.VirtualMachineScaleSet_Spec)
	if ok {
		// Populate our instance from source
		return scaleSet.AssignPropertiesFromVirtualMachineScaleSet_Spec(src)
	}

	// Convert to an intermediate form
	src = &alpha20201201s.VirtualMachineScaleSet_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = scaleSet.AssignPropertiesFromVirtualMachineScaleSet_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*alpha20201201s.VirtualMachineScaleSet_Spec)
	if ok {
		// Populate destination from our instance
		return scaleSet.AssignPropertiesToVirtualMachineScaleSet_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &alpha20201201s.VirtualMachineScaleSet_Spec{}
	err := scaleSet.AssignPropertiesToVirtualMachineScaleSet_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualMachineScaleSet_Spec populates our VirtualMachineScaleSet_Spec from the provided source VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) AssignPropertiesFromVirtualMachineScaleSet_Spec(source *alpha20201201s.VirtualMachineScaleSet_Spec) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		scaleSet.AdditionalCapabilities = &additionalCapability
	} else {
		scaleSet.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy
		err := automaticRepairsPolicy.AssignPropertiesFromAutomaticRepairsPolicy(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticRepairsPolicy() to populate field AutomaticRepairsPolicy")
		}
		scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		scaleSet.AutomaticRepairsPolicy = nil
	}

	// AzureName
	scaleSet.AzureName = source.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocation")
		}
		scaleSet.ExtendedLocation = &extendedLocation
	} else {
		scaleSet.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.AssignPropertiesFromSubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field HostGroup")
		}
		scaleSet.HostGroup = &hostGroup
	} else {
		scaleSet.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity
		err := identity.AssignPropertiesFromVirtualMachineScaleSetIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIdentity() to populate field Identity")
		}
		scaleSet.Identity = &identity
	} else {
		scaleSet.Identity = nil
	}

	// Location
	scaleSet.Location = genruntime.ClonePointerToString(source.Location)

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := OrchestrationMode(*source.OrchestrationMode)
		scaleSet.OrchestrationMode = &orchestrationMode
	} else {
		scaleSet.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		scaleSet.Overprovision = &overprovision
	} else {
		scaleSet.Overprovision = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		scaleSet.Owner = &owner
	} else {
		scaleSet.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignPropertiesFromPlan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlan() to populate field Plan")
		}
		scaleSet.Plan = &plan
	} else {
		scaleSet.Plan = nil
	}

	// PlatformFaultDomainCount
	scaleSet.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.AssignPropertiesFromSubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field ProximityPlacementGroup")
		}
		scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		scaleSet.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy
		err := scaleInPolicy.AssignPropertiesFromScaleInPolicy(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScaleInPolicy() to populate field ScaleInPolicy")
		}
		scaleSet.ScaleInPolicy = &scaleInPolicy
	} else {
		scaleSet.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		scaleSet.SinglePlacementGroup = &singlePlacementGroup
	} else {
		scaleSet.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignPropertiesFromSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSku() to populate field Sku")
		}
		scaleSet.Sku = &sku
	} else {
		scaleSet.Sku = nil
	}

	// Tags
	scaleSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy
		err := upgradePolicy.AssignPropertiesFromUpgradePolicy(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUpgradePolicy() to populate field UpgradePolicy")
		}
		scaleSet.UpgradePolicy = &upgradePolicy
	} else {
		scaleSet.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile
		err := virtualMachineProfile.AssignPropertiesFromVirtualMachineScaleSetVMProfile(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetVMProfile() to populate field VirtualMachineProfile")
		}
		scaleSet.VirtualMachineProfile = &virtualMachineProfile
	} else {
		scaleSet.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		scaleSet.ZoneBalance = &zoneBalance
	} else {
		scaleSet.ZoneBalance = nil
	}

	// Zones
	scaleSet.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSet_Spec populates the provided destination VirtualMachineScaleSet_Spec from our VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) AssignPropertiesToVirtualMachineScaleSet_Spec(destination *alpha20201201s.VirtualMachineScaleSet_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if scaleSet.AdditionalCapabilities != nil {
		var additionalCapability alpha20201201s.AdditionalCapabilities
		err := scaleSet.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if scaleSet.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy alpha20201201s.AutomaticRepairsPolicy
		err := scaleSet.AutomaticRepairsPolicy.AssignPropertiesToAutomaticRepairsPolicy(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticRepairsPolicy() to populate field AutomaticRepairsPolicy")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// AzureName
	destination.AzureName = scaleSet.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if scaleSet.ExtendedLocation != nil {
		var extendedLocation alpha20201201s.ExtendedLocation
		err := scaleSet.ExtendedLocation.AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if scaleSet.HostGroup != nil {
		var hostGroup alpha20201201s.SubResource
		err := scaleSet.HostGroup.AssignPropertiesToSubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if scaleSet.Identity != nil {
		var identity alpha20201201s.VirtualMachineScaleSetIdentity
		err := scaleSet.Identity.AssignPropertiesToVirtualMachineScaleSetIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(scaleSet.Location)

	// OrchestrationMode
	if scaleSet.OrchestrationMode != nil {
		orchestrationMode := string(*scaleSet.OrchestrationMode)
		destination.OrchestrationMode = &orchestrationMode
	} else {
		destination.OrchestrationMode = nil
	}

	// OriginalVersion
	destination.OriginalVersion = scaleSet.OriginalVersion()

	// Overprovision
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Owner
	if scaleSet.Owner != nil {
		owner := scaleSet.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if scaleSet.Plan != nil {
		var plan alpha20201201s.Plan
		err := scaleSet.Plan.AssignPropertiesToPlan(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	destination.PlatformFaultDomainCount = genruntime.ClonePointerToInt(scaleSet.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if scaleSet.ProximityPlacementGroup != nil {
		var proximityPlacementGroup alpha20201201s.SubResource
		err := scaleSet.ProximityPlacementGroup.AssignPropertiesToSubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if scaleSet.ScaleInPolicy != nil {
		var scaleInPolicy alpha20201201s.ScaleInPolicy
		err := scaleSet.ScaleInPolicy.AssignPropertiesToScaleInPolicy(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScaleInPolicy() to populate field ScaleInPolicy")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if scaleSet.Sku != nil {
		var sku alpha20201201s.Sku
		err := scaleSet.Sku.AssignPropertiesToSku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(scaleSet.Tags)

	// UpgradePolicy
	if scaleSet.UpgradePolicy != nil {
		var upgradePolicy alpha20201201s.UpgradePolicy
		err := scaleSet.UpgradePolicy.AssignPropertiesToUpgradePolicy(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUpgradePolicy() to populate field UpgradePolicy")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if scaleSet.VirtualMachineProfile != nil {
		var virtualMachineProfile alpha20201201s.VirtualMachineScaleSetVMProfile
		err := scaleSet.VirtualMachineProfile.AssignPropertiesToVirtualMachineScaleSetVMProfile(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetVMProfile() to populate field VirtualMachineProfile")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(scaleSet.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (scaleSet *VirtualMachineScaleSet_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (scaleSet *VirtualMachineScaleSet_Spec) SetAzureName(azureName string) {
	scaleSet.AzureName = azureName
}

// Deprecated version of AutomaticRepairsPolicy. Use v1beta20201201.AutomaticRepairsPolicy instead
type AutomaticRepairsPolicy struct {
	Enabled     *bool   `json:"enabled,omitempty"`
	GracePeriod *string `json:"gracePeriod,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticRepairsPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *AutomaticRepairsPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &AutomaticRepairsPolicyARM{}

	// Set property ‘Enabled’:
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if policy.GracePeriod != nil {
		gracePeriod := *policy.GracePeriod
		result.GracePeriod = &gracePeriod
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticRepairsPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticRepairsPolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticRepairsPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticRepairsPolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticRepairsPolicyARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		policy.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if typedInput.GracePeriod != nil {
		gracePeriod := *typedInput.GracePeriod
		policy.GracePeriod = &gracePeriod
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticRepairsPolicy populates our AutomaticRepairsPolicy from the provided source AutomaticRepairsPolicy
func (policy *AutomaticRepairsPolicy) AssignPropertiesFromAutomaticRepairsPolicy(source *alpha20201201s.AutomaticRepairsPolicy) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// No error
	return nil
}

// AssignPropertiesToAutomaticRepairsPolicy populates the provided destination AutomaticRepairsPolicy from our AutomaticRepairsPolicy
func (policy *AutomaticRepairsPolicy) AssignPropertiesToAutomaticRepairsPolicy(destination *alpha20201201s.AutomaticRepairsPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	destination.GracePeriod = genruntime.ClonePointerToString(policy.GracePeriod)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutomaticRepairsPolicy_STATUS. Use v1beta20201201.AutomaticRepairsPolicy_STATUS instead
type AutomaticRepairsPolicy_STATUS struct {
	Enabled     *bool   `json:"enabled,omitempty"`
	GracePeriod *string `json:"gracePeriod,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticRepairsPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticRepairsPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticRepairsPolicy_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticRepairsPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticRepairsPolicy_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticRepairsPolicy_STATUSARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		policy.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if typedInput.GracePeriod != nil {
		gracePeriod := *typedInput.GracePeriod
		policy.GracePeriod = &gracePeriod
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromAutomaticRepairsPolicy_STATUS populates our AutomaticRepairsPolicy_STATUS from the provided source AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy_STATUS) AssignPropertiesFromAutomaticRepairsPolicy_STATUS(source *alpha20201201s.AutomaticRepairsPolicy_STATUS) error {
=======
// AssignPropertiesFromAutomaticRepairsPolicySTATUS populates our AutomaticRepairsPolicy_STATUS from the provided source AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy_STATUS) AssignPropertiesFromAutomaticRepairsPolicySTATUS(source *alpha20201201s.AutomaticRepairsPolicy_STATUS) error {
>>>>>>> main

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToAutomaticRepairsPolicy_STATUS populates the provided destination AutomaticRepairsPolicy_STATUS from our AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy_STATUS) AssignPropertiesToAutomaticRepairsPolicy_STATUS(destination *alpha20201201s.AutomaticRepairsPolicy_STATUS) error {
=======
// AssignPropertiesToAutomaticRepairsPolicySTATUS populates the provided destination AutomaticRepairsPolicy_STATUS from our AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy_STATUS) AssignPropertiesToAutomaticRepairsPolicySTATUS(destination *alpha20201201s.AutomaticRepairsPolicy_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	destination.GracePeriod = genruntime.ClonePointerToString(policy.GracePeriod)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// Deprecated version of OrchestrationMode. Use v1beta20201201.OrchestrationMode instead
// +kubebuilder:validation:Enum={"Flexible","Uniform"}
type OrchestrationMode string

const (
	OrchestrationMode_Flexible = OrchestrationMode("Flexible")
	OrchestrationMode_Uniform  = OrchestrationMode("Uniform")
)

// Deprecated version of OrchestrationMode_STATUS. Use v1beta20201201.OrchestrationMode_STATUS instead
type OrchestrationMode_STATUS string

const (
	OrchestrationMode_Flexible_STATUS = OrchestrationMode_STATUS("Flexible")
	OrchestrationMode_Uniform_STATUS  = OrchestrationMode_STATUS("Uniform")
=======
// Deprecated version of OrchestrationMode_STATUS. Use v1beta20201201.OrchestrationMode_STATUS instead
type OrchestrationMode_STATUS string

const (
	OrchestrationMode_STATUS_Flexible = OrchestrationMode_STATUS("Flexible")
	OrchestrationMode_STATUS_Uniform  = OrchestrationMode_STATUS("Uniform")
>>>>>>> main
)

// Deprecated version of ScaleInPolicy. Use v1beta20201201.ScaleInPolicy instead
type ScaleInPolicy struct {
	Rules []ScaleInPolicy_Rules `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleInPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *ScaleInPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &ScaleInPolicyARM{}

	// Set property ‘Rules’:
	for _, item := range policy.Rules {
		result.Rules = append(result.Rules, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ScaleInPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScaleInPolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ScaleInPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScaleInPolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScaleInPolicyARM, got %T", armInput)
	}

	// Set property ‘Rules’:
	for _, item := range typedInput.Rules {
		policy.Rules = append(policy.Rules, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromScaleInPolicy populates our ScaleInPolicy from the provided source ScaleInPolicy
func (policy *ScaleInPolicy) AssignPropertiesFromScaleInPolicy(source *alpha20201201s.ScaleInPolicy) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleInPolicy_Rules, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ScaleInPolicy_Rules(ruleItem)
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignPropertiesToScaleInPolicy populates the provided destination ScaleInPolicy from our ScaleInPolicy
func (policy *ScaleInPolicy) AssignPropertiesToScaleInPolicy(destination *alpha20201201s.ScaleInPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if policy.Rules != nil {
		ruleList := make([]string, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = string(ruleItem)
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ScaleInPolicy_STATUS. Use v1beta20201201.ScaleInPolicy_STATUS instead
type ScaleInPolicy_STATUS struct {
<<<<<<< HEAD
	Rules []ScaleInPolicy_Rules_STATUS `json:"rules,omitempty"`
=======
	Rules []ScaleInPolicySTATUSRules `json:"rules,omitempty"`
>>>>>>> main
}

var _ genruntime.FromARMConverter = &ScaleInPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ScaleInPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScaleInPolicy_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ScaleInPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScaleInPolicy_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScaleInPolicy_STATUSARM, got %T", armInput)
	}

	// Set property ‘Rules’:
	for _, item := range typedInput.Rules {
		policy.Rules = append(policy.Rules, item)
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromScaleInPolicy_STATUS populates our ScaleInPolicy_STATUS from the provided source ScaleInPolicy_STATUS
func (policy *ScaleInPolicy_STATUS) AssignPropertiesFromScaleInPolicy_STATUS(source *alpha20201201s.ScaleInPolicy_STATUS) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleInPolicy_Rules_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ScaleInPolicy_Rules_STATUS(ruleItem)
=======
// AssignPropertiesFromScaleInPolicySTATUS populates our ScaleInPolicy_STATUS from the provided source ScaleInPolicy_STATUS
func (policy *ScaleInPolicy_STATUS) AssignPropertiesFromScaleInPolicySTATUS(source *alpha20201201s.ScaleInPolicy_STATUS) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleInPolicySTATUSRules, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = ScaleInPolicySTATUSRules(ruleItem)
>>>>>>> main
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToScaleInPolicy_STATUS populates the provided destination ScaleInPolicy_STATUS from our ScaleInPolicy_STATUS
func (policy *ScaleInPolicy_STATUS) AssignPropertiesToScaleInPolicy_STATUS(destination *alpha20201201s.ScaleInPolicy_STATUS) error {
=======
// AssignPropertiesToScaleInPolicySTATUS populates the provided destination ScaleInPolicy_STATUS from our ScaleInPolicy_STATUS
func (policy *ScaleInPolicy_STATUS) AssignPropertiesToScaleInPolicySTATUS(destination *alpha20201201s.ScaleInPolicy_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if policy.Rules != nil {
		ruleList := make([]string, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = string(ruleItem)
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Sku. Use v1beta20201201.Sku instead
type Sku struct {
	Capacity *int    `json:"capacity,omitempty"`
	Name     *string `json:"name,omitempty"`
	Tier     *string `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &SkuARM{}

	// Set property ‘Capacity’:
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property ‘Name’:
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SkuARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SkuARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SkuARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromSku populates our Sku from the provided source Sku
func (sku *Sku) AssignPropertiesFromSku(source *alpha20201201s.Sku) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignPropertiesToSku populates the provided destination Sku from our Sku
func (sku *Sku) AssignPropertiesToSku(destination *alpha20201201s.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Sku_STATUS. Use v1beta20201201.Sku_STATUS instead
type Sku_STATUS struct {
	Capacity *int    `json:"capacity,omitempty"`
	Name     *string `json:"name,omitempty"`
	Tier     *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_STATUSARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromSku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignPropertiesFromSku_STATUS(source *alpha20201201s.Sku_STATUS) error {
=======
// AssignPropertiesFromSkuSTATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignPropertiesFromSkuSTATUS(source *alpha20201201s.Sku_STATUS) error {
>>>>>>> main

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToSku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignPropertiesToSku_STATUS(destination *alpha20201201s.Sku_STATUS) error {
=======
// AssignPropertiesToSkuSTATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignPropertiesToSkuSTATUS(destination *alpha20201201s.Sku_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of UpgradePolicy. Use v1beta20201201.UpgradePolicy instead
type UpgradePolicy struct {
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy `json:"automaticOSUpgradePolicy,omitempty"`
	Mode                     *UpgradePolicy_Mode       `json:"mode,omitempty"`
	RollingUpgradePolicy     *RollingUpgradePolicy     `json:"rollingUpgradePolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &UpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *UpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &UpgradePolicyARM{}

	// Set property ‘AutomaticOSUpgradePolicy’:
	if policy.AutomaticOSUpgradePolicy != nil {
		automaticOSUpgradePolicyARM, err := (*policy.AutomaticOSUpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticOSUpgradePolicy := *automaticOSUpgradePolicyARM.(*AutomaticOSUpgradePolicyARM)
		result.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if policy.Mode != nil {
		mode := *policy.Mode
		result.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if policy.RollingUpgradePolicy != nil {
		rollingUpgradePolicyARM, err := (*policy.RollingUpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		rollingUpgradePolicy := *rollingUpgradePolicyARM.(*RollingUpgradePolicyARM)
		result.RollingUpgradePolicy = &rollingUpgradePolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *UpgradePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UpgradePolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *UpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UpgradePolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UpgradePolicyARM, got %T", armInput)
	}

	// Set property ‘AutomaticOSUpgradePolicy’:
	if typedInput.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy1 AutomaticOSUpgradePolicy
		err := automaticOSUpgradePolicy1.PopulateFromARM(owner, *typedInput.AutomaticOSUpgradePolicy)
		if err != nil {
			return err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicy1
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		policy.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if typedInput.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy1 RollingUpgradePolicy
		err := rollingUpgradePolicy1.PopulateFromARM(owner, *typedInput.RollingUpgradePolicy)
		if err != nil {
			return err
		}
		rollingUpgradePolicy := rollingUpgradePolicy1
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignPropertiesFromUpgradePolicy populates our UpgradePolicy from the provided source UpgradePolicy
func (policy *UpgradePolicy) AssignPropertiesFromUpgradePolicy(source *alpha20201201s.UpgradePolicy) error {

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy
		err := automaticOSUpgradePolicy.AssignPropertiesFromAutomaticOSUpgradePolicy(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticOSUpgradePolicy() to populate field AutomaticOSUpgradePolicy")
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
		mode := UpgradePolicy_Mode(*source.Mode)
		policy.Mode = &mode
	} else {
		policy.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy
		err := rollingUpgradePolicy.AssignPropertiesFromRollingUpgradePolicy(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRollingUpgradePolicy() to populate field RollingUpgradePolicy")
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUpgradePolicy populates the provided destination UpgradePolicy from our UpgradePolicy
func (policy *UpgradePolicy) AssignPropertiesToUpgradePolicy(destination *alpha20201201s.UpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticOSUpgradePolicy
	if policy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy alpha20201201s.AutomaticOSUpgradePolicy
		err := policy.AutomaticOSUpgradePolicy.AssignPropertiesToAutomaticOSUpgradePolicy(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticOSUpgradePolicy() to populate field AutomaticOSUpgradePolicy")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if policy.Mode != nil {
		mode := string(*policy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RollingUpgradePolicy
	if policy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy alpha20201201s.RollingUpgradePolicy
		err := policy.RollingUpgradePolicy.AssignPropertiesToRollingUpgradePolicy(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRollingUpgradePolicy() to populate field RollingUpgradePolicy")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of UpgradePolicy_STATUS. Use v1beta20201201.UpgradePolicy_STATUS instead
type UpgradePolicy_STATUS struct {
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy_STATUS `json:"automaticOSUpgradePolicy,omitempty"`
<<<<<<< HEAD
	Mode                     *UpgradePolicy_Mode_STATUS       `json:"mode,omitempty"`
=======
	Mode                     *UpgradePolicySTATUSMode         `json:"mode,omitempty"`
>>>>>>> main
	RollingUpgradePolicy     *RollingUpgradePolicy_STATUS     `json:"rollingUpgradePolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &UpgradePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *UpgradePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UpgradePolicy_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *UpgradePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UpgradePolicy_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UpgradePolicy_STATUSARM, got %T", armInput)
	}

	// Set property ‘AutomaticOSUpgradePolicy’:
	if typedInput.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy1 AutomaticOSUpgradePolicy_STATUS
		err := automaticOSUpgradePolicy1.PopulateFromARM(owner, *typedInput.AutomaticOSUpgradePolicy)
		if err != nil {
			return err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicy1
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		policy.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if typedInput.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy1 RollingUpgradePolicy_STATUS
		err := rollingUpgradePolicy1.PopulateFromARM(owner, *typedInput.RollingUpgradePolicy)
		if err != nil {
			return err
		}
		rollingUpgradePolicy := rollingUpgradePolicy1
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromUpgradePolicy_STATUS populates our UpgradePolicy_STATUS from the provided source UpgradePolicy_STATUS
func (policy *UpgradePolicy_STATUS) AssignPropertiesFromUpgradePolicy_STATUS(source *alpha20201201s.UpgradePolicy_STATUS) error {
=======
// AssignPropertiesFromUpgradePolicySTATUS populates our UpgradePolicy_STATUS from the provided source UpgradePolicy_STATUS
func (policy *UpgradePolicy_STATUS) AssignPropertiesFromUpgradePolicySTATUS(source *alpha20201201s.UpgradePolicy_STATUS) error {
>>>>>>> main

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy_STATUS
<<<<<<< HEAD
		err := automaticOSUpgradePolicy.AssignPropertiesFromAutomaticOSUpgradePolicy_STATUS(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticOSUpgradePolicy_STATUS() to populate field AutomaticOSUpgradePolicy")
=======
		err := automaticOSUpgradePolicy.AssignPropertiesFromAutomaticOSUpgradePolicySTATUS(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutomaticOSUpgradePolicySTATUS() to populate field AutomaticOSUpgradePolicy")
>>>>>>> main
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
<<<<<<< HEAD
		mode := UpgradePolicy_Mode_STATUS(*source.Mode)
=======
		mode := UpgradePolicySTATUSMode(*source.Mode)
>>>>>>> main
		policy.Mode = &mode
	} else {
		policy.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy_STATUS
<<<<<<< HEAD
		err := rollingUpgradePolicy.AssignPropertiesFromRollingUpgradePolicy_STATUS(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRollingUpgradePolicy_STATUS() to populate field RollingUpgradePolicy")
=======
		err := rollingUpgradePolicy.AssignPropertiesFromRollingUpgradePolicySTATUS(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRollingUpgradePolicySTATUS() to populate field RollingUpgradePolicy")
>>>>>>> main
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToUpgradePolicy_STATUS populates the provided destination UpgradePolicy_STATUS from our UpgradePolicy_STATUS
func (policy *UpgradePolicy_STATUS) AssignPropertiesToUpgradePolicy_STATUS(destination *alpha20201201s.UpgradePolicy_STATUS) error {
=======
// AssignPropertiesToUpgradePolicySTATUS populates the provided destination UpgradePolicy_STATUS from our UpgradePolicy_STATUS
func (policy *UpgradePolicy_STATUS) AssignPropertiesToUpgradePolicySTATUS(destination *alpha20201201s.UpgradePolicy_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticOSUpgradePolicy
	if policy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy alpha20201201s.AutomaticOSUpgradePolicy_STATUS
<<<<<<< HEAD
		err := policy.AutomaticOSUpgradePolicy.AssignPropertiesToAutomaticOSUpgradePolicy_STATUS(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticOSUpgradePolicy_STATUS() to populate field AutomaticOSUpgradePolicy")
=======
		err := policy.AutomaticOSUpgradePolicy.AssignPropertiesToAutomaticOSUpgradePolicySTATUS(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutomaticOSUpgradePolicySTATUS() to populate field AutomaticOSUpgradePolicy")
>>>>>>> main
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if policy.Mode != nil {
		mode := string(*policy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RollingUpgradePolicy
	if policy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy alpha20201201s.RollingUpgradePolicy_STATUS
<<<<<<< HEAD
		err := policy.RollingUpgradePolicy.AssignPropertiesToRollingUpgradePolicy_STATUS(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRollingUpgradePolicy_STATUS() to populate field RollingUpgradePolicy")
=======
		err := policy.RollingUpgradePolicy.AssignPropertiesToRollingUpgradePolicySTATUS(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRollingUpgradePolicySTATUS() to populate field RollingUpgradePolicy")
>>>>>>> main
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetIdentity. Use v1beta20201201.VirtualMachineScaleSetIdentity instead
type VirtualMachineScaleSetIdentity struct {
	Type *VirtualMachineScaleSetIdentity_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *VirtualMachineScaleSetIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetIdentityARM{}

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineScaleSetIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineScaleSetIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIdentityARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIdentity populates our VirtualMachineScaleSetIdentity from the provided source VirtualMachineScaleSetIdentity
func (identity *VirtualMachineScaleSetIdentity) AssignPropertiesFromVirtualMachineScaleSetIdentity(source *alpha20201201s.VirtualMachineScaleSetIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineScaleSetIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIdentity populates the provided destination VirtualMachineScaleSetIdentity from our VirtualMachineScaleSetIdentity
func (identity *VirtualMachineScaleSetIdentity) AssignPropertiesToVirtualMachineScaleSetIdentity(destination *alpha20201201s.VirtualMachineScaleSetIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetIdentity_STATUS. Use v1beta20201201.VirtualMachineScaleSetIdentity_STATUS instead
type VirtualMachineScaleSetIdentity_STATUS struct {
<<<<<<< HEAD
	PrincipalId *string                                     `json:"principalId,omitempty"`
	TenantId    *string                                     `json:"tenantId,omitempty"`
	Type        *VirtualMachineScaleSetIdentity_Type_STATUS `json:"type,omitempty"`
=======
	PrincipalId *string                                   `json:"principalId,omitempty"`
	TenantId    *string                                   `json:"tenantId,omitempty"`
	Type        *VirtualMachineScaleSetIdentitySTATUSType `json:"type,omitempty"`
>>>>>>> main
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineScaleSetIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIdentity_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineScaleSetIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIdentity_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIdentity_STATUSARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetIdentity_STATUS populates our VirtualMachineScaleSetIdentity_STATUS from the provided source VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity_STATUS) AssignPropertiesFromVirtualMachineScaleSetIdentity_STATUS(source *alpha20201201s.VirtualMachineScaleSetIdentity_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetIdentitySTATUS populates our VirtualMachineScaleSetIdentity_STATUS from the provided source VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity_STATUS) AssignPropertiesFromVirtualMachineScaleSetIdentitySTATUS(source *alpha20201201s.VirtualMachineScaleSetIdentity_STATUS) error {
>>>>>>> main

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
<<<<<<< HEAD
		typeVar := VirtualMachineScaleSetIdentity_Type_STATUS(*source.Type)
=======
		typeVar := VirtualMachineScaleSetIdentitySTATUSType(*source.Type)
>>>>>>> main
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetIdentity_STATUS populates the provided destination VirtualMachineScaleSetIdentity_STATUS from our VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity_STATUS) AssignPropertiesToVirtualMachineScaleSetIdentity_STATUS(destination *alpha20201201s.VirtualMachineScaleSetIdentity_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetIdentitySTATUS populates the provided destination VirtualMachineScaleSetIdentity_STATUS from our VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity_STATUS) AssignPropertiesToVirtualMachineScaleSetIdentitySTATUS(destination *alpha20201201s.VirtualMachineScaleSetIdentity_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// Deprecated version of VirtualMachineScaleSetVMProfile. Use v1beta20201201.VirtualMachineScaleSetVMProfile instead
type VirtualMachineScaleSetVMProfile struct {
	BillingProfile         *BillingProfile                         `json:"billingProfile,omitempty"`
	DiagnosticsProfile     *DiagnosticsProfile                     `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy         *EvictionPolicy                         `json:"evictionPolicy,omitempty"`
	ExtensionProfile       *VirtualMachineScaleSetExtensionProfile `json:"extensionProfile,omitempty"`
	LicenseType            *string                                 `json:"licenseType,omitempty"`
	NetworkProfile         *VirtualMachineScaleSetNetworkProfile   `json:"networkProfile,omitempty"`
	OsProfile              *VirtualMachineScaleSetOSProfile        `json:"osProfile,omitempty"`
	Priority               *Priority                               `json:"priority,omitempty"`
	ScheduledEventsProfile *ScheduledEventsProfile                 `json:"scheduledEventsProfile,omitempty"`
	SecurityProfile        *SecurityProfile                        `json:"securityProfile,omitempty"`
	StorageProfile         *VirtualMachineScaleSetStorageProfile   `json:"storageProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetVMProfile{}
=======
// Deprecated version of VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile. Use v1beta20201201.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile instead
type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile struct {
	BillingProfile         *BillingProfile                                                                 `json:"billingProfile,omitempty"`
	DiagnosticsProfile     *DiagnosticsProfile                                                             `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy         *VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy       `json:"evictionPolicy,omitempty"`
	ExtensionProfile       *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile `json:"extensionProfile,omitempty"`
	LicenseType            *string                                                                         `json:"licenseType,omitempty"`
	NetworkProfile         *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile   `json:"networkProfile,omitempty"`
	OsProfile              *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile        `json:"osProfile,omitempty"`
	Priority               *VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority             `json:"priority,omitempty"`
	ScheduledEventsProfile *ScheduledEventsProfile                                                         `json:"scheduledEventsProfile,omitempty"`
	SecurityProfile        *SecurityProfile                                                                `json:"securityProfile,omitempty"`
	StorageProfile         *VirtualMachineScaleSetStorageProfile                                           `json:"storageProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile{}
>>>>>>> main

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetVMProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetVMProfileARM{}

	// Set property ‘BillingProfile’:
	if profile.BillingProfile != nil {
		billingProfileARM, err := (*profile.BillingProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		billingProfile := *billingProfileARM.(*BillingProfileARM)
		result.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if profile.DiagnosticsProfile != nil {
		diagnosticsProfileARM, err := (*profile.DiagnosticsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnosticsProfile := *diagnosticsProfileARM.(*DiagnosticsProfileARM)
		result.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if profile.EvictionPolicy != nil {
		evictionPolicy := *profile.EvictionPolicy
		result.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if profile.ExtensionProfile != nil {
		extensionProfileARM, err := (*profile.ExtensionProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extensionProfile := *extensionProfileARM.(*VirtualMachineScaleSetExtensionProfileARM)
		result.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if profile.LicenseType != nil {
		licenseType := *profile.LicenseType
		result.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if profile.NetworkProfile != nil {
		networkProfileARM, err := (*profile.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := *networkProfileARM.(*VirtualMachineScaleSetNetworkProfileARM)
		result.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if profile.OsProfile != nil {
		osProfileARM, err := (*profile.OsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osProfile := *osProfileARM.(*VirtualMachineScaleSetOSProfileARM)
		result.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if profile.Priority != nil {
		priority := *profile.Priority
		result.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if profile.ScheduledEventsProfile != nil {
		scheduledEventsProfileARM, err := (*profile.ScheduledEventsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scheduledEventsProfile := *scheduledEventsProfileARM.(*ScheduledEventsProfileARM)
		result.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if profile.SecurityProfile != nil {
		securityProfileARM, err := (*profile.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := *securityProfileARM.(*SecurityProfileARM)
		result.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if profile.StorageProfile != nil {
		storageProfileARM, err := (*profile.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfileARM.(*VirtualMachineScaleSetStorageProfileARM)
		result.StorageProfile = &storageProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetVMProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetVMProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetVMProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetVMProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetVMProfileARM, got %T", armInput)
	}

	// Set property ‘BillingProfile’:
	if typedInput.BillingProfile != nil {
		var billingProfile1 BillingProfile
		err := billingProfile1.PopulateFromARM(owner, *typedInput.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		profile.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if typedInput.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		profile.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if typedInput.EvictionPolicy != nil {
		evictionPolicy := *typedInput.EvictionPolicy
		profile.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if typedInput.ExtensionProfile != nil {
		var extensionProfile1 VirtualMachineScaleSetExtensionProfile
		err := extensionProfile1.PopulateFromARM(owner, *typedInput.ExtensionProfile)
		if err != nil {
			return err
		}
		extensionProfile := extensionProfile1
		profile.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		profile.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if typedInput.NetworkProfile != nil {
		var networkProfile1 VirtualMachineScaleSetNetworkProfile
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		profile.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if typedInput.OsProfile != nil {
		var osProfile1 VirtualMachineScaleSetOSProfile
		err := osProfile1.PopulateFromARM(owner, *typedInput.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		profile.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		profile.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if typedInput.ScheduledEventsProfile != nil {
		var scheduledEventsProfile1 ScheduledEventsProfile
		err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.ScheduledEventsProfile)
		if err != nil {
			return err
		}
		scheduledEventsProfile := scheduledEventsProfile1
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if typedInput.SecurityProfile != nil {
		var securityProfile1 SecurityProfile
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		profile.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if typedInput.StorageProfile != nil {
		var storageProfile1 VirtualMachineScaleSetStorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		profile.StorageProfile = &storageProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetVMProfile populates our VirtualMachineScaleSetVMProfile from the provided source VirtualMachineScaleSetVMProfile
func (profile *VirtualMachineScaleSetVMProfile) AssignPropertiesFromVirtualMachineScaleSetVMProfile(source *alpha20201201s.VirtualMachineScaleSetVMProfile) error {

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignPropertiesFromBillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfile() to populate field BillingProfile")
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := EvictionPolicy(*source.EvictionPolicy)
		profile.EvictionPolicy = &evictionPolicy
	} else {
		profile.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile
		err := extensionProfile.AssignPropertiesFromVirtualMachineScaleSetExtensionProfile(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetExtensionProfile() to populate field ExtensionProfile")
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile
		err := networkProfile.AssignPropertiesFromVirtualMachineScaleSetNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkProfile() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile
		err := osProfile.AssignPropertiesFromVirtualMachineScaleSetOSProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSProfile() to populate field OsProfile")
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := Priority(*source.Priority)
		profile.Priority = &priority
	} else {
		profile.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile
		err := scheduledEventsProfile.AssignPropertiesFromScheduledEventsProfile(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScheduledEventsProfile() to populate field ScheduledEventsProfile")
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignPropertiesFromSecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfile() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile
		err := storageProfile.AssignPropertiesFromVirtualMachineScaleSetStorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetStorageProfile() to populate field StorageProfile")
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetVMProfile populates the provided destination VirtualMachineScaleSetVMProfile from our VirtualMachineScaleSetVMProfile
func (profile *VirtualMachineScaleSetVMProfile) AssignPropertiesToVirtualMachineScaleSetVMProfile(destination *alpha20201201s.VirtualMachineScaleSetVMProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BillingProfile
	if profile.BillingProfile != nil {
		var billingProfile alpha20201201s.BillingProfile
		err := profile.BillingProfile.AssignPropertiesToBillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfile() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// DiagnosticsProfile
	if profile.DiagnosticsProfile != nil {
		var diagnosticsProfile alpha20201201s.DiagnosticsProfile
		err := profile.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if profile.EvictionPolicy != nil {
		evictionPolicy := string(*profile.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtensionProfile
	if profile.ExtensionProfile != nil {
		var extensionProfile alpha20201201s.VirtualMachineScaleSetExtensionProfile
		err := profile.ExtensionProfile.AssignPropertiesToVirtualMachineScaleSetExtensionProfile(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetExtensionProfile() to populate field ExtensionProfile")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile alpha20201201s.VirtualMachineScaleSetNetworkProfile
		err := profile.NetworkProfile.AssignPropertiesToVirtualMachineScaleSetNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if profile.OsProfile != nil {
		var osProfile alpha20201201s.VirtualMachineScaleSetOSProfile
		err := profile.OsProfile.AssignPropertiesToVirtualMachineScaleSetOSProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSProfile() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	if profile.Priority != nil {
		priority := string(*profile.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ScheduledEventsProfile
	if profile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile alpha20201201s.ScheduledEventsProfile
		err := profile.ScheduledEventsProfile.AssignPropertiesToScheduledEventsProfile(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScheduledEventsProfile() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile alpha20201201s.SecurityProfile
		err := profile.SecurityProfile.AssignPropertiesToSecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if profile.StorageProfile != nil {
		var storageProfile alpha20201201s.VirtualMachineScaleSetStorageProfile
		err := profile.StorageProfile.AssignPropertiesToVirtualMachineScaleSetStorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetStorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
=======
// Deprecated version of VirtualMachineScaleSetsSpecPropertiesOrchestrationMode. Use
// v1beta20201201.VirtualMachineScaleSetsSpecPropertiesOrchestrationMode instead
// +kubebuilder:validation:Enum={"Flexible","Uniform"}
type VirtualMachineScaleSetsSpecPropertiesOrchestrationMode string

const (
	VirtualMachineScaleSetsSpecPropertiesOrchestrationMode_Flexible = VirtualMachineScaleSetsSpecPropertiesOrchestrationMode("Flexible")
	VirtualMachineScaleSetsSpecPropertiesOrchestrationMode_Uniform  = VirtualMachineScaleSetsSpecPropertiesOrchestrationMode("Uniform")
)

>>>>>>> main
// Deprecated version of VirtualMachineScaleSetVMProfile_STATUS. Use v1beta20201201.VirtualMachineScaleSetVMProfile_STATUS instead
type VirtualMachineScaleSetVMProfile_STATUS struct {
	BillingProfile         *BillingProfile_STATUS                         `json:"billingProfile,omitempty"`
	DiagnosticsProfile     *DiagnosticsProfile_STATUS                     `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy         *EvictionPolicy_STATUS                         `json:"evictionPolicy,omitempty"`
	ExtensionProfile       *VirtualMachineScaleSetExtensionProfile_STATUS `json:"extensionProfile,omitempty"`
	LicenseType            *string                                        `json:"licenseType,omitempty"`
	NetworkProfile         *VirtualMachineScaleSetNetworkProfile_STATUS   `json:"networkProfile,omitempty"`
	OsProfile              *VirtualMachineScaleSetOSProfile_STATUS        `json:"osProfile,omitempty"`
	Priority               *Priority_STATUS                               `json:"priority,omitempty"`
	ScheduledEventsProfile *ScheduledEventsProfile_STATUS                 `json:"scheduledEventsProfile,omitempty"`
	SecurityProfile        *SecurityProfile_STATUS                        `json:"securityProfile,omitempty"`
	StorageProfile         *VirtualMachineScaleSetStorageProfile_STATUS   `json:"storageProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetVMProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetVMProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetVMProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetVMProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetVMProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetVMProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘BillingProfile’:
	if typedInput.BillingProfile != nil {
		var billingProfile1 BillingProfile_STATUS
		err := billingProfile1.PopulateFromARM(owner, *typedInput.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		profile.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if typedInput.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile_STATUS
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		profile.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if typedInput.EvictionPolicy != nil {
		evictionPolicy := *typedInput.EvictionPolicy
		profile.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if typedInput.ExtensionProfile != nil {
		var extensionProfile1 VirtualMachineScaleSetExtensionProfile_STATUS
		err := extensionProfile1.PopulateFromARM(owner, *typedInput.ExtensionProfile)
		if err != nil {
			return err
		}
		extensionProfile := extensionProfile1
		profile.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		profile.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if typedInput.NetworkProfile != nil {
		var networkProfile1 VirtualMachineScaleSetNetworkProfile_STATUS
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		profile.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if typedInput.OsProfile != nil {
		var osProfile1 VirtualMachineScaleSetOSProfile_STATUS
		err := osProfile1.PopulateFromARM(owner, *typedInput.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		profile.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		profile.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if typedInput.ScheduledEventsProfile != nil {
		var scheduledEventsProfile1 ScheduledEventsProfile_STATUS
		err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.ScheduledEventsProfile)
		if err != nil {
			return err
		}
		scheduledEventsProfile := scheduledEventsProfile1
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if typedInput.SecurityProfile != nil {
		var securityProfile1 SecurityProfile_STATUS
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		profile.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if typedInput.StorageProfile != nil {
		var storageProfile1 VirtualMachineScaleSetStorageProfile_STATUS
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		profile.StorageProfile = &storageProfile
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetVMProfile_STATUS populates our VirtualMachineScaleSetVMProfile_STATUS from the provided source VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetVMProfile_STATUS(source *alpha20201201s.VirtualMachineScaleSetVMProfile_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetVMProfileSTATUS populates our VirtualMachineScaleSetVMProfile_STATUS from the provided source VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetVMProfileSTATUS(source *alpha20201201s.VirtualMachineScaleSetVMProfile_STATUS) error {
>>>>>>> main

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_STATUS
<<<<<<< HEAD
		err := billingProfile.AssignPropertiesFromBillingProfile_STATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfile_STATUS() to populate field BillingProfile")
=======
		err := billingProfile.AssignPropertiesFromBillingProfileSTATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfileSTATUS() to populate field BillingProfile")
>>>>>>> main
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_STATUS
<<<<<<< HEAD
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfile_STATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
=======
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfileSTATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfileSTATUS() to populate field DiagnosticsProfile")
>>>>>>> main
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := EvictionPolicy_STATUS(*source.EvictionPolicy)
		profile.EvictionPolicy = &evictionPolicy
	} else {
		profile.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile_STATUS
<<<<<<< HEAD
		err := extensionProfile.AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_STATUS(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_STATUS() to populate field ExtensionProfile")
=======
		err := extensionProfile.AssignPropertiesFromVirtualMachineScaleSetExtensionProfileSTATUS(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetExtensionProfileSTATUS() to populate field ExtensionProfile")
>>>>>>> main
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile_STATUS
<<<<<<< HEAD
		err := networkProfile.AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_STATUS() to populate field NetworkProfile")
=======
		err := networkProfile.AssignPropertiesFromVirtualMachineScaleSetNetworkProfileSTATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkProfileSTATUS() to populate field NetworkProfile")
>>>>>>> main
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile_STATUS
<<<<<<< HEAD
		err := osProfile.AssignPropertiesFromVirtualMachineScaleSetOSProfile_STATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSProfile_STATUS() to populate field OsProfile")
=======
		err := osProfile.AssignPropertiesFromVirtualMachineScaleSetOSProfileSTATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSProfileSTATUS() to populate field OsProfile")
>>>>>>> main
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := Priority_STATUS(*source.Priority)
		profile.Priority = &priority
	} else {
		profile.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile_STATUS
<<<<<<< HEAD
		err := scheduledEventsProfile.AssignPropertiesFromScheduledEventsProfile_STATUS(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
=======
		err := scheduledEventsProfile.AssignPropertiesFromScheduledEventsProfileSTATUS(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromScheduledEventsProfileSTATUS() to populate field ScheduledEventsProfile")
>>>>>>> main
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_STATUS
<<<<<<< HEAD
		err := securityProfile.AssignPropertiesFromSecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfile_STATUS() to populate field SecurityProfile")
=======
		err := securityProfile.AssignPropertiesFromSecurityProfileSTATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfileSTATUS() to populate field SecurityProfile")
>>>>>>> main
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile_STATUS
<<<<<<< HEAD
		err := storageProfile.AssignPropertiesFromVirtualMachineScaleSetStorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetStorageProfile_STATUS() to populate field StorageProfile")
=======
		err := storageProfile.AssignPropertiesFromVirtualMachineScaleSetStorageProfileSTATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetStorageProfileSTATUS() to populate field StorageProfile")
>>>>>>> main
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetVMProfile_STATUS populates the provided destination VirtualMachineScaleSetVMProfile_STATUS from our VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetVMProfile_STATUS(destination *alpha20201201s.VirtualMachineScaleSetVMProfile_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetVMProfileSTATUS populates the provided destination VirtualMachineScaleSetVMProfile_STATUS from our VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetVMProfileSTATUS(destination *alpha20201201s.VirtualMachineScaleSetVMProfile_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BillingProfile
	if profile.BillingProfile != nil {
		var billingProfile alpha20201201s.BillingProfile_STATUS
<<<<<<< HEAD
		err := profile.BillingProfile.AssignPropertiesToBillingProfile_STATUS(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfile_STATUS() to populate field BillingProfile")
=======
		err := profile.BillingProfile.AssignPropertiesToBillingProfileSTATUS(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfileSTATUS() to populate field BillingProfile")
>>>>>>> main
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// DiagnosticsProfile
	if profile.DiagnosticsProfile != nil {
		var diagnosticsProfile alpha20201201s.DiagnosticsProfile_STATUS
<<<<<<< HEAD
		err := profile.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfile_STATUS(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
=======
		err := profile.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfileSTATUS(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfileSTATUS() to populate field DiagnosticsProfile")
>>>>>>> main
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if profile.EvictionPolicy != nil {
		evictionPolicy := string(*profile.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtensionProfile
	if profile.ExtensionProfile != nil {
		var extensionProfile alpha20201201s.VirtualMachineScaleSetExtensionProfile_STATUS
<<<<<<< HEAD
		err := profile.ExtensionProfile.AssignPropertiesToVirtualMachineScaleSetExtensionProfile_STATUS(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetExtensionProfile_STATUS() to populate field ExtensionProfile")
=======
		err := profile.ExtensionProfile.AssignPropertiesToVirtualMachineScaleSetExtensionProfileSTATUS(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetExtensionProfileSTATUS() to populate field ExtensionProfile")
>>>>>>> main
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile alpha20201201s.VirtualMachineScaleSetNetworkProfile_STATUS
<<<<<<< HEAD
		err := profile.NetworkProfile.AssignPropertiesToVirtualMachineScaleSetNetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkProfile_STATUS() to populate field NetworkProfile")
=======
		err := profile.NetworkProfile.AssignPropertiesToVirtualMachineScaleSetNetworkProfileSTATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkProfileSTATUS() to populate field NetworkProfile")
>>>>>>> main
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if profile.OsProfile != nil {
		var osProfile alpha20201201s.VirtualMachineScaleSetOSProfile_STATUS
<<<<<<< HEAD
		err := profile.OsProfile.AssignPropertiesToVirtualMachineScaleSetOSProfile_STATUS(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSProfile_STATUS() to populate field OsProfile")
=======
		err := profile.OsProfile.AssignPropertiesToVirtualMachineScaleSetOSProfileSTATUS(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSProfileSTATUS() to populate field OsProfile")
>>>>>>> main
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	if profile.Priority != nil {
		priority := string(*profile.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ScheduledEventsProfile
	if profile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile alpha20201201s.ScheduledEventsProfile_STATUS
<<<<<<< HEAD
		err := profile.ScheduledEventsProfile.AssignPropertiesToScheduledEventsProfile_STATUS(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
=======
		err := profile.ScheduledEventsProfile.AssignPropertiesToScheduledEventsProfileSTATUS(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToScheduledEventsProfileSTATUS() to populate field ScheduledEventsProfile")
>>>>>>> main
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile alpha20201201s.SecurityProfile_STATUS
<<<<<<< HEAD
		err := profile.SecurityProfile.AssignPropertiesToSecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfile_STATUS() to populate field SecurityProfile")
=======
		err := profile.SecurityProfile.AssignPropertiesToSecurityProfileSTATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfileSTATUS() to populate field SecurityProfile")
>>>>>>> main
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if profile.StorageProfile != nil {
		var storageProfile alpha20201201s.VirtualMachineScaleSetStorageProfile_STATUS
<<<<<<< HEAD
		err := profile.StorageProfile.AssignPropertiesToVirtualMachineScaleSetStorageProfile_STATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetStorageProfile_STATUS() to populate field StorageProfile")
=======
		err := profile.StorageProfile.AssignPropertiesToVirtualMachineScaleSetStorageProfileSTATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetStorageProfileSTATUS() to populate field StorageProfile")
>>>>>>> main
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutomaticOSUpgradePolicy. Use v1beta20201201.AutomaticOSUpgradePolicy instead
type AutomaticOSUpgradePolicy struct {
	DisableAutomaticRollback *bool `json:"disableAutomaticRollback,omitempty"`
	EnableAutomaticOSUpgrade *bool `json:"enableAutomaticOSUpgrade,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticOSUpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *AutomaticOSUpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &AutomaticOSUpgradePolicyARM{}

	// Set property ‘DisableAutomaticRollback’:
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		result.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		result.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticOSUpgradePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticOSUpgradePolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticOSUpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticOSUpgradePolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticOSUpgradePolicyARM, got %T", armInput)
	}

	// Set property ‘DisableAutomaticRollback’:
	if typedInput.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *typedInput.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if typedInput.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *typedInput.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticOSUpgradePolicy populates our AutomaticOSUpgradePolicy from the provided source AutomaticOSUpgradePolicy
func (policy *AutomaticOSUpgradePolicy) AssignPropertiesFromAutomaticOSUpgradePolicy(source *alpha20201201s.AutomaticOSUpgradePolicy) error {

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutomaticOSUpgradePolicy populates the provided destination AutomaticOSUpgradePolicy from our AutomaticOSUpgradePolicy
func (policy *AutomaticOSUpgradePolicy) AssignPropertiesToAutomaticOSUpgradePolicy(destination *alpha20201201s.AutomaticOSUpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableAutomaticRollback
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutomaticOSUpgradePolicy_STATUS. Use v1beta20201201.AutomaticOSUpgradePolicy_STATUS instead
type AutomaticOSUpgradePolicy_STATUS struct {
	DisableAutomaticRollback *bool `json:"disableAutomaticRollback,omitempty"`
	EnableAutomaticOSUpgrade *bool `json:"enableAutomaticOSUpgrade,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticOSUpgradePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticOSUpgradePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticOSUpgradePolicy_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticOSUpgradePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticOSUpgradePolicy_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticOSUpgradePolicy_STATUSARM, got %T", armInput)
	}

	// Set property ‘DisableAutomaticRollback’:
	if typedInput.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *typedInput.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if typedInput.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *typedInput.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromAutomaticOSUpgradePolicy_STATUS populates our AutomaticOSUpgradePolicy_STATUS from the provided source AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy_STATUS) AssignPropertiesFromAutomaticOSUpgradePolicy_STATUS(source *alpha20201201s.AutomaticOSUpgradePolicy_STATUS) error {
=======
// AssignPropertiesFromAutomaticOSUpgradePolicySTATUS populates our AutomaticOSUpgradePolicy_STATUS from the provided source AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy_STATUS) AssignPropertiesFromAutomaticOSUpgradePolicySTATUS(source *alpha20201201s.AutomaticOSUpgradePolicy_STATUS) error {
>>>>>>> main

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToAutomaticOSUpgradePolicy_STATUS populates the provided destination AutomaticOSUpgradePolicy_STATUS from our AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy_STATUS) AssignPropertiesToAutomaticOSUpgradePolicy_STATUS(destination *alpha20201201s.AutomaticOSUpgradePolicy_STATUS) error {
=======
// AssignPropertiesToAutomaticOSUpgradePolicySTATUS populates the provided destination AutomaticOSUpgradePolicy_STATUS from our AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy_STATUS) AssignPropertiesToAutomaticOSUpgradePolicySTATUS(destination *alpha20201201s.AutomaticOSUpgradePolicy_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableAutomaticRollback
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of RollingUpgradePolicy. Use v1beta20201201.RollingUpgradePolicy instead
type RollingUpgradePolicy struct {
	EnableCrossZoneUpgrade *bool `json:"enableCrossZoneUpgrade,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=5
	MaxBatchInstancePercent *int `json:"maxBatchInstancePercent,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=5
	MaxUnhealthyInstancePercent *int `json:"maxUnhealthyInstancePercent,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=0
	MaxUnhealthyUpgradedInstancePercent *int    `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`
	PauseTimeBetweenBatches             *string `json:"pauseTimeBetweenBatches,omitempty"`
	PrioritizeUnhealthyInstances        *bool   `json:"prioritizeUnhealthyInstances,omitempty"`
}

var _ genruntime.ARMTransformer = &RollingUpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *RollingUpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &RollingUpgradePolicyARM{}

	// Set property ‘EnableCrossZoneUpgrade’:
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		result.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if policy.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *policy.MaxBatchInstancePercent
		result.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if policy.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *policy.MaxUnhealthyInstancePercent
		result.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if policy.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *policy.MaxUnhealthyUpgradedInstancePercent
		result.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if policy.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *policy.PauseTimeBetweenBatches
		result.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *policy.PrioritizeUnhealthyInstances
		result.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *RollingUpgradePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RollingUpgradePolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *RollingUpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RollingUpgradePolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RollingUpgradePolicyARM, got %T", armInput)
	}

	// Set property ‘EnableCrossZoneUpgrade’:
	if typedInput.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *typedInput.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if typedInput.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *typedInput.MaxBatchInstancePercent
		policy.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if typedInput.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *typedInput.MaxUnhealthyInstancePercent
		policy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if typedInput.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *typedInput.MaxUnhealthyUpgradedInstancePercent
		policy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if typedInput.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *typedInput.PauseTimeBetweenBatches
		policy.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if typedInput.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *typedInput.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}

	// No error
	return nil
}

// AssignPropertiesFromRollingUpgradePolicy populates our RollingUpgradePolicy from the provided source RollingUpgradePolicy
func (policy *RollingUpgradePolicy) AssignPropertiesFromRollingUpgradePolicy(source *alpha20201201s.RollingUpgradePolicy) error {

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	if source.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *source.MaxBatchInstancePercent
		policy.MaxBatchInstancePercent = &maxBatchInstancePercent
	} else {
		policy.MaxBatchInstancePercent = nil
	}

	// MaxUnhealthyInstancePercent
	if source.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *source.MaxUnhealthyInstancePercent
		policy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	} else {
		policy.MaxUnhealthyInstancePercent = nil
	}

	// MaxUnhealthyUpgradedInstancePercent
	if source.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *source.MaxUnhealthyUpgradedInstancePercent
		policy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	} else {
		policy.MaxUnhealthyUpgradedInstancePercent = nil
	}

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRollingUpgradePolicy populates the provided destination RollingUpgradePolicy from our RollingUpgradePolicy
func (policy *RollingUpgradePolicy) AssignPropertiesToRollingUpgradePolicy(destination *alpha20201201s.RollingUpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableCrossZoneUpgrade
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	if policy.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *policy.MaxBatchInstancePercent
		destination.MaxBatchInstancePercent = &maxBatchInstancePercent
	} else {
		destination.MaxBatchInstancePercent = nil
	}

	// MaxUnhealthyInstancePercent
	if policy.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *policy.MaxUnhealthyInstancePercent
		destination.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	} else {
		destination.MaxUnhealthyInstancePercent = nil
	}

	// MaxUnhealthyUpgradedInstancePercent
	if policy.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *policy.MaxUnhealthyUpgradedInstancePercent
		destination.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	} else {
		destination.MaxUnhealthyUpgradedInstancePercent = nil
	}

	// PauseTimeBetweenBatches
	destination.PauseTimeBetweenBatches = genruntime.ClonePointerToString(policy.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *policy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of RollingUpgradePolicy_STATUS. Use v1beta20201201.RollingUpgradePolicy_STATUS instead
type RollingUpgradePolicy_STATUS struct {
	EnableCrossZoneUpgrade              *bool   `json:"enableCrossZoneUpgrade,omitempty"`
	MaxBatchInstancePercent             *int    `json:"maxBatchInstancePercent,omitempty"`
	MaxUnhealthyInstancePercent         *int    `json:"maxUnhealthyInstancePercent,omitempty"`
	MaxUnhealthyUpgradedInstancePercent *int    `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`
	PauseTimeBetweenBatches             *string `json:"pauseTimeBetweenBatches,omitempty"`
	PrioritizeUnhealthyInstances        *bool   `json:"prioritizeUnhealthyInstances,omitempty"`
}

var _ genruntime.FromARMConverter = &RollingUpgradePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *RollingUpgradePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RollingUpgradePolicy_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *RollingUpgradePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RollingUpgradePolicy_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RollingUpgradePolicy_STATUSARM, got %T", armInput)
	}

	// Set property ‘EnableCrossZoneUpgrade’:
	if typedInput.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *typedInput.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if typedInput.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *typedInput.MaxBatchInstancePercent
		policy.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if typedInput.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *typedInput.MaxUnhealthyInstancePercent
		policy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if typedInput.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *typedInput.MaxUnhealthyUpgradedInstancePercent
		policy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if typedInput.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *typedInput.PauseTimeBetweenBatches
		policy.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if typedInput.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *typedInput.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromRollingUpgradePolicy_STATUS populates our RollingUpgradePolicy_STATUS from the provided source RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy_STATUS) AssignPropertiesFromRollingUpgradePolicy_STATUS(source *alpha20201201s.RollingUpgradePolicy_STATUS) error {
=======
// AssignPropertiesFromRollingUpgradePolicySTATUS populates our RollingUpgradePolicy_STATUS from the provided source RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy_STATUS) AssignPropertiesFromRollingUpgradePolicySTATUS(source *alpha20201201s.RollingUpgradePolicy_STATUS) error {
>>>>>>> main

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	policy.MaxBatchInstancePercent = genruntime.ClonePointerToInt(source.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	policy.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	policy.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToRollingUpgradePolicy_STATUS populates the provided destination RollingUpgradePolicy_STATUS from our RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy_STATUS) AssignPropertiesToRollingUpgradePolicy_STATUS(destination *alpha20201201s.RollingUpgradePolicy_STATUS) error {
=======
// AssignPropertiesToRollingUpgradePolicySTATUS populates the provided destination RollingUpgradePolicy_STATUS from our RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy_STATUS) AssignPropertiesToRollingUpgradePolicySTATUS(destination *alpha20201201s.RollingUpgradePolicy_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableCrossZoneUpgrade
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	destination.MaxBatchInstancePercent = genruntime.ClonePointerToInt(policy.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	destination.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	destination.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	destination.PauseTimeBetweenBatches = genruntime.ClonePointerToString(policy.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *policy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ScaleInPolicy_Rules. Use v1beta20201201.ScaleInPolicy_Rules instead
// +kubebuilder:validation:Enum={"Default","NewestVM","OldestVM"}
type ScaleInPolicy_Rules string

const (
	ScaleInPolicy_Rules_Default  = ScaleInPolicy_Rules("Default")
	ScaleInPolicy_Rules_NewestVM = ScaleInPolicy_Rules("NewestVM")
	ScaleInPolicy_Rules_OldestVM = ScaleInPolicy_Rules("OldestVM")
)

<<<<<<< HEAD
// Deprecated version of ScaleInPolicy_Rules_STATUS. Use v1beta20201201.ScaleInPolicy_Rules_STATUS instead
type ScaleInPolicy_Rules_STATUS string

const (
	ScaleInPolicy_Rules_Default_STATUS  = ScaleInPolicy_Rules_STATUS("Default")
	ScaleInPolicy_Rules_NewestVM_STATUS = ScaleInPolicy_Rules_STATUS("NewestVM")
	ScaleInPolicy_Rules_OldestVM_STATUS = ScaleInPolicy_Rules_STATUS("OldestVM")
=======
// Deprecated version of ScaleInPolicySTATUSRules. Use v1beta20201201.ScaleInPolicySTATUSRules instead
type ScaleInPolicySTATUSRules string

const (
	ScaleInPolicySTATUSRules_Default  = ScaleInPolicySTATUSRules("Default")
	ScaleInPolicySTATUSRules_NewestVM = ScaleInPolicySTATUSRules("NewestVM")
	ScaleInPolicySTATUSRules_OldestVM = ScaleInPolicySTATUSRules("OldestVM")
>>>>>>> main
)

// Deprecated version of ScheduledEventsProfile. Use v1beta20201201.ScheduledEventsProfile instead
type ScheduledEventsProfile struct {
	TerminateNotificationProfile *TerminateNotificationProfile `json:"terminateNotificationProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduledEventsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ScheduledEventsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &ScheduledEventsProfileARM{}

	// Set property ‘TerminateNotificationProfile’:
	if profile.TerminateNotificationProfile != nil {
		terminateNotificationProfileARM, err := (*profile.TerminateNotificationProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		terminateNotificationProfile := *terminateNotificationProfileARM.(*TerminateNotificationProfileARM)
		result.TerminateNotificationProfile = &terminateNotificationProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ScheduledEventsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduledEventsProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ScheduledEventsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduledEventsProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduledEventsProfileARM, got %T", armInput)
	}

	// Set property ‘TerminateNotificationProfile’:
	if typedInput.TerminateNotificationProfile != nil {
		var terminateNotificationProfile1 TerminateNotificationProfile
		err := terminateNotificationProfile1.PopulateFromARM(owner, *typedInput.TerminateNotificationProfile)
		if err != nil {
			return err
		}
		terminateNotificationProfile := terminateNotificationProfile1
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromScheduledEventsProfile populates our ScheduledEventsProfile from the provided source ScheduledEventsProfile
func (profile *ScheduledEventsProfile) AssignPropertiesFromScheduledEventsProfile(source *alpha20201201s.ScheduledEventsProfile) error {

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile
		err := terminateNotificationProfile.AssignPropertiesFromTerminateNotificationProfile(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromTerminateNotificationProfile() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToScheduledEventsProfile populates the provided destination ScheduledEventsProfile from our ScheduledEventsProfile
func (profile *ScheduledEventsProfile) AssignPropertiesToScheduledEventsProfile(destination *alpha20201201s.ScheduledEventsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile alpha20201201s.TerminateNotificationProfile
		err := profile.TerminateNotificationProfile.AssignPropertiesToTerminateNotificationProfile(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToTerminateNotificationProfile() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ScheduledEventsProfile_STATUS. Use v1beta20201201.ScheduledEventsProfile_STATUS instead
type ScheduledEventsProfile_STATUS struct {
	TerminateNotificationProfile *TerminateNotificationProfile_STATUS `json:"terminateNotificationProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduledEventsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ScheduledEventsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduledEventsProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ScheduledEventsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduledEventsProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduledEventsProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘TerminateNotificationProfile’:
	if typedInput.TerminateNotificationProfile != nil {
		var terminateNotificationProfile1 TerminateNotificationProfile_STATUS
		err := terminateNotificationProfile1.PopulateFromARM(owner, *typedInput.TerminateNotificationProfile)
		if err != nil {
			return err
		}
		terminateNotificationProfile := terminateNotificationProfile1
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromScheduledEventsProfile_STATUS populates our ScheduledEventsProfile_STATUS from the provided source ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignPropertiesFromScheduledEventsProfile_STATUS(source *alpha20201201s.ScheduledEventsProfile_STATUS) error {
=======
// AssignPropertiesFromScheduledEventsProfileSTATUS populates our ScheduledEventsProfile_STATUS from the provided source ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignPropertiesFromScheduledEventsProfileSTATUS(source *alpha20201201s.ScheduledEventsProfile_STATUS) error {
>>>>>>> main

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile_STATUS
<<<<<<< HEAD
		err := terminateNotificationProfile.AssignPropertiesFromTerminateNotificationProfile_STATUS(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromTerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
=======
		err := terminateNotificationProfile.AssignPropertiesFromTerminateNotificationProfileSTATUS(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromTerminateNotificationProfileSTATUS() to populate field TerminateNotificationProfile")
>>>>>>> main
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToScheduledEventsProfile_STATUS populates the provided destination ScheduledEventsProfile_STATUS from our ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignPropertiesToScheduledEventsProfile_STATUS(destination *alpha20201201s.ScheduledEventsProfile_STATUS) error {
=======
// AssignPropertiesToScheduledEventsProfileSTATUS populates the provided destination ScheduledEventsProfile_STATUS from our ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignPropertiesToScheduledEventsProfileSTATUS(destination *alpha20201201s.ScheduledEventsProfile_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile alpha20201201s.TerminateNotificationProfile_STATUS
<<<<<<< HEAD
		err := profile.TerminateNotificationProfile.AssignPropertiesToTerminateNotificationProfile_STATUS(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToTerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
=======
		err := profile.TerminateNotificationProfile.AssignPropertiesToTerminateNotificationProfileSTATUS(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToTerminateNotificationProfileSTATUS() to populate field TerminateNotificationProfile")
>>>>>>> main
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of UpgradePolicy_Mode. Use v1beta20201201.UpgradePolicy_Mode instead
// +kubebuilder:validation:Enum={"Automatic","Manual","Rolling"}
type UpgradePolicy_Mode string

const (
	UpgradePolicy_Mode_Automatic = UpgradePolicy_Mode("Automatic")
	UpgradePolicy_Mode_Manual    = UpgradePolicy_Mode("Manual")
	UpgradePolicy_Mode_Rolling   = UpgradePolicy_Mode("Rolling")
)

<<<<<<< HEAD
// Deprecated version of UpgradePolicy_Mode_STATUS. Use v1beta20201201.UpgradePolicy_Mode_STATUS instead
type UpgradePolicy_Mode_STATUS string

const (
	UpgradePolicy_Mode_Automatic_STATUS = UpgradePolicy_Mode_STATUS("Automatic")
	UpgradePolicy_Mode_Manual_STATUS    = UpgradePolicy_Mode_STATUS("Manual")
	UpgradePolicy_Mode_Rolling_STATUS   = UpgradePolicy_Mode_STATUS("Rolling")
)

// Deprecated version of VirtualMachineScaleSetExtensionProfile. Use v1beta20201201.VirtualMachineScaleSetExtensionProfile instead
type VirtualMachineScaleSetExtensionProfile struct {
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetExtensionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetExtensionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetExtensionProfileARM{}

	// Set property ‘ExtensionsTimeBudget’:
	if profile.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *profile.ExtensionsTimeBudget
		result.ExtensionsTimeBudget = &extensionsTimeBudget
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetExtensionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtensionProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetExtensionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtensionProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetExtensionProfileARM, got %T", armInput)
	}

	// Set property ‘ExtensionsTimeBudget’:
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		profile.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetExtensionProfile populates our VirtualMachineScaleSetExtensionProfile from the provided source VirtualMachineScaleSetExtensionProfile
func (profile *VirtualMachineScaleSetExtensionProfile) AssignPropertiesFromVirtualMachineScaleSetExtensionProfile(source *alpha20201201s.VirtualMachineScaleSetExtensionProfile) error {

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetExtensionProfile populates the provided destination VirtualMachineScaleSetExtensionProfile from our VirtualMachineScaleSetExtensionProfile
func (profile *VirtualMachineScaleSetExtensionProfile) AssignPropertiesToVirtualMachineScaleSetExtensionProfile(destination *alpha20201201s.VirtualMachineScaleSetExtensionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetExtensionProfile_STATUS. Use v1beta20201201.VirtualMachineScaleSetExtensionProfile_STATUS instead
type VirtualMachineScaleSetExtensionProfile_STATUS struct {
	Extensions           []VirtualMachineScaleSetExtension_STATUS `json:"extensions,omitempty"`
	ExtensionsTimeBudget *string                                  `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtensionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtensionProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtensionProfile_STATUSARM)
	if !ok {
=======
// Deprecated version of UpgradePolicySTATUSMode. Use v1beta20201201.UpgradePolicySTATUSMode instead
type UpgradePolicySTATUSMode string

const (
	UpgradePolicySTATUSMode_Automatic = UpgradePolicySTATUSMode("Automatic")
	UpgradePolicySTATUSMode_Manual    = UpgradePolicySTATUSMode("Manual")
	UpgradePolicySTATUSMode_Rolling   = UpgradePolicySTATUSMode("Rolling")
)

// Deprecated version of VirtualMachineScaleSetExtensionProfile_STATUS. Use v1beta20201201.VirtualMachineScaleSetExtensionProfile_STATUS instead
type VirtualMachineScaleSetExtensionProfile_STATUS struct {
	Extensions           []VirtualMachineScaleSetExtension_STATUS `json:"extensions,omitempty"`
	ExtensionsTimeBudget *string                                  `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtensionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtensionProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtensionProfile_STATUSARM)
	if !ok {
>>>>>>> main
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetExtensionProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘Extensions’:
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineScaleSetExtension_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Extensions = append(profile.Extensions, item1)
	}

	// Set property ‘ExtensionsTimeBudget’:
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		profile.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_STATUS populates our VirtualMachineScaleSetExtensionProfile_STATUS from the provided source VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetExtensionProfile_STATUS(source *alpha20201201s.VirtualMachineScaleSetExtensionProfile_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetExtensionProfileSTATUS populates our VirtualMachineScaleSetExtensionProfile_STATUS from the provided source VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetExtensionProfileSTATUS(source *alpha20201201s.VirtualMachineScaleSetExtensionProfile_STATUS) error {
>>>>>>> main

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineScaleSetExtension_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineScaleSetExtension_STATUS
<<<<<<< HEAD
			err := extension.AssignPropertiesFromVirtualMachineScaleSetExtension_STATUS(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetExtension_STATUS() to populate field Extensions")
=======
			err := extension.AssignPropertiesFromVirtualMachineScaleSetExtensionSTATUS(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetExtensionSTATUS() to populate field Extensions")
>>>>>>> main
			}
			extensionList[extensionIndex] = extension
		}
		profile.Extensions = extensionList
	} else {
		profile.Extensions = nil
	}

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetExtensionProfile_STATUS populates the provided destination VirtualMachineScaleSetExtensionProfile_STATUS from our VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetExtensionProfile_STATUS(destination *alpha20201201s.VirtualMachineScaleSetExtensionProfile_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetExtensionProfileSTATUS populates the provided destination VirtualMachineScaleSetExtensionProfile_STATUS from our VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetExtensionProfileSTATUS(destination *alpha20201201s.VirtualMachineScaleSetExtensionProfile_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Extensions
	if profile.Extensions != nil {
		extensionList := make([]alpha20201201s.VirtualMachineScaleSetExtension_STATUS, len(profile.Extensions))
		for extensionIndex, extensionItem := range profile.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension alpha20201201s.VirtualMachineScaleSetExtension_STATUS
<<<<<<< HEAD
			err := extensionItem.AssignPropertiesToVirtualMachineScaleSetExtension_STATUS(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetExtension_STATUS() to populate field Extensions")
=======
			err := extensionItem.AssignPropertiesToVirtualMachineScaleSetExtensionSTATUS(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetExtensionSTATUS() to populate field Extensions")
>>>>>>> main
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// Deprecated version of VirtualMachineScaleSetNetworkProfile. Use v1beta20201201.VirtualMachineScaleSetNetworkProfile instead
type VirtualMachineScaleSetNetworkProfile struct {
	HealthProbe                    *ApiEntityReference                          `json:"healthProbe,omitempty"`
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetNetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetNetworkProfileARM{}

	// Set property ‘HealthProbe’:
	if profile.HealthProbe != nil {
		healthProbeARM, err := (*profile.HealthProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		healthProbe := *healthProbeARM.(*ApiEntityReferenceARM)
		result.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range profile.NetworkInterfaceConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaceConfigurations = append(result.NetworkInterfaceConfigurations, *itemARM.(*VirtualMachineScaleSetNetworkConfigurationARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetNetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetNetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkProfileARM, got %T", armInput)
=======
// Deprecated version of VirtualMachineScaleSetNetworkProfile_STATUS. Use v1beta20201201.VirtualMachineScaleSetNetworkProfile_STATUS instead
type VirtualMachineScaleSetNetworkProfile_STATUS struct {
	HealthProbe                    *ApiEntityReference_STATUS                          `json:"healthProbe,omitempty"`
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration_STATUS `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkProfile_STATUSARM, got %T", armInput)
>>>>>>> main
	}

	// Set property ‘HealthProbe’:
	if typedInput.HealthProbe != nil {
<<<<<<< HEAD
		var healthProbe1 ApiEntityReference
=======
		var healthProbe1 ApiEntityReference_STATUS
>>>>>>> main
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		profile.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range typedInput.NetworkInterfaceConfigurations {
<<<<<<< HEAD
		var item1 VirtualMachineScaleSetNetworkConfiguration
=======
		var item1 VirtualMachineScaleSetNetworkConfiguration_STATUS
>>>>>>> main
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetNetworkProfile populates our VirtualMachineScaleSetNetworkProfile from the provided source VirtualMachineScaleSetNetworkProfile
func (profile *VirtualMachineScaleSetNetworkProfile) AssignPropertiesFromVirtualMachineScaleSetNetworkProfile(source *alpha20201201s.VirtualMachineScaleSetNetworkProfile) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference
		err := healthProbe.AssignPropertiesFromApiEntityReference(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReference() to populate field HealthProbe")
=======
// AssignPropertiesFromVirtualMachineScaleSetNetworkProfileSTATUS populates our VirtualMachineScaleSetNetworkProfile_STATUS from the provided source VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetNetworkProfileSTATUS(source *alpha20201201s.VirtualMachineScaleSetNetworkProfile_STATUS) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference_STATUS
		err := healthProbe.AssignPropertiesFromApiEntityReferenceSTATUS(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReferenceSTATUS() to populate field HealthProbe")
>>>>>>> main
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
<<<<<<< HEAD
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration
			err := networkInterfaceConfiguration.AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration() to populate field NetworkInterfaceConfigurations")
=======
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration_STATUS, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration_STATUS
			err := networkInterfaceConfiguration.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationSTATUS(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationSTATUS() to populate field NetworkInterfaceConfigurations")
>>>>>>> main
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetNetworkProfile populates the provided destination VirtualMachineScaleSetNetworkProfile from our VirtualMachineScaleSetNetworkProfile
func (profile *VirtualMachineScaleSetNetworkProfile) AssignPropertiesToVirtualMachineScaleSetNetworkProfile(destination *alpha20201201s.VirtualMachineScaleSetNetworkProfile) error {
=======
// AssignPropertiesToVirtualMachineScaleSetNetworkProfileSTATUS populates the provided destination VirtualMachineScaleSetNetworkProfile_STATUS from our VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetNetworkProfileSTATUS(destination *alpha20201201s.VirtualMachineScaleSetNetworkProfile_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if profile.HealthProbe != nil {
<<<<<<< HEAD
		var healthProbe alpha20201201s.ApiEntityReference
		err := profile.HealthProbe.AssignPropertiesToApiEntityReference(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReference() to populate field HealthProbe")
=======
		var healthProbe alpha20201201s.ApiEntityReference_STATUS
		err := profile.HealthProbe.AssignPropertiesToApiEntityReferenceSTATUS(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReferenceSTATUS() to populate field HealthProbe")
>>>>>>> main
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
<<<<<<< HEAD
		networkInterfaceConfigurationList := make([]alpha20201201s.VirtualMachineScaleSetNetworkConfiguration, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration alpha20201201s.VirtualMachineScaleSetNetworkConfiguration
			err := networkInterfaceConfigurationItem.AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration() to populate field NetworkInterfaceConfigurations")
=======
		networkInterfaceConfigurationList := make([]alpha20201201s.VirtualMachineScaleSetNetworkConfiguration_STATUS, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration alpha20201201s.VirtualMachineScaleSetNetworkConfiguration_STATUS
			err := networkInterfaceConfigurationItem.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationSTATUS(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationSTATUS() to populate field NetworkInterfaceConfigurations")
>>>>>>> main
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// Deprecated version of VirtualMachineScaleSetNetworkProfile_STATUS. Use v1beta20201201.VirtualMachineScaleSetNetworkProfile_STATUS instead
type VirtualMachineScaleSetNetworkProfile_STATUS struct {
	HealthProbe                    *ApiEntityReference_STATUS                          `json:"healthProbe,omitempty"`
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration_STATUS `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘HealthProbe’:
	if typedInput.HealthProbe != nil {
		var healthProbe1 ApiEntityReference_STATUS
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		profile.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineScaleSetNetworkConfiguration_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_STATUS populates our VirtualMachineScaleSetNetworkProfile_STATUS from the provided source VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetNetworkProfile_STATUS(source *alpha20201201s.VirtualMachineScaleSetNetworkProfile_STATUS) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference_STATUS
		err := healthProbe.AssignPropertiesFromApiEntityReference_STATUS(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReference_STATUS() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration_STATUS, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration_STATUS
			err := networkInterfaceConfiguration.AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_STATUS(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkProfile_STATUS populates the provided destination VirtualMachineScaleSetNetworkProfile_STATUS from our VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetNetworkProfile_STATUS(destination *alpha20201201s.VirtualMachineScaleSetNetworkProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if profile.HealthProbe != nil {
		var healthProbe alpha20201201s.ApiEntityReference_STATUS
		err := profile.HealthProbe.AssignPropertiesToApiEntityReference_STATUS(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReference_STATUS() to populate field HealthProbe")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]alpha20201201s.VirtualMachineScaleSetNetworkConfiguration_STATUS, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration alpha20201201s.VirtualMachineScaleSetNetworkConfiguration_STATUS
			err := networkInterfaceConfigurationItem.AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_STATUS(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetOSProfile. Use v1beta20201201.VirtualMachineScaleSetOSProfile instead
type VirtualMachineScaleSetOSProfile struct {
	AdminPassword        *genruntime.SecretReference `json:"adminPassword,omitempty"`
	AdminUsername        *string                     `json:"adminUsername,omitempty"`
	ComputerNamePrefix   *string                     `json:"computerNamePrefix,omitempty"`
	CustomData           *string                     `json:"customData,omitempty"`
	LinuxConfiguration   *LinuxConfiguration         `json:"linuxConfiguration,omitempty"`
	Secrets              []VaultSecretGroup          `json:"secrets,omitempty"`
	WindowsConfiguration *WindowsConfiguration       `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetOSProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetOSProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetOSProfileARM{}

	// Set property ‘AdminPassword’:
	if profile.AdminPassword != nil {
		adminPasswordSecret, err := resolved.ResolvedSecrets.LookupSecret(*profile.AdminPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminPassword")
		}
		adminPassword := adminPasswordSecret
		result.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if profile.ComputerNamePrefix != nil {
		computerNamePrefix := *profile.ComputerNamePrefix
		result.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if profile.CustomData != nil {
		customData := *profile.CustomData
		result.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if profile.LinuxConfiguration != nil {
		linuxConfigurationARM, err := (*profile.LinuxConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxConfiguration := *linuxConfigurationARM.(*LinuxConfigurationARM)
		result.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range profile.Secrets {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, *itemARM.(*VaultSecretGroupARM))
	}

	// Set property ‘WindowsConfiguration’:
	if profile.WindowsConfiguration != nil {
		windowsConfigurationARM, err := (*profile.WindowsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsConfiguration := *windowsConfigurationARM.(*WindowsConfigurationARM)
		result.WindowsConfiguration = &windowsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetOSProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetOSProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSProfileARM, got %T", armInput)
	}

	// no assignment for property ‘AdminPassword’

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		profile.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSProfile populates our VirtualMachineScaleSetOSProfile from the provided source VirtualMachineScaleSetOSProfile
func (profile *VirtualMachineScaleSetOSProfile) AssignPropertiesFromVirtualMachineScaleSetOSProfile(source *alpha20201201s.VirtualMachineScaleSetOSProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignPropertiesFromLinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignPropertiesFromVaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignPropertiesFromWindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSProfile populates the provided destination VirtualMachineScaleSetOSProfile from our VirtualMachineScaleSetOSProfile
func (profile *VirtualMachineScaleSetOSProfile) AssignPropertiesToVirtualMachineScaleSetOSProfile(destination *alpha20201201s.VirtualMachineScaleSetOSProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration alpha20201201s.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]alpha20201201s.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret alpha20201201s.VaultSecretGroup
			err := secretItem.AssignPropertiesToVaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration alpha20201201s.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetOSProfile_STATUS. Use v1beta20201201.VirtualMachineScaleSetOSProfile_STATUS instead
type VirtualMachineScaleSetOSProfile_STATUS struct {
	AdminUsername        *string                      `json:"adminUsername,omitempty"`
	ComputerNamePrefix   *string                      `json:"computerNamePrefix,omitempty"`
	CustomData           *string                      `json:"customData,omitempty"`
	LinuxConfiguration   *LinuxConfiguration_STATUS   `json:"linuxConfiguration,omitempty"`
	Secrets              []VaultSecretGroup_STATUS    `json:"secrets,omitempty"`
	WindowsConfiguration *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetOSProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetOSProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSProfile_STATUSARM)
	if !ok {
=======
// Deprecated version of VirtualMachineScaleSetOSProfile_STATUS. Use v1beta20201201.VirtualMachineScaleSetOSProfile_STATUS instead
type VirtualMachineScaleSetOSProfile_STATUS struct {
	AdminUsername        *string                      `json:"adminUsername,omitempty"`
	ComputerNamePrefix   *string                      `json:"computerNamePrefix,omitempty"`
	CustomData           *string                      `json:"customData,omitempty"`
	LinuxConfiguration   *LinuxConfiguration_STATUS   `json:"linuxConfiguration,omitempty"`
	Secrets              []VaultSecretGroup_STATUS    `json:"secrets,omitempty"`
	WindowsConfiguration *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetOSProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetOSProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSProfile_STATUSARM)
	if !ok {
>>>>>>> main
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		profile.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration_STATUS
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration_STATUS
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetOSProfile_STATUS populates our VirtualMachineScaleSetOSProfile_STATUS from the provided source VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetOSProfile_STATUS(source *alpha20201201s.VirtualMachineScaleSetOSProfile_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetOSProfileSTATUS populates our VirtualMachineScaleSetOSProfile_STATUS from the provided source VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetOSProfileSTATUS(source *alpha20201201s.VirtualMachineScaleSetOSProfile_STATUS) error {
>>>>>>> main

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_STATUS
<<<<<<< HEAD
		err := linuxConfiguration.AssignPropertiesFromLinuxConfiguration_STATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfiguration_STATUS() to populate field LinuxConfiguration")
=======
		err := linuxConfiguration.AssignPropertiesFromLinuxConfigurationSTATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfigurationSTATUS() to populate field LinuxConfiguration")
>>>>>>> main
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_STATUS
<<<<<<< HEAD
			err := secret.AssignPropertiesFromVaultSecretGroup_STATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroup_STATUS() to populate field Secrets")
=======
			err := secret.AssignPropertiesFromVaultSecretGroupSTATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroupSTATUS() to populate field Secrets")
>>>>>>> main
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_STATUS
<<<<<<< HEAD
		err := windowsConfiguration.AssignPropertiesFromWindowsConfiguration_STATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfiguration_STATUS() to populate field WindowsConfiguration")
=======
		err := windowsConfiguration.AssignPropertiesFromWindowsConfigurationSTATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfigurationSTATUS() to populate field WindowsConfiguration")
>>>>>>> main
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetOSProfile_STATUS populates the provided destination VirtualMachineScaleSetOSProfile_STATUS from our VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetOSProfile_STATUS(destination *alpha20201201s.VirtualMachineScaleSetOSProfile_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetOSProfileSTATUS populates the provided destination VirtualMachineScaleSetOSProfile_STATUS from our VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetOSProfileSTATUS(destination *alpha20201201s.VirtualMachineScaleSetOSProfile_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration alpha20201201s.LinuxConfiguration_STATUS
<<<<<<< HEAD
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfiguration_STATUS(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfiguration_STATUS() to populate field LinuxConfiguration")
=======
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfigurationSTATUS(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfigurationSTATUS() to populate field LinuxConfiguration")
>>>>>>> main
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]alpha20201201s.VaultSecretGroup_STATUS, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret alpha20201201s.VaultSecretGroup_STATUS
<<<<<<< HEAD
			err := secretItem.AssignPropertiesToVaultSecretGroup_STATUS(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroup_STATUS() to populate field Secrets")
=======
			err := secretItem.AssignPropertiesToVaultSecretGroupSTATUS(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroupSTATUS() to populate field Secrets")
>>>>>>> main
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration alpha20201201s.WindowsConfiguration_STATUS
<<<<<<< HEAD
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfiguration_STATUS(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfiguration_STATUS() to populate field WindowsConfiguration")
=======
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfigurationSTATUS(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfigurationSTATUS() to populate field WindowsConfiguration")
>>>>>>> main
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
=======
// Deprecated version of VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile. Use v1beta20201201.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile instead
type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile struct {
	Extensions           []VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions `json:"extensions,omitempty"`
	ExtensionsTimeBudget *string                                                                                     `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM{}

	// Set property ‘Extensions’:
	for _, item := range profile.Extensions {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Extensions = append(result.Extensions, *itemARM.(*VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_ExtensionsARM))
	}

	// Set property ‘ExtensionsTimeBudget’:
	if profile.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *profile.ExtensionsTimeBudget
		result.ExtensionsTimeBudget = &extensionsTimeBudget
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM, got %T", armInput)
	}

	// Set property ‘Extensions’:
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Extensions = append(profile.Extensions, item1)
	}

	// Set property ‘ExtensionsTimeBudget’:
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		profile.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile(source *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) error {

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions
			err := extension.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		profile.Extensions = extensionList
	} else {
		profile.Extensions = nil
	}

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile(destination *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Extensions
	if profile.Extensions != nil {
		extensionList := make([]alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions, len(profile.Extensions))
		for extensionIndex, extensionItem := range profile.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions
			err := extensionItem.AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile. Use v1beta20201201.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile instead
type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile struct {
	HealthProbe                    *ApiEntityReference                                                                                           `json:"healthProbe,omitempty"`
	NetworkInterfaceConfigurations []VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM{}

	// Set property ‘HealthProbe’:
	if profile.HealthProbe != nil {
		healthProbeARM, err := (*profile.HealthProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		healthProbe := *healthProbeARM.(*ApiEntityReferenceARM)
		result.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range profile.NetworkInterfaceConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaceConfigurations = append(result.NetworkInterfaceConfigurations, *itemARM.(*VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurationsARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM, got %T", armInput)
	}

	// Set property ‘HealthProbe’:
	if typedInput.HealthProbe != nil {
		var healthProbe1 ApiEntityReference
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		profile.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile(source *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference
		err := healthProbe.AssignPropertiesFromApiEntityReference(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReference() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
			err := networkInterfaceConfiguration.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile(destination *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if profile.HealthProbe != nil {
		var healthProbe alpha20201201s.ApiEntityReference
		err := profile.HealthProbe.AssignPropertiesToApiEntityReference(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReference() to populate field HealthProbe")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
			err := networkInterfaceConfigurationItem.AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile. Use v1beta20201201.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile instead
type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile struct {
	AdminPassword        *genruntime.SecretReference `json:"adminPassword,omitempty"`
	AdminUsername        *string                     `json:"adminUsername,omitempty"`
	ComputerNamePrefix   *string                     `json:"computerNamePrefix,omitempty"`
	CustomData           *string                     `json:"customData,omitempty"`
	LinuxConfiguration   *LinuxConfiguration         `json:"linuxConfiguration,omitempty"`
	Secrets              []VaultSecretGroup          `json:"secrets,omitempty"`
	WindowsConfiguration *WindowsConfiguration       `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfileARM{}

	// Set property ‘AdminPassword’:
	if profile.AdminPassword != nil {
		adminPasswordSecret, err := resolved.ResolvedSecrets.LookupSecret(*profile.AdminPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminPassword")
		}
		adminPassword := adminPasswordSecret
		result.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if profile.ComputerNamePrefix != nil {
		computerNamePrefix := *profile.ComputerNamePrefix
		result.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if profile.CustomData != nil {
		customData := *profile.CustomData
		result.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if profile.LinuxConfiguration != nil {
		linuxConfigurationARM, err := (*profile.LinuxConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxConfiguration := *linuxConfigurationARM.(*LinuxConfigurationARM)
		result.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range profile.Secrets {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, *itemARM.(*VaultSecretGroupARM))
	}

	// Set property ‘WindowsConfiguration’:
	if profile.WindowsConfiguration != nil {
		windowsConfigurationARM, err := (*profile.WindowsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsConfiguration := *windowsConfigurationARM.(*WindowsConfigurationARM)
		result.WindowsConfiguration = &windowsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfileARM, got %T", armInput)
	}

	// no assignment for property ‘AdminPassword’

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		profile.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileOsProfile populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileOsProfile(source *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignPropertiesFromLinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignPropertiesFromVaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignPropertiesFromWindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileOsProfile populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile
func (profile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileOsProfile(destination *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_OsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration alpha20201201s.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]alpha20201201s.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret alpha20201201s.VaultSecretGroup
			err := secretItem.AssignPropertiesToVaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration alpha20201201s.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy. Use
// v1beta20201201.VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy instead
// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy string

const (
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy_Deallocate = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy("Deallocate")
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy_Delete     = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy("Delete")
)

// Deprecated version of VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority. Use
// v1beta20201201.VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority instead
// +kubebuilder:validation:Enum={"Low","Regular","Spot"}
type VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority string

const (
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority_Low     = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority("Low")
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority_Regular = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority("Regular")
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority_Spot    = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority("Spot")
)

>>>>>>> main
// Deprecated version of VirtualMachineScaleSetStorageProfile. Use v1beta20201201.VirtualMachineScaleSetStorageProfile instead
type VirtualMachineScaleSetStorageProfile struct {
	DataDisks      []VirtualMachineScaleSetDataDisk `json:"dataDisks,omitempty"`
	ImageReference *ImageReference                  `json:"imageReference,omitempty"`
	OsDisk         *VirtualMachineScaleSetOSDisk    `json:"osDisk,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetStorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetStorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetStorageProfileARM{}

	// Set property ‘DataDisks’:
	for _, item := range profile.DataDisks {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DataDisks = append(result.DataDisks, *itemARM.(*VirtualMachineScaleSetDataDiskARM))
	}

	// Set property ‘ImageReference’:
	if profile.ImageReference != nil {
		imageReferenceARM, err := (*profile.ImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageReference := *imageReferenceARM.(*ImageReferenceARM)
		result.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if profile.OsDisk != nil {
		osDiskARM, err := (*profile.OsDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osDisk := *osDiskARM.(*VirtualMachineScaleSetOSDiskARM)
		result.OsDisk = &osDisk
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetStorageProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetStorageProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetStorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetStorageProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetStorageProfileARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 VirtualMachineScaleSetDataDisk
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 VirtualMachineScaleSetOSDisk
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetStorageProfile populates our VirtualMachineScaleSetStorageProfile from the provided source VirtualMachineScaleSetStorageProfile
func (profile *VirtualMachineScaleSetStorageProfile) AssignPropertiesFromVirtualMachineScaleSetStorageProfile(source *alpha20201201s.VirtualMachineScaleSetStorageProfile) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk
			err := dataDisk.AssignPropertiesFromVirtualMachineScaleSetDataDisk(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignPropertiesFromImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReference() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk
		err := osDisk.AssignPropertiesFromVirtualMachineScaleSetOSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSDisk() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetStorageProfile populates the provided destination VirtualMachineScaleSetStorageProfile from our VirtualMachineScaleSetStorageProfile
func (profile *VirtualMachineScaleSetStorageProfile) AssignPropertiesToVirtualMachineScaleSetStorageProfile(destination *alpha20201201s.VirtualMachineScaleSetStorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]alpha20201201s.VirtualMachineScaleSetDataDisk, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk alpha20201201s.VirtualMachineScaleSetDataDisk
			err := dataDiskItem.AssignPropertiesToVirtualMachineScaleSetDataDisk(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference alpha20201201s.ImageReference
		err := profile.ImageReference.AssignPropertiesToImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReference() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk alpha20201201s.VirtualMachineScaleSetOSDisk
		err := profile.OsDisk.AssignPropertiesToVirtualMachineScaleSetOSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSDisk() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetStorageProfile_STATUS. Use v1beta20201201.VirtualMachineScaleSetStorageProfile_STATUS instead
type VirtualMachineScaleSetStorageProfile_STATUS struct {
	DataDisks      []VirtualMachineScaleSetDataDisk_STATUS `json:"dataDisks,omitempty"`
	ImageReference *ImageReference_STATUS                  `json:"imageReference,omitempty"`
	OsDisk         *VirtualMachineScaleSetOSDisk_STATUS    `json:"osDisk,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetStorageProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetStorageProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetStorageProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetStorageProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 VirtualMachineScaleSetDataDisk_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference_STATUS
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 VirtualMachineScaleSetOSDisk_STATUS
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetStorageProfile_STATUS populates our VirtualMachineScaleSetStorageProfile_STATUS from the provided source VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetStorageProfile_STATUS(source *alpha20201201s.VirtualMachineScaleSetStorageProfile_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetStorageProfileSTATUS populates our VirtualMachineScaleSetStorageProfile_STATUS from the provided source VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) AssignPropertiesFromVirtualMachineScaleSetStorageProfileSTATUS(source *alpha20201201s.VirtualMachineScaleSetStorageProfile_STATUS) error {
>>>>>>> main

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk_STATUS
<<<<<<< HEAD
			err := dataDisk.AssignPropertiesFromVirtualMachineScaleSetDataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetDataDisk_STATUS() to populate field DataDisks")
=======
			err := dataDisk.AssignPropertiesFromVirtualMachineScaleSetDataDiskSTATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetDataDiskSTATUS() to populate field DataDisks")
>>>>>>> main
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_STATUS
<<<<<<< HEAD
		err := imageReference.AssignPropertiesFromImageReference_STATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReference_STATUS() to populate field ImageReference")
=======
		err := imageReference.AssignPropertiesFromImageReferenceSTATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReferenceSTATUS() to populate field ImageReference")
>>>>>>> main
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk_STATUS
<<<<<<< HEAD
		err := osDisk.AssignPropertiesFromVirtualMachineScaleSetOSDisk_STATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSDisk_STATUS() to populate field OsDisk")
=======
		err := osDisk.AssignPropertiesFromVirtualMachineScaleSetOSDiskSTATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetOSDiskSTATUS() to populate field OsDisk")
>>>>>>> main
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetStorageProfile_STATUS populates the provided destination VirtualMachineScaleSetStorageProfile_STATUS from our VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetStorageProfile_STATUS(destination *alpha20201201s.VirtualMachineScaleSetStorageProfile_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetStorageProfileSTATUS populates the provided destination VirtualMachineScaleSetStorageProfile_STATUS from our VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) AssignPropertiesToVirtualMachineScaleSetStorageProfileSTATUS(destination *alpha20201201s.VirtualMachineScaleSetStorageProfile_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]alpha20201201s.VirtualMachineScaleSetDataDisk_STATUS, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk alpha20201201s.VirtualMachineScaleSetDataDisk_STATUS
<<<<<<< HEAD
			err := dataDiskItem.AssignPropertiesToVirtualMachineScaleSetDataDisk_STATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetDataDisk_STATUS() to populate field DataDisks")
=======
			err := dataDiskItem.AssignPropertiesToVirtualMachineScaleSetDataDiskSTATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetDataDiskSTATUS() to populate field DataDisks")
>>>>>>> main
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference alpha20201201s.ImageReference_STATUS
<<<<<<< HEAD
		err := profile.ImageReference.AssignPropertiesToImageReference_STATUS(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReference_STATUS() to populate field ImageReference")
=======
		err := profile.ImageReference.AssignPropertiesToImageReferenceSTATUS(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReferenceSTATUS() to populate field ImageReference")
>>>>>>> main
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk alpha20201201s.VirtualMachineScaleSetOSDisk_STATUS
<<<<<<< HEAD
		err := profile.OsDisk.AssignPropertiesToVirtualMachineScaleSetOSDisk_STATUS(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSDisk_STATUS() to populate field OsDisk")
=======
		err := profile.OsDisk.AssignPropertiesToVirtualMachineScaleSetOSDiskSTATUS(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetOSDiskSTATUS() to populate field OsDisk")
>>>>>>> main
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ApiEntityReference. Use v1beta20201201.ApiEntityReference instead
type ApiEntityReference struct {
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiEntityReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ApiEntityReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &ApiEntityReferenceARM{}

	// Set property ‘Id’:
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ApiEntityReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiEntityReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ApiEntityReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ApiEntityReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiEntityReferenceARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromApiEntityReference populates our ApiEntityReference from the provided source ApiEntityReference
func (reference *ApiEntityReference) AssignPropertiesFromApiEntityReference(source *alpha20201201s.ApiEntityReference) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApiEntityReference populates the provided destination ApiEntityReference from our ApiEntityReference
func (reference *ApiEntityReference) AssignPropertiesToApiEntityReference(destination *alpha20201201s.ApiEntityReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ApiEntityReference_STATUS. Use v1beta20201201.ApiEntityReference_STATUS instead
type ApiEntityReference_STATUS struct {
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiEntityReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ApiEntityReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiEntityReference_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ApiEntityReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiEntityReference_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiEntityReference_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromApiEntityReference_STATUS populates our ApiEntityReference_STATUS from the provided source ApiEntityReference_STATUS
func (reference *ApiEntityReference_STATUS) AssignPropertiesFromApiEntityReference_STATUS(source *alpha20201201s.ApiEntityReference_STATUS) error {
=======
// AssignPropertiesFromApiEntityReferenceSTATUS populates our ApiEntityReference_STATUS from the provided source ApiEntityReference_STATUS
func (reference *ApiEntityReference_STATUS) AssignPropertiesFromApiEntityReferenceSTATUS(source *alpha20201201s.ApiEntityReference_STATUS) error {
>>>>>>> main

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToApiEntityReference_STATUS populates the provided destination ApiEntityReference_STATUS from our ApiEntityReference_STATUS
func (reference *ApiEntityReference_STATUS) AssignPropertiesToApiEntityReference_STATUS(destination *alpha20201201s.ApiEntityReference_STATUS) error {
=======
// AssignPropertiesToApiEntityReferenceSTATUS populates the provided destination ApiEntityReference_STATUS from our ApiEntityReference_STATUS
func (reference *ApiEntityReference_STATUS) AssignPropertiesToApiEntityReferenceSTATUS(destination *alpha20201201s.ApiEntityReference_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of TerminateNotificationProfile. Use v1beta20201201.TerminateNotificationProfile instead
type TerminateNotificationProfile struct {
	Enable           *bool   `json:"enable,omitempty"`
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

var _ genruntime.ARMTransformer = &TerminateNotificationProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *TerminateNotificationProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &TerminateNotificationProfileARM{}

	// Set property ‘Enable’:
	if profile.Enable != nil {
		enable := *profile.Enable
		result.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if profile.NotBeforeTimeout != nil {
		notBeforeTimeout := *profile.NotBeforeTimeout
		result.NotBeforeTimeout = &notBeforeTimeout
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TerminateNotificationProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TerminateNotificationProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TerminateNotificationProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TerminateNotificationProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TerminateNotificationProfileARM, got %T", armInput)
	}

	// Set property ‘Enable’:
	if typedInput.Enable != nil {
		enable := *typedInput.Enable
		profile.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if typedInput.NotBeforeTimeout != nil {
		notBeforeTimeout := *typedInput.NotBeforeTimeout
		profile.NotBeforeTimeout = &notBeforeTimeout
	}

	// No error
	return nil
}

// AssignPropertiesFromTerminateNotificationProfile populates our TerminateNotificationProfile from the provided source TerminateNotificationProfile
func (profile *TerminateNotificationProfile) AssignPropertiesFromTerminateNotificationProfile(source *alpha20201201s.TerminateNotificationProfile) error {

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// No error
	return nil
}

// AssignPropertiesToTerminateNotificationProfile populates the provided destination TerminateNotificationProfile from our TerminateNotificationProfile
func (profile *TerminateNotificationProfile) AssignPropertiesToTerminateNotificationProfile(destination *alpha20201201s.TerminateNotificationProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of TerminateNotificationProfile_STATUS. Use v1beta20201201.TerminateNotificationProfile_STATUS instead
type TerminateNotificationProfile_STATUS struct {
	Enable           *bool   `json:"enable,omitempty"`
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

var _ genruntime.FromARMConverter = &TerminateNotificationProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TerminateNotificationProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &TerminateNotificationProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TerminateNotificationProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TerminateNotificationProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TerminateNotificationProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘Enable’:
	if typedInput.Enable != nil {
		enable := *typedInput.Enable
		profile.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if typedInput.NotBeforeTimeout != nil {
		notBeforeTimeout := *typedInput.NotBeforeTimeout
		profile.NotBeforeTimeout = &notBeforeTimeout
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromTerminateNotificationProfile_STATUS populates our TerminateNotificationProfile_STATUS from the provided source TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignPropertiesFromTerminateNotificationProfile_STATUS(source *alpha20201201s.TerminateNotificationProfile_STATUS) error {
=======
// AssignPropertiesFromTerminateNotificationProfileSTATUS populates our TerminateNotificationProfile_STATUS from the provided source TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignPropertiesFromTerminateNotificationProfileSTATUS(source *alpha20201201s.TerminateNotificationProfile_STATUS) error {
>>>>>>> main

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToTerminateNotificationProfile_STATUS populates the provided destination TerminateNotificationProfile_STATUS from our TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignPropertiesToTerminateNotificationProfile_STATUS(destination *alpha20201201s.TerminateNotificationProfile_STATUS) error {
=======
// AssignPropertiesToTerminateNotificationProfileSTATUS populates the provided destination TerminateNotificationProfile_STATUS from our TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignPropertiesToTerminateNotificationProfileSTATUS(destination *alpha20201201s.TerminateNotificationProfile_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetDataDisk. Use v1beta20201201.VirtualMachineScaleSetDataDisk instead
type VirtualMachineScaleSetDataDisk struct {
	Caching *Caching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	CreateOption      *CreateOption `json:"createOption,omitempty"`
	DiskIOPSReadWrite *int          `json:"diskIOPSReadWrite,omitempty"`
	DiskMBpsReadWrite *int          `json:"diskMBpsReadWrite,omitempty"`
	DiskSizeGB        *int          `json:"diskSizeGB,omitempty"`

	// +kubebuilder:validation:Required
	Lun                     *int                                         `json:"lun,omitempty"`
	ManagedDisk             *VirtualMachineScaleSetManagedDiskParameters `json:"managedDisk,omitempty"`
	Name                    *string                                      `json:"name,omitempty"`
	WriteAcceleratorEnabled *bool                                        `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetDataDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *VirtualMachineScaleSetDataDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetDataDiskARM{}

	// Set property ‘Caching’:
	if disk.Caching != nil {
		caching := *disk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if disk.CreateOption != nil {
		createOption := *disk.CreateOption
		result.CreateOption = &createOption
	}

	// Set property ‘DiskIOPSReadWrite’:
	if disk.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *disk.DiskIOPSReadWrite
		result.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if disk.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *disk.DiskMBpsReadWrite
		result.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	if disk.Lun != nil {
		lun := *disk.Lun
		result.Lun = &lun
	}

	// Set property ‘ManagedDisk’:
	if disk.ManagedDisk != nil {
		managedDiskARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDiskARM.(*VirtualMachineScaleSetManagedDiskParametersARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetDataDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetDataDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetDataDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetDataDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetDataDiskARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if typedInput.CreateOption != nil {
		createOption := *typedInput.CreateOption
		disk.CreateOption = &createOption
	}

	// Set property ‘DiskIOPSReadWrite’:
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		disk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		disk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetDataDisk populates our VirtualMachineScaleSetDataDisk from the provided source VirtualMachineScaleSetDataDisk
func (disk *VirtualMachineScaleSetDataDisk) AssignPropertiesFromVirtualMachineScaleSetDataDisk(source *alpha20201201s.VirtualMachineScaleSetDataDisk) error {

	// Caching
	if source.Caching != nil {
		caching := Caching(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := CreateOption(*source.CreateOption)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetDataDisk populates the provided destination VirtualMachineScaleSetDataDisk from our VirtualMachineScaleSetDataDisk
func (disk *VirtualMachineScaleSetDataDisk) AssignPropertiesToVirtualMachineScaleSetDataDisk(destination *alpha20201201s.VirtualMachineScaleSetDataDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk alpha20201201s.VirtualMachineScaleSetManagedDiskParameters
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetDataDisk_STATUS. Use v1beta20201201.VirtualMachineScaleSetDataDisk_STATUS instead
type VirtualMachineScaleSetDataDisk_STATUS struct {
	Caching                 *Caching_STATUS                                     `json:"caching,omitempty"`
	CreateOption            *CreateOption_STATUS                                `json:"createOption,omitempty"`
	DiskIOPSReadWrite       *int                                                `json:"diskIOPSReadWrite,omitempty"`
	DiskMBpsReadWrite       *int                                                `json:"diskMBpsReadWrite,omitempty"`
	DiskSizeGB              *int                                                `json:"diskSizeGB,omitempty"`
	Lun                     *int                                                `json:"lun,omitempty"`
	ManagedDisk             *VirtualMachineScaleSetManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`
	Name                    *string                                             `json:"name,omitempty"`
	WriteAcceleratorEnabled *bool                                               `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetDataDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetDataDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetDataDisk_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetDataDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetDataDisk_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetDataDisk_STATUSARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if typedInput.CreateOption != nil {
		createOption := *typedInput.CreateOption
		disk.CreateOption = &createOption
	}

	// Set property ‘DiskIOPSReadWrite’:
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		disk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		disk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetDataDisk_STATUS populates our VirtualMachineScaleSetDataDisk_STATUS from the provided source VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk_STATUS) AssignPropertiesFromVirtualMachineScaleSetDataDisk_STATUS(source *alpha20201201s.VirtualMachineScaleSetDataDisk_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetDataDiskSTATUS populates our VirtualMachineScaleSetDataDisk_STATUS from the provided source VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk_STATUS) AssignPropertiesFromVirtualMachineScaleSetDataDiskSTATUS(source *alpha20201201s.VirtualMachineScaleSetDataDisk_STATUS) error {
>>>>>>> main

	// Caching
	if source.Caching != nil {
		caching := Caching_STATUS(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := CreateOption_STATUS(*source.CreateOption)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_STATUS
<<<<<<< HEAD
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
=======
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSTATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSTATUS() to populate field ManagedDisk")
>>>>>>> main
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetDataDisk_STATUS populates the provided destination VirtualMachineScaleSetDataDisk_STATUS from our VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk_STATUS) AssignPropertiesToVirtualMachineScaleSetDataDisk_STATUS(destination *alpha20201201s.VirtualMachineScaleSetDataDisk_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetDataDiskSTATUS populates the provided destination VirtualMachineScaleSetDataDisk_STATUS from our VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk_STATUS) AssignPropertiesToVirtualMachineScaleSetDataDiskSTATUS(destination *alpha20201201s.VirtualMachineScaleSetDataDisk_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk alpha20201201s.VirtualMachineScaleSetManagedDiskParameters_STATUS
<<<<<<< HEAD
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
=======
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSTATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSTATUS() to populate field ManagedDisk")
>>>>>>> main
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetExtension_STATUS. Use v1beta20201201.VirtualMachineScaleSetExtension_STATUS instead
type VirtualMachineScaleSetExtension_STATUS struct {
<<<<<<< HEAD
	Id *string `json:"id,omitempty"`
=======
	AutoUpgradeMinorVersion  *bool              `json:"autoUpgradeMinorVersion,omitempty"`
	EnableAutomaticUpgrade   *bool              `json:"enableAutomaticUpgrade,omitempty"`
	ForceUpdateTag           *string            `json:"forceUpdateTag,omitempty"`
	Id                       *string            `json:"id,omitempty"`
	Name                     *string            `json:"name,omitempty"`
	PropertiesType           *string            `json:"properties_type,omitempty"`
	ProtectedSettings        map[string]v1.JSON `json:"protectedSettings,omitempty"`
	ProvisionAfterExtensions []string           `json:"provisionAfterExtensions,omitempty"`
	ProvisioningState        *string            `json:"provisioningState,omitempty"`
	Publisher                *string            `json:"publisher,omitempty"`
	Settings                 map[string]v1.JSON `json:"settings,omitempty"`
	Type                     *string            `json:"type,omitempty"`
	TypeHandlerVersion       *string            `json:"typeHandlerVersion,omitempty"`
>>>>>>> main
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtension_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *VirtualMachineScaleSetExtension_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtension_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *VirtualMachineScaleSetExtension_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtension_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetExtension_STATUSARM, got %T", armInput)
<<<<<<< HEAD
=======
	}

	// Set property ‘AutoUpgradeMinorVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// Set property ‘EnableAutomaticUpgrade’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutomaticUpgrade != nil {
			enableAutomaticUpgrade := *typedInput.Properties.EnableAutomaticUpgrade
			extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
		}
	}

	// Set property ‘ForceUpdateTag’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceUpdateTag != nil {
			forceUpdateTag := *typedInput.Properties.ForceUpdateTag
			extension.ForceUpdateTag = &forceUpdateTag
		}
>>>>>>> main
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		extension.Id = &id
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetExtension_STATUS populates our VirtualMachineScaleSetExtension_STATUS from the provided source VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension_STATUS) AssignPropertiesFromVirtualMachineScaleSetExtension_STATUS(source *alpha20201201s.VirtualMachineScaleSetExtension_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetExtensionSTATUS populates our VirtualMachineScaleSetExtension_STATUS from the provided source VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension_STATUS) AssignPropertiesFromVirtualMachineScaleSetExtensionSTATUS(source *alpha20201201s.VirtualMachineScaleSetExtension_STATUS) error {

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)
>>>>>>> main

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetExtension_STATUS populates the provided destination VirtualMachineScaleSetExtension_STATUS from our VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension_STATUS) AssignPropertiesToVirtualMachineScaleSetExtension_STATUS(destination *alpha20201201s.VirtualMachineScaleSetExtension_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetExtensionSTATUS populates the provided destination VirtualMachineScaleSetExtension_STATUS from our VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension_STATUS) AssignPropertiesToVirtualMachineScaleSetExtensionSTATUS(destination *alpha20201201s.VirtualMachineScaleSetExtension_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// Deprecated version of VirtualMachineScaleSetNetworkConfiguration. Use v1beta20201201.VirtualMachineScaleSetNetworkConfiguration instead
type VirtualMachineScaleSetNetworkConfiguration struct {
	DnsSettings                 *VirtualMachineScaleSetNetworkConfigurationDnsSettings `json:"dnsSettings,omitempty"`
	EnableAcceleratedNetworking *bool                                                  `json:"enableAcceleratedNetworking,omitempty"`
	EnableFpga                  *bool                                                  `json:"enableFpga,omitempty"`
	EnableIPForwarding          *bool                                                  `json:"enableIPForwarding,omitempty"`

	// +kubebuilder:validation:Required
	IpConfigurations []VirtualMachineScaleSetIPConfiguration `json:"ipConfigurations,omitempty"`

	// +kubebuilder:validation:Required
	Name                 *string                       `json:"name,omitempty"`
	NetworkSecurityGroup *SubResource                  `json:"networkSecurityGroup,omitempty"`
	Primary              *bool                         `json:"primary,omitempty"`
	Reference            *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetNetworkConfigurationARM{}

	// Set property ‘Id’:
	if configuration.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*configuration.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if configuration.DnsSettings != nil ||
		configuration.EnableAcceleratedNetworking != nil ||
		configuration.EnableFpga != nil ||
		configuration.EnableIPForwarding != nil ||
		configuration.IpConfigurations != nil ||
		configuration.NetworkSecurityGroup != nil ||
		configuration.Primary != nil {
		result.Properties = &VirtualMachineScaleSetNetworkConfigurationPropertiesARM{}
	}
	if configuration.DnsSettings != nil {
		dnsSettingsARM, err := (*configuration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettingsARM.(*VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		result.Properties.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	}
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		result.Properties.EnableFpga = &enableFpga
	}
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		result.Properties.EnableIPForwarding = &enableIPForwarding
	}
	for _, item := range configuration.IpConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, *itemARM.(*VirtualMachineScaleSetIPConfigurationARM))
	}
	if configuration.NetworkSecurityGroup != nil {
		networkSecurityGroupARM, err := (*configuration.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := *networkSecurityGroupARM.(*SubResourceARM)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if configuration.Primary != nil {
		primary := *configuration.Primary
		result.Properties.Primary = &primary
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetNetworkConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfigurationARM, got %T", armInput)
=======
// Deprecated version of VirtualMachineScaleSetNetworkConfiguration_STATUS. Use v1beta20201201.VirtualMachineScaleSetNetworkConfiguration_STATUS instead
type VirtualMachineScaleSetNetworkConfiguration_STATUS struct {
	DnsSettings                 *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS `json:"dnsSettings,omitempty"`
	EnableAcceleratedNetworking *bool                                                         `json:"enableAcceleratedNetworking,omitempty"`
	EnableFpga                  *bool                                                         `json:"enableFpga,omitempty"`
	EnableIPForwarding          *bool                                                         `json:"enableIPForwarding,omitempty"`
	Id                          *string                                                       `json:"id,omitempty"`
	IpConfigurations            []VirtualMachineScaleSetIPConfiguration_STATUS                `json:"ipConfigurations,omitempty"`
	Name                        *string                                                       `json:"name,omitempty"`
	NetworkSecurityGroup        *SubResource_STATUS                                           `json:"networkSecurityGroup,omitempty"`
	Primary                     *bool                                                         `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfiguration_STATUSARM, got %T", armInput)
>>>>>>> main
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
<<<<<<< HEAD
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableFpga’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configuration.EnableFpga = &enableFpga
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configuration.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSetIPConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configuration.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration populates our VirtualMachineScaleSetNetworkConfiguration from the provided source VirtualMachineScaleSetNetworkConfiguration
func (configuration *VirtualMachineScaleSetNetworkConfiguration) AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration(source *alpha20201201s.VirtualMachineScaleSetNetworkConfiguration) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration
			err := ipConfiguration.AssignPropertiesFromVirtualMachineScaleSetIPConfiguration(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource
		err := networkSecurityGroup.AssignPropertiesFromSubResource(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration populates the provided destination VirtualMachineScaleSetNetworkConfiguration from our VirtualMachineScaleSetNetworkConfiguration
func (configuration *VirtualMachineScaleSetNetworkConfiguration) AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration(destination *alpha20201201s.VirtualMachineScaleSetNetworkConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]alpha20201201s.VirtualMachineScaleSetIPConfiguration, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration alpha20201201s.VirtualMachineScaleSetIPConfiguration
			err := ipConfigurationItem.AssignPropertiesToVirtualMachineScaleSetIPConfiguration(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var networkSecurityGroup alpha20201201s.SubResource
		err := configuration.NetworkSecurityGroup.AssignPropertiesToSubResource(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetNetworkConfiguration_STATUS. Use v1beta20201201.VirtualMachineScaleSetNetworkConfiguration_STATUS instead
type VirtualMachineScaleSetNetworkConfiguration_STATUS struct {
	DnsSettings                 *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS `json:"dnsSettings,omitempty"`
	EnableAcceleratedNetworking *bool                                                         `json:"enableAcceleratedNetworking,omitempty"`
	EnableFpga                  *bool                                                         `json:"enableFpga,omitempty"`
	EnableIPForwarding          *bool                                                         `json:"enableIPForwarding,omitempty"`
	Id                          *string                                                       `json:"id,omitempty"`
	IpConfigurations            []VirtualMachineScaleSetIPConfiguration_STATUS                `json:"ipConfigurations,omitempty"`
	Name                        *string                                                       `json:"name,omitempty"`
	NetworkSecurityGroup        *SubResource_STATUS                                           `json:"networkSecurityGroup,omitempty"`
	Primary                     *bool                                                         `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
=======
>>>>>>> main
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableFpga’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configuration.EnableFpga = &enableFpga
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configuration.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSetIPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource_STATUS
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configuration.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_STATUS populates our VirtualMachineScaleSetNetworkConfiguration_STATUS from the provided source VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) AssignPropertiesFromVirtualMachineScaleSetNetworkConfiguration_STATUS(source *alpha20201201s.VirtualMachineScaleSetNetworkConfiguration_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationSTATUS populates our VirtualMachineScaleSetNetworkConfiguration_STATUS from the provided source VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationSTATUS(source *alpha20201201s.VirtualMachineScaleSetNetworkConfiguration_STATUS) error {
>>>>>>> main

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
<<<<<<< HEAD
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS() to populate field DnsSettings")
=======
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsSTATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsSTATUS() to populate field DnsSettings")
>>>>>>> main
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration_STATUS, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration_STATUS
<<<<<<< HEAD
			err := ipConfiguration.AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_STATUS() to populate field IpConfigurations")
=======
			err := ipConfiguration.AssignPropertiesFromVirtualMachineScaleSetIPConfigurationSTATUS(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIPConfigurationSTATUS() to populate field IpConfigurations")
>>>>>>> main
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource_STATUS
<<<<<<< HEAD
		err := networkSecurityGroup.AssignPropertiesFromSubResource_STATUS(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field NetworkSecurityGroup")
=======
		err := networkSecurityGroup.AssignPropertiesFromSubResourceSTATUS(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field NetworkSecurityGroup")
>>>>>>> main
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_STATUS populates the provided destination VirtualMachineScaleSetNetworkConfiguration_STATUS from our VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) AssignPropertiesToVirtualMachineScaleSetNetworkConfiguration_STATUS(destination *alpha20201201s.VirtualMachineScaleSetNetworkConfiguration_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationSTATUS populates the provided destination VirtualMachineScaleSetNetworkConfiguration_STATUS from our VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationSTATUS(destination *alpha20201201s.VirtualMachineScaleSetNetworkConfiguration_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
<<<<<<< HEAD
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS() to populate field DnsSettings")
=======
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsSTATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsSTATUS() to populate field DnsSettings")
>>>>>>> main
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]alpha20201201s.VirtualMachineScaleSetIPConfiguration_STATUS, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration alpha20201201s.VirtualMachineScaleSetIPConfiguration_STATUS
<<<<<<< HEAD
			err := ipConfigurationItem.AssignPropertiesToVirtualMachineScaleSetIPConfiguration_STATUS(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIPConfiguration_STATUS() to populate field IpConfigurations")
=======
			err := ipConfigurationItem.AssignPropertiesToVirtualMachineScaleSetIPConfigurationSTATUS(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIPConfigurationSTATUS() to populate field IpConfigurations")
>>>>>>> main
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var networkSecurityGroup alpha20201201s.SubResource_STATUS
<<<<<<< HEAD
		err := configuration.NetworkSecurityGroup.AssignPropertiesToSubResource_STATUS(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field NetworkSecurityGroup")
=======
		err := configuration.NetworkSecurityGroup.AssignPropertiesToSubResourceSTATUS(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field NetworkSecurityGroup")
>>>>>>> main
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetOSDisk. Use v1beta20201201.VirtualMachineScaleSetOSDisk instead
type VirtualMachineScaleSetOSDisk struct {
	Caching *Caching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	CreateOption            *CreateOption                                `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings                            `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                                         `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk                             `json:"image,omitempty"`
	ManagedDisk             *VirtualMachineScaleSetManagedDiskParameters `json:"managedDisk,omitempty"`
	Name                    *string                                      `json:"name,omitempty"`
	OsType                  *VirtualMachineScaleSetOSDisk_OsType         `json:"osType,omitempty"`
	VhdContainers           []string                                     `json:"vhdContainers,omitempty"`
	WriteAcceleratorEnabled *bool                                        `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetOSDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *VirtualMachineScaleSetOSDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetOSDiskARM{}

	// Set property ‘Caching’:
	if disk.Caching != nil {
		caching := *disk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if disk.CreateOption != nil {
		createOption := *disk.CreateOption
		result.CreateOption = &createOption
	}

	// Set property ‘DiffDiskSettings’:
	if disk.DiffDiskSettings != nil {
		diffDiskSettingsARM, err := (*disk.DiffDiskSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diffDiskSettings := *diffDiskSettingsARM.(*DiffDiskSettingsARM)
		result.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if disk.Image != nil {
		imageARM, err := (*disk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := *imageARM.(*VirtualHardDiskARM)
		result.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if disk.ManagedDisk != nil {
		managedDiskARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDiskARM.(*VirtualMachineScaleSetManagedDiskParametersARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property ‘OsType’:
	if disk.OsType != nil {
		osType := *disk.OsType
		result.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range disk.VhdContainers {
		result.VhdContainers = append(result.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetOSDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetOSDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSDiskARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if typedInput.CreateOption != nil {
		createOption := *typedInput.CreateOption
		disk.CreateOption = &createOption
	}

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		disk.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range typedInput.VhdContainers {
		disk.VhdContainers = append(disk.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSDisk populates our VirtualMachineScaleSetOSDisk from the provided source VirtualMachineScaleSetOSDisk
func (disk *VirtualMachineScaleSetOSDisk) AssignPropertiesFromVirtualMachineScaleSetOSDisk(source *alpha20201201s.VirtualMachineScaleSetOSDisk) error {

	// Caching
	if source.Caching != nil {
		caching := Caching(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := CreateOption(*source.CreateOption)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettings() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignPropertiesFromVirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := VirtualMachineScaleSetOSDisk_OsType(*source.OsType)
		disk.OsType = &osType
	} else {
		disk.OsType = nil
	}

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSDisk populates the provided destination VirtualMachineScaleSetOSDisk from our VirtualMachineScaleSetOSDisk
func (disk *VirtualMachineScaleSetOSDisk) AssignPropertiesToVirtualMachineScaleSetOSDisk(destination *alpha20201201s.VirtualMachineScaleSetOSDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting alpha20201201s.DiffDiskSettings
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettings() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image alpha20201201s.VirtualHardDisk
		err := disk.Image.AssignPropertiesToVirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk alpha20201201s.VirtualMachineScaleSetManagedDiskParameters
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// VhdContainers
	destination.VhdContainers = genruntime.CloneSliceOfString(disk.VhdContainers)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetOSDisk_STATUS. Use v1beta20201201.VirtualMachineScaleSetOSDisk_STATUS instead
type VirtualMachineScaleSetOSDisk_STATUS struct {
	Caching                 *Caching_STATUS                                     `json:"caching,omitempty"`
	CreateOption            *CreateOption_STATUS                                `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings_STATUS                            `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                                                `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk_STATUS                             `json:"image,omitempty"`
	ManagedDisk             *VirtualMachineScaleSetManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`
	Name                    *string                                             `json:"name,omitempty"`
<<<<<<< HEAD
	OsType                  *VirtualMachineScaleSetOSDisk_OsType_STATUS         `json:"osType,omitempty"`
=======
	OsType                  *VirtualMachineScaleSetOSDiskSTATUSOsType           `json:"osType,omitempty"`
>>>>>>> main
	VhdContainers           []string                                            `json:"vhdContainers,omitempty"`
	WriteAcceleratorEnabled *bool                                               `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetOSDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSDisk_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetOSDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSDisk_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSDisk_STATUSARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		disk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	if typedInput.CreateOption != nil {
		createOption := *typedInput.CreateOption
		disk.CreateOption = &createOption
	}

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings_STATUS
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_STATUS
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		disk.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range typedInput.VhdContainers {
		disk.VhdContainers = append(disk.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetOSDisk_STATUS populates our VirtualMachineScaleSetOSDisk_STATUS from the provided source VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk_STATUS) AssignPropertiesFromVirtualMachineScaleSetOSDisk_STATUS(source *alpha20201201s.VirtualMachineScaleSetOSDisk_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetOSDiskSTATUS populates our VirtualMachineScaleSetOSDisk_STATUS from the provided source VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk_STATUS) AssignPropertiesFromVirtualMachineScaleSetOSDiskSTATUS(source *alpha20201201s.VirtualMachineScaleSetOSDisk_STATUS) error {
>>>>>>> main

	// Caching
	if source.Caching != nil {
		caching := Caching_STATUS(*source.Caching)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := CreateOption_STATUS(*source.CreateOption)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_STATUS
<<<<<<< HEAD
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettings_STATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettings_STATUS() to populate field DiffDiskSettings")
=======
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettingsSTATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettingsSTATUS() to populate field DiffDiskSettings")
>>>>>>> main
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
<<<<<<< HEAD
		err := image.AssignPropertiesFromVirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk_STATUS() to populate field Image")
=======
		err := image.AssignPropertiesFromVirtualHardDiskSTATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Image")
>>>>>>> main
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_STATUS
<<<<<<< HEAD
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
=======
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSTATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSTATUS() to populate field ManagedDisk")
>>>>>>> main
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
<<<<<<< HEAD
		osType := VirtualMachineScaleSetOSDisk_OsType_STATUS(*source.OsType)
=======
		osType := VirtualMachineScaleSetOSDiskSTATUSOsType(*source.OsType)
>>>>>>> main
		disk.OsType = &osType
	} else {
		disk.OsType = nil
	}

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetOSDisk_STATUS populates the provided destination VirtualMachineScaleSetOSDisk_STATUS from our VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk_STATUS) AssignPropertiesToVirtualMachineScaleSetOSDisk_STATUS(destination *alpha20201201s.VirtualMachineScaleSetOSDisk_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetOSDiskSTATUS populates the provided destination VirtualMachineScaleSetOSDisk_STATUS from our VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk_STATUS) AssignPropertiesToVirtualMachineScaleSetOSDiskSTATUS(destination *alpha20201201s.VirtualMachineScaleSetOSDisk_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting alpha20201201s.DiffDiskSettings_STATUS
<<<<<<< HEAD
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettings_STATUS(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettings_STATUS() to populate field DiffDiskSettings")
=======
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettingsSTATUS(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettingsSTATUS() to populate field DiffDiskSettings")
>>>>>>> main
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image alpha20201201s.VirtualHardDisk_STATUS
<<<<<<< HEAD
		err := disk.Image.AssignPropertiesToVirtualHardDisk_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk_STATUS() to populate field Image")
=======
		err := disk.Image.AssignPropertiesToVirtualHardDiskSTATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Image")
>>>>>>> main
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk alpha20201201s.VirtualMachineScaleSetManagedDiskParameters_STATUS
<<<<<<< HEAD
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
=======
		err := disk.ManagedDisk.AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSTATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSTATUS() to populate field ManagedDisk")
>>>>>>> main
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// VhdContainers
	destination.VhdContainers = genruntime.CloneSliceOfString(disk.VhdContainers)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetIPConfiguration. Use v1beta20201201.VirtualMachineScaleSetIPConfiguration instead
type VirtualMachineScaleSetIPConfiguration struct {
	ApplicationGatewayBackendAddressPools []SubResource `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []SubResource `json:"applicationSecurityGroups,omitempty"`
	LoadBalancerBackendAddressPools       []SubResource `json:"loadBalancerBackendAddressPools,omitempty"`
	LoadBalancerInboundNatPools           []SubResource `json:"loadBalancerInboundNatPools,omitempty"`

	// +kubebuilder:validation:Required
	Name                         *string                                                                  `json:"name,omitempty"`
	Primary                      *bool                                                                    `json:"primary,omitempty"`
	PrivateIPAddressVersion      *VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`
	PublicIPAddressConfiguration *VirtualMachineScaleSetPublicIPAddressConfiguration                      `json:"publicIPAddressConfiguration,omitempty"`
	Reference                    *genruntime.ResourceReference                                            `armReference:"Id" json:"reference,omitempty"`
	Subnet                       *ApiEntityReference                                                      `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIPConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetIPConfigurationARM{}

	// Set property ‘Id’:
	if configuration.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*configuration.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if configuration.ApplicationGatewayBackendAddressPools != nil ||
		configuration.ApplicationSecurityGroups != nil ||
		configuration.LoadBalancerBackendAddressPools != nil ||
		configuration.LoadBalancerInboundNatPools != nil ||
		configuration.Primary != nil ||
		configuration.PrivateIPAddressVersion != nil ||
		configuration.PublicIPAddressConfiguration != nil ||
		configuration.Subnet != nil {
		result.Properties = &VirtualMachineScaleSetIPConfigurationPropertiesARM{}
	}
	for _, item := range configuration.ApplicationGatewayBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayBackendAddressPools = append(result.Properties.ApplicationGatewayBackendAddressPools, *itemARM.(*SubResourceARM))
	}
	for _, item := range configuration.ApplicationSecurityGroups {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationSecurityGroups = append(result.Properties.ApplicationSecurityGroups, *itemARM.(*SubResourceARM))
	}
	for _, item := range configuration.LoadBalancerBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddressPools = append(result.Properties.LoadBalancerBackendAddressPools, *itemARM.(*SubResourceARM))
	}
	for _, item := range configuration.LoadBalancerInboundNatPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerInboundNatPools = append(result.Properties.LoadBalancerInboundNatPools, *itemARM.(*SubResourceARM))
	}
	if configuration.Primary != nil {
		primary := *configuration.Primary
		result.Properties.Primary = &primary
	}
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *configuration.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if configuration.PublicIPAddressConfiguration != nil {
		publicIPAddressConfigurationARM, err := (*configuration.PublicIPAddressConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddressConfiguration := *publicIPAddressConfigurationARM.(*VirtualMachineScaleSetPublicIPAddressConfigurationARM)
		result.Properties.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	}
	if configuration.Subnet != nil {
		subnetARM, err := (*configuration.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnetARM.(*ApiEntityReferenceARM)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetIPConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIPConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIPConfigurationARM)
	if !ok {
<<<<<<< HEAD
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIPConfigurationARM, got %T", armInput)
=======
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurationsARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configurations.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configurations.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableFpga’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configurations.EnableFpga = &enableFpga
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configurations.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		configurations.Id = &id
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configurations.IpConfigurations = append(configurations.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configurations.Name = &name
	}

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configurations.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configurations.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
func (configurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations(source *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings() to populate field DnsSettings")
		}
		configurations.DnsSettings = &dnsSetting
	} else {
		configurations.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configurations.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configurations.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configurations.EnableFpga = &enableFpga
	} else {
		configurations.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configurations.EnableIPForwarding = &enableIPForwarding
	} else {
		configurations.EnableIPForwarding = nil
	}

	// Id
	configurations.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
			err := ipConfiguration.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configurations.IpConfigurations = ipConfigurationList
	} else {
		configurations.IpConfigurations = nil
	}

	// Name
	configurations.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource
		err := networkSecurityGroup.AssignPropertiesFromSubResource(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field NetworkSecurityGroup")
		}
		configurations.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configurations.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configurations.Primary = &primary
	} else {
		configurations.Primary = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
func (configurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations(destination *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configurations.DnsSettings != nil {
		var dnsSetting alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := configurations.DnsSettings.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configurations.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configurations.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configurations.EnableFpga != nil {
		enableFpga := *configurations.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configurations.EnableIPForwarding != nil {
		enableIPForwarding := *configurations.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configurations.Id)

	// IpConfigurations
	if configurations.IpConfigurations != nil {
		ipConfigurationList := make([]alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations, len(configurations.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configurations.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
			err := ipConfigurationItem.AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configurations.Name)

	// NetworkSecurityGroup
	if configurations.NetworkSecurityGroup != nil {
		var networkSecurityGroup alpha20201201s.SubResource
		err := configurations.NetworkSecurityGroup.AssignPropertiesToSubResource(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configurations.Primary != nil {
		primary := *configurations.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetDataDiskCaching. Use v1beta20201201.VirtualMachineScaleSetDataDiskCaching
// instead
// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type VirtualMachineScaleSetDataDiskCaching string

const (
	VirtualMachineScaleSetDataDiskCaching_None      = VirtualMachineScaleSetDataDiskCaching("None")
	VirtualMachineScaleSetDataDiskCaching_ReadOnly  = VirtualMachineScaleSetDataDiskCaching("ReadOnly")
	VirtualMachineScaleSetDataDiskCaching_ReadWrite = VirtualMachineScaleSetDataDiskCaching("ReadWrite")
)

// Deprecated version of VirtualMachineScaleSetDataDiskCreateOption. Use
// v1beta20201201.VirtualMachineScaleSetDataDiskCreateOption instead
// +kubebuilder:validation:Enum={"Attach","Empty","FromImage"}
type VirtualMachineScaleSetDataDiskCreateOption string

const (
	VirtualMachineScaleSetDataDiskCreateOption_Attach    = VirtualMachineScaleSetDataDiskCreateOption("Attach")
	VirtualMachineScaleSetDataDiskCreateOption_Empty     = VirtualMachineScaleSetDataDiskCreateOption("Empty")
	VirtualMachineScaleSetDataDiskCreateOption_FromImage = VirtualMachineScaleSetDataDiskCreateOption("FromImage")
)

// Deprecated version of VirtualMachineScaleSetIPConfiguration_STATUS. Use v1beta20201201.VirtualMachineScaleSetIPConfiguration_STATUS instead
type VirtualMachineScaleSetIPConfiguration_STATUS struct {
	ApplicationGatewayBackendAddressPools []SubResource_STATUS                                                          `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []SubResource_STATUS                                                          `json:"applicationSecurityGroups,omitempty"`
	Id                                    *string                                                                       `json:"id,omitempty"`
	LoadBalancerBackendAddressPools       []SubResource_STATUS                                                          `json:"loadBalancerBackendAddressPools,omitempty"`
	LoadBalancerInboundNatPools           []SubResource_STATUS                                                          `json:"loadBalancerInboundNatPools,omitempty"`
	Name                                  *string                                                                       `json:"name,omitempty"`
	Primary                               *bool                                                                         `json:"primary,omitempty"`
	PrivateIPAddressVersion               *VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`
	PublicIPAddressConfiguration          *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS                    `json:"publicIPAddressConfiguration,omitempty"`
	Subnet                                *ApiEntityReference_STATUS                                                    `json:"subnet,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIPConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIPConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIPConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIPConfiguration_STATUSARM, got %T", armInput)
>>>>>>> main
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
<<<<<<< HEAD
			var item1 SubResource
=======
			var item1 SubResource_STATUS
>>>>>>> main
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationGatewayBackendAddressPools = append(configuration.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
<<<<<<< HEAD
			var item1 SubResource
=======
			var item1 SubResource_STATUS
>>>>>>> main
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationSecurityGroups = append(configuration.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
<<<<<<< HEAD
			var item1 SubResource
=======
			var item1 SubResource_STATUS
>>>>>>> main
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerBackendAddressPools = append(configuration.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
<<<<<<< HEAD
			var item1 SubResource
=======
			var item1 SubResource_STATUS
>>>>>>> main
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerInboundNatPools = append(configuration.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PublicIPAddressConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
<<<<<<< HEAD
			var publicIPAddressConfiguration1 VirtualMachineScaleSetPublicIPAddressConfiguration
=======
			var publicIPAddressConfiguration1 VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
>>>>>>> main
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// no assignment for property ‘Reference’

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
<<<<<<< HEAD
			var subnet1 ApiEntityReference
=======
			var subnet1 ApiEntityReference_STATUS
>>>>>>> main
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetIPConfiguration populates our VirtualMachineScaleSetIPConfiguration from the provided source VirtualMachineScaleSetIPConfiguration
func (configuration *VirtualMachineScaleSetIPConfiguration) AssignPropertiesFromVirtualMachineScaleSetIPConfiguration(source *alpha20201201s.VirtualMachineScaleSetIPConfiguration) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromSubResource(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field ApplicationGatewayBackendAddressPools")
=======
// AssignPropertiesFromVirtualMachineScaleSetIPConfigurationSTATUS populates our VirtualMachineScaleSetIPConfiguration_STATUS from the provided source VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) AssignPropertiesFromVirtualMachineScaleSetIPConfigurationSTATUS(source *alpha20201201s.VirtualMachineScaleSetIPConfiguration_STATUS) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource_STATUS, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource_STATUS
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromSubResourceSTATUS(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field ApplicationGatewayBackendAddressPools")
>>>>>>> main
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
<<<<<<< HEAD
		applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource
			err := applicationSecurityGroup.AssignPropertiesFromSubResource(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field ApplicationSecurityGroups")
=======
		applicationSecurityGroupList := make([]SubResource_STATUS, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource_STATUS
			err := applicationSecurityGroup.AssignPropertiesFromSubResourceSTATUS(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field ApplicationSecurityGroups")
>>>>>>> main
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
<<<<<<< HEAD
		loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource
			err := loadBalancerBackendAddressPool.AssignPropertiesFromSubResource(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field LoadBalancerBackendAddressPools")
=======
		loadBalancerBackendAddressPoolList := make([]SubResource_STATUS, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource_STATUS
			err := loadBalancerBackendAddressPool.AssignPropertiesFromSubResourceSTATUS(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field LoadBalancerBackendAddressPools")
>>>>>>> main
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
<<<<<<< HEAD
		loadBalancerInboundNatPoolList := make([]SubResource, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource
			err := loadBalancerInboundNatPool.AssignPropertiesFromSubResource(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field LoadBalancerInboundNatPools")
=======
		loadBalancerInboundNatPoolList := make([]SubResource_STATUS, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource_STATUS
			err := loadBalancerInboundNatPool.AssignPropertiesFromSubResourceSTATUS(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field LoadBalancerInboundNatPools")
>>>>>>> main
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
<<<<<<< HEAD
		privateIPAddressVersion := VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion(*source.PrivateIPAddressVersion)
=======
		privateIPAddressVersion := VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion(*source.PrivateIPAddressVersion)
>>>>>>> main
		configuration.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
<<<<<<< HEAD
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration
		err := publicIPAddressConfiguration.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
=======
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
		err := publicIPAddressConfiguration.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationSTATUS(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationSTATUS() to populate field PublicIPAddressConfiguration")
>>>>>>> main
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
<<<<<<< HEAD
		var subnet ApiEntityReference
		err := subnet.AssignPropertiesFromApiEntityReference(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReference() to populate field Subnet")
=======
		var subnet ApiEntityReference_STATUS
		err := subnet.AssignPropertiesFromApiEntityReferenceSTATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReferenceSTATUS() to populate field Subnet")
>>>>>>> main
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetIPConfiguration populates the provided destination VirtualMachineScaleSetIPConfiguration from our VirtualMachineScaleSetIPConfiguration
func (configuration *VirtualMachineScaleSetIPConfiguration) AssignPropertiesToVirtualMachineScaleSetIPConfiguration(destination *alpha20201201s.VirtualMachineScaleSetIPConfiguration) error {
=======
// AssignPropertiesToVirtualMachineScaleSetIPConfigurationSTATUS populates the provided destination VirtualMachineScaleSetIPConfiguration_STATUS from our VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) AssignPropertiesToVirtualMachineScaleSetIPConfigurationSTATUS(destination *alpha20201201s.VirtualMachineScaleSetIPConfiguration_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
<<<<<<< HEAD
		applicationGatewayBackendAddressPoolList := make([]alpha20201201s.SubResource, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool alpha20201201s.SubResource
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToSubResource(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field ApplicationGatewayBackendAddressPools")
=======
		applicationGatewayBackendAddressPoolList := make([]alpha20201201s.SubResource_STATUS, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool alpha20201201s.SubResource_STATUS
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToSubResourceSTATUS(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field ApplicationGatewayBackendAddressPools")
>>>>>>> main
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
<<<<<<< HEAD
		applicationSecurityGroupList := make([]alpha20201201s.SubResource, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup alpha20201201s.SubResource
			err := applicationSecurityGroupItem.AssignPropertiesToSubResource(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field ApplicationSecurityGroups")
=======
		applicationSecurityGroupList := make([]alpha20201201s.SubResource_STATUS, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup alpha20201201s.SubResource_STATUS
			err := applicationSecurityGroupItem.AssignPropertiesToSubResourceSTATUS(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field ApplicationSecurityGroups")
>>>>>>> main
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
<<<<<<< HEAD
		loadBalancerBackendAddressPoolList := make([]alpha20201201s.SubResource, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool alpha20201201s.SubResource
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToSubResource(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field LoadBalancerBackendAddressPools")
=======
		loadBalancerBackendAddressPoolList := make([]alpha20201201s.SubResource_STATUS, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool alpha20201201s.SubResource_STATUS
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToSubResourceSTATUS(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field LoadBalancerBackendAddressPools")
>>>>>>> main
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configuration.LoadBalancerInboundNatPools != nil {
<<<<<<< HEAD
		loadBalancerInboundNatPoolList := make([]alpha20201201s.SubResource, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool alpha20201201s.SubResource
			err := loadBalancerInboundNatPoolItem.AssignPropertiesToSubResource(&loadBalancerInboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field LoadBalancerInboundNatPools")
=======
		loadBalancerInboundNatPoolList := make([]alpha20201201s.SubResource_STATUS, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool alpha20201201s.SubResource_STATUS
			err := loadBalancerInboundNatPoolItem.AssignPropertiesToSubResourceSTATUS(&loadBalancerInboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field LoadBalancerInboundNatPools")
>>>>>>> main
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
<<<<<<< HEAD
		var publicIPAddressConfiguration alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration
		err := configuration.PublicIPAddressConfiguration.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet alpha20201201s.ApiEntityReference
		err := configuration.Subnet.AssignPropertiesToApiEntityReference(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReference() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetIPConfiguration_STATUS. Use v1beta20201201.VirtualMachineScaleSetIPConfiguration_STATUS instead
type VirtualMachineScaleSetIPConfiguration_STATUS struct {
	ApplicationGatewayBackendAddressPools []SubResource_STATUS                                                            `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []SubResource_STATUS                                                            `json:"applicationSecurityGroups,omitempty"`
	Id                                    *string                                                                         `json:"id,omitempty"`
	LoadBalancerBackendAddressPools       []SubResource_STATUS                                                            `json:"loadBalancerBackendAddressPools,omitempty"`
	LoadBalancerInboundNatPools           []SubResource_STATUS                                                            `json:"loadBalancerInboundNatPools,omitempty"`
	Name                                  *string                                                                         `json:"name,omitempty"`
	Primary                               *bool                                                                           `json:"primary,omitempty"`
	PrivateIPAddressVersion               *VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS `json:"privateIPAddressVersion,omitempty"`
	PublicIPAddressConfiguration          *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS                      `json:"publicIPAddressConfiguration,omitempty"`
	Subnet                                *ApiEntityReference_STATUS                                                      `json:"subnet,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIPConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIPConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIPConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIPConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationGatewayBackendAddressPools = append(configuration.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationSecurityGroups = append(configuration.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerBackendAddressPools = append(configuration.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerInboundNatPools = append(configuration.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PublicIPAddressConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 ApiEntityReference_STATUS
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_STATUS populates our VirtualMachineScaleSetIPConfiguration_STATUS from the provided source VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) AssignPropertiesFromVirtualMachineScaleSetIPConfiguration_STATUS(source *alpha20201201s.VirtualMachineScaleSetIPConfiguration_STATUS) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource_STATUS, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource_STATUS
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromSubResource_STATUS(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource_STATUS, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource_STATUS
			err := applicationSecurityGroup.AssignPropertiesFromSubResource_STATUS(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource_STATUS, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource_STATUS
			err := loadBalancerBackendAddressPool.AssignPropertiesFromSubResource_STATUS(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource_STATUS, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource_STATUS
			err := loadBalancerInboundNatPool.AssignPropertiesFromSubResource_STATUS(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS(*source.PrivateIPAddressVersion)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
		err := publicIPAddressConfiguration.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference_STATUS
		err := subnet.AssignPropertiesFromApiEntityReference_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReference_STATUS() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIPConfiguration_STATUS populates the provided destination VirtualMachineScaleSetIPConfiguration_STATUS from our VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) AssignPropertiesToVirtualMachineScaleSetIPConfiguration_STATUS(destination *alpha20201201s.VirtualMachineScaleSetIPConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]alpha20201201s.SubResource_STATUS, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool alpha20201201s.SubResource_STATUS
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToSubResource_STATUS(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]alpha20201201s.SubResource_STATUS, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup alpha20201201s.SubResource_STATUS
			err := applicationSecurityGroupItem.AssignPropertiesToSubResource_STATUS(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]alpha20201201s.SubResource_STATUS, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool alpha20201201s.SubResource_STATUS
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToSubResource_STATUS(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configuration.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]alpha20201201s.SubResource_STATUS, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool alpha20201201s.SubResource_STATUS
			err := loadBalancerInboundNatPoolItem.AssignPropertiesToSubResource_STATUS(&loadBalancerInboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
		err := configuration.PublicIPAddressConfiguration.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
=======
		var publicIPAddressConfiguration alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
		err := configuration.PublicIPAddressConfiguration.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationSTATUS(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationSTATUS() to populate field PublicIPAddressConfiguration")
>>>>>>> main
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet alpha20201201s.ApiEntityReference_STATUS
<<<<<<< HEAD
		err := configuration.Subnet.AssignPropertiesToApiEntityReference_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReference_STATUS() to populate field Subnet")
=======
		err := configuration.Subnet.AssignPropertiesToApiEntityReferenceSTATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReferenceSTATUS() to populate field Subnet")
>>>>>>> main
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetManagedDiskParameters. Use v1beta20201201.VirtualMachineScaleSetManagedDiskParameters instead
type VirtualMachineScaleSetManagedDiskParameters struct {
	DiskEncryptionSet  *SubResource        `json:"diskEncryptionSet,omitempty"`
	StorageAccountType *StorageAccountType `json:"storageAccountType,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetManagedDiskParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetManagedDiskParametersARM{}

	// Set property ‘DiskEncryptionSet’:
	if parameters.DiskEncryptionSet != nil {
		diskEncryptionSetARM, err := (*parameters.DiskEncryptionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionSet := *diskEncryptionSetARM.(*SubResourceARM)
		result.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if parameters.StorageAccountType != nil {
		storageAccountType := *parameters.StorageAccountType
		result.StorageAccountType = &storageAccountType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *VirtualMachineScaleSetManagedDiskParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetManagedDiskParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetManagedDiskParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetManagedDiskParametersARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters populates our VirtualMachineScaleSetManagedDiskParameters from the provided source VirtualMachineScaleSetManagedDiskParameters
func (parameters *VirtualMachineScaleSetManagedDiskParameters) AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters(source *alpha20201201s.VirtualMachineScaleSetManagedDiskParameters) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource
		err := diskEncryptionSet.AssignPropertiesFromSubResource(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := StorageAccountType(*source.StorageAccountType)
		parameters.StorageAccountType = &storageAccountType
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters populates the provided destination VirtualMachineScaleSetManagedDiskParameters from our VirtualMachineScaleSetManagedDiskParameters
func (parameters *VirtualMachineScaleSetManagedDiskParameters) AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters(destination *alpha20201201s.VirtualMachineScaleSetManagedDiskParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet alpha20201201s.SubResource
		err := parameters.DiskEncryptionSet.AssignPropertiesToSubResource(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetManagedDiskParameters_STATUS. Use v1beta20201201.VirtualMachineScaleSetManagedDiskParameters_STATUS instead
type VirtualMachineScaleSetManagedDiskParameters_STATUS struct {
	DiskEncryptionSet  *SubResource_STATUS        `json:"diskEncryptionSet,omitempty"`
	StorageAccountType *StorageAccountType_STATUS `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetManagedDiskParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetManagedDiskParameters_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetManagedDiskParameters_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetManagedDiskParameters_STATUSARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_STATUS
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_STATUS populates our VirtualMachineScaleSetManagedDiskParameters_STATUS from the provided source VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters_STATUS(source *alpha20201201s.VirtualMachineScaleSetManagedDiskParameters_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSTATUS populates our VirtualMachineScaleSetManagedDiskParameters_STATUS from the provided source VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersSTATUS(source *alpha20201201s.VirtualMachineScaleSetManagedDiskParameters_STATUS) error {
>>>>>>> main

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_STATUS
<<<<<<< HEAD
		err := diskEncryptionSet.AssignPropertiesFromSubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field DiskEncryptionSet")
=======
		err := diskEncryptionSet.AssignPropertiesFromSubResourceSTATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field DiskEncryptionSet")
>>>>>>> main
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := StorageAccountType_STATUS(*source.StorageAccountType)
		parameters.StorageAccountType = &storageAccountType
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_STATUS populates the provided destination VirtualMachineScaleSetManagedDiskParameters_STATUS from our VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters_STATUS(destination *alpha20201201s.VirtualMachineScaleSetManagedDiskParameters_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSTATUS populates the provided destination VirtualMachineScaleSetManagedDiskParameters_STATUS from our VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersSTATUS(destination *alpha20201201s.VirtualMachineScaleSetManagedDiskParameters_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet alpha20201201s.SubResource_STATUS
<<<<<<< HEAD
		err := parameters.DiskEncryptionSet.AssignPropertiesToSubResource_STATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field DiskEncryptionSet")
=======
		err := parameters.DiskEncryptionSet.AssignPropertiesToSubResourceSTATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field DiskEncryptionSet")
>>>>>>> main
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetNetworkConfigurationDnsSettings. Use v1beta20201201.VirtualMachineScaleSetNetworkConfigurationDnsSettings instead
type VirtualMachineScaleSetNetworkConfigurationDnsSettings struct {
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkConfigurationDnsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM{}

	// Set property ‘DnsServers’:
	for _, item := range settings.DnsServers {
		result.DnsServers = append(result.DnsServers, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM, got %T", armInput)
	}

	// Set property ‘DnsServers’:
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings(source *alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings from our VirtualMachineScaleSetNetworkConfigurationDnsSettings
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings(destination *alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS. Use v1beta20201201.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS instead
type VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS struct {
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘DnsServers’:
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(source *alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsSTATUS populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsSTATUS(source *alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {
>>>>>>> main

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS from our VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(destination *alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsSTATUS populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS from our VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsSTATUS(destination *alpha20201201s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetOSDisk_OsType. Use v1beta20201201.VirtualMachineScaleSetOSDisk_OsType instead
// +kubebuilder:validation:Enum={"Linux","Windows"}
type VirtualMachineScaleSetOSDisk_OsType string

const (
	VirtualMachineScaleSetOSDisk_OsType_Linux   = VirtualMachineScaleSetOSDisk_OsType("Linux")
	VirtualMachineScaleSetOSDisk_OsType_Windows = VirtualMachineScaleSetOSDisk_OsType("Windows")
)

<<<<<<< HEAD
// Deprecated version of VirtualMachineScaleSetOSDisk_OsType_STATUS. Use
// v1beta20201201.VirtualMachineScaleSetOSDisk_OsType_STATUS instead
type VirtualMachineScaleSetOSDisk_OsType_STATUS string

const (
	VirtualMachineScaleSetOSDisk_OsType_Linux_STATUS   = VirtualMachineScaleSetOSDisk_OsType_STATUS("Linux")
	VirtualMachineScaleSetOSDisk_OsType_Windows_STATUS = VirtualMachineScaleSetOSDisk_OsType_STATUS("Windows")
)

// Deprecated version of VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion. Use
// v1beta20201201.VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion instead
// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion string

const (
	VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_IPv4 = VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion("IPv4")
	VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_IPv6 = VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion("IPv6")
)

// Deprecated version of VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS. Use
// v1beta20201201.VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS instead
type VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS string

const (
	VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_IPv4_STATUS = VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS("IPv4")
	VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_IPv6_STATUS = VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS("IPv6")
)

// Deprecated version of VirtualMachineScaleSetPublicIPAddressConfiguration. Use v1beta20201201.VirtualMachineScaleSetPublicIPAddressConfiguration instead
type VirtualMachineScaleSetPublicIPAddressConfiguration struct {
=======
// Deprecated version of VirtualMachineScaleSetOSDiskSTATUSOsType. Use
// v1beta20201201.VirtualMachineScaleSetOSDiskSTATUSOsType instead
type VirtualMachineScaleSetOSDiskSTATUSOsType string

const (
	VirtualMachineScaleSetOSDiskSTATUSOsType_Linux   = VirtualMachineScaleSetOSDiskSTATUSOsType("Linux")
	VirtualMachineScaleSetOSDiskSTATUSOsType_Windows = VirtualMachineScaleSetOSDiskSTATUSOsType("Windows")
)

// Deprecated version of VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations. Use v1beta20201201.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations instead
type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations struct {
	ApplicationGatewayBackendAddressPools []SubResource `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []SubResource `json:"applicationSecurityGroups,omitempty"`
	Id                                    *string       `json:"id,omitempty"`
	LoadBalancerBackendAddressPools       []SubResource `json:"loadBalancerBackendAddressPools,omitempty"`
	LoadBalancerInboundNatPools           []SubResource `json:"loadBalancerInboundNatPools,omitempty"`

	// +kubebuilder:validation:Required
	Name                         *string                                                                                                                                                                          `json:"name,omitempty"`
	Primary                      *bool                                                                                                                                                                            `json:"primary,omitempty"`
	PrivateIPAddressVersion      *VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion               `json:"privateIPAddressVersion,omitempty"`
	PublicIPAddressConfiguration *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration `json:"publicIPAddressConfiguration,omitempty"`
	Subnet                       *ApiEntityReference                                                                                                                                                              `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configurations == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM{}

	// Set property ‘Id’:
	if configurations.Id != nil {
		id := *configurations.Id
		result.Id = &id
	}

	// Set property ‘Name’:
	if configurations.Name != nil {
		name := *configurations.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if configurations.ApplicationGatewayBackendAddressPools != nil ||
		configurations.ApplicationSecurityGroups != nil ||
		configurations.LoadBalancerBackendAddressPools != nil ||
		configurations.LoadBalancerInboundNatPools != nil ||
		configurations.Primary != nil ||
		configurations.PrivateIPAddressVersion != nil ||
		configurations.PublicIPAddressConfiguration != nil ||
		configurations.Subnet != nil {
		result.Properties = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM{}
	}
	for _, item := range configurations.ApplicationGatewayBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayBackendAddressPools = append(result.Properties.ApplicationGatewayBackendAddressPools, *itemARM.(*SubResourceARM))
	}
	for _, item := range configurations.ApplicationSecurityGroups {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationSecurityGroups = append(result.Properties.ApplicationSecurityGroups, *itemARM.(*SubResourceARM))
	}
	for _, item := range configurations.LoadBalancerBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddressPools = append(result.Properties.LoadBalancerBackendAddressPools, *itemARM.(*SubResourceARM))
	}
	for _, item := range configurations.LoadBalancerInboundNatPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerInboundNatPools = append(result.Properties.LoadBalancerInboundNatPools, *itemARM.(*SubResourceARM))
	}
	if configurations.Primary != nil {
		primary := *configurations.Primary
		result.Properties.Primary = &primary
	}
	if configurations.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *configurations.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if configurations.PublicIPAddressConfiguration != nil {
		publicIPAddressConfigurationARM, err := (*configurations.PublicIPAddressConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddressConfiguration := *publicIPAddressConfigurationARM.(*VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM)
		result.Properties.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	}
	if configurations.Subnet != nil {
		subnetARM, err := (*configurations.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnetARM.(*ApiEntityReferenceARM)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configurations.ApplicationGatewayBackendAddressPools = append(configurations.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configurations.ApplicationSecurityGroups = append(configurations.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		configurations.Id = &id
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configurations.LoadBalancerBackendAddressPools = append(configurations.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configurations.LoadBalancerInboundNatPools = append(configurations.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configurations.Name = &name
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configurations.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			configurations.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PublicIPAddressConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configurations.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 ApiEntityReference
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configurations.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
func (configurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(source *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromSubResource(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configurations.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configurations.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource
			err := applicationSecurityGroup.AssignPropertiesFromSubResource(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configurations.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configurations.ApplicationSecurityGroups = nil
	}

	// Id
	configurations.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource
			err := loadBalancerBackendAddressPool.AssignPropertiesFromSubResource(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configurations.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configurations.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource
			err := loadBalancerInboundNatPool.AssignPropertiesFromSubResource(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configurations.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configurations.LoadBalancerInboundNatPools = nil
	}

	// Name
	configurations.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configurations.Primary = &primary
	} else {
		configurations.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion(*source.PrivateIPAddressVersion)
		configurations.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configurations.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
		err := publicIPAddressConfiguration.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		configurations.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configurations.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference
		err := subnet.AssignPropertiesFromApiEntityReference(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiEntityReference() to populate field Subnet")
		}
		configurations.Subnet = &subnet
	} else {
		configurations.Subnet = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
func (configurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(destination *alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configurations.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]alpha20201201s.SubResource, len(configurations.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configurations.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool alpha20201201s.SubResource
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToSubResource(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configurations.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]alpha20201201s.SubResource, len(configurations.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configurations.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup alpha20201201s.SubResource
			err := applicationSecurityGroupItem.AssignPropertiesToSubResource(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configurations.Id)

	// LoadBalancerBackendAddressPools
	if configurations.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]alpha20201201s.SubResource, len(configurations.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configurations.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool alpha20201201s.SubResource
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToSubResource(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configurations.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]alpha20201201s.SubResource, len(configurations.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configurations.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool alpha20201201s.SubResource
			err := loadBalancerInboundNatPoolItem.AssignPropertiesToSubResource(&loadBalancerInboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configurations.Name)

	// Primary
	if configurations.Primary != nil {
		primary := *configurations.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configurations.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configurations.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configurations.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration alpha20201201s.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
		err := configurations.PublicIPAddressConfiguration.AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configurations.Subnet != nil {
		var subnet alpha20201201s.ApiEntityReference
		err := configurations.Subnet.AssignPropertiesToApiEntityReference(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiEntityReference() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion. Use
// v1beta20201201.VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion instead
type VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion string

const (
	VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion_IPv4 = VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion("IPv4")
	VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion_IPv6 = VirtualMachineScaleSetIPConfigurationPropertiesSTATUSPrivateIPAddressVersion("IPv6")
)

// Deprecated version of VirtualMachineScaleSetManagedDiskParametersStorageAccountType. Use
// v1beta20201201.VirtualMachineScaleSetManagedDiskParametersStorageAccountType instead
// +kubebuilder:validation:Enum={"Premium_LRS","Premium_ZRS","Standard_LRS","StandardSSD_LRS","StandardSSD_ZRS","UltraSSD_LRS"}
type VirtualMachineScaleSetManagedDiskParametersStorageAccountType string

const (
	VirtualMachineScaleSetManagedDiskParametersStorageAccountType_PremiumLRS     = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("Premium_LRS")
	VirtualMachineScaleSetManagedDiskParametersStorageAccountType_PremiumZRS     = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("Premium_ZRS")
	VirtualMachineScaleSetManagedDiskParametersStorageAccountType_StandardLRS    = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("Standard_LRS")
	VirtualMachineScaleSetManagedDiskParametersStorageAccountType_StandardSSDLRS = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("StandardSSD_LRS")
	VirtualMachineScaleSetManagedDiskParametersStorageAccountType_StandardSSDZRS = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("StandardSSD_ZRS")
	VirtualMachineScaleSetManagedDiskParametersStorageAccountType_UltraSSDLRS    = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("UltraSSD_LRS")
)

// Deprecated version of VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS. Use v1beta20201201.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS instead
type VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS struct {
	DnsSettings            *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS                     `json:"dnsSettings,omitempty"`
	IdleTimeoutInMinutes   *int                                                                                      `json:"idleTimeoutInMinutes,omitempty"`
	IpTags                 []VirtualMachineScaleSetIpTag_STATUS                                                      `json:"ipTags,omitempty"`
	Name                   *string                                                                                   `json:"name,omitempty"`
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion `json:"publicIPAddressVersion,omitempty"`
	PublicIPPrefix         *SubResource_STATUS                                                                       `json:"publicIPPrefix,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_STATUS
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationSTATUS populates our VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationSTATUS(source *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSTATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSTATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag_STATUS, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag_STATUS
			err := ipTag.AssignPropertiesFromVirtualMachineScaleSetIpTagSTATUS(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIpTagSTATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion(*source.PublicIPAddressVersion)
		configuration.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_STATUS
		err := publicIPPrefix.AssignPropertiesFromSubResourceSTATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationSTATUS populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS from our VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationSTATUS(destination *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSTATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSTATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]alpha20201201s.VirtualMachineScaleSetIpTag_STATUS, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag alpha20201201s.VirtualMachineScaleSetIpTag_STATUS
			err := ipTagItem.AssignPropertiesToVirtualMachineScaleSetIpTagSTATUS(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIpTagSTATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix alpha20201201s.SubResource_STATUS
		err := configuration.PublicIPPrefix.AssignPropertiesToSubResourceSTATUS(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration. Use v1beta20201201.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration instead
type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration struct {
>>>>>>> main
	DnsSettings          *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings `json:"dnsSettings,omitempty"`
	IdleTimeoutInMinutes *int                                                           `json:"idleTimeoutInMinutes,omitempty"`
	IpTags               []VirtualMachineScaleSetIpTag                                  `json:"ipTags,omitempty"`

	// +kubebuilder:validation:Required
	Name                   *string                                                                              `json:"name,omitempty"`
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion `json:"publicIPAddressVersion,omitempty"`
	PublicIPPrefix         *SubResource                                                                         `json:"publicIPPrefix,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetPublicIPAddressConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetPublicIPAddressConfigurationARM{}

	// Set property ‘Name’:
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if configuration.DnsSettings != nil ||
		configuration.IdleTimeoutInMinutes != nil ||
		configuration.IpTags != nil ||
		configuration.PublicIPAddressVersion != nil ||
		configuration.PublicIPPrefix != nil {
		result.Properties = &VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesARM{}
	}
	if configuration.DnsSettings != nil {
		dnsSettingsARM, err := (*configuration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettingsARM.(*VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if configuration.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *configuration.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	for _, item := range configuration.IpTags {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpTags = append(result.Properties.IpTags, *itemARM.(*VirtualMachineScaleSetIpTagARM))
	}
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *configuration.PublicIPAddressVersion
		result.Properties.PublicIPAddressVersion = &publicIPAddressVersion
	}
	if configuration.PublicIPPrefix != nil {
		publicIPPrefixARM, err := (*configuration.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := *publicIPPrefixARM.(*SubResourceARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfigurationARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration populates our VirtualMachineScaleSetPublicIPAddressConfiguration from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration(source *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag
			err := ipTag.AssignPropertiesFromVirtualMachineScaleSetIpTag(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion(*source.PublicIPAddressVersion)
		configuration.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignPropertiesFromSubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration from our VirtualMachineScaleSetPublicIPAddressConfiguration
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration(destination *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]alpha20201201s.VirtualMachineScaleSetIpTag, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag alpha20201201s.VirtualMachineScaleSetIpTag
			err := ipTagItem.AssignPropertiesToVirtualMachineScaleSetIpTag(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix alpha20201201s.SubResource
		err := configuration.PublicIPPrefix.AssignPropertiesToSubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// Deprecated version of VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS. Use v1beta20201201.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS instead
type VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS struct {
	DnsSettings            *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS                       `json:"dnsSettings,omitempty"`
	IdleTimeoutInMinutes   *int                                                                                        `json:"idleTimeoutInMinutes,omitempty"`
	IpTags                 []VirtualMachineScaleSetIpTag_STATUS                                                        `json:"ipTags,omitempty"`
	Name                   *string                                                                                     `json:"name,omitempty"`
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS `json:"publicIPAddressVersion,omitempty"`
	PublicIPPrefix         *SubResource_STATUS                                                                         `json:"publicIPPrefix,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfiguration_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfiguration_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfiguration_STATUSARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_STATUS
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS populates our VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(source *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag_STATUS, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag_STATUS
			err := ipTag.AssignPropertiesFromVirtualMachineScaleSetIpTag_STATUS(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineScaleSetIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS(*source.PublicIPAddressVersion)
		configuration.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_STATUS
		err := publicIPPrefix.AssignPropertiesFromSubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS from our VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(destination *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
		err := configuration.DnsSettings.AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]alpha20201201s.VirtualMachineScaleSetIpTag_STATUS, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag alpha20201201s.VirtualMachineScaleSetIpTag_STATUS
			err := ipTagItem.AssignPropertiesToVirtualMachineScaleSetIpTag_STATUS(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineScaleSetIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix alpha20201201s.SubResource_STATUS
		err := configuration.PublicIPPrefix.AssignPropertiesToSubResource_STATUS(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}
=======
// Deprecated version of
// VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion.
// Use
// v1beta20201201.VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion
// instead
// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion string

const (
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion_IPv4 = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion("IPv4")
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion_IPv6 = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion("IPv6")
)
>>>>>>> main

// Deprecated version of VirtualMachineScaleSetIpTag. Use v1beta20201201.VirtualMachineScaleSetIpTag instead
type VirtualMachineScaleSetIpTag struct {
	IpTagType *string `json:"ipTagType,omitempty"`
	Tag       *string `json:"tag,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIpTag{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ipTag *VirtualMachineScaleSetIpTag) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ipTag == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetIpTagARM{}

	// Set property ‘IpTagType’:
	if ipTag.IpTagType != nil {
		ipTagType := *ipTag.IpTagType
		result.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if ipTag.Tag != nil {
		tag := *ipTag.Tag
		result.Tag = &tag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipTag *VirtualMachineScaleSetIpTag) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIpTagARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipTag *VirtualMachineScaleSetIpTag) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIpTagARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIpTagARM, got %T", armInput)
	}

	// Set property ‘IpTagType’:
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		ipTag.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		ipTag.Tag = &tag
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIpTag populates our VirtualMachineScaleSetIpTag from the provided source VirtualMachineScaleSetIpTag
func (ipTag *VirtualMachineScaleSetIpTag) AssignPropertiesFromVirtualMachineScaleSetIpTag(source *alpha20201201s.VirtualMachineScaleSetIpTag) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIpTag populates the provided destination VirtualMachineScaleSetIpTag from our VirtualMachineScaleSetIpTag
func (ipTag *VirtualMachineScaleSetIpTag) AssignPropertiesToVirtualMachineScaleSetIpTag(destination *alpha20201201s.VirtualMachineScaleSetIpTag) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetIpTag_STATUS. Use v1beta20201201.VirtualMachineScaleSetIpTag_STATUS instead
type VirtualMachineScaleSetIpTag_STATUS struct {
	IpTagType *string `json:"ipTagType,omitempty"`
	Tag       *string `json:"tag,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIpTag_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIpTag_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIpTag_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIpTag_STATUSARM, got %T", armInput)
	}

	// Set property ‘IpTagType’:
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		ipTag.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		ipTag.Tag = &tag
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetIpTag_STATUS populates our VirtualMachineScaleSetIpTag_STATUS from the provided source VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) AssignPropertiesFromVirtualMachineScaleSetIpTag_STATUS(source *alpha20201201s.VirtualMachineScaleSetIpTag_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetIpTagSTATUS populates our VirtualMachineScaleSetIpTag_STATUS from the provided source VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) AssignPropertiesFromVirtualMachineScaleSetIpTagSTATUS(source *alpha20201201s.VirtualMachineScaleSetIpTag_STATUS) error {
>>>>>>> main

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetIpTag_STATUS populates the provided destination VirtualMachineScaleSetIpTag_STATUS from our VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) AssignPropertiesToVirtualMachineScaleSetIpTag_STATUS(destination *alpha20201201s.VirtualMachineScaleSetIpTag_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetIpTagSTATUS populates the provided destination VirtualMachineScaleSetIpTag_STATUS from our VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) AssignPropertiesToVirtualMachineScaleSetIpTagSTATUS(destination *alpha20201201s.VirtualMachineScaleSetIpTag_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings. Use v1beta20201201.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings instead
type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings struct {
	// +kubebuilder:validation:Required
	DomainNameLabel *string `json:"domainNameLabel,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM{}

	// Set property ‘DomainNameLabel’:
	if settings.DomainNameLabel != nil {
		domainNameLabel := *settings.DomainNameLabel
		result.DomainNameLabel = &domainNameLabel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM, got %T", armInput)
	}

	// Set property ‘DomainNameLabel’:
	if typedInput.DomainNameLabel != nil {
		domainNameLabel := *typedInput.DomainNameLabel
		settings.DomainNameLabel = &domainNameLabel
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(source *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error {

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(destination *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(settings.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS. Use v1beta20201201.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS instead
type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS struct {
	DomainNameLabel *string `json:"domainNameLabel,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘DomainNameLabel’:
	if typedInput.DomainNameLabel != nil {
		domainNameLabel := *typedInput.DomainNameLabel
		settings.DomainNameLabel = &domainNameLabel
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(source *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {
=======
// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSTATUS populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSTATUS(source *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {
>>>>>>> main

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(destination *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {
=======
// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSTATUS populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsSTATUS(destination *alpha20201201s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {
>>>>>>> main
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(settings.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion. Use
// v1beta20201201.VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion instead
// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv4 = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv6 = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion("IPv6")
)

<<<<<<< HEAD
// Deprecated version of VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS. Use
// v1beta20201201.VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS instead
type VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv4_STATUS = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv6_STATUS = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS("IPv6")
=======
// Deprecated version of VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion. Use
// v1beta20201201.VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion instead
type VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion_IPv4 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion_IPv6 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesSTATUSPublicIPAddressVersion("IPv6")
>>>>>>> main
)

func init() {
	SchemeBuilder.Register(&VirtualMachineScaleSet{}, &VirtualMachineScaleSetList{})
}
