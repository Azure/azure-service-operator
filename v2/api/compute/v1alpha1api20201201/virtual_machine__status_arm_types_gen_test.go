// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_StatusARM, VirtualMachine_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_StatusARM runs a test to see if a specific instance of VirtualMachine_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_StatusARM(subject VirtualMachine_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_StatusARM instances for property testing - lazily instantiated by
//VirtualMachine_StatusARMGenerator()
var virtualMachine_statusARMGenerator gopter.Gen

// VirtualMachine_StatusARMGenerator returns a generator of VirtualMachine_StatusARM instances for property testing.
// We first initialize virtualMachine_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_StatusARMGenerator() gopter.Gen {
	if virtualMachine_statusARMGenerator != nil {
		return virtualMachine_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_StatusARM(generators)
	virtualMachine_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_StatusARM(generators)
	virtualMachine_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_StatusARM{}), generators)

	return virtualMachine_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_StatusARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentity_StatusARMGenerator())
	gens["Plan"] = gen.PtrOf(Plan_StatusARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachineProperties_StatusARMGenerator())
	gens["Resources"] = gen.SliceOf(VirtualMachineExtension_StatusARMGenerator())
}

func Test_VirtualMachineExtension_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtension_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtension_StatusARM, VirtualMachineExtension_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtension_StatusARM runs a test to see if a specific instance of VirtualMachineExtension_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtension_StatusARM(subject VirtualMachineExtension_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtension_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtension_StatusARM instances for property testing - lazily instantiated by
//VirtualMachineExtension_StatusARMGenerator()
var virtualMachineExtension_statusARMGenerator gopter.Gen

// VirtualMachineExtension_StatusARMGenerator returns a generator of VirtualMachineExtension_StatusARM instances for property testing.
// We first initialize virtualMachineExtension_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtension_StatusARMGenerator() gopter.Gen {
	if virtualMachineExtension_statusARMGenerator != nil {
		return virtualMachineExtension_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtension_StatusARM(generators)
	virtualMachineExtension_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtension_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtension_StatusARM(generators)
	virtualMachineExtension_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_StatusARM{}), generators)

	return virtualMachineExtension_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtension_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtension_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtension_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtension_StatusARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachineExtensionProperties_StatusARMGenerator())
}

func Test_VirtualMachineIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_StatusARM, VirtualMachineIdentity_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_StatusARM runs a test to see if a specific instance of VirtualMachineIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_StatusARM(subject VirtualMachineIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_StatusARM instances for property testing - lazily instantiated by
//VirtualMachineIdentity_StatusARMGenerator()
var virtualMachineIdentity_statusARMGenerator gopter.Gen

// VirtualMachineIdentity_StatusARMGenerator returns a generator of VirtualMachineIdentity_StatusARM instances for property testing.
// We first initialize virtualMachineIdentity_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineIdentity_StatusARMGenerator() gopter.Gen {
	if virtualMachineIdentity_statusARMGenerator != nil {
		return virtualMachineIdentity_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_StatusARM(generators)
	virtualMachineIdentity_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineIdentity_StatusARM(generators)
	virtualMachineIdentity_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_StatusARM{}), generators)

	return virtualMachineIdentity_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_StatusARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentity_Type_StatusNone,
		VirtualMachineIdentity_Type_StatusSystemAssigned,
		VirtualMachineIdentity_Type_StatusSystemAssignedUserAssigned,
		VirtualMachineIdentity_Type_StatusUserAssigned))
}

// AddRelatedPropertyGeneratorsForVirtualMachineIdentity_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineIdentity_StatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), VirtualMachineIdentity_UserAssignedIdentities_StatusARMGenerator())
}

func Test_VirtualMachineProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineProperties_StatusARM, VirtualMachineProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineProperties_StatusARM runs a test to see if a specific instance of VirtualMachineProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineProperties_StatusARM(subject VirtualMachineProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineProperties_StatusARM instances for property testing - lazily instantiated by
//VirtualMachineProperties_StatusARMGenerator()
var virtualMachineProperties_statusARMGenerator gopter.Gen

// VirtualMachineProperties_StatusARMGenerator returns a generator of VirtualMachineProperties_StatusARM instances for property testing.
// We first initialize virtualMachineProperties_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineProperties_StatusARMGenerator() gopter.Gen {
	if virtualMachineProperties_statusARMGenerator != nil {
		return virtualMachineProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_StatusARM(generators)
	virtualMachineProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineProperties_StatusARM(generators)
	virtualMachineProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_StatusARM{}), generators)

	return virtualMachineProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_StatusDeallocate, EvictionPolicy_StatusDelete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_StatusLow, Priority_StatusRegular, Priority_StatusSpot))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineProperties_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_StatusARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResource_StatusARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_StatusARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_StatusARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfile_StatusARMGenerator())
	gens["Host"] = gen.PtrOf(SubResource_StatusARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_StatusARMGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceView_StatusARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_StatusARMGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfile_StatusARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_StatusARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_StatusARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfile_StatusARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResource_StatusARMGenerator())
}

func Test_BillingProfile_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile_StatusARM, BillingProfile_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile_StatusARM runs a test to see if a specific instance of BillingProfile_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile_StatusARM(subject BillingProfile_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_StatusARM instances for property testing - lazily instantiated by
//BillingProfile_StatusARMGenerator()
var billingProfile_statusARMGenerator gopter.Gen

// BillingProfile_StatusARMGenerator returns a generator of BillingProfile_StatusARM instances for property testing.
func BillingProfile_StatusARMGenerator() gopter.Gen {
	if billingProfile_statusARMGenerator != nil {
		return billingProfile_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile_StatusARM(generators)
	billingProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(BillingProfile_StatusARM{}), generators)

	return billingProfile_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile_StatusARM, DiagnosticsProfile_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile_StatusARM runs a test to see if a specific instance of DiagnosticsProfile_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile_StatusARM(subject DiagnosticsProfile_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_StatusARM instances for property testing - lazily instantiated by
//DiagnosticsProfile_StatusARMGenerator()
var diagnosticsProfile_statusARMGenerator gopter.Gen

// DiagnosticsProfile_StatusARMGenerator returns a generator of DiagnosticsProfile_StatusARM instances for property testing.
func DiagnosticsProfile_StatusARMGenerator() gopter.Gen {
	if diagnosticsProfile_statusARMGenerator != nil {
		return diagnosticsProfile_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile_StatusARM(generators)
	diagnosticsProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_StatusARM{}), generators)

	return diagnosticsProfile_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnostics_StatusARMGenerator())
}

func Test_HardwareProfile_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile_StatusARM, HardwareProfile_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile_StatusARM runs a test to see if a specific instance of HardwareProfile_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile_StatusARM(subject HardwareProfile_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_StatusARM instances for property testing - lazily instantiated by
//HardwareProfile_StatusARMGenerator()
var hardwareProfile_statusARMGenerator gopter.Gen

// HardwareProfile_StatusARMGenerator returns a generator of HardwareProfile_StatusARM instances for property testing.
func HardwareProfile_StatusARMGenerator() gopter.Gen {
	if hardwareProfile_statusARMGenerator != nil {
		return hardwareProfile_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile_StatusARM(generators)
	hardwareProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_StatusARM{}), generators)

	return hardwareProfile_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfile_VmSize_StatusBasic_A0,
		HardwareProfile_VmSize_StatusBasic_A1,
		HardwareProfile_VmSize_StatusBasic_A2,
		HardwareProfile_VmSize_StatusBasic_A3,
		HardwareProfile_VmSize_StatusBasic_A4,
		HardwareProfile_VmSize_StatusStandard_A0,
		HardwareProfile_VmSize_StatusStandard_A1,
		HardwareProfile_VmSize_StatusStandard_A10,
		HardwareProfile_VmSize_StatusStandard_A11,
		HardwareProfile_VmSize_StatusStandard_A1_V2,
		HardwareProfile_VmSize_StatusStandard_A2,
		HardwareProfile_VmSize_StatusStandard_A2M_V2,
		HardwareProfile_VmSize_StatusStandard_A2_V2,
		HardwareProfile_VmSize_StatusStandard_A3,
		HardwareProfile_VmSize_StatusStandard_A4,
		HardwareProfile_VmSize_StatusStandard_A4M_V2,
		HardwareProfile_VmSize_StatusStandard_A4_V2,
		HardwareProfile_VmSize_StatusStandard_A5,
		HardwareProfile_VmSize_StatusStandard_A6,
		HardwareProfile_VmSize_StatusStandard_A7,
		HardwareProfile_VmSize_StatusStandard_A8,
		HardwareProfile_VmSize_StatusStandard_A8M_V2,
		HardwareProfile_VmSize_StatusStandard_A8_V2,
		HardwareProfile_VmSize_StatusStandard_A9,
		HardwareProfile_VmSize_StatusStandard_B1Ms,
		HardwareProfile_VmSize_StatusStandard_B1S,
		HardwareProfile_VmSize_StatusStandard_B2Ms,
		HardwareProfile_VmSize_StatusStandard_B2S,
		HardwareProfile_VmSize_StatusStandard_B4Ms,
		HardwareProfile_VmSize_StatusStandard_B8Ms,
		HardwareProfile_VmSize_StatusStandard_D1,
		HardwareProfile_VmSize_StatusStandard_D11,
		HardwareProfile_VmSize_StatusStandard_D11_V2,
		HardwareProfile_VmSize_StatusStandard_D12,
		HardwareProfile_VmSize_StatusStandard_D12_V2,
		HardwareProfile_VmSize_StatusStandard_D13,
		HardwareProfile_VmSize_StatusStandard_D13_V2,
		HardwareProfile_VmSize_StatusStandard_D14,
		HardwareProfile_VmSize_StatusStandard_D14_V2,
		HardwareProfile_VmSize_StatusStandard_D15_V2,
		HardwareProfile_VmSize_StatusStandard_D16S_V3,
		HardwareProfile_VmSize_StatusStandard_D16_V3,
		HardwareProfile_VmSize_StatusStandard_D1_V2,
		HardwareProfile_VmSize_StatusStandard_D2,
		HardwareProfile_VmSize_StatusStandard_D2S_V3,
		HardwareProfile_VmSize_StatusStandard_D2_V2,
		HardwareProfile_VmSize_StatusStandard_D2_V3,
		HardwareProfile_VmSize_StatusStandard_D3,
		HardwareProfile_VmSize_StatusStandard_D32S_V3,
		HardwareProfile_VmSize_StatusStandard_D32_V3,
		HardwareProfile_VmSize_StatusStandard_D3_V2,
		HardwareProfile_VmSize_StatusStandard_D4,
		HardwareProfile_VmSize_StatusStandard_D4S_V3,
		HardwareProfile_VmSize_StatusStandard_D4_V2,
		HardwareProfile_VmSize_StatusStandard_D4_V3,
		HardwareProfile_VmSize_StatusStandard_D5_V2,
		HardwareProfile_VmSize_StatusStandard_D64S_V3,
		HardwareProfile_VmSize_StatusStandard_D64_V3,
		HardwareProfile_VmSize_StatusStandard_D8S_V3,
		HardwareProfile_VmSize_StatusStandard_D8_V3,
		HardwareProfile_VmSize_StatusStandard_DS1,
		HardwareProfile_VmSize_StatusStandard_DS11,
		HardwareProfile_VmSize_StatusStandard_DS11_V2,
		HardwareProfile_VmSize_StatusStandard_DS12,
		HardwareProfile_VmSize_StatusStandard_DS12_V2,
		HardwareProfile_VmSize_StatusStandard_DS13,
		HardwareProfile_VmSize_StatusStandard_DS132_V2,
		HardwareProfile_VmSize_StatusStandard_DS134_V2,
		HardwareProfile_VmSize_StatusStandard_DS13_V2,
		HardwareProfile_VmSize_StatusStandard_DS14,
		HardwareProfile_VmSize_StatusStandard_DS144_V2,
		HardwareProfile_VmSize_StatusStandard_DS148_V2,
		HardwareProfile_VmSize_StatusStandard_DS14_V2,
		HardwareProfile_VmSize_StatusStandard_DS15_V2,
		HardwareProfile_VmSize_StatusStandard_DS1_V2,
		HardwareProfile_VmSize_StatusStandard_DS2,
		HardwareProfile_VmSize_StatusStandard_DS2_V2,
		HardwareProfile_VmSize_StatusStandard_DS3,
		HardwareProfile_VmSize_StatusStandard_DS3_V2,
		HardwareProfile_VmSize_StatusStandard_DS4,
		HardwareProfile_VmSize_StatusStandard_DS4_V2,
		HardwareProfile_VmSize_StatusStandard_DS5_V2,
		HardwareProfile_VmSize_StatusStandard_E16S_V3,
		HardwareProfile_VmSize_StatusStandard_E16_V3,
		HardwareProfile_VmSize_StatusStandard_E2S_V3,
		HardwareProfile_VmSize_StatusStandard_E2_V3,
		HardwareProfile_VmSize_StatusStandard_E3216_V3,
		HardwareProfile_VmSize_StatusStandard_E328S_V3,
		HardwareProfile_VmSize_StatusStandard_E32S_V3,
		HardwareProfile_VmSize_StatusStandard_E32_V3,
		HardwareProfile_VmSize_StatusStandard_E4S_V3,
		HardwareProfile_VmSize_StatusStandard_E4_V3,
		HardwareProfile_VmSize_StatusStandard_E6416S_V3,
		HardwareProfile_VmSize_StatusStandard_E6432S_V3,
		HardwareProfile_VmSize_StatusStandard_E64S_V3,
		HardwareProfile_VmSize_StatusStandard_E64_V3,
		HardwareProfile_VmSize_StatusStandard_E8S_V3,
		HardwareProfile_VmSize_StatusStandard_E8_V3,
		HardwareProfile_VmSize_StatusStandard_F1,
		HardwareProfile_VmSize_StatusStandard_F16,
		HardwareProfile_VmSize_StatusStandard_F16S,
		HardwareProfile_VmSize_StatusStandard_F16S_V2,
		HardwareProfile_VmSize_StatusStandard_F1S,
		HardwareProfile_VmSize_StatusStandard_F2,
		HardwareProfile_VmSize_StatusStandard_F2S,
		HardwareProfile_VmSize_StatusStandard_F2S_V2,
		HardwareProfile_VmSize_StatusStandard_F32S_V2,
		HardwareProfile_VmSize_StatusStandard_F4,
		HardwareProfile_VmSize_StatusStandard_F4S,
		HardwareProfile_VmSize_StatusStandard_F4S_V2,
		HardwareProfile_VmSize_StatusStandard_F64S_V2,
		HardwareProfile_VmSize_StatusStandard_F72S_V2,
		HardwareProfile_VmSize_StatusStandard_F8,
		HardwareProfile_VmSize_StatusStandard_F8S,
		HardwareProfile_VmSize_StatusStandard_F8S_V2,
		HardwareProfile_VmSize_StatusStandard_G1,
		HardwareProfile_VmSize_StatusStandard_G2,
		HardwareProfile_VmSize_StatusStandard_G3,
		HardwareProfile_VmSize_StatusStandard_G4,
		HardwareProfile_VmSize_StatusStandard_G5,
		HardwareProfile_VmSize_StatusStandard_GS1,
		HardwareProfile_VmSize_StatusStandard_GS2,
		HardwareProfile_VmSize_StatusStandard_GS3,
		HardwareProfile_VmSize_StatusStandard_GS4,
		HardwareProfile_VmSize_StatusStandard_GS44,
		HardwareProfile_VmSize_StatusStandard_GS48,
		HardwareProfile_VmSize_StatusStandard_GS5,
		HardwareProfile_VmSize_StatusStandard_GS516,
		HardwareProfile_VmSize_StatusStandard_GS58,
		HardwareProfile_VmSize_StatusStandard_H16,
		HardwareProfile_VmSize_StatusStandard_H16M,
		HardwareProfile_VmSize_StatusStandard_H16Mr,
		HardwareProfile_VmSize_StatusStandard_H16R,
		HardwareProfile_VmSize_StatusStandard_H8,
		HardwareProfile_VmSize_StatusStandard_H8M,
		HardwareProfile_VmSize_StatusStandard_L16S,
		HardwareProfile_VmSize_StatusStandard_L32S,
		HardwareProfile_VmSize_StatusStandard_L4S,
		HardwareProfile_VmSize_StatusStandard_L8S,
		HardwareProfile_VmSize_StatusStandard_M12832Ms,
		HardwareProfile_VmSize_StatusStandard_M12864Ms,
		HardwareProfile_VmSize_StatusStandard_M128Ms,
		HardwareProfile_VmSize_StatusStandard_M128S,
		HardwareProfile_VmSize_StatusStandard_M6416Ms,
		HardwareProfile_VmSize_StatusStandard_M6432Ms,
		HardwareProfile_VmSize_StatusStandard_M64Ms,
		HardwareProfile_VmSize_StatusStandard_M64S,
		HardwareProfile_VmSize_StatusStandard_NC12,
		HardwareProfile_VmSize_StatusStandard_NC12S_V2,
		HardwareProfile_VmSize_StatusStandard_NC12S_V3,
		HardwareProfile_VmSize_StatusStandard_NC24,
		HardwareProfile_VmSize_StatusStandard_NC24R,
		HardwareProfile_VmSize_StatusStandard_NC24Rs_V2,
		HardwareProfile_VmSize_StatusStandard_NC24Rs_V3,
		HardwareProfile_VmSize_StatusStandard_NC24S_V2,
		HardwareProfile_VmSize_StatusStandard_NC24S_V3,
		HardwareProfile_VmSize_StatusStandard_NC6,
		HardwareProfile_VmSize_StatusStandard_NC6S_V2,
		HardwareProfile_VmSize_StatusStandard_NC6S_V3,
		HardwareProfile_VmSize_StatusStandard_ND12S,
		HardwareProfile_VmSize_StatusStandard_ND24Rs,
		HardwareProfile_VmSize_StatusStandard_ND24S,
		HardwareProfile_VmSize_StatusStandard_ND6S,
		HardwareProfile_VmSize_StatusStandard_NV12,
		HardwareProfile_VmSize_StatusStandard_NV24,
		HardwareProfile_VmSize_StatusStandard_NV6))
}

func Test_NetworkProfile_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_StatusARM, NetworkProfile_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_StatusARM runs a test to see if a specific instance of NetworkProfile_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_StatusARM(subject NetworkProfile_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_StatusARM instances for property testing - lazily instantiated by
//NetworkProfile_StatusARMGenerator()
var networkProfile_statusARMGenerator gopter.Gen

// NetworkProfile_StatusARMGenerator returns a generator of NetworkProfile_StatusARM instances for property testing.
func NetworkProfile_StatusARMGenerator() gopter.Gen {
	if networkProfile_statusARMGenerator != nil {
		return networkProfile_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfile_StatusARM(generators)
	networkProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_StatusARM{}), generators)

	return networkProfile_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfile_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReference_StatusARMGenerator())
}

func Test_OSProfile_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfile_StatusARM, OSProfile_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfile_StatusARM runs a test to see if a specific instance of OSProfile_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfile_StatusARM(subject OSProfile_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_StatusARM instances for property testing - lazily instantiated by
//OSProfile_StatusARMGenerator()
var osProfile_statusARMGenerator gopter.Gen

// OSProfile_StatusARMGenerator returns a generator of OSProfile_StatusARM instances for property testing.
// We first initialize osProfile_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfile_StatusARMGenerator() gopter.Gen {
	if osProfile_statusARMGenerator != nil {
		return osProfile_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_StatusARM(generators)
	osProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_StatusARM(generators)
	AddRelatedPropertyGeneratorsForOSProfile_StatusARM(generators)
	osProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_StatusARM{}), generators)

	return osProfile_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForOSProfile_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfile_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_StatusARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_StatusARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_StatusARMGenerator())
}

func Test_SecurityProfile_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile_StatusARM, SecurityProfile_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile_StatusARM runs a test to see if a specific instance of SecurityProfile_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile_StatusARM(subject SecurityProfile_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_StatusARM instances for property testing - lazily instantiated by
//SecurityProfile_StatusARMGenerator()
var securityProfile_statusARMGenerator gopter.Gen

// SecurityProfile_StatusARMGenerator returns a generator of SecurityProfile_StatusARM instances for property testing.
// We first initialize securityProfile_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfile_StatusARMGenerator() gopter.Gen {
	if securityProfile_statusARMGenerator != nil {
		return securityProfile_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_StatusARM(generators)
	securityProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_StatusARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile_StatusARM(generators)
	securityProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_StatusARM{}), generators)

	return securityProfile_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfile_SecurityType_StatusTrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfile_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettings_StatusARMGenerator())
}

func Test_StorageProfile_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile_StatusARM, StorageProfile_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile_StatusARM runs a test to see if a specific instance of StorageProfile_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile_StatusARM(subject StorageProfile_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_StatusARM instances for property testing - lazily instantiated by
//StorageProfile_StatusARMGenerator()
var storageProfile_statusARMGenerator gopter.Gen

// StorageProfile_StatusARMGenerator returns a generator of StorageProfile_StatusARM instances for property testing.
func StorageProfile_StatusARMGenerator() gopter.Gen {
	if storageProfile_statusARMGenerator != nil {
		return storageProfile_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile_StatusARM(generators)
	storageProfile_statusARMGenerator = gen.Struct(reflect.TypeOf(StorageProfile_StatusARM{}), generators)

	return storageProfile_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile_StatusARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDisk_StatusARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_StatusARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDisk_StatusARMGenerator())
}

func Test_VirtualMachineExtensionProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionProperties_StatusARM, VirtualMachineExtensionProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionProperties_StatusARM runs a test to see if a specific instance of VirtualMachineExtensionProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionProperties_StatusARM(subject VirtualMachineExtensionProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionProperties_StatusARM instances for property testing - lazily instantiated by
//VirtualMachineExtensionProperties_StatusARMGenerator()
var virtualMachineExtensionProperties_statusARMGenerator gopter.Gen

// VirtualMachineExtensionProperties_StatusARMGenerator returns a generator of VirtualMachineExtensionProperties_StatusARM instances for property testing.
// We first initialize virtualMachineExtensionProperties_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionProperties_StatusARMGenerator() gopter.Gen {
	if virtualMachineExtensionProperties_statusARMGenerator != nil {
		return virtualMachineExtensionProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionProperties_StatusARM(generators)
	virtualMachineExtensionProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionProperties_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionProperties_StatusARM(generators)
	virtualMachineExtensionProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionProperties_StatusARM{}), generators)

	return virtualMachineExtensionProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["ForceUpdateTag"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionProperties_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["InstanceView"] = gen.PtrOf(VirtualMachineExtensionInstanceView_StatusARMGenerator())
}

func Test_VirtualMachineIdentity_UserAssignedIdentities_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_UserAssignedIdentities_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_StatusARM, VirtualMachineIdentity_UserAssignedIdentities_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_StatusARM runs a test to see if a specific instance of VirtualMachineIdentity_UserAssignedIdentities_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_StatusARM(subject VirtualMachineIdentity_UserAssignedIdentities_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_UserAssignedIdentities_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_UserAssignedIdentities_StatusARM instances for property testing - lazily
//instantiated by VirtualMachineIdentity_UserAssignedIdentities_StatusARMGenerator()
var virtualMachineIdentity_userAssignedIdentities_statusARMGenerator gopter.Gen

// VirtualMachineIdentity_UserAssignedIdentities_StatusARMGenerator returns a generator of VirtualMachineIdentity_UserAssignedIdentities_StatusARM instances for property testing.
func VirtualMachineIdentity_UserAssignedIdentities_StatusARMGenerator() gopter.Gen {
	if virtualMachineIdentity_userAssignedIdentities_statusARMGenerator != nil {
		return virtualMachineIdentity_userAssignedIdentities_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_StatusARM(generators)
	virtualMachineIdentity_userAssignedIdentities_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_UserAssignedIdentities_StatusARM{}), generators)

	return virtualMachineIdentity_userAssignedIdentities_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_StatusARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineInstanceView_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceView_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceView_StatusARM, VirtualMachineInstanceView_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceView_StatusARM runs a test to see if a specific instance of VirtualMachineInstanceView_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceView_StatusARM(subject VirtualMachineInstanceView_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceView_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceView_StatusARM instances for property testing - lazily instantiated by
//VirtualMachineInstanceView_StatusARMGenerator()
var virtualMachineInstanceView_statusARMGenerator gopter.Gen

// VirtualMachineInstanceView_StatusARMGenerator returns a generator of VirtualMachineInstanceView_StatusARM instances for property testing.
// We first initialize virtualMachineInstanceView_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceView_StatusARMGenerator() gopter.Gen {
	if virtualMachineInstanceView_statusARMGenerator != nil {
		return virtualMachineInstanceView_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_StatusARM(generators)
	virtualMachineInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_StatusARM(generators)
	virtualMachineInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_StatusARM{}), generators)

	return virtualMachineInstanceView_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(VirtualMachineInstanceView_HyperVGeneration_StatusV1, VirtualMachineInstanceView_HyperVGeneration_StatusV2))
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceView_StatusARMGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceView_StatusARMGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceView_StatusARMGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatus_StatusARMGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatus_StatusARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusARMGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceView_StatusARMGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatus_StatusARMGenerator())
}

func Test_BootDiagnosticsInstanceView_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceView_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceView_StatusARM, BootDiagnosticsInstanceView_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceView_StatusARM runs a test to see if a specific instance of BootDiagnosticsInstanceView_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceView_StatusARM(subject BootDiagnosticsInstanceView_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceView_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceView_StatusARM instances for property testing - lazily instantiated by
//BootDiagnosticsInstanceView_StatusARMGenerator()
var bootDiagnosticsInstanceView_statusARMGenerator gopter.Gen

// BootDiagnosticsInstanceView_StatusARMGenerator returns a generator of BootDiagnosticsInstanceView_StatusARM instances for property testing.
// We first initialize bootDiagnosticsInstanceView_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceView_StatusARMGenerator() gopter.Gen {
	if bootDiagnosticsInstanceView_statusARMGenerator != nil {
		return bootDiagnosticsInstanceView_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_StatusARM(generators)
	bootDiagnosticsInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_StatusARM(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_StatusARM(generators)
	bootDiagnosticsInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_StatusARM{}), generators)

	return bootDiagnosticsInstanceView_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusARMGenerator())
}

func Test_BootDiagnostics_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics_StatusARM, BootDiagnostics_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics_StatusARM runs a test to see if a specific instance of BootDiagnostics_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics_StatusARM(subject BootDiagnostics_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_StatusARM instances for property testing - lazily instantiated by
//BootDiagnostics_StatusARMGenerator()
var bootDiagnostics_statusARMGenerator gopter.Gen

// BootDiagnostics_StatusARMGenerator returns a generator of BootDiagnostics_StatusARM instances for property testing.
func BootDiagnostics_StatusARMGenerator() gopter.Gen {
	if bootDiagnostics_statusARMGenerator != nil {
		return bootDiagnostics_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics_StatusARM(generators)
	bootDiagnostics_statusARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_StatusARM{}), generators)

	return bootDiagnostics_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics_StatusARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk_StatusARM, DataDisk_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk_StatusARM runs a test to see if a specific instance of DataDisk_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk_StatusARM(subject DataDisk_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_StatusARM instances for property testing - lazily instantiated by DataDisk_StatusARMGenerator()
var dataDisk_statusARMGenerator gopter.Gen

// DataDisk_StatusARMGenerator returns a generator of DataDisk_StatusARM instances for property testing.
// We first initialize dataDisk_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDisk_StatusARMGenerator() gopter.Gen {
	if dataDisk_statusARMGenerator != nil {
		return dataDisk_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_StatusARM(generators)
	dataDisk_statusARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_StatusARM(generators)
	AddRelatedPropertyGeneratorsForDataDisk_StatusARM(generators)
	dataDisk_statusARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_StatusARM{}), generators)

	return dataDisk_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk_StatusARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_StatusNone, Caching_StatusReadOnly, Caching_StatusReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_StatusAttach, CreateOption_StatusEmpty, CreateOption_StatusFromImage)
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_StatusForceDetach))
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.Int()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk_StatusARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDisk_StatusARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_StatusARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_StatusARMGenerator())
}

func Test_DiskInstanceView_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceView_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceView_StatusARM, DiskInstanceView_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceView_StatusARM runs a test to see if a specific instance of DiskInstanceView_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceView_StatusARM(subject DiskInstanceView_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceView_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceView_StatusARM instances for property testing - lazily instantiated by
//DiskInstanceView_StatusARMGenerator()
var diskInstanceView_statusARMGenerator gopter.Gen

// DiskInstanceView_StatusARMGenerator returns a generator of DiskInstanceView_StatusARM instances for property testing.
// We first initialize diskInstanceView_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceView_StatusARMGenerator() gopter.Gen {
	if diskInstanceView_statusARMGenerator != nil {
		return diskInstanceView_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceView_StatusARM(generators)
	diskInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceView_StatusARM(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceView_StatusARM(generators)
	diskInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_StatusARM{}), generators)

	return diskInstanceView_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceView_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceView_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettings_StatusARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusARMGenerator())
}

func Test_ImageReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference_StatusARM, ImageReference_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference_StatusARM runs a test to see if a specific instance of ImageReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference_StatusARM(subject ImageReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_StatusARM instances for property testing - lazily instantiated by
//ImageReference_StatusARMGenerator()
var imageReference_statusARMGenerator gopter.Gen

// ImageReference_StatusARMGenerator returns a generator of ImageReference_StatusARM instances for property testing.
func ImageReference_StatusARMGenerator() gopter.Gen {
	if imageReference_statusARMGenerator != nil {
		return imageReference_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference_StatusARM(generators)
	imageReference_statusARMGenerator = gen.Struct(reflect.TypeOf(ImageReference_StatusARM{}), generators)

	return imageReference_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReference_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference_StatusARM(gens map[string]gopter.Gen) {
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatus_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatus_StatusARM, InstanceViewStatus_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatus_StatusARM runs a test to see if a specific instance of InstanceViewStatus_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatus_StatusARM(subject InstanceViewStatus_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_StatusARM instances for property testing - lazily instantiated by
//InstanceViewStatus_StatusARMGenerator()
var instanceViewStatus_statusARMGenerator gopter.Gen

// InstanceViewStatus_StatusARMGenerator returns a generator of InstanceViewStatus_StatusARM instances for property testing.
func InstanceViewStatus_StatusARMGenerator() gopter.Gen {
	if instanceViewStatus_statusARMGenerator != nil {
		return instanceViewStatus_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatus_StatusARM(generators)
	instanceViewStatus_statusARMGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_StatusARM{}), generators)

	return instanceViewStatus_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatus_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatus_StatusARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.OneConstOf(InstanceViewStatus_Level_StatusError, InstanceViewStatus_Level_StatusInfo, InstanceViewStatus_Level_StatusWarning))
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration_StatusARM, LinuxConfiguration_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration_StatusARM runs a test to see if a specific instance of LinuxConfiguration_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration_StatusARM(subject LinuxConfiguration_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_StatusARM instances for property testing - lazily instantiated by
//LinuxConfiguration_StatusARMGenerator()
var linuxConfiguration_statusARMGenerator gopter.Gen

// LinuxConfiguration_StatusARMGenerator returns a generator of LinuxConfiguration_StatusARM instances for property testing.
// We first initialize linuxConfiguration_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfiguration_StatusARMGenerator() gopter.Gen {
	if linuxConfiguration_statusARMGenerator != nil {
		return linuxConfiguration_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_StatusARM(generators)
	linuxConfiguration_statusARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_StatusARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration_StatusARM(generators)
	linuxConfiguration_statusARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_StatusARM{}), generators)

	return linuxConfiguration_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration_StatusARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration_StatusARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettings_StatusARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfiguration_StatusARMGenerator())
}

func Test_MaintenanceRedeployStatus_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatus_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatus_StatusARM, MaintenanceRedeployStatus_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatus_StatusARM runs a test to see if a specific instance of MaintenanceRedeployStatus_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatus_StatusARM(subject MaintenanceRedeployStatus_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatus_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatus_StatusARM instances for property testing - lazily instantiated by
//MaintenanceRedeployStatus_StatusARMGenerator()
var maintenanceRedeployStatus_statusARMGenerator gopter.Gen

// MaintenanceRedeployStatus_StatusARMGenerator returns a generator of MaintenanceRedeployStatus_StatusARM instances for property testing.
func MaintenanceRedeployStatus_StatusARMGenerator() gopter.Gen {
	if maintenanceRedeployStatus_statusARMGenerator != nil {
		return maintenanceRedeployStatus_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_StatusARM(generators)
	maintenanceRedeployStatus_statusARMGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatus_StatusARM{}), generators)

	return maintenanceRedeployStatus_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_StatusARM(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.OneConstOf(
		MaintenanceRedeployStatus_LastOperationResultCode_StatusMaintenanceAborted,
		MaintenanceRedeployStatus_LastOperationResultCode_StatusMaintenanceCompleted,
		MaintenanceRedeployStatus_LastOperationResultCode_StatusNone,
		MaintenanceRedeployStatus_LastOperationResultCode_StatusRetryLater))
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReference_StatusARM, NetworkInterfaceReference_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReference_StatusARM runs a test to see if a specific instance of NetworkInterfaceReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReference_StatusARM(subject NetworkInterfaceReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_StatusARM instances for property testing - lazily instantiated by
//NetworkInterfaceReference_StatusARMGenerator()
var networkInterfaceReference_statusARMGenerator gopter.Gen

// NetworkInterfaceReference_StatusARMGenerator returns a generator of NetworkInterfaceReference_StatusARM instances for property testing.
// We first initialize networkInterfaceReference_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceReference_StatusARMGenerator() gopter.Gen {
	if networkInterfaceReference_statusARMGenerator != nil {
		return networkInterfaceReference_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_StatusARM(generators)
	networkInterfaceReference_statusARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_StatusARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceReference_StatusARM(generators)
	networkInterfaceReference_statusARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_StatusARM{}), generators)

	return networkInterfaceReference_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReference_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReference_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceReference_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceReference_StatusARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferenceProperties_StatusARMGenerator())
}

func Test_OSDisk_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk_StatusARM, OSDisk_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk_StatusARM runs a test to see if a specific instance of OSDisk_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk_StatusARM(subject OSDisk_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_StatusARM instances for property testing - lazily instantiated by OSDisk_StatusARMGenerator()
var osDisk_statusARMGenerator gopter.Gen

// OSDisk_StatusARMGenerator returns a generator of OSDisk_StatusARM instances for property testing.
// We first initialize osDisk_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDisk_StatusARMGenerator() gopter.Gen {
	if osDisk_statusARMGenerator != nil {
		return osDisk_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_StatusARM(generators)
	osDisk_statusARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_StatusARM(generators)
	AddRelatedPropertyGeneratorsForOSDisk_StatusARM(generators)
	osDisk_statusARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_StatusARM{}), generators)

	return osDisk_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk_StatusARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_StatusNone, Caching_StatusReadOnly, Caching_StatusReadWrite))
	gens["CreateOption"] = gen.OneConstOf(CreateOption_StatusAttach, CreateOption_StatusEmpty, CreateOption_StatusFromImage)
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDisk_OsType_StatusLinux, OSDisk_OsType_StatusWindows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk_StatusARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_StatusARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettings_StatusARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_StatusARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_StatusARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_StatusARMGenerator())
}

func Test_UefiSettings_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings_StatusARM, UefiSettings_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings_StatusARM runs a test to see if a specific instance of UefiSettings_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings_StatusARM(subject UefiSettings_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_StatusARM instances for property testing - lazily instantiated by
//UefiSettings_StatusARMGenerator()
var uefiSettings_statusARMGenerator gopter.Gen

// UefiSettings_StatusARMGenerator returns a generator of UefiSettings_StatusARM instances for property testing.
func UefiSettings_StatusARMGenerator() gopter.Gen {
	if uefiSettings_statusARMGenerator != nil {
		return uefiSettings_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings_StatusARM(generators)
	uefiSettings_statusARMGenerator = gen.Struct(reflect.TypeOf(UefiSettings_StatusARM{}), generators)

	return uefiSettings_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings_StatusARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup_StatusARM, VaultSecretGroup_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup_StatusARM runs a test to see if a specific instance of VaultSecretGroup_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup_StatusARM(subject VaultSecretGroup_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_StatusARM instances for property testing - lazily instantiated by
//VaultSecretGroup_StatusARMGenerator()
var vaultSecretGroup_statusARMGenerator gopter.Gen

// VaultSecretGroup_StatusARMGenerator returns a generator of VaultSecretGroup_StatusARM instances for property testing.
func VaultSecretGroup_StatusARMGenerator() gopter.Gen {
	if vaultSecretGroup_statusARMGenerator != nil {
		return vaultSecretGroup_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup_StatusARM(generators)
	vaultSecretGroup_statusARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_StatusARM{}), generators)

	return vaultSecretGroup_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup_StatusARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_StatusARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificate_StatusARMGenerator())
}

func Test_VirtualMachineAgentInstanceView_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceView_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceView_StatusARM, VirtualMachineAgentInstanceView_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceView_StatusARM runs a test to see if a specific instance of VirtualMachineAgentInstanceView_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceView_StatusARM(subject VirtualMachineAgentInstanceView_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceView_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceView_StatusARM instances for property testing - lazily instantiated by
//VirtualMachineAgentInstanceView_StatusARMGenerator()
var virtualMachineAgentInstanceView_statusARMGenerator gopter.Gen

// VirtualMachineAgentInstanceView_StatusARMGenerator returns a generator of VirtualMachineAgentInstanceView_StatusARM instances for property testing.
// We first initialize virtualMachineAgentInstanceView_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceView_StatusARMGenerator() gopter.Gen {
	if virtualMachineAgentInstanceView_statusARMGenerator != nil {
		return virtualMachineAgentInstanceView_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_StatusARM(generators)
	virtualMachineAgentInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_StatusARM(generators)
	virtualMachineAgentInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_StatusARM{}), generators)

	return virtualMachineAgentInstanceView_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceView_StatusARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusARMGenerator())
}

func Test_VirtualMachineExtensionInstanceView_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceView_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceView_StatusARM, VirtualMachineExtensionInstanceView_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceView_StatusARM runs a test to see if a specific instance of VirtualMachineExtensionInstanceView_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceView_StatusARM(subject VirtualMachineExtensionInstanceView_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceView_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceView_StatusARM instances for property testing - lazily instantiated by
//VirtualMachineExtensionInstanceView_StatusARMGenerator()
var virtualMachineExtensionInstanceView_statusARMGenerator gopter.Gen

// VirtualMachineExtensionInstanceView_StatusARMGenerator returns a generator of VirtualMachineExtensionInstanceView_StatusARM instances for property testing.
// We first initialize virtualMachineExtensionInstanceView_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceView_StatusARMGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceView_statusARMGenerator != nil {
		return virtualMachineExtensionInstanceView_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_StatusARM(generators)
	virtualMachineExtensionInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_StatusARM(generators)
	virtualMachineExtensionInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_StatusARM{}), generators)

	return virtualMachineExtensionInstanceView_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusARMGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatus_StatusARMGenerator())
}

func Test_VirtualMachineHealthStatus_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatus_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatus_StatusARM, VirtualMachineHealthStatus_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatus_StatusARM runs a test to see if a specific instance of VirtualMachineHealthStatus_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatus_StatusARM(subject VirtualMachineHealthStatus_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatus_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatus_StatusARM instances for property testing - lazily instantiated by
//VirtualMachineHealthStatus_StatusARMGenerator()
var virtualMachineHealthStatus_statusARMGenerator gopter.Gen

// VirtualMachineHealthStatus_StatusARMGenerator returns a generator of VirtualMachineHealthStatus_StatusARM instances for property testing.
func VirtualMachineHealthStatus_StatusARMGenerator() gopter.Gen {
	if virtualMachineHealthStatus_statusARMGenerator != nil {
		return virtualMachineHealthStatus_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_StatusARM(generators)
	virtualMachineHealthStatus_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatus_StatusARM{}), generators)

	return virtualMachineHealthStatus_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_StatusARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusARMGenerator())
}

func Test_VirtualMachinePatchStatus_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatus_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatus_StatusARM, VirtualMachinePatchStatus_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatus_StatusARM runs a test to see if a specific instance of VirtualMachinePatchStatus_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatus_StatusARM(subject VirtualMachinePatchStatus_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatus_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatus_StatusARM instances for property testing - lazily instantiated by
//VirtualMachinePatchStatus_StatusARMGenerator()
var virtualMachinePatchStatus_statusARMGenerator gopter.Gen

// VirtualMachinePatchStatus_StatusARMGenerator returns a generator of VirtualMachinePatchStatus_StatusARM instances for property testing.
func VirtualMachinePatchStatus_StatusARMGenerator() gopter.Gen {
	if virtualMachinePatchStatus_statusARMGenerator != nil {
		return virtualMachinePatchStatus_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_StatusARM(generators)
	virtualMachinePatchStatus_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatus_StatusARM{}), generators)

	return virtualMachinePatchStatus_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_StatusARM(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummary_StatusARMGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatus_StatusARMGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummary_StatusARMGenerator())
}

func Test_WindowsConfiguration_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration_StatusARM, WindowsConfiguration_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration_StatusARM runs a test to see if a specific instance of WindowsConfiguration_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration_StatusARM(subject WindowsConfiguration_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_StatusARM instances for property testing - lazily instantiated by
//WindowsConfiguration_StatusARMGenerator()
var windowsConfiguration_statusARMGenerator gopter.Gen

// WindowsConfiguration_StatusARMGenerator returns a generator of WindowsConfiguration_StatusARM instances for property testing.
// We first initialize windowsConfiguration_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfiguration_StatusARMGenerator() gopter.Gen {
	if windowsConfiguration_statusARMGenerator != nil {
		return windowsConfiguration_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_StatusARM(generators)
	windowsConfiguration_statusARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_StatusARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration_StatusARM(generators)
	windowsConfiguration_statusARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_StatusARM{}), generators)

	return windowsConfiguration_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration_StatusARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration_StatusARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContent_StatusARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettings_StatusARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfiguration_StatusARMGenerator())
}

func Test_AdditionalUnattendContent_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent_StatusARM, AdditionalUnattendContent_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent_StatusARM runs a test to see if a specific instance of AdditionalUnattendContent_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent_StatusARM(subject AdditionalUnattendContent_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_StatusARM instances for property testing - lazily instantiated by
//AdditionalUnattendContent_StatusARMGenerator()
var additionalUnattendContent_statusARMGenerator gopter.Gen

// AdditionalUnattendContent_StatusARMGenerator returns a generator of AdditionalUnattendContent_StatusARM instances for property testing.
func AdditionalUnattendContent_StatusARMGenerator() gopter.Gen {
	if additionalUnattendContent_statusARMGenerator != nil {
		return additionalUnattendContent_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent_StatusARM(generators)
	additionalUnattendContent_statusARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_StatusARM{}), generators)

	return additionalUnattendContent_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent_StatusARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_ComponentName_StatusMicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_PassName_StatusOobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_SettingName_StatusAutoLogon, AdditionalUnattendContent_SettingName_StatusFirstLogonCommands))
}

func Test_AvailablePatchSummary_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummary_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummary_StatusARM, AvailablePatchSummary_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummary_StatusARM runs a test to see if a specific instance of AvailablePatchSummary_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummary_StatusARM(subject AvailablePatchSummary_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummary_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummary_StatusARM instances for property testing - lazily instantiated by
//AvailablePatchSummary_StatusARMGenerator()
var availablePatchSummary_statusARMGenerator gopter.Gen

// AvailablePatchSummary_StatusARMGenerator returns a generator of AvailablePatchSummary_StatusARM instances for property testing.
// We first initialize availablePatchSummary_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummary_StatusARMGenerator() gopter.Gen {
	if availablePatchSummary_statusARMGenerator != nil {
		return availablePatchSummary_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummary_StatusARM(generators)
	availablePatchSummary_statusARMGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummary_StatusARM(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummary_StatusARM(generators)
	availablePatchSummary_statusARMGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_StatusARM{}), generators)

	return availablePatchSummary_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummary_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummary_StatusARM(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		AvailablePatchSummary_Status_StatusCompletedWithWarnings,
		AvailablePatchSummary_Status_StatusFailed,
		AvailablePatchSummary_Status_StatusInProgress,
		AvailablePatchSummary_Status_StatusSucceeded,
		AvailablePatchSummary_Status_StatusUnknown))
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummary_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummary_StatusARM(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiError_StatusARMGenerator())
}

func Test_DiffDiskSettings_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings_StatusARM, DiffDiskSettings_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings_StatusARM runs a test to see if a specific instance of DiffDiskSettings_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings_StatusARM(subject DiffDiskSettings_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_StatusARM instances for property testing - lazily instantiated by
//DiffDiskSettings_StatusARMGenerator()
var diffDiskSettings_statusARMGenerator gopter.Gen

// DiffDiskSettings_StatusARMGenerator returns a generator of DiffDiskSettings_StatusARM instances for property testing.
func DiffDiskSettings_StatusARMGenerator() gopter.Gen {
	if diffDiskSettings_statusARMGenerator != nil {
		return diffDiskSettings_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings_StatusARM(generators)
	diffDiskSettings_statusARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_StatusARM{}), generators)

	return diffDiskSettings_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings_StatusARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_StatusLocal))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_StatusCacheDisk, DiffDiskPlacement_StatusResourceDisk))
}

func Test_DiskEncryptionSettings_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings_StatusARM, DiskEncryptionSettings_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings_StatusARM runs a test to see if a specific instance of DiskEncryptionSettings_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings_StatusARM(subject DiskEncryptionSettings_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_StatusARM instances for property testing - lazily instantiated by
//DiskEncryptionSettings_StatusARMGenerator()
var diskEncryptionSettings_statusARMGenerator gopter.Gen

// DiskEncryptionSettings_StatusARMGenerator returns a generator of DiskEncryptionSettings_StatusARM instances for property testing.
// We first initialize diskEncryptionSettings_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettings_StatusARMGenerator() gopter.Gen {
	if diskEncryptionSettings_statusARMGenerator != nil {
		return diskEncryptionSettings_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_StatusARM(generators)
	diskEncryptionSettings_statusARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_StatusARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings_StatusARM(generators)
	diskEncryptionSettings_statusARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_StatusARM{}), generators)

	return diskEncryptionSettings_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings_StatusARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings_StatusARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReference_StatusARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReference_StatusARMGenerator())
}

func Test_LastPatchInstallationSummary_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummary_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummary_StatusARM, LastPatchInstallationSummary_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummary_StatusARM runs a test to see if a specific instance of LastPatchInstallationSummary_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummary_StatusARM(subject LastPatchInstallationSummary_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummary_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummary_StatusARM instances for property testing - lazily instantiated by
//LastPatchInstallationSummary_StatusARMGenerator()
var lastPatchInstallationSummary_statusARMGenerator gopter.Gen

// LastPatchInstallationSummary_StatusARMGenerator returns a generator of LastPatchInstallationSummary_StatusARM instances for property testing.
// We first initialize lastPatchInstallationSummary_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummary_StatusARMGenerator() gopter.Gen {
	if lastPatchInstallationSummary_statusARMGenerator != nil {
		return lastPatchInstallationSummary_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_StatusARM(generators)
	lastPatchInstallationSummary_statusARMGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_StatusARM(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_StatusARM(generators)
	lastPatchInstallationSummary_statusARMGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_StatusARM{}), generators)

	return lastPatchInstallationSummary_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_StatusARM(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		LastPatchInstallationSummary_Status_StatusCompletedWithWarnings,
		LastPatchInstallationSummary_Status_StatusFailed,
		LastPatchInstallationSummary_Status_StatusInProgress,
		LastPatchInstallationSummary_Status_StatusSucceeded,
		LastPatchInstallationSummary_Status_StatusUnknown))
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_StatusARM(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiError_StatusARMGenerator())
}

func Test_LinuxPatchSettings_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings_StatusARM, LinuxPatchSettings_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings_StatusARM runs a test to see if a specific instance of LinuxPatchSettings_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings_StatusARM(subject LinuxPatchSettings_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_StatusARM instances for property testing - lazily instantiated by
//LinuxPatchSettings_StatusARMGenerator()
var linuxPatchSettings_statusARMGenerator gopter.Gen

// LinuxPatchSettings_StatusARMGenerator returns a generator of LinuxPatchSettings_StatusARM instances for property testing.
func LinuxPatchSettings_StatusARMGenerator() gopter.Gen {
	if linuxPatchSettings_statusARMGenerator != nil {
		return linuxPatchSettings_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings_StatusARM(generators)
	linuxPatchSettings_statusARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_StatusARM{}), generators)

	return linuxPatchSettings_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings_StatusARM(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_PatchMode_StatusAutomaticByPlatform, LinuxPatchSettings_PatchMode_StatusImageDefault))
}

func Test_ManagedDiskParameters_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters_StatusARM, ManagedDiskParameters_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters_StatusARM runs a test to see if a specific instance of ManagedDiskParameters_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters_StatusARM(subject ManagedDiskParameters_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_StatusARM instances for property testing - lazily instantiated by
//ManagedDiskParameters_StatusARMGenerator()
var managedDiskParameters_statusARMGenerator gopter.Gen

// ManagedDiskParameters_StatusARMGenerator returns a generator of ManagedDiskParameters_StatusARM instances for property testing.
// We first initialize managedDiskParameters_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParameters_StatusARMGenerator() gopter.Gen {
	if managedDiskParameters_statusARMGenerator != nil {
		return managedDiskParameters_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_StatusARM(generators)
	managedDiskParameters_statusARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_StatusARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters_StatusARM(generators)
	managedDiskParameters_statusARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_StatusARM{}), generators)

	return managedDiskParameters_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_StatusPremium_LRS,
		StorageAccountType_StatusPremium_ZRS,
		StorageAccountType_StatusStandardSSD_LRS,
		StorageAccountType_StatusStandardSSD_ZRS,
		StorageAccountType_StatusStandard_LRS,
		StorageAccountType_StatusUltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters_StatusARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_StatusARMGenerator())
}

func Test_NetworkInterfaceReferenceProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferenceProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceProperties_StatusARM, NetworkInterfaceReferenceProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceProperties_StatusARM runs a test to see if a specific instance of NetworkInterfaceReferenceProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceProperties_StatusARM(subject NetworkInterfaceReferenceProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferenceProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferenceProperties_StatusARM instances for property testing - lazily instantiated by
//NetworkInterfaceReferenceProperties_StatusARMGenerator()
var networkInterfaceReferenceProperties_statusARMGenerator gopter.Gen

// NetworkInterfaceReferenceProperties_StatusARMGenerator returns a generator of NetworkInterfaceReferenceProperties_StatusARM instances for property testing.
func NetworkInterfaceReferenceProperties_StatusARMGenerator() gopter.Gen {
	if networkInterfaceReferenceProperties_statusARMGenerator != nil {
		return networkInterfaceReferenceProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_StatusARM(generators)
	networkInterfaceReferenceProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceProperties_StatusARM{}), generators)

	return networkInterfaceReferenceProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettings_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings_StatusARM, PatchSettings_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings_StatusARM runs a test to see if a specific instance of PatchSettings_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings_StatusARM(subject PatchSettings_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_StatusARM instances for property testing - lazily instantiated by
//PatchSettings_StatusARMGenerator()
var patchSettings_statusARMGenerator gopter.Gen

// PatchSettings_StatusARMGenerator returns a generator of PatchSettings_StatusARM instances for property testing.
func PatchSettings_StatusARMGenerator() gopter.Gen {
	if patchSettings_statusARMGenerator != nil {
		return patchSettings_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings_StatusARM(generators)
	patchSettings_statusARMGenerator = gen.Struct(reflect.TypeOf(PatchSettings_StatusARM{}), generators)

	return patchSettings_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings_StatusARM(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_PatchMode_StatusAutomaticByOS, PatchSettings_PatchMode_StatusAutomaticByPlatform, PatchSettings_PatchMode_StatusManual))
}

func Test_SshConfiguration_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration_StatusARM, SshConfiguration_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration_StatusARM runs a test to see if a specific instance of SshConfiguration_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration_StatusARM(subject SshConfiguration_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_StatusARM instances for property testing - lazily instantiated by
//SshConfiguration_StatusARMGenerator()
var sshConfiguration_statusARMGenerator gopter.Gen

// SshConfiguration_StatusARMGenerator returns a generator of SshConfiguration_StatusARM instances for property testing.
func SshConfiguration_StatusARMGenerator() gopter.Gen {
	if sshConfiguration_statusARMGenerator != nil {
		return sshConfiguration_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration_StatusARM(generators)
	sshConfiguration_statusARMGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_StatusARM{}), generators)

	return sshConfiguration_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration_StatusARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKey_StatusARMGenerator())
}

func Test_VaultCertificate_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate_StatusARM, VaultCertificate_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate_StatusARM runs a test to see if a specific instance of VaultCertificate_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate_StatusARM(subject VaultCertificate_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_StatusARM instances for property testing - lazily instantiated by
//VaultCertificate_StatusARMGenerator()
var vaultCertificate_statusARMGenerator gopter.Gen

// VaultCertificate_StatusARMGenerator returns a generator of VaultCertificate_StatusARM instances for property testing.
func VaultCertificate_StatusARMGenerator() gopter.Gen {
	if vaultCertificate_statusARMGenerator != nil {
		return vaultCertificate_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate_StatusARM(generators)
	vaultCertificate_statusARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_StatusARM{}), generators)

	return vaultCertificate_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate_StatusARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk_StatusARM, VirtualHardDisk_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk_StatusARM runs a test to see if a specific instance of VirtualHardDisk_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk_StatusARM(subject VirtualHardDisk_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_StatusARM instances for property testing - lazily instantiated by
//VirtualHardDisk_StatusARMGenerator()
var virtualHardDisk_statusARMGenerator gopter.Gen

// VirtualHardDisk_StatusARMGenerator returns a generator of VirtualHardDisk_StatusARM instances for property testing.
func VirtualHardDisk_StatusARMGenerator() gopter.Gen {
	if virtualHardDisk_statusARMGenerator != nil {
		return virtualHardDisk_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk_StatusARM(generators)
	virtualHardDisk_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_StatusARM{}), generators)

	return virtualHardDisk_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk_StatusARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceView_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceView_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_StatusARM, VirtualMachineExtensionHandlerInstanceView_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_StatusARM runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceView_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_StatusARM(subject VirtualMachineExtensionHandlerInstanceView_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceView_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceView_StatusARM instances for property testing - lazily
//instantiated by VirtualMachineExtensionHandlerInstanceView_StatusARMGenerator()
var virtualMachineExtensionHandlerInstanceView_statusARMGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceView_StatusARMGenerator returns a generator of VirtualMachineExtensionHandlerInstanceView_StatusARM instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceView_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceView_StatusARMGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceView_statusARMGenerator != nil {
		return virtualMachineExtensionHandlerInstanceView_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_StatusARM(generators)
	virtualMachineExtensionHandlerInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_StatusARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_StatusARM(generators)
	virtualMachineExtensionHandlerInstanceView_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_StatusARM{}), generators)

	return virtualMachineExtensionHandlerInstanceView_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_StatusARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusARMGenerator())
}

func Test_WinRMConfiguration_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration_StatusARM, WinRMConfiguration_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration_StatusARM runs a test to see if a specific instance of WinRMConfiguration_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration_StatusARM(subject WinRMConfiguration_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_StatusARM instances for property testing - lazily instantiated by
//WinRMConfiguration_StatusARMGenerator()
var winRMConfiguration_statusARMGenerator gopter.Gen

// WinRMConfiguration_StatusARMGenerator returns a generator of WinRMConfiguration_StatusARM instances for property testing.
func WinRMConfiguration_StatusARMGenerator() gopter.Gen {
	if winRMConfiguration_statusARMGenerator != nil {
		return winRMConfiguration_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration_StatusARM(generators)
	winRMConfiguration_statusARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_StatusARM{}), generators)

	return winRMConfiguration_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration_StatusARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListener_StatusARMGenerator())
}

func Test_ApiError_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiError_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiError_StatusARM, ApiError_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiError_StatusARM runs a test to see if a specific instance of ApiError_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiError_StatusARM(subject ApiError_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiError_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiError_StatusARM instances for property testing - lazily instantiated by ApiError_StatusARMGenerator()
var apiError_statusARMGenerator gopter.Gen

// ApiError_StatusARMGenerator returns a generator of ApiError_StatusARM instances for property testing.
// We first initialize apiError_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiError_StatusARMGenerator() gopter.Gen {
	if apiError_statusARMGenerator != nil {
		return apiError_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiError_StatusARM(generators)
	apiError_statusARMGenerator = gen.Struct(reflect.TypeOf(ApiError_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiError_StatusARM(generators)
	AddRelatedPropertyGeneratorsForApiError_StatusARM(generators)
	apiError_statusARMGenerator = gen.Struct(reflect.TypeOf(ApiError_StatusARM{}), generators)

	return apiError_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForApiError_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiError_StatusARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiError_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiError_StatusARM(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBase_StatusARMGenerator())
	gens["Innererror"] = gen.PtrOf(InnerError_StatusARMGenerator())
}

func Test_KeyVaultKeyReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference_StatusARM, KeyVaultKeyReference_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference_StatusARM runs a test to see if a specific instance of KeyVaultKeyReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference_StatusARM(subject KeyVaultKeyReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_StatusARM instances for property testing - lazily instantiated by
//KeyVaultKeyReference_StatusARMGenerator()
var keyVaultKeyReference_statusARMGenerator gopter.Gen

// KeyVaultKeyReference_StatusARMGenerator returns a generator of KeyVaultKeyReference_StatusARM instances for property testing.
// We first initialize keyVaultKeyReference_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReference_StatusARMGenerator() gopter.Gen {
	if keyVaultKeyReference_statusARMGenerator != nil {
		return keyVaultKeyReference_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_StatusARM(generators)
	keyVaultKeyReference_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_StatusARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference_StatusARM(generators)
	keyVaultKeyReference_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_StatusARM{}), generators)

	return keyVaultKeyReference_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference_StatusARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference_StatusARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResource_StatusARMGenerator()
}

func Test_KeyVaultSecretReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference_StatusARM, KeyVaultSecretReference_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference_StatusARM runs a test to see if a specific instance of KeyVaultSecretReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference_StatusARM(subject KeyVaultSecretReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_StatusARM instances for property testing - lazily instantiated by
//KeyVaultSecretReference_StatusARMGenerator()
var keyVaultSecretReference_statusARMGenerator gopter.Gen

// KeyVaultSecretReference_StatusARMGenerator returns a generator of KeyVaultSecretReference_StatusARM instances for property testing.
// We first initialize keyVaultSecretReference_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReference_StatusARMGenerator() gopter.Gen {
	if keyVaultSecretReference_statusARMGenerator != nil {
		return keyVaultSecretReference_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_StatusARM(generators)
	keyVaultSecretReference_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_StatusARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference_StatusARM(generators)
	keyVaultSecretReference_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_StatusARM{}), generators)

	return keyVaultSecretReference_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference_StatusARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference_StatusARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SubResource_StatusARMGenerator()
}

func Test_SshPublicKey_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKey_StatusARM, SshPublicKey_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKey_StatusARM runs a test to see if a specific instance of SshPublicKey_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKey_StatusARM(subject SshPublicKey_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_StatusARM instances for property testing - lazily instantiated by
//SshPublicKey_StatusARMGenerator()
var sshPublicKey_statusARMGenerator gopter.Gen

// SshPublicKey_StatusARMGenerator returns a generator of SshPublicKey_StatusARM instances for property testing.
func SshPublicKey_StatusARMGenerator() gopter.Gen {
	if sshPublicKey_statusARMGenerator != nil {
		return sshPublicKey_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKey_StatusARM(generators)
	sshPublicKey_statusARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_StatusARM{}), generators)

	return sshPublicKey_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKey_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKey_StatusARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener_StatusARM, WinRMListener_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener_StatusARM runs a test to see if a specific instance of WinRMListener_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener_StatusARM(subject WinRMListener_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_StatusARM instances for property testing - lazily instantiated by
//WinRMListener_StatusARMGenerator()
var winRMListener_statusARMGenerator gopter.Gen

// WinRMListener_StatusARMGenerator returns a generator of WinRMListener_StatusARM instances for property testing.
func WinRMListener_StatusARMGenerator() gopter.Gen {
	if winRMListener_statusARMGenerator != nil {
		return winRMListener_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener_StatusARM(generators)
	winRMListener_statusARMGenerator = gen.Struct(reflect.TypeOf(WinRMListener_StatusARM{}), generators)

	return winRMListener_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener_StatusARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListener_Protocol_StatusHttp, WinRMListener_Protocol_StatusHttps))
}

func Test_ApiErrorBase_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBase_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBase_StatusARM, ApiErrorBase_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBase_StatusARM runs a test to see if a specific instance of ApiErrorBase_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBase_StatusARM(subject ApiErrorBase_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBase_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBase_StatusARM instances for property testing - lazily instantiated by
//ApiErrorBase_StatusARMGenerator()
var apiErrorBase_statusARMGenerator gopter.Gen

// ApiErrorBase_StatusARMGenerator returns a generator of ApiErrorBase_StatusARM instances for property testing.
func ApiErrorBase_StatusARMGenerator() gopter.Gen {
	if apiErrorBase_statusARMGenerator != nil {
		return apiErrorBase_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBase_StatusARM(generators)
	apiErrorBase_statusARMGenerator = gen.Struct(reflect.TypeOf(ApiErrorBase_StatusARM{}), generators)

	return apiErrorBase_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBase_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBase_StatusARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerError_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerError_StatusARM, InnerError_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerError_StatusARM runs a test to see if a specific instance of InnerError_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerError_StatusARM(subject InnerError_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_StatusARM instances for property testing - lazily instantiated by
//InnerError_StatusARMGenerator()
var innerError_statusARMGenerator gopter.Gen

// InnerError_StatusARMGenerator returns a generator of InnerError_StatusARM instances for property testing.
func InnerError_StatusARMGenerator() gopter.Gen {
	if innerError_statusARMGenerator != nil {
		return innerError_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_StatusARM(generators)
	innerError_statusARMGenerator = gen.Struct(reflect.TypeOf(InnerError_StatusARM{}), generators)

	return innerError_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForInnerError_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerError_StatusARM(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}
