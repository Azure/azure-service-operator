// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200930

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20200930storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Disk_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Disk to hub returns original",
		prop.ForAll(RunResourceConversionTestForDisk, DiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForDisk tests if a specific instance of Disk round trips to the hub storage version and back losslessly
func RunResourceConversionTestForDisk(subject Disk) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20200930storage.Disk
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Disk
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Disk_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Disk to Disk via AssignPropertiesToDisk & AssignPropertiesFromDisk returns original",
		prop.ForAll(RunPropertyAssignmentTestForDisk, DiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDisk tests if a specific instance of Disk can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForDisk(subject Disk) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.Disk
	err := copied.AssignPropertiesToDisk(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Disk
	err = actual.AssignPropertiesFromDisk(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Disk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisk, DiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisk runs a test to see if a specific instance of Disk round trips to JSON and back losslessly
func RunJSONSerializationTestForDisk(subject Disk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk instances for property testing - lazily instantiated by DiskGenerator()
var diskGenerator gopter.Gen

// DiskGenerator returns a generator of Disk instances for property testing.
func DiskGenerator() gopter.Gen {
	if diskGenerator != nil {
		return diskGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDisk(generators)
	diskGenerator = gen.Struct(reflect.TypeOf(Disk{}), generators)

	return diskGenerator
}

// AddRelatedPropertyGeneratorsForDisk is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisk(gens map[string]gopter.Gen) {
	gens["Spec"] = Disks_SPECGenerator()
	gens["Status"] = Disk_StatusGenerator()
}

func Test_Disk_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Disk_Status to Disk_Status via AssignPropertiesToDisk_Status & AssignPropertiesFromDisk_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDisk_Status, Disk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDisk_Status tests if a specific instance of Disk_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForDisk_Status(subject Disk_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.Disk_Status
	err := copied.AssignPropertiesToDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Disk_Status
	err = actual.AssignPropertiesFromDisk_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Disk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisk_Status, Disk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisk_Status runs a test to see if a specific instance of Disk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDisk_Status(subject Disk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk_Status instances for property testing - lazily instantiated by Disk_StatusGenerator()
var disk_statusGenerator gopter.Gen

// Disk_StatusGenerator returns a generator of Disk_Status instances for property testing.
// We first initialize disk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disk_StatusGenerator() gopter.Gen {
	if disk_statusGenerator != nil {
		return disk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_Status(generators)
	disk_statusGenerator = gen.Struct(reflect.TypeOf(Disk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_Status(generators)
	AddRelatedPropertyGeneratorsForDisk_Status(generators)
	disk_statusGenerator = gen.Struct(reflect.TypeOf(Disk_Status{}), generators)

	return disk_statusGenerator
}

// AddIndependentPropertyGeneratorsForDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisk_Status(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeBytes"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.OneConstOf(
		DiskState_StatusActiveSAS,
		DiskState_StatusActiveUpload,
		DiskState_StatusAttached,
		DiskState_StatusReadyToUpload,
		DiskState_StatusReserved,
		DiskState_StatusUnattached))
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskProperties_HyperVGeneration_StatusV1, DiskProperties_HyperVGeneration_StatusV2))
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedByExtended"] = gen.SliceOf(gen.AlphaString())
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(NetworkAccessPolicy_StatusAllowAll, NetworkAccessPolicy_StatusAllowPrivate, NetworkAccessPolicy_StatusDenyAll))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskProperties_OsType_StatusLinux, DiskProperties_OsType_StatusWindows))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["TimeCreated"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisk_Status(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationData_StatusGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_StatusGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollection_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlan_StatusGenerator())
	gens["ShareInfo"] = gen.SliceOf(ShareInfoElement_StatusGenerator())
	gens["Sku"] = gen.PtrOf(DiskSku_StatusGenerator())
}

func Test_Disks_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Disks_SPEC to Disks_SPEC via AssignPropertiesToDisks_SPEC & AssignPropertiesFromDisks_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForDisks_SPEC, Disks_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDisks_SPEC tests if a specific instance of Disks_SPEC can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForDisks_SPEC(subject Disks_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.Disks_SPEC
	err := copied.AssignPropertiesToDisks_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Disks_SPEC
	err = actual.AssignPropertiesFromDisks_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Disks_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disks_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisks_SPEC, Disks_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisks_SPEC runs a test to see if a specific instance of Disks_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDisks_SPEC(subject Disks_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disks_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disks_SPEC instances for property testing - lazily instantiated by Disks_SPECGenerator()
var disks_specGenerator gopter.Gen

// Disks_SPECGenerator returns a generator of Disks_SPEC instances for property testing.
// We first initialize disks_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disks_SPECGenerator() gopter.Gen {
	if disks_specGenerator != nil {
		return disks_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisks_SPEC(generators)
	disks_specGenerator = gen.Struct(reflect.TypeOf(Disks_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisks_SPEC(generators)
	AddRelatedPropertyGeneratorsForDisks_SPEC(generators)
	disks_specGenerator = gen.Struct(reflect.TypeOf(Disks_SPEC{}), generators)

	return disks_specGenerator
}

// AddIndependentPropertyGeneratorsForDisks_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisks_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.OneConstOf(
		DiskState_SpecActiveSAS,
		DiskState_SpecActiveUpload,
		DiskState_SpecAttached,
		DiskState_SpecReadyToUpload,
		DiskState_SpecReserved,
		DiskState_SpecUnattached))
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskProperties_HyperVGeneration_SpecV1, DiskProperties_HyperVGeneration_SpecV2))
	gens["Location"] = gen.AlphaString()
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(NetworkAccessPolicy_SpecAllowAll, NetworkAccessPolicy_SpecAllowPrivate, NetworkAccessPolicy_SpecDenyAll))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskProperties_OsType_SpecLinux, DiskProperties_OsType_SpecWindows))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisks_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisks_SPEC(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationData_SpecGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_SpecGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollection_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlan_SpecGenerator())
	gens["Sku"] = gen.PtrOf(DiskSku_SpecGenerator())
}

func Test_CreationData_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CreationData_Spec to CreationData_Spec via AssignPropertiesToCreationData_Spec & AssignPropertiesFromCreationData_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCreationData_Spec, CreationData_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCreationData_Spec tests if a specific instance of CreationData_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForCreationData_Spec(subject CreationData_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.CreationData_Spec
	err := copied.AssignPropertiesToCreationData_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CreationData_Spec
	err = actual.AssignPropertiesFromCreationData_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CreationData_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationData_Spec, CreationData_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationData_Spec runs a test to see if a specific instance of CreationData_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationData_Spec(subject CreationData_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_Spec instances for property testing - lazily instantiated by CreationData_SpecGenerator()
var creationData_specGenerator gopter.Gen

// CreationData_SpecGenerator returns a generator of CreationData_Spec instances for property testing.
// We first initialize creationData_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationData_SpecGenerator() gopter.Gen {
	if creationData_specGenerator != nil {
		return creationData_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_Spec(generators)
	creationData_specGenerator = gen.Struct(reflect.TypeOf(CreationData_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_Spec(generators)
	AddRelatedPropertyGeneratorsForCreationData_Spec(generators)
	creationData_specGenerator = gen.Struct(reflect.TypeOf(CreationData_Spec{}), generators)

	return creationData_specGenerator
}

// AddIndependentPropertyGeneratorsForCreationData_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationData_Spec(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.OneConstOf(
		CreationData_CreateOption_SpecAttach,
		CreationData_CreateOption_SpecCopy,
		CreationData_CreateOption_SpecEmpty,
		CreationData_CreateOption_SpecFromImage,
		CreationData_CreateOption_SpecImport,
		CreationData_CreateOption_SpecRestore,
		CreationData_CreateOption_SpecUpload)
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationData_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationData_Spec(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReference_SpecGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReference_SpecGenerator())
}

func Test_CreationData_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CreationData_Status to CreationData_Status via AssignPropertiesToCreationData_Status & AssignPropertiesFromCreationData_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForCreationData_Status, CreationData_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCreationData_Status tests if a specific instance of CreationData_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForCreationData_Status(subject CreationData_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.CreationData_Status
	err := copied.AssignPropertiesToCreationData_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CreationData_Status
	err = actual.AssignPropertiesFromCreationData_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CreationData_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationData_Status, CreationData_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationData_Status runs a test to see if a specific instance of CreationData_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationData_Status(subject CreationData_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_Status instances for property testing - lazily instantiated by
//CreationData_StatusGenerator()
var creationData_statusGenerator gopter.Gen

// CreationData_StatusGenerator returns a generator of CreationData_Status instances for property testing.
// We first initialize creationData_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationData_StatusGenerator() gopter.Gen {
	if creationData_statusGenerator != nil {
		return creationData_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_Status(generators)
	creationData_statusGenerator = gen.Struct(reflect.TypeOf(CreationData_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_Status(generators)
	AddRelatedPropertyGeneratorsForCreationData_Status(generators)
	creationData_statusGenerator = gen.Struct(reflect.TypeOf(CreationData_Status{}), generators)

	return creationData_statusGenerator
}

// AddIndependentPropertyGeneratorsForCreationData_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationData_Status(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.OneConstOf(
		CreationData_CreateOption_StatusAttach,
		CreationData_CreateOption_StatusCopy,
		CreationData_CreateOption_StatusEmpty,
		CreationData_CreateOption_StatusFromImage,
		CreationData_CreateOption_StatusImport,
		CreationData_CreateOption_StatusRestore,
		CreationData_CreateOption_StatusUpload)
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationData_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationData_Status(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReference_StatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReference_StatusGenerator())
}

func Test_DiskSku_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiskSku_Spec to DiskSku_Spec via AssignPropertiesToDiskSku_Spec & AssignPropertiesFromDiskSku_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiskSku_Spec, DiskSku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiskSku_Spec tests if a specific instance of DiskSku_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForDiskSku_Spec(subject DiskSku_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.DiskSku_Spec
	err := copied.AssignPropertiesToDiskSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiskSku_Spec
	err = actual.AssignPropertiesFromDiskSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiskSku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSku_Spec, DiskSku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSku_Spec runs a test to see if a specific instance of DiskSku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSku_Spec(subject DiskSku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_Spec instances for property testing - lazily instantiated by DiskSku_SpecGenerator()
var diskSku_specGenerator gopter.Gen

// DiskSku_SpecGenerator returns a generator of DiskSku_Spec instances for property testing.
func DiskSku_SpecGenerator() gopter.Gen {
	if diskSku_specGenerator != nil {
		return diskSku_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSku_Spec(generators)
	diskSku_specGenerator = gen.Struct(reflect.TypeOf(DiskSku_Spec{}), generators)

	return diskSku_specGenerator
}

// AddIndependentPropertyGeneratorsForDiskSku_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSku_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSku_Name_SpecPremium_LRS,
		DiskSku_Name_SpecStandardSSD_LRS,
		DiskSku_Name_SpecStandard_LRS,
		DiskSku_Name_SpecUltraSSD_LRS))
}

func Test_DiskSku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DiskSku_Status to DiskSku_Status via AssignPropertiesToDiskSku_Status & AssignPropertiesFromDiskSku_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDiskSku_Status, DiskSku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDiskSku_Status tests if a specific instance of DiskSku_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForDiskSku_Status(subject DiskSku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.DiskSku_Status
	err := copied.AssignPropertiesToDiskSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DiskSku_Status
	err = actual.AssignPropertiesFromDiskSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DiskSku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSku_Status, DiskSku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSku_Status runs a test to see if a specific instance of DiskSku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSku_Status(subject DiskSku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_Status instances for property testing - lazily instantiated by DiskSku_StatusGenerator()
var diskSku_statusGenerator gopter.Gen

// DiskSku_StatusGenerator returns a generator of DiskSku_Status instances for property testing.
func DiskSku_StatusGenerator() gopter.Gen {
	if diskSku_statusGenerator != nil {
		return diskSku_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSku_Status(generators)
	diskSku_statusGenerator = gen.Struct(reflect.TypeOf(DiskSku_Status{}), generators)

	return diskSku_statusGenerator
}

// AddIndependentPropertyGeneratorsForDiskSku_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSku_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSku_Name_StatusPremium_LRS,
		DiskSku_Name_StatusStandardSSD_LRS,
		DiskSku_Name_StatusStandard_LRS,
		DiskSku_Name_StatusUltraSSD_LRS))
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsCollection_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionSettingsCollection_Spec to EncryptionSettingsCollection_Spec via AssignPropertiesToEncryptionSettingsCollection_Spec & AssignPropertiesFromEncryptionSettingsCollection_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionSettingsCollection_Spec, EncryptionSettingsCollection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionSettingsCollection_Spec tests if a specific instance of EncryptionSettingsCollection_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForEncryptionSettingsCollection_Spec(subject EncryptionSettingsCollection_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.EncryptionSettingsCollection_Spec
	err := copied.AssignPropertiesToEncryptionSettingsCollection_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionSettingsCollection_Spec
	err = actual.AssignPropertiesFromEncryptionSettingsCollection_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionSettingsCollection_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollection_Spec, EncryptionSettingsCollection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollection_Spec runs a test to see if a specific instance of EncryptionSettingsCollection_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollection_Spec(subject EncryptionSettingsCollection_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_Spec instances for property testing - lazily instantiated by
//EncryptionSettingsCollection_SpecGenerator()
var encryptionSettingsCollection_specGenerator gopter.Gen

// EncryptionSettingsCollection_SpecGenerator returns a generator of EncryptionSettingsCollection_Spec instances for property testing.
// We first initialize encryptionSettingsCollection_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollection_SpecGenerator() gopter.Gen {
	if encryptionSettingsCollection_specGenerator != nil {
		return encryptionSettingsCollection_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Spec(generators)
	encryptionSettingsCollection_specGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Spec(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Spec(generators)
	encryptionSettingsCollection_specGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_Spec{}), generators)

	return encryptionSettingsCollection_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.Bool()
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Spec(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElement_SpecGenerator())
}

func Test_EncryptionSettingsCollection_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionSettingsCollection_Status to EncryptionSettingsCollection_Status via AssignPropertiesToEncryptionSettingsCollection_Status & AssignPropertiesFromEncryptionSettingsCollection_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionSettingsCollection_Status, EncryptionSettingsCollection_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionSettingsCollection_Status tests if a specific instance of EncryptionSettingsCollection_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForEncryptionSettingsCollection_Status(subject EncryptionSettingsCollection_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.EncryptionSettingsCollection_Status
	err := copied.AssignPropertiesToEncryptionSettingsCollection_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionSettingsCollection_Status
	err = actual.AssignPropertiesFromEncryptionSettingsCollection_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionSettingsCollection_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollection_Status, EncryptionSettingsCollection_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollection_Status runs a test to see if a specific instance of EncryptionSettingsCollection_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollection_Status(subject EncryptionSettingsCollection_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_Status instances for property testing - lazily instantiated by
//EncryptionSettingsCollection_StatusGenerator()
var encryptionSettingsCollection_statusGenerator gopter.Gen

// EncryptionSettingsCollection_StatusGenerator returns a generator of EncryptionSettingsCollection_Status instances for property testing.
// We first initialize encryptionSettingsCollection_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollection_StatusGenerator() gopter.Gen {
	if encryptionSettingsCollection_statusGenerator != nil {
		return encryptionSettingsCollection_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Status(generators)
	encryptionSettingsCollection_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Status(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Status(generators)
	encryptionSettingsCollection_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_Status{}), generators)

	return encryptionSettingsCollection_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.Bool()
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Status(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElement_StatusGenerator())
}

func Test_Encryption_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Encryption_Spec to Encryption_Spec via AssignPropertiesToEncryption_Spec & AssignPropertiesFromEncryption_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryption_Spec, Encryption_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryption_Spec tests if a specific instance of Encryption_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForEncryption_Spec(subject Encryption_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.Encryption_Spec
	err := copied.AssignPropertiesToEncryption_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Encryption_Spec
	err = actual.AssignPropertiesFromEncryption_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Encryption_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_Spec, Encryption_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_Spec runs a test to see if a specific instance of Encryption_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_Spec(subject Encryption_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Spec instances for property testing - lazily instantiated by Encryption_SpecGenerator()
var encryption_specGenerator gopter.Gen

// Encryption_SpecGenerator returns a generator of Encryption_Spec instances for property testing.
func Encryption_SpecGenerator() gopter.Gen {
	if encryption_specGenerator != nil {
		return encryption_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Spec(generators)
	encryption_specGenerator = gen.Struct(reflect.TypeOf(Encryption_Spec{}), generators)

	return encryption_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(EncryptionType_SpecEncryptionAtRestWithCustomerKey, EncryptionType_SpecEncryptionAtRestWithPlatformAndCustomerKeys, EncryptionType_SpecEncryptionAtRestWithPlatformKey))
}

func Test_Encryption_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Encryption_Status to Encryption_Status via AssignPropertiesToEncryption_Status & AssignPropertiesFromEncryption_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryption_Status, Encryption_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryption_Status tests if a specific instance of Encryption_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForEncryption_Status(subject Encryption_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.Encryption_Status
	err := copied.AssignPropertiesToEncryption_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Encryption_Status
	err = actual.AssignPropertiesFromEncryption_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Encryption_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_Status, Encryption_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_Status runs a test to see if a specific instance of Encryption_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_Status(subject Encryption_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Status instances for property testing - lazily instantiated by Encryption_StatusGenerator()
var encryption_statusGenerator gopter.Gen

// Encryption_StatusGenerator returns a generator of Encryption_Status instances for property testing.
func Encryption_StatusGenerator() gopter.Gen {
	if encryption_statusGenerator != nil {
		return encryption_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Status(generators)
	encryption_statusGenerator = gen.Struct(reflect.TypeOf(Encryption_Status{}), generators)

	return encryption_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(EncryptionType_StatusEncryptionAtRestWithCustomerKey, EncryptionType_StatusEncryptionAtRestWithPlatformAndCustomerKeys, EncryptionType_StatusEncryptionAtRestWithPlatformKey))
}

func Test_ExtendedLocation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Spec to ExtendedLocation_Spec via AssignPropertiesToExtendedLocation_Spec & AssignPropertiesFromExtendedLocation_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Spec tests if a specific instance of ExtendedLocation_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.ExtendedLocation_Spec
	err := copied.AssignPropertiesToExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Spec
	err = actual.AssignPropertiesFromExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Spec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocation_SpecGenerator()
var extendedLocation_specGenerator gopter.Gen

// ExtendedLocation_SpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocation_SpecGenerator() gopter.Gen {
	if extendedLocation_specGenerator != nil {
		return extendedLocation_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Spec(generators)
	extendedLocation_specGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocation_specGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_ExtendedLocation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Status to ExtendedLocation_Status via AssignPropertiesToExtendedLocation_Status & AssignPropertiesFromExtendedLocation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Status tests if a specific instance of ExtendedLocation_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.ExtendedLocation_Status
	err := copied.AssignPropertiesToExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Status
	err = actual.AssignPropertiesFromExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Status runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocation_StatusGenerator()
var extendedLocation_statusGenerator gopter.Gen

// ExtendedLocation_StatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocation_StatusGenerator() gopter.Gen {
	if extendedLocation_statusGenerator != nil {
		return extendedLocation_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Status(generators)
	extendedLocation_statusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocation_statusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_StatusEdgeZone))
}

func Test_PurchasePlan_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PurchasePlan_Spec to PurchasePlan_Spec via AssignPropertiesToPurchasePlan_Spec & AssignPropertiesFromPurchasePlan_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPurchasePlan_Spec, PurchasePlan_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPurchasePlan_Spec tests if a specific instance of PurchasePlan_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForPurchasePlan_Spec(subject PurchasePlan_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.PurchasePlan_Spec
	err := copied.AssignPropertiesToPurchasePlan_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PurchasePlan_Spec
	err = actual.AssignPropertiesFromPurchasePlan_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PurchasePlan_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlan_Spec, PurchasePlan_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlan_Spec runs a test to see if a specific instance of PurchasePlan_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlan_Spec(subject PurchasePlan_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_Spec instances for property testing - lazily instantiated by PurchasePlan_SpecGenerator()
var purchasePlan_specGenerator gopter.Gen

// PurchasePlan_SpecGenerator returns a generator of PurchasePlan_Spec instances for property testing.
func PurchasePlan_SpecGenerator() gopter.Gen {
	if purchasePlan_specGenerator != nil {
		return purchasePlan_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlan_Spec(generators)
	purchasePlan_specGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_Spec{}), generators)

	return purchasePlan_specGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlan_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlan_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Product"] = gen.AlphaString()
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.AlphaString()
}

func Test_PurchasePlan_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PurchasePlan_Status to PurchasePlan_Status via AssignPropertiesToPurchasePlan_Status & AssignPropertiesFromPurchasePlan_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForPurchasePlan_Status, PurchasePlan_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPurchasePlan_Status tests if a specific instance of PurchasePlan_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForPurchasePlan_Status(subject PurchasePlan_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.PurchasePlan_Status
	err := copied.AssignPropertiesToPurchasePlan_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PurchasePlan_Status
	err = actual.AssignPropertiesFromPurchasePlan_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PurchasePlan_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlan_Status, PurchasePlan_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlan_Status runs a test to see if a specific instance of PurchasePlan_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlan_Status(subject PurchasePlan_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_Status instances for property testing - lazily instantiated by
//PurchasePlan_StatusGenerator()
var purchasePlan_statusGenerator gopter.Gen

// PurchasePlan_StatusGenerator returns a generator of PurchasePlan_Status instances for property testing.
func PurchasePlan_StatusGenerator() gopter.Gen {
	if purchasePlan_statusGenerator != nil {
		return purchasePlan_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlan_Status(generators)
	purchasePlan_statusGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_Status{}), generators)

	return purchasePlan_statusGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlan_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlan_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Product"] = gen.AlphaString()
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.AlphaString()
}

func Test_ShareInfoElement_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ShareInfoElement_Status to ShareInfoElement_Status via AssignPropertiesToShareInfoElement_Status & AssignPropertiesFromShareInfoElement_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForShareInfoElement_Status, ShareInfoElement_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForShareInfoElement_Status tests if a specific instance of ShareInfoElement_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForShareInfoElement_Status(subject ShareInfoElement_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.ShareInfoElement_Status
	err := copied.AssignPropertiesToShareInfoElement_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ShareInfoElement_Status
	err = actual.AssignPropertiesFromShareInfoElement_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ShareInfoElement_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShareInfoElement_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShareInfoElement_Status, ShareInfoElement_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShareInfoElement_Status runs a test to see if a specific instance of ShareInfoElement_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForShareInfoElement_Status(subject ShareInfoElement_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShareInfoElement_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShareInfoElement_Status instances for property testing - lazily instantiated by
//ShareInfoElement_StatusGenerator()
var shareInfoElement_statusGenerator gopter.Gen

// ShareInfoElement_StatusGenerator returns a generator of ShareInfoElement_Status instances for property testing.
func ShareInfoElement_StatusGenerator() gopter.Gen {
	if shareInfoElement_statusGenerator != nil {
		return shareInfoElement_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShareInfoElement_Status(generators)
	shareInfoElement_statusGenerator = gen.Struct(reflect.TypeOf(ShareInfoElement_Status{}), generators)

	return shareInfoElement_statusGenerator
}

// AddIndependentPropertyGeneratorsForShareInfoElement_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShareInfoElement_Status(gens map[string]gopter.Gen) {
	gens["VmUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsElement_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionSettingsElement_Spec to EncryptionSettingsElement_Spec via AssignPropertiesToEncryptionSettingsElement_Spec & AssignPropertiesFromEncryptionSettingsElement_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionSettingsElement_Spec, EncryptionSettingsElement_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionSettingsElement_Spec tests if a specific instance of EncryptionSettingsElement_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForEncryptionSettingsElement_Spec(subject EncryptionSettingsElement_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.EncryptionSettingsElement_Spec
	err := copied.AssignPropertiesToEncryptionSettingsElement_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionSettingsElement_Spec
	err = actual.AssignPropertiesFromEncryptionSettingsElement_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionSettingsElement_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElement_Spec, EncryptionSettingsElement_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElement_Spec runs a test to see if a specific instance of EncryptionSettingsElement_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElement_Spec(subject EncryptionSettingsElement_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_Spec instances for property testing - lazily instantiated by
//EncryptionSettingsElement_SpecGenerator()
var encryptionSettingsElement_specGenerator gopter.Gen

// EncryptionSettingsElement_SpecGenerator returns a generator of EncryptionSettingsElement_Spec instances for property testing.
func EncryptionSettingsElement_SpecGenerator() gopter.Gen {
	if encryptionSettingsElement_specGenerator != nil {
		return encryptionSettingsElement_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Spec(generators)
	encryptionSettingsElement_specGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_Spec{}), generators)

	return encryptionSettingsElement_specGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Spec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReference_SpecGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReference_SpecGenerator())
}

func Test_EncryptionSettingsElement_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionSettingsElement_Status to EncryptionSettingsElement_Status via AssignPropertiesToEncryptionSettingsElement_Status & AssignPropertiesFromEncryptionSettingsElement_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionSettingsElement_Status, EncryptionSettingsElement_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionSettingsElement_Status tests if a specific instance of EncryptionSettingsElement_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForEncryptionSettingsElement_Status(subject EncryptionSettingsElement_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.EncryptionSettingsElement_Status
	err := copied.AssignPropertiesToEncryptionSettingsElement_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionSettingsElement_Status
	err = actual.AssignPropertiesFromEncryptionSettingsElement_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionSettingsElement_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElement_Status, EncryptionSettingsElement_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElement_Status runs a test to see if a specific instance of EncryptionSettingsElement_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElement_Status(subject EncryptionSettingsElement_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_Status instances for property testing - lazily instantiated by
//EncryptionSettingsElement_StatusGenerator()
var encryptionSettingsElement_statusGenerator gopter.Gen

// EncryptionSettingsElement_StatusGenerator returns a generator of EncryptionSettingsElement_Status instances for property testing.
func EncryptionSettingsElement_StatusGenerator() gopter.Gen {
	if encryptionSettingsElement_statusGenerator != nil {
		return encryptionSettingsElement_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Status(generators)
	encryptionSettingsElement_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_Status{}), generators)

	return encryptionSettingsElement_statusGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReference_StatusGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReference_StatusGenerator())
}

func Test_ImageDiskReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ImageDiskReference_Spec to ImageDiskReference_Spec via AssignPropertiesToImageDiskReference_Spec & AssignPropertiesFromImageDiskReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForImageDiskReference_Spec, ImageDiskReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForImageDiskReference_Spec tests if a specific instance of ImageDiskReference_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForImageDiskReference_Spec(subject ImageDiskReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.ImageDiskReference_Spec
	err := copied.AssignPropertiesToImageDiskReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ImageDiskReference_Spec
	err = actual.AssignPropertiesFromImageDiskReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ImageDiskReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReference_Spec, ImageDiskReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReference_Spec runs a test to see if a specific instance of ImageDiskReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReference_Spec(subject ImageDiskReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_Spec instances for property testing - lazily instantiated by
//ImageDiskReference_SpecGenerator()
var imageDiskReference_specGenerator gopter.Gen

// ImageDiskReference_SpecGenerator returns a generator of ImageDiskReference_Spec instances for property testing.
func ImageDiskReference_SpecGenerator() gopter.Gen {
	if imageDiskReference_specGenerator != nil {
		return imageDiskReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReference_Spec(generators)
	imageDiskReference_specGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_Spec{}), generators)

	return imageDiskReference_specGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReference_Spec(gens map[string]gopter.Gen) {
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_ImageDiskReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ImageDiskReference_Status to ImageDiskReference_Status via AssignPropertiesToImageDiskReference_Status & AssignPropertiesFromImageDiskReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForImageDiskReference_Status, ImageDiskReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForImageDiskReference_Status tests if a specific instance of ImageDiskReference_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForImageDiskReference_Status(subject ImageDiskReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.ImageDiskReference_Status
	err := copied.AssignPropertiesToImageDiskReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ImageDiskReference_Status
	err = actual.AssignPropertiesFromImageDiskReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ImageDiskReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReference_Status, ImageDiskReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReference_Status runs a test to see if a specific instance of ImageDiskReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReference_Status(subject ImageDiskReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_Status instances for property testing - lazily instantiated by
//ImageDiskReference_StatusGenerator()
var imageDiskReference_statusGenerator gopter.Gen

// ImageDiskReference_StatusGenerator returns a generator of ImageDiskReference_Status instances for property testing.
func ImageDiskReference_StatusGenerator() gopter.Gen {
	if imageDiskReference_statusGenerator != nil {
		return imageDiskReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReference_Status(generators)
	imageDiskReference_statusGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_Status{}), generators)

	return imageDiskReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReference_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_KeyVaultAndKeyReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultAndKeyReference_Spec to KeyVaultAndKeyReference_Spec via AssignPropertiesToKeyVaultAndKeyReference_Spec & AssignPropertiesFromKeyVaultAndKeyReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultAndKeyReference_Spec, KeyVaultAndKeyReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultAndKeyReference_Spec tests if a specific instance of KeyVaultAndKeyReference_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultAndKeyReference_Spec(subject KeyVaultAndKeyReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.KeyVaultAndKeyReference_Spec
	err := copied.AssignPropertiesToKeyVaultAndKeyReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultAndKeyReference_Spec
	err = actual.AssignPropertiesFromKeyVaultAndKeyReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultAndKeyReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReference_Spec, KeyVaultAndKeyReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReference_Spec runs a test to see if a specific instance of KeyVaultAndKeyReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReference_Spec(subject KeyVaultAndKeyReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_Spec instances for property testing - lazily instantiated by
//KeyVaultAndKeyReference_SpecGenerator()
var keyVaultAndKeyReference_specGenerator gopter.Gen

// KeyVaultAndKeyReference_SpecGenerator returns a generator of KeyVaultAndKeyReference_Spec instances for property testing.
// We first initialize keyVaultAndKeyReference_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReference_SpecGenerator() gopter.Gen {
	if keyVaultAndKeyReference_specGenerator != nil {
		return keyVaultAndKeyReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Spec(generators)
	keyVaultAndKeyReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Spec(generators)
	keyVaultAndKeyReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_Spec{}), generators)

	return keyVaultAndKeyReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Spec(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SourceVault_SpecGenerator()
}

func Test_KeyVaultAndKeyReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultAndKeyReference_Status to KeyVaultAndKeyReference_Status via AssignPropertiesToKeyVaultAndKeyReference_Status & AssignPropertiesFromKeyVaultAndKeyReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultAndKeyReference_Status, KeyVaultAndKeyReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultAndKeyReference_Status tests if a specific instance of KeyVaultAndKeyReference_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultAndKeyReference_Status(subject KeyVaultAndKeyReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.KeyVaultAndKeyReference_Status
	err := copied.AssignPropertiesToKeyVaultAndKeyReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultAndKeyReference_Status
	err = actual.AssignPropertiesFromKeyVaultAndKeyReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultAndKeyReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReference_Status, KeyVaultAndKeyReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReference_Status runs a test to see if a specific instance of KeyVaultAndKeyReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReference_Status(subject KeyVaultAndKeyReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_Status instances for property testing - lazily instantiated by
//KeyVaultAndKeyReference_StatusGenerator()
var keyVaultAndKeyReference_statusGenerator gopter.Gen

// KeyVaultAndKeyReference_StatusGenerator returns a generator of KeyVaultAndKeyReference_Status instances for property testing.
// We first initialize keyVaultAndKeyReference_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReference_StatusGenerator() gopter.Gen {
	if keyVaultAndKeyReference_statusGenerator != nil {
		return keyVaultAndKeyReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Status(generators)
	keyVaultAndKeyReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Status(generators)
	keyVaultAndKeyReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_Status{}), generators)

	return keyVaultAndKeyReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Status(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SourceVault_StatusGenerator()
}

func Test_KeyVaultAndSecretReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultAndSecretReference_Spec to KeyVaultAndSecretReference_Spec via AssignPropertiesToKeyVaultAndSecretReference_Spec & AssignPropertiesFromKeyVaultAndSecretReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultAndSecretReference_Spec, KeyVaultAndSecretReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultAndSecretReference_Spec tests if a specific instance of KeyVaultAndSecretReference_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultAndSecretReference_Spec(subject KeyVaultAndSecretReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.KeyVaultAndSecretReference_Spec
	err := copied.AssignPropertiesToKeyVaultAndSecretReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultAndSecretReference_Spec
	err = actual.AssignPropertiesFromKeyVaultAndSecretReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultAndSecretReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReference_Spec, KeyVaultAndSecretReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReference_Spec runs a test to see if a specific instance of KeyVaultAndSecretReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReference_Spec(subject KeyVaultAndSecretReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_Spec instances for property testing - lazily instantiated by
//KeyVaultAndSecretReference_SpecGenerator()
var keyVaultAndSecretReference_specGenerator gopter.Gen

// KeyVaultAndSecretReference_SpecGenerator returns a generator of KeyVaultAndSecretReference_Spec instances for property testing.
// We first initialize keyVaultAndSecretReference_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReference_SpecGenerator() gopter.Gen {
	if keyVaultAndSecretReference_specGenerator != nil {
		return keyVaultAndSecretReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Spec(generators)
	keyVaultAndSecretReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Spec(generators)
	keyVaultAndSecretReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_Spec{}), generators)

	return keyVaultAndSecretReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Spec(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SourceVault_SpecGenerator()
}

func Test_KeyVaultAndSecretReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultAndSecretReference_Status to KeyVaultAndSecretReference_Status via AssignPropertiesToKeyVaultAndSecretReference_Status & AssignPropertiesFromKeyVaultAndSecretReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultAndSecretReference_Status, KeyVaultAndSecretReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultAndSecretReference_Status tests if a specific instance of KeyVaultAndSecretReference_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultAndSecretReference_Status(subject KeyVaultAndSecretReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.KeyVaultAndSecretReference_Status
	err := copied.AssignPropertiesToKeyVaultAndSecretReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultAndSecretReference_Status
	err = actual.AssignPropertiesFromKeyVaultAndSecretReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultAndSecretReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReference_Status, KeyVaultAndSecretReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReference_Status runs a test to see if a specific instance of KeyVaultAndSecretReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReference_Status(subject KeyVaultAndSecretReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_Status instances for property testing - lazily instantiated by
//KeyVaultAndSecretReference_StatusGenerator()
var keyVaultAndSecretReference_statusGenerator gopter.Gen

// KeyVaultAndSecretReference_StatusGenerator returns a generator of KeyVaultAndSecretReference_Status instances for property testing.
// We first initialize keyVaultAndSecretReference_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReference_StatusGenerator() gopter.Gen {
	if keyVaultAndSecretReference_statusGenerator != nil {
		return keyVaultAndSecretReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Status(generators)
	keyVaultAndSecretReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Status(generators)
	keyVaultAndSecretReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_Status{}), generators)

	return keyVaultAndSecretReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Status(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SourceVault_StatusGenerator()
}

func Test_SourceVault_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SourceVault_Spec to SourceVault_Spec via AssignPropertiesToSourceVault_Spec & AssignPropertiesFromSourceVault_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSourceVault_Spec, SourceVault_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSourceVault_Spec tests if a specific instance of SourceVault_Spec can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForSourceVault_Spec(subject SourceVault_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.SourceVault_Spec
	err := copied.AssignPropertiesToSourceVault_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SourceVault_Spec
	err = actual.AssignPropertiesFromSourceVault_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SourceVault_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVault_Spec, SourceVault_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVault_Spec runs a test to see if a specific instance of SourceVault_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVault_Spec(subject SourceVault_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_Spec instances for property testing - lazily instantiated by SourceVault_SpecGenerator()
var sourceVault_specGenerator gopter.Gen

// SourceVault_SpecGenerator returns a generator of SourceVault_Spec instances for property testing.
func SourceVault_SpecGenerator() gopter.Gen {
	if sourceVault_specGenerator != nil {
		return sourceVault_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	sourceVault_specGenerator = gen.Struct(reflect.TypeOf(SourceVault_Spec{}), generators)

	return sourceVault_specGenerator
}

func Test_SourceVault_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SourceVault_Status to SourceVault_Status via AssignPropertiesToSourceVault_Status & AssignPropertiesFromSourceVault_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSourceVault_Status, SourceVault_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSourceVault_Status tests if a specific instance of SourceVault_Status can be assigned to v1alpha1api20200930storage and back losslessly
func RunPropertyAssignmentTestForSourceVault_Status(subject SourceVault_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200930storage.SourceVault_Status
	err := copied.AssignPropertiesToSourceVault_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SourceVault_Status
	err = actual.AssignPropertiesFromSourceVault_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SourceVault_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVault_Status, SourceVault_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVault_Status runs a test to see if a specific instance of SourceVault_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVault_Status(subject SourceVault_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_Status instances for property testing - lazily instantiated by SourceVault_StatusGenerator()
var sourceVault_statusGenerator gopter.Gen

// SourceVault_StatusGenerator returns a generator of SourceVault_Status instances for property testing.
func SourceVault_StatusGenerator() gopter.Gen {
	if sourceVault_statusGenerator != nil {
		return sourceVault_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSourceVault_Status(generators)
	sourceVault_statusGenerator = gen.Struct(reflect.TypeOf(SourceVault_Status{}), generators)

	return sourceVault_statusGenerator
}

// AddIndependentPropertyGeneratorsForSourceVault_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSourceVault_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
