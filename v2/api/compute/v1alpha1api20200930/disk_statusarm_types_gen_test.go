// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200930

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Disk_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisk_STATUSARM, Disk_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisk_STATUSARM runs a test to see if a specific instance of Disk_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDisk_STATUSARM(subject Disk_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk_STATUSARM instances for property testing - lazily instantiated by Disk_STATUSARMGenerator()
var disk_STATUSARMGenerator gopter.Gen

// Disk_STATUSARMGenerator returns a generator of Disk_STATUSARM instances for property testing.
// We first initialize disk_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disk_STATUSARMGenerator() gopter.Gen {
	if disk_STATUSARMGenerator != nil {
		return disk_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_STATUSARM(generators)
	disk_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Disk_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForDisk_STATUSARM(generators)
	disk_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Disk_STATUSARM{}), generators)

	return disk_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDisk_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisk_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedByExtended"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisk_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisk_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(DiskProperties_STATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(DiskSku_STATUSARMGenerator())
}

func Test_DiskProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskProperties_STATUSARM, DiskProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskProperties_STATUSARM runs a test to see if a specific instance of DiskProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskProperties_STATUSARM(subject DiskProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskProperties_STATUSARM instances for property testing - lazily instantiated by
// DiskProperties_STATUSARMGenerator()
var diskProperties_STATUSARMGenerator gopter.Gen

// DiskProperties_STATUSARMGenerator returns a generator of DiskProperties_STATUSARM instances for property testing.
// We first initialize diskProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskProperties_STATUSARMGenerator() gopter.Gen {
	if diskProperties_STATUSARMGenerator != nil {
		return diskProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskProperties_STATUSARM(generators)
	diskProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForDiskProperties_STATUSARM(generators)
	diskProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_STATUSARM{}), generators)

	return diskProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeBytes"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.OneConstOf(
		DiskState_STATUSActiveSAS,
		DiskState_STATUSActiveUpload,
		DiskState_STATUSAttached,
		DiskState_STATUSReadyToUpload,
		DiskState_STATUSReserved,
		DiskState_STATUSUnattached))
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskProperties_HyperVGeneration_STATUSV1, DiskProperties_HyperVGeneration_STATUSV2))
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(NetworkAccessPolicy_STATUSAllowAll, NetworkAccessPolicy_STATUSAllowPrivate, NetworkAccessPolicy_STATUSDenyAll))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskProperties_OsType_STATUSLinux, DiskProperties_OsType_STATUSWindows))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["TimeCreated"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationData_STATUSARMGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_STATUSARMGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollection_STATUSARMGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlan_STATUSARMGenerator())
	gens["ShareInfo"] = gen.SliceOf(ShareInfoElement_STATUSARMGenerator())
}

func Test_DiskSku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSku_STATUSARM, DiskSku_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSku_STATUSARM runs a test to see if a specific instance of DiskSku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSku_STATUSARM(subject DiskSku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_STATUSARM instances for property testing - lazily instantiated by DiskSku_STATUSARMGenerator()
var diskSku_STATUSARMGenerator gopter.Gen

// DiskSku_STATUSARMGenerator returns a generator of DiskSku_STATUSARM instances for property testing.
func DiskSku_STATUSARMGenerator() gopter.Gen {
	if diskSku_STATUSARMGenerator != nil {
		return diskSku_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSku_STATUSARM(generators)
	diskSku_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskSku_STATUSARM{}), generators)

	return diskSku_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSku_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSku_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSku_Name_STATUSPremium_LRS,
		DiskSku_Name_STATUSStandardSSD_LRS,
		DiskSku_Name_STATUSStandard_LRS,
		DiskSku_Name_STATUSUltraSSD_LRS))
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_STATUSARM, ExtendedLocation_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_STATUSARM runs a test to see if a specific instance of ExtendedLocation_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_STATUSARM(subject ExtendedLocation_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUSARM instances for property testing - lazily instantiated by
// ExtendedLocation_STATUSARMGenerator()
var extendedLocation_STATUSARMGenerator gopter.Gen

// ExtendedLocation_STATUSARMGenerator returns a generator of ExtendedLocation_STATUSARM instances for property testing.
func ExtendedLocation_STATUSARMGenerator() gopter.Gen {
	if extendedLocation_STATUSARMGenerator != nil {
		return extendedLocation_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM(generators)
	extendedLocation_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUSARM{}), generators)

	return extendedLocation_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_STATUSEdgeZone))
}

func Test_CreationData_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationData_STATUSARM, CreationData_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationData_STATUSARM runs a test to see if a specific instance of CreationData_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationData_STATUSARM(subject CreationData_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_STATUSARM instances for property testing - lazily instantiated by
// CreationData_STATUSARMGenerator()
var creationData_STATUSARMGenerator gopter.Gen

// CreationData_STATUSARMGenerator returns a generator of CreationData_STATUSARM instances for property testing.
// We first initialize creationData_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationData_STATUSARMGenerator() gopter.Gen {
	if creationData_STATUSARMGenerator != nil {
		return creationData_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_STATUSARM(generators)
	creationData_STATUSARMGenerator = gen.Struct(reflect.TypeOf(CreationData_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForCreationData_STATUSARM(generators)
	creationData_STATUSARMGenerator = gen.Struct(reflect.TypeOf(CreationData_STATUSARM{}), generators)

	return creationData_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCreationData_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationData_STATUSARM(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(
		CreationData_CreateOption_STATUSAttach,
		CreationData_CreateOption_STATUSCopy,
		CreationData_CreateOption_STATUSEmpty,
		CreationData_CreateOption_STATUSFromImage,
		CreationData_CreateOption_STATUSImport,
		CreationData_CreateOption_STATUSRestore,
		CreationData_CreateOption_STATUSUpload))
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationData_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationData_STATUSARM(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReference_STATUSARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReference_STATUSARMGenerator())
}

func Test_EncryptionSettingsCollection_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollection_STATUSARM, EncryptionSettingsCollection_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollection_STATUSARM runs a test to see if a specific instance of EncryptionSettingsCollection_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollection_STATUSARM(subject EncryptionSettingsCollection_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_STATUSARM instances for property testing - lazily instantiated by
// EncryptionSettingsCollection_STATUSARMGenerator()
var encryptionSettingsCollection_STATUSARMGenerator gopter.Gen

// EncryptionSettingsCollection_STATUSARMGenerator returns a generator of EncryptionSettingsCollection_STATUSARM instances for property testing.
// We first initialize encryptionSettingsCollection_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollection_STATUSARMGenerator() gopter.Gen {
	if encryptionSettingsCollection_STATUSARMGenerator != nil {
		return encryptionSettingsCollection_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_STATUSARM(generators)
	encryptionSettingsCollection_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_STATUSARM(generators)
	encryptionSettingsCollection_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_STATUSARM{}), generators)

	return encryptionSettingsCollection_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_STATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_STATUSARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElement_STATUSARMGenerator())
}

func Test_Encryption_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_STATUSARM, Encryption_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_STATUSARM runs a test to see if a specific instance of Encryption_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_STATUSARM(subject Encryption_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_STATUSARM instances for property testing - lazily instantiated by
// Encryption_STATUSARMGenerator()
var encryption_STATUSARMGenerator gopter.Gen

// Encryption_STATUSARMGenerator returns a generator of Encryption_STATUSARM instances for property testing.
func Encryption_STATUSARMGenerator() gopter.Gen {
	if encryption_STATUSARMGenerator != nil {
		return encryption_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_STATUSARM(generators)
	encryption_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUSARM{}), generators)

	return encryption_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_STATUSARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(EncryptionType_STATUSEncryptionAtRestWithCustomerKey, EncryptionType_STATUSEncryptionAtRestWithPlatformAndCustomerKeys, EncryptionType_STATUSEncryptionAtRestWithPlatformKey))
}

func Test_PurchasePlan_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlan_STATUSARM, PurchasePlan_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlan_STATUSARM runs a test to see if a specific instance of PurchasePlan_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlan_STATUSARM(subject PurchasePlan_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_STATUSARM instances for property testing - lazily instantiated by
// PurchasePlan_STATUSARMGenerator()
var purchasePlan_STATUSARMGenerator gopter.Gen

// PurchasePlan_STATUSARMGenerator returns a generator of PurchasePlan_STATUSARM instances for property testing.
func PurchasePlan_STATUSARMGenerator() gopter.Gen {
	if purchasePlan_STATUSARMGenerator != nil {
		return purchasePlan_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlan_STATUSARM(generators)
	purchasePlan_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_STATUSARM{}), generators)

	return purchasePlan_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlan_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlan_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_ShareInfoElement_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShareInfoElement_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShareInfoElement_STATUSARM, ShareInfoElement_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShareInfoElement_STATUSARM runs a test to see if a specific instance of ShareInfoElement_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForShareInfoElement_STATUSARM(subject ShareInfoElement_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShareInfoElement_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShareInfoElement_STATUSARM instances for property testing - lazily instantiated by
// ShareInfoElement_STATUSARMGenerator()
var shareInfoElement_STATUSARMGenerator gopter.Gen

// ShareInfoElement_STATUSARMGenerator returns a generator of ShareInfoElement_STATUSARM instances for property testing.
func ShareInfoElement_STATUSARMGenerator() gopter.Gen {
	if shareInfoElement_STATUSARMGenerator != nil {
		return shareInfoElement_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShareInfoElement_STATUSARM(generators)
	shareInfoElement_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ShareInfoElement_STATUSARM{}), generators)

	return shareInfoElement_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForShareInfoElement_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShareInfoElement_STATUSARM(gens map[string]gopter.Gen) {
	gens["VmUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsElement_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElement_STATUSARM, EncryptionSettingsElement_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElement_STATUSARM runs a test to see if a specific instance of EncryptionSettingsElement_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElement_STATUSARM(subject EncryptionSettingsElement_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_STATUSARM instances for property testing - lazily instantiated by
// EncryptionSettingsElement_STATUSARMGenerator()
var encryptionSettingsElement_STATUSARMGenerator gopter.Gen

// EncryptionSettingsElement_STATUSARMGenerator returns a generator of EncryptionSettingsElement_STATUSARM instances for property testing.
func EncryptionSettingsElement_STATUSARMGenerator() gopter.Gen {
	if encryptionSettingsElement_STATUSARMGenerator != nil {
		return encryptionSettingsElement_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElement_STATUSARM(generators)
	encryptionSettingsElement_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_STATUSARM{}), generators)

	return encryptionSettingsElement_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElement_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElement_STATUSARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReference_STATUSARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReference_STATUSARMGenerator())
}

func Test_ImageDiskReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReference_STATUSARM, ImageDiskReference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReference_STATUSARM runs a test to see if a specific instance of ImageDiskReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReference_STATUSARM(subject ImageDiskReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_STATUSARM instances for property testing - lazily instantiated by
// ImageDiskReference_STATUSARMGenerator()
var imageDiskReference_STATUSARMGenerator gopter.Gen

// ImageDiskReference_STATUSARMGenerator returns a generator of ImageDiskReference_STATUSARM instances for property testing.
func ImageDiskReference_STATUSARMGenerator() gopter.Gen {
	if imageDiskReference_STATUSARMGenerator != nil {
		return imageDiskReference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReference_STATUSARM(generators)
	imageDiskReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_STATUSARM{}), generators)

	return imageDiskReference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_KeyVaultAndKeyReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReference_STATUSARM, KeyVaultAndKeyReference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReference_STATUSARM runs a test to see if a specific instance of KeyVaultAndKeyReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReference_STATUSARM(subject KeyVaultAndKeyReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultAndKeyReference_STATUSARMGenerator()
var keyVaultAndKeyReference_STATUSARMGenerator gopter.Gen

// KeyVaultAndKeyReference_STATUSARMGenerator returns a generator of KeyVaultAndKeyReference_STATUSARM instances for property testing.
// We first initialize keyVaultAndKeyReference_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReference_STATUSARMGenerator() gopter.Gen {
	if keyVaultAndKeyReference_STATUSARMGenerator != nil {
		return keyVaultAndKeyReference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_STATUSARM(generators)
	keyVaultAndKeyReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_STATUSARM(generators)
	keyVaultAndKeyReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_STATUSARM{}), generators)

	return keyVaultAndKeyReference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVault_STATUSARMGenerator())
}

func Test_KeyVaultAndSecretReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReference_STATUSARM, KeyVaultAndSecretReference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReference_STATUSARM runs a test to see if a specific instance of KeyVaultAndSecretReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReference_STATUSARM(subject KeyVaultAndSecretReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultAndSecretReference_STATUSARMGenerator()
var keyVaultAndSecretReference_STATUSARMGenerator gopter.Gen

// KeyVaultAndSecretReference_STATUSARMGenerator returns a generator of KeyVaultAndSecretReference_STATUSARM instances for property testing.
// We first initialize keyVaultAndSecretReference_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReference_STATUSARMGenerator() gopter.Gen {
	if keyVaultAndSecretReference_STATUSARMGenerator != nil {
		return keyVaultAndSecretReference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_STATUSARM(generators)
	keyVaultAndSecretReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_STATUSARM(generators)
	keyVaultAndSecretReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_STATUSARM{}), generators)

	return keyVaultAndSecretReference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVault_STATUSARMGenerator())
}

func Test_SourceVault_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVault_STATUSARM, SourceVault_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVault_STATUSARM runs a test to see if a specific instance of SourceVault_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVault_STATUSARM(subject SourceVault_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_STATUSARM instances for property testing - lazily instantiated by
// SourceVault_STATUSARMGenerator()
var sourceVault_STATUSARMGenerator gopter.Gen

// SourceVault_STATUSARMGenerator returns a generator of SourceVault_STATUSARM instances for property testing.
func SourceVault_STATUSARMGenerator() gopter.Gen {
	if sourceVault_STATUSARMGenerator != nil {
		return sourceVault_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSourceVault_STATUSARM(generators)
	sourceVault_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SourceVault_STATUSARM{}), generators)

	return sourceVault_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSourceVault_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSourceVault_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
