// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200930

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Disk_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisk_StatusARM, Disk_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisk_StatusARM runs a test to see if a specific instance of Disk_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDisk_StatusARM(subject Disk_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk_StatusARM instances for property testing - lazily instantiated by Disk_StatusARMGenerator()
var disk_statusARMGenerator gopter.Gen

// Disk_StatusARMGenerator returns a generator of Disk_StatusARM instances for property testing.
// We first initialize disk_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disk_StatusARMGenerator() gopter.Gen {
	if disk_statusARMGenerator != nil {
		return disk_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_StatusARM(generators)
	disk_statusARMGenerator = gen.Struct(reflect.TypeOf(Disk_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_StatusARM(generators)
	AddRelatedPropertyGeneratorsForDisk_StatusARM(generators)
	disk_statusARMGenerator = gen.Struct(reflect.TypeOf(Disk_StatusARM{}), generators)

	return disk_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDisk_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisk_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedByExtended"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisk_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisk_StatusARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusARMGenerator())
	gens["Properties"] = gen.PtrOf(DiskProperties_StatusARMGenerator())
	gens["Sku"] = gen.PtrOf(DiskSku_StatusARMGenerator())
}

func Test_DiskProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskProperties_StatusARM, DiskProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskProperties_StatusARM runs a test to see if a specific instance of DiskProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskProperties_StatusARM(subject DiskProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskProperties_StatusARM instances for property testing - lazily instantiated by
//DiskProperties_StatusARMGenerator()
var diskProperties_statusARMGenerator gopter.Gen

// DiskProperties_StatusARMGenerator returns a generator of DiskProperties_StatusARM instances for property testing.
// We first initialize diskProperties_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskProperties_StatusARMGenerator() gopter.Gen {
	if diskProperties_statusARMGenerator != nil {
		return diskProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskProperties_StatusARM(generators)
	diskProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskProperties_StatusARM(generators)
	AddRelatedPropertyGeneratorsForDiskProperties_StatusARM(generators)
	diskProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_StatusARM{}), generators)

	return diskProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeBytes"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.OneConstOf(
		DiskState_StatusActiveSAS,
		DiskState_StatusActiveUpload,
		DiskState_StatusAttached,
		DiskState_StatusReadyToUpload,
		DiskState_StatusReserved,
		DiskState_StatusUnattached))
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskProperties_HyperVGeneration_StatusV1, DiskProperties_HyperVGeneration_StatusV2))
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(NetworkAccessPolicy_StatusAllowAll, NetworkAccessPolicy_StatusAllowPrivate, NetworkAccessPolicy_StatusDenyAll))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskProperties_OsType_StatusLinux, DiskProperties_OsType_StatusWindows))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["TimeCreated"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskProperties_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["CreationData"] = CreationData_StatusARMGenerator()
	gens["Encryption"] = gen.PtrOf(Encryption_StatusARMGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollection_StatusARMGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlan_StatusARMGenerator())
	gens["ShareInfo"] = gen.SliceOf(ShareInfoElement_StatusARMGenerator())
}

func Test_DiskSku_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSku_StatusARM, DiskSku_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSku_StatusARM runs a test to see if a specific instance of DiskSku_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSku_StatusARM(subject DiskSku_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_StatusARM instances for property testing - lazily instantiated by DiskSku_StatusARMGenerator()
var diskSku_statusARMGenerator gopter.Gen

// DiskSku_StatusARMGenerator returns a generator of DiskSku_StatusARM instances for property testing.
func DiskSku_StatusARMGenerator() gopter.Gen {
	if diskSku_statusARMGenerator != nil {
		return diskSku_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSku_StatusARM(generators)
	diskSku_statusARMGenerator = gen.Struct(reflect.TypeOf(DiskSku_StatusARM{}), generators)

	return diskSku_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSku_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSku_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSku_Name_StatusPremium_LRS,
		DiskSku_Name_StatusStandardSSD_LRS,
		DiskSku_Name_StatusStandard_LRS,
		DiskSku_Name_StatusUltraSSD_LRS))
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_StatusARM, ExtendedLocation_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_StatusARM runs a test to see if a specific instance of ExtendedLocation_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_StatusARM(subject ExtendedLocation_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_StatusARM instances for property testing - lazily instantiated by
//ExtendedLocation_StatusARMGenerator()
var extendedLocation_statusARMGenerator gopter.Gen

// ExtendedLocation_StatusARMGenerator returns a generator of ExtendedLocation_StatusARM instances for property testing.
func ExtendedLocation_StatusARMGenerator() gopter.Gen {
	if extendedLocation_statusARMGenerator != nil {
		return extendedLocation_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM(generators)
	extendedLocation_statusARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_StatusARM{}), generators)

	return extendedLocation_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_StatusEdgeZone))
}

func Test_CreationData_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationData_StatusARM, CreationData_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationData_StatusARM runs a test to see if a specific instance of CreationData_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationData_StatusARM(subject CreationData_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_StatusARM instances for property testing - lazily instantiated by
//CreationData_StatusARMGenerator()
var creationData_statusARMGenerator gopter.Gen

// CreationData_StatusARMGenerator returns a generator of CreationData_StatusARM instances for property testing.
// We first initialize creationData_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationData_StatusARMGenerator() gopter.Gen {
	if creationData_statusARMGenerator != nil {
		return creationData_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_StatusARM(generators)
	creationData_statusARMGenerator = gen.Struct(reflect.TypeOf(CreationData_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_StatusARM(generators)
	AddRelatedPropertyGeneratorsForCreationData_StatusARM(generators)
	creationData_statusARMGenerator = gen.Struct(reflect.TypeOf(CreationData_StatusARM{}), generators)

	return creationData_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForCreationData_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationData_StatusARM(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.OneConstOf(
		CreationData_CreateOption_StatusAttach,
		CreationData_CreateOption_StatusCopy,
		CreationData_CreateOption_StatusEmpty,
		CreationData_CreateOption_StatusFromImage,
		CreationData_CreateOption_StatusImport,
		CreationData_CreateOption_StatusRestore,
		CreationData_CreateOption_StatusUpload)
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationData_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationData_StatusARM(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReference_StatusARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReference_StatusARMGenerator())
}

func Test_EncryptionSettingsCollection_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollection_StatusARM, EncryptionSettingsCollection_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollection_StatusARM runs a test to see if a specific instance of EncryptionSettingsCollection_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollection_StatusARM(subject EncryptionSettingsCollection_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_StatusARM instances for property testing - lazily instantiated by
//EncryptionSettingsCollection_StatusARMGenerator()
var encryptionSettingsCollection_statusARMGenerator gopter.Gen

// EncryptionSettingsCollection_StatusARMGenerator returns a generator of EncryptionSettingsCollection_StatusARM instances for property testing.
// We first initialize encryptionSettingsCollection_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollection_StatusARMGenerator() gopter.Gen {
	if encryptionSettingsCollection_statusARMGenerator != nil {
		return encryptionSettingsCollection_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_StatusARM(generators)
	encryptionSettingsCollection_statusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_StatusARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_StatusARM(generators)
	encryptionSettingsCollection_statusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_StatusARM{}), generators)

	return encryptionSettingsCollection_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_StatusARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.Bool()
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_StatusARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElement_StatusARMGenerator())
}

func Test_Encryption_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_StatusARM, Encryption_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_StatusARM runs a test to see if a specific instance of Encryption_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_StatusARM(subject Encryption_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_StatusARM instances for property testing - lazily instantiated by
//Encryption_StatusARMGenerator()
var encryption_statusARMGenerator gopter.Gen

// Encryption_StatusARMGenerator returns a generator of Encryption_StatusARM instances for property testing.
func Encryption_StatusARMGenerator() gopter.Gen {
	if encryption_statusARMGenerator != nil {
		return encryption_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_StatusARM(generators)
	encryption_statusARMGenerator = gen.Struct(reflect.TypeOf(Encryption_StatusARM{}), generators)

	return encryption_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_StatusARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(EncryptionType_StatusEncryptionAtRestWithCustomerKey, EncryptionType_StatusEncryptionAtRestWithPlatformAndCustomerKeys, EncryptionType_StatusEncryptionAtRestWithPlatformKey))
}

func Test_PurchasePlan_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlan_StatusARM, PurchasePlan_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlan_StatusARM runs a test to see if a specific instance of PurchasePlan_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlan_StatusARM(subject PurchasePlan_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_StatusARM instances for property testing - lazily instantiated by
//PurchasePlan_StatusARMGenerator()
var purchasePlan_statusARMGenerator gopter.Gen

// PurchasePlan_StatusARMGenerator returns a generator of PurchasePlan_StatusARM instances for property testing.
func PurchasePlan_StatusARMGenerator() gopter.Gen {
	if purchasePlan_statusARMGenerator != nil {
		return purchasePlan_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlan_StatusARM(generators)
	purchasePlan_statusARMGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_StatusARM{}), generators)

	return purchasePlan_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlan_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlan_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Product"] = gen.AlphaString()
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.AlphaString()
}

func Test_ShareInfoElement_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShareInfoElement_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShareInfoElement_StatusARM, ShareInfoElement_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShareInfoElement_StatusARM runs a test to see if a specific instance of ShareInfoElement_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForShareInfoElement_StatusARM(subject ShareInfoElement_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShareInfoElement_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShareInfoElement_StatusARM instances for property testing - lazily instantiated by
//ShareInfoElement_StatusARMGenerator()
var shareInfoElement_statusARMGenerator gopter.Gen

// ShareInfoElement_StatusARMGenerator returns a generator of ShareInfoElement_StatusARM instances for property testing.
func ShareInfoElement_StatusARMGenerator() gopter.Gen {
	if shareInfoElement_statusARMGenerator != nil {
		return shareInfoElement_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShareInfoElement_StatusARM(generators)
	shareInfoElement_statusARMGenerator = gen.Struct(reflect.TypeOf(ShareInfoElement_StatusARM{}), generators)

	return shareInfoElement_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForShareInfoElement_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShareInfoElement_StatusARM(gens map[string]gopter.Gen) {
	gens["VmUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsElement_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElement_StatusARM, EncryptionSettingsElement_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElement_StatusARM runs a test to see if a specific instance of EncryptionSettingsElement_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElement_StatusARM(subject EncryptionSettingsElement_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_StatusARM instances for property testing - lazily instantiated by
//EncryptionSettingsElement_StatusARMGenerator()
var encryptionSettingsElement_statusARMGenerator gopter.Gen

// EncryptionSettingsElement_StatusARMGenerator returns a generator of EncryptionSettingsElement_StatusARM instances for property testing.
func EncryptionSettingsElement_StatusARMGenerator() gopter.Gen {
	if encryptionSettingsElement_statusARMGenerator != nil {
		return encryptionSettingsElement_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElement_StatusARM(generators)
	encryptionSettingsElement_statusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_StatusARM{}), generators)

	return encryptionSettingsElement_statusARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElement_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElement_StatusARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReference_StatusARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReference_StatusARMGenerator())
}

func Test_ImageDiskReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReference_StatusARM, ImageDiskReference_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReference_StatusARM runs a test to see if a specific instance of ImageDiskReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReference_StatusARM(subject ImageDiskReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_StatusARM instances for property testing - lazily instantiated by
//ImageDiskReference_StatusARMGenerator()
var imageDiskReference_statusARMGenerator gopter.Gen

// ImageDiskReference_StatusARMGenerator returns a generator of ImageDiskReference_StatusARM instances for property testing.
func ImageDiskReference_StatusARMGenerator() gopter.Gen {
	if imageDiskReference_statusARMGenerator != nil {
		return imageDiskReference_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReference_StatusARM(generators)
	imageDiskReference_statusARMGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_StatusARM{}), generators)

	return imageDiskReference_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReference_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReference_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_KeyVaultAndKeyReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReference_StatusARM, KeyVaultAndKeyReference_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReference_StatusARM runs a test to see if a specific instance of KeyVaultAndKeyReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReference_StatusARM(subject KeyVaultAndKeyReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_StatusARM instances for property testing - lazily instantiated by
//KeyVaultAndKeyReference_StatusARMGenerator()
var keyVaultAndKeyReference_statusARMGenerator gopter.Gen

// KeyVaultAndKeyReference_StatusARMGenerator returns a generator of KeyVaultAndKeyReference_StatusARM instances for property testing.
// We first initialize keyVaultAndKeyReference_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReference_StatusARMGenerator() gopter.Gen {
	if keyVaultAndKeyReference_statusARMGenerator != nil {
		return keyVaultAndKeyReference_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_StatusARM(generators)
	keyVaultAndKeyReference_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_StatusARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_StatusARM(generators)
	keyVaultAndKeyReference_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_StatusARM{}), generators)

	return keyVaultAndKeyReference_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_StatusARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_StatusARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SourceVault_StatusARMGenerator()
}

func Test_KeyVaultAndSecretReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReference_StatusARM, KeyVaultAndSecretReference_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReference_StatusARM runs a test to see if a specific instance of KeyVaultAndSecretReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReference_StatusARM(subject KeyVaultAndSecretReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_StatusARM instances for property testing - lazily instantiated by
//KeyVaultAndSecretReference_StatusARMGenerator()
var keyVaultAndSecretReference_statusARMGenerator gopter.Gen

// KeyVaultAndSecretReference_StatusARMGenerator returns a generator of KeyVaultAndSecretReference_StatusARM instances for property testing.
// We first initialize keyVaultAndSecretReference_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReference_StatusARMGenerator() gopter.Gen {
	if keyVaultAndSecretReference_statusARMGenerator != nil {
		return keyVaultAndSecretReference_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_StatusARM(generators)
	keyVaultAndSecretReference_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_StatusARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_StatusARM(generators)
	keyVaultAndSecretReference_statusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_StatusARM{}), generators)

	return keyVaultAndSecretReference_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_StatusARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_StatusARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SourceVault_StatusARMGenerator()
}

func Test_SourceVault_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVault_StatusARM, SourceVault_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVault_StatusARM runs a test to see if a specific instance of SourceVault_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVault_StatusARM(subject SourceVault_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_StatusARM instances for property testing - lazily instantiated by
//SourceVault_StatusARMGenerator()
var sourceVault_statusARMGenerator gopter.Gen

// SourceVault_StatusARMGenerator returns a generator of SourceVault_StatusARM instances for property testing.
func SourceVault_StatusARMGenerator() gopter.Gen {
	if sourceVault_statusARMGenerator != nil {
		return sourceVault_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSourceVault_StatusARM(generators)
	sourceVault_statusARMGenerator = gen.Struct(reflect.TypeOf(SourceVault_StatusARM{}), generators)

	return sourceVault_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForSourceVault_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSourceVault_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
