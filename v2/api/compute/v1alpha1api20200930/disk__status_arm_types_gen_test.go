// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200930

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Disk_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskStatusARM, DiskStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskStatusARM runs a test to see if a specific instance of Disk_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskStatusARM(subject Disk_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk_StatusARM instances for property testing - lazily instantiated by DiskStatusARMGenerator()
var diskStatusARMGenerator gopter.Gen

// DiskStatusARMGenerator returns a generator of Disk_StatusARM instances for property testing.
// We first initialize diskStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskStatusARMGenerator() gopter.Gen {
	if diskStatusARMGenerator != nil {
		return diskStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskStatusARM(generators)
	diskStatusARMGenerator = gen.Struct(reflect.TypeOf(Disk_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskStatusARM(generators)
	AddRelatedPropertyGeneratorsForDiskStatusARM(generators)
	diskStatusARMGenerator = gen.Struct(reflect.TypeOf(Disk_StatusARM{}), generators)

	return diskStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedByExtended"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskStatusARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusARMGenerator())
	gens["Properties"] = gen.PtrOf(DiskPropertiesStatusARMGenerator())
	gens["Sku"] = gen.PtrOf(DiskSkuStatusARMGenerator())
}

func Test_DiskProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskPropertiesStatusARM, DiskPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskPropertiesStatusARM runs a test to see if a specific instance of DiskProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskPropertiesStatusARM(subject DiskProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskProperties_StatusARM instances for property testing - lazily instantiated by
// DiskPropertiesStatusARMGenerator()
var diskPropertiesStatusARMGenerator gopter.Gen

// DiskPropertiesStatusARMGenerator returns a generator of DiskProperties_StatusARM instances for property testing.
// We first initialize diskPropertiesStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskPropertiesStatusARMGenerator() gopter.Gen {
	if diskPropertiesStatusARMGenerator != nil {
		return diskPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskPropertiesStatusARM(generators)
	diskPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskPropertiesStatusARM(generators)
	AddRelatedPropertyGeneratorsForDiskPropertiesStatusARM(generators)
	diskPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_StatusARM{}), generators)

	return diskPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeBytes"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.OneConstOf(
		DiskState_StatusActiveSAS,
		DiskState_StatusActiveUpload,
		DiskState_StatusAttached,
		DiskState_StatusReadyToUpload,
		DiskState_StatusReserved,
		DiskState_StatusUnattached))
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskPropertiesStatusHyperVGenerationV1, DiskPropertiesStatusHyperVGenerationV2))
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(NetworkAccessPolicy_StatusAllowAll, NetworkAccessPolicy_StatusAllowPrivate, NetworkAccessPolicy_StatusDenyAll))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskPropertiesStatusOsTypeLinux, DiskPropertiesStatusOsTypeWindows))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["TimeCreated"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskPropertiesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationDataStatusARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionStatusARMGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollectionStatusARMGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlanStatusARMGenerator())
	gens["ShareInfo"] = gen.SliceOf(ShareInfoElementStatusARMGenerator())
}

func Test_DiskSku_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSkuStatusARM, DiskSkuStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSkuStatusARM runs a test to see if a specific instance of DiskSku_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSkuStatusARM(subject DiskSku_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_StatusARM instances for property testing - lazily instantiated by DiskSkuStatusARMGenerator()
var diskSkuStatusARMGenerator gopter.Gen

// DiskSkuStatusARMGenerator returns a generator of DiskSku_StatusARM instances for property testing.
func DiskSkuStatusARMGenerator() gopter.Gen {
	if diskSkuStatusARMGenerator != nil {
		return diskSkuStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSkuStatusARM(generators)
	diskSkuStatusARMGenerator = gen.Struct(reflect.TypeOf(DiskSku_StatusARM{}), generators)

	return diskSkuStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSkuStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSkuStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSkuStatusNamePremiumLRS,
		DiskSkuStatusNameStandardLRS,
		DiskSkuStatusNameStandardSSDLRS,
		DiskSkuStatusNameUltraSSDLRS))
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationStatusARM, ExtendedLocationStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationStatusARM runs a test to see if a specific instance of ExtendedLocation_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationStatusARM(subject ExtendedLocation_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_StatusARM instances for property testing - lazily instantiated by
// ExtendedLocationStatusARMGenerator()
var extendedLocationStatusARMGenerator gopter.Gen

// ExtendedLocationStatusARMGenerator returns a generator of ExtendedLocation_StatusARM instances for property testing.
func ExtendedLocationStatusARMGenerator() gopter.Gen {
	if extendedLocationStatusARMGenerator != nil {
		return extendedLocationStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationStatusARM(generators)
	extendedLocationStatusARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_StatusARM{}), generators)

	return extendedLocationStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_StatusEdgeZone))
}

func Test_CreationData_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationDataStatusARM, CreationDataStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationDataStatusARM runs a test to see if a specific instance of CreationData_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationDataStatusARM(subject CreationData_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_StatusARM instances for property testing - lazily instantiated by
// CreationDataStatusARMGenerator()
var creationDataStatusARMGenerator gopter.Gen

// CreationDataStatusARMGenerator returns a generator of CreationData_StatusARM instances for property testing.
// We first initialize creationDataStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationDataStatusARMGenerator() gopter.Gen {
	if creationDataStatusARMGenerator != nil {
		return creationDataStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationDataStatusARM(generators)
	creationDataStatusARMGenerator = gen.Struct(reflect.TypeOf(CreationData_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationDataStatusARM(generators)
	AddRelatedPropertyGeneratorsForCreationDataStatusARM(generators)
	creationDataStatusARMGenerator = gen.Struct(reflect.TypeOf(CreationData_StatusARM{}), generators)

	return creationDataStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForCreationDataStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationDataStatusARM(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(
		CreationDataStatusCreateOptionAttach,
		CreationDataStatusCreateOptionCopy,
		CreationDataStatusCreateOptionEmpty,
		CreationDataStatusCreateOptionFromImage,
		CreationDataStatusCreateOptionImport,
		CreationDataStatusCreateOptionRestore,
		CreationDataStatusCreateOptionUpload))
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationDataStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationDataStatusARM(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReferenceStatusARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReferenceStatusARMGenerator())
}

func Test_EncryptionSettingsCollection_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollectionStatusARM, EncryptionSettingsCollectionStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollectionStatusARM runs a test to see if a specific instance of EncryptionSettingsCollection_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollectionStatusARM(subject EncryptionSettingsCollection_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_StatusARM instances for property testing - lazily instantiated by
// EncryptionSettingsCollectionStatusARMGenerator()
var encryptionSettingsCollectionStatusARMGenerator gopter.Gen

// EncryptionSettingsCollectionStatusARMGenerator returns a generator of EncryptionSettingsCollection_StatusARM instances for property testing.
// We first initialize encryptionSettingsCollectionStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollectionStatusARMGenerator() gopter.Gen {
	if encryptionSettingsCollectionStatusARMGenerator != nil {
		return encryptionSettingsCollectionStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionStatusARM(generators)
	encryptionSettingsCollectionStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionStatusARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionStatusARM(generators)
	encryptionSettingsCollectionStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_StatusARM{}), generators)

	return encryptionSettingsCollectionStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionStatusARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionStatusARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElementStatusARMGenerator())
}

func Test_Encryption_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionStatusARM, EncryptionStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionStatusARM runs a test to see if a specific instance of Encryption_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionStatusARM(subject Encryption_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_StatusARM instances for property testing - lazily instantiated by
// EncryptionStatusARMGenerator()
var encryptionStatusARMGenerator gopter.Gen

// EncryptionStatusARMGenerator returns a generator of Encryption_StatusARM instances for property testing.
func EncryptionStatusARMGenerator() gopter.Gen {
	if encryptionStatusARMGenerator != nil {
		return encryptionStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionStatusARM(generators)
	encryptionStatusARMGenerator = gen.Struct(reflect.TypeOf(Encryption_StatusARM{}), generators)

	return encryptionStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionStatusARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(EncryptionType_StatusEncryptionAtRestWithCustomerKey, EncryptionType_StatusEncryptionAtRestWithPlatformAndCustomerKeys, EncryptionType_StatusEncryptionAtRestWithPlatformKey))
}

func Test_PurchasePlan_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlanStatusARM, PurchasePlanStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlanStatusARM runs a test to see if a specific instance of PurchasePlan_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlanStatusARM(subject PurchasePlan_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_StatusARM instances for property testing - lazily instantiated by
// PurchasePlanStatusARMGenerator()
var purchasePlanStatusARMGenerator gopter.Gen

// PurchasePlanStatusARMGenerator returns a generator of PurchasePlan_StatusARM instances for property testing.
func PurchasePlanStatusARMGenerator() gopter.Gen {
	if purchasePlanStatusARMGenerator != nil {
		return purchasePlanStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlanStatusARM(generators)
	purchasePlanStatusARMGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_StatusARM{}), generators)

	return purchasePlanStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlanStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlanStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_ShareInfoElement_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShareInfoElement_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShareInfoElementStatusARM, ShareInfoElementStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShareInfoElementStatusARM runs a test to see if a specific instance of ShareInfoElement_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForShareInfoElementStatusARM(subject ShareInfoElement_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShareInfoElement_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShareInfoElement_StatusARM instances for property testing - lazily instantiated by
// ShareInfoElementStatusARMGenerator()
var shareInfoElementStatusARMGenerator gopter.Gen

// ShareInfoElementStatusARMGenerator returns a generator of ShareInfoElement_StatusARM instances for property testing.
func ShareInfoElementStatusARMGenerator() gopter.Gen {
	if shareInfoElementStatusARMGenerator != nil {
		return shareInfoElementStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShareInfoElementStatusARM(generators)
	shareInfoElementStatusARMGenerator = gen.Struct(reflect.TypeOf(ShareInfoElement_StatusARM{}), generators)

	return shareInfoElementStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForShareInfoElementStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShareInfoElementStatusARM(gens map[string]gopter.Gen) {
	gens["VmUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsElement_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElementStatusARM, EncryptionSettingsElementStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElementStatusARM runs a test to see if a specific instance of EncryptionSettingsElement_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElementStatusARM(subject EncryptionSettingsElement_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_StatusARM instances for property testing - lazily instantiated by
// EncryptionSettingsElementStatusARMGenerator()
var encryptionSettingsElementStatusARMGenerator gopter.Gen

// EncryptionSettingsElementStatusARMGenerator returns a generator of EncryptionSettingsElement_StatusARM instances for property testing.
func EncryptionSettingsElementStatusARMGenerator() gopter.Gen {
	if encryptionSettingsElementStatusARMGenerator != nil {
		return encryptionSettingsElementStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElementStatusARM(generators)
	encryptionSettingsElementStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_StatusARM{}), generators)

	return encryptionSettingsElementStatusARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElementStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElementStatusARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReferenceStatusARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReferenceStatusARMGenerator())
}

func Test_ImageDiskReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReferenceStatusARM, ImageDiskReferenceStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReferenceStatusARM runs a test to see if a specific instance of ImageDiskReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReferenceStatusARM(subject ImageDiskReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_StatusARM instances for property testing - lazily instantiated by
// ImageDiskReferenceStatusARMGenerator()
var imageDiskReferenceStatusARMGenerator gopter.Gen

// ImageDiskReferenceStatusARMGenerator returns a generator of ImageDiskReference_StatusARM instances for property testing.
func ImageDiskReferenceStatusARMGenerator() gopter.Gen {
	if imageDiskReferenceStatusARMGenerator != nil {
		return imageDiskReferenceStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReferenceStatusARM(generators)
	imageDiskReferenceStatusARMGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_StatusARM{}), generators)

	return imageDiskReferenceStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReferenceStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReferenceStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_KeyVaultAndKeyReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReferenceStatusARM, KeyVaultAndKeyReferenceStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReferenceStatusARM runs a test to see if a specific instance of KeyVaultAndKeyReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReferenceStatusARM(subject KeyVaultAndKeyReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_StatusARM instances for property testing - lazily instantiated by
// KeyVaultAndKeyReferenceStatusARMGenerator()
var keyVaultAndKeyReferenceStatusARMGenerator gopter.Gen

// KeyVaultAndKeyReferenceStatusARMGenerator returns a generator of KeyVaultAndKeyReference_StatusARM instances for property testing.
// We first initialize keyVaultAndKeyReferenceStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReferenceStatusARMGenerator() gopter.Gen {
	if keyVaultAndKeyReferenceStatusARMGenerator != nil {
		return keyVaultAndKeyReferenceStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceStatusARM(generators)
	keyVaultAndKeyReferenceStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceStatusARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceStatusARM(generators)
	keyVaultAndKeyReferenceStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_StatusARM{}), generators)

	return keyVaultAndKeyReferenceStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceStatusARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceStatusARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVaultStatusARMGenerator())
}

func Test_KeyVaultAndSecretReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReferenceStatusARM, KeyVaultAndSecretReferenceStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReferenceStatusARM runs a test to see if a specific instance of KeyVaultAndSecretReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReferenceStatusARM(subject KeyVaultAndSecretReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_StatusARM instances for property testing - lazily instantiated by
// KeyVaultAndSecretReferenceStatusARMGenerator()
var keyVaultAndSecretReferenceStatusARMGenerator gopter.Gen

// KeyVaultAndSecretReferenceStatusARMGenerator returns a generator of KeyVaultAndSecretReference_StatusARM instances for property testing.
// We first initialize keyVaultAndSecretReferenceStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReferenceStatusARMGenerator() gopter.Gen {
	if keyVaultAndSecretReferenceStatusARMGenerator != nil {
		return keyVaultAndSecretReferenceStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceStatusARM(generators)
	keyVaultAndSecretReferenceStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceStatusARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceStatusARM(generators)
	keyVaultAndSecretReferenceStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_StatusARM{}), generators)

	return keyVaultAndSecretReferenceStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceStatusARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceStatusARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVaultStatusARMGenerator())
}

func Test_SourceVault_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVaultStatusARM, SourceVaultStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVaultStatusARM runs a test to see if a specific instance of SourceVault_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVaultStatusARM(subject SourceVault_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_StatusARM instances for property testing - lazily instantiated by
// SourceVaultStatusARMGenerator()
var sourceVaultStatusARMGenerator gopter.Gen

// SourceVaultStatusARMGenerator returns a generator of SourceVault_StatusARM instances for property testing.
func SourceVaultStatusARMGenerator() gopter.Gen {
	if sourceVaultStatusARMGenerator != nil {
		return sourceVaultStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSourceVaultStatusARM(generators)
	sourceVaultStatusARMGenerator = gen.Struct(reflect.TypeOf(SourceVault_StatusARM{}), generators)

	return sourceVaultStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForSourceVaultStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSourceVaultStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
