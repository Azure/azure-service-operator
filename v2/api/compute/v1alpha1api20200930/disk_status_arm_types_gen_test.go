// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200930

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Disk_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSTATUSARM, DiskSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSTATUSARM runs a test to see if a specific instance of Disk_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSTATUSARM(subject Disk_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk_STATUSARM instances for property testing - lazily instantiated by DiskSTATUSARMGenerator()
var diskSTATUSARMGenerator gopter.Gen

// DiskSTATUSARMGenerator returns a generator of Disk_STATUSARM instances for property testing.
// We first initialize diskSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskSTATUSARMGenerator() gopter.Gen {
	if diskSTATUSARMGenerator != nil {
		return diskSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSTATUSARM(generators)
	diskSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Disk_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForDiskSTATUSARM(generators)
	diskSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Disk_STATUSARM{}), generators)

	return diskSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedByExtended"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskSTATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(DiskPropertiesSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(DiskSkuSTATUSARMGenerator())
}

func Test_DiskProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskPropertiesSTATUSARM, DiskPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskPropertiesSTATUSARM runs a test to see if a specific instance of DiskProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskPropertiesSTATUSARM(subject DiskProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskProperties_STATUSARM instances for property testing - lazily instantiated by
// DiskPropertiesSTATUSARMGenerator()
var diskPropertiesSTATUSARMGenerator gopter.Gen

// DiskPropertiesSTATUSARMGenerator returns a generator of DiskProperties_STATUSARM instances for property testing.
// We first initialize diskPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskPropertiesSTATUSARMGenerator() gopter.Gen {
	if diskPropertiesSTATUSARMGenerator != nil {
		return diskPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskPropertiesSTATUSARM(generators)
	diskPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForDiskPropertiesSTATUSARM(generators)
	diskPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_STATUSARM{}), generators)

	return diskPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeBytes"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.OneConstOf(
		DiskState_STATUS_ActiveSAS,
		DiskState_STATUS_ActiveUpload,
		DiskState_STATUS_Attached,
		DiskState_STATUS_ReadyToUpload,
		DiskState_STATUS_Reserved,
		DiskState_STATUS_Unattached))
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskPropertiesSTATUSHyperVGeneration_V1, DiskPropertiesSTATUSHyperVGeneration_V2))
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(NetworkAccessPolicy_STATUS_AllowAll, NetworkAccessPolicy_STATUS_AllowPrivate, NetworkAccessPolicy_STATUS_DenyAll))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskPropertiesSTATUSOsType_Linux, DiskPropertiesSTATUSOsType_Windows))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["TimeCreated"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationDataSTATUSARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionSTATUSARMGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollectionSTATUSARMGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlanSTATUSARMGenerator())
	gens["ShareInfo"] = gen.SliceOf(ShareInfoElementSTATUSARMGenerator())
}

func Test_DiskSku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSkuSTATUSARM, DiskSkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSkuSTATUSARM runs a test to see if a specific instance of DiskSku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSkuSTATUSARM(subject DiskSku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_STATUSARM instances for property testing - lazily instantiated by DiskSkuSTATUSARMGenerator()
var diskSkuSTATUSARMGenerator gopter.Gen

// DiskSkuSTATUSARMGenerator returns a generator of DiskSku_STATUSARM instances for property testing.
func DiskSkuSTATUSARMGenerator() gopter.Gen {
	if diskSkuSTATUSARMGenerator != nil {
		return diskSkuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSkuSTATUSARM(generators)
	diskSkuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskSku_STATUSARM{}), generators)

	return diskSkuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSkuSTATUSName_PremiumLRS,
		DiskSkuSTATUSName_StandardLRS,
		DiskSkuSTATUSName_StandardSSDLRS,
		DiskSkuSTATUSName_UltraSSDLRS))
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSTATUSARM, ExtendedLocationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSTATUSARM runs a test to see if a specific instance of ExtendedLocation_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSTATUSARM(subject ExtendedLocation_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUSARM instances for property testing - lazily instantiated by
// ExtendedLocationSTATUSARMGenerator()
var extendedLocationSTATUSARMGenerator gopter.Gen

// ExtendedLocationSTATUSARMGenerator returns a generator of ExtendedLocation_STATUSARM instances for property testing.
func ExtendedLocationSTATUSARMGenerator() gopter.Gen {
	if extendedLocationSTATUSARMGenerator != nil {
		return extendedLocationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM(generators)
	extendedLocationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUSARM{}), generators)

	return extendedLocationSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_STATUS_EdgeZone))
}

func Test_CreationData_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationDataSTATUSARM, CreationDataSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationDataSTATUSARM runs a test to see if a specific instance of CreationData_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationDataSTATUSARM(subject CreationData_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_STATUSARM instances for property testing - lazily instantiated by
// CreationDataSTATUSARMGenerator()
var creationDataSTATUSARMGenerator gopter.Gen

// CreationDataSTATUSARMGenerator returns a generator of CreationData_STATUSARM instances for property testing.
// We first initialize creationDataSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationDataSTATUSARMGenerator() gopter.Gen {
	if creationDataSTATUSARMGenerator != nil {
		return creationDataSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationDataSTATUSARM(generators)
	creationDataSTATUSARMGenerator = gen.Struct(reflect.TypeOf(CreationData_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationDataSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForCreationDataSTATUSARM(generators)
	creationDataSTATUSARMGenerator = gen.Struct(reflect.TypeOf(CreationData_STATUSARM{}), generators)

	return creationDataSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCreationDataSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationDataSTATUSARM(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(
		CreationDataSTATUSCreateOption_Attach,
		CreationDataSTATUSCreateOption_Copy,
		CreationDataSTATUSCreateOption_Empty,
		CreationDataSTATUSCreateOption_FromImage,
		CreationDataSTATUSCreateOption_Import,
		CreationDataSTATUSCreateOption_Restore,
		CreationDataSTATUSCreateOption_Upload))
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationDataSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationDataSTATUSARM(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReferenceSTATUSARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReferenceSTATUSARMGenerator())
}

func Test_Encryption_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSTATUSARM, EncryptionSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSTATUSARM runs a test to see if a specific instance of Encryption_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSTATUSARM(subject Encryption_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_STATUSARM instances for property testing - lazily instantiated by
// EncryptionSTATUSARMGenerator()
var encryptionSTATUSARMGenerator gopter.Gen

// EncryptionSTATUSARMGenerator returns a generator of Encryption_STATUSARM instances for property testing.
func EncryptionSTATUSARMGenerator() gopter.Gen {
	if encryptionSTATUSARMGenerator != nil {
		return encryptionSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSTATUSARM(generators)
	encryptionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUSARM{}), generators)

	return encryptionSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSTATUSARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(EncryptionType_STATUS_EncryptionAtRestWithCustomerKey, EncryptionType_STATUS_EncryptionAtRestWithPlatformAndCustomerKeys, EncryptionType_STATUS_EncryptionAtRestWithPlatformKey))
}

func Test_EncryptionSettingsCollection_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollectionSTATUSARM, EncryptionSettingsCollectionSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollectionSTATUSARM runs a test to see if a specific instance of EncryptionSettingsCollection_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollectionSTATUSARM(subject EncryptionSettingsCollection_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_STATUSARM instances for property testing - lazily instantiated by
// EncryptionSettingsCollectionSTATUSARMGenerator()
var encryptionSettingsCollectionSTATUSARMGenerator gopter.Gen

// EncryptionSettingsCollectionSTATUSARMGenerator returns a generator of EncryptionSettingsCollection_STATUSARM instances for property testing.
// We first initialize encryptionSettingsCollectionSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollectionSTATUSARMGenerator() gopter.Gen {
	if encryptionSettingsCollectionSTATUSARMGenerator != nil {
		return encryptionSettingsCollectionSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionSTATUSARM(generators)
	encryptionSettingsCollectionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionSTATUSARM(generators)
	encryptionSettingsCollectionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_STATUSARM{}), generators)

	return encryptionSettingsCollectionSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionSTATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionSTATUSARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElementSTATUSARMGenerator())
}

func Test_PurchasePlan_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlanSTATUSARM, PurchasePlanSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlanSTATUSARM runs a test to see if a specific instance of PurchasePlan_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlanSTATUSARM(subject PurchasePlan_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_STATUSARM instances for property testing - lazily instantiated by
// PurchasePlanSTATUSARMGenerator()
var purchasePlanSTATUSARMGenerator gopter.Gen

// PurchasePlanSTATUSARMGenerator returns a generator of PurchasePlan_STATUSARM instances for property testing.
func PurchasePlanSTATUSARMGenerator() gopter.Gen {
	if purchasePlanSTATUSARMGenerator != nil {
		return purchasePlanSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlanSTATUSARM(generators)
	purchasePlanSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_STATUSARM{}), generators)

	return purchasePlanSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlanSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlanSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_ShareInfoElement_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShareInfoElement_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShareInfoElementSTATUSARM, ShareInfoElementSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShareInfoElementSTATUSARM runs a test to see if a specific instance of ShareInfoElement_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForShareInfoElementSTATUSARM(subject ShareInfoElement_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShareInfoElement_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShareInfoElement_STATUSARM instances for property testing - lazily instantiated by
// ShareInfoElementSTATUSARMGenerator()
var shareInfoElementSTATUSARMGenerator gopter.Gen

// ShareInfoElementSTATUSARMGenerator returns a generator of ShareInfoElement_STATUSARM instances for property testing.
func ShareInfoElementSTATUSARMGenerator() gopter.Gen {
	if shareInfoElementSTATUSARMGenerator != nil {
		return shareInfoElementSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShareInfoElementSTATUSARM(generators)
	shareInfoElementSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ShareInfoElement_STATUSARM{}), generators)

	return shareInfoElementSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForShareInfoElementSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShareInfoElementSTATUSARM(gens map[string]gopter.Gen) {
	gens["VmUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsElement_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElementSTATUSARM, EncryptionSettingsElementSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElementSTATUSARM runs a test to see if a specific instance of EncryptionSettingsElement_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElementSTATUSARM(subject EncryptionSettingsElement_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_STATUSARM instances for property testing - lazily instantiated by
// EncryptionSettingsElementSTATUSARMGenerator()
var encryptionSettingsElementSTATUSARMGenerator gopter.Gen

// EncryptionSettingsElementSTATUSARMGenerator returns a generator of EncryptionSettingsElement_STATUSARM instances for property testing.
func EncryptionSettingsElementSTATUSARMGenerator() gopter.Gen {
	if encryptionSettingsElementSTATUSARMGenerator != nil {
		return encryptionSettingsElementSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElementSTATUSARM(generators)
	encryptionSettingsElementSTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_STATUSARM{}), generators)

	return encryptionSettingsElementSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElementSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElementSTATUSARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReferenceSTATUSARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReferenceSTATUSARMGenerator())
}

func Test_ImageDiskReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReferenceSTATUSARM, ImageDiskReferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReferenceSTATUSARM runs a test to see if a specific instance of ImageDiskReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReferenceSTATUSARM(subject ImageDiskReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_STATUSARM instances for property testing - lazily instantiated by
// ImageDiskReferenceSTATUSARMGenerator()
var imageDiskReferenceSTATUSARMGenerator gopter.Gen

// ImageDiskReferenceSTATUSARMGenerator returns a generator of ImageDiskReference_STATUSARM instances for property testing.
func ImageDiskReferenceSTATUSARMGenerator() gopter.Gen {
	if imageDiskReferenceSTATUSARMGenerator != nil {
		return imageDiskReferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReferenceSTATUSARM(generators)
	imageDiskReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_STATUSARM{}), generators)

	return imageDiskReferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_KeyVaultAndKeyReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReferenceSTATUSARM, KeyVaultAndKeyReferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReferenceSTATUSARM runs a test to see if a specific instance of KeyVaultAndKeyReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReferenceSTATUSARM(subject KeyVaultAndKeyReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultAndKeyReferenceSTATUSARMGenerator()
var keyVaultAndKeyReferenceSTATUSARMGenerator gopter.Gen

// KeyVaultAndKeyReferenceSTATUSARMGenerator returns a generator of KeyVaultAndKeyReference_STATUSARM instances for property testing.
// We first initialize keyVaultAndKeyReferenceSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReferenceSTATUSARMGenerator() gopter.Gen {
	if keyVaultAndKeyReferenceSTATUSARMGenerator != nil {
		return keyVaultAndKeyReferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceSTATUSARM(generators)
	keyVaultAndKeyReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceSTATUSARM(generators)
	keyVaultAndKeyReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_STATUSARM{}), generators)

	return keyVaultAndKeyReferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVaultSTATUSARMGenerator())
}

func Test_KeyVaultAndSecretReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReferenceSTATUSARM, KeyVaultAndSecretReferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReferenceSTATUSARM runs a test to see if a specific instance of KeyVaultAndSecretReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReferenceSTATUSARM(subject KeyVaultAndSecretReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultAndSecretReferenceSTATUSARMGenerator()
var keyVaultAndSecretReferenceSTATUSARMGenerator gopter.Gen

// KeyVaultAndSecretReferenceSTATUSARMGenerator returns a generator of KeyVaultAndSecretReference_STATUSARM instances for property testing.
// We first initialize keyVaultAndSecretReferenceSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReferenceSTATUSARMGenerator() gopter.Gen {
	if keyVaultAndSecretReferenceSTATUSARMGenerator != nil {
		return keyVaultAndSecretReferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceSTATUSARM(generators)
	keyVaultAndSecretReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceSTATUSARM(generators)
	keyVaultAndSecretReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_STATUSARM{}), generators)

	return keyVaultAndSecretReferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVaultSTATUSARMGenerator())
}

func Test_SourceVault_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVaultSTATUSARM, SourceVaultSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVaultSTATUSARM runs a test to see if a specific instance of SourceVault_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVaultSTATUSARM(subject SourceVault_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_STATUSARM instances for property testing - lazily instantiated by
// SourceVaultSTATUSARMGenerator()
var sourceVaultSTATUSARMGenerator gopter.Gen

// SourceVaultSTATUSARMGenerator returns a generator of SourceVault_STATUSARM instances for property testing.
func SourceVaultSTATUSARMGenerator() gopter.Gen {
	if sourceVaultSTATUSARMGenerator != nil {
		return sourceVaultSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSourceVaultSTATUSARM(generators)
	sourceVaultSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SourceVault_STATUSARM{}), generators)

	return sourceVaultSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSourceVaultSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSourceVaultSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
