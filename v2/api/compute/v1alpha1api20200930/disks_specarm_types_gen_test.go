// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200930

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Disks_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disks_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisks_SPECARM, Disks_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisks_SPECARM runs a test to see if a specific instance of Disks_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDisks_SPECARM(subject Disks_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disks_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disks_SPECARM instances for property testing - lazily instantiated by Disks_SPECARMGenerator()
var disks_specarmGenerator gopter.Gen

// Disks_SPECARMGenerator returns a generator of Disks_SPECARM instances for property testing.
// We first initialize disks_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disks_SPECARMGenerator() gopter.Gen {
	if disks_specarmGenerator != nil {
		return disks_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisks_SPECARM(generators)
	disks_specarmGenerator = gen.Struct(reflect.TypeOf(Disks_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisks_SPECARM(generators)
	AddRelatedPropertyGeneratorsForDisks_SPECARM(generators)
	disks_specarmGenerator = gen.Struct(reflect.TypeOf(Disks_SPECARM{}), generators)

	return disks_specarmGenerator
}

// AddIndependentPropertyGeneratorsForDisks_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisks_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisks_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisks_SPECARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(DiskProperties_SpecARMGenerator())
	gens["Sku"] = gen.PtrOf(DiskSku_SpecARMGenerator())
}

func Test_DiskProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskProperties_SpecARM, DiskProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskProperties_SpecARM runs a test to see if a specific instance of DiskProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskProperties_SpecARM(subject DiskProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskProperties_SpecARM instances for property testing - lazily instantiated by
//DiskProperties_SpecARMGenerator()
var diskProperties_specARMGenerator gopter.Gen

// DiskProperties_SpecARMGenerator returns a generator of DiskProperties_SpecARM instances for property testing.
// We first initialize diskProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskProperties_SpecARMGenerator() gopter.Gen {
	if diskProperties_specARMGenerator != nil {
		return diskProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskProperties_SpecARM(generators)
	diskProperties_specARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForDiskProperties_SpecARM(generators)
	diskProperties_specARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_SpecARM{}), generators)

	return diskProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.OneConstOf(
		DiskState_SpecActiveSAS,
		DiskState_SpecActiveUpload,
		DiskState_SpecAttached,
		DiskState_SpecReadyToUpload,
		DiskState_SpecReserved,
		DiskState_SpecUnattached))
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskProperties_HyperVGeneration_SpecV1, DiskProperties_HyperVGeneration_SpecV2))
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(NetworkAccessPolicy_SpecAllowAll, NetworkAccessPolicy_SpecAllowPrivate, NetworkAccessPolicy_SpecDenyAll))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskProperties_OsType_SpecLinux, DiskProperties_OsType_SpecWindows))
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["CreationData"] = CreationData_SpecARMGenerator()
	gens["Encryption"] = gen.PtrOf(Encryption_SpecARMGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollection_SpecARMGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlan_SpecARMGenerator())
}

func Test_DiskSku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSku_SpecARM, DiskSku_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSku_SpecARM runs a test to see if a specific instance of DiskSku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSku_SpecARM(subject DiskSku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_SpecARM instances for property testing - lazily instantiated by DiskSku_SpecARMGenerator()
var diskSku_specARMGenerator gopter.Gen

// DiskSku_SpecARMGenerator returns a generator of DiskSku_SpecARM instances for property testing.
func DiskSku_SpecARMGenerator() gopter.Gen {
	if diskSku_specARMGenerator != nil {
		return diskSku_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSku_SpecARM(generators)
	diskSku_specARMGenerator = gen.Struct(reflect.TypeOf(DiskSku_SpecARM{}), generators)

	return diskSku_specARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSku_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSku_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSku_Name_SpecPremium_LRS,
		DiskSku_Name_SpecStandardSSD_LRS,
		DiskSku_Name_SpecStandard_LRS,
		DiskSku_Name_SpecUltraSSD_LRS))
}

func Test_ExtendedLocation_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_SpecARM, ExtendedLocation_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_SpecARM runs a test to see if a specific instance of ExtendedLocation_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_SpecARM(subject ExtendedLocation_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_SpecARM instances for property testing - lazily instantiated by
//ExtendedLocation_SpecARMGenerator()
var extendedLocation_specARMGenerator gopter.Gen

// ExtendedLocation_SpecARMGenerator returns a generator of ExtendedLocation_SpecARM instances for property testing.
func ExtendedLocation_SpecARMGenerator() gopter.Gen {
	if extendedLocation_specARMGenerator != nil {
		return extendedLocation_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM(generators)
	extendedLocation_specARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_SpecARM{}), generators)

	return extendedLocation_specARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_SpecEdgeZone))
}

func Test_CreationData_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationData_SpecARM, CreationData_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationData_SpecARM runs a test to see if a specific instance of CreationData_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationData_SpecARM(subject CreationData_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_SpecARM instances for property testing - lazily instantiated by
//CreationData_SpecARMGenerator()
var creationData_specARMGenerator gopter.Gen

// CreationData_SpecARMGenerator returns a generator of CreationData_SpecARM instances for property testing.
// We first initialize creationData_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationData_SpecARMGenerator() gopter.Gen {
	if creationData_specARMGenerator != nil {
		return creationData_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_SpecARM(generators)
	creationData_specARMGenerator = gen.Struct(reflect.TypeOf(CreationData_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_SpecARM(generators)
	AddRelatedPropertyGeneratorsForCreationData_SpecARM(generators)
	creationData_specARMGenerator = gen.Struct(reflect.TypeOf(CreationData_SpecARM{}), generators)

	return creationData_specARMGenerator
}

// AddIndependentPropertyGeneratorsForCreationData_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationData_SpecARM(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.OneConstOf(
		CreationData_CreateOption_SpecAttach,
		CreationData_CreateOption_SpecCopy,
		CreationData_CreateOption_SpecEmpty,
		CreationData_CreateOption_SpecFromImage,
		CreationData_CreateOption_SpecImport,
		CreationData_CreateOption_SpecRestore,
		CreationData_CreateOption_SpecUpload)
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationData_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationData_SpecARM(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReference_SpecARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReference_SpecARMGenerator())
}

func Test_EncryptionSettingsCollection_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollection_SpecARM, EncryptionSettingsCollection_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollection_SpecARM runs a test to see if a specific instance of EncryptionSettingsCollection_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollection_SpecARM(subject EncryptionSettingsCollection_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_SpecARM instances for property testing - lazily instantiated by
//EncryptionSettingsCollection_SpecARMGenerator()
var encryptionSettingsCollection_specARMGenerator gopter.Gen

// EncryptionSettingsCollection_SpecARMGenerator returns a generator of EncryptionSettingsCollection_SpecARM instances for property testing.
// We first initialize encryptionSettingsCollection_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollection_SpecARMGenerator() gopter.Gen {
	if encryptionSettingsCollection_specARMGenerator != nil {
		return encryptionSettingsCollection_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_SpecARM(generators)
	encryptionSettingsCollection_specARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_SpecARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_SpecARM(generators)
	encryptionSettingsCollection_specARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_SpecARM{}), generators)

	return encryptionSettingsCollection_specARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_SpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.Bool()
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_SpecARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElement_SpecARMGenerator())
}

func Test_Encryption_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_SpecARM, Encryption_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_SpecARM runs a test to see if a specific instance of Encryption_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_SpecARM(subject Encryption_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_SpecARM instances for property testing - lazily instantiated by Encryption_SpecARMGenerator()
var encryption_specARMGenerator gopter.Gen

// Encryption_SpecARMGenerator returns a generator of Encryption_SpecARM instances for property testing.
func Encryption_SpecARMGenerator() gopter.Gen {
	if encryption_specARMGenerator != nil {
		return encryption_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_SpecARM(generators)
	encryption_specARMGenerator = gen.Struct(reflect.TypeOf(Encryption_SpecARM{}), generators)

	return encryption_specARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_SpecARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(EncryptionType_SpecEncryptionAtRestWithCustomerKey, EncryptionType_SpecEncryptionAtRestWithPlatformAndCustomerKeys, EncryptionType_SpecEncryptionAtRestWithPlatformKey))
}

func Test_PurchasePlan_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlan_SpecARM, PurchasePlan_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlan_SpecARM runs a test to see if a specific instance of PurchasePlan_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlan_SpecARM(subject PurchasePlan_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_SpecARM instances for property testing - lazily instantiated by
//PurchasePlan_SpecARMGenerator()
var purchasePlan_specARMGenerator gopter.Gen

// PurchasePlan_SpecARMGenerator returns a generator of PurchasePlan_SpecARM instances for property testing.
func PurchasePlan_SpecARMGenerator() gopter.Gen {
	if purchasePlan_specARMGenerator != nil {
		return purchasePlan_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlan_SpecARM(generators)
	purchasePlan_specARMGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_SpecARM{}), generators)

	return purchasePlan_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlan_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlan_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Product"] = gen.AlphaString()
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.AlphaString()
}

func Test_EncryptionSettingsElement_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElement_SpecARM, EncryptionSettingsElement_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElement_SpecARM runs a test to see if a specific instance of EncryptionSettingsElement_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElement_SpecARM(subject EncryptionSettingsElement_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_SpecARM instances for property testing - lazily instantiated by
//EncryptionSettingsElement_SpecARMGenerator()
var encryptionSettingsElement_specARMGenerator gopter.Gen

// EncryptionSettingsElement_SpecARMGenerator returns a generator of EncryptionSettingsElement_SpecARM instances for property testing.
func EncryptionSettingsElement_SpecARMGenerator() gopter.Gen {
	if encryptionSettingsElement_specARMGenerator != nil {
		return encryptionSettingsElement_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElement_SpecARM(generators)
	encryptionSettingsElement_specARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_SpecARM{}), generators)

	return encryptionSettingsElement_specARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElement_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElement_SpecARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReference_SpecARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReference_SpecARMGenerator())
}

func Test_ImageDiskReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReference_SpecARM, ImageDiskReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReference_SpecARM runs a test to see if a specific instance of ImageDiskReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReference_SpecARM(subject ImageDiskReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_SpecARM instances for property testing - lazily instantiated by
//ImageDiskReference_SpecARMGenerator()
var imageDiskReference_specARMGenerator gopter.Gen

// ImageDiskReference_SpecARMGenerator returns a generator of ImageDiskReference_SpecARM instances for property testing.
func ImageDiskReference_SpecARMGenerator() gopter.Gen {
	if imageDiskReference_specARMGenerator != nil {
		return imageDiskReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReference_SpecARM(generators)
	imageDiskReference_specARMGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_SpecARM{}), generators)

	return imageDiskReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReference_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_KeyVaultAndKeyReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReference_SpecARM, KeyVaultAndKeyReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReference_SpecARM runs a test to see if a specific instance of KeyVaultAndKeyReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReference_SpecARM(subject KeyVaultAndKeyReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_SpecARM instances for property testing - lazily instantiated by
//KeyVaultAndKeyReference_SpecARMGenerator()
var keyVaultAndKeyReference_specARMGenerator gopter.Gen

// KeyVaultAndKeyReference_SpecARMGenerator returns a generator of KeyVaultAndKeyReference_SpecARM instances for property testing.
// We first initialize keyVaultAndKeyReference_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReference_SpecARMGenerator() gopter.Gen {
	if keyVaultAndKeyReference_specARMGenerator != nil {
		return keyVaultAndKeyReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_SpecARM(generators)
	keyVaultAndKeyReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_SpecARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_SpecARM(generators)
	keyVaultAndKeyReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_SpecARM{}), generators)

	return keyVaultAndKeyReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_SpecARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SourceVault_SpecARMGenerator()
}

func Test_KeyVaultAndSecretReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReference_SpecARM, KeyVaultAndSecretReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReference_SpecARM runs a test to see if a specific instance of KeyVaultAndSecretReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReference_SpecARM(subject KeyVaultAndSecretReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_SpecARM instances for property testing - lazily instantiated by
//KeyVaultAndSecretReference_SpecARMGenerator()
var keyVaultAndSecretReference_specARMGenerator gopter.Gen

// KeyVaultAndSecretReference_SpecARMGenerator returns a generator of KeyVaultAndSecretReference_SpecARM instances for property testing.
// We first initialize keyVaultAndSecretReference_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReference_SpecARMGenerator() gopter.Gen {
	if keyVaultAndSecretReference_specARMGenerator != nil {
		return keyVaultAndSecretReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_SpecARM(generators)
	keyVaultAndSecretReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_SpecARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_SpecARM(generators)
	keyVaultAndSecretReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_SpecARM{}), generators)

	return keyVaultAndSecretReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_SpecARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_SpecARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = SourceVault_SpecARMGenerator()
}

func Test_SourceVault_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVault_SpecARM, SourceVault_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVault_SpecARM runs a test to see if a specific instance of SourceVault_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVault_SpecARM(subject SourceVault_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_SpecARM instances for property testing - lazily instantiated by
//SourceVault_SpecARMGenerator()
var sourceVault_specARMGenerator gopter.Gen

// SourceVault_SpecARMGenerator returns a generator of SourceVault_SpecARM instances for property testing.
func SourceVault_SpecARMGenerator() gopter.Gen {
	if sourceVault_specARMGenerator != nil {
		return sourceVault_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSourceVault_SpecARM(generators)
	sourceVault_specARMGenerator = gen.Struct(reflect.TypeOf(SourceVault_SpecARM{}), generators)

	return sourceVault_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSourceVault_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSourceVault_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
