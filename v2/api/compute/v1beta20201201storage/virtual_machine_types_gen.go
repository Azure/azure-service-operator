// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201201storage

import (
	"fmt"
	v20210701s "github.com/Azure/azure-service-operator/v2/api/compute/v1beta20210701storage"
	v20220301s "github.com/Azure/azure-service-operator/v2/api/compute/v1beta20220301storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1beta20201201.VirtualMachine
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/resourceDefinitions/virtualMachines
type VirtualMachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachines_Spec  `json:"spec,omitempty"`
	Status            VirtualMachine_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachine{}

// GetConditions returns the conditions of the resource
func (machine *VirtualMachine) GetConditions() conditions.Conditions {
	return machine.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (machine *VirtualMachine) SetConditions(conditions conditions.Conditions) {
	machine.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachine{}

// ConvertFrom populates our VirtualMachine from the provided hub VirtualMachine
func (machine *VirtualMachine) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20220301s.VirtualMachine)
	if !ok {
		return fmt.Errorf("expected compute/v1beta20220301storage/VirtualMachine but received %T instead", hub)
	}

	return machine.AssignPropertiesFromVirtualMachine(source)
}

// ConvertTo populates the provided hub VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20220301s.VirtualMachine)
	if !ok {
		return fmt.Errorf("expected compute/v1beta20220301storage/VirtualMachine but received %T instead", hub)
	}

	return machine.AssignPropertiesToVirtualMachine(destination)
}

var _ genruntime.KubernetesResource = &VirtualMachine{}

// AzureName returns the Azure name of the resource
func (machine *VirtualMachine) AzureName() string {
	return machine.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-12-01"
func (machine VirtualMachine) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (machine *VirtualMachine) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (machine *VirtualMachine) GetSpec() genruntime.ConvertibleSpec {
	return &machine.Spec
}

// GetStatus returns the status of this resource
func (machine *VirtualMachine) GetStatus() genruntime.ConvertibleStatus {
	return &machine.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachines"
func (machine *VirtualMachine) GetType() string {
	return "Microsoft.Compute/virtualMachines"
}

// NewEmptyStatus returns a new empty (blank) status
func (machine *VirtualMachine) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachine_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (machine *VirtualMachine) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(machine.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  machine.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (machine *VirtualMachine) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachine_STATUS); ok {
		machine.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachine_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	machine.Status = st
	return nil
}

// AssignPropertiesFromVirtualMachine populates our VirtualMachine from the provided source VirtualMachine
func (machine *VirtualMachine) AssignPropertiesFromVirtualMachine(source *v20220301s.VirtualMachine) error {

	// ObjectMeta
	machine.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachines_Spec
	err := spec.AssignPropertiesFromVirtualMachinesSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinesSpec() to populate field Spec")
	}
	machine.Spec = spec

	// Status
	var status VirtualMachine_STATUS
	err = status.AssignPropertiesFromVirtualMachineSTATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineSTATUS() to populate field Status")
	}
	machine.Status = status

	// No error
	return nil
}

// AssignPropertiesToVirtualMachine populates the provided destination VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) AssignPropertiesToVirtualMachine(destination *v20220301s.VirtualMachine) error {

	// ObjectMeta
	destination.ObjectMeta = *machine.ObjectMeta.DeepCopy()

	// Spec
	var spec v20220301s.VirtualMachines_Spec
	err := machine.Spec.AssignPropertiesToVirtualMachinesSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinesSpec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20220301s.VirtualMachine_STATUS
	err = machine.Status.AssignPropertiesToVirtualMachineSTATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineSTATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (machine *VirtualMachine) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: machine.Spec.OriginalVersion,
		Kind:    "VirtualMachine",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1beta20201201.VirtualMachine
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/resourceDefinitions/virtualMachines
type VirtualMachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachine `json:"items"`
}

// Storage version of v1beta20201201.APIVersion
// +kubebuilder:validation:Enum={"2020-12-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2020-12-01")

// Storage version of v1beta20201201.VirtualMachine_STATUS
type VirtualMachine_STATUS struct {
	AdditionalCapabilities  *AdditionalCapabilities_STATUS     `json:"additionalCapabilities,omitempty"`
	AvailabilitySet         *SubResource_STATUS                `json:"availabilitySet,omitempty"`
	BillingProfile          *BillingProfile_STATUS             `json:"billingProfile,omitempty"`
	Conditions              []conditions.Condition             `json:"conditions,omitempty"`
	DiagnosticsProfile      *DiagnosticsProfile_STATUS         `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy          *string                            `json:"evictionPolicy,omitempty"`
	ExtendedLocation        *ExtendedLocation_STATUS           `json:"extendedLocation,omitempty"`
	ExtensionsTimeBudget    *string                            `json:"extensionsTimeBudget,omitempty"`
	HardwareProfile         *HardwareProfile_STATUS            `json:"hardwareProfile,omitempty"`
	Host                    *SubResource_STATUS                `json:"host,omitempty"`
	HostGroup               *SubResource_STATUS                `json:"hostGroup,omitempty"`
	Id                      *string                            `json:"id,omitempty"`
	Identity                *VirtualMachineIdentity_STATUS     `json:"identity,omitempty"`
	InstanceView            *VirtualMachineInstanceView_STATUS `json:"instanceView,omitempty"`
	LicenseType             *string                            `json:"licenseType,omitempty"`
	Location                *string                            `json:"location,omitempty"`
	Name                    *string                            `json:"name,omitempty"`
	NetworkProfile          *NetworkProfile_STATUS             `json:"networkProfile,omitempty"`
	OsProfile               *OSProfile_STATUS                  `json:"osProfile,omitempty"`
	Plan                    *Plan_STATUS                       `json:"plan,omitempty"`
	PlatformFaultDomain     *int                               `json:"platformFaultDomain,omitempty"`
	Priority                *string                            `json:"priority,omitempty"`
	PropertyBag             genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProvisioningState       *string                            `json:"provisioningState,omitempty"`
	ProximityPlacementGroup *SubResource_STATUS                `json:"proximityPlacementGroup,omitempty"`
	Resources               []VirtualMachineExtension_STATUS   `json:"resources,omitempty"`
	SecurityProfile         *SecurityProfile_STATUS            `json:"securityProfile,omitempty"`
	StorageProfile          *StorageProfile_STATUS             `json:"storageProfile,omitempty"`
	Tags                    map[string]string                  `json:"tags,omitempty"`
	Type                    *string                            `json:"type,omitempty"`
	VirtualMachineScaleSet  *SubResource_STATUS                `json:"virtualMachineScaleSet,omitempty"`
	VmId                    *string                            `json:"vmId,omitempty"`
	Zones                   []string                           `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachine_STATUS{}

// ConvertStatusFrom populates our VirtualMachine_STATUS from the provided source
func (machine *VirtualMachine_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20220301s.VirtualMachine_STATUS)
	if ok {
		// Populate our instance from source
		return machine.AssignPropertiesFromVirtualMachineSTATUS(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.VirtualMachine_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = machine.AssignPropertiesFromVirtualMachineSTATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20220301s.VirtualMachine_STATUS)
	if ok {
		// Populate destination from our instance
		return machine.AssignPropertiesToVirtualMachineSTATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.VirtualMachine_STATUS{}
	err := machine.AssignPropertiesToVirtualMachineSTATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualMachineSTATUS populates our VirtualMachine_STATUS from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignPropertiesFromVirtualMachineSTATUS(source *v20220301s.VirtualMachine_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_STATUS
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilitiesSTATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilitiesSTATUS() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		propertyBag.Add("ApplicationProfile", *source.ApplicationProfile)
	} else {
		propertyBag.Remove("ApplicationProfile")
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from AvailabilitySet")
		}
		var availabilitySet SubResource_STATUS
		err = availabilitySet.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field AvailabilitySet from SubResource_STATUSStash")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_STATUS
		err := billingProfile.AssignPropertiesFromBillingProfileSTATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfileSTATUS() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		propertyBag.Add("CapacityReservation", *source.CapacityReservation)
	} else {
		propertyBag.Remove("CapacityReservation")
	}

	// Conditions
	machine.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_STATUS
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfileSTATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfileSTATUS() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	machine.EvictionPolicy = genruntime.ClonePointerToString(source.EvictionPolicy)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20210701s.ExtendedLocation_STATUS
		err := extendedLocationSTATUSStash.AssignPropertiesFromExtendedLocationSTATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationSTATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation_STATUS
		err = extendedLocation.AssignPropertiesFromExtendedLocationSTATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationSTATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile_STATUS
		err := hardwareProfile.AssignPropertiesFromHardwareProfileSTATUS(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHardwareProfileSTATUS() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from Host")
		}
		var host SubResource_STATUS
		err = host.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field Host from SubResource_STATUSStash")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from HostGroup")
		}
		var hostGroup SubResource_STATUS
		err = hostGroup.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field HostGroup from SubResource_STATUSStash")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Id
	machine.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity_STATUS
		err := identity.AssignPropertiesFromVirtualMachineIdentitySTATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineIdentitySTATUS() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineInstanceView_STATUS
		err := instanceView.AssignPropertiesFromVirtualMachineInstanceViewSTATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineInstanceViewSTATUS() to populate field InstanceView")
		}
		machine.InstanceView = &instanceView
	} else {
		machine.InstanceView = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	machine.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile_STATUS
		err := networkProfile.AssignPropertiesFromNetworkProfileSTATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkProfileSTATUS() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile_STATUS
		err := osProfile.AssignPropertiesFromOSProfileSTATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOSProfileSTATUS() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
		err := plan.AssignPropertiesFromPlanSTATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlanSTATUS() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	machine.Priority = genruntime.ClonePointerToString(source.Priority)

	// ProvisioningState
	machine.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup SubResource_STATUS
		err = proximityPlacementGroup.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field ProximityPlacementGroup from SubResource_STATUSStash")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// Resources
	if source.Resources != nil {
		resourceList := make([]VirtualMachineExtension_STATUS, len(source.Resources))
		for resourceIndex, resourceItem := range source.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource VirtualMachineExtension_STATUS
			err := resource.AssignPropertiesFromVirtualMachineExtensionSTATUS(&resourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineExtensionSTATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		machine.Resources = resourceList
	} else {
		machine.Resources = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		propertyBag.Add("ScheduledEventsProfile", *source.ScheduledEventsProfile)
	} else {
		propertyBag.Remove("ScheduledEventsProfile")
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_STATUS
		err := securityProfile.AssignPropertiesFromSecurityProfileSTATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfileSTATUS() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile_STATUS
		err := storageProfile.AssignPropertiesFromStorageProfileSTATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromStorageProfileSTATUS() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TimeCreated
	if source.TimeCreated != nil {
		propertyBag.Add("TimeCreated", *source.TimeCreated)
	} else {
		propertyBag.Remove("TimeCreated")
	}

	// Type
	machine.Type = genruntime.ClonePointerToString(source.Type)

	// UserData
	if source.UserData != nil {
		propertyBag.Add("UserData", *source.UserData)
	} else {
		propertyBag.Remove("UserData")
	}

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from VirtualMachineScaleSet")
		}
		var virtualMachineScaleSet SubResource_STATUS
		err = virtualMachineScaleSet.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field VirtualMachineScaleSet from SubResource_STATUSStash")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// VmId
	machine.VmId = genruntime.ClonePointerToString(source.VmId)

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		machine.PropertyBag = propertyBag
	} else {
		machine.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineSTATUS populates the provided destination VirtualMachine_STATUS from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignPropertiesToVirtualMachineSTATUS(destination *v20220301s.VirtualMachine_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(machine.PropertyBag)

	// AdditionalCapabilities
	if machine.AdditionalCapabilities != nil {
		var additionalCapability v20220301s.AdditionalCapabilities_STATUS
		err := machine.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilitiesSTATUS(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilitiesSTATUS() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if propertyBag.Contains("ApplicationProfile") {
		var applicationProfile v20220301s.ApplicationProfile_STATUS
		err := propertyBag.Pull("ApplicationProfile", &applicationProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ApplicationProfile' from propertyBag")
		}

		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// AvailabilitySet
	if machine.AvailabilitySet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.AvailabilitySet.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from AvailabilitySet")
		}
		var availabilitySet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field AvailabilitySet from SubResource_STATUSStash")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// BillingProfile
	if machine.BillingProfile != nil {
		var billingProfile v20220301s.BillingProfile_STATUS
		err := machine.BillingProfile.AssignPropertiesToBillingProfileSTATUS(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfileSTATUS() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if propertyBag.Contains("CapacityReservation") {
		var capacityReservation v20220301s.CapacityReservationProfile_STATUS
		err := propertyBag.Pull("CapacityReservation", &capacityReservation)
		if err != nil {
			return errors.Wrap(err, "pulling 'CapacityReservation' from propertyBag")
		}

		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(machine.Conditions)

	// DiagnosticsProfile
	if machine.DiagnosticsProfile != nil {
		var diagnosticsProfile v20220301s.DiagnosticsProfile_STATUS
		err := machine.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfileSTATUS(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfileSTATUS() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	destination.EvictionPolicy = genruntime.ClonePointerToString(machine.EvictionPolicy)

	// ExtendedLocation
	if machine.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20210701s.ExtendedLocation_STATUS
		err := machine.ExtendedLocation.AssignPropertiesToExtendedLocationSTATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationSTATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation v20220301s.ExtendedLocation_STATUS
		err = extendedLocationSTATUSStash.AssignPropertiesToExtendedLocationSTATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationSTATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machine.ExtensionsTimeBudget)

	// HardwareProfile
	if machine.HardwareProfile != nil {
		var hardwareProfile v20220301s.HardwareProfile_STATUS
		err := machine.HardwareProfile.AssignPropertiesToHardwareProfileSTATUS(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHardwareProfileSTATUS() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machine.Host != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.Host.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from Host")
		}
		var host v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field Host from SubResource_STATUSStash")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machine.HostGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.HostGroup.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from HostGroup")
		}
		var hostGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field HostGroup from SubResource_STATUSStash")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(machine.Id)

	// Identity
	if machine.Identity != nil {
		var identity v20220301s.VirtualMachineIdentity_STATUS
		err := machine.Identity.AssignPropertiesToVirtualMachineIdentitySTATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineIdentitySTATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InstanceView
	if machine.InstanceView != nil {
		var instanceView v20220301s.VirtualMachineInstanceView_STATUS
		err := machine.InstanceView.AssignPropertiesToVirtualMachineInstanceViewSTATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineInstanceViewSTATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machine.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machine.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(machine.Name)

	// NetworkProfile
	if machine.NetworkProfile != nil {
		var networkProfile v20220301s.NetworkProfile_STATUS
		err := machine.NetworkProfile.AssignPropertiesToNetworkProfileSTATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkProfileSTATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if machine.OsProfile != nil {
		var osProfile v20220301s.OSProfile_STATUS
		err := machine.OsProfile.AssignPropertiesToOSProfileSTATUS(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOSProfileSTATUS() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Plan
	if machine.Plan != nil {
		var plan v20220301s.Plan_STATUS
		err := machine.Plan.AssignPropertiesToPlanSTATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlanSTATUS() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machine.PlatformFaultDomain)

	// Priority
	destination.Priority = genruntime.ClonePointerToString(machine.Priority)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(machine.ProvisioningState)

	// ProximityPlacementGroup
	if machine.ProximityPlacementGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.ProximityPlacementGroup.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field ProximityPlacementGroup from SubResource_STATUSStash")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// Resources
	if machine.Resources != nil {
		resourceList := make([]v20220301s.VirtualMachineExtension_STATUS, len(machine.Resources))
		for resourceIndex, resourceItem := range machine.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource v20220301s.VirtualMachineExtension_STATUS
			err := resourceItem.AssignPropertiesToVirtualMachineExtensionSTATUS(&resource)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineExtensionSTATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		destination.Resources = resourceList
	} else {
		destination.Resources = nil
	}

	// ScheduledEventsProfile
	if propertyBag.Contains("ScheduledEventsProfile") {
		var scheduledEventsProfile v20220301s.ScheduledEventsProfile_STATUS
		err := propertyBag.Pull("ScheduledEventsProfile", &scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ScheduledEventsProfile' from propertyBag")
		}

		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if machine.SecurityProfile != nil {
		var securityProfile v20220301s.SecurityProfile_STATUS
		err := machine.SecurityProfile.AssignPropertiesToSecurityProfileSTATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfileSTATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machine.StorageProfile != nil {
		var storageProfile v20220301s.StorageProfile_STATUS
		err := machine.StorageProfile.AssignPropertiesToStorageProfileSTATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToStorageProfileSTATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machine.Tags)

	// TimeCreated
	if propertyBag.Contains("TimeCreated") {
		var timeCreated string
		err := propertyBag.Pull("TimeCreated", &timeCreated)
		if err != nil {
			return errors.Wrap(err, "pulling 'TimeCreated' from propertyBag")
		}

		destination.TimeCreated = &timeCreated
	} else {
		destination.TimeCreated = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(machine.Type)

	// UserData
	if propertyBag.Contains("UserData") {
		var userDatum string
		err := propertyBag.Pull("UserData", &userDatum)
		if err != nil {
			return errors.Wrap(err, "pulling 'UserData' from propertyBag")
		}

		destination.UserData = &userDatum
	} else {
		destination.UserData = nil
	}

	// VirtualMachineScaleSet
	if machine.VirtualMachineScaleSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.VirtualMachineScaleSet.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from VirtualMachineScaleSet")
		}
		var virtualMachineScaleSet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field VirtualMachineScaleSet from SubResource_STATUSStash")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// VmId
	destination.VmId = genruntime.ClonePointerToString(machine.VmId)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machine.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachines_Spec
type VirtualMachines_Spec struct {
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`
	AvailabilitySet        *SubResource            `json:"availabilitySet,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName            string                                          `json:"azureName,omitempty"`
	BillingProfile       *BillingProfile                                 `json:"billingProfile,omitempty"`
	DiagnosticsProfile   *DiagnosticsProfile                             `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy       *string                                         `json:"evictionPolicy,omitempty"`
	ExtendedLocation     *ExtendedLocation                               `json:"extendedLocation,omitempty"`
	ExtensionsTimeBudget *string                                         `json:"extensionsTimeBudget,omitempty"`
	HardwareProfile      *HardwareProfile                                `json:"hardwareProfile,omitempty"`
	Host                 *SubResource                                    `json:"host,omitempty"`
	HostGroup            *SubResource                                    `json:"hostGroup,omitempty"`
	Identity             *VirtualMachineIdentity                         `json:"identity,omitempty"`
	LicenseType          *string                                         `json:"licenseType,omitempty"`
	Location             *string                                         `json:"location,omitempty"`
	NetworkProfile       *VirtualMachines_Spec_Properties_NetworkProfile `json:"networkProfile,omitempty"`
	OriginalVersion      string                                          `json:"originalVersion,omitempty"`
	OsProfile            *VirtualMachines_Spec_Properties_OsProfile      `json:"osProfile,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                   *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Plan                    *Plan                              `json:"plan,omitempty"`
	PlatformFaultDomain     *int                               `json:"platformFaultDomain,omitempty"`
	Priority                *string                            `json:"priority,omitempty"`
	PropertyBag             genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProximityPlacementGroup *SubResource                       `json:"proximityPlacementGroup,omitempty"`
	SecurityProfile         *SecurityProfile                   `json:"securityProfile,omitempty"`
	StorageProfile          *StorageProfile                    `json:"storageProfile,omitempty"`
	Tags                    map[string]string                  `json:"tags,omitempty"`
	VirtualMachineScaleSet  *SubResource                       `json:"virtualMachineScaleSet,omitempty"`
	Zones                   []string                           `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleSpec = &VirtualMachines_Spec{}

// ConvertSpecFrom populates our VirtualMachines_Spec from the provided source
func (machines *VirtualMachines_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20220301s.VirtualMachines_Spec)
	if ok {
		// Populate our instance from source
		return machines.AssignPropertiesFromVirtualMachinesSpec(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.VirtualMachines_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = machines.AssignPropertiesFromVirtualMachinesSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachines_Spec
func (machines *VirtualMachines_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20220301s.VirtualMachines_Spec)
	if ok {
		// Populate destination from our instance
		return machines.AssignPropertiesToVirtualMachinesSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.VirtualMachines_Spec{}
	err := machines.AssignPropertiesToVirtualMachinesSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualMachinesSpec populates our VirtualMachines_Spec from the provided source VirtualMachines_Spec
func (machines *VirtualMachines_Spec) AssignPropertiesFromVirtualMachinesSpec(source *v20220301s.VirtualMachines_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		machines.AdditionalCapabilities = &additionalCapability
	} else {
		machines.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		propertyBag.Add("ApplicationProfile", *source.ApplicationProfile)
	} else {
		propertyBag.Remove("ApplicationProfile")
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignPropertiesFromSubResource(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SubResourceStash from AvailabilitySet")
		}
		var availabilitySet SubResource
		err = availabilitySet.AssignPropertiesFromSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field AvailabilitySet from SubResourceStash")
		}
		machines.AvailabilitySet = &availabilitySet
	} else {
		machines.AvailabilitySet = nil
	}

	// AzureName
	machines.AzureName = source.AzureName

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignPropertiesFromBillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBillingProfile() to populate field BillingProfile")
		}
		machines.BillingProfile = &billingProfile
	} else {
		machines.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		propertyBag.Add("CapacityReservation", *source.CapacityReservation)
	} else {
		propertyBag.Remove("CapacityReservation")
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		machines.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machines.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	machines.EvictionPolicy = genruntime.ClonePointerToString(source.EvictionPolicy)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationStash v20210701s.ExtendedLocation
		err := extendedLocationStash.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation
		err = extendedLocation.AssignPropertiesFromExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		machines.ExtendedLocation = &extendedLocation
	} else {
		machines.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machines.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile
		err := hardwareProfile.AssignPropertiesFromHardwareProfile(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHardwareProfile() to populate field HardwareProfile")
		}
		machines.HardwareProfile = &hardwareProfile
	} else {
		machines.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignPropertiesFromSubResource(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SubResourceStash from Host")
		}
		var host SubResource
		err = host.AssignPropertiesFromSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field Host from SubResourceStash")
		}
		machines.Host = &host
	} else {
		machines.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignPropertiesFromSubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SubResourceStash from HostGroup")
		}
		var hostGroup SubResource
		err = hostGroup.AssignPropertiesFromSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field HostGroup from SubResourceStash")
		}
		machines.HostGroup = &hostGroup
	} else {
		machines.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity
		err := identity.AssignPropertiesFromVirtualMachineIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineIdentity() to populate field Identity")
		}
		machines.Identity = &identity
	} else {
		machines.Identity = nil
	}

	// LicenseType
	machines.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machines.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachines_Spec_Properties_NetworkProfile
		err := networkProfile.AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile() to populate field NetworkProfile")
		}
		machines.NetworkProfile = &networkProfile
	} else {
		machines.NetworkProfile = nil
	}

	// OriginalVersion
	machines.OriginalVersion = source.OriginalVersion

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachines_Spec_Properties_OsProfile
		err := osProfile.AssignPropertiesFromVirtualMachinesSpecPropertiesOsProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinesSpecPropertiesOsProfile() to populate field OsProfile")
		}
		machines.OsProfile = &osProfile
	} else {
		machines.OsProfile = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		machines.Owner = &owner
	} else {
		machines.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignPropertiesFromPlan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPlan() to populate field Plan")
		}
		machines.Plan = &plan
	} else {
		machines.Plan = nil
	}

	// PlatformFaultDomain
	machines.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	machines.Priority = genruntime.ClonePointerToString(source.Priority)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignPropertiesFromSubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SubResourceStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup SubResource
		err = proximityPlacementGroup.AssignPropertiesFromSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field ProximityPlacementGroup from SubResourceStash")
		}
		machines.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machines.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		propertyBag.Add("ScheduledEventsProfile", *source.ScheduledEventsProfile)
	} else {
		propertyBag.Remove("ScheduledEventsProfile")
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignPropertiesFromSecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSecurityProfile() to populate field SecurityProfile")
		}
		machines.SecurityProfile = &securityProfile
	} else {
		machines.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignPropertiesFromStorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromStorageProfile() to populate field StorageProfile")
		}
		machines.StorageProfile = &storageProfile
	} else {
		machines.StorageProfile = nil
	}

	// Tags
	machines.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UserData
	if source.UserData != nil {
		propertyBag.Add("UserData", *source.UserData)
	} else {
		propertyBag.Remove("UserData")
	}

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignPropertiesFromSubResource(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SubResourceStash from VirtualMachineScaleSet")
		}
		var virtualMachineScaleSet SubResource
		err = virtualMachineScaleSet.AssignPropertiesFromSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field VirtualMachineScaleSet from SubResourceStash")
		}
		machines.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machines.VirtualMachineScaleSet = nil
	}

	// Zones
	machines.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		machines.PropertyBag = propertyBag
	} else {
		machines.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpec populates the provided destination VirtualMachines_Spec from our VirtualMachines_Spec
func (machines *VirtualMachines_Spec) AssignPropertiesToVirtualMachinesSpec(destination *v20220301s.VirtualMachines_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(machines.PropertyBag)

	// AdditionalCapabilities
	if machines.AdditionalCapabilities != nil {
		var additionalCapability v20220301s.AdditionalCapabilities
		err := machines.AdditionalCapabilities.AssignPropertiesToAdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if propertyBag.Contains("ApplicationProfile") {
		var applicationProfile v20220301s.ApplicationProfile
		err := propertyBag.Pull("ApplicationProfile", &applicationProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ApplicationProfile' from propertyBag")
		}

		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// AvailabilitySet
	if machines.AvailabilitySet != nil {
		var subResourceStash v20210701s.SubResource
		err := machines.AvailabilitySet.AssignPropertiesToSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SubResourceStash from AvailabilitySet")
		}
		var availabilitySet v20220301s.SubResource
		err = subResourceStash.AssignPropertiesToSubResource(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field AvailabilitySet from SubResourceStash")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// AzureName
	destination.AzureName = machines.AzureName

	// BillingProfile
	if machines.BillingProfile != nil {
		var billingProfile v20220301s.BillingProfile
		err := machines.BillingProfile.AssignPropertiesToBillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBillingProfile() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if propertyBag.Contains("CapacityReservation") {
		var capacityReservation v20220301s.CapacityReservationProfile
		err := propertyBag.Pull("CapacityReservation", &capacityReservation)
		if err != nil {
			return errors.Wrap(err, "pulling 'CapacityReservation' from propertyBag")
		}

		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if machines.DiagnosticsProfile != nil {
		var diagnosticsProfile v20220301s.DiagnosticsProfile
		err := machines.DiagnosticsProfile.AssignPropertiesToDiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	destination.EvictionPolicy = genruntime.ClonePointerToString(machines.EvictionPolicy)

	// ExtendedLocation
	if machines.ExtendedLocation != nil {
		var extendedLocationStash v20210701s.ExtendedLocation
		err := machines.ExtendedLocation.AssignPropertiesToExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation v20220301s.ExtendedLocation
		err = extendedLocationStash.AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machines.ExtensionsTimeBudget)

	// HardwareProfile
	if machines.HardwareProfile != nil {
		var hardwareProfile v20220301s.HardwareProfile
		err := machines.HardwareProfile.AssignPropertiesToHardwareProfile(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHardwareProfile() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machines.Host != nil {
		var subResourceStash v20210701s.SubResource
		err := machines.Host.AssignPropertiesToSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SubResourceStash from Host")
		}
		var host v20220301s.SubResource
		err = subResourceStash.AssignPropertiesToSubResource(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field Host from SubResourceStash")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machines.HostGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := machines.HostGroup.AssignPropertiesToSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SubResourceStash from HostGroup")
		}
		var hostGroup v20220301s.SubResource
		err = subResourceStash.AssignPropertiesToSubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field HostGroup from SubResourceStash")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if machines.Identity != nil {
		var identity v20220301s.VirtualMachineIdentity
		err := machines.Identity.AssignPropertiesToVirtualMachineIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machines.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machines.Location)

	// NetworkProfile
	if machines.NetworkProfile != nil {
		var networkProfile v20220301s.VirtualMachines_Spec_Properties_NetworkProfile
		err := machines.NetworkProfile.AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OriginalVersion
	destination.OriginalVersion = machines.OriginalVersion

	// OsProfile
	if machines.OsProfile != nil {
		var osProfile v20220301s.VirtualMachines_Spec_Properties_OsProfile
		err := machines.OsProfile.AssignPropertiesToVirtualMachinesSpecPropertiesOsProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinesSpecPropertiesOsProfile() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Owner
	if machines.Owner != nil {
		owner := machines.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if machines.Plan != nil {
		var plan v20220301s.Plan
		err := machines.Plan.AssignPropertiesToPlan(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPlan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machines.PlatformFaultDomain)

	// Priority
	destination.Priority = genruntime.ClonePointerToString(machines.Priority)

	// ProximityPlacementGroup
	if machines.ProximityPlacementGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := machines.ProximityPlacementGroup.AssignPropertiesToSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SubResourceStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup v20220301s.SubResource
		err = subResourceStash.AssignPropertiesToSubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field ProximityPlacementGroup from SubResourceStash")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if propertyBag.Contains("ScheduledEventsProfile") {
		var scheduledEventsProfile v20220301s.ScheduledEventsProfile
		err := propertyBag.Pull("ScheduledEventsProfile", &scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ScheduledEventsProfile' from propertyBag")
		}

		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if machines.SecurityProfile != nil {
		var securityProfile v20220301s.SecurityProfile
		err := machines.SecurityProfile.AssignPropertiesToSecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machines.StorageProfile != nil {
		var storageProfile v20220301s.StorageProfile
		err := machines.StorageProfile.AssignPropertiesToStorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToStorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machines.Tags)

	// UserData
	if propertyBag.Contains("UserData") {
		var userDatum string
		err := propertyBag.Pull("UserData", &userDatum)
		if err != nil {
			return errors.Wrap(err, "pulling 'UserData' from propertyBag")
		}

		destination.UserData = &userDatum
	} else {
		destination.UserData = nil
	}

	// VirtualMachineScaleSet
	if machines.VirtualMachineScaleSet != nil {
		var subResourceStash v20210701s.SubResource
		err := machines.VirtualMachineScaleSet.AssignPropertiesToSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SubResourceStash from VirtualMachineScaleSet")
		}
		var virtualMachineScaleSet v20220301s.SubResource
		err = subResourceStash.AssignPropertiesToSubResource(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field VirtualMachineScaleSet from SubResourceStash")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machines.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.AdditionalCapabilities
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/AdditionalCapabilities
type AdditionalCapabilities struct {
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UltraSSDEnabled *bool                  `json:"ultraSSDEnabled,omitempty"`
}

// AssignPropertiesFromAdditionalCapabilities populates our AdditionalCapabilities from the provided source AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignPropertiesFromAdditionalCapabilities(source *v20220301s.AdditionalCapabilities) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HibernationEnabled
	if source.HibernationEnabled != nil {
		propertyBag.Add("HibernationEnabled", *source.HibernationEnabled)
	} else {
		propertyBag.Remove("HibernationEnabled")
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		capabilities.PropertyBag = propertyBag
	} else {
		capabilities.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalCapabilities populates the provided destination AdditionalCapabilities from our AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignPropertiesToAdditionalCapabilities(destination *v20220301s.AdditionalCapabilities) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(capabilities.PropertyBag)

	// HibernationEnabled
	if propertyBag.Contains("HibernationEnabled") {
		var hibernationEnabled bool
		err := propertyBag.Pull("HibernationEnabled", &hibernationEnabled)
		if err != nil {
			return errors.Wrap(err, "pulling 'HibernationEnabled' from propertyBag")
		}

		destination.HibernationEnabled = &hibernationEnabled
	} else {
		destination.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.AdditionalCapabilities_STATUS
type AdditionalCapabilities_STATUS struct {
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UltraSSDEnabled *bool                  `json:"ultraSSDEnabled,omitempty"`
}

// AssignPropertiesFromAdditionalCapabilitiesSTATUS populates our AdditionalCapabilities_STATUS from the provided source AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignPropertiesFromAdditionalCapabilitiesSTATUS(source *v20220301s.AdditionalCapabilities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HibernationEnabled
	if source.HibernationEnabled != nil {
		propertyBag.Add("HibernationEnabled", *source.HibernationEnabled)
	} else {
		propertyBag.Remove("HibernationEnabled")
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		capabilities.PropertyBag = propertyBag
	} else {
		capabilities.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalCapabilitiesSTATUS populates the provided destination AdditionalCapabilities_STATUS from our AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignPropertiesToAdditionalCapabilitiesSTATUS(destination *v20220301s.AdditionalCapabilities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(capabilities.PropertyBag)

	// HibernationEnabled
	if propertyBag.Contains("HibernationEnabled") {
		var hibernationEnabled bool
		err := propertyBag.Pull("HibernationEnabled", &hibernationEnabled)
		if err != nil {
			return errors.Wrap(err, "pulling 'HibernationEnabled' from propertyBag")
		}

		destination.HibernationEnabled = &hibernationEnabled
	} else {
		destination.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.BillingProfile
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/BillingProfile
type BillingProfile struct {
	MaxPrice    *float64               `json:"maxPrice,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromBillingProfile populates our BillingProfile from the provided source BillingProfile
func (profile *BillingProfile) AssignPropertiesFromBillingProfile(source *v20220301s.BillingProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBillingProfile populates the provided destination BillingProfile from our BillingProfile
func (profile *BillingProfile) AssignPropertiesToBillingProfile(destination *v20220301s.BillingProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.BillingProfile_STATUS
type BillingProfile_STATUS struct {
	MaxPrice    *float64               `json:"maxPrice,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromBillingProfileSTATUS populates our BillingProfile_STATUS from the provided source BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignPropertiesFromBillingProfileSTATUS(source *v20220301s.BillingProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBillingProfileSTATUS populates the provided destination BillingProfile_STATUS from our BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignPropertiesToBillingProfileSTATUS(destination *v20220301s.BillingProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DiagnosticsProfile
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiagnosticsProfile
type DiagnosticsProfile struct {
	BootDiagnostics *BootDiagnostics       `json:"bootDiagnostics,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDiagnosticsProfile populates our DiagnosticsProfile from the provided source DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignPropertiesFromDiagnosticsProfile(source *v20220301s.DiagnosticsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics
		err := bootDiagnostic.AssignPropertiesFromBootDiagnostics(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBootDiagnostics() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiagnosticsProfile populates the provided destination DiagnosticsProfile from our DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignPropertiesToDiagnosticsProfile(destination *v20220301s.DiagnosticsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic v20220301s.BootDiagnostics
		err := profile.BootDiagnostics.AssignPropertiesToBootDiagnostics(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBootDiagnostics() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DiagnosticsProfile_STATUS
type DiagnosticsProfile_STATUS struct {
	BootDiagnostics *BootDiagnostics_STATUS `json:"bootDiagnostics,omitempty"`
	PropertyBag     genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDiagnosticsProfileSTATUS populates our DiagnosticsProfile_STATUS from the provided source DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignPropertiesFromDiagnosticsProfileSTATUS(source *v20220301s.DiagnosticsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics_STATUS
		err := bootDiagnostic.AssignPropertiesFromBootDiagnosticsSTATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBootDiagnosticsSTATUS() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiagnosticsProfileSTATUS populates the provided destination DiagnosticsProfile_STATUS from our DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignPropertiesToDiagnosticsProfileSTATUS(destination *v20220301s.DiagnosticsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic v20220301s.BootDiagnostics_STATUS
		err := profile.BootDiagnostics.AssignPropertiesToBootDiagnosticsSTATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBootDiagnosticsSTATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.ExtendedLocation
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ExtendedLocation
type ExtendedLocation struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignPropertiesFromExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignPropertiesFromExtendedLocation(source *v20210701s.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignPropertiesToExtendedLocation(destination *v20210701s.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.ExtendedLocation_STATUS
type ExtendedLocation_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignPropertiesFromExtendedLocationSTATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignPropertiesFromExtendedLocationSTATUS(source *v20210701s.ExtendedLocation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocationSTATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignPropertiesToExtendedLocationSTATUS(destination *v20210701s.ExtendedLocation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.HardwareProfile
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/HardwareProfile
type HardwareProfile struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VmSize      *string                `json:"vmSize,omitempty"`
}

// AssignPropertiesFromHardwareProfile populates our HardwareProfile from the provided source HardwareProfile
func (profile *HardwareProfile) AssignPropertiesFromHardwareProfile(source *v20220301s.HardwareProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		propertyBag.Add("VmSizeProperties", *source.VmSizeProperties)
	} else {
		propertyBag.Remove("VmSizeProperties")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHardwareProfile populates the provided destination HardwareProfile from our HardwareProfile
func (profile *HardwareProfile) AssignPropertiesToHardwareProfile(destination *v20220301s.HardwareProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VmSizeProperties
	if propertyBag.Contains("VmSizeProperties") {
		var vmSizeProperty v20220301s.VMSizeProperties
		err := propertyBag.Pull("VmSizeProperties", &vmSizeProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'VmSizeProperties' from propertyBag")
		}

		destination.VmSizeProperties = &vmSizeProperty
	} else {
		destination.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.HardwareProfile_STATUS
type HardwareProfile_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VmSize      *string                `json:"vmSize,omitempty"`
}

// AssignPropertiesFromHardwareProfileSTATUS populates our HardwareProfile_STATUS from the provided source HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignPropertiesFromHardwareProfileSTATUS(source *v20220301s.HardwareProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		propertyBag.Add("VmSizeProperties", *source.VmSizeProperties)
	} else {
		propertyBag.Remove("VmSizeProperties")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHardwareProfileSTATUS populates the provided destination HardwareProfile_STATUS from our HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignPropertiesToHardwareProfileSTATUS(destination *v20220301s.HardwareProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VmSizeProperties
	if propertyBag.Contains("VmSizeProperties") {
		var vmSizeProperty v20220301s.VMSizeProperties_STATUS
		err := propertyBag.Pull("VmSizeProperties", &vmSizeProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'VmSizeProperties' from propertyBag")
		}

		destination.VmSizeProperties = &vmSizeProperty
	} else {
		destination.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.NetworkProfile_STATUS
type NetworkProfile_STATUS struct {
	NetworkInterfaces []NetworkInterfaceReference_STATUS `json:"networkInterfaces,omitempty"`
	PropertyBag       genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromNetworkProfileSTATUS populates our NetworkProfile_STATUS from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignPropertiesFromNetworkProfileSTATUS(source *v20220301s.NetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		propertyBag.Add("NetworkApiVersion", *source.NetworkApiVersion)
	} else {
		propertyBag.Remove("NetworkApiVersion")
	}

	// NetworkInterfaceConfigurations
	if len(source.NetworkInterfaceConfigurations) > 0 {
		propertyBag.Add("NetworkInterfaceConfigurations", source.NetworkInterfaceConfigurations)
	} else {
		propertyBag.Remove("NetworkInterfaceConfigurations")
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference_STATUS, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference_STATUS
			err := networkInterface.AssignPropertiesFromNetworkInterfaceReferenceSTATUS(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceReferenceSTATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkProfileSTATUS populates the provided destination NetworkProfile_STATUS from our NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignPropertiesToNetworkProfileSTATUS(destination *v20220301s.NetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// NetworkApiVersion
	if propertyBag.Contains("NetworkApiVersion") {
		var networkApiVersion string
		err := propertyBag.Pull("NetworkApiVersion", &networkApiVersion)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkApiVersion' from propertyBag")
		}

		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if propertyBag.Contains("NetworkInterfaceConfigurations") {
		var networkInterfaceConfiguration []v20220301s.VirtualMachineNetworkInterfaceConfiguration_STATUS
		err := propertyBag.Pull("NetworkInterfaceConfigurations", &networkInterfaceConfiguration)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkInterfaceConfigurations' from propertyBag")
		}

		destination.NetworkInterfaceConfigurations = networkInterfaceConfiguration
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]v20220301s.NetworkInterfaceReference_STATUS, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface v20220301s.NetworkInterfaceReference_STATUS
			err := networkInterfaceItem.AssignPropertiesToNetworkInterfaceReferenceSTATUS(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceReferenceSTATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.OSProfile_STATUS
type OSProfile_STATUS struct {
	AdminUsername               *string                      `json:"adminUsername,omitempty"`
	AllowExtensionOperations    *bool                        `json:"allowExtensionOperations,omitempty"`
	ComputerName                *string                      `json:"computerName,omitempty"`
	CustomData                  *string                      `json:"customData,omitempty"`
	LinuxConfiguration          *LinuxConfiguration_STATUS   `json:"linuxConfiguration,omitempty"`
	PropertyBag                 genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	RequireGuestProvisionSignal *bool                        `json:"requireGuestProvisionSignal,omitempty"`
	Secrets                     []VaultSecretGroup_STATUS    `json:"secrets,omitempty"`
	WindowsConfiguration        *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

// AssignPropertiesFromOSProfileSTATUS populates our OSProfile_STATUS from the provided source OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignPropertiesFromOSProfileSTATUS(source *v20220301s.OSProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_STATUS
		err := linuxConfiguration.AssignPropertiesFromLinuxConfigurationSTATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfigurationSTATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_STATUS
			err := secret.AssignPropertiesFromVaultSecretGroupSTATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroupSTATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_STATUS
		err := windowsConfiguration.AssignPropertiesFromWindowsConfigurationSTATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfigurationSTATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSProfileSTATUS populates the provided destination OSProfile_STATUS from our OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignPropertiesToOSProfileSTATUS(destination *v20220301s.OSProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v20220301s.LinuxConfiguration_STATUS
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfigurationSTATUS(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfigurationSTATUS() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v20220301s.VaultSecretGroup_STATUS, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v20220301s.VaultSecretGroup_STATUS
			err := secretItem.AssignPropertiesToVaultSecretGroupSTATUS(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroupSTATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v20220301s.WindowsConfiguration_STATUS
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfigurationSTATUS(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfigurationSTATUS() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.Plan
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/Plan
type Plan struct {
	Name          *string                `json:"name,omitempty"`
	Product       *string                `json:"product,omitempty"`
	PromotionCode *string                `json:"promotionCode,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher     *string                `json:"publisher,omitempty"`
}

// AssignPropertiesFromPlan populates our Plan from the provided source Plan
func (plan *Plan) AssignPropertiesFromPlan(source *v20220301s.Plan) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		plan.PropertyBag = propertyBag
	} else {
		plan.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPlan populates the provided destination Plan from our Plan
func (plan *Plan) AssignPropertiesToPlan(destination *v20220301s.Plan) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(plan.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.Plan_STATUS
type Plan_STATUS struct {
	Name          *string                `json:"name,omitempty"`
	Product       *string                `json:"product,omitempty"`
	PromotionCode *string                `json:"promotionCode,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher     *string                `json:"publisher,omitempty"`
}

// AssignPropertiesFromPlanSTATUS populates our Plan_STATUS from the provided source Plan_STATUS
func (plan *Plan_STATUS) AssignPropertiesFromPlanSTATUS(source *v20220301s.Plan_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		plan.PropertyBag = propertyBag
	} else {
		plan.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPlanSTATUS populates the provided destination Plan_STATUS from our Plan_STATUS
func (plan *Plan_STATUS) AssignPropertiesToPlanSTATUS(destination *v20220301s.Plan_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(plan.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.SecurityProfile
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SecurityProfile
type SecurityProfile struct {
	EncryptionAtHost *bool                  `json:"encryptionAtHost,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecurityType     *string                `json:"securityType,omitempty"`
	UefiSettings     *UefiSettings          `json:"uefiSettings,omitempty"`
}

// AssignPropertiesFromSecurityProfile populates our SecurityProfile from the provided source SecurityProfile
func (profile *SecurityProfile) AssignPropertiesFromSecurityProfile(source *v20220301s.SecurityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	profile.SecurityType = genruntime.ClonePointerToString(source.SecurityType)

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings
		err := uefiSetting.AssignPropertiesFromUefiSettings(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUefiSettings() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityProfile populates the provided destination SecurityProfile from our SecurityProfile
func (profile *SecurityProfile) AssignPropertiesToSecurityProfile(destination *v20220301s.SecurityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	destination.SecurityType = genruntime.ClonePointerToString(profile.SecurityType)

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting v20220301s.UefiSettings
		err := profile.UefiSettings.AssignPropertiesToUefiSettings(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUefiSettings() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.SecurityProfile_STATUS
type SecurityProfile_STATUS struct {
	EncryptionAtHost *bool                  `json:"encryptionAtHost,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecurityType     *string                `json:"securityType,omitempty"`
	UefiSettings     *UefiSettings_STATUS   `json:"uefiSettings,omitempty"`
}

// AssignPropertiesFromSecurityProfileSTATUS populates our SecurityProfile_STATUS from the provided source SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignPropertiesFromSecurityProfileSTATUS(source *v20220301s.SecurityProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	profile.SecurityType = genruntime.ClonePointerToString(source.SecurityType)

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings_STATUS
		err := uefiSetting.AssignPropertiesFromUefiSettingsSTATUS(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUefiSettingsSTATUS() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityProfileSTATUS populates the provided destination SecurityProfile_STATUS from our SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignPropertiesToSecurityProfileSTATUS(destination *v20220301s.SecurityProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	destination.SecurityType = genruntime.ClonePointerToString(profile.SecurityType)

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting v20220301s.UefiSettings_STATUS
		err := profile.UefiSettings.AssignPropertiesToUefiSettingsSTATUS(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUefiSettingsSTATUS() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.StorageProfile
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/StorageProfile
type StorageProfile struct {
	DataDisks      []DataDisk             `json:"dataDisks,omitempty"`
	ImageReference *ImageReference        `json:"imageReference,omitempty"`
	OsDisk         *OSDisk                `json:"osDisk,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromStorageProfile populates our StorageProfile from the provided source StorageProfile
func (profile *StorageProfile) AssignPropertiesFromStorageProfile(source *v20220301s.StorageProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk
			err := dataDisk.AssignPropertiesFromDataDisk(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignPropertiesFromImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReference() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk
		err := osDisk.AssignPropertiesFromOSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOSDisk() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToStorageProfile populates the provided destination StorageProfile from our StorageProfile
func (profile *StorageProfile) AssignPropertiesToStorageProfile(destination *v20220301s.StorageProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v20220301s.DataDisk, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v20220301s.DataDisk
			err := dataDiskItem.AssignPropertiesToDataDisk(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v20220301s.ImageReference
		err := profile.ImageReference.AssignPropertiesToImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReference() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v20220301s.OSDisk
		err := profile.OsDisk.AssignPropertiesToOSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOSDisk() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.StorageProfile_STATUS
type StorageProfile_STATUS struct {
	DataDisks      []DataDisk_STATUS      `json:"dataDisks,omitempty"`
	ImageReference *ImageReference_STATUS `json:"imageReference,omitempty"`
	OsDisk         *OSDisk_STATUS         `json:"osDisk,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromStorageProfileSTATUS populates our StorageProfile_STATUS from the provided source StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignPropertiesFromStorageProfileSTATUS(source *v20220301s.StorageProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk_STATUS
			err := dataDisk.AssignPropertiesFromDataDiskSTATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDataDiskSTATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_STATUS
		err := imageReference.AssignPropertiesFromImageReferenceSTATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromImageReferenceSTATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk_STATUS
		err := osDisk.AssignPropertiesFromOSDiskSTATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOSDiskSTATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToStorageProfileSTATUS populates the provided destination StorageProfile_STATUS from our StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignPropertiesToStorageProfileSTATUS(destination *v20220301s.StorageProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v20220301s.DataDisk_STATUS, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v20220301s.DataDisk_STATUS
			err := dataDiskItem.AssignPropertiesToDataDiskSTATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDataDiskSTATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v20220301s.ImageReference_STATUS
		err := profile.ImageReference.AssignPropertiesToImageReferenceSTATUS(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToImageReferenceSTATUS() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v20220301s.OSDisk_STATUS
		err := profile.OsDisk.AssignPropertiesToOSDiskSTATUS(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOSDiskSTATUS() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.SubResource
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SubResource
type SubResource struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromSubResource populates our SubResource from the provided source SubResource
func (resource *SubResource) AssignPropertiesFromSubResource(source *v20210701s.SubResource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubResource populates the provided destination SubResource from our SubResource
func (resource *SubResource) AssignPropertiesToSubResource(destination *v20210701s.SubResource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.SubResource_STATUS
type SubResource_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromSubResourceSTATUS populates our SubResource_STATUS from the provided source SubResource_STATUS
func (resource *SubResource_STATUS) AssignPropertiesFromSubResourceSTATUS(source *v20210701s.SubResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubResourceSTATUS populates the provided destination SubResource_STATUS from our SubResource_STATUS
func (resource *SubResource_STATUS) AssignPropertiesToSubResourceSTATUS(destination *v20210701s.SubResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachineExtension_STATUS
type VirtualMachineExtension_STATUS struct {
	AutoUpgradeMinorVersion *bool                                       `json:"autoUpgradeMinorVersion,omitempty"`
	EnableAutomaticUpgrade  *bool                                       `json:"enableAutomaticUpgrade,omitempty"`
	ForceUpdateTag          *string                                     `json:"forceUpdateTag,omitempty"`
	Id                      *string                                     `json:"id,omitempty"`
	InstanceView            *VirtualMachineExtensionInstanceView_STATUS `json:"instanceView,omitempty"`
	Location                *string                                     `json:"location,omitempty"`
	Name                    *string                                     `json:"name,omitempty"`
	PropertiesType          *string                                     `json:"properties_type,omitempty"`
	PropertyBag             genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
	ProtectedSettings       map[string]v1.JSON                          `json:"protectedSettings,omitempty"`
	ProvisioningState       *string                                     `json:"provisioningState,omitempty"`
	Publisher               *string                                     `json:"publisher,omitempty"`
	Settings                map[string]v1.JSON                          `json:"settings,omitempty"`
	Tags                    map[string]string                           `json:"tags,omitempty"`
	Type                    *string                                     `json:"type,omitempty"`
	TypeHandlerVersion      *string                                     `json:"typeHandlerVersion,omitempty"`
}

// AssignPropertiesFromVirtualMachineExtensionSTATUS populates our VirtualMachineExtension_STATUS from the provided source VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignPropertiesFromVirtualMachineExtensionSTATUS(source *v20220301s.VirtualMachineExtension_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineExtensionInstanceView_STATUS
		err := instanceView.AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS() to populate field InstanceView")
		}
		extension.InstanceView = &instanceView
	} else {
		extension.InstanceView = nil
	}

	// Location
	extension.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// PropertiesType
	extension.PropertiesType = genruntime.ClonePointerToString(source.PropertiesType)

	// ProtectedSettings
	if source.ProtectedSettings != nil {
		protectedSettingMap := make(map[string]v1.JSON, len(source.ProtectedSettings))
		for protectedSettingKey, protectedSettingValue := range source.ProtectedSettings {
			// Shadow the loop variable to avoid aliasing
			protectedSettingValue := protectedSettingValue
			protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
		}
		extension.ProtectedSettings = protectedSettingMap
	} else {
		extension.ProtectedSettings = nil
	}

	// ProtectedSettingsFromKeyVault
	if len(source.ProtectedSettingsFromKeyVault) > 0 {
		propertyBag.Add("ProtectedSettingsFromKeyVault", source.ProtectedSettingsFromKeyVault)
	} else {
		propertyBag.Remove("ProtectedSettingsFromKeyVault")
	}

	// ProvisioningState
	extension.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if source.SuppressFailures != nil {
		propertyBag.Add("SuppressFailures", *source.SuppressFailures)
	} else {
		propertyBag.Remove("SuppressFailures")
	}

	// Tags
	extension.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		extension.PropertyBag = propertyBag
	} else {
		extension.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionSTATUS populates the provided destination VirtualMachineExtension_STATUS from our VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignPropertiesToVirtualMachineExtensionSTATUS(destination *v20220301s.VirtualMachineExtension_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(extension.PropertyBag)

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// InstanceView
	if extension.InstanceView != nil {
		var instanceView v20220301s.VirtualMachineExtensionInstanceView_STATUS
		err := extension.InstanceView.AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(extension.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// PropertiesType
	destination.PropertiesType = genruntime.ClonePointerToString(extension.PropertiesType)

	// ProtectedSettings
	if extension.ProtectedSettings != nil {
		protectedSettingMap := make(map[string]v1.JSON, len(extension.ProtectedSettings))
		for protectedSettingKey, protectedSettingValue := range extension.ProtectedSettings {
			// Shadow the loop variable to avoid aliasing
			protectedSettingValue := protectedSettingValue
			protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
		}
		destination.ProtectedSettings = protectedSettingMap
	} else {
		destination.ProtectedSettings = nil
	}

	// ProtectedSettingsFromKeyVault
	if propertyBag.Contains("ProtectedSettingsFromKeyVault") {
		var protectedSettingsFromKeyVault map[string]v1.JSON
		err := propertyBag.Pull("ProtectedSettingsFromKeyVault", &protectedSettingsFromKeyVault)
		if err != nil {
			return errors.Wrap(err, "pulling 'ProtectedSettingsFromKeyVault' from propertyBag")
		}

		destination.ProtectedSettingsFromKeyVault = protectedSettingsFromKeyVault
	} else {
		destination.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(extension.ProvisioningState)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// SuppressFailures
	if propertyBag.Contains("SuppressFailures") {
		var suppressFailure bool
		err := propertyBag.Pull("SuppressFailures", &suppressFailure)
		if err != nil {
			return errors.Wrap(err, "pulling 'SuppressFailures' from propertyBag")
		}

		destination.SuppressFailures = &suppressFailure
	} else {
		destination.SuppressFailures = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(extension.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachineIdentity
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineIdentity
type VirtualMachineIdentity struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignPropertiesFromVirtualMachineIdentity populates our VirtualMachineIdentity from the provided source VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignPropertiesFromVirtualMachineIdentity(source *v20220301s.VirtualMachineIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineIdentity populates the provided destination VirtualMachineIdentity from our VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignPropertiesToVirtualMachineIdentity(destination *v20220301s.VirtualMachineIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachineIdentity_STATUS
type VirtualMachineIdentity_STATUS struct {
	PrincipalId *string                `json:"principalId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TenantId    *string                `json:"tenantId,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignPropertiesFromVirtualMachineIdentitySTATUS populates our VirtualMachineIdentity_STATUS from the provided source VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignPropertiesFromVirtualMachineIdentitySTATUS(source *v20220301s.VirtualMachineIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineIdentitySTATUS populates the provided destination VirtualMachineIdentity_STATUS from our VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignPropertiesToVirtualMachineIdentitySTATUS(destination *v20220301s.VirtualMachineIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachineInstanceView_STATUS
type VirtualMachineInstanceView_STATUS struct {
	AssignedHost              *string                                      `json:"assignedHost,omitempty"`
	BootDiagnostics           *BootDiagnosticsInstanceView_STATUS          `json:"bootDiagnostics,omitempty"`
	ComputerName              *string                                      `json:"computerName,omitempty"`
	Disks                     []DiskInstanceView_STATUS                    `json:"disks,omitempty"`
	Extensions                []VirtualMachineExtensionInstanceView_STATUS `json:"extensions,omitempty"`
	HyperVGeneration          *string                                      `json:"hyperVGeneration,omitempty"`
	MaintenanceRedeployStatus *MaintenanceRedeployStatus_STATUS            `json:"maintenanceRedeployStatus,omitempty"`
	OsName                    *string                                      `json:"osName,omitempty"`
	OsVersion                 *string                                      `json:"osVersion,omitempty"`
	PatchStatus               *VirtualMachinePatchStatus_STATUS            `json:"patchStatus,omitempty"`
	PlatformFaultDomain       *int                                         `json:"platformFaultDomain,omitempty"`
	PlatformUpdateDomain      *int                                         `json:"platformUpdateDomain,omitempty"`
	PropertyBag               genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	RdpThumbPrint             *string                                      `json:"rdpThumbPrint,omitempty"`
	Statuses                  []InstanceViewStatus_STATUS                  `json:"statuses,omitempty"`
	VmAgent                   *VirtualMachineAgentInstanceView_STATUS      `json:"vmAgent,omitempty"`
	VmHealth                  *VirtualMachineHealthStatus_STATUS           `json:"vmHealth,omitempty"`
}

// AssignPropertiesFromVirtualMachineInstanceViewSTATUS populates our VirtualMachineInstanceView_STATUS from the provided source VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignPropertiesFromVirtualMachineInstanceViewSTATUS(source *v20220301s.VirtualMachineInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssignedHost
	view.AssignedHost = genruntime.ClonePointerToString(source.AssignedHost)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnosticsInstanceView_STATUS
		err := bootDiagnostic.AssignPropertiesFromBootDiagnosticsInstanceViewSTATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromBootDiagnosticsInstanceViewSTATUS() to populate field BootDiagnostics")
		}
		view.BootDiagnostics = &bootDiagnostic
	} else {
		view.BootDiagnostics = nil
	}

	// ComputerName
	view.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// Disks
	if source.Disks != nil {
		diskList := make([]DiskInstanceView_STATUS, len(source.Disks))
		for diskIndex, diskItem := range source.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk DiskInstanceView_STATUS
			err := disk.AssignPropertiesFromDiskInstanceViewSTATUS(&diskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDiskInstanceViewSTATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		view.Disks = diskList
	} else {
		view.Disks = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineExtensionInstanceView_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineExtensionInstanceView_STATUS
			err := extension.AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		view.Extensions = extensionList
	} else {
		view.Extensions = nil
	}

	// HyperVGeneration
	view.HyperVGeneration = genruntime.ClonePointerToString(source.HyperVGeneration)

	// MaintenanceRedeployStatus
	if source.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus MaintenanceRedeployStatus_STATUS
		err := maintenanceRedeployStatus.AssignPropertiesFromMaintenanceRedeployStatusSTATUS(source.MaintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromMaintenanceRedeployStatusSTATUS() to populate field MaintenanceRedeployStatus")
		}
		view.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		view.MaintenanceRedeployStatus = nil
	}

	// OsName
	view.OsName = genruntime.ClonePointerToString(source.OsName)

	// OsVersion
	view.OsVersion = genruntime.ClonePointerToString(source.OsVersion)

	// PatchStatus
	if source.PatchStatus != nil {
		var patchStatus VirtualMachinePatchStatus_STATUS
		err := patchStatus.AssignPropertiesFromVirtualMachinePatchStatusSTATUS(source.PatchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinePatchStatusSTATUS() to populate field PatchStatus")
		}
		view.PatchStatus = &patchStatus
	} else {
		view.PatchStatus = nil
	}

	// PlatformFaultDomain
	view.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// PlatformUpdateDomain
	view.PlatformUpdateDomain = genruntime.ClonePointerToInt(source.PlatformUpdateDomain)

	// RdpThumbPrint
	view.RdpThumbPrint = genruntime.ClonePointerToString(source.RdpThumbPrint)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignPropertiesFromInstanceViewStatusSTATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgent
	if source.VmAgent != nil {
		var vmAgent VirtualMachineAgentInstanceView_STATUS
		err := vmAgent.AssignPropertiesFromVirtualMachineAgentInstanceViewSTATUS(source.VmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineAgentInstanceViewSTATUS() to populate field VmAgent")
		}
		view.VmAgent = &vmAgent
	} else {
		view.VmAgent = nil
	}

	// VmHealth
	if source.VmHealth != nil {
		var vmHealth VirtualMachineHealthStatus_STATUS
		err := vmHealth.AssignPropertiesFromVirtualMachineHealthStatusSTATUS(source.VmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineHealthStatusSTATUS() to populate field VmHealth")
		}
		view.VmHealth = &vmHealth
	} else {
		view.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineInstanceViewSTATUS populates the provided destination VirtualMachineInstanceView_STATUS from our VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignPropertiesToVirtualMachineInstanceViewSTATUS(destination *v20220301s.VirtualMachineInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// AssignedHost
	destination.AssignedHost = genruntime.ClonePointerToString(view.AssignedHost)

	// BootDiagnostics
	if view.BootDiagnostics != nil {
		var bootDiagnostic v20220301s.BootDiagnosticsInstanceView_STATUS
		err := view.BootDiagnostics.AssignPropertiesToBootDiagnosticsInstanceViewSTATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToBootDiagnosticsInstanceViewSTATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(view.ComputerName)

	// Disks
	if view.Disks != nil {
		diskList := make([]v20220301s.DiskInstanceView_STATUS, len(view.Disks))
		for diskIndex, diskItem := range view.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk v20220301s.DiskInstanceView_STATUS
			err := diskItem.AssignPropertiesToDiskInstanceViewSTATUS(&disk)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDiskInstanceViewSTATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		destination.Disks = diskList
	} else {
		destination.Disks = nil
	}

	// Extensions
	if view.Extensions != nil {
		extensionList := make([]v20220301s.VirtualMachineExtensionInstanceView_STATUS, len(view.Extensions))
		for extensionIndex, extensionItem := range view.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension v20220301s.VirtualMachineExtensionInstanceView_STATUS
			err := extensionItem.AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// HyperVGeneration
	destination.HyperVGeneration = genruntime.ClonePointerToString(view.HyperVGeneration)

	// MaintenanceRedeployStatus
	if view.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus v20220301s.MaintenanceRedeployStatus_STATUS
		err := view.MaintenanceRedeployStatus.AssignPropertiesToMaintenanceRedeployStatusSTATUS(&maintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToMaintenanceRedeployStatusSTATUS() to populate field MaintenanceRedeployStatus")
		}
		destination.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		destination.MaintenanceRedeployStatus = nil
	}

	// OsName
	destination.OsName = genruntime.ClonePointerToString(view.OsName)

	// OsVersion
	destination.OsVersion = genruntime.ClonePointerToString(view.OsVersion)

	// PatchStatus
	if view.PatchStatus != nil {
		var patchStatus v20220301s.VirtualMachinePatchStatus_STATUS
		err := view.PatchStatus.AssignPropertiesToVirtualMachinePatchStatusSTATUS(&patchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinePatchStatusSTATUS() to populate field PatchStatus")
		}
		destination.PatchStatus = &patchStatus
	} else {
		destination.PatchStatus = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(view.PlatformFaultDomain)

	// PlatformUpdateDomain
	destination.PlatformUpdateDomain = genruntime.ClonePointerToInt(view.PlatformUpdateDomain)

	// RdpThumbPrint
	destination.RdpThumbPrint = genruntime.ClonePointerToString(view.RdpThumbPrint)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20220301s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20220301s.InstanceViewStatus_STATUS
			err := statusItem.AssignPropertiesToInstanceViewStatusSTATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgent
	if view.VmAgent != nil {
		var vmAgent v20220301s.VirtualMachineAgentInstanceView_STATUS
		err := view.VmAgent.AssignPropertiesToVirtualMachineAgentInstanceViewSTATUS(&vmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineAgentInstanceViewSTATUS() to populate field VmAgent")
		}
		destination.VmAgent = &vmAgent
	} else {
		destination.VmAgent = nil
	}

	// VmHealth
	if view.VmHealth != nil {
		var vmHealth v20220301s.VirtualMachineHealthStatus_STATUS
		err := view.VmHealth.AssignPropertiesToVirtualMachineHealthStatusSTATUS(&vmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineHealthStatusSTATUS() to populate field VmHealth")
		}
		destination.VmHealth = &vmHealth
	} else {
		destination.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachines_Spec_Properties_NetworkProfile
type VirtualMachines_Spec_Properties_NetworkProfile struct {
	NetworkInterfaces []VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces `json:"networkInterfaces,omitempty"`
	PropertyBag       genruntime.PropertyBag                                             `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile populates our VirtualMachines_Spec_Properties_NetworkProfile from the provided source VirtualMachines_Spec_Properties_NetworkProfile
func (profile *VirtualMachines_Spec_Properties_NetworkProfile) AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfile(source *v20220301s.VirtualMachines_Spec_Properties_NetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		propertyBag.Add("NetworkApiVersion", *source.NetworkApiVersion)
	} else {
		propertyBag.Remove("NetworkApiVersion")
	}

	// NetworkInterfaceConfigurations
	if len(source.NetworkInterfaceConfigurations) > 0 {
		propertyBag.Add("NetworkInterfaceConfigurations", source.NetworkInterfaceConfigurations)
	} else {
		propertyBag.Remove("NetworkInterfaceConfigurations")
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
			err := networkInterface.AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile populates the provided destination VirtualMachines_Spec_Properties_NetworkProfile from our VirtualMachines_Spec_Properties_NetworkProfile
func (profile *VirtualMachines_Spec_Properties_NetworkProfile) AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfile(destination *v20220301s.VirtualMachines_Spec_Properties_NetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// NetworkApiVersion
	if propertyBag.Contains("NetworkApiVersion") {
		var networkApiVersion string
		err := propertyBag.Pull("NetworkApiVersion", &networkApiVersion)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkApiVersion' from propertyBag")
		}

		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if propertyBag.Contains("NetworkInterfaceConfigurations") {
		var networkInterfaceConfiguration []v20220301s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations
		err := propertyBag.Pull("NetworkInterfaceConfigurations", &networkInterfaceConfiguration)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkInterfaceConfigurations' from propertyBag")
		}

		destination.NetworkInterfaceConfigurations = networkInterfaceConfiguration
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]v20220301s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface v20220301s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
			err := networkInterfaceItem.AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachines_Spec_Properties_OsProfile
type VirtualMachines_Spec_Properties_OsProfile struct {
	AdminPassword               *genruntime.SecretReference `json:"adminPassword,omitempty"`
	AdminUsername               *string                     `json:"adminUsername,omitempty"`
	AllowExtensionOperations    *bool                       `json:"allowExtensionOperations,omitempty"`
	ComputerName                *string                     `json:"computerName,omitempty"`
	CustomData                  *string                     `json:"customData,omitempty"`
	LinuxConfiguration          *LinuxConfiguration         `json:"linuxConfiguration,omitempty"`
	PropertyBag                 genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	RequireGuestProvisionSignal *bool                       `json:"requireGuestProvisionSignal,omitempty"`
	Secrets                     []VaultSecretGroup          `json:"secrets,omitempty"`
	WindowsConfiguration        *WindowsConfiguration       `json:"windowsConfiguration,omitempty"`
}

// AssignPropertiesFromVirtualMachinesSpecPropertiesOsProfile populates our VirtualMachines_Spec_Properties_OsProfile from the provided source VirtualMachines_Spec_Properties_OsProfile
func (profile *VirtualMachines_Spec_Properties_OsProfile) AssignPropertiesFromVirtualMachinesSpecPropertiesOsProfile(source *v20220301s.VirtualMachines_Spec_Properties_OsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignPropertiesFromLinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignPropertiesFromVaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignPropertiesFromWindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpecPropertiesOsProfile populates the provided destination VirtualMachines_Spec_Properties_OsProfile from our VirtualMachines_Spec_Properties_OsProfile
func (profile *VirtualMachines_Spec_Properties_OsProfile) AssignPropertiesToVirtualMachinesSpecPropertiesOsProfile(destination *v20220301s.VirtualMachines_Spec_Properties_OsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v20220301s.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignPropertiesToLinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v20220301s.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v20220301s.VaultSecretGroup
			err := secretItem.AssignPropertiesToVaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v20220301s.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignPropertiesToWindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.BootDiagnostics
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/BootDiagnostics
type BootDiagnostics struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageUri  *string                `json:"storageUri,omitempty"`
}

// AssignPropertiesFromBootDiagnostics populates our BootDiagnostics from the provided source BootDiagnostics
func (diagnostics *BootDiagnostics) AssignPropertiesFromBootDiagnostics(source *v20220301s.BootDiagnostics) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		diagnostics.PropertyBag = propertyBag
	} else {
		diagnostics.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBootDiagnostics populates the provided destination BootDiagnostics from our BootDiagnostics
func (diagnostics *BootDiagnostics) AssignPropertiesToBootDiagnostics(destination *v20220301s.BootDiagnostics) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(diagnostics.PropertyBag)

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.BootDiagnostics_STATUS
type BootDiagnostics_STATUS struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageUri  *string                `json:"storageUri,omitempty"`
}

// AssignPropertiesFromBootDiagnosticsSTATUS populates our BootDiagnostics_STATUS from the provided source BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignPropertiesFromBootDiagnosticsSTATUS(source *v20220301s.BootDiagnostics_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		diagnostics.PropertyBag = propertyBag
	} else {
		diagnostics.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBootDiagnosticsSTATUS populates the provided destination BootDiagnostics_STATUS from our BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignPropertiesToBootDiagnosticsSTATUS(destination *v20220301s.BootDiagnostics_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(diagnostics.PropertyBag)

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.BootDiagnosticsInstanceView_STATUS
type BootDiagnosticsInstanceView_STATUS struct {
	ConsoleScreenshotBlobUri *string                    `json:"consoleScreenshotBlobUri,omitempty"`
	PropertyBag              genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	SerialConsoleLogBlobUri  *string                    `json:"serialConsoleLogBlobUri,omitempty"`
	Status                   *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

// AssignPropertiesFromBootDiagnosticsInstanceViewSTATUS populates our BootDiagnosticsInstanceView_STATUS from the provided source BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignPropertiesFromBootDiagnosticsInstanceViewSTATUS(source *v20220301s.BootDiagnosticsInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConsoleScreenshotBlobUri
	view.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(source.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	view.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(source.SerialConsoleLogBlobUri)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignPropertiesFromInstanceViewStatusSTATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBootDiagnosticsInstanceViewSTATUS populates the provided destination BootDiagnosticsInstanceView_STATUS from our BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignPropertiesToBootDiagnosticsInstanceViewSTATUS(destination *v20220301s.BootDiagnosticsInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// ConsoleScreenshotBlobUri
	destination.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(view.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	destination.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(view.SerialConsoleLogBlobUri)

	// Status
	if view.Status != nil {
		var status v20220301s.InstanceViewStatus_STATUS
		err := view.Status.AssignPropertiesToInstanceViewStatusSTATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DataDisk
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DataDisk
type DataDisk struct {
	Caching                 *string                `json:"caching,omitempty"`
	CreateOption            *string                `json:"createOption,omitempty"`
	DetachOption            *string                `json:"detachOption,omitempty"`
	DiskSizeGB              *int                   `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk       `json:"image,omitempty"`
	Lun                     *int                   `json:"lun,omitempty"`
	ManagedDisk             *ManagedDiskParameters `json:"managedDisk,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ToBeDetached            *bool                  `json:"toBeDetached,omitempty"`
	Vhd                     *VirtualHardDisk       `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                  `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignPropertiesFromDataDisk populates our DataDisk from the provided source DataDisk
func (disk *DataDisk) AssignPropertiesFromDataDisk(source *v20220301s.DataDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DetachOption
	disk.DetachOption = genruntime.ClonePointerToString(source.DetachOption)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignPropertiesFromVirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignPropertiesFromManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignPropertiesFromVirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDataDisk populates the provided destination DataDisk from our DataDisk
func (disk *DataDisk) AssignPropertiesToDataDisk(destination *v20220301s.DataDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DetachOption
	destination.DetachOption = genruntime.ClonePointerToString(disk.DetachOption)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk
		err := disk.Image.AssignPropertiesToVirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.ManagedDiskParameters
		err := disk.ManagedDisk.AssignPropertiesToManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd v20220301s.VirtualHardDisk
		err := disk.Vhd.AssignPropertiesToVirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DataDisk_STATUS
type DataDisk_STATUS struct {
	Caching                 *string                       `json:"caching,omitempty"`
	CreateOption            *string                       `json:"createOption,omitempty"`
	DetachOption            *string                       `json:"detachOption,omitempty"`
	DiskIOPSReadWrite       *int                          `json:"diskIOPSReadWrite,omitempty"`
	DiskMBpsReadWrite       *int                          `json:"diskMBpsReadWrite,omitempty"`
	DiskSizeGB              *int                          `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk_STATUS       `json:"image,omitempty"`
	Lun                     *int                          `json:"lun,omitempty"`
	ManagedDisk             *ManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`
	Name                    *string                       `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	ToBeDetached            *bool                         `json:"toBeDetached,omitempty"`
	Vhd                     *VirtualHardDisk_STATUS       `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                         `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignPropertiesFromDataDiskSTATUS populates our DataDisk_STATUS from the provided source DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignPropertiesFromDataDiskSTATUS(source *v20220301s.DataDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DetachOption
	disk.DetachOption = genruntime.ClonePointerToString(source.DetachOption)

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignPropertiesFromVirtualHardDiskSTATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignPropertiesFromManagedDiskParametersSTATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedDiskParametersSTATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignPropertiesFromVirtualHardDiskSTATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDataDiskSTATUS populates the provided destination DataDisk_STATUS from our DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignPropertiesToDataDiskSTATUS(destination *v20220301s.DataDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DetachOption
	destination.DetachOption = genruntime.ClonePointerToString(disk.DetachOption)

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk_STATUS
		err := disk.Image.AssignPropertiesToVirtualHardDiskSTATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignPropertiesToManagedDiskParametersSTATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedDiskParametersSTATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd v20220301s.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignPropertiesToVirtualHardDiskSTATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DiskInstanceView_STATUS
type DiskInstanceView_STATUS struct {
	EncryptionSettings []DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	Name               *string                         `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	Statuses           []InstanceViewStatus_STATUS     `json:"statuses,omitempty"`
}

// AssignPropertiesFromDiskInstanceViewSTATUS populates our DiskInstanceView_STATUS from the provided source DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignPropertiesFromDiskInstanceViewSTATUS(source *v20220301s.DiskInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		encryptionSettingList := make([]DiskEncryptionSettings_STATUS, len(source.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range source.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting DiskEncryptionSettings_STATUS
			err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettingsSTATUS(&encryptionSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSettingsSTATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		view.EncryptionSettings = encryptionSettingList
	} else {
		view.EncryptionSettings = nil
	}

	// Name
	view.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignPropertiesFromInstanceViewStatusSTATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskInstanceViewSTATUS populates the provided destination DiskInstanceView_STATUS from our DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignPropertiesToDiskInstanceViewSTATUS(destination *v20220301s.DiskInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// EncryptionSettings
	if view.EncryptionSettings != nil {
		encryptionSettingList := make([]v20220301s.DiskEncryptionSettings_STATUS, len(view.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range view.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting v20220301s.DiskEncryptionSettings_STATUS
			err := encryptionSettingItem.AssignPropertiesToDiskEncryptionSettingsSTATUS(&encryptionSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSettingsSTATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		destination.EncryptionSettings = encryptionSettingList
	} else {
		destination.EncryptionSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(view.Name)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20220301s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20220301s.InstanceViewStatus_STATUS
			err := statusItem.AssignPropertiesToInstanceViewStatusSTATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.ImageReference
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ImageReference
type ImageReference struct {
	Offer       *string                `json:"offer,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher   *string                `json:"publisher,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	Sku       *string                       `json:"sku,omitempty"`
	Version   *string                       `json:"version,omitempty"`
}

// AssignPropertiesFromImageReference populates our ImageReference from the provided source ImageReference
func (reference *ImageReference) AssignPropertiesFromImageReference(source *v20220301s.ImageReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CommunityGalleryImageId
	if source.CommunityGalleryImageId != nil {
		propertyBag.Add("CommunityGalleryImageId", *source.CommunityGalleryImageId)
	} else {
		propertyBag.Remove("CommunityGalleryImageId")
	}

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// SharedGalleryImageId
	if source.SharedGalleryImageId != nil {
		propertyBag.Add("SharedGalleryImageId", *source.SharedGalleryImageId)
	} else {
		propertyBag.Remove("SharedGalleryImageId")
	}

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToImageReference populates the provided destination ImageReference from our ImageReference
func (reference *ImageReference) AssignPropertiesToImageReference(destination *v20220301s.ImageReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// CommunityGalleryImageId
	if propertyBag.Contains("CommunityGalleryImageId") {
		var communityGalleryImageId string
		err := propertyBag.Pull("CommunityGalleryImageId", &communityGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'CommunityGalleryImageId' from propertyBag")
		}

		destination.CommunityGalleryImageId = &communityGalleryImageId
	} else {
		destination.CommunityGalleryImageId = nil
	}

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// SharedGalleryImageId
	if propertyBag.Contains("SharedGalleryImageId") {
		var sharedGalleryImageId string
		err := propertyBag.Pull("SharedGalleryImageId", &sharedGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'SharedGalleryImageId' from propertyBag")
		}

		destination.SharedGalleryImageId = &sharedGalleryImageId
	} else {
		destination.SharedGalleryImageId = nil
	}

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.ImageReference_STATUS
type ImageReference_STATUS struct {
	ExactVersion *string                `json:"exactVersion,omitempty"`
	Id           *string                `json:"id,omitempty"`
	Offer        *string                `json:"offer,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher    *string                `json:"publisher,omitempty"`
	Sku          *string                `json:"sku,omitempty"`
	Version      *string                `json:"version,omitempty"`
}

// AssignPropertiesFromImageReferenceSTATUS populates our ImageReference_STATUS from the provided source ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignPropertiesFromImageReferenceSTATUS(source *v20220301s.ImageReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CommunityGalleryImageId
	if source.CommunityGalleryImageId != nil {
		propertyBag.Add("CommunityGalleryImageId", *source.CommunityGalleryImageId)
	} else {
		propertyBag.Remove("CommunityGalleryImageId")
	}

	// ExactVersion
	reference.ExactVersion = genruntime.ClonePointerToString(source.ExactVersion)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// SharedGalleryImageId
	if source.SharedGalleryImageId != nil {
		propertyBag.Add("SharedGalleryImageId", *source.SharedGalleryImageId)
	} else {
		propertyBag.Remove("SharedGalleryImageId")
	}

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToImageReferenceSTATUS populates the provided destination ImageReference_STATUS from our ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignPropertiesToImageReferenceSTATUS(destination *v20220301s.ImageReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// CommunityGalleryImageId
	if propertyBag.Contains("CommunityGalleryImageId") {
		var communityGalleryImageId string
		err := propertyBag.Pull("CommunityGalleryImageId", &communityGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'CommunityGalleryImageId' from propertyBag")
		}

		destination.CommunityGalleryImageId = &communityGalleryImageId
	} else {
		destination.CommunityGalleryImageId = nil
	}

	// ExactVersion
	destination.ExactVersion = genruntime.ClonePointerToString(reference.ExactVersion)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// SharedGalleryImageId
	if propertyBag.Contains("SharedGalleryImageId") {
		var sharedGalleryImageId string
		err := propertyBag.Pull("SharedGalleryImageId", &sharedGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'SharedGalleryImageId' from propertyBag")
		}

		destination.SharedGalleryImageId = &sharedGalleryImageId
	} else {
		destination.SharedGalleryImageId = nil
	}

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.InstanceViewStatus_STATUS
type InstanceViewStatus_STATUS struct {
	Code          *string                `json:"code,omitempty"`
	DisplayStatus *string                `json:"displayStatus,omitempty"`
	Level         *string                `json:"level,omitempty"`
	Message       *string                `json:"message,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Time          *string                `json:"time,omitempty"`
}

// AssignPropertiesFromInstanceViewStatusSTATUS populates our InstanceViewStatus_STATUS from the provided source InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignPropertiesFromInstanceViewStatusSTATUS(source *v20220301s.InstanceViewStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	status.Code = genruntime.ClonePointerToString(source.Code)

	// DisplayStatus
	status.DisplayStatus = genruntime.ClonePointerToString(source.DisplayStatus)

	// Level
	status.Level = genruntime.ClonePointerToString(source.Level)

	// Message
	status.Message = genruntime.ClonePointerToString(source.Message)

	// Time
	status.Time = genruntime.ClonePointerToString(source.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInstanceViewStatusSTATUS populates the provided destination InstanceViewStatus_STATUS from our InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignPropertiesToInstanceViewStatusSTATUS(destination *v20220301s.InstanceViewStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(status.Code)

	// DisplayStatus
	destination.DisplayStatus = genruntime.ClonePointerToString(status.DisplayStatus)

	// Level
	destination.Level = genruntime.ClonePointerToString(status.Level)

	// Message
	destination.Message = genruntime.ClonePointerToString(status.Message)

	// Time
	destination.Time = genruntime.ClonePointerToString(status.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.LinuxConfiguration
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/LinuxConfiguration
type LinuxConfiguration struct {
	DisablePasswordAuthentication *bool                  `json:"disablePasswordAuthentication,omitempty"`
	PatchSettings                 *LinuxPatchSettings    `json:"patchSettings,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ProvisionVMAgent              *bool                  `json:"provisionVMAgent,omitempty"`
	Ssh                           *SshConfiguration      `json:"ssh,omitempty"`
}

// AssignPropertiesFromLinuxConfiguration populates our LinuxConfiguration from the provided source LinuxConfiguration
func (configuration *LinuxConfiguration) AssignPropertiesFromLinuxConfiguration(source *v20220301s.LinuxConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings
		err := patchSetting.AssignPropertiesFromLinuxPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxPatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration
		err := ssh.AssignPropertiesFromSshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSshConfiguration() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxConfiguration populates the provided destination LinuxConfiguration from our LinuxConfiguration
func (configuration *LinuxConfiguration) AssignPropertiesToLinuxConfiguration(destination *v20220301s.LinuxConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20220301s.LinuxPatchSettings
		err := configuration.PatchSettings.AssignPropertiesToLinuxPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxPatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh v20220301s.SshConfiguration
		err := configuration.Ssh.AssignPropertiesToSshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSshConfiguration() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.LinuxConfiguration_STATUS
type LinuxConfiguration_STATUS struct {
	DisablePasswordAuthentication *bool                      `json:"disablePasswordAuthentication,omitempty"`
	PatchSettings                 *LinuxPatchSettings_STATUS `json:"patchSettings,omitempty"`
	PropertyBag                   genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	ProvisionVMAgent              *bool                      `json:"provisionVMAgent,omitempty"`
	Ssh                           *SshConfiguration_STATUS   `json:"ssh,omitempty"`
}

// AssignPropertiesFromLinuxConfigurationSTATUS populates our LinuxConfiguration_STATUS from the provided source LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignPropertiesFromLinuxConfigurationSTATUS(source *v20220301s.LinuxConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings_STATUS
		err := patchSetting.AssignPropertiesFromLinuxPatchSettingsSTATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxPatchSettingsSTATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration_STATUS
		err := ssh.AssignPropertiesFromSshConfigurationSTATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSshConfigurationSTATUS() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxConfigurationSTATUS populates the provided destination LinuxConfiguration_STATUS from our LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignPropertiesToLinuxConfigurationSTATUS(destination *v20220301s.LinuxConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20220301s.LinuxPatchSettings_STATUS
		err := configuration.PatchSettings.AssignPropertiesToLinuxPatchSettingsSTATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxPatchSettingsSTATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh v20220301s.SshConfiguration_STATUS
		err := configuration.Ssh.AssignPropertiesToSshConfigurationSTATUS(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSshConfigurationSTATUS() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.MaintenanceRedeployStatus_STATUS
type MaintenanceRedeployStatus_STATUS struct {
	IsCustomerInitiatedMaintenanceAllowed *bool                  `json:"isCustomerInitiatedMaintenanceAllowed,omitempty"`
	LastOperationMessage                  *string                `json:"lastOperationMessage,omitempty"`
	LastOperationResultCode               *string                `json:"lastOperationResultCode,omitempty"`
	MaintenanceWindowEndTime              *string                `json:"maintenanceWindowEndTime,omitempty"`
	MaintenanceWindowStartTime            *string                `json:"maintenanceWindowStartTime,omitempty"`
	PreMaintenanceWindowEndTime           *string                `json:"preMaintenanceWindowEndTime,omitempty"`
	PreMaintenanceWindowStartTime         *string                `json:"preMaintenanceWindowStartTime,omitempty"`
	PropertyBag                           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromMaintenanceRedeployStatusSTATUS populates our MaintenanceRedeployStatus_STATUS from the provided source MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignPropertiesFromMaintenanceRedeployStatusSTATUS(source *v20220301s.MaintenanceRedeployStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IsCustomerInitiatedMaintenanceAllowed
	if source.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *source.IsCustomerInitiatedMaintenanceAllowed
		status.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		status.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	status.LastOperationMessage = genruntime.ClonePointerToString(source.LastOperationMessage)

	// LastOperationResultCode
	status.LastOperationResultCode = genruntime.ClonePointerToString(source.LastOperationResultCode)

	// MaintenanceWindowEndTime
	status.MaintenanceWindowEndTime = genruntime.ClonePointerToString(source.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	status.MaintenanceWindowStartTime = genruntime.ClonePointerToString(source.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	status.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	status.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToMaintenanceRedeployStatusSTATUS populates the provided destination MaintenanceRedeployStatus_STATUS from our MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignPropertiesToMaintenanceRedeployStatusSTATUS(destination *v20220301s.MaintenanceRedeployStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// IsCustomerInitiatedMaintenanceAllowed
	if status.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *status.IsCustomerInitiatedMaintenanceAllowed
		destination.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		destination.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	destination.LastOperationMessage = genruntime.ClonePointerToString(status.LastOperationMessage)

	// LastOperationResultCode
	destination.LastOperationResultCode = genruntime.ClonePointerToString(status.LastOperationResultCode)

	// MaintenanceWindowEndTime
	destination.MaintenanceWindowEndTime = genruntime.ClonePointerToString(status.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	destination.MaintenanceWindowStartTime = genruntime.ClonePointerToString(status.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	destination.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	destination.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.NetworkInterfaceReference_STATUS
type NetworkInterfaceReference_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	Primary     *bool                  `json:"primary,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromNetworkInterfaceReferenceSTATUS populates our NetworkInterfaceReference_STATUS from the provided source NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignPropertiesFromNetworkInterfaceReferenceSTATUS(source *v20220301s.NetworkInterfaceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceReferenceSTATUS populates the provided destination NetworkInterfaceReference_STATUS from our NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignPropertiesToNetworkInterfaceReferenceSTATUS(destination *v20220301s.NetworkInterfaceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Primary
	if reference.Primary != nil {
		primary := *reference.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.OSDisk
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/OSDisk
type OSDisk struct {
	Caching                 *string                 `json:"caching,omitempty"`
	CreateOption            *string                 `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings       `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                    `json:"diskSizeGB,omitempty"`
	EncryptionSettings      *DiskEncryptionSettings `json:"encryptionSettings,omitempty"`
	Image                   *VirtualHardDisk        `json:"image,omitempty"`
	ManagedDisk             *ManagedDiskParameters  `json:"managedDisk,omitempty"`
	Name                    *string                 `json:"name,omitempty"`
	OsType                  *string                 `json:"osType,omitempty"`
	PropertyBag             genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
	Vhd                     *VirtualHardDisk        `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                   `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignPropertiesFromOSDisk populates our OSDisk from the provided source OSDisk
func (disk *OSDisk) AssignPropertiesFromOSDisk(source *v20220301s.OSDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettings() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings
		err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettings(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSettings() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignPropertiesFromVirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignPropertiesFromManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	disk.OsType = genruntime.ClonePointerToString(source.OsType)

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignPropertiesFromVirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSDisk populates the provided destination OSDisk from our OSDisk
func (disk *OSDisk) AssignPropertiesToOSDisk(destination *v20220301s.OSDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v20220301s.DiffDiskSettings
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettings() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting v20220301s.DiskEncryptionSettings
		err := disk.EncryptionSettings.AssignPropertiesToDiskEncryptionSettings(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSettings() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk
		err := disk.Image.AssignPropertiesToVirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.ManagedDiskParameters
		err := disk.ManagedDisk.AssignPropertiesToManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(disk.OsType)

	// Vhd
	if disk.Vhd != nil {
		var vhd v20220301s.VirtualHardDisk
		err := disk.Vhd.AssignPropertiesToVirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.OSDisk_STATUS
type OSDisk_STATUS struct {
	Caching                 *string                        `json:"caching,omitempty"`
	CreateOption            *string                        `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings_STATUS       `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                           `json:"diskSizeGB,omitempty"`
	EncryptionSettings      *DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	Image                   *VirtualHardDisk_STATUS        `json:"image,omitempty"`
	ManagedDisk             *ManagedDiskParameters_STATUS  `json:"managedDisk,omitempty"`
	Name                    *string                        `json:"name,omitempty"`
	OsType                  *string                        `json:"osType,omitempty"`
	PropertyBag             genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	Vhd                     *VirtualHardDisk_STATUS        `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                          `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignPropertiesFromOSDiskSTATUS populates our OSDisk_STATUS from the provided source OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignPropertiesFromOSDiskSTATUS(source *v20220301s.OSDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_STATUS
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettingsSTATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiffDiskSettingsSTATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings_STATUS
		err := encryptionSetting.AssignPropertiesFromDiskEncryptionSettingsSTATUS(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSettingsSTATUS() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignPropertiesFromVirtualHardDiskSTATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignPropertiesFromManagedDiskParametersSTATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedDiskParametersSTATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	disk.OsType = genruntime.ClonePointerToString(source.OsType)

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignPropertiesFromVirtualHardDiskSTATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromVirtualHardDiskSTATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOSDiskSTATUS populates the provided destination OSDisk_STATUS from our OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignPropertiesToOSDiskSTATUS(destination *v20220301s.OSDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v20220301s.DiffDiskSettings_STATUS
		err := disk.DiffDiskSettings.AssignPropertiesToDiffDiskSettingsSTATUS(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiffDiskSettingsSTATUS() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting v20220301s.DiskEncryptionSettings_STATUS
		err := disk.EncryptionSettings.AssignPropertiesToDiskEncryptionSettingsSTATUS(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSettingsSTATUS() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk_STATUS
		err := disk.Image.AssignPropertiesToVirtualHardDiskSTATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignPropertiesToManagedDiskParametersSTATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedDiskParametersSTATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(disk.OsType)

	// Vhd
	if disk.Vhd != nil {
		var vhd v20220301s.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignPropertiesToVirtualHardDiskSTATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToVirtualHardDiskSTATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.UefiSettings
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/UefiSettings
type UefiSettings struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecureBootEnabled *bool                  `json:"secureBootEnabled,omitempty"`
	VTpmEnabled       *bool                  `json:"vTpmEnabled,omitempty"`
}

// AssignPropertiesFromUefiSettings populates our UefiSettings from the provided source UefiSettings
func (settings *UefiSettings) AssignPropertiesFromUefiSettings(source *v20220301s.UefiSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUefiSettings populates the provided destination UefiSettings from our UefiSettings
func (settings *UefiSettings) AssignPropertiesToUefiSettings(destination *v20220301s.UefiSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.UefiSettings_STATUS
type UefiSettings_STATUS struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecureBootEnabled *bool                  `json:"secureBootEnabled,omitempty"`
	VTpmEnabled       *bool                  `json:"vTpmEnabled,omitempty"`
}

// AssignPropertiesFromUefiSettingsSTATUS populates our UefiSettings_STATUS from the provided source UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignPropertiesFromUefiSettingsSTATUS(source *v20220301s.UefiSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUefiSettingsSTATUS populates the provided destination UefiSettings_STATUS from our UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignPropertiesToUefiSettingsSTATUS(destination *v20220301s.UefiSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VaultSecretGroup
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VaultSecretGroup
type VaultSecretGroup struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault       *SubResource           `json:"sourceVault,omitempty"`
	VaultCertificates []VaultCertificate     `json:"vaultCertificates,omitempty"`
}

// AssignPropertiesFromVaultSecretGroup populates our VaultSecretGroup from the provided source VaultSecretGroup
func (group *VaultSecretGroup) AssignPropertiesFromVaultSecretGroup(source *v20220301s.VaultSecretGroup) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault SubResource
		err = sourceVault.AssignPropertiesFromSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SourceVault from SubResourceStash")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate
			err := vaultCertificate.AssignPropertiesFromVaultCertificate(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultSecretGroup populates the provided destination VaultSecretGroup from our VaultSecretGroup
func (group *VaultSecretGroup) AssignPropertiesToVaultSecretGroup(destination *v20220301s.VaultSecretGroup) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// SourceVault
	if group.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := group.SourceVault.AssignPropertiesToSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource
		err = subResourceStash.AssignPropertiesToSubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SourceVault from SubResourceStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]v20220301s.VaultCertificate, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate v20220301s.VaultCertificate
			err := vaultCertificateItem.AssignPropertiesToVaultCertificate(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VaultSecretGroup_STATUS
type VaultSecretGroup_STATUS struct {
	PropertyBag       genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
	SourceVault       *SubResource_STATUS       `json:"sourceVault,omitempty"`
	VaultCertificates []VaultCertificate_STATUS `json:"vaultCertificates,omitempty"`
}

// AssignPropertiesFromVaultSecretGroupSTATUS populates our VaultSecretGroup_STATUS from the provided source VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignPropertiesFromVaultSecretGroupSTATUS(source *v20220301s.VaultSecretGroup_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault SubResource_STATUS
		err = sourceVault.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate_STATUS, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate_STATUS
			err := vaultCertificate.AssignPropertiesFromVaultCertificateSTATUS(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVaultCertificateSTATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultSecretGroupSTATUS populates the provided destination VaultSecretGroup_STATUS from our VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignPropertiesToVaultSecretGroupSTATUS(destination *v20220301s.VaultSecretGroup_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// SourceVault
	if group.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := group.SourceVault.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]v20220301s.VaultCertificate_STATUS, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate v20220301s.VaultCertificate_STATUS
			err := vaultCertificateItem.AssignPropertiesToVaultCertificateSTATUS(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVaultCertificateSTATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachineAgentInstanceView_STATUS
type VirtualMachineAgentInstanceView_STATUS struct {
	ExtensionHandlers []VirtualMachineExtensionHandlerInstanceView_STATUS `json:"extensionHandlers,omitempty"`
	PropertyBag       genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	Statuses          []InstanceViewStatus_STATUS                         `json:"statuses,omitempty"`
	VmAgentVersion    *string                                             `json:"vmAgentVersion,omitempty"`
}

// AssignPropertiesFromVirtualMachineAgentInstanceViewSTATUS populates our VirtualMachineAgentInstanceView_STATUS from the provided source VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignPropertiesFromVirtualMachineAgentInstanceViewSTATUS(source *v20220301s.VirtualMachineAgentInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExtensionHandlers
	if source.ExtensionHandlers != nil {
		extensionHandlerList := make([]VirtualMachineExtensionHandlerInstanceView_STATUS, len(source.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range source.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandler.AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewSTATUS(&extensionHandlerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewSTATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		view.ExtensionHandlers = extensionHandlerList
	} else {
		view.ExtensionHandlers = nil
	}

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignPropertiesFromInstanceViewStatusSTATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgentVersion
	view.VmAgentVersion = genruntime.ClonePointerToString(source.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineAgentInstanceViewSTATUS populates the provided destination VirtualMachineAgentInstanceView_STATUS from our VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignPropertiesToVirtualMachineAgentInstanceViewSTATUS(destination *v20220301s.VirtualMachineAgentInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// ExtensionHandlers
	if view.ExtensionHandlers != nil {
		extensionHandlerList := make([]v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS, len(view.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range view.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandlerItem.AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewSTATUS(&extensionHandler)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewSTATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		destination.ExtensionHandlers = extensionHandlerList
	} else {
		destination.ExtensionHandlers = nil
	}

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20220301s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20220301s.InstanceViewStatus_STATUS
			err := statusItem.AssignPropertiesToInstanceViewStatusSTATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgentVersion
	destination.VmAgentVersion = genruntime.ClonePointerToString(view.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachineExtensionInstanceView_STATUS
type VirtualMachineExtensionInstanceView_STATUS struct {
	Name               *string                     `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	Statuses           []InstanceViewStatus_STATUS `json:"statuses,omitempty"`
	Substatuses        []InstanceViewStatus_STATUS `json:"substatuses,omitempty"`
	Type               *string                     `json:"type,omitempty"`
	TypeHandlerVersion *string                     `json:"typeHandlerVersion,omitempty"`
}

// AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS populates our VirtualMachineExtensionInstanceView_STATUS from the provided source VirtualMachineExtensionInstanceView_STATUS
func (view *VirtualMachineExtensionInstanceView_STATUS) AssignPropertiesFromVirtualMachineExtensionInstanceViewSTATUS(source *v20220301s.VirtualMachineExtensionInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	view.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignPropertiesFromInstanceViewStatusSTATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// Substatuses
	if source.Substatuses != nil {
		substatusList := make([]InstanceViewStatus_STATUS, len(source.Substatuses))
		for substatusIndex, substatusItem := range source.Substatuses {
			// Shadow the loop variable to avoid aliasing
			substatusItem := substatusItem
			var substatus InstanceViewStatus_STATUS
			err := substatus.AssignPropertiesFromInstanceViewStatusSTATUS(&substatusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Substatuses")
			}
			substatusList[substatusIndex] = substatus
		}
		view.Substatuses = substatusList
	} else {
		view.Substatuses = nil
	}

	// Type
	view.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	view.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS populates the provided destination VirtualMachineExtensionInstanceView_STATUS from our VirtualMachineExtensionInstanceView_STATUS
func (view *VirtualMachineExtensionInstanceView_STATUS) AssignPropertiesToVirtualMachineExtensionInstanceViewSTATUS(destination *v20220301s.VirtualMachineExtensionInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(view.Name)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20220301s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20220301s.InstanceViewStatus_STATUS
			err := statusItem.AssignPropertiesToInstanceViewStatusSTATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Substatuses
	if view.Substatuses != nil {
		substatusList := make([]v20220301s.InstanceViewStatus_STATUS, len(view.Substatuses))
		for substatusIndex, substatusItem := range view.Substatuses {
			// Shadow the loop variable to avoid aliasing
			substatusItem := substatusItem
			var substatus v20220301s.InstanceViewStatus_STATUS
			err := substatusItem.AssignPropertiesToInstanceViewStatusSTATUS(&substatus)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Substatuses")
			}
			substatusList[substatusIndex] = substatus
		}
		destination.Substatuses = substatusList
	} else {
		destination.Substatuses = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(view.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(view.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachineHealthStatus_STATUS
type VirtualMachineHealthStatus_STATUS struct {
	PropertyBag genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Status      *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

// AssignPropertiesFromVirtualMachineHealthStatusSTATUS populates our VirtualMachineHealthStatus_STATUS from the provided source VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignPropertiesFromVirtualMachineHealthStatusSTATUS(source *v20220301s.VirtualMachineHealthStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Status
	if source.Status != nil {
		var statusLocal InstanceViewStatus_STATUS
		err := statusLocal.AssignPropertiesFromInstanceViewStatusSTATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Status")
		}
		status.Status = &statusLocal
	} else {
		status.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineHealthStatusSTATUS populates the provided destination VirtualMachineHealthStatus_STATUS from our VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignPropertiesToVirtualMachineHealthStatusSTATUS(destination *v20220301s.VirtualMachineHealthStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// Status
	if status.Status != nil {
		var statusLocal v20220301s.InstanceViewStatus_STATUS
		err := status.Status.AssignPropertiesToInstanceViewStatusSTATUS(&statusLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Status")
		}
		destination.Status = &statusLocal
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachinePatchStatus_STATUS
type VirtualMachinePatchStatus_STATUS struct {
	AvailablePatchSummary        *AvailablePatchSummary_STATUS        `json:"availablePatchSummary,omitempty"`
	ConfigurationStatuses        []InstanceViewStatus_STATUS          `json:"configurationStatuses,omitempty"`
	LastPatchInstallationSummary *LastPatchInstallationSummary_STATUS `json:"lastPatchInstallationSummary,omitempty"`
	PropertyBag                  genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromVirtualMachinePatchStatusSTATUS populates our VirtualMachinePatchStatus_STATUS from the provided source VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignPropertiesFromVirtualMachinePatchStatusSTATUS(source *v20220301s.VirtualMachinePatchStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AvailablePatchSummary
	if source.AvailablePatchSummary != nil {
		var availablePatchSummary AvailablePatchSummary_STATUS
		err := availablePatchSummary.AssignPropertiesFromAvailablePatchSummarySTATUS(source.AvailablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAvailablePatchSummarySTATUS() to populate field AvailablePatchSummary")
		}
		status.AvailablePatchSummary = &availablePatchSummary
	} else {
		status.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if source.ConfigurationStatuses != nil {
		configurationStatusList := make([]InstanceViewStatus_STATUS, len(source.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range source.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus InstanceViewStatus_STATUS
			err := configurationStatus.AssignPropertiesFromInstanceViewStatusSTATUS(&configurationStatusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		status.ConfigurationStatuses = configurationStatusList
	} else {
		status.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if source.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary LastPatchInstallationSummary_STATUS
		err := lastPatchInstallationSummary.AssignPropertiesFromLastPatchInstallationSummarySTATUS(source.LastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLastPatchInstallationSummarySTATUS() to populate field LastPatchInstallationSummary")
		}
		status.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		status.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinePatchStatusSTATUS populates the provided destination VirtualMachinePatchStatus_STATUS from our VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignPropertiesToVirtualMachinePatchStatusSTATUS(destination *v20220301s.VirtualMachinePatchStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// AvailablePatchSummary
	if status.AvailablePatchSummary != nil {
		var availablePatchSummary v20220301s.AvailablePatchSummary_STATUS
		err := status.AvailablePatchSummary.AssignPropertiesToAvailablePatchSummarySTATUS(&availablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAvailablePatchSummarySTATUS() to populate field AvailablePatchSummary")
		}
		destination.AvailablePatchSummary = &availablePatchSummary
	} else {
		destination.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if status.ConfigurationStatuses != nil {
		configurationStatusList := make([]v20220301s.InstanceViewStatus_STATUS, len(status.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range status.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus v20220301s.InstanceViewStatus_STATUS
			err := configurationStatusItem.AssignPropertiesToInstanceViewStatusSTATUS(&configurationStatus)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		destination.ConfigurationStatuses = configurationStatusList
	} else {
		destination.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if status.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary v20220301s.LastPatchInstallationSummary_STATUS
		err := status.LastPatchInstallationSummary.AssignPropertiesToLastPatchInstallationSummarySTATUS(&lastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLastPatchInstallationSummarySTATUS() to populate field LastPatchInstallationSummary")
		}
		destination.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		destination.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
type VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces struct {
	Primary     *bool                  `json:"primary,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces populates our VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces from the provided source VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
func (interfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) AssignPropertiesFromVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(source *v20220301s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		interfaces.Primary = &primary
	} else {
		interfaces.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		interfaces.Reference = &reference
	} else {
		interfaces.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		interfaces.PropertyBag = propertyBag
	} else {
		interfaces.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces populates the provided destination VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces from our VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
func (interfaces *VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) AssignPropertiesToVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(destination *v20220301s.VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(interfaces.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// Primary
	if interfaces.Primary != nil {
		primary := *interfaces.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if interfaces.Reference != nil {
		reference := interfaces.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.WindowsConfiguration
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WindowsConfiguration
type WindowsConfiguration struct {
	AdditionalUnattendContent []AdditionalUnattendContent `json:"additionalUnattendContent,omitempty"`
	EnableAutomaticUpdates    *bool                       `json:"enableAutomaticUpdates,omitempty"`
	PatchSettings             *PatchSettings              `json:"patchSettings,omitempty"`
	PropertyBag               genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	ProvisionVMAgent          *bool                       `json:"provisionVMAgent,omitempty"`
	TimeZone                  *string                     `json:"timeZone,omitempty"`
	WinRM                     *WinRMConfiguration         `json:"winRM,omitempty"`
}

// AssignPropertiesFromWindowsConfiguration populates our WindowsConfiguration from the provided source WindowsConfiguration
func (configuration *WindowsConfiguration) AssignPropertiesFromWindowsConfiguration(source *v20220301s.WindowsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent
			err := additionalUnattendContent.AssignPropertiesFromAdditionalUnattendContent(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromAdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings
		err := patchSetting.AssignPropertiesFromPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration
		err := winRM.AssignPropertiesFromWinRMConfiguration(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWinRMConfiguration() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWindowsConfiguration populates the provided destination WindowsConfiguration from our WindowsConfiguration
func (configuration *WindowsConfiguration) AssignPropertiesToWindowsConfiguration(destination *v20220301s.WindowsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]v20220301s.AdditionalUnattendContent, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent v20220301s.AdditionalUnattendContent
			err := additionalUnattendContentItem.AssignPropertiesToAdditionalUnattendContent(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToAdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20220301s.PatchSettings
		err := configuration.PatchSettings.AssignPropertiesToPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM v20220301s.WinRMConfiguration
		err := configuration.WinRM.AssignPropertiesToWinRMConfiguration(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWinRMConfiguration() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.WindowsConfiguration_STATUS
type WindowsConfiguration_STATUS struct {
	AdditionalUnattendContent []AdditionalUnattendContent_STATUS `json:"additionalUnattendContent,omitempty"`
	EnableAutomaticUpdates    *bool                              `json:"enableAutomaticUpdates,omitempty"`
	PatchSettings             *PatchSettings_STATUS              `json:"patchSettings,omitempty"`
	PropertyBag               genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProvisionVMAgent          *bool                              `json:"provisionVMAgent,omitempty"`
	TimeZone                  *string                            `json:"timeZone,omitempty"`
	WinRM                     *WinRMConfiguration_STATUS         `json:"winRM,omitempty"`
}

// AssignPropertiesFromWindowsConfigurationSTATUS populates our WindowsConfiguration_STATUS from the provided source WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignPropertiesFromWindowsConfigurationSTATUS(source *v20220301s.WindowsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent_STATUS, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent_STATUS
			err := additionalUnattendContent.AssignPropertiesFromAdditionalUnattendContentSTATUS(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromAdditionalUnattendContentSTATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings_STATUS
		err := patchSetting.AssignPropertiesFromPatchSettingsSTATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPatchSettingsSTATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration_STATUS
		err := winRM.AssignPropertiesFromWinRMConfigurationSTATUS(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromWinRMConfigurationSTATUS() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWindowsConfigurationSTATUS populates the provided destination WindowsConfiguration_STATUS from our WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignPropertiesToWindowsConfigurationSTATUS(destination *v20220301s.WindowsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]v20220301s.AdditionalUnattendContent_STATUS, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent v20220301s.AdditionalUnattendContent_STATUS
			err := additionalUnattendContentItem.AssignPropertiesToAdditionalUnattendContentSTATUS(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToAdditionalUnattendContentSTATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20220301s.PatchSettings_STATUS
		err := configuration.PatchSettings.AssignPropertiesToPatchSettingsSTATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPatchSettingsSTATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM v20220301s.WinRMConfiguration_STATUS
		err := configuration.WinRM.AssignPropertiesToWinRMConfigurationSTATUS(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToWinRMConfigurationSTATUS() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.AdditionalUnattendContent
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/AdditionalUnattendContent
type AdditionalUnattendContent struct {
	ComponentName *string                `json:"componentName,omitempty"`
	Content       *string                `json:"content,omitempty"`
	PassName      *string                `json:"passName,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SettingName   *string                `json:"settingName,omitempty"`
}

// AssignPropertiesFromAdditionalUnattendContent populates our AdditionalUnattendContent from the provided source AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignPropertiesFromAdditionalUnattendContent(source *v20220301s.AdditionalUnattendContent) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ComponentName
	content.ComponentName = genruntime.ClonePointerToString(source.ComponentName)

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	content.PassName = genruntime.ClonePointerToString(source.PassName)

	// SettingName
	content.SettingName = genruntime.ClonePointerToString(source.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		content.PropertyBag = propertyBag
	} else {
		content.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalUnattendContent populates the provided destination AdditionalUnattendContent from our AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignPropertiesToAdditionalUnattendContent(destination *v20220301s.AdditionalUnattendContent) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(content.PropertyBag)

	// ComponentName
	destination.ComponentName = genruntime.ClonePointerToString(content.ComponentName)

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	destination.PassName = genruntime.ClonePointerToString(content.PassName)

	// SettingName
	destination.SettingName = genruntime.ClonePointerToString(content.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.AdditionalUnattendContent_STATUS
type AdditionalUnattendContent_STATUS struct {
	ComponentName *string                `json:"componentName,omitempty"`
	Content       *string                `json:"content,omitempty"`
	PassName      *string                `json:"passName,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SettingName   *string                `json:"settingName,omitempty"`
}

// AssignPropertiesFromAdditionalUnattendContentSTATUS populates our AdditionalUnattendContent_STATUS from the provided source AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignPropertiesFromAdditionalUnattendContentSTATUS(source *v20220301s.AdditionalUnattendContent_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ComponentName
	content.ComponentName = genruntime.ClonePointerToString(source.ComponentName)

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	content.PassName = genruntime.ClonePointerToString(source.PassName)

	// SettingName
	content.SettingName = genruntime.ClonePointerToString(source.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		content.PropertyBag = propertyBag
	} else {
		content.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalUnattendContentSTATUS populates the provided destination AdditionalUnattendContent_STATUS from our AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignPropertiesToAdditionalUnattendContentSTATUS(destination *v20220301s.AdditionalUnattendContent_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(content.PropertyBag)

	// ComponentName
	destination.ComponentName = genruntime.ClonePointerToString(content.ComponentName)

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	destination.PassName = genruntime.ClonePointerToString(content.PassName)

	// SettingName
	destination.SettingName = genruntime.ClonePointerToString(content.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.AvailablePatchSummary_STATUS
type AvailablePatchSummary_STATUS struct {
	AssessmentActivityId          *string                `json:"assessmentActivityId,omitempty"`
	CriticalAndSecurityPatchCount *int                   `json:"criticalAndSecurityPatchCount,omitempty"`
	Error                         *ApiError_STATUS       `json:"error,omitempty"`
	LastModifiedTime              *string                `json:"lastModifiedTime,omitempty"`
	OtherPatchCount               *int                   `json:"otherPatchCount,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RebootPending                 *bool                  `json:"rebootPending,omitempty"`
	StartTime                     *string                `json:"startTime,omitempty"`
	Status                        *string                `json:"status,omitempty"`
}

// AssignPropertiesFromAvailablePatchSummarySTATUS populates our AvailablePatchSummary_STATUS from the provided source AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignPropertiesFromAvailablePatchSummarySTATUS(source *v20220301s.AvailablePatchSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentActivityId
	summary.AssessmentActivityId = genruntime.ClonePointerToString(source.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	summary.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(source.CriticalAndSecurityPatchCount)

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignPropertiesFromApiErrorSTATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiErrorSTATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// OtherPatchCount
	summary.OtherPatchCount = genruntime.ClonePointerToInt(source.OtherPatchCount)

	// RebootPending
	if source.RebootPending != nil {
		rebootPending := *source.RebootPending
		summary.RebootPending = &rebootPending
	} else {
		summary.RebootPending = nil
	}

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	summary.Status = genruntime.ClonePointerToString(source.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		summary.PropertyBag = propertyBag
	} else {
		summary.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAvailablePatchSummarySTATUS populates the provided destination AvailablePatchSummary_STATUS from our AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignPropertiesToAvailablePatchSummarySTATUS(destination *v20220301s.AvailablePatchSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(summary.PropertyBag)

	// AssessmentActivityId
	destination.AssessmentActivityId = genruntime.ClonePointerToString(summary.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	destination.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(summary.CriticalAndSecurityPatchCount)

	// Error
	if summary.Error != nil {
		var error v20220301s.ApiError_STATUS
		err := summary.Error.AssignPropertiesToApiErrorSTATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiErrorSTATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// OtherPatchCount
	destination.OtherPatchCount = genruntime.ClonePointerToInt(summary.OtherPatchCount)

	// RebootPending
	if summary.RebootPending != nil {
		rebootPending := *summary.RebootPending
		destination.RebootPending = &rebootPending
	} else {
		destination.RebootPending = nil
	}

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	destination.Status = genruntime.ClonePointerToString(summary.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DiffDiskSettings
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiffDiskSettings
type DiffDiskSettings struct {
	Option      *string                `json:"option,omitempty"`
	Placement   *string                `json:"placement,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDiffDiskSettings populates our DiffDiskSettings from the provided source DiffDiskSettings
func (settings *DiffDiskSettings) AssignPropertiesFromDiffDiskSettings(source *v20220301s.DiffDiskSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Option
	settings.Option = genruntime.ClonePointerToString(source.Option)

	// Placement
	settings.Placement = genruntime.ClonePointerToString(source.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiffDiskSettings populates the provided destination DiffDiskSettings from our DiffDiskSettings
func (settings *DiffDiskSettings) AssignPropertiesToDiffDiskSettings(destination *v20220301s.DiffDiskSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Option
	destination.Option = genruntime.ClonePointerToString(settings.Option)

	// Placement
	destination.Placement = genruntime.ClonePointerToString(settings.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DiffDiskSettings_STATUS
type DiffDiskSettings_STATUS struct {
	Option      *string                `json:"option,omitempty"`
	Placement   *string                `json:"placement,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDiffDiskSettingsSTATUS populates our DiffDiskSettings_STATUS from the provided source DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignPropertiesFromDiffDiskSettingsSTATUS(source *v20220301s.DiffDiskSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Option
	settings.Option = genruntime.ClonePointerToString(source.Option)

	// Placement
	settings.Placement = genruntime.ClonePointerToString(source.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiffDiskSettingsSTATUS populates the provided destination DiffDiskSettings_STATUS from our DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignPropertiesToDiffDiskSettingsSTATUS(destination *v20220301s.DiffDiskSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Option
	destination.Option = genruntime.ClonePointerToString(settings.Option)

	// Placement
	destination.Placement = genruntime.ClonePointerToString(settings.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DiskEncryptionSettings
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiskEncryptionSettings
type DiskEncryptionSettings struct {
	DiskEncryptionKey *KeyVaultSecretReference `json:"diskEncryptionKey,omitempty"`
	Enabled           *bool                    `json:"enabled,omitempty"`
	KeyEncryptionKey  *KeyVaultKeyReference    `json:"keyEncryptionKey,omitempty"`
	PropertyBag       genruntime.PropertyBag   `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDiskEncryptionSettings populates our DiskEncryptionSettings from the provided source DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignPropertiesFromDiskEncryptionSettings(source *v20220301s.DiskEncryptionSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference
		err := diskEncryptionKey.AssignPropertiesFromKeyVaultSecretReference(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference
		err := keyEncryptionKey.AssignPropertiesFromKeyVaultKeyReference(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSettings populates the provided destination DiskEncryptionSettings from our DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignPropertiesToDiskEncryptionSettings(destination *v20220301s.DiskEncryptionSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey v20220301s.KeyVaultSecretReference
		err := settings.DiskEncryptionKey.AssignPropertiesToKeyVaultSecretReference(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey v20220301s.KeyVaultKeyReference
		err := settings.KeyEncryptionKey.AssignPropertiesToKeyVaultKeyReference(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DiskEncryptionSettings_STATUS
type DiskEncryptionSettings_STATUS struct {
	DiskEncryptionKey *KeyVaultSecretReference_STATUS `json:"diskEncryptionKey,omitempty"`
	Enabled           *bool                           `json:"enabled,omitempty"`
	KeyEncryptionKey  *KeyVaultKeyReference_STATUS    `json:"keyEncryptionKey,omitempty"`
	PropertyBag       genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDiskEncryptionSettingsSTATUS populates our DiskEncryptionSettings_STATUS from the provided source DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignPropertiesFromDiskEncryptionSettingsSTATUS(source *v20220301s.DiskEncryptionSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference_STATUS
		err := diskEncryptionKey.AssignPropertiesFromKeyVaultSecretReferenceSTATUS(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultSecretReferenceSTATUS() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference_STATUS
		err := keyEncryptionKey.AssignPropertiesFromKeyVaultKeyReferenceSTATUS(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultKeyReferenceSTATUS() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSettingsSTATUS populates the provided destination DiskEncryptionSettings_STATUS from our DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignPropertiesToDiskEncryptionSettingsSTATUS(destination *v20220301s.DiskEncryptionSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey v20220301s.KeyVaultSecretReference_STATUS
		err := settings.DiskEncryptionKey.AssignPropertiesToKeyVaultSecretReferenceSTATUS(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultSecretReferenceSTATUS() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey v20220301s.KeyVaultKeyReference_STATUS
		err := settings.KeyEncryptionKey.AssignPropertiesToKeyVaultKeyReferenceSTATUS(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultKeyReferenceSTATUS() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.LastPatchInstallationSummary_STATUS
type LastPatchInstallationSummary_STATUS struct {
	Error                     *ApiError_STATUS       `json:"error,omitempty"`
	ExcludedPatchCount        *int                   `json:"excludedPatchCount,omitempty"`
	FailedPatchCount          *int                   `json:"failedPatchCount,omitempty"`
	InstallationActivityId    *string                `json:"installationActivityId,omitempty"`
	InstalledPatchCount       *int                   `json:"installedPatchCount,omitempty"`
	LastModifiedTime          *string                `json:"lastModifiedTime,omitempty"`
	MaintenanceWindowExceeded *bool                  `json:"maintenanceWindowExceeded,omitempty"`
	NotSelectedPatchCount     *int                   `json:"notSelectedPatchCount,omitempty"`
	PendingPatchCount         *int                   `json:"pendingPatchCount,omitempty"`
	PropertyBag               genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StartTime                 *string                `json:"startTime,omitempty"`
	Status                    *string                `json:"status,omitempty"`
}

// AssignPropertiesFromLastPatchInstallationSummarySTATUS populates our LastPatchInstallationSummary_STATUS from the provided source LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignPropertiesFromLastPatchInstallationSummarySTATUS(source *v20220301s.LastPatchInstallationSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignPropertiesFromApiErrorSTATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiErrorSTATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// ExcludedPatchCount
	summary.ExcludedPatchCount = genruntime.ClonePointerToInt(source.ExcludedPatchCount)

	// FailedPatchCount
	summary.FailedPatchCount = genruntime.ClonePointerToInt(source.FailedPatchCount)

	// InstallationActivityId
	summary.InstallationActivityId = genruntime.ClonePointerToString(source.InstallationActivityId)

	// InstalledPatchCount
	summary.InstalledPatchCount = genruntime.ClonePointerToInt(source.InstalledPatchCount)

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// MaintenanceWindowExceeded
	if source.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *source.MaintenanceWindowExceeded
		summary.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		summary.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	summary.NotSelectedPatchCount = genruntime.ClonePointerToInt(source.NotSelectedPatchCount)

	// PendingPatchCount
	summary.PendingPatchCount = genruntime.ClonePointerToInt(source.PendingPatchCount)

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	summary.Status = genruntime.ClonePointerToString(source.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		summary.PropertyBag = propertyBag
	} else {
		summary.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLastPatchInstallationSummarySTATUS populates the provided destination LastPatchInstallationSummary_STATUS from our LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignPropertiesToLastPatchInstallationSummarySTATUS(destination *v20220301s.LastPatchInstallationSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(summary.PropertyBag)

	// Error
	if summary.Error != nil {
		var error v20220301s.ApiError_STATUS
		err := summary.Error.AssignPropertiesToApiErrorSTATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiErrorSTATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// ExcludedPatchCount
	destination.ExcludedPatchCount = genruntime.ClonePointerToInt(summary.ExcludedPatchCount)

	// FailedPatchCount
	destination.FailedPatchCount = genruntime.ClonePointerToInt(summary.FailedPatchCount)

	// InstallationActivityId
	destination.InstallationActivityId = genruntime.ClonePointerToString(summary.InstallationActivityId)

	// InstalledPatchCount
	destination.InstalledPatchCount = genruntime.ClonePointerToInt(summary.InstalledPatchCount)

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// MaintenanceWindowExceeded
	if summary.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *summary.MaintenanceWindowExceeded
		destination.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		destination.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	destination.NotSelectedPatchCount = genruntime.ClonePointerToInt(summary.NotSelectedPatchCount)

	// PendingPatchCount
	destination.PendingPatchCount = genruntime.ClonePointerToInt(summary.PendingPatchCount)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	destination.Status = genruntime.ClonePointerToString(summary.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.LinuxPatchSettings
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/LinuxPatchSettings
type LinuxPatchSettings struct {
	PatchMode   *string                `json:"patchMode,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromLinuxPatchSettings populates our LinuxPatchSettings from the provided source LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignPropertiesFromLinuxPatchSettings(source *v20220301s.LinuxPatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if source.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *source.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *source.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxPatchSettings populates the provided destination LinuxPatchSettings from our LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignPropertiesToLinuxPatchSettings(destination *v20220301s.LinuxPatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.LinuxPatchSettings_STATUS
type LinuxPatchSettings_STATUS struct {
	PatchMode   *string                `json:"patchMode,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromLinuxPatchSettingsSTATUS populates our LinuxPatchSettings_STATUS from the provided source LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignPropertiesFromLinuxPatchSettingsSTATUS(source *v20220301s.LinuxPatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if source.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *source.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *source.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxPatchSettingsSTATUS populates the provided destination LinuxPatchSettings_STATUS from our LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignPropertiesToLinuxPatchSettingsSTATUS(destination *v20220301s.LinuxPatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.ManagedDiskParameters
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ManagedDiskParameters
type ManagedDiskParameters struct {
	DiskEncryptionSet *DiskEncryptionSetParameters `json:"diskEncryptionSet,omitempty"`
	PropertyBag       genruntime.PropertyBag       `json:"$propertyBag,omitempty"`

	// Reference: Resource Id
	Reference          *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	StorageAccountType *string                       `json:"storageAccountType,omitempty"`
}

// AssignPropertiesFromManagedDiskParameters populates our ManagedDiskParameters from the provided source ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignPropertiesFromManagedDiskParameters(source *v20220301s.ManagedDiskParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSetParametersStash v20210701s.DiskEncryptionSetParameters
		err := diskEncryptionSetParametersStash.AssignPropertiesFromDiskEncryptionSetParameters(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSetParameters() to populate field DiskEncryptionSetParametersStash from DiskEncryptionSet")
		}
		var diskEncryptionSet DiskEncryptionSetParameters
		err = diskEncryptionSet.AssignPropertiesFromDiskEncryptionSetParameters(&diskEncryptionSetParametersStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDiskEncryptionSetParameters() to populate field DiskEncryptionSet from DiskEncryptionSetParametersStash")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		parameters.Reference = &reference
	} else {
		parameters.Reference = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		propertyBag.Add("SecurityProfile", *source.SecurityProfile)
	} else {
		propertyBag.Remove("SecurityProfile")
	}

	// StorageAccountType
	parameters.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedDiskParameters populates the provided destination ManagedDiskParameters from our ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignPropertiesToManagedDiskParameters(destination *v20220301s.ManagedDiskParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSetParametersStash v20210701s.DiskEncryptionSetParameters
		err := parameters.DiskEncryptionSet.AssignPropertiesToDiskEncryptionSetParameters(&diskEncryptionSetParametersStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSetParameters() to populate field DiskEncryptionSetParametersStash from DiskEncryptionSet")
		}
		var diskEncryptionSet v20220301s.DiskEncryptionSetParameters
		err = diskEncryptionSetParametersStash.AssignPropertiesToDiskEncryptionSetParameters(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDiskEncryptionSetParameters() to populate field DiskEncryptionSet from DiskEncryptionSetParametersStash")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Reference
	if parameters.Reference != nil {
		reference := parameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// SecurityProfile
	if propertyBag.Contains("SecurityProfile") {
		var securityProfile v20220301s.VMDiskSecurityProfile
		err := propertyBag.Pull("SecurityProfile", &securityProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'SecurityProfile' from propertyBag")
		}

		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(parameters.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.ManagedDiskParameters_STATUS
type ManagedDiskParameters_STATUS struct {
	DiskEncryptionSet  *SubResource_STATUS    `json:"diskEncryptionSet,omitempty"`
	Id                 *string                `json:"id,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageAccountType *string                `json:"storageAccountType,omitempty"`
}

// AssignPropertiesFromManagedDiskParametersSTATUS populates our ManagedDiskParameters_STATUS from the provided source ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignPropertiesFromManagedDiskParametersSTATUS(source *v20220301s.ManagedDiskParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from DiskEncryptionSet")
		}
		var diskEncryptionSet SubResource_STATUS
		err = diskEncryptionSet.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field DiskEncryptionSet from SubResource_STATUSStash")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Id
	parameters.Id = genruntime.ClonePointerToString(source.Id)

	// SecurityProfile
	if source.SecurityProfile != nil {
		propertyBag.Add("SecurityProfile", *source.SecurityProfile)
	} else {
		propertyBag.Remove("SecurityProfile")
	}

	// StorageAccountType
	parameters.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedDiskParametersSTATUS populates the provided destination ManagedDiskParameters_STATUS from our ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignPropertiesToManagedDiskParametersSTATUS(destination *v20220301s.ManagedDiskParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := parameters.DiskEncryptionSet.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from DiskEncryptionSet")
		}
		var diskEncryptionSet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field DiskEncryptionSet from SubResource_STATUSStash")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(parameters.Id)

	// SecurityProfile
	if propertyBag.Contains("SecurityProfile") {
		var securityProfile v20220301s.VMDiskSecurityProfile_STATUS
		err := propertyBag.Pull("SecurityProfile", &securityProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'SecurityProfile' from propertyBag")
		}

		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(parameters.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.PatchSettings
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/PatchSettings
type PatchSettings struct {
	EnableHotpatching *bool                  `json:"enableHotpatching,omitempty"`
	PatchMode         *string                `json:"patchMode,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromPatchSettings populates our PatchSettings from the provided source PatchSettings
func (settings *PatchSettings) AssignPropertiesFromPatchSettings(source *v20220301s.PatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if source.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *source.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *source.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPatchSettings populates the provided destination PatchSettings from our PatchSettings
func (settings *PatchSettings) AssignPropertiesToPatchSettings(destination *v20220301s.PatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.PatchSettings_STATUS
type PatchSettings_STATUS struct {
	EnableHotpatching *bool                  `json:"enableHotpatching,omitempty"`
	PatchMode         *string                `json:"patchMode,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromPatchSettingsSTATUS populates our PatchSettings_STATUS from the provided source PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignPropertiesFromPatchSettingsSTATUS(source *v20220301s.PatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if source.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *source.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *source.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPatchSettingsSTATUS populates the provided destination PatchSettings_STATUS from our PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignPropertiesToPatchSettingsSTATUS(destination *v20220301s.PatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.SshConfiguration
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SshConfiguration
type SshConfiguration struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	PublicKeys  []SshPublicKey         `json:"publicKeys,omitempty"`
}

// AssignPropertiesFromSshConfiguration populates our SshConfiguration from the provided source SshConfiguration
func (configuration *SshConfiguration) AssignPropertiesFromSshConfiguration(source *v20220301s.SshConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey
			err := publicKey.AssignPropertiesFromSshPublicKey(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshConfiguration populates the provided destination SshConfiguration from our SshConfiguration
func (configuration *SshConfiguration) AssignPropertiesToSshConfiguration(destination *v20220301s.SshConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v20220301s.SshPublicKey, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v20220301s.SshPublicKey
			err := publicKeyItem.AssignPropertiesToSshPublicKey(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.SshConfiguration_STATUS
type SshConfiguration_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	PublicKeys  []SshPublicKey_STATUS  `json:"publicKeys,omitempty"`
}

// AssignPropertiesFromSshConfigurationSTATUS populates our SshConfiguration_STATUS from the provided source SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignPropertiesFromSshConfigurationSTATUS(source *v20220301s.SshConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey_STATUS, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey_STATUS
			err := publicKey.AssignPropertiesFromSshPublicKeySTATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSshPublicKeySTATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshConfigurationSTATUS populates the provided destination SshConfiguration_STATUS from our SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignPropertiesToSshConfigurationSTATUS(destination *v20220301s.SshConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v20220301s.SshPublicKey_STATUS, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v20220301s.SshPublicKey_STATUS
			err := publicKeyItem.AssignPropertiesToSshPublicKeySTATUS(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSshPublicKeySTATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VaultCertificate
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VaultCertificate
type VaultCertificate struct {
	CertificateStore *string                `json:"certificateStore,omitempty"`
	CertificateUrl   *string                `json:"certificateUrl,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromVaultCertificate populates our VaultCertificate from the provided source VaultCertificate
func (certificate *VaultCertificate) AssignPropertiesFromVaultCertificate(source *v20220301s.VaultCertificate) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		certificate.PropertyBag = propertyBag
	} else {
		certificate.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultCertificate populates the provided destination VaultCertificate from our VaultCertificate
func (certificate *VaultCertificate) AssignPropertiesToVaultCertificate(destination *v20220301s.VaultCertificate) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(certificate.PropertyBag)

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VaultCertificate_STATUS
type VaultCertificate_STATUS struct {
	CertificateStore *string                `json:"certificateStore,omitempty"`
	CertificateUrl   *string                `json:"certificateUrl,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromVaultCertificateSTATUS populates our VaultCertificate_STATUS from the provided source VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignPropertiesFromVaultCertificateSTATUS(source *v20220301s.VaultCertificate_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		certificate.PropertyBag = propertyBag
	} else {
		certificate.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultCertificateSTATUS populates the provided destination VaultCertificate_STATUS from our VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignPropertiesToVaultCertificateSTATUS(destination *v20220301s.VaultCertificate_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(certificate.PropertyBag)

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualHardDisk
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualHardDisk
type VirtualHardDisk struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Uri         *string                `json:"uri,omitempty"`
}

// AssignPropertiesFromVirtualHardDisk populates our VirtualHardDisk from the provided source VirtualHardDisk
func (disk *VirtualHardDisk) AssignPropertiesFromVirtualHardDisk(source *v20220301s.VirtualHardDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualHardDisk populates the provided destination VirtualHardDisk from our VirtualHardDisk
func (disk *VirtualHardDisk) AssignPropertiesToVirtualHardDisk(destination *v20220301s.VirtualHardDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualHardDisk_STATUS
type VirtualHardDisk_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Uri         *string                `json:"uri,omitempty"`
}

// AssignPropertiesFromVirtualHardDiskSTATUS populates our VirtualHardDisk_STATUS from the provided source VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignPropertiesFromVirtualHardDiskSTATUS(source *v20220301s.VirtualHardDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualHardDiskSTATUS populates the provided destination VirtualHardDisk_STATUS from our VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignPropertiesToVirtualHardDiskSTATUS(destination *v20220301s.VirtualHardDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.VirtualMachineExtensionHandlerInstanceView_STATUS
type VirtualMachineExtensionHandlerInstanceView_STATUS struct {
	PropertyBag        genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Status             *InstanceViewStatus_STATUS `json:"status,omitempty"`
	Type               *string                    `json:"type,omitempty"`
	TypeHandlerVersion *string                    `json:"typeHandlerVersion,omitempty"`
}

// AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewSTATUS populates our VirtualMachineExtensionHandlerInstanceView_STATUS from the provided source VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignPropertiesFromVirtualMachineExtensionHandlerInstanceViewSTATUS(source *v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignPropertiesFromInstanceViewStatusSTATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInstanceViewStatusSTATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// Type
	view.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	view.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewSTATUS populates the provided destination VirtualMachineExtensionHandlerInstanceView_STATUS from our VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignPropertiesToVirtualMachineExtensionHandlerInstanceViewSTATUS(destination *v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// Status
	if view.Status != nil {
		var status v20220301s.InstanceViewStatus_STATUS
		err := view.Status.AssignPropertiesToInstanceViewStatusSTATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInstanceViewStatusSTATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(view.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(view.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.WinRMConfiguration
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WinRMConfiguration
type WinRMConfiguration struct {
	Listeners   []WinRMListener        `json:"listeners,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromWinRMConfiguration populates our WinRMConfiguration from the provided source WinRMConfiguration
func (configuration *WinRMConfiguration) AssignPropertiesFromWinRMConfiguration(source *v20220301s.WinRMConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener
			err := listener.AssignPropertiesFromWinRMListener(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromWinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMConfiguration populates the provided destination WinRMConfiguration from our WinRMConfiguration
func (configuration *WinRMConfiguration) AssignPropertiesToWinRMConfiguration(destination *v20220301s.WinRMConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]v20220301s.WinRMListener, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener v20220301s.WinRMListener
			err := listenerItem.AssignPropertiesToWinRMListener(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToWinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.WinRMConfiguration_STATUS
type WinRMConfiguration_STATUS struct {
	Listeners   []WinRMListener_STATUS `json:"listeners,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromWinRMConfigurationSTATUS populates our WinRMConfiguration_STATUS from the provided source WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignPropertiesFromWinRMConfigurationSTATUS(source *v20220301s.WinRMConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener_STATUS, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener_STATUS
			err := listener.AssignPropertiesFromWinRMListenerSTATUS(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromWinRMListenerSTATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMConfigurationSTATUS populates the provided destination WinRMConfiguration_STATUS from our WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignPropertiesToWinRMConfigurationSTATUS(destination *v20220301s.WinRMConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]v20220301s.WinRMListener_STATUS, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener v20220301s.WinRMListener_STATUS
			err := listenerItem.AssignPropertiesToWinRMListenerSTATUS(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToWinRMListenerSTATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.ApiError_STATUS
type ApiError_STATUS struct {
	Code        *string                `json:"code,omitempty"`
	Details     []ApiErrorBase_STATUS  `json:"details,omitempty"`
	Innererror  *InnerError_STATUS     `json:"innererror,omitempty"`
	Message     *string                `json:"message,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Target      *string                `json:"target,omitempty"`
}

// AssignPropertiesFromApiErrorSTATUS populates our ApiError_STATUS from the provided source ApiError_STATUS
func (error *ApiError_STATUS) AssignPropertiesFromApiErrorSTATUS(source *v20220301s.ApiError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ApiErrorBase_STATUS, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ApiErrorBase_STATUS
			err := detail.AssignPropertiesFromApiErrorBaseSTATUS(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApiErrorBaseSTATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		error.Details = detailList
	} else {
		error.Details = nil
	}

	// Innererror
	if source.Innererror != nil {
		var innererror InnerError_STATUS
		err := innererror.AssignPropertiesFromInnerErrorSTATUS(source.Innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromInnerErrorSTATUS() to populate field Innererror")
		}
		error.Innererror = &innererror
	} else {
		error.Innererror = nil
	}

	// Message
	error.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	error.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApiErrorSTATUS populates the provided destination ApiError_STATUS from our ApiError_STATUS
func (error *ApiError_STATUS) AssignPropertiesToApiErrorSTATUS(destination *v20220301s.ApiError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// Details
	if error.Details != nil {
		detailList := make([]v20220301s.ApiErrorBase_STATUS, len(error.Details))
		for detailIndex, detailItem := range error.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail v20220301s.ApiErrorBase_STATUS
			err := detailItem.AssignPropertiesToApiErrorBaseSTATUS(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApiErrorBaseSTATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Innererror
	if error.Innererror != nil {
		var innererror v20220301s.InnerError_STATUS
		err := error.Innererror.AssignPropertiesToInnerErrorSTATUS(&innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToInnerErrorSTATUS() to populate field Innererror")
		}
		destination.Innererror = &innererror
	} else {
		destination.Innererror = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(error.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(error.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.DiskEncryptionSetParameters
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiskEncryptionSetParameters
type DiskEncryptionSetParameters struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromDiskEncryptionSetParameters populates our DiskEncryptionSetParameters from the provided source DiskEncryptionSetParameters
func (parameters *DiskEncryptionSetParameters) AssignPropertiesFromDiskEncryptionSetParameters(source *v20210701s.DiskEncryptionSetParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		parameters.Reference = &reference
	} else {
		parameters.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSetParameters populates the provided destination DiskEncryptionSetParameters from our DiskEncryptionSetParameters
func (parameters *DiskEncryptionSetParameters) AssignPropertiesToDiskEncryptionSetParameters(destination *v20210701s.DiskEncryptionSetParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Reference
	if parameters.Reference != nil {
		reference := parameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.KeyVaultKeyReference
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/KeyVaultKeyReference
type KeyVaultKeyReference struct {
	KeyUrl      *string                `json:"keyUrl,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault *SubResource           `json:"sourceVault,omitempty"`
}

// AssignPropertiesFromKeyVaultKeyReference populates our KeyVaultKeyReference from the provided source KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignPropertiesFromKeyVaultKeyReference(source *v20220301s.KeyVaultKeyReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault SubResource
		err = sourceVault.AssignPropertiesFromSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SourceVault from SubResourceStash")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultKeyReference populates the provided destination KeyVaultKeyReference from our KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignPropertiesToKeyVaultKeyReference(destination *v20220301s.KeyVaultKeyReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := reference.SourceVault.AssignPropertiesToSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource
		err = subResourceStash.AssignPropertiesToSubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SourceVault from SubResourceStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.KeyVaultKeyReference_STATUS
type KeyVaultKeyReference_STATUS struct {
	KeyUrl      *string                `json:"keyUrl,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault *SubResource_STATUS    `json:"sourceVault,omitempty"`
}

// AssignPropertiesFromKeyVaultKeyReferenceSTATUS populates our KeyVaultKeyReference_STATUS from the provided source KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignPropertiesFromKeyVaultKeyReferenceSTATUS(source *v20220301s.KeyVaultKeyReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault SubResource_STATUS
		err = sourceVault.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultKeyReferenceSTATUS populates the provided destination KeyVaultKeyReference_STATUS from our KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignPropertiesToKeyVaultKeyReferenceSTATUS(destination *v20220301s.KeyVaultKeyReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := reference.SourceVault.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.KeyVaultSecretReference
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/KeyVaultSecretReference
type KeyVaultSecretReference struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretUrl   *string                `json:"secretUrl,omitempty"`
	SourceVault *SubResource           `json:"sourceVault,omitempty"`
}

// AssignPropertiesFromKeyVaultSecretReference populates our KeyVaultSecretReference from the provided source KeyVaultSecretReference
func (reference *KeyVaultSecretReference) AssignPropertiesFromKeyVaultSecretReference(source *v20220301s.KeyVaultSecretReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretUrl
	reference.SecretUrl = genruntime.ClonePointerToString(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault SubResource
		err = sourceVault.AssignPropertiesFromSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field SourceVault from SubResourceStash")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSecretReference populates the provided destination KeyVaultSecretReference from our KeyVaultSecretReference
func (reference *KeyVaultSecretReference) AssignPropertiesToKeyVaultSecretReference(destination *v20220301s.KeyVaultSecretReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// SecretUrl
	destination.SecretUrl = genruntime.ClonePointerToString(reference.SecretUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := reference.SourceVault.AssignPropertiesToSubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource
		err = subResourceStash.AssignPropertiesToSubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field SourceVault from SubResourceStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.KeyVaultSecretReference_STATUS
type KeyVaultSecretReference_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretUrl   *string                `json:"secretUrl,omitempty"`
	SourceVault *SubResource_STATUS    `json:"sourceVault,omitempty"`
}

// AssignPropertiesFromKeyVaultSecretReferenceSTATUS populates our KeyVaultSecretReference_STATUS from the provided source KeyVaultSecretReference_STATUS
func (reference *KeyVaultSecretReference_STATUS) AssignPropertiesFromKeyVaultSecretReferenceSTATUS(source *v20220301s.KeyVaultSecretReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretUrl
	reference.SecretUrl = genruntime.ClonePointerToString(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignPropertiesFromSubResourceSTATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault SubResource_STATUS
		err = sourceVault.AssignPropertiesFromSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResourceSTATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSecretReferenceSTATUS populates the provided destination KeyVaultSecretReference_STATUS from our KeyVaultSecretReference_STATUS
func (reference *KeyVaultSecretReference_STATUS) AssignPropertiesToKeyVaultSecretReferenceSTATUS(destination *v20220301s.KeyVaultSecretReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// SecretUrl
	destination.SecretUrl = genruntime.ClonePointerToString(reference.SecretUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := reference.SourceVault.AssignPropertiesToSubResourceSTATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignPropertiesToSubResourceSTATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResourceSTATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.SshPublicKey
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SshPublicKey
type SshPublicKey struct {
	KeyData     *string                `json:"keyData,omitempty"`
	Path        *string                `json:"path,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromSshPublicKey populates our SshPublicKey from the provided source SshPublicKey
func (publicKey *SshPublicKey) AssignPropertiesFromSshPublicKey(source *v20220301s.SshPublicKey) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		publicKey.PropertyBag = propertyBag
	} else {
		publicKey.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshPublicKey populates the provided destination SshPublicKey from our SshPublicKey
func (publicKey *SshPublicKey) AssignPropertiesToSshPublicKey(destination *v20220301s.SshPublicKey) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(publicKey.PropertyBag)

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.SshPublicKey_STATUS
type SshPublicKey_STATUS struct {
	KeyData     *string                `json:"keyData,omitempty"`
	Path        *string                `json:"path,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromSshPublicKeySTATUS populates our SshPublicKey_STATUS from the provided source SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignPropertiesFromSshPublicKeySTATUS(source *v20220301s.SshPublicKey_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		publicKey.PropertyBag = propertyBag
	} else {
		publicKey.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshPublicKeySTATUS populates the provided destination SshPublicKey_STATUS from our SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignPropertiesToSshPublicKeySTATUS(destination *v20220301s.SshPublicKey_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(publicKey.PropertyBag)

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.WinRMListener
// Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WinRMListener
type WinRMListener struct {
	CertificateUrl *string                `json:"certificateUrl,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol       *string                `json:"protocol,omitempty"`
}

// AssignPropertiesFromWinRMListener populates our WinRMListener from the provided source WinRMListener
func (listener *WinRMListener) AssignPropertiesFromWinRMListener(source *v20220301s.WinRMListener) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	listener.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		listener.PropertyBag = propertyBag
	} else {
		listener.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMListener populates the provided destination WinRMListener from our WinRMListener
func (listener *WinRMListener) AssignPropertiesToWinRMListener(destination *v20220301s.WinRMListener) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(listener.PropertyBag)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(listener.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.WinRMListener_STATUS
type WinRMListener_STATUS struct {
	CertificateUrl *string                `json:"certificateUrl,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol       *string                `json:"protocol,omitempty"`
}

// AssignPropertiesFromWinRMListenerSTATUS populates our WinRMListener_STATUS from the provided source WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignPropertiesFromWinRMListenerSTATUS(source *v20220301s.WinRMListener_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	listener.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		listener.PropertyBag = propertyBag
	} else {
		listener.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMListenerSTATUS populates the provided destination WinRMListener_STATUS from our WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignPropertiesToWinRMListenerSTATUS(destination *v20220301s.WinRMListener_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(listener.PropertyBag)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(listener.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.ApiErrorBase_STATUS
type ApiErrorBase_STATUS struct {
	Code        *string                `json:"code,omitempty"`
	Message     *string                `json:"message,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Target      *string                `json:"target,omitempty"`
}

// AssignPropertiesFromApiErrorBaseSTATUS populates our ApiErrorBase_STATUS from the provided source ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignPropertiesFromApiErrorBaseSTATUS(source *v20220301s.ApiErrorBase_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	base.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	base.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	base.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		base.PropertyBag = propertyBag
	} else {
		base.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApiErrorBaseSTATUS populates the provided destination ApiErrorBase_STATUS from our ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignPropertiesToApiErrorBaseSTATUS(destination *v20220301s.ApiErrorBase_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(base.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(base.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(base.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(base.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1beta20201201.InnerError_STATUS
type InnerError_STATUS struct {
	Errordetail   *string                `json:"errordetail,omitempty"`
	Exceptiontype *string                `json:"exceptiontype,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromInnerErrorSTATUS populates our InnerError_STATUS from the provided source InnerError_STATUS
func (error *InnerError_STATUS) AssignPropertiesFromInnerErrorSTATUS(source *v20220301s.InnerError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Errordetail
	error.Errordetail = genruntime.ClonePointerToString(source.Errordetail)

	// Exceptiontype
	error.Exceptiontype = genruntime.ClonePointerToString(source.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInnerErrorSTATUS populates the provided destination InnerError_STATUS from our InnerError_STATUS
func (error *InnerError_STATUS) AssignPropertiesToInnerErrorSTATUS(destination *v20220301s.InnerError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// Errordetail
	destination.Errordetail = genruntime.ClonePointerToString(error.Errordetail)

	// Exceptiontype
	destination.Exceptiontype = genruntime.ClonePointerToString(error.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&VirtualMachine{}, &VirtualMachineList{})
}
