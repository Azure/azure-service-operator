// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine runs a test to see if a specific instance of VirtualMachine round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine(subject VirtualMachine) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine instances for property testing - lazily instantiated by VirtualMachineGenerator()
var virtualMachineGenerator gopter.Gen

// VirtualMachineGenerator returns a generator of VirtualMachine instances for property testing.
func VirtualMachineGenerator() gopter.Gen {
	if virtualMachineGenerator != nil {
		return virtualMachineGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachine(generators)
	virtualMachineGenerator = gen.Struct(reflect.TypeOf(VirtualMachine{}), generators)

	return virtualMachineGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachine is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualMachinesSPECGenerator()
	gens["Status"] = VirtualMachineStatusGenerator()
}

func Test_VirtualMachine_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineStatus, VirtualMachineStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineStatus runs a test to see if a specific instance of VirtualMachine_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineStatus(subject VirtualMachine_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_Status instances for property testing - lazily instantiated by
//VirtualMachineStatusGenerator()
var virtualMachineStatusGenerator gopter.Gen

// VirtualMachineStatusGenerator returns a generator of VirtualMachine_Status instances for property testing.
// We first initialize virtualMachineStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineStatusGenerator() gopter.Gen {
	if virtualMachineStatusGenerator != nil {
		return virtualMachineStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineStatus(generators)
	virtualMachineStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineStatus(generators)
	virtualMachineStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	return virtualMachineStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineStatus(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineStatus(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesStatusGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileStatusGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileStatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileStatusGenerator())
	gens["Host"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentityStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceViewStatusGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileStatusGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileStatusGenerator())
	gens["Plan"] = gen.PtrOf(PlanStatusGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Resources"] = gen.SliceOf(VirtualMachineExtensionStatusGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileStatusGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileStatusGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_VirtualMachines_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSPEC, VirtualMachinesSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSPEC runs a test to see if a specific instance of VirtualMachines_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSPEC(subject VirtualMachines_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_SPEC instances for property testing - lazily instantiated by
//VirtualMachinesSPECGenerator()
var virtualMachinesSPECGenerator gopter.Gen

// VirtualMachinesSPECGenerator returns a generator of VirtualMachines_SPEC instances for property testing.
// We first initialize virtualMachinesSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSPECGenerator() gopter.Gen {
	if virtualMachinesSPECGenerator != nil {
		return virtualMachinesSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSPEC(generators)
	virtualMachinesSPECGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSPEC(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSPEC(generators)
	virtualMachinesSPECGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPEC{}), generators)

	return virtualMachinesSPECGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSPEC(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesSpecGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileSpecGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileSpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSpecGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileSpecGenerator())
	gens["Host"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentitySpecGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileSpecGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileSpecGenerator())
	gens["Plan"] = gen.PtrOf(PlanSpecGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileSpecGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileSpecGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_AdditionalCapabilities_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilitiesSpec, AdditionalCapabilitiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilitiesSpec runs a test to see if a specific instance of AdditionalCapabilities_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilitiesSpec(subject AdditionalCapabilities_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Spec instances for property testing - lazily instantiated by
//AdditionalCapabilitiesSpecGenerator()
var additionalCapabilitiesSpecGenerator gopter.Gen

// AdditionalCapabilitiesSpecGenerator returns a generator of AdditionalCapabilities_Spec instances for property testing.
func AdditionalCapabilitiesSpecGenerator() gopter.Gen {
	if additionalCapabilitiesSpecGenerator != nil {
		return additionalCapabilitiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilitiesSpec(generators)
	additionalCapabilitiesSpecGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Spec{}), generators)

	return additionalCapabilitiesSpecGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilitiesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilitiesSpec(gens map[string]gopter.Gen) {
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_AdditionalCapabilities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilitiesStatus, AdditionalCapabilitiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilitiesStatus runs a test to see if a specific instance of AdditionalCapabilities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilitiesStatus(subject AdditionalCapabilities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Status instances for property testing - lazily instantiated by
//AdditionalCapabilitiesStatusGenerator()
var additionalCapabilitiesStatusGenerator gopter.Gen

// AdditionalCapabilitiesStatusGenerator returns a generator of AdditionalCapabilities_Status instances for property testing.
func AdditionalCapabilitiesStatusGenerator() gopter.Gen {
	if additionalCapabilitiesStatusGenerator != nil {
		return additionalCapabilitiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus(generators)
	additionalCapabilitiesStatusGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Status{}), generators)

	return additionalCapabilitiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus(gens map[string]gopter.Gen) {
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_BillingProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileSpec, BillingProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileSpec runs a test to see if a specific instance of BillingProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileSpec(subject BillingProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Spec instances for property testing - lazily instantiated by BillingProfileSpecGenerator()
var billingProfileSpecGenerator gopter.Gen

// BillingProfileSpecGenerator returns a generator of BillingProfile_Spec instances for property testing.
func BillingProfileSpecGenerator() gopter.Gen {
	if billingProfileSpecGenerator != nil {
		return billingProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileSpec(generators)
	billingProfileSpecGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Spec{}), generators)

	return billingProfileSpecGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileSpec(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_BillingProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileStatus, BillingProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileStatus runs a test to see if a specific instance of BillingProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileStatus(subject BillingProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Status instances for property testing - lazily instantiated by
//BillingProfileStatusGenerator()
var billingProfileStatusGenerator gopter.Gen

// BillingProfileStatusGenerator returns a generator of BillingProfile_Status instances for property testing.
func BillingProfileStatusGenerator() gopter.Gen {
	if billingProfileStatusGenerator != nil {
		return billingProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileStatus(generators)
	billingProfileStatusGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Status{}), generators)

	return billingProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileStatus(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileSpec, DiagnosticsProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileSpec runs a test to see if a specific instance of DiagnosticsProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileSpec(subject DiagnosticsProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Spec instances for property testing - lazily instantiated by
//DiagnosticsProfileSpecGenerator()
var diagnosticsProfileSpecGenerator gopter.Gen

// DiagnosticsProfileSpecGenerator returns a generator of DiagnosticsProfile_Spec instances for property testing.
func DiagnosticsProfileSpecGenerator() gopter.Gen {
	if diagnosticsProfileSpecGenerator != nil {
		return diagnosticsProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileSpec(generators)
	diagnosticsProfileSpecGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Spec{}), generators)

	return diagnosticsProfileSpecGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileSpec(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsSpecGenerator())
}

func Test_DiagnosticsProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileStatus, DiagnosticsProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileStatus runs a test to see if a specific instance of DiagnosticsProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileStatus(subject DiagnosticsProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Status instances for property testing - lazily instantiated by
//DiagnosticsProfileStatusGenerator()
var diagnosticsProfileStatusGenerator gopter.Gen

// DiagnosticsProfileStatusGenerator returns a generator of DiagnosticsProfile_Status instances for property testing.
func DiagnosticsProfileStatusGenerator() gopter.Gen {
	if diagnosticsProfileStatusGenerator != nil {
		return diagnosticsProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus(generators)
	diagnosticsProfileStatusGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Status{}), generators)

	return diagnosticsProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsStatusGenerator())
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationSpec, ExtendedLocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationSpec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationSpec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocationSpecGenerator()
var extendedLocationSpecGenerator gopter.Gen

// ExtendedLocationSpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocationSpecGenerator() gopter.Gen {
	if extendedLocationSpecGenerator != nil {
		return extendedLocationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationSpec(generators)
	extendedLocationSpecGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocationSpecGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationStatus, ExtendedLocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationStatus runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationStatus(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocationStatusGenerator()
var extendedLocationStatusGenerator gopter.Gen

// ExtendedLocationStatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocationStatusGenerator() gopter.Gen {
	if extendedLocationStatusGenerator != nil {
		return extendedLocationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationStatus(generators)
	extendedLocationStatusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocationStatusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_HardwareProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileSpec, HardwareProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileSpec runs a test to see if a specific instance of HardwareProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileSpec(subject HardwareProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Spec instances for property testing - lazily instantiated by
//HardwareProfileSpecGenerator()
var hardwareProfileSpecGenerator gopter.Gen

// HardwareProfileSpecGenerator returns a generator of HardwareProfile_Spec instances for property testing.
func HardwareProfileSpecGenerator() gopter.Gen {
	if hardwareProfileSpecGenerator != nil {
		return hardwareProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileSpec(generators)
	hardwareProfileSpecGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Spec{}), generators)

	return hardwareProfileSpecGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileSpec(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_HardwareProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileStatus, HardwareProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileStatus runs a test to see if a specific instance of HardwareProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileStatus(subject HardwareProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Status instances for property testing - lazily instantiated by
//HardwareProfileStatusGenerator()
var hardwareProfileStatusGenerator gopter.Gen

// HardwareProfileStatusGenerator returns a generator of HardwareProfile_Status instances for property testing.
func HardwareProfileStatusGenerator() gopter.Gen {
	if hardwareProfileStatusGenerator != nil {
		return hardwareProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileStatus(generators)
	hardwareProfileStatusGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Status{}), generators)

	return hardwareProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileStatus(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileSpec, NetworkProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileSpec runs a test to see if a specific instance of NetworkProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileSpec(subject NetworkProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Spec instances for property testing - lazily instantiated by NetworkProfileSpecGenerator()
var networkProfileSpecGenerator gopter.Gen

// NetworkProfileSpecGenerator returns a generator of NetworkProfile_Spec instances for property testing.
func NetworkProfileSpecGenerator() gopter.Gen {
	if networkProfileSpecGenerator != nil {
		return networkProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfileSpec(generators)
	networkProfileSpecGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Spec{}), generators)

	return networkProfileSpecGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileSpec(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceSpecGenerator())
}

func Test_NetworkProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileStatus, NetworkProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileStatus runs a test to see if a specific instance of NetworkProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileStatus(subject NetworkProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Status instances for property testing - lazily instantiated by
//NetworkProfileStatusGenerator()
var networkProfileStatusGenerator gopter.Gen

// NetworkProfileStatusGenerator returns a generator of NetworkProfile_Status instances for property testing.
func NetworkProfileStatusGenerator() gopter.Gen {
	if networkProfileStatusGenerator != nil {
		return networkProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfileStatus(generators)
	networkProfileStatusGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Status{}), generators)

	return networkProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileStatus(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceStatusGenerator())
}

func Test_OSProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileSpec, OSProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileSpec runs a test to see if a specific instance of OSProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileSpec(subject OSProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Spec instances for property testing - lazily instantiated by OSProfileSpecGenerator()
var osProfileSpecGenerator gopter.Gen

// OSProfileSpecGenerator returns a generator of OSProfile_Spec instances for property testing.
// We first initialize osProfileSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileSpecGenerator() gopter.Gen {
	if osProfileSpecGenerator != nil {
		return osProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileSpec(generators)
	osProfileSpecGenerator = gen.Struct(reflect.TypeOf(OSProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileSpec(generators)
	AddRelatedPropertyGeneratorsForOSProfileSpec(generators)
	osProfileSpecGenerator = gen.Struct(reflect.TypeOf(OSProfile_Spec{}), generators)

	return osProfileSpecGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileSpec(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileSpec(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationSpecGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupSpecGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationSpecGenerator())
}

func Test_OSProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileStatus, OSProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileStatus runs a test to see if a specific instance of OSProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileStatus(subject OSProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Status instances for property testing - lazily instantiated by OSProfileStatusGenerator()
var osProfileStatusGenerator gopter.Gen

// OSProfileStatusGenerator returns a generator of OSProfile_Status instances for property testing.
// We first initialize osProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileStatusGenerator() gopter.Gen {
	if osProfileStatusGenerator != nil {
		return osProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileStatus(generators)
	osProfileStatusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileStatus(generators)
	AddRelatedPropertyGeneratorsForOSProfileStatus(generators)
	osProfileStatusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	return osProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileStatus(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileStatus(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationStatusGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupStatusGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationStatusGenerator())
}

func Test_Plan_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlanSpec, PlanSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlanSpec runs a test to see if a specific instance of Plan_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPlanSpec(subject Plan_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Spec instances for property testing - lazily instantiated by PlanSpecGenerator()
var planSpecGenerator gopter.Gen

// PlanSpecGenerator returns a generator of Plan_Spec instances for property testing.
func PlanSpecGenerator() gopter.Gen {
	if planSpecGenerator != nil {
		return planSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlanSpec(generators)
	planSpecGenerator = gen.Struct(reflect.TypeOf(Plan_Spec{}), generators)

	return planSpecGenerator
}

// AddIndependentPropertyGeneratorsForPlanSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlanSpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_Plan_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlanStatus, PlanStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlanStatus runs a test to see if a specific instance of Plan_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPlanStatus(subject Plan_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Status instances for property testing - lazily instantiated by PlanStatusGenerator()
var planStatusGenerator gopter.Gen

// PlanStatusGenerator returns a generator of Plan_Status instances for property testing.
func PlanStatusGenerator() gopter.Gen {
	if planStatusGenerator != nil {
		return planStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlanStatus(generators)
	planStatusGenerator = gen.Struct(reflect.TypeOf(Plan_Status{}), generators)

	return planStatusGenerator
}

// AddIndependentPropertyGeneratorsForPlanStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlanStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecurityProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileSpec, SecurityProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileSpec runs a test to see if a specific instance of SecurityProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileSpec(subject SecurityProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Spec instances for property testing - lazily instantiated by
//SecurityProfileSpecGenerator()
var securityProfileSpecGenerator gopter.Gen

// SecurityProfileSpecGenerator returns a generator of SecurityProfile_Spec instances for property testing.
// We first initialize securityProfileSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileSpecGenerator() gopter.Gen {
	if securityProfileSpecGenerator != nil {
		return securityProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileSpec(generators)
	securityProfileSpecGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileSpec(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileSpec(generators)
	securityProfileSpecGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Spec{}), generators)

	return securityProfileSpecGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileSpec(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecurityProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileSpec(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsSpecGenerator())
}

func Test_SecurityProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileStatus, SecurityProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileStatus runs a test to see if a specific instance of SecurityProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileStatus(subject SecurityProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Status instances for property testing - lazily instantiated by
//SecurityProfileStatusGenerator()
var securityProfileStatusGenerator gopter.Gen

// SecurityProfileStatusGenerator returns a generator of SecurityProfile_Status instances for property testing.
// We first initialize securityProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileStatusGenerator() gopter.Gen {
	if securityProfileStatusGenerator != nil {
		return securityProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileStatus(generators)
	securityProfileStatusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileStatus(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileStatus(generators)
	securityProfileStatusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	return securityProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileStatus(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecurityProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileStatus(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsStatusGenerator())
}

func Test_StorageProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileSpec, StorageProfileSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileSpec runs a test to see if a specific instance of StorageProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileSpec(subject StorageProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Spec instances for property testing - lazily instantiated by StorageProfileSpecGenerator()
var storageProfileSpecGenerator gopter.Gen

// StorageProfileSpecGenerator returns a generator of StorageProfile_Spec instances for property testing.
func StorageProfileSpecGenerator() gopter.Gen {
	if storageProfileSpecGenerator != nil {
		return storageProfileSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileSpec(generators)
	storageProfileSpecGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Spec{}), generators)

	return storageProfileSpecGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileSpec(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskSpecGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceSpecGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskSpecGenerator())
}

func Test_StorageProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileStatus, StorageProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileStatus runs a test to see if a specific instance of StorageProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileStatus(subject StorageProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Status instances for property testing - lazily instantiated by
//StorageProfileStatusGenerator()
var storageProfileStatusGenerator gopter.Gen

// StorageProfileStatusGenerator returns a generator of StorageProfile_Status instances for property testing.
func StorageProfileStatusGenerator() gopter.Gen {
	if storageProfileStatusGenerator != nil {
		return storageProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileStatus(generators)
	storageProfileStatusGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Status{}), generators)

	return storageProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileStatus(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskStatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceStatusGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskStatusGenerator())
}

func Test_SubResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResourceSpec, SubResourceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResourceSpec runs a test to see if a specific instance of SubResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResourceSpec(subject SubResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Spec instances for property testing - lazily instantiated by SubResourceSpecGenerator()
var subResourceSpecGenerator gopter.Gen

// SubResourceSpecGenerator returns a generator of SubResource_Spec instances for property testing.
func SubResourceSpecGenerator() gopter.Gen {
	if subResourceSpecGenerator != nil {
		return subResourceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResourceSpecGenerator = gen.Struct(reflect.TypeOf(SubResource_Spec{}), generators)

	return subResourceSpecGenerator
}

func Test_SubResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResourceStatus, SubResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResourceStatus runs a test to see if a specific instance of SubResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResourceStatus(subject SubResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Status instances for property testing - lazily instantiated by SubResourceStatusGenerator()
var subResourceStatusGenerator gopter.Gen

// SubResourceStatusGenerator returns a generator of SubResource_Status instances for property testing.
func SubResourceStatusGenerator() gopter.Gen {
	if subResourceStatusGenerator != nil {
		return subResourceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResourceStatus(generators)
	subResourceStatusGenerator = gen.Struct(reflect.TypeOf(SubResource_Status{}), generators)

	return subResourceStatusGenerator
}

// AddIndependentPropertyGeneratorsForSubResourceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResourceStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtension_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtension_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionStatus, VirtualMachineExtensionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionStatus runs a test to see if a specific instance of VirtualMachineExtension_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionStatus(subject VirtualMachineExtension_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtension_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtension_Status instances for property testing - lazily instantiated by
//VirtualMachineExtensionStatusGenerator()
var virtualMachineExtensionStatusGenerator gopter.Gen

// VirtualMachineExtensionStatusGenerator returns a generator of VirtualMachineExtension_Status instances for property testing.
// We first initialize virtualMachineExtensionStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionStatusGenerator() gopter.Gen {
	if virtualMachineExtensionStatusGenerator != nil {
		return virtualMachineExtensionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	virtualMachineExtensionStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	virtualMachineExtensionStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	return virtualMachineExtensionStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["ForceUpdateTag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus(gens map[string]gopter.Gen) {
	gens["InstanceView"] = gen.PtrOf(VirtualMachineExtensionInstanceViewStatusGenerator())
}

func Test_VirtualMachineIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentitySpec, VirtualMachineIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentitySpec runs a test to see if a specific instance of VirtualMachineIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentitySpec(subject VirtualMachineIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Spec instances for property testing - lazily instantiated by
//VirtualMachineIdentitySpecGenerator()
var virtualMachineIdentitySpecGenerator gopter.Gen

// VirtualMachineIdentitySpecGenerator returns a generator of VirtualMachineIdentity_Spec instances for property testing.
func VirtualMachineIdentitySpecGenerator() gopter.Gen {
	if virtualMachineIdentitySpecGenerator != nil {
		return virtualMachineIdentitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpec(generators)
	virtualMachineIdentitySpecGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Spec{}), generators)

	return virtualMachineIdentitySpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentitySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityStatus, VirtualMachineIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityStatus runs a test to see if a specific instance of VirtualMachineIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityStatus(subject VirtualMachineIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Status instances for property testing - lazily instantiated by
//VirtualMachineIdentityStatusGenerator()
var virtualMachineIdentityStatusGenerator gopter.Gen

// VirtualMachineIdentityStatusGenerator returns a generator of VirtualMachineIdentity_Status instances for property testing.
// We first initialize virtualMachineIdentityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineIdentityStatusGenerator() gopter.Gen {
	if virtualMachineIdentityStatusGenerator != nil {
		return virtualMachineIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus(generators)
	virtualMachineIdentityStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineIdentityStatus(generators)
	virtualMachineIdentityStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	return virtualMachineIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator())
}

func Test_VirtualMachineInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceViewStatus, VirtualMachineInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceViewStatus runs a test to see if a specific instance of VirtualMachineInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceViewStatus(subject VirtualMachineInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineInstanceViewStatusGenerator()
var virtualMachineInstanceViewStatusGenerator gopter.Gen

// VirtualMachineInstanceViewStatusGenerator returns a generator of VirtualMachineInstanceView_Status instances for property testing.
// We first initialize virtualMachineInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineInstanceViewStatusGenerator != nil {
		return virtualMachineInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	virtualMachineInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	virtualMachineInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	return virtualMachineInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.AlphaString())
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceViewStatusGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceViewStatusGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceViewStatusGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatusStatusGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatusStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceViewStatusGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatusStatusGenerator())
}

func Test_BootDiagnosticsInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus, BootDiagnosticsInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus runs a test to see if a specific instance of BootDiagnosticsInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus(subject BootDiagnosticsInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceView_Status instances for property testing - lazily instantiated by
//BootDiagnosticsInstanceViewStatusGenerator()
var bootDiagnosticsInstanceViewStatusGenerator gopter.Gen

// BootDiagnosticsInstanceViewStatusGenerator returns a generator of BootDiagnosticsInstanceView_Status instances for property testing.
// We first initialize bootDiagnosticsInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceViewStatusGenerator() gopter.Gen {
	if bootDiagnosticsInstanceViewStatusGenerator != nil {
		return bootDiagnosticsInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	bootDiagnosticsInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	bootDiagnosticsInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	return bootDiagnosticsInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_BootDiagnostics_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsSpec, BootDiagnosticsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsSpec runs a test to see if a specific instance of BootDiagnostics_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsSpec(subject BootDiagnostics_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Spec instances for property testing - lazily instantiated by
//BootDiagnosticsSpecGenerator()
var bootDiagnosticsSpecGenerator gopter.Gen

// BootDiagnosticsSpecGenerator returns a generator of BootDiagnostics_Spec instances for property testing.
func BootDiagnosticsSpecGenerator() gopter.Gen {
	if bootDiagnosticsSpecGenerator != nil {
		return bootDiagnosticsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsSpec(generators)
	bootDiagnosticsSpecGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Spec{}), generators)

	return bootDiagnosticsSpecGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsSpec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_BootDiagnostics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsStatus, BootDiagnosticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsStatus runs a test to see if a specific instance of BootDiagnostics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsStatus(subject BootDiagnostics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Status instances for property testing - lazily instantiated by
//BootDiagnosticsStatusGenerator()
var bootDiagnosticsStatusGenerator gopter.Gen

// BootDiagnosticsStatusGenerator returns a generator of BootDiagnostics_Status instances for property testing.
func BootDiagnosticsStatusGenerator() gopter.Gen {
	if bootDiagnosticsStatusGenerator != nil {
		return bootDiagnosticsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsStatus(generators)
	bootDiagnosticsStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Status{}), generators)

	return bootDiagnosticsStatusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskSpec, DataDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskSpec runs a test to see if a specific instance of DataDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskSpec(subject DataDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Spec instances for property testing - lazily instantiated by DataDiskSpecGenerator()
var dataDiskSpecGenerator gopter.Gen

// DataDiskSpecGenerator returns a generator of DataDisk_Spec instances for property testing.
// We first initialize dataDiskSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskSpecGenerator() gopter.Gen {
	if dataDiskSpecGenerator != nil {
		return dataDiskSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskSpec(generators)
	dataDiskSpecGenerator = gen.Struct(reflect.TypeOf(DataDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskSpec(generators)
	AddRelatedPropertyGeneratorsForDataDiskSpec(generators)
	dataDiskSpecGenerator = gen.Struct(reflect.TypeOf(DataDisk_Spec{}), generators)

	return dataDiskSpecGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskSpec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DetachOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskSpec(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskSpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersSpecGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskSpecGenerator())
}

func Test_DataDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskStatus, DataDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskStatus runs a test to see if a specific instance of DataDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskStatus(subject DataDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Status instances for property testing - lazily instantiated by DataDiskStatusGenerator()
var dataDiskStatusGenerator gopter.Gen

// DataDiskStatusGenerator returns a generator of DataDisk_Status instances for property testing.
// We first initialize dataDiskStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskStatusGenerator() gopter.Gen {
	if dataDiskStatusGenerator != nil {
		return dataDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskStatus(generators)
	dataDiskStatusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskStatus(generators)
	AddRelatedPropertyGeneratorsForDataDiskStatus(generators)
	dataDiskStatusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	return dataDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskStatus(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DetachOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskStatus(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersStatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
}

func Test_DiskInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceViewStatus, DiskInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceViewStatus runs a test to see if a specific instance of DiskInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceViewStatus(subject DiskInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceView_Status instances for property testing - lazily instantiated by
//DiskInstanceViewStatusGenerator()
var diskInstanceViewStatusGenerator gopter.Gen

// DiskInstanceViewStatusGenerator returns a generator of DiskInstanceView_Status instances for property testing.
// We first initialize diskInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceViewStatusGenerator() gopter.Gen {
	if diskInstanceViewStatusGenerator != nil {
		return diskInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(generators)
	diskInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceViewStatus(generators)
	diskInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	return diskInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettingsStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_ImageReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceSpec, ImageReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceSpec runs a test to see if a specific instance of ImageReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceSpec(subject ImageReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Spec instances for property testing - lazily instantiated by ImageReferenceSpecGenerator()
var imageReferenceSpecGenerator gopter.Gen

// ImageReferenceSpecGenerator returns a generator of ImageReference_Spec instances for property testing.
func ImageReferenceSpecGenerator() gopter.Gen {
	if imageReferenceSpecGenerator != nil {
		return imageReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceSpec(generators)
	imageReferenceSpecGenerator = gen.Struct(reflect.TypeOf(ImageReference_Spec{}), generators)

	return imageReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceSpec(gens map[string]gopter.Gen) {
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceStatus, ImageReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceStatus runs a test to see if a specific instance of ImageReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceStatus(subject ImageReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Status instances for property testing - lazily instantiated by
//ImageReferenceStatusGenerator()
var imageReferenceStatusGenerator gopter.Gen

// ImageReferenceStatusGenerator returns a generator of ImageReference_Status instances for property testing.
func ImageReferenceStatusGenerator() gopter.Gen {
	if imageReferenceStatusGenerator != nil {
		return imageReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceStatus(generators)
	imageReferenceStatusGenerator = gen.Struct(reflect.TypeOf(ImageReference_Status{}), generators)

	return imageReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceStatus(gens map[string]gopter.Gen) {
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatusStatus, InstanceViewStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatusStatus runs a test to see if a specific instance of InstanceViewStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatusStatus(subject InstanceViewStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_Status instances for property testing - lazily instantiated by
//InstanceViewStatusStatusGenerator()
var instanceViewStatusStatusGenerator gopter.Gen

// InstanceViewStatusStatusGenerator returns a generator of InstanceViewStatus_Status instances for property testing.
func InstanceViewStatusStatusGenerator() gopter.Gen {
	if instanceViewStatusStatusGenerator != nil {
		return instanceViewStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatusStatus(generators)
	instanceViewStatusStatusGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_Status{}), generators)

	return instanceViewStatusStatusGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatusStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatusStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationSpec, LinuxConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationSpec runs a test to see if a specific instance of LinuxConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationSpec(subject LinuxConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Spec instances for property testing - lazily instantiated by
//LinuxConfigurationSpecGenerator()
var linuxConfigurationSpecGenerator gopter.Gen

// LinuxConfigurationSpecGenerator returns a generator of LinuxConfiguration_Spec instances for property testing.
// We first initialize linuxConfigurationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationSpecGenerator() gopter.Gen {
	if linuxConfigurationSpecGenerator != nil {
		return linuxConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationSpec(generators)
	linuxConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationSpec(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationSpec(generators)
	linuxConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Spec{}), generators)

	return linuxConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationSpec(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationSpec(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsSpecGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationSpecGenerator())
}

func Test_LinuxConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationStatus, LinuxConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationStatus runs a test to see if a specific instance of LinuxConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationStatus(subject LinuxConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Status instances for property testing - lazily instantiated by
//LinuxConfigurationStatusGenerator()
var linuxConfigurationStatusGenerator gopter.Gen

// LinuxConfigurationStatusGenerator returns a generator of LinuxConfiguration_Status instances for property testing.
// We first initialize linuxConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationStatusGenerator() gopter.Gen {
	if linuxConfigurationStatusGenerator != nil {
		return linuxConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(generators)
	linuxConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationStatus(generators)
	linuxConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	return linuxConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationStatus(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsStatusGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationStatusGenerator())
}

func Test_MaintenanceRedeployStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatusStatus, MaintenanceRedeployStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatusStatus runs a test to see if a specific instance of MaintenanceRedeployStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatusStatus(subject MaintenanceRedeployStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatus_Status instances for property testing - lazily instantiated by
//MaintenanceRedeployStatusStatusGenerator()
var maintenanceRedeployStatusStatusGenerator gopter.Gen

// MaintenanceRedeployStatusStatusGenerator returns a generator of MaintenanceRedeployStatus_Status instances for property testing.
func MaintenanceRedeployStatusStatusGenerator() gopter.Gen {
	if maintenanceRedeployStatusStatusGenerator != nil {
		return maintenanceRedeployStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus(generators)
	maintenanceRedeployStatusStatusGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatus_Status{}), generators)

	return maintenanceRedeployStatusStatusGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceSpec, NetworkInterfaceReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceSpec runs a test to see if a specific instance of NetworkInterfaceReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceSpec(subject NetworkInterfaceReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Spec instances for property testing - lazily instantiated by
//NetworkInterfaceReferenceSpecGenerator()
var networkInterfaceReferenceSpecGenerator gopter.Gen

// NetworkInterfaceReferenceSpecGenerator returns a generator of NetworkInterfaceReference_Spec instances for property testing.
func NetworkInterfaceReferenceSpecGenerator() gopter.Gen {
	if networkInterfaceReferenceSpecGenerator != nil {
		return networkInterfaceReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpec(generators)
	networkInterfaceReferenceSpecGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Spec{}), generators)

	return networkInterfaceReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSpec(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkInterfaceReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceStatus, NetworkInterfaceReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceStatus runs a test to see if a specific instance of NetworkInterfaceReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceStatus(subject NetworkInterfaceReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Status instances for property testing - lazily instantiated by
//NetworkInterfaceReferenceStatusGenerator()
var networkInterfaceReferenceStatusGenerator gopter.Gen

// NetworkInterfaceReferenceStatusGenerator returns a generator of NetworkInterfaceReference_Status instances for property testing.
func NetworkInterfaceReferenceStatusGenerator() gopter.Gen {
	if networkInterfaceReferenceStatusGenerator != nil {
		return networkInterfaceReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus(generators)
	networkInterfaceReferenceStatusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Status{}), generators)

	return networkInterfaceReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_OSDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskSpec, OSDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskSpec runs a test to see if a specific instance of OSDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskSpec(subject OSDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Spec instances for property testing - lazily instantiated by OSDiskSpecGenerator()
var osDiskSpecGenerator gopter.Gen

// OSDiskSpecGenerator returns a generator of OSDisk_Spec instances for property testing.
// We first initialize osDiskSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskSpecGenerator() gopter.Gen {
	if osDiskSpecGenerator != nil {
		return osDiskSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskSpec(generators)
	osDiskSpecGenerator = gen.Struct(reflect.TypeOf(OSDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskSpec(generators)
	AddRelatedPropertyGeneratorsForOSDiskSpec(generators)
	osDiskSpecGenerator = gen.Struct(reflect.TypeOf(OSDisk_Spec{}), generators)

	return osDiskSpecGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskSpec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskSpec(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsSpecGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsSpecGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskSpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersSpecGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskSpecGenerator())
}

func Test_OSDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskStatus, OSDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskStatus runs a test to see if a specific instance of OSDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskStatus(subject OSDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Status instances for property testing - lazily instantiated by OSDiskStatusGenerator()
var osDiskStatusGenerator gopter.Gen

// OSDiskStatusGenerator returns a generator of OSDisk_Status instances for property testing.
// We first initialize osDiskStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskStatusGenerator() gopter.Gen {
	if osDiskStatusGenerator != nil {
		return osDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskStatus(generators)
	osDiskStatusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskStatus(generators)
	AddRelatedPropertyGeneratorsForOSDiskStatus(generators)
	osDiskStatusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	return osDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskStatus(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskStatus(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsStatusGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsStatusGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersStatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
}

func Test_UefiSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsSpec, UefiSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsSpec runs a test to see if a specific instance of UefiSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsSpec(subject UefiSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Spec instances for property testing - lazily instantiated by UefiSettingsSpecGenerator()
var uefiSettingsSpecGenerator gopter.Gen

// UefiSettingsSpecGenerator returns a generator of UefiSettings_Spec instances for property testing.
func UefiSettingsSpecGenerator() gopter.Gen {
	if uefiSettingsSpecGenerator != nil {
		return uefiSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsSpec(generators)
	uefiSettingsSpecGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Spec{}), generators)

	return uefiSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsSpec(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_UefiSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsStatus, UefiSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsStatus runs a test to see if a specific instance of UefiSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsStatus(subject UefiSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Status instances for property testing - lazily instantiated by UefiSettingsStatusGenerator()
var uefiSettingsStatusGenerator gopter.Gen

// UefiSettingsStatusGenerator returns a generator of UefiSettings_Status instances for property testing.
func UefiSettingsStatusGenerator() gopter.Gen {
	if uefiSettingsStatusGenerator != nil {
		return uefiSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsStatus(generators)
	uefiSettingsStatusGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Status{}), generators)

	return uefiSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsStatus(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupSpec, VaultSecretGroupSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupSpec runs a test to see if a specific instance of VaultSecretGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupSpec(subject VaultSecretGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Spec instances for property testing - lazily instantiated by
//VaultSecretGroupSpecGenerator()
var vaultSecretGroupSpecGenerator gopter.Gen

// VaultSecretGroupSpecGenerator returns a generator of VaultSecretGroup_Spec instances for property testing.
func VaultSecretGroupSpecGenerator() gopter.Gen {
	if vaultSecretGroupSpecGenerator != nil {
		return vaultSecretGroupSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupSpec(generators)
	vaultSecretGroupSpecGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Spec{}), generators)

	return vaultSecretGroupSpecGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupSpec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceSpecGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateSpecGenerator())
}

func Test_VaultSecretGroup_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupStatus, VaultSecretGroupStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupStatus runs a test to see if a specific instance of VaultSecretGroup_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupStatus(subject VaultSecretGroup_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Status instances for property testing - lazily instantiated by
//VaultSecretGroupStatusGenerator()
var vaultSecretGroupStatusGenerator gopter.Gen

// VaultSecretGroupStatusGenerator returns a generator of VaultSecretGroup_Status instances for property testing.
func VaultSecretGroupStatusGenerator() gopter.Gen {
	if vaultSecretGroupStatusGenerator != nil {
		return vaultSecretGroupStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupStatus(generators)
	vaultSecretGroupStatusGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Status{}), generators)

	return vaultSecretGroupStatusGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateStatusGenerator())
}

func Test_VirtualMachineAgentInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus, VirtualMachineAgentInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus runs a test to see if a specific instance of VirtualMachineAgentInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus(subject VirtualMachineAgentInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineAgentInstanceViewStatusGenerator()
var virtualMachineAgentInstanceViewStatusGenerator gopter.Gen

// VirtualMachineAgentInstanceViewStatusGenerator returns a generator of VirtualMachineAgentInstanceView_Status instances for property testing.
// We first initialize virtualMachineAgentInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineAgentInstanceViewStatusGenerator != nil {
		return virtualMachineAgentInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	virtualMachineAgentInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	virtualMachineAgentInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	return virtualMachineAgentInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceViewStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineExtensionInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus, VirtualMachineExtensionInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus runs a test to see if a specific instance of VirtualMachineExtensionInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus(subject VirtualMachineExtensionInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineExtensionInstanceViewStatusGenerator()
var virtualMachineExtensionInstanceViewStatusGenerator gopter.Gen

// VirtualMachineExtensionInstanceViewStatusGenerator returns a generator of VirtualMachineExtensionInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceViewStatusGenerator != nil {
		return virtualMachineExtensionInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	virtualMachineExtensionInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	virtualMachineExtensionInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	return virtualMachineExtensionInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineHealthStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatusStatus, VirtualMachineHealthStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatusStatus runs a test to see if a specific instance of VirtualMachineHealthStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatusStatus(subject VirtualMachineHealthStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatus_Status instances for property testing - lazily instantiated by
//VirtualMachineHealthStatusStatusGenerator()
var virtualMachineHealthStatusStatusGenerator gopter.Gen

// VirtualMachineHealthStatusStatusGenerator returns a generator of VirtualMachineHealthStatus_Status instances for property testing.
func VirtualMachineHealthStatusStatusGenerator() gopter.Gen {
	if virtualMachineHealthStatusStatusGenerator != nil {
		return virtualMachineHealthStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus(generators)
	virtualMachineHealthStatusStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatus_Status{}), generators)

	return virtualMachineHealthStatusStatusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineIdentity_Status_UserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Status_UserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityStatusUserAssignedIdentities, VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityStatusUserAssignedIdentities runs a test to see if a specific instance of VirtualMachineIdentity_Status_UserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityStatusUserAssignedIdentities(subject VirtualMachineIdentity_Status_UserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Status_UserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Status_UserAssignedIdentities instances for property testing - lazily
//instantiated by VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator()
var virtualMachineIdentityStatusUserAssignedIdentitiesGenerator gopter.Gen

// VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator returns a generator of VirtualMachineIdentity_Status_UserAssignedIdentities instances for property testing.
func VirtualMachineIdentityStatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if virtualMachineIdentityStatusUserAssignedIdentitiesGenerator != nil {
		return virtualMachineIdentityStatusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatusUserAssignedIdentities(generators)
	virtualMachineIdentityStatusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status_UserAssignedIdentities{}), generators)

	return virtualMachineIdentityStatusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinePatchStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatusStatus, VirtualMachinePatchStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatusStatus runs a test to see if a specific instance of VirtualMachinePatchStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatusStatus(subject VirtualMachinePatchStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatus_Status instances for property testing - lazily instantiated by
//VirtualMachinePatchStatusStatusGenerator()
var virtualMachinePatchStatusStatusGenerator gopter.Gen

// VirtualMachinePatchStatusStatusGenerator returns a generator of VirtualMachinePatchStatus_Status instances for property testing.
func VirtualMachinePatchStatusStatusGenerator() gopter.Gen {
	if virtualMachinePatchStatusStatusGenerator != nil {
		return virtualMachinePatchStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus(generators)
	virtualMachinePatchStatusStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatus_Status{}), generators)

	return virtualMachinePatchStatusStatusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummaryStatusGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummaryStatusGenerator())
}

func Test_WindowsConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationSpec, WindowsConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationSpec runs a test to see if a specific instance of WindowsConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationSpec(subject WindowsConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Spec instances for property testing - lazily instantiated by
//WindowsConfigurationSpecGenerator()
var windowsConfigurationSpecGenerator gopter.Gen

// WindowsConfigurationSpecGenerator returns a generator of WindowsConfiguration_Spec instances for property testing.
// We first initialize windowsConfigurationSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationSpecGenerator() gopter.Gen {
	if windowsConfigurationSpecGenerator != nil {
		return windowsConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationSpec(generators)
	windowsConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationSpec(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationSpec(generators)
	windowsConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Spec{}), generators)

	return windowsConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationSpec(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationSpec(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentSpecGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsSpecGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationSpecGenerator())
}

func Test_WindowsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationStatus, WindowsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationStatus runs a test to see if a specific instance of WindowsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationStatus(subject WindowsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Status instances for property testing - lazily instantiated by
//WindowsConfigurationStatusGenerator()
var windowsConfigurationStatusGenerator gopter.Gen

// WindowsConfigurationStatusGenerator returns a generator of WindowsConfiguration_Status instances for property testing.
// We first initialize windowsConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationStatusGenerator() gopter.Gen {
	if windowsConfigurationStatusGenerator != nil {
		return windowsConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(generators)
	windowsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationStatus(generators)
	windowsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	return windowsConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentStatusGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsStatusGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationStatusGenerator())
}

func Test_AdditionalUnattendContent_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentSpec, AdditionalUnattendContentSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentSpec runs a test to see if a specific instance of AdditionalUnattendContent_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentSpec(subject AdditionalUnattendContent_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Spec instances for property testing - lazily instantiated by
//AdditionalUnattendContentSpecGenerator()
var additionalUnattendContentSpecGenerator gopter.Gen

// AdditionalUnattendContentSpecGenerator returns a generator of AdditionalUnattendContent_Spec instances for property testing.
func AdditionalUnattendContentSpecGenerator() gopter.Gen {
	if additionalUnattendContentSpecGenerator != nil {
		return additionalUnattendContentSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpec(generators)
	additionalUnattendContentSpecGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Spec{}), generators)

	return additionalUnattendContentSpecGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentSpec(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.AlphaString())
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.AlphaString())
	gens["SettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AdditionalUnattendContent_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentStatus, AdditionalUnattendContentStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentStatus runs a test to see if a specific instance of AdditionalUnattendContent_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentStatus(subject AdditionalUnattendContent_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Status instances for property testing - lazily instantiated by
//AdditionalUnattendContentStatusGenerator()
var additionalUnattendContentStatusGenerator gopter.Gen

// AdditionalUnattendContentStatusGenerator returns a generator of AdditionalUnattendContent_Status instances for property testing.
func AdditionalUnattendContentStatusGenerator() gopter.Gen {
	if additionalUnattendContentStatusGenerator != nil {
		return additionalUnattendContentStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus(generators)
	additionalUnattendContentStatusGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Status{}), generators)

	return additionalUnattendContentStatusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.AlphaString())
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.AlphaString())
	gens["SettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AvailablePatchSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummaryStatus, AvailablePatchSummaryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummaryStatus runs a test to see if a specific instance of AvailablePatchSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummaryStatus(subject AvailablePatchSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummary_Status instances for property testing - lazily instantiated by
//AvailablePatchSummaryStatusGenerator()
var availablePatchSummaryStatusGenerator gopter.Gen

// AvailablePatchSummaryStatusGenerator returns a generator of AvailablePatchSummary_Status instances for property testing.
// We first initialize availablePatchSummaryStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummaryStatusGenerator() gopter.Gen {
	if availablePatchSummaryStatusGenerator != nil {
		return availablePatchSummaryStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	availablePatchSummaryStatusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	availablePatchSummaryStatusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	return availablePatchSummaryStatusGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorStatusGenerator())
}

func Test_DiffDiskSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsSpec, DiffDiskSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsSpec runs a test to see if a specific instance of DiffDiskSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsSpec(subject DiffDiskSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Spec instances for property testing - lazily instantiated by
//DiffDiskSettingsSpecGenerator()
var diffDiskSettingsSpecGenerator gopter.Gen

// DiffDiskSettingsSpecGenerator returns a generator of DiffDiskSettings_Spec instances for property testing.
func DiffDiskSettingsSpecGenerator() gopter.Gen {
	if diffDiskSettingsSpecGenerator != nil {
		return diffDiskSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsSpec(generators)
	diffDiskSettingsSpecGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Spec{}), generators)

	return diffDiskSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsSpec(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.AlphaString())
	gens["Placement"] = gen.PtrOf(gen.AlphaString())
}

func Test_DiffDiskSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsStatus, DiffDiskSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsStatus runs a test to see if a specific instance of DiffDiskSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsStatus(subject DiffDiskSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Status instances for property testing - lazily instantiated by
//DiffDiskSettingsStatusGenerator()
var diffDiskSettingsStatusGenerator gopter.Gen

// DiffDiskSettingsStatusGenerator returns a generator of DiffDiskSettings_Status instances for property testing.
func DiffDiskSettingsStatusGenerator() gopter.Gen {
	if diffDiskSettingsStatusGenerator != nil {
		return diffDiskSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus(generators)
	diffDiskSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Status{}), generators)

	return diffDiskSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.AlphaString())
	gens["Placement"] = gen.PtrOf(gen.AlphaString())
}

func Test_DiskEncryptionSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsSpec, DiskEncryptionSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsSpec runs a test to see if a specific instance of DiskEncryptionSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsSpec(subject DiskEncryptionSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Spec instances for property testing - lazily instantiated by
//DiskEncryptionSettingsSpecGenerator()
var diskEncryptionSettingsSpecGenerator gopter.Gen

// DiskEncryptionSettingsSpecGenerator returns a generator of DiskEncryptionSettings_Spec instances for property testing.
// We first initialize diskEncryptionSettingsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsSpecGenerator() gopter.Gen {
	if diskEncryptionSettingsSpecGenerator != nil {
		return diskEncryptionSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpec(generators)
	diskEncryptionSettingsSpecGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpec(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpec(generators)
	diskEncryptionSettingsSpecGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Spec{}), generators)

	return diskEncryptionSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSpec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSpec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceSpecGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceSpecGenerator())
}

func Test_DiskEncryptionSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsStatus, DiskEncryptionSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsStatus runs a test to see if a specific instance of DiskEncryptionSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsStatus(subject DiskEncryptionSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Status instances for property testing - lazily instantiated by
//DiskEncryptionSettingsStatusGenerator()
var diskEncryptionSettingsStatusGenerator gopter.Gen

// DiskEncryptionSettingsStatusGenerator returns a generator of DiskEncryptionSettings_Status instances for property testing.
// We first initialize diskEncryptionSettingsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsStatusGenerator() gopter.Gen {
	if diskEncryptionSettingsStatusGenerator != nil {
		return diskEncryptionSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	diskEncryptionSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	diskEncryptionSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	return diskEncryptionSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceStatusGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceStatusGenerator())
}

func Test_LastPatchInstallationSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummaryStatus, LastPatchInstallationSummaryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummaryStatus runs a test to see if a specific instance of LastPatchInstallationSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummaryStatus(subject LastPatchInstallationSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummary_Status instances for property testing - lazily instantiated by
//LastPatchInstallationSummaryStatusGenerator()
var lastPatchInstallationSummaryStatusGenerator gopter.Gen

// LastPatchInstallationSummaryStatusGenerator returns a generator of LastPatchInstallationSummary_Status instances for property testing.
// We first initialize lastPatchInstallationSummaryStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummaryStatusGenerator() gopter.Gen {
	if lastPatchInstallationSummaryStatusGenerator != nil {
		return lastPatchInstallationSummaryStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	lastPatchInstallationSummaryStatusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	lastPatchInstallationSummaryStatusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	return lastPatchInstallationSummaryStatusGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorStatusGenerator())
}

func Test_LinuxPatchSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsSpec, LinuxPatchSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsSpec runs a test to see if a specific instance of LinuxPatchSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsSpec(subject LinuxPatchSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Spec instances for property testing - lazily instantiated by
//LinuxPatchSettingsSpecGenerator()
var linuxPatchSettingsSpecGenerator gopter.Gen

// LinuxPatchSettingsSpecGenerator returns a generator of LinuxPatchSettings_Spec instances for property testing.
func LinuxPatchSettingsSpecGenerator() gopter.Gen {
	if linuxPatchSettingsSpecGenerator != nil {
		return linuxPatchSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpec(generators)
	linuxPatchSettingsSpecGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Spec{}), generators)

	return linuxPatchSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsSpec(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxPatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsStatus, LinuxPatchSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsStatus runs a test to see if a specific instance of LinuxPatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsStatus(subject LinuxPatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Status instances for property testing - lazily instantiated by
//LinuxPatchSettingsStatusGenerator()
var linuxPatchSettingsStatusGenerator gopter.Gen

// LinuxPatchSettingsStatusGenerator returns a generator of LinuxPatchSettings_Status instances for property testing.
func LinuxPatchSettingsStatusGenerator() gopter.Gen {
	if linuxPatchSettingsStatusGenerator != nil {
		return linuxPatchSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus(generators)
	linuxPatchSettingsStatusGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Status{}), generators)

	return linuxPatchSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedDiskParameters_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersSpec, ManagedDiskParametersSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersSpec runs a test to see if a specific instance of ManagedDiskParameters_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersSpec(subject ManagedDiskParameters_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Spec instances for property testing - lazily instantiated by
//ManagedDiskParametersSpecGenerator()
var managedDiskParametersSpecGenerator gopter.Gen

// ManagedDiskParametersSpecGenerator returns a generator of ManagedDiskParameters_Spec instances for property testing.
// We first initialize managedDiskParametersSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersSpecGenerator() gopter.Gen {
	if managedDiskParametersSpecGenerator != nil {
		return managedDiskParametersSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersSpec(generators)
	managedDiskParametersSpecGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersSpec(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersSpec(generators)
	managedDiskParametersSpecGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Spec{}), generators)

	return managedDiskParametersSpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersSpec(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersSpec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_ManagedDiskParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersStatus, ManagedDiskParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersStatus runs a test to see if a specific instance of ManagedDiskParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersStatus(subject ManagedDiskParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Status instances for property testing - lazily instantiated by
//ManagedDiskParametersStatusGenerator()
var managedDiskParametersStatusGenerator gopter.Gen

// ManagedDiskParametersStatusGenerator returns a generator of ManagedDiskParameters_Status instances for property testing.
// We first initialize managedDiskParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersStatusGenerator() gopter.Gen {
	if managedDiskParametersStatusGenerator != nil {
		return managedDiskParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(generators)
	managedDiskParametersStatusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersStatus(generators)
	managedDiskParametersStatusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	return managedDiskParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersStatus(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_PatchSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsSpec, PatchSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsSpec runs a test to see if a specific instance of PatchSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsSpec(subject PatchSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Spec instances for property testing - lazily instantiated by PatchSettingsSpecGenerator()
var patchSettingsSpecGenerator gopter.Gen

// PatchSettingsSpecGenerator returns a generator of PatchSettings_Spec instances for property testing.
func PatchSettingsSpecGenerator() gopter.Gen {
	if patchSettingsSpecGenerator != nil {
		return patchSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsSpec(generators)
	patchSettingsSpecGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Spec{}), generators)

	return patchSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsSpec(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_PatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsStatus, PatchSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsStatus runs a test to see if a specific instance of PatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsStatus(subject PatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Status instances for property testing - lazily instantiated by
//PatchSettingsStatusGenerator()
var patchSettingsStatusGenerator gopter.Gen

// PatchSettingsStatusGenerator returns a generator of PatchSettings_Status instances for property testing.
func PatchSettingsStatusGenerator() gopter.Gen {
	if patchSettingsStatusGenerator != nil {
		return patchSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsStatus(generators)
	patchSettingsStatusGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Status{}), generators)

	return patchSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsStatus(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_SshConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationSpec, SshConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationSpec runs a test to see if a specific instance of SshConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationSpec(subject SshConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Spec instances for property testing - lazily instantiated by
//SshConfigurationSpecGenerator()
var sshConfigurationSpecGenerator gopter.Gen

// SshConfigurationSpecGenerator returns a generator of SshConfiguration_Spec instances for property testing.
func SshConfigurationSpecGenerator() gopter.Gen {
	if sshConfigurationSpecGenerator != nil {
		return sshConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationSpec(generators)
	sshConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Spec{}), generators)

	return sshConfigurationSpecGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationSpec(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeySpecGenerator())
}

func Test_SshConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationStatus, SshConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationStatus runs a test to see if a specific instance of SshConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationStatus(subject SshConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Status instances for property testing - lazily instantiated by
//SshConfigurationStatusGenerator()
var sshConfigurationStatusGenerator gopter.Gen

// SshConfigurationStatusGenerator returns a generator of SshConfiguration_Status instances for property testing.
func SshConfigurationStatusGenerator() gopter.Gen {
	if sshConfigurationStatusGenerator != nil {
		return sshConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationStatus(generators)
	sshConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Status{}), generators)

	return sshConfigurationStatusGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationStatus(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeyStatusGenerator())
}

func Test_VaultCertificate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateSpec, VaultCertificateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateSpec runs a test to see if a specific instance of VaultCertificate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateSpec(subject VaultCertificate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Spec instances for property testing - lazily instantiated by
//VaultCertificateSpecGenerator()
var vaultCertificateSpecGenerator gopter.Gen

// VaultCertificateSpecGenerator returns a generator of VaultCertificate_Spec instances for property testing.
func VaultCertificateSpecGenerator() gopter.Gen {
	if vaultCertificateSpecGenerator != nil {
		return vaultCertificateSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateSpec(generators)
	vaultCertificateSpecGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Spec{}), generators)

	return vaultCertificateSpecGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateSpec(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VaultCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateStatus, VaultCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateStatus runs a test to see if a specific instance of VaultCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateStatus(subject VaultCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Status instances for property testing - lazily instantiated by
//VaultCertificateStatusGenerator()
var vaultCertificateStatusGenerator gopter.Gen

// VaultCertificateStatusGenerator returns a generator of VaultCertificate_Status instances for property testing.
func VaultCertificateStatusGenerator() gopter.Gen {
	if vaultCertificateStatusGenerator != nil {
		return vaultCertificateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateStatus(generators)
	vaultCertificateStatusGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Status{}), generators)

	return vaultCertificateStatusGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateStatus(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskSpec, VirtualHardDiskSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskSpec runs a test to see if a specific instance of VirtualHardDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskSpec(subject VirtualHardDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Spec instances for property testing - lazily instantiated by
//VirtualHardDiskSpecGenerator()
var virtualHardDiskSpecGenerator gopter.Gen

// VirtualHardDiskSpecGenerator returns a generator of VirtualHardDisk_Spec instances for property testing.
func VirtualHardDiskSpecGenerator() gopter.Gen {
	if virtualHardDiskSpecGenerator != nil {
		return virtualHardDiskSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskSpec(generators)
	virtualHardDiskSpecGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Spec{}), generators)

	return virtualHardDiskSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskSpec(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskStatus, VirtualHardDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskStatus runs a test to see if a specific instance of VirtualHardDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskStatus(subject VirtualHardDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Status instances for property testing - lazily instantiated by
//VirtualHardDiskStatusGenerator()
var virtualHardDiskStatusGenerator gopter.Gen

// VirtualHardDiskStatusGenerator returns a generator of VirtualHardDisk_Status instances for property testing.
func VirtualHardDiskStatusGenerator() gopter.Gen {
	if virtualHardDiskStatusGenerator != nil {
		return virtualHardDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskStatus(generators)
	virtualHardDiskStatusGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Status{}), generators)

	return virtualHardDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskStatus(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus, VirtualMachineExtensionHandlerInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus(subject VirtualMachineExtensionHandlerInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing - lazily instantiated
//by VirtualMachineExtensionHandlerInstanceViewStatusGenerator()
var virtualMachineExtensionHandlerInstanceViewStatusGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceViewStatusGenerator returns a generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceViewStatusGenerator != nil {
		return virtualMachineExtensionHandlerInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	virtualMachineExtensionHandlerInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	virtualMachineExtensionHandlerInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	return virtualMachineExtensionHandlerInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_WinRMConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationSpec, WinRMConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationSpec runs a test to see if a specific instance of WinRMConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationSpec(subject WinRMConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Spec instances for property testing - lazily instantiated by
//WinRMConfigurationSpecGenerator()
var winRMConfigurationSpecGenerator gopter.Gen

// WinRMConfigurationSpecGenerator returns a generator of WinRMConfiguration_Spec instances for property testing.
func WinRMConfigurationSpecGenerator() gopter.Gen {
	if winRMConfigurationSpecGenerator != nil {
		return winRMConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationSpec(generators)
	winRMConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Spec{}), generators)

	return winRMConfigurationSpecGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationSpec(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerSpecGenerator())
}

func Test_WinRMConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationStatus, WinRMConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationStatus runs a test to see if a specific instance of WinRMConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationStatus(subject WinRMConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Status instances for property testing - lazily instantiated by
//WinRMConfigurationStatusGenerator()
var winRMConfigurationStatusGenerator gopter.Gen

// WinRMConfigurationStatusGenerator returns a generator of WinRMConfiguration_Status instances for property testing.
func WinRMConfigurationStatusGenerator() gopter.Gen {
	if winRMConfigurationStatusGenerator != nil {
		return winRMConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationStatus(generators)
	winRMConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Status{}), generators)

	return winRMConfigurationStatusGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationStatus(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerStatusGenerator())
}

func Test_ApiError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorStatus, ApiErrorStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorStatus runs a test to see if a specific instance of ApiError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorStatus(subject ApiError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiError_Status instances for property testing - lazily instantiated by ApiErrorStatusGenerator()
var apiErrorStatusGenerator gopter.Gen

// ApiErrorStatusGenerator returns a generator of ApiError_Status instances for property testing.
// We first initialize apiErrorStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiErrorStatusGenerator() gopter.Gen {
	if apiErrorStatusGenerator != nil {
		return apiErrorStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorStatus(generators)
	apiErrorStatusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorStatus(generators)
	AddRelatedPropertyGeneratorsForApiErrorStatus(generators)
	apiErrorStatusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	return apiErrorStatusGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiErrorStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiErrorStatus(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBaseStatusGenerator())
	gens["Innererror"] = gen.PtrOf(InnerErrorStatusGenerator())
}

func Test_KeyVaultKeyReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceSpec, KeyVaultKeyReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceSpec runs a test to see if a specific instance of KeyVaultKeyReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceSpec(subject KeyVaultKeyReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Spec instances for property testing - lazily instantiated by
//KeyVaultKeyReferenceSpecGenerator()
var keyVaultKeyReferenceSpecGenerator gopter.Gen

// KeyVaultKeyReferenceSpecGenerator returns a generator of KeyVaultKeyReference_Spec instances for property testing.
// We first initialize keyVaultKeyReferenceSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceSpecGenerator() gopter.Gen {
	if keyVaultKeyReferenceSpecGenerator != nil {
		return keyVaultKeyReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpec(generators)
	keyVaultKeyReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpec(generators)
	keyVaultKeyReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Spec{}), generators)

	return keyVaultKeyReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSpec(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSpec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_KeyVaultKeyReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceStatus, KeyVaultKeyReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceStatus runs a test to see if a specific instance of KeyVaultKeyReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceStatus(subject KeyVaultKeyReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Status instances for property testing - lazily instantiated by
//KeyVaultKeyReferenceStatusGenerator()
var keyVaultKeyReferenceStatusGenerator gopter.Gen

// KeyVaultKeyReferenceStatusGenerator returns a generator of KeyVaultKeyReference_Status instances for property testing.
// We first initialize keyVaultKeyReferenceStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceStatusGenerator() gopter.Gen {
	if keyVaultKeyReferenceStatusGenerator != nil {
		return keyVaultKeyReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	keyVaultKeyReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	keyVaultKeyReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	return keyVaultKeyReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_KeyVaultSecretReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceSpec, KeyVaultSecretReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceSpec runs a test to see if a specific instance of KeyVaultSecretReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceSpec(subject KeyVaultSecretReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Spec instances for property testing - lazily instantiated by
//KeyVaultSecretReferenceSpecGenerator()
var keyVaultSecretReferenceSpecGenerator gopter.Gen

// KeyVaultSecretReferenceSpecGenerator returns a generator of KeyVaultSecretReference_Spec instances for property testing.
// We first initialize keyVaultSecretReferenceSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceSpecGenerator() gopter.Gen {
	if keyVaultSecretReferenceSpecGenerator != nil {
		return keyVaultSecretReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpec(generators)
	keyVaultSecretReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpec(generators)
	keyVaultSecretReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Spec{}), generators)

	return keyVaultSecretReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSpec(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSpec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceSpecGenerator())
}

func Test_KeyVaultSecretReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceStatus, KeyVaultSecretReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceStatus runs a test to see if a specific instance of KeyVaultSecretReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceStatus(subject KeyVaultSecretReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Status instances for property testing - lazily instantiated by
//KeyVaultSecretReferenceStatusGenerator()
var keyVaultSecretReferenceStatusGenerator gopter.Gen

// KeyVaultSecretReferenceStatusGenerator returns a generator of KeyVaultSecretReference_Status instances for property testing.
// We first initialize keyVaultSecretReferenceStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceStatusGenerator() gopter.Gen {
	if keyVaultSecretReferenceStatusGenerator != nil {
		return keyVaultSecretReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	keyVaultSecretReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	keyVaultSecretReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	return keyVaultSecretReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_SshPublicKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeySpec, SshPublicKeySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeySpec runs a test to see if a specific instance of SshPublicKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeySpec(subject SshPublicKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Spec instances for property testing - lazily instantiated by SshPublicKeySpecGenerator()
var sshPublicKeySpecGenerator gopter.Gen

// SshPublicKeySpecGenerator returns a generator of SshPublicKey_Spec instances for property testing.
func SshPublicKeySpecGenerator() gopter.Gen {
	if sshPublicKeySpecGenerator != nil {
		return sshPublicKeySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeySpec(generators)
	sshPublicKeySpecGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Spec{}), generators)

	return sshPublicKeySpecGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeySpec(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_SshPublicKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeyStatus, SshPublicKeyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeyStatus runs a test to see if a specific instance of SshPublicKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeyStatus(subject SshPublicKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Status instances for property testing - lazily instantiated by SshPublicKeyStatusGenerator()
var sshPublicKeyStatusGenerator gopter.Gen

// SshPublicKeyStatusGenerator returns a generator of SshPublicKey_Status instances for property testing.
func SshPublicKeyStatusGenerator() gopter.Gen {
	if sshPublicKeyStatusGenerator != nil {
		return sshPublicKeyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeyStatus(generators)
	sshPublicKeyStatusGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Status{}), generators)

	return sshPublicKeyStatusGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeyStatus(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerSpec, WinRMListenerSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerSpec runs a test to see if a specific instance of WinRMListener_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerSpec(subject WinRMListener_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Spec instances for property testing - lazily instantiated by WinRMListenerSpecGenerator()
var winRMListenerSpecGenerator gopter.Gen

// WinRMListenerSpecGenerator returns a generator of WinRMListener_Spec instances for property testing.
func WinRMListenerSpecGenerator() gopter.Gen {
	if winRMListenerSpecGenerator != nil {
		return winRMListenerSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerSpec(generators)
	winRMListenerSpecGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Spec{}), generators)

	return winRMListenerSpecGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerSpec(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerStatus, WinRMListenerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerStatus runs a test to see if a specific instance of WinRMListener_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerStatus(subject WinRMListener_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Status instances for property testing - lazily instantiated by
//WinRMListenerStatusGenerator()
var winRMListenerStatusGenerator gopter.Gen

// WinRMListenerStatusGenerator returns a generator of WinRMListener_Status instances for property testing.
func WinRMListenerStatusGenerator() gopter.Gen {
	if winRMListenerStatusGenerator != nil {
		return winRMListenerStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerStatus(generators)
	winRMListenerStatusGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Status{}), generators)

	return winRMListenerStatusGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerStatus(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiErrorBase_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBase_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBaseStatus, ApiErrorBaseStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBaseStatus runs a test to see if a specific instance of ApiErrorBase_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBaseStatus(subject ApiErrorBase_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBase_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBase_Status instances for property testing - lazily instantiated by ApiErrorBaseStatusGenerator()
var apiErrorBaseStatusGenerator gopter.Gen

// ApiErrorBaseStatusGenerator returns a generator of ApiErrorBase_Status instances for property testing.
func ApiErrorBaseStatusGenerator() gopter.Gen {
	if apiErrorBaseStatusGenerator != nil {
		return apiErrorBaseStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBaseStatus(generators)
	apiErrorBaseStatusGenerator = gen.Struct(reflect.TypeOf(ApiErrorBase_Status{}), generators)

	return apiErrorBaseStatusGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBaseStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBaseStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerErrorStatus, InnerErrorStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerErrorStatus runs a test to see if a specific instance of InnerError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerErrorStatus(subject InnerError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_Status instances for property testing - lazily instantiated by InnerErrorStatusGenerator()
var innerErrorStatusGenerator gopter.Gen

// InnerErrorStatusGenerator returns a generator of InnerError_Status instances for property testing.
func InnerErrorStatusGenerator() gopter.Gen {
	if innerErrorStatusGenerator != nil {
		return innerErrorStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerErrorStatus(generators)
	innerErrorStatusGenerator = gen.Struct(reflect.TypeOf(InnerError_Status{}), generators)

	return innerErrorStatusGenerator
}

// AddIndependentPropertyGeneratorsForInnerErrorStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerErrorStatus(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}
