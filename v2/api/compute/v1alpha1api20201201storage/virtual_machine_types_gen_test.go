// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine runs a test to see if a specific instance of VirtualMachine round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine(subject VirtualMachine) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine instances for property testing - lazily instantiated by VirtualMachineGenerator()
var virtualMachineGenerator gopter.Gen

// VirtualMachineGenerator returns a generator of VirtualMachine instances for property testing.
func VirtualMachineGenerator() gopter.Gen {
	if virtualMachineGenerator != nil {
		return virtualMachineGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachine(generators)
	virtualMachineGenerator = gen.Struct(reflect.TypeOf(VirtualMachine{}), generators)

	return virtualMachineGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachine is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualMachines_SPECGenerator()
	gens["Status"] = VirtualMachine_StatusGenerator()
}

func Test_VirtualMachine_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_Status, VirtualMachine_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_Status runs a test to see if a specific instance of VirtualMachine_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_Status(subject VirtualMachine_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_Status instances for property testing - lazily instantiated by
//VirtualMachine_StatusGenerator()
var virtualMachine_statusGenerator gopter.Gen

// VirtualMachine_StatusGenerator returns a generator of VirtualMachine_Status instances for property testing.
// We first initialize virtualMachine_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_StatusGenerator() gopter.Gen {
	if virtualMachine_statusGenerator != nil {
		return virtualMachine_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_Status(generators)
	virtualMachine_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_Status(generators)
	virtualMachine_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	return virtualMachine_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_Status(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_Status(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_StatusGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_StatusGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfile_StatusGenerator())
	gens["Host"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentity_StatusGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceView_StatusGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_StatusGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfile_StatusGenerator())
	gens["Plan"] = gen.PtrOf(Plan_StatusGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["Resources"] = gen.SliceOf(VirtualMachineExtension_StatusGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_StatusGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfile_StatusGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_VirtualMachines_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachines_SPEC, VirtualMachines_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachines_SPEC runs a test to see if a specific instance of VirtualMachines_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachines_SPEC(subject VirtualMachines_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_SPEC instances for property testing - lazily instantiated by
//VirtualMachines_SPECGenerator()
var virtualMachines_specGenerator gopter.Gen

// VirtualMachines_SPECGenerator returns a generator of VirtualMachines_SPEC instances for property testing.
// We first initialize virtualMachines_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachines_SPECGenerator() gopter.Gen {
	if virtualMachines_specGenerator != nil {
		return virtualMachines_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachines_SPEC(generators)
	virtualMachines_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachines_SPEC(generators)
	AddRelatedPropertyGeneratorsForVirtualMachines_SPEC(generators)
	virtualMachines_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SPEC{}), generators)

	return virtualMachines_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachines_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachines_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachines_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachines_SPEC(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_SpecGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_SpecGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfile_SpecGenerator())
	gens["Host"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentity_SpecGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_SpecGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfile_SpecGenerator())
	gens["Plan"] = gen.PtrOf(Plan_SpecGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_SpecGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfile_SpecGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_AdditionalCapabilities_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilities_Spec, AdditionalCapabilities_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilities_Spec runs a test to see if a specific instance of AdditionalCapabilities_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilities_Spec(subject AdditionalCapabilities_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Spec instances for property testing - lazily instantiated by
//AdditionalCapabilities_SpecGenerator()
var additionalCapabilities_specGenerator gopter.Gen

// AdditionalCapabilities_SpecGenerator returns a generator of AdditionalCapabilities_Spec instances for property testing.
func AdditionalCapabilities_SpecGenerator() gopter.Gen {
	if additionalCapabilities_specGenerator != nil {
		return additionalCapabilities_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilities_Spec(generators)
	additionalCapabilities_specGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Spec{}), generators)

	return additionalCapabilities_specGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilities_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilities_Spec(gens map[string]gopter.Gen) {
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_AdditionalCapabilities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilities_Status, AdditionalCapabilities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilities_Status runs a test to see if a specific instance of AdditionalCapabilities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilities_Status(subject AdditionalCapabilities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Status instances for property testing - lazily instantiated by
//AdditionalCapabilities_StatusGenerator()
var additionalCapabilities_statusGenerator gopter.Gen

// AdditionalCapabilities_StatusGenerator returns a generator of AdditionalCapabilities_Status instances for property testing.
func AdditionalCapabilities_StatusGenerator() gopter.Gen {
	if additionalCapabilities_statusGenerator != nil {
		return additionalCapabilities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilities_Status(generators)
	additionalCapabilities_statusGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Status{}), generators)

	return additionalCapabilities_statusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilities_Status(gens map[string]gopter.Gen) {
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_BillingProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile_Spec, BillingProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile_Spec runs a test to see if a specific instance of BillingProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile_Spec(subject BillingProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Spec instances for property testing - lazily instantiated by
//BillingProfile_SpecGenerator()
var billingProfile_specGenerator gopter.Gen

// BillingProfile_SpecGenerator returns a generator of BillingProfile_Spec instances for property testing.
func BillingProfile_SpecGenerator() gopter.Gen {
	if billingProfile_specGenerator != nil {
		return billingProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile_Spec(generators)
	billingProfile_specGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Spec{}), generators)

	return billingProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile_Spec(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_BillingProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile_Status, BillingProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile_Status runs a test to see if a specific instance of BillingProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile_Status(subject BillingProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Status instances for property testing - lazily instantiated by
//BillingProfile_StatusGenerator()
var billingProfile_statusGenerator gopter.Gen

// BillingProfile_StatusGenerator returns a generator of BillingProfile_Status instances for property testing.
func BillingProfile_StatusGenerator() gopter.Gen {
	if billingProfile_statusGenerator != nil {
		return billingProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile_Status(generators)
	billingProfile_statusGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Status{}), generators)

	return billingProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile_Status(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile_Spec, DiagnosticsProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile_Spec runs a test to see if a specific instance of DiagnosticsProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile_Spec(subject DiagnosticsProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Spec instances for property testing - lazily instantiated by
//DiagnosticsProfile_SpecGenerator()
var diagnosticsProfile_specGenerator gopter.Gen

// DiagnosticsProfile_SpecGenerator returns a generator of DiagnosticsProfile_Spec instances for property testing.
func DiagnosticsProfile_SpecGenerator() gopter.Gen {
	if diagnosticsProfile_specGenerator != nil {
		return diagnosticsProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile_Spec(generators)
	diagnosticsProfile_specGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Spec{}), generators)

	return diagnosticsProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile_Spec(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnostics_SpecGenerator())
}

func Test_DiagnosticsProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile_Status, DiagnosticsProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile_Status runs a test to see if a specific instance of DiagnosticsProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile_Status(subject DiagnosticsProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Status instances for property testing - lazily instantiated by
//DiagnosticsProfile_StatusGenerator()
var diagnosticsProfile_statusGenerator gopter.Gen

// DiagnosticsProfile_StatusGenerator returns a generator of DiagnosticsProfile_Status instances for property testing.
func DiagnosticsProfile_StatusGenerator() gopter.Gen {
	if diagnosticsProfile_statusGenerator != nil {
		return diagnosticsProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile_Status(generators)
	diagnosticsProfile_statusGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Status{}), generators)

	return diagnosticsProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile_Status(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnostics_StatusGenerator())
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Spec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocation_SpecGenerator()
var extendedLocation_specGenerator gopter.Gen

// ExtendedLocation_SpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocation_SpecGenerator() gopter.Gen {
	if extendedLocation_specGenerator != nil {
		return extendedLocation_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Spec(generators)
	extendedLocation_specGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocation_specGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Status runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocation_StatusGenerator()
var extendedLocation_statusGenerator gopter.Gen

// ExtendedLocation_StatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocation_StatusGenerator() gopter.Gen {
	if extendedLocation_statusGenerator != nil {
		return extendedLocation_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Status(generators)
	extendedLocation_statusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocation_statusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_HardwareProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile_Spec, HardwareProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile_Spec runs a test to see if a specific instance of HardwareProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile_Spec(subject HardwareProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Spec instances for property testing - lazily instantiated by
//HardwareProfile_SpecGenerator()
var hardwareProfile_specGenerator gopter.Gen

// HardwareProfile_SpecGenerator returns a generator of HardwareProfile_Spec instances for property testing.
func HardwareProfile_SpecGenerator() gopter.Gen {
	if hardwareProfile_specGenerator != nil {
		return hardwareProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile_Spec(generators)
	hardwareProfile_specGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Spec{}), generators)

	return hardwareProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile_Spec(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_HardwareProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile_Status, HardwareProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile_Status runs a test to see if a specific instance of HardwareProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile_Status(subject HardwareProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Status instances for property testing - lazily instantiated by
//HardwareProfile_StatusGenerator()
var hardwareProfile_statusGenerator gopter.Gen

// HardwareProfile_StatusGenerator returns a generator of HardwareProfile_Status instances for property testing.
func HardwareProfile_StatusGenerator() gopter.Gen {
	if hardwareProfile_statusGenerator != nil {
		return hardwareProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile_Status(generators)
	hardwareProfile_statusGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Status{}), generators)

	return hardwareProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile_Status(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_Spec, NetworkProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_Spec runs a test to see if a specific instance of NetworkProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_Spec(subject NetworkProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Spec instances for property testing - lazily instantiated by
//NetworkProfile_SpecGenerator()
var networkProfile_specGenerator gopter.Gen

// NetworkProfile_SpecGenerator returns a generator of NetworkProfile_Spec instances for property testing.
func NetworkProfile_SpecGenerator() gopter.Gen {
	if networkProfile_specGenerator != nil {
		return networkProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfile_Spec(generators)
	networkProfile_specGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Spec{}), generators)

	return networkProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_Spec(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReference_SpecGenerator())
}

func Test_NetworkProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_Status, NetworkProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_Status runs a test to see if a specific instance of NetworkProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_Status(subject NetworkProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Status instances for property testing - lazily instantiated by
//NetworkProfile_StatusGenerator()
var networkProfile_statusGenerator gopter.Gen

// NetworkProfile_StatusGenerator returns a generator of NetworkProfile_Status instances for property testing.
func NetworkProfile_StatusGenerator() gopter.Gen {
	if networkProfile_statusGenerator != nil {
		return networkProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfile_Status(generators)
	networkProfile_statusGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Status{}), generators)

	return networkProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_Status(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReference_StatusGenerator())
}

func Test_OSProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfile_Spec, OSProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfile_Spec runs a test to see if a specific instance of OSProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfile_Spec(subject OSProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Spec instances for property testing - lazily instantiated by OSProfile_SpecGenerator()
var osProfile_specGenerator gopter.Gen

// OSProfile_SpecGenerator returns a generator of OSProfile_Spec instances for property testing.
// We first initialize osProfile_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfile_SpecGenerator() gopter.Gen {
	if osProfile_specGenerator != nil {
		return osProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_Spec(generators)
	osProfile_specGenerator = gen.Struct(reflect.TypeOf(OSProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_Spec(generators)
	AddRelatedPropertyGeneratorsForOSProfile_Spec(generators)
	osProfile_specGenerator = gen.Struct(reflect.TypeOf(OSProfile_Spec{}), generators)

	return osProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForOSProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfile_Spec(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfile_Spec(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_SpecGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_SpecGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_SpecGenerator())
}

func Test_OSProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfile_Status, OSProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfile_Status runs a test to see if a specific instance of OSProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfile_Status(subject OSProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Status instances for property testing - lazily instantiated by OSProfile_StatusGenerator()
var osProfile_statusGenerator gopter.Gen

// OSProfile_StatusGenerator returns a generator of OSProfile_Status instances for property testing.
// We first initialize osProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfile_StatusGenerator() gopter.Gen {
	if osProfile_statusGenerator != nil {
		return osProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_Status(generators)
	osProfile_statusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_Status(generators)
	AddRelatedPropertyGeneratorsForOSProfile_Status(generators)
	osProfile_statusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	return osProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForOSProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfile_Status(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfile_Status(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_StatusGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_StatusGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_StatusGenerator())
}

func Test_Plan_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan_Spec, Plan_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan_Spec runs a test to see if a specific instance of Plan_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan_Spec(subject Plan_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Spec instances for property testing - lazily instantiated by Plan_SpecGenerator()
var plan_specGenerator gopter.Gen

// Plan_SpecGenerator returns a generator of Plan_Spec instances for property testing.
func Plan_SpecGenerator() gopter.Gen {
	if plan_specGenerator != nil {
		return plan_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan_Spec(generators)
	plan_specGenerator = gen.Struct(reflect.TypeOf(Plan_Spec{}), generators)

	return plan_specGenerator
}

// AddIndependentPropertyGeneratorsForPlan_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_Plan_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan_Status, Plan_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan_Status runs a test to see if a specific instance of Plan_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan_Status(subject Plan_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Status instances for property testing - lazily instantiated by Plan_StatusGenerator()
var plan_statusGenerator gopter.Gen

// Plan_StatusGenerator returns a generator of Plan_Status instances for property testing.
func Plan_StatusGenerator() gopter.Gen {
	if plan_statusGenerator != nil {
		return plan_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan_Status(generators)
	plan_statusGenerator = gen.Struct(reflect.TypeOf(Plan_Status{}), generators)

	return plan_statusGenerator
}

// AddIndependentPropertyGeneratorsForPlan_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecurityProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile_Spec, SecurityProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile_Spec runs a test to see if a specific instance of SecurityProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile_Spec(subject SecurityProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Spec instances for property testing - lazily instantiated by
//SecurityProfile_SpecGenerator()
var securityProfile_specGenerator gopter.Gen

// SecurityProfile_SpecGenerator returns a generator of SecurityProfile_Spec instances for property testing.
// We first initialize securityProfile_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfile_SpecGenerator() gopter.Gen {
	if securityProfile_specGenerator != nil {
		return securityProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_Spec(generators)
	securityProfile_specGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_Spec(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile_Spec(generators)
	securityProfile_specGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Spec{}), generators)

	return securityProfile_specGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile_Spec(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecurityProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile_Spec(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettings_SpecGenerator())
}

func Test_SecurityProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile_Status, SecurityProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile_Status runs a test to see if a specific instance of SecurityProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile_Status(subject SecurityProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Status instances for property testing - lazily instantiated by
//SecurityProfile_StatusGenerator()
var securityProfile_statusGenerator gopter.Gen

// SecurityProfile_StatusGenerator returns a generator of SecurityProfile_Status instances for property testing.
// We first initialize securityProfile_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfile_StatusGenerator() gopter.Gen {
	if securityProfile_statusGenerator != nil {
		return securityProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_Status(generators)
	securityProfile_statusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_Status(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile_Status(generators)
	securityProfile_statusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	return securityProfile_statusGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile_Status(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecurityProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile_Status(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettings_StatusGenerator())
}

func Test_StorageProfile_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile_Spec, StorageProfile_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile_Spec runs a test to see if a specific instance of StorageProfile_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile_Spec(subject StorageProfile_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Spec instances for property testing - lazily instantiated by
//StorageProfile_SpecGenerator()
var storageProfile_specGenerator gopter.Gen

// StorageProfile_SpecGenerator returns a generator of StorageProfile_Spec instances for property testing.
func StorageProfile_SpecGenerator() gopter.Gen {
	if storageProfile_specGenerator != nil {
		return storageProfile_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile_Spec(generators)
	storageProfile_specGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Spec{}), generators)

	return storageProfile_specGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile_Spec(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDisk_SpecGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_SpecGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDisk_SpecGenerator())
}

func Test_StorageProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile_Status, StorageProfile_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile_Status runs a test to see if a specific instance of StorageProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile_Status(subject StorageProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Status instances for property testing - lazily instantiated by
//StorageProfile_StatusGenerator()
var storageProfile_statusGenerator gopter.Gen

// StorageProfile_StatusGenerator returns a generator of StorageProfile_Status instances for property testing.
func StorageProfile_StatusGenerator() gopter.Gen {
	if storageProfile_statusGenerator != nil {
		return storageProfile_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile_Status(generators)
	storageProfile_statusGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Status{}), generators)

	return storageProfile_statusGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile_Status(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDisk_StatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_StatusGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDisk_StatusGenerator())
}

func Test_SubResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_Spec, SubResource_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_Spec runs a test to see if a specific instance of SubResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_Spec(subject SubResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Spec instances for property testing - lazily instantiated by SubResource_SpecGenerator()
var subResource_specGenerator gopter.Gen

// SubResource_SpecGenerator returns a generator of SubResource_Spec instances for property testing.
func SubResource_SpecGenerator() gopter.Gen {
	if subResource_specGenerator != nil {
		return subResource_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResource_specGenerator = gen.Struct(reflect.TypeOf(SubResource_Spec{}), generators)

	return subResource_specGenerator
}

func Test_SubResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_Status, SubResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_Status runs a test to see if a specific instance of SubResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_Status(subject SubResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_Status instances for property testing - lazily instantiated by SubResource_StatusGenerator()
var subResource_statusGenerator gopter.Gen

// SubResource_StatusGenerator returns a generator of SubResource_Status instances for property testing.
func SubResource_StatusGenerator() gopter.Gen {
	if subResource_statusGenerator != nil {
		return subResource_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_Status(generators)
	subResource_statusGenerator = gen.Struct(reflect.TypeOf(SubResource_Status{}), generators)

	return subResource_statusGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtension_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtension_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtension_Status, VirtualMachineExtension_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtension_Status runs a test to see if a specific instance of VirtualMachineExtension_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtension_Status(subject VirtualMachineExtension_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtension_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtension_Status instances for property testing - lazily instantiated by
//VirtualMachineExtension_StatusGenerator()
var virtualMachineExtension_statusGenerator gopter.Gen

// VirtualMachineExtension_StatusGenerator returns a generator of VirtualMachineExtension_Status instances for property testing.
// We first initialize virtualMachineExtension_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtension_StatusGenerator() gopter.Gen {
	if virtualMachineExtension_statusGenerator != nil {
		return virtualMachineExtension_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtension_Status(generators)
	virtualMachineExtension_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtension_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtension_Status(generators)
	virtualMachineExtension_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	return virtualMachineExtension_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtension_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtension_Status(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["ForceUpdateTag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtension_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtension_Status(gens map[string]gopter.Gen) {
	gens["InstanceView"] = gen.PtrOf(VirtualMachineExtensionInstanceView_StatusGenerator())
}

func Test_VirtualMachineIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_Spec, VirtualMachineIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_Spec runs a test to see if a specific instance of VirtualMachineIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_Spec(subject VirtualMachineIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Spec instances for property testing - lazily instantiated by
//VirtualMachineIdentity_SpecGenerator()
var virtualMachineIdentity_specGenerator gopter.Gen

// VirtualMachineIdentity_SpecGenerator returns a generator of VirtualMachineIdentity_Spec instances for property testing.
func VirtualMachineIdentity_SpecGenerator() gopter.Gen {
	if virtualMachineIdentity_specGenerator != nil {
		return virtualMachineIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Spec(generators)
	virtualMachineIdentity_specGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Spec{}), generators)

	return virtualMachineIdentity_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_Status, VirtualMachineIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_Status runs a test to see if a specific instance of VirtualMachineIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_Status(subject VirtualMachineIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Status instances for property testing - lazily instantiated by
//VirtualMachineIdentity_StatusGenerator()
var virtualMachineIdentity_statusGenerator gopter.Gen

// VirtualMachineIdentity_StatusGenerator returns a generator of VirtualMachineIdentity_Status instances for property testing.
// We first initialize virtualMachineIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineIdentity_StatusGenerator() gopter.Gen {
	if virtualMachineIdentity_statusGenerator != nil {
		return virtualMachineIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Status(generators)
	virtualMachineIdentity_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineIdentity_Status(generators)
	virtualMachineIdentity_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	return virtualMachineIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator())
}

func Test_VirtualMachineInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceView_Status, VirtualMachineInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceView_Status runs a test to see if a specific instance of VirtualMachineInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceView_Status(subject VirtualMachineInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineInstanceView_StatusGenerator()
var virtualMachineInstanceView_statusGenerator gopter.Gen

// VirtualMachineInstanceView_StatusGenerator returns a generator of VirtualMachineInstanceView_Status instances for property testing.
// We first initialize virtualMachineInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceView_StatusGenerator() gopter.Gen {
	if virtualMachineInstanceView_statusGenerator != nil {
		return virtualMachineInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_Status(generators)
	virtualMachineInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_Status(generators)
	virtualMachineInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	return virtualMachineInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceView_Status(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.AlphaString())
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceView_Status(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceView_StatusGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceView_StatusGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceView_StatusGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatus_StatusGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatus_StatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceView_StatusGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatus_StatusGenerator())
}

func Test_BootDiagnosticsInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceView_Status, BootDiagnosticsInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceView_Status runs a test to see if a specific instance of BootDiagnosticsInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceView_Status(subject BootDiagnosticsInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceView_Status instances for property testing - lazily instantiated by
//BootDiagnosticsInstanceView_StatusGenerator()
var bootDiagnosticsInstanceView_statusGenerator gopter.Gen

// BootDiagnosticsInstanceView_StatusGenerator returns a generator of BootDiagnosticsInstanceView_Status instances for property testing.
// We first initialize bootDiagnosticsInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceView_StatusGenerator() gopter.Gen {
	if bootDiagnosticsInstanceView_statusGenerator != nil {
		return bootDiagnosticsInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_Status(generators)
	bootDiagnosticsInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_Status(generators)
	bootDiagnosticsInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	return bootDiagnosticsInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceView_Status(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusGenerator())
}

func Test_BootDiagnostics_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics_Spec, BootDiagnostics_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics_Spec runs a test to see if a specific instance of BootDiagnostics_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics_Spec(subject BootDiagnostics_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Spec instances for property testing - lazily instantiated by
//BootDiagnostics_SpecGenerator()
var bootDiagnostics_specGenerator gopter.Gen

// BootDiagnostics_SpecGenerator returns a generator of BootDiagnostics_Spec instances for property testing.
func BootDiagnostics_SpecGenerator() gopter.Gen {
	if bootDiagnostics_specGenerator != nil {
		return bootDiagnostics_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics_Spec(generators)
	bootDiagnostics_specGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Spec{}), generators)

	return bootDiagnostics_specGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_BootDiagnostics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics_Status, BootDiagnostics_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics_Status runs a test to see if a specific instance of BootDiagnostics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics_Status(subject BootDiagnostics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Status instances for property testing - lazily instantiated by
//BootDiagnostics_StatusGenerator()
var bootDiagnostics_statusGenerator gopter.Gen

// BootDiagnostics_StatusGenerator returns a generator of BootDiagnostics_Status instances for property testing.
func BootDiagnostics_StatusGenerator() gopter.Gen {
	if bootDiagnostics_statusGenerator != nil {
		return bootDiagnostics_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics_Status(generators)
	bootDiagnostics_statusGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Status{}), generators)

	return bootDiagnostics_statusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk_Spec, DataDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk_Spec runs a test to see if a specific instance of DataDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk_Spec(subject DataDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Spec instances for property testing - lazily instantiated by DataDisk_SpecGenerator()
var dataDisk_specGenerator gopter.Gen

// DataDisk_SpecGenerator returns a generator of DataDisk_Spec instances for property testing.
// We first initialize dataDisk_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDisk_SpecGenerator() gopter.Gen {
	if dataDisk_specGenerator != nil {
		return dataDisk_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_Spec(generators)
	dataDisk_specGenerator = gen.Struct(reflect.TypeOf(DataDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_Spec(generators)
	AddRelatedPropertyGeneratorsForDataDisk_Spec(generators)
	dataDisk_specGenerator = gen.Struct(reflect.TypeOf(DataDisk_Spec{}), generators)

	return dataDisk_specGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk_Spec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DetachOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk_Spec(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_SpecGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
}

func Test_DataDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk_Status, DataDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk_Status runs a test to see if a specific instance of DataDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk_Status(subject DataDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Status instances for property testing - lazily instantiated by DataDisk_StatusGenerator()
var dataDisk_statusGenerator gopter.Gen

// DataDisk_StatusGenerator returns a generator of DataDisk_Status instances for property testing.
// We first initialize dataDisk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDisk_StatusGenerator() gopter.Gen {
	if dataDisk_statusGenerator != nil {
		return dataDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_Status(generators)
	dataDisk_statusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_Status(generators)
	AddRelatedPropertyGeneratorsForDataDisk_Status(generators)
	dataDisk_statusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	return dataDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk_Status(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DetachOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk_Status(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_StatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
}

func Test_DiskInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceView_Status, DiskInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceView_Status runs a test to see if a specific instance of DiskInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceView_Status(subject DiskInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceView_Status instances for property testing - lazily instantiated by
//DiskInstanceView_StatusGenerator()
var diskInstanceView_statusGenerator gopter.Gen

// DiskInstanceView_StatusGenerator returns a generator of DiskInstanceView_Status instances for property testing.
// We first initialize diskInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceView_StatusGenerator() gopter.Gen {
	if diskInstanceView_statusGenerator != nil {
		return diskInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceView_Status(generators)
	diskInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceView_Status(generators)
	diskInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	return diskInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceView_Status(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettings_StatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
}

func Test_ImageReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference_Spec, ImageReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference_Spec runs a test to see if a specific instance of ImageReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference_Spec(subject ImageReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Spec instances for property testing - lazily instantiated by
//ImageReference_SpecGenerator()
var imageReference_specGenerator gopter.Gen

// ImageReference_SpecGenerator returns a generator of ImageReference_Spec instances for property testing.
func ImageReference_SpecGenerator() gopter.Gen {
	if imageReference_specGenerator != nil {
		return imageReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference_Spec(generators)
	imageReference_specGenerator = gen.Struct(reflect.TypeOf(ImageReference_Spec{}), generators)

	return imageReference_specGenerator
}

// AddIndependentPropertyGeneratorsForImageReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference_Spec(gens map[string]gopter.Gen) {
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference_Status, ImageReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference_Status runs a test to see if a specific instance of ImageReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference_Status(subject ImageReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Status instances for property testing - lazily instantiated by
//ImageReference_StatusGenerator()
var imageReference_statusGenerator gopter.Gen

// ImageReference_StatusGenerator returns a generator of ImageReference_Status instances for property testing.
func ImageReference_StatusGenerator() gopter.Gen {
	if imageReference_statusGenerator != nil {
		return imageReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference_Status(generators)
	imageReference_statusGenerator = gen.Struct(reflect.TypeOf(ImageReference_Status{}), generators)

	return imageReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForImageReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference_Status(gens map[string]gopter.Gen) {
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatus_Status, InstanceViewStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatus_Status runs a test to see if a specific instance of InstanceViewStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatus_Status(subject InstanceViewStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_Status instances for property testing - lazily instantiated by
//InstanceViewStatus_StatusGenerator()
var instanceViewStatus_statusGenerator gopter.Gen

// InstanceViewStatus_StatusGenerator returns a generator of InstanceViewStatus_Status instances for property testing.
func InstanceViewStatus_StatusGenerator() gopter.Gen {
	if instanceViewStatus_statusGenerator != nil {
		return instanceViewStatus_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatus_Status(generators)
	instanceViewStatus_statusGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_Status{}), generators)

	return instanceViewStatus_statusGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatus_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatus_Status(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration_Spec, LinuxConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration_Spec runs a test to see if a specific instance of LinuxConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration_Spec(subject LinuxConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Spec instances for property testing - lazily instantiated by
//LinuxConfiguration_SpecGenerator()
var linuxConfiguration_specGenerator gopter.Gen

// LinuxConfiguration_SpecGenerator returns a generator of LinuxConfiguration_Spec instances for property testing.
// We first initialize linuxConfiguration_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfiguration_SpecGenerator() gopter.Gen {
	if linuxConfiguration_specGenerator != nil {
		return linuxConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_Spec(generators)
	linuxConfiguration_specGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_Spec(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration_Spec(generators)
	linuxConfiguration_specGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Spec{}), generators)

	return linuxConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettings_SpecGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfiguration_SpecGenerator())
}

func Test_LinuxConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration_Status, LinuxConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration_Status runs a test to see if a specific instance of LinuxConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration_Status(subject LinuxConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Status instances for property testing - lazily instantiated by
//LinuxConfiguration_StatusGenerator()
var linuxConfiguration_statusGenerator gopter.Gen

// LinuxConfiguration_StatusGenerator returns a generator of LinuxConfiguration_Status instances for property testing.
// We first initialize linuxConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfiguration_StatusGenerator() gopter.Gen {
	if linuxConfiguration_statusGenerator != nil {
		return linuxConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_Status(generators)
	linuxConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration_Status(generators)
	linuxConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	return linuxConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration_Status(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration_Status(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettings_StatusGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfiguration_StatusGenerator())
}

func Test_MaintenanceRedeployStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatus_Status, MaintenanceRedeployStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatus_Status runs a test to see if a specific instance of MaintenanceRedeployStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatus_Status(subject MaintenanceRedeployStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatus_Status instances for property testing - lazily instantiated by
//MaintenanceRedeployStatus_StatusGenerator()
var maintenanceRedeployStatus_statusGenerator gopter.Gen

// MaintenanceRedeployStatus_StatusGenerator returns a generator of MaintenanceRedeployStatus_Status instances for property testing.
func MaintenanceRedeployStatus_StatusGenerator() gopter.Gen {
	if maintenanceRedeployStatus_statusGenerator != nil {
		return maintenanceRedeployStatus_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_Status(generators)
	maintenanceRedeployStatus_statusGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatus_Status{}), generators)

	return maintenanceRedeployStatus_statusGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatus_Status(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReference_Spec, NetworkInterfaceReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReference_Spec runs a test to see if a specific instance of NetworkInterfaceReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReference_Spec(subject NetworkInterfaceReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Spec instances for property testing - lazily instantiated by
//NetworkInterfaceReference_SpecGenerator()
var networkInterfaceReference_specGenerator gopter.Gen

// NetworkInterfaceReference_SpecGenerator returns a generator of NetworkInterfaceReference_Spec instances for property testing.
func NetworkInterfaceReference_SpecGenerator() gopter.Gen {
	if networkInterfaceReference_specGenerator != nil {
		return networkInterfaceReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Spec(generators)
	networkInterfaceReference_specGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Spec{}), generators)

	return networkInterfaceReference_specGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Spec(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkInterfaceReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReference_Status, NetworkInterfaceReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReference_Status runs a test to see if a specific instance of NetworkInterfaceReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReference_Status(subject NetworkInterfaceReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Status instances for property testing - lazily instantiated by
//NetworkInterfaceReference_StatusGenerator()
var networkInterfaceReference_statusGenerator gopter.Gen

// NetworkInterfaceReference_StatusGenerator returns a generator of NetworkInterfaceReference_Status instances for property testing.
func NetworkInterfaceReference_StatusGenerator() gopter.Gen {
	if networkInterfaceReference_statusGenerator != nil {
		return networkInterfaceReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Status(generators)
	networkInterfaceReference_statusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Status{}), generators)

	return networkInterfaceReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReference_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_OSDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk_Spec, OSDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk_Spec runs a test to see if a specific instance of OSDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk_Spec(subject OSDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Spec instances for property testing - lazily instantiated by OSDisk_SpecGenerator()
var osDisk_specGenerator gopter.Gen

// OSDisk_SpecGenerator returns a generator of OSDisk_Spec instances for property testing.
// We first initialize osDisk_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDisk_SpecGenerator() gopter.Gen {
	if osDisk_specGenerator != nil {
		return osDisk_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_Spec(generators)
	osDisk_specGenerator = gen.Struct(reflect.TypeOf(OSDisk_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_Spec(generators)
	AddRelatedPropertyGeneratorsForOSDisk_Spec(generators)
	osDisk_specGenerator = gen.Struct(reflect.TypeOf(OSDisk_Spec{}), generators)

	return osDisk_specGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk_Spec(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk_Spec(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_SpecGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettings_SpecGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_SpecGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_SpecGenerator())
}

func Test_OSDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk_Status, OSDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk_Status runs a test to see if a specific instance of OSDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk_Status(subject OSDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Status instances for property testing - lazily instantiated by OSDisk_StatusGenerator()
var osDisk_statusGenerator gopter.Gen

// OSDisk_StatusGenerator returns a generator of OSDisk_Status instances for property testing.
// We first initialize osDisk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDisk_StatusGenerator() gopter.Gen {
	if osDisk_statusGenerator != nil {
		return osDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_Status(generators)
	osDisk_statusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_Status(generators)
	AddRelatedPropertyGeneratorsForOSDisk_Status(generators)
	osDisk_statusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	return osDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk_Status(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk_Status(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_StatusGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettings_StatusGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_StatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_StatusGenerator())
}

func Test_UefiSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings_Spec, UefiSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings_Spec runs a test to see if a specific instance of UefiSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings_Spec(subject UefiSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Spec instances for property testing - lazily instantiated by UefiSettings_SpecGenerator()
var uefiSettings_specGenerator gopter.Gen

// UefiSettings_SpecGenerator returns a generator of UefiSettings_Spec instances for property testing.
func UefiSettings_SpecGenerator() gopter.Gen {
	if uefiSettings_specGenerator != nil {
		return uefiSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings_Spec(generators)
	uefiSettings_specGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Spec{}), generators)

	return uefiSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings_Spec(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_UefiSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings_Status, UefiSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings_Status runs a test to see if a specific instance of UefiSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings_Status(subject UefiSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Status instances for property testing - lazily instantiated by
//UefiSettings_StatusGenerator()
var uefiSettings_statusGenerator gopter.Gen

// UefiSettings_StatusGenerator returns a generator of UefiSettings_Status instances for property testing.
func UefiSettings_StatusGenerator() gopter.Gen {
	if uefiSettings_statusGenerator != nil {
		return uefiSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings_Status(generators)
	uefiSettings_statusGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Status{}), generators)

	return uefiSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings_Status(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup_Spec, VaultSecretGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup_Spec runs a test to see if a specific instance of VaultSecretGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup_Spec(subject VaultSecretGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Spec instances for property testing - lazily instantiated by
//VaultSecretGroup_SpecGenerator()
var vaultSecretGroup_specGenerator gopter.Gen

// VaultSecretGroup_SpecGenerator returns a generator of VaultSecretGroup_Spec instances for property testing.
func VaultSecretGroup_SpecGenerator() gopter.Gen {
	if vaultSecretGroup_specGenerator != nil {
		return vaultSecretGroup_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup_Spec(generators)
	vaultSecretGroup_specGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Spec{}), generators)

	return vaultSecretGroup_specGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_SpecGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificate_SpecGenerator())
}

func Test_VaultSecretGroup_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup_Status, VaultSecretGroup_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup_Status runs a test to see if a specific instance of VaultSecretGroup_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup_Status(subject VaultSecretGroup_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Status instances for property testing - lazily instantiated by
//VaultSecretGroup_StatusGenerator()
var vaultSecretGroup_statusGenerator gopter.Gen

// VaultSecretGroup_StatusGenerator returns a generator of VaultSecretGroup_Status instances for property testing.
func VaultSecretGroup_StatusGenerator() gopter.Gen {
	if vaultSecretGroup_statusGenerator != nil {
		return vaultSecretGroup_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup_Status(generators)
	vaultSecretGroup_statusGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Status{}), generators)

	return vaultSecretGroup_statusGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_StatusGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificate_StatusGenerator())
}

func Test_VirtualMachineAgentInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceView_Status, VirtualMachineAgentInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceView_Status runs a test to see if a specific instance of VirtualMachineAgentInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceView_Status(subject VirtualMachineAgentInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineAgentInstanceView_StatusGenerator()
var virtualMachineAgentInstanceView_statusGenerator gopter.Gen

// VirtualMachineAgentInstanceView_StatusGenerator returns a generator of VirtualMachineAgentInstanceView_Status instances for property testing.
// We first initialize virtualMachineAgentInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceView_StatusGenerator() gopter.Gen {
	if virtualMachineAgentInstanceView_statusGenerator != nil {
		return virtualMachineAgentInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(generators)
	virtualMachineAgentInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(generators)
	virtualMachineAgentInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	return virtualMachineAgentInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceView_Status(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceView_StatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
}

func Test_VirtualMachineExtensionInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceView_Status, VirtualMachineExtensionInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceView_Status runs a test to see if a specific instance of VirtualMachineExtensionInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceView_Status(subject VirtualMachineExtensionInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceView_Status instances for property testing - lazily instantiated by
//VirtualMachineExtensionInstanceView_StatusGenerator()
var virtualMachineExtensionInstanceView_statusGenerator gopter.Gen

// VirtualMachineExtensionInstanceView_StatusGenerator returns a generator of VirtualMachineExtensionInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceView_StatusGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceView_statusGenerator != nil {
		return virtualMachineExtensionInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(generators)
	virtualMachineExtensionInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(generators)
	virtualMachineExtensionInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	return virtualMachineExtensionInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
}

func Test_VirtualMachineHealthStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatus_Status, VirtualMachineHealthStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatus_Status runs a test to see if a specific instance of VirtualMachineHealthStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatus_Status(subject VirtualMachineHealthStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatus_Status instances for property testing - lazily instantiated by
//VirtualMachineHealthStatus_StatusGenerator()
var virtualMachineHealthStatus_statusGenerator gopter.Gen

// VirtualMachineHealthStatus_StatusGenerator returns a generator of VirtualMachineHealthStatus_Status instances for property testing.
func VirtualMachineHealthStatus_StatusGenerator() gopter.Gen {
	if virtualMachineHealthStatus_statusGenerator != nil {
		return virtualMachineHealthStatus_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_Status(generators)
	virtualMachineHealthStatus_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatus_Status{}), generators)

	return virtualMachineHealthStatus_statusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatus_Status(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusGenerator())
}

func Test_VirtualMachineIdentity_UserAssignedIdentities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_UserAssignedIdentities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_Status, VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_Status runs a test to see if a specific instance of VirtualMachineIdentity_UserAssignedIdentities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentities_Status(subject VirtualMachineIdentity_UserAssignedIdentities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_UserAssignedIdentities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_UserAssignedIdentities_Status instances for property testing - lazily
//instantiated by VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator()
var virtualMachineIdentity_userAssignedIdentities_statusGenerator gopter.Gen

// VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator returns a generator of VirtualMachineIdentity_UserAssignedIdentities_Status instances for property testing.
func VirtualMachineIdentity_UserAssignedIdentities_StatusGenerator() gopter.Gen {
	if virtualMachineIdentity_userAssignedIdentities_statusGenerator != nil {
		return virtualMachineIdentity_userAssignedIdentities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_Status(generators)
	virtualMachineIdentity_userAssignedIdentities_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_UserAssignedIdentities_Status{}), generators)

	return virtualMachineIdentity_userAssignedIdentities_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentities_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinePatchStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatus_Status, VirtualMachinePatchStatus_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatus_Status runs a test to see if a specific instance of VirtualMachinePatchStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatus_Status(subject VirtualMachinePatchStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatus_Status instances for property testing - lazily instantiated by
//VirtualMachinePatchStatus_StatusGenerator()
var virtualMachinePatchStatus_statusGenerator gopter.Gen

// VirtualMachinePatchStatus_StatusGenerator returns a generator of VirtualMachinePatchStatus_Status instances for property testing.
func VirtualMachinePatchStatus_StatusGenerator() gopter.Gen {
	if virtualMachinePatchStatus_statusGenerator != nil {
		return virtualMachinePatchStatus_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_Status(generators)
	virtualMachinePatchStatus_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatus_Status{}), generators)

	return virtualMachinePatchStatus_statusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatus_Status(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummary_StatusGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatus_StatusGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummary_StatusGenerator())
}

func Test_WindowsConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration_Spec, WindowsConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration_Spec runs a test to see if a specific instance of WindowsConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration_Spec(subject WindowsConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Spec instances for property testing - lazily instantiated by
//WindowsConfiguration_SpecGenerator()
var windowsConfiguration_specGenerator gopter.Gen

// WindowsConfiguration_SpecGenerator returns a generator of WindowsConfiguration_Spec instances for property testing.
// We first initialize windowsConfiguration_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfiguration_SpecGenerator() gopter.Gen {
	if windowsConfiguration_specGenerator != nil {
		return windowsConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_Spec(generators)
	windowsConfiguration_specGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_Spec(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration_Spec(generators)
	windowsConfiguration_specGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Spec{}), generators)

	return windowsConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContent_SpecGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettings_SpecGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfiguration_SpecGenerator())
}

func Test_WindowsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration_Status, WindowsConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration_Status runs a test to see if a specific instance of WindowsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration_Status(subject WindowsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Status instances for property testing - lazily instantiated by
//WindowsConfiguration_StatusGenerator()
var windowsConfiguration_statusGenerator gopter.Gen

// WindowsConfiguration_StatusGenerator returns a generator of WindowsConfiguration_Status instances for property testing.
// We first initialize windowsConfiguration_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfiguration_StatusGenerator() gopter.Gen {
	if windowsConfiguration_statusGenerator != nil {
		return windowsConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_Status(generators)
	windowsConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_Status(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration_Status(generators)
	windowsConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	return windowsConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration_Status(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration_Status(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContent_StatusGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettings_StatusGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfiguration_StatusGenerator())
}

func Test_AdditionalUnattendContent_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent_Spec, AdditionalUnattendContent_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent_Spec runs a test to see if a specific instance of AdditionalUnattendContent_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent_Spec(subject AdditionalUnattendContent_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Spec instances for property testing - lazily instantiated by
//AdditionalUnattendContent_SpecGenerator()
var additionalUnattendContent_specGenerator gopter.Gen

// AdditionalUnattendContent_SpecGenerator returns a generator of AdditionalUnattendContent_Spec instances for property testing.
func AdditionalUnattendContent_SpecGenerator() gopter.Gen {
	if additionalUnattendContent_specGenerator != nil {
		return additionalUnattendContent_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Spec(generators)
	additionalUnattendContent_specGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Spec{}), generators)

	return additionalUnattendContent_specGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Spec(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.AlphaString())
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.AlphaString())
	gens["SettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AdditionalUnattendContent_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent_Status, AdditionalUnattendContent_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent_Status runs a test to see if a specific instance of AdditionalUnattendContent_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent_Status(subject AdditionalUnattendContent_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Status instances for property testing - lazily instantiated by
//AdditionalUnattendContent_StatusGenerator()
var additionalUnattendContent_statusGenerator gopter.Gen

// AdditionalUnattendContent_StatusGenerator returns a generator of AdditionalUnattendContent_Status instances for property testing.
func AdditionalUnattendContent_StatusGenerator() gopter.Gen {
	if additionalUnattendContent_statusGenerator != nil {
		return additionalUnattendContent_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Status(generators)
	additionalUnattendContent_statusGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Status{}), generators)

	return additionalUnattendContent_statusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent_Status(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.AlphaString())
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.AlphaString())
	gens["SettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AvailablePatchSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummary_Status, AvailablePatchSummary_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummary_Status runs a test to see if a specific instance of AvailablePatchSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummary_Status(subject AvailablePatchSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummary_Status instances for property testing - lazily instantiated by
//AvailablePatchSummary_StatusGenerator()
var availablePatchSummary_statusGenerator gopter.Gen

// AvailablePatchSummary_StatusGenerator returns a generator of AvailablePatchSummary_Status instances for property testing.
// We first initialize availablePatchSummary_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummary_StatusGenerator() gopter.Gen {
	if availablePatchSummary_statusGenerator != nil {
		return availablePatchSummary_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummary_Status(generators)
	availablePatchSummary_statusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummary_Status(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummary_Status(generators)
	availablePatchSummary_statusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	return availablePatchSummary_statusGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummary_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummary_Status(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummary_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummary_Status(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiError_StatusGenerator())
}

func Test_DiffDiskSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings_Spec, DiffDiskSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings_Spec runs a test to see if a specific instance of DiffDiskSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings_Spec(subject DiffDiskSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Spec instances for property testing - lazily instantiated by
//DiffDiskSettings_SpecGenerator()
var diffDiskSettings_specGenerator gopter.Gen

// DiffDiskSettings_SpecGenerator returns a generator of DiffDiskSettings_Spec instances for property testing.
func DiffDiskSettings_SpecGenerator() gopter.Gen {
	if diffDiskSettings_specGenerator != nil {
		return diffDiskSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings_Spec(generators)
	diffDiskSettings_specGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Spec{}), generators)

	return diffDiskSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings_Spec(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.AlphaString())
	gens["Placement"] = gen.PtrOf(gen.AlphaString())
}

func Test_DiffDiskSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings_Status, DiffDiskSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings_Status runs a test to see if a specific instance of DiffDiskSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings_Status(subject DiffDiskSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Status instances for property testing - lazily instantiated by
//DiffDiskSettings_StatusGenerator()
var diffDiskSettings_statusGenerator gopter.Gen

// DiffDiskSettings_StatusGenerator returns a generator of DiffDiskSettings_Status instances for property testing.
func DiffDiskSettings_StatusGenerator() gopter.Gen {
	if diffDiskSettings_statusGenerator != nil {
		return diffDiskSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings_Status(generators)
	diffDiskSettings_statusGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Status{}), generators)

	return diffDiskSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings_Status(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.AlphaString())
	gens["Placement"] = gen.PtrOf(gen.AlphaString())
}

func Test_DiskEncryptionSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings_Spec, DiskEncryptionSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings_Spec runs a test to see if a specific instance of DiskEncryptionSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings_Spec(subject DiskEncryptionSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Spec instances for property testing - lazily instantiated by
//DiskEncryptionSettings_SpecGenerator()
var diskEncryptionSettings_specGenerator gopter.Gen

// DiskEncryptionSettings_SpecGenerator returns a generator of DiskEncryptionSettings_Spec instances for property testing.
// We first initialize diskEncryptionSettings_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettings_SpecGenerator() gopter.Gen {
	if diskEncryptionSettings_specGenerator != nil {
		return diskEncryptionSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Spec(generators)
	diskEncryptionSettings_specGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Spec(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Spec(generators)
	diskEncryptionSettings_specGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Spec{}), generators)

	return diskEncryptionSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Spec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReference_SpecGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReference_SpecGenerator())
}

func Test_DiskEncryptionSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings_Status, DiskEncryptionSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings_Status runs a test to see if a specific instance of DiskEncryptionSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings_Status(subject DiskEncryptionSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Status instances for property testing - lazily instantiated by
//DiskEncryptionSettings_StatusGenerator()
var diskEncryptionSettings_statusGenerator gopter.Gen

// DiskEncryptionSettings_StatusGenerator returns a generator of DiskEncryptionSettings_Status instances for property testing.
// We first initialize diskEncryptionSettings_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettings_StatusGenerator() gopter.Gen {
	if diskEncryptionSettings_statusGenerator != nil {
		return diskEncryptionSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Status(generators)
	diskEncryptionSettings_statusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Status(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Status(generators)
	diskEncryptionSettings_statusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	return diskEncryptionSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReference_StatusGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReference_StatusGenerator())
}

func Test_LastPatchInstallationSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummary_Status, LastPatchInstallationSummary_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummary_Status runs a test to see if a specific instance of LastPatchInstallationSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummary_Status(subject LastPatchInstallationSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummary_Status instances for property testing - lazily instantiated by
//LastPatchInstallationSummary_StatusGenerator()
var lastPatchInstallationSummary_statusGenerator gopter.Gen

// LastPatchInstallationSummary_StatusGenerator returns a generator of LastPatchInstallationSummary_Status instances for property testing.
// We first initialize lastPatchInstallationSummary_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummary_StatusGenerator() gopter.Gen {
	if lastPatchInstallationSummary_statusGenerator != nil {
		return lastPatchInstallationSummary_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_Status(generators)
	lastPatchInstallationSummary_statusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_Status(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_Status(generators)
	lastPatchInstallationSummary_statusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	return lastPatchInstallationSummary_statusGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummary_Status(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummary_Status(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiError_StatusGenerator())
}

func Test_LinuxPatchSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings_Spec, LinuxPatchSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings_Spec runs a test to see if a specific instance of LinuxPatchSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings_Spec(subject LinuxPatchSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Spec instances for property testing - lazily instantiated by
//LinuxPatchSettings_SpecGenerator()
var linuxPatchSettings_specGenerator gopter.Gen

// LinuxPatchSettings_SpecGenerator returns a generator of LinuxPatchSettings_Spec instances for property testing.
func LinuxPatchSettings_SpecGenerator() gopter.Gen {
	if linuxPatchSettings_specGenerator != nil {
		return linuxPatchSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings_Spec(generators)
	linuxPatchSettings_specGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Spec{}), generators)

	return linuxPatchSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings_Spec(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxPatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings_Status, LinuxPatchSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings_Status runs a test to see if a specific instance of LinuxPatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings_Status(subject LinuxPatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Status instances for property testing - lazily instantiated by
//LinuxPatchSettings_StatusGenerator()
var linuxPatchSettings_statusGenerator gopter.Gen

// LinuxPatchSettings_StatusGenerator returns a generator of LinuxPatchSettings_Status instances for property testing.
func LinuxPatchSettings_StatusGenerator() gopter.Gen {
	if linuxPatchSettings_statusGenerator != nil {
		return linuxPatchSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings_Status(generators)
	linuxPatchSettings_statusGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Status{}), generators)

	return linuxPatchSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings_Status(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedDiskParameters_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters_Spec, ManagedDiskParameters_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters_Spec runs a test to see if a specific instance of ManagedDiskParameters_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters_Spec(subject ManagedDiskParameters_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Spec instances for property testing - lazily instantiated by
//ManagedDiskParameters_SpecGenerator()
var managedDiskParameters_specGenerator gopter.Gen

// ManagedDiskParameters_SpecGenerator returns a generator of ManagedDiskParameters_Spec instances for property testing.
// We first initialize managedDiskParameters_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParameters_SpecGenerator() gopter.Gen {
	if managedDiskParameters_specGenerator != nil {
		return managedDiskParameters_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_Spec(generators)
	managedDiskParameters_specGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_Spec(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters_Spec(generators)
	managedDiskParameters_specGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Spec{}), generators)

	return managedDiskParameters_specGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters_Spec(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters_Spec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_ManagedDiskParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters_Status, ManagedDiskParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters_Status runs a test to see if a specific instance of ManagedDiskParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters_Status(subject ManagedDiskParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Status instances for property testing - lazily instantiated by
//ManagedDiskParameters_StatusGenerator()
var managedDiskParameters_statusGenerator gopter.Gen

// ManagedDiskParameters_StatusGenerator returns a generator of ManagedDiskParameters_Status instances for property testing.
// We first initialize managedDiskParameters_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParameters_StatusGenerator() gopter.Gen {
	if managedDiskParameters_statusGenerator != nil {
		return managedDiskParameters_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_Status(generators)
	managedDiskParameters_statusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_Status(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters_Status(generators)
	managedDiskParameters_statusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	return managedDiskParameters_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_PatchSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings_Spec, PatchSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings_Spec runs a test to see if a specific instance of PatchSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings_Spec(subject PatchSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Spec instances for property testing - lazily instantiated by PatchSettings_SpecGenerator()
var patchSettings_specGenerator gopter.Gen

// PatchSettings_SpecGenerator returns a generator of PatchSettings_Spec instances for property testing.
func PatchSettings_SpecGenerator() gopter.Gen {
	if patchSettings_specGenerator != nil {
		return patchSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings_Spec(generators)
	patchSettings_specGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Spec{}), generators)

	return patchSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings_Spec(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_PatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings_Status, PatchSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings_Status runs a test to see if a specific instance of PatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings_Status(subject PatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Status instances for property testing - lazily instantiated by
//PatchSettings_StatusGenerator()
var patchSettings_statusGenerator gopter.Gen

// PatchSettings_StatusGenerator returns a generator of PatchSettings_Status instances for property testing.
func PatchSettings_StatusGenerator() gopter.Gen {
	if patchSettings_statusGenerator != nil {
		return patchSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings_Status(generators)
	patchSettings_statusGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Status{}), generators)

	return patchSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings_Status(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_SshConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration_Spec, SshConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration_Spec runs a test to see if a specific instance of SshConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration_Spec(subject SshConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Spec instances for property testing - lazily instantiated by
//SshConfiguration_SpecGenerator()
var sshConfiguration_specGenerator gopter.Gen

// SshConfiguration_SpecGenerator returns a generator of SshConfiguration_Spec instances for property testing.
func SshConfiguration_SpecGenerator() gopter.Gen {
	if sshConfiguration_specGenerator != nil {
		return sshConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration_Spec(generators)
	sshConfiguration_specGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Spec{}), generators)

	return sshConfiguration_specGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKey_SpecGenerator())
}

func Test_SshConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration_Status, SshConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration_Status runs a test to see if a specific instance of SshConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration_Status(subject SshConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Status instances for property testing - lazily instantiated by
//SshConfiguration_StatusGenerator()
var sshConfiguration_statusGenerator gopter.Gen

// SshConfiguration_StatusGenerator returns a generator of SshConfiguration_Status instances for property testing.
func SshConfiguration_StatusGenerator() gopter.Gen {
	if sshConfiguration_statusGenerator != nil {
		return sshConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration_Status(generators)
	sshConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Status{}), generators)

	return sshConfiguration_statusGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration_Status(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKey_StatusGenerator())
}

func Test_VaultCertificate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate_Spec, VaultCertificate_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate_Spec runs a test to see if a specific instance of VaultCertificate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate_Spec(subject VaultCertificate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Spec instances for property testing - lazily instantiated by
//VaultCertificate_SpecGenerator()
var vaultCertificate_specGenerator gopter.Gen

// VaultCertificate_SpecGenerator returns a generator of VaultCertificate_Spec instances for property testing.
func VaultCertificate_SpecGenerator() gopter.Gen {
	if vaultCertificate_specGenerator != nil {
		return vaultCertificate_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate_Spec(generators)
	vaultCertificate_specGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Spec{}), generators)

	return vaultCertificate_specGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate_Spec(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VaultCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate_Status, VaultCertificate_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate_Status runs a test to see if a specific instance of VaultCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate_Status(subject VaultCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Status instances for property testing - lazily instantiated by
//VaultCertificate_StatusGenerator()
var vaultCertificate_statusGenerator gopter.Gen

// VaultCertificate_StatusGenerator returns a generator of VaultCertificate_Status instances for property testing.
func VaultCertificate_StatusGenerator() gopter.Gen {
	if vaultCertificate_statusGenerator != nil {
		return vaultCertificate_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate_Status(generators)
	vaultCertificate_statusGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Status{}), generators)

	return vaultCertificate_statusGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate_Status(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk_Spec, VirtualHardDisk_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk_Spec runs a test to see if a specific instance of VirtualHardDisk_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk_Spec(subject VirtualHardDisk_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Spec instances for property testing - lazily instantiated by
//VirtualHardDisk_SpecGenerator()
var virtualHardDisk_specGenerator gopter.Gen

// VirtualHardDisk_SpecGenerator returns a generator of VirtualHardDisk_Spec instances for property testing.
func VirtualHardDisk_SpecGenerator() gopter.Gen {
	if virtualHardDisk_specGenerator != nil {
		return virtualHardDisk_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk_Spec(generators)
	virtualHardDisk_specGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Spec{}), generators)

	return virtualHardDisk_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk_Spec(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk_Status, VirtualHardDisk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk_Status runs a test to see if a specific instance of VirtualHardDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk_Status(subject VirtualHardDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Status instances for property testing - lazily instantiated by
//VirtualHardDisk_StatusGenerator()
var virtualHardDisk_statusGenerator gopter.Gen

// VirtualHardDisk_StatusGenerator returns a generator of VirtualHardDisk_Status instances for property testing.
func VirtualHardDisk_StatusGenerator() gopter.Gen {
	if virtualHardDisk_statusGenerator != nil {
		return virtualHardDisk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk_Status(generators)
	virtualHardDisk_statusGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Status{}), generators)

	return virtualHardDisk_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk_Status(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_Status, VirtualMachineExtensionHandlerInstanceView_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_Status runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceView_Status(subject VirtualMachineExtensionHandlerInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing - lazily instantiated
//by VirtualMachineExtensionHandlerInstanceView_StatusGenerator()
var virtualMachineExtensionHandlerInstanceView_statusGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceView_StatusGenerator returns a generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceView_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceView_StatusGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceView_statusGenerator != nil {
		return virtualMachineExtensionHandlerInstanceView_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(generators)
	virtualMachineExtensionHandlerInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(generators)
	virtualMachineExtensionHandlerInstanceView_statusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	return virtualMachineExtensionHandlerInstanceView_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceView_Status(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatus_StatusGenerator())
}

func Test_WinRMConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration_Spec, WinRMConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration_Spec runs a test to see if a specific instance of WinRMConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration_Spec(subject WinRMConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Spec instances for property testing - lazily instantiated by
//WinRMConfiguration_SpecGenerator()
var winRMConfiguration_specGenerator gopter.Gen

// WinRMConfiguration_SpecGenerator returns a generator of WinRMConfiguration_Spec instances for property testing.
func WinRMConfiguration_SpecGenerator() gopter.Gen {
	if winRMConfiguration_specGenerator != nil {
		return winRMConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration_Spec(generators)
	winRMConfiguration_specGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Spec{}), generators)

	return winRMConfiguration_specGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListener_SpecGenerator())
}

func Test_WinRMConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration_Status, WinRMConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration_Status runs a test to see if a specific instance of WinRMConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration_Status(subject WinRMConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Status instances for property testing - lazily instantiated by
//WinRMConfiguration_StatusGenerator()
var winRMConfiguration_statusGenerator gopter.Gen

// WinRMConfiguration_StatusGenerator returns a generator of WinRMConfiguration_Status instances for property testing.
func WinRMConfiguration_StatusGenerator() gopter.Gen {
	if winRMConfiguration_statusGenerator != nil {
		return winRMConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration_Status(generators)
	winRMConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Status{}), generators)

	return winRMConfiguration_statusGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration_Status(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListener_StatusGenerator())
}

func Test_ApiError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiError_Status, ApiError_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiError_Status runs a test to see if a specific instance of ApiError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiError_Status(subject ApiError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiError_Status instances for property testing - lazily instantiated by ApiError_StatusGenerator()
var apiError_statusGenerator gopter.Gen

// ApiError_StatusGenerator returns a generator of ApiError_Status instances for property testing.
// We first initialize apiError_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiError_StatusGenerator() gopter.Gen {
	if apiError_statusGenerator != nil {
		return apiError_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiError_Status(generators)
	apiError_statusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiError_Status(generators)
	AddRelatedPropertyGeneratorsForApiError_Status(generators)
	apiError_statusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	return apiError_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiError_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiError_Status(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiError_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiError_Status(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBase_StatusGenerator())
	gens["Innererror"] = gen.PtrOf(InnerError_StatusGenerator())
}

func Test_KeyVaultKeyReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference_Spec, KeyVaultKeyReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference_Spec runs a test to see if a specific instance of KeyVaultKeyReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference_Spec(subject KeyVaultKeyReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Spec instances for property testing - lazily instantiated by
//KeyVaultKeyReference_SpecGenerator()
var keyVaultKeyReference_specGenerator gopter.Gen

// KeyVaultKeyReference_SpecGenerator returns a generator of KeyVaultKeyReference_Spec instances for property testing.
// We first initialize keyVaultKeyReference_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReference_SpecGenerator() gopter.Gen {
	if keyVaultKeyReference_specGenerator != nil {
		return keyVaultKeyReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Spec(generators)
	keyVaultKeyReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Spec(generators)
	keyVaultKeyReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Spec{}), generators)

	return keyVaultKeyReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Spec(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_KeyVaultKeyReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference_Status, KeyVaultKeyReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference_Status runs a test to see if a specific instance of KeyVaultKeyReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference_Status(subject KeyVaultKeyReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Status instances for property testing - lazily instantiated by
//KeyVaultKeyReference_StatusGenerator()
var keyVaultKeyReference_statusGenerator gopter.Gen

// KeyVaultKeyReference_StatusGenerator returns a generator of KeyVaultKeyReference_Status instances for property testing.
// We first initialize keyVaultKeyReference_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReference_StatusGenerator() gopter.Gen {
	if keyVaultKeyReference_statusGenerator != nil {
		return keyVaultKeyReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Status(generators)
	keyVaultKeyReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Status(generators)
	keyVaultKeyReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	return keyVaultKeyReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference_Status(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_KeyVaultSecretReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference_Spec, KeyVaultSecretReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference_Spec runs a test to see if a specific instance of KeyVaultSecretReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference_Spec(subject KeyVaultSecretReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Spec instances for property testing - lazily instantiated by
//KeyVaultSecretReference_SpecGenerator()
var keyVaultSecretReference_specGenerator gopter.Gen

// KeyVaultSecretReference_SpecGenerator returns a generator of KeyVaultSecretReference_Spec instances for property testing.
// We first initialize keyVaultSecretReference_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReference_SpecGenerator() gopter.Gen {
	if keyVaultSecretReference_specGenerator != nil {
		return keyVaultSecretReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Spec(generators)
	keyVaultSecretReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Spec(generators)
	keyVaultSecretReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Spec{}), generators)

	return keyVaultSecretReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Spec(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_SpecGenerator())
}

func Test_KeyVaultSecretReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference_Status, KeyVaultSecretReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference_Status runs a test to see if a specific instance of KeyVaultSecretReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference_Status(subject KeyVaultSecretReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Status instances for property testing - lazily instantiated by
//KeyVaultSecretReference_StatusGenerator()
var keyVaultSecretReference_statusGenerator gopter.Gen

// KeyVaultSecretReference_StatusGenerator returns a generator of KeyVaultSecretReference_Status instances for property testing.
// We first initialize keyVaultSecretReference_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReference_StatusGenerator() gopter.Gen {
	if keyVaultSecretReference_statusGenerator != nil {
		return keyVaultSecretReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Status(generators)
	keyVaultSecretReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Status(generators)
	keyVaultSecretReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	return keyVaultSecretReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference_Status(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_StatusGenerator())
}

func Test_SshPublicKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKey_Spec, SshPublicKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKey_Spec runs a test to see if a specific instance of SshPublicKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKey_Spec(subject SshPublicKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Spec instances for property testing - lazily instantiated by SshPublicKey_SpecGenerator()
var sshPublicKey_specGenerator gopter.Gen

// SshPublicKey_SpecGenerator returns a generator of SshPublicKey_Spec instances for property testing.
func SshPublicKey_SpecGenerator() gopter.Gen {
	if sshPublicKey_specGenerator != nil {
		return sshPublicKey_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKey_Spec(generators)
	sshPublicKey_specGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Spec{}), generators)

	return sshPublicKey_specGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKey_Spec(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_SshPublicKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKey_Status, SshPublicKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKey_Status runs a test to see if a specific instance of SshPublicKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKey_Status(subject SshPublicKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Status instances for property testing - lazily instantiated by
//SshPublicKey_StatusGenerator()
var sshPublicKey_statusGenerator gopter.Gen

// SshPublicKey_StatusGenerator returns a generator of SshPublicKey_Status instances for property testing.
func SshPublicKey_StatusGenerator() gopter.Gen {
	if sshPublicKey_statusGenerator != nil {
		return sshPublicKey_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKey_Status(generators)
	sshPublicKey_statusGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Status{}), generators)

	return sshPublicKey_statusGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKey_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKey_Status(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener_Spec, WinRMListener_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener_Spec runs a test to see if a specific instance of WinRMListener_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener_Spec(subject WinRMListener_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Spec instances for property testing - lazily instantiated by WinRMListener_SpecGenerator()
var winRMListener_specGenerator gopter.Gen

// WinRMListener_SpecGenerator returns a generator of WinRMListener_Spec instances for property testing.
func WinRMListener_SpecGenerator() gopter.Gen {
	if winRMListener_specGenerator != nil {
		return winRMListener_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener_Spec(generators)
	winRMListener_specGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Spec{}), generators)

	return winRMListener_specGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener_Spec(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener_Status, WinRMListener_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener_Status runs a test to see if a specific instance of WinRMListener_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener_Status(subject WinRMListener_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Status instances for property testing - lazily instantiated by
//WinRMListener_StatusGenerator()
var winRMListener_statusGenerator gopter.Gen

// WinRMListener_StatusGenerator returns a generator of WinRMListener_Status instances for property testing.
func WinRMListener_StatusGenerator() gopter.Gen {
	if winRMListener_statusGenerator != nil {
		return winRMListener_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener_Status(generators)
	winRMListener_statusGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Status{}), generators)

	return winRMListener_statusGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener_Status(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiErrorBase_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBase_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBase_Status, ApiErrorBase_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBase_Status runs a test to see if a specific instance of ApiErrorBase_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBase_Status(subject ApiErrorBase_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBase_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBase_Status instances for property testing - lazily instantiated by
//ApiErrorBase_StatusGenerator()
var apiErrorBase_statusGenerator gopter.Gen

// ApiErrorBase_StatusGenerator returns a generator of ApiErrorBase_Status instances for property testing.
func ApiErrorBase_StatusGenerator() gopter.Gen {
	if apiErrorBase_statusGenerator != nil {
		return apiErrorBase_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBase_Status(generators)
	apiErrorBase_statusGenerator = gen.Struct(reflect.TypeOf(ApiErrorBase_Status{}), generators)

	return apiErrorBase_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBase_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBase_Status(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerError_Status, InnerError_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerError_Status runs a test to see if a specific instance of InnerError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerError_Status(subject InnerError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_Status instances for property testing - lazily instantiated by InnerError_StatusGenerator()
var innerError_statusGenerator gopter.Gen

// InnerError_StatusGenerator returns a generator of InnerError_Status instances for property testing.
func InnerError_StatusGenerator() gopter.Gen {
	if innerError_statusGenerator != nil {
		return innerError_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_Status(generators)
	innerError_statusGenerator = gen.Struct(reflect.TypeOf(InnerError_Status{}), generators)

	return innerError_statusGenerator
}

// AddIndependentPropertyGeneratorsForInnerError_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerError_Status(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}
