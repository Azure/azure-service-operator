// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200930storage

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/compute/v1alpha1api20201201storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Disk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisk, DiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisk runs a test to see if a specific instance of Disk round trips to JSON and back losslessly
func RunJSONSerializationTestForDisk(subject Disk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk instances for property testing - lazily instantiated by DiskGenerator()
var diskGenerator gopter.Gen

// DiskGenerator returns a generator of Disk instances for property testing.
func DiskGenerator() gopter.Gen {
	if diskGenerator != nil {
		return diskGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDisk(generators)
	diskGenerator = gen.Struct(reflect.TypeOf(Disk{}), generators)

	return diskGenerator
}

// AddRelatedPropertyGeneratorsForDisk is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisk(gens map[string]gopter.Gen) {
	gens["Spec"] = Disks_SPECGenerator()
	gens["Status"] = Disk_StatusGenerator()
}

func Test_Disk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisk_Status, Disk_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisk_Status runs a test to see if a specific instance of Disk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDisk_Status(subject Disk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk_Status instances for property testing - lazily instantiated by Disk_StatusGenerator()
var disk_statusGenerator gopter.Gen

// Disk_StatusGenerator returns a generator of Disk_Status instances for property testing.
// We first initialize disk_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disk_StatusGenerator() gopter.Gen {
	if disk_statusGenerator != nil {
		return disk_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_Status(generators)
	disk_statusGenerator = gen.Struct(reflect.TypeOf(Disk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_Status(generators)
	AddRelatedPropertyGeneratorsForDisk_Status(generators)
	disk_statusGenerator = gen.Struct(reflect.TypeOf(Disk_Status{}), generators)

	return disk_statusGenerator
}

// AddIndependentPropertyGeneratorsForDisk_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisk_Status(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeBytes"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedByExtended"] = gen.SliceOf(gen.AlphaString())
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["TimeCreated"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisk_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisk_Status(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationData_StatusGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_StatusGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollection_StatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_StatusGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlan_StatusGenerator())
	gens["ShareInfo"] = gen.SliceOf(ShareInfoElement_StatusGenerator())
	gens["Sku"] = gen.PtrOf(DiskSku_StatusGenerator())
}

func Test_Disks_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disks_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisks_SPEC, Disks_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisks_SPEC runs a test to see if a specific instance of Disks_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDisks_SPEC(subject Disks_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disks_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disks_SPEC instances for property testing - lazily instantiated by Disks_SPECGenerator()
var disks_specGenerator gopter.Gen

// Disks_SPECGenerator returns a generator of Disks_SPEC instances for property testing.
// We first initialize disks_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disks_SPECGenerator() gopter.Gen {
	if disks_specGenerator != nil {
		return disks_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisks_SPEC(generators)
	disks_specGenerator = gen.Struct(reflect.TypeOf(Disks_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisks_SPEC(generators)
	AddRelatedPropertyGeneratorsForDisks_SPEC(generators)
	disks_specGenerator = gen.Struct(reflect.TypeOf(Disks_SPEC{}), generators)

	return disks_specGenerator
}

// AddIndependentPropertyGeneratorsForDisks_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisks_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisks_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisks_SPEC(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationData_SpecGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_SpecGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollection_SpecGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_SpecGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlan_SpecGenerator())
	gens["Sku"] = gen.PtrOf(DiskSku_SpecGenerator())
}

func Test_CreationData_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationData_Spec, CreationData_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationData_Spec runs a test to see if a specific instance of CreationData_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationData_Spec(subject CreationData_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_Spec instances for property testing - lazily instantiated by CreationData_SpecGenerator()
var creationData_specGenerator gopter.Gen

// CreationData_SpecGenerator returns a generator of CreationData_Spec instances for property testing.
// We first initialize creationData_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationData_SpecGenerator() gopter.Gen {
	if creationData_specGenerator != nil {
		return creationData_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_Spec(generators)
	creationData_specGenerator = gen.Struct(reflect.TypeOf(CreationData_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_Spec(generators)
	AddRelatedPropertyGeneratorsForCreationData_Spec(generators)
	creationData_specGenerator = gen.Struct(reflect.TypeOf(CreationData_Spec{}), generators)

	return creationData_specGenerator
}

// AddIndependentPropertyGeneratorsForCreationData_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationData_Spec(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationData_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationData_Spec(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReference_SpecGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReference_SpecGenerator())
}

func Test_CreationData_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationData_Status, CreationData_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationData_Status runs a test to see if a specific instance of CreationData_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationData_Status(subject CreationData_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_Status instances for property testing - lazily instantiated by
//CreationData_StatusGenerator()
var creationData_statusGenerator gopter.Gen

// CreationData_StatusGenerator returns a generator of CreationData_Status instances for property testing.
// We first initialize creationData_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationData_StatusGenerator() gopter.Gen {
	if creationData_statusGenerator != nil {
		return creationData_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_Status(generators)
	creationData_statusGenerator = gen.Struct(reflect.TypeOf(CreationData_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_Status(generators)
	AddRelatedPropertyGeneratorsForCreationData_Status(generators)
	creationData_statusGenerator = gen.Struct(reflect.TypeOf(CreationData_Status{}), generators)

	return creationData_statusGenerator
}

// AddIndependentPropertyGeneratorsForCreationData_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationData_Status(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationData_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationData_Status(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReference_StatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReference_StatusGenerator())
}

func Test_DiskSku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSku_Spec, DiskSku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSku_Spec runs a test to see if a specific instance of DiskSku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSku_Spec(subject DiskSku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_Spec instances for property testing - lazily instantiated by DiskSku_SpecGenerator()
var diskSku_specGenerator gopter.Gen

// DiskSku_SpecGenerator returns a generator of DiskSku_Spec instances for property testing.
func DiskSku_SpecGenerator() gopter.Gen {
	if diskSku_specGenerator != nil {
		return diskSku_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSku_Spec(generators)
	diskSku_specGenerator = gen.Struct(reflect.TypeOf(DiskSku_Spec{}), generators)

	return diskSku_specGenerator
}

// AddIndependentPropertyGeneratorsForDiskSku_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSku_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_DiskSku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSku_Status, DiskSku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSku_Status runs a test to see if a specific instance of DiskSku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSku_Status(subject DiskSku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_Status instances for property testing - lazily instantiated by DiskSku_StatusGenerator()
var diskSku_statusGenerator gopter.Gen

// DiskSku_StatusGenerator returns a generator of DiskSku_Status instances for property testing.
func DiskSku_StatusGenerator() gopter.Gen {
	if diskSku_statusGenerator != nil {
		return diskSku_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSku_Status(generators)
	diskSku_statusGenerator = gen.Struct(reflect.TypeOf(DiskSku_Status{}), generators)

	return diskSku_statusGenerator
}

// AddIndependentPropertyGeneratorsForDiskSku_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSku_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsCollection_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollection_Spec, EncryptionSettingsCollection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollection_Spec runs a test to see if a specific instance of EncryptionSettingsCollection_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollection_Spec(subject EncryptionSettingsCollection_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_Spec instances for property testing - lazily instantiated by
//EncryptionSettingsCollection_SpecGenerator()
var encryptionSettingsCollection_specGenerator gopter.Gen

// EncryptionSettingsCollection_SpecGenerator returns a generator of EncryptionSettingsCollection_Spec instances for property testing.
// We first initialize encryptionSettingsCollection_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollection_SpecGenerator() gopter.Gen {
	if encryptionSettingsCollection_specGenerator != nil {
		return encryptionSettingsCollection_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Spec(generators)
	encryptionSettingsCollection_specGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Spec(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Spec(generators)
	encryptionSettingsCollection_specGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_Spec{}), generators)

	return encryptionSettingsCollection_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Spec(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElement_SpecGenerator())
}

func Test_EncryptionSettingsCollection_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollection_Status, EncryptionSettingsCollection_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollection_Status runs a test to see if a specific instance of EncryptionSettingsCollection_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollection_Status(subject EncryptionSettingsCollection_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_Status instances for property testing - lazily instantiated by
//EncryptionSettingsCollection_StatusGenerator()
var encryptionSettingsCollection_statusGenerator gopter.Gen

// EncryptionSettingsCollection_StatusGenerator returns a generator of EncryptionSettingsCollection_Status instances for property testing.
// We first initialize encryptionSettingsCollection_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollection_StatusGenerator() gopter.Gen {
	if encryptionSettingsCollection_statusGenerator != nil {
		return encryptionSettingsCollection_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Status(generators)
	encryptionSettingsCollection_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Status(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Status(generators)
	encryptionSettingsCollection_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_Status{}), generators)

	return encryptionSettingsCollection_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_Status(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElement_StatusGenerator())
}

func Test_Encryption_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_Spec, Encryption_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_Spec runs a test to see if a specific instance of Encryption_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_Spec(subject Encryption_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Spec instances for property testing - lazily instantiated by Encryption_SpecGenerator()
var encryption_specGenerator gopter.Gen

// Encryption_SpecGenerator returns a generator of Encryption_Spec instances for property testing.
func Encryption_SpecGenerator() gopter.Gen {
	if encryption_specGenerator != nil {
		return encryption_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Spec(generators)
	encryption_specGenerator = gen.Struct(reflect.TypeOf(Encryption_Spec{}), generators)

	return encryption_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Encryption_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_Status, Encryption_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_Status runs a test to see if a specific instance of Encryption_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_Status(subject Encryption_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Status instances for property testing - lazily instantiated by Encryption_StatusGenerator()
var encryption_statusGenerator gopter.Gen

// Encryption_StatusGenerator returns a generator of Encryption_Status instances for property testing.
func Encryption_StatusGenerator() gopter.Gen {
	if encryption_statusGenerator != nil {
		return encryption_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Status(generators)
	encryption_statusGenerator = gen.Struct(reflect.TypeOf(Encryption_Status{}), generators)

	return encryption_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Spec to ExtendedLocation_Spec via AssignPropertiesToExtendedLocation_Spec & AssignPropertiesFromExtendedLocation_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Spec tests if a specific instance of ExtendedLocation_Spec can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ExtendedLocation_Spec
	err := copied.AssignPropertiesToExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Spec
	err = actual.AssignPropertiesFromExtendedLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Spec, ExtendedLocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Spec runs a test to see if a specific instance of ExtendedLocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Spec(subject ExtendedLocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Spec instances for property testing - lazily instantiated by
//ExtendedLocation_SpecGenerator()
var extendedLocation_specGenerator gopter.Gen

// ExtendedLocation_SpecGenerator returns a generator of ExtendedLocation_Spec instances for property testing.
func ExtendedLocation_SpecGenerator() gopter.Gen {
	if extendedLocation_specGenerator != nil {
		return extendedLocation_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Spec(generators)
	extendedLocation_specGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Spec{}), generators)

	return extendedLocation_specGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_Status to ExtendedLocation_Status via AssignPropertiesToExtendedLocation_Status & AssignPropertiesFromExtendedLocation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_Status tests if a specific instance of ExtendedLocation_Status can be assigned to v1alpha1api20201201storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20201201storage.ExtendedLocation_Status
	err := copied.AssignPropertiesToExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_Status
	err = actual.AssignPropertiesFromExtendedLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_Status, ExtendedLocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_Status runs a test to see if a specific instance of ExtendedLocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_Status(subject ExtendedLocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_Status instances for property testing - lazily instantiated by
//ExtendedLocation_StatusGenerator()
var extendedLocation_statusGenerator gopter.Gen

// ExtendedLocation_StatusGenerator returns a generator of ExtendedLocation_Status instances for property testing.
func ExtendedLocation_StatusGenerator() gopter.Gen {
	if extendedLocation_statusGenerator != nil {
		return extendedLocation_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_Status(generators)
	extendedLocation_statusGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_Status{}), generators)

	return extendedLocation_statusGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_PurchasePlan_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlan_Spec, PurchasePlan_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlan_Spec runs a test to see if a specific instance of PurchasePlan_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlan_Spec(subject PurchasePlan_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_Spec instances for property testing - lazily instantiated by PurchasePlan_SpecGenerator()
var purchasePlan_specGenerator gopter.Gen

// PurchasePlan_SpecGenerator returns a generator of PurchasePlan_Spec instances for property testing.
func PurchasePlan_SpecGenerator() gopter.Gen {
	if purchasePlan_specGenerator != nil {
		return purchasePlan_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlan_Spec(generators)
	purchasePlan_specGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_Spec{}), generators)

	return purchasePlan_specGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlan_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlan_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_PurchasePlan_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlan_Status, PurchasePlan_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlan_Status runs a test to see if a specific instance of PurchasePlan_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlan_Status(subject PurchasePlan_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_Status instances for property testing - lazily instantiated by
//PurchasePlan_StatusGenerator()
var purchasePlan_statusGenerator gopter.Gen

// PurchasePlan_StatusGenerator returns a generator of PurchasePlan_Status instances for property testing.
func PurchasePlan_StatusGenerator() gopter.Gen {
	if purchasePlan_statusGenerator != nil {
		return purchasePlan_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlan_Status(generators)
	purchasePlan_statusGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_Status{}), generators)

	return purchasePlan_statusGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlan_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlan_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_ShareInfoElement_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShareInfoElement_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShareInfoElement_Status, ShareInfoElement_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShareInfoElement_Status runs a test to see if a specific instance of ShareInfoElement_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForShareInfoElement_Status(subject ShareInfoElement_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShareInfoElement_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShareInfoElement_Status instances for property testing - lazily instantiated by
//ShareInfoElement_StatusGenerator()
var shareInfoElement_statusGenerator gopter.Gen

// ShareInfoElement_StatusGenerator returns a generator of ShareInfoElement_Status instances for property testing.
func ShareInfoElement_StatusGenerator() gopter.Gen {
	if shareInfoElement_statusGenerator != nil {
		return shareInfoElement_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShareInfoElement_Status(generators)
	shareInfoElement_statusGenerator = gen.Struct(reflect.TypeOf(ShareInfoElement_Status{}), generators)

	return shareInfoElement_statusGenerator
}

// AddIndependentPropertyGeneratorsForShareInfoElement_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShareInfoElement_Status(gens map[string]gopter.Gen) {
	gens["VmUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsElement_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElement_Spec, EncryptionSettingsElement_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElement_Spec runs a test to see if a specific instance of EncryptionSettingsElement_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElement_Spec(subject EncryptionSettingsElement_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_Spec instances for property testing - lazily instantiated by
//EncryptionSettingsElement_SpecGenerator()
var encryptionSettingsElement_specGenerator gopter.Gen

// EncryptionSettingsElement_SpecGenerator returns a generator of EncryptionSettingsElement_Spec instances for property testing.
func EncryptionSettingsElement_SpecGenerator() gopter.Gen {
	if encryptionSettingsElement_specGenerator != nil {
		return encryptionSettingsElement_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Spec(generators)
	encryptionSettingsElement_specGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_Spec{}), generators)

	return encryptionSettingsElement_specGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Spec(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReference_SpecGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReference_SpecGenerator())
}

func Test_EncryptionSettingsElement_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElement_Status, EncryptionSettingsElement_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElement_Status runs a test to see if a specific instance of EncryptionSettingsElement_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElement_Status(subject EncryptionSettingsElement_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_Status instances for property testing - lazily instantiated by
//EncryptionSettingsElement_StatusGenerator()
var encryptionSettingsElement_statusGenerator gopter.Gen

// EncryptionSettingsElement_StatusGenerator returns a generator of EncryptionSettingsElement_Status instances for property testing.
func EncryptionSettingsElement_StatusGenerator() gopter.Gen {
	if encryptionSettingsElement_statusGenerator != nil {
		return encryptionSettingsElement_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Status(generators)
	encryptionSettingsElement_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_Status{}), generators)

	return encryptionSettingsElement_statusGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElement_Status(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReference_StatusGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReference_StatusGenerator())
}

func Test_ImageDiskReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReference_Spec, ImageDiskReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReference_Spec runs a test to see if a specific instance of ImageDiskReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReference_Spec(subject ImageDiskReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_Spec instances for property testing - lazily instantiated by
//ImageDiskReference_SpecGenerator()
var imageDiskReference_specGenerator gopter.Gen

// ImageDiskReference_SpecGenerator returns a generator of ImageDiskReference_Spec instances for property testing.
func ImageDiskReference_SpecGenerator() gopter.Gen {
	if imageDiskReference_specGenerator != nil {
		return imageDiskReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReference_Spec(generators)
	imageDiskReference_specGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_Spec{}), generators)

	return imageDiskReference_specGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReference_Spec(gens map[string]gopter.Gen) {
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_ImageDiskReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReference_Status, ImageDiskReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReference_Status runs a test to see if a specific instance of ImageDiskReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReference_Status(subject ImageDiskReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_Status instances for property testing - lazily instantiated by
//ImageDiskReference_StatusGenerator()
var imageDiskReference_statusGenerator gopter.Gen

// ImageDiskReference_StatusGenerator returns a generator of ImageDiskReference_Status instances for property testing.
func ImageDiskReference_StatusGenerator() gopter.Gen {
	if imageDiskReference_statusGenerator != nil {
		return imageDiskReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReference_Status(generators)
	imageDiskReference_statusGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_Status{}), generators)

	return imageDiskReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReference_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_KeyVaultAndKeyReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReference_Spec, KeyVaultAndKeyReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReference_Spec runs a test to see if a specific instance of KeyVaultAndKeyReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReference_Spec(subject KeyVaultAndKeyReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_Spec instances for property testing - lazily instantiated by
//KeyVaultAndKeyReference_SpecGenerator()
var keyVaultAndKeyReference_specGenerator gopter.Gen

// KeyVaultAndKeyReference_SpecGenerator returns a generator of KeyVaultAndKeyReference_Spec instances for property testing.
// We first initialize keyVaultAndKeyReference_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReference_SpecGenerator() gopter.Gen {
	if keyVaultAndKeyReference_specGenerator != nil {
		return keyVaultAndKeyReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Spec(generators)
	keyVaultAndKeyReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Spec(generators)
	keyVaultAndKeyReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_Spec{}), generators)

	return keyVaultAndKeyReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Spec(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVault_SpecGenerator())
}

func Test_KeyVaultAndKeyReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReference_Status, KeyVaultAndKeyReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReference_Status runs a test to see if a specific instance of KeyVaultAndKeyReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReference_Status(subject KeyVaultAndKeyReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_Status instances for property testing - lazily instantiated by
//KeyVaultAndKeyReference_StatusGenerator()
var keyVaultAndKeyReference_statusGenerator gopter.Gen

// KeyVaultAndKeyReference_StatusGenerator returns a generator of KeyVaultAndKeyReference_Status instances for property testing.
// We first initialize keyVaultAndKeyReference_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReference_StatusGenerator() gopter.Gen {
	if keyVaultAndKeyReference_statusGenerator != nil {
		return keyVaultAndKeyReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Status(generators)
	keyVaultAndKeyReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Status(generators)
	keyVaultAndKeyReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_Status{}), generators)

	return keyVaultAndKeyReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_Status(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVault_StatusGenerator())
}

func Test_KeyVaultAndSecretReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReference_Spec, KeyVaultAndSecretReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReference_Spec runs a test to see if a specific instance of KeyVaultAndSecretReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReference_Spec(subject KeyVaultAndSecretReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_Spec instances for property testing - lazily instantiated by
//KeyVaultAndSecretReference_SpecGenerator()
var keyVaultAndSecretReference_specGenerator gopter.Gen

// KeyVaultAndSecretReference_SpecGenerator returns a generator of KeyVaultAndSecretReference_Spec instances for property testing.
// We first initialize keyVaultAndSecretReference_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReference_SpecGenerator() gopter.Gen {
	if keyVaultAndSecretReference_specGenerator != nil {
		return keyVaultAndSecretReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Spec(generators)
	keyVaultAndSecretReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Spec(generators)
	keyVaultAndSecretReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_Spec{}), generators)

	return keyVaultAndSecretReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Spec(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Spec(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVault_SpecGenerator())
}

func Test_KeyVaultAndSecretReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReference_Status, KeyVaultAndSecretReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReference_Status runs a test to see if a specific instance of KeyVaultAndSecretReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReference_Status(subject KeyVaultAndSecretReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_Status instances for property testing - lazily instantiated by
//KeyVaultAndSecretReference_StatusGenerator()
var keyVaultAndSecretReference_statusGenerator gopter.Gen

// KeyVaultAndSecretReference_StatusGenerator returns a generator of KeyVaultAndSecretReference_Status instances for property testing.
// We first initialize keyVaultAndSecretReference_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReference_StatusGenerator() gopter.Gen {
	if keyVaultAndSecretReference_statusGenerator != nil {
		return keyVaultAndSecretReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Status(generators)
	keyVaultAndSecretReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Status(generators)
	keyVaultAndSecretReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_Status{}), generators)

	return keyVaultAndSecretReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_Status(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_Status(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVault_StatusGenerator())
}

func Test_SourceVault_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVault_Spec, SourceVault_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVault_Spec runs a test to see if a specific instance of SourceVault_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVault_Spec(subject SourceVault_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_Spec instances for property testing - lazily instantiated by SourceVault_SpecGenerator()
var sourceVault_specGenerator gopter.Gen

// SourceVault_SpecGenerator returns a generator of SourceVault_Spec instances for property testing.
func SourceVault_SpecGenerator() gopter.Gen {
	if sourceVault_specGenerator != nil {
		return sourceVault_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	sourceVault_specGenerator = gen.Struct(reflect.TypeOf(SourceVault_Spec{}), generators)

	return sourceVault_specGenerator
}

func Test_SourceVault_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVault_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVault_Status, SourceVault_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVault_Status runs a test to see if a specific instance of SourceVault_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVault_Status(subject SourceVault_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVault_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVault_Status instances for property testing - lazily instantiated by SourceVault_StatusGenerator()
var sourceVault_statusGenerator gopter.Gen

// SourceVault_StatusGenerator returns a generator of SourceVault_Status instances for property testing.
func SourceVault_StatusGenerator() gopter.Gen {
	if sourceVault_statusGenerator != nil {
		return sourceVault_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSourceVault_Status(generators)
	sourceVault_statusGenerator = gen.Struct(reflect.TypeOf(SourceVault_Status{}), generators)

	return sourceVault_statusGenerator
}

// AddIndependentPropertyGeneratorsForSourceVault_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSourceVault_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
