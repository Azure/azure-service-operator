// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine, VirtualMachineGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine runs a test to see if a specific instance of VirtualMachine round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine(subject VirtualMachine) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine instances for property testing - lazily instantiated by VirtualMachineGenerator()
var virtualMachineGenerator gopter.Gen

// VirtualMachineGenerator returns a generator of VirtualMachine instances for property testing.
func VirtualMachineGenerator() gopter.Gen {
	if virtualMachineGenerator != nil {
		return virtualMachineGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachine(generators)
	virtualMachineGenerator = gen.Struct(reflect.TypeOf(VirtualMachine{}), generators)

	return virtualMachineGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachine is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine(gens map[string]gopter.Gen) {
	gens["Spec"] = VirtualMachinesSpecGenerator()
	gens["Status"] = VirtualMachineStatusGenerator()
}

func Test_VirtualMachine_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineStatus, VirtualMachineStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineStatus runs a test to see if a specific instance of VirtualMachine_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineStatus(subject VirtualMachine_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_Status instances for property testing - lazily instantiated by
// VirtualMachineStatusGenerator()
var virtualMachineStatusGenerator gopter.Gen

// VirtualMachineStatusGenerator returns a generator of VirtualMachine_Status instances for property testing.
// We first initialize virtualMachineStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineStatusGenerator() gopter.Gen {
	if virtualMachineStatusGenerator != nil {
		return virtualMachineStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineStatus(generators)
	virtualMachineStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineStatus(generators)
	virtualMachineStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Status{}), generators)

	return virtualMachineStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineStatus(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["TimeCreated"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UserData"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineStatus(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesStatusGenerator())
	gens["ApplicationProfile"] = gen.PtrOf(ApplicationProfileStatusGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileStatusGenerator())
	gens["CapacityReservation"] = gen.PtrOf(CapacityReservationProfileStatusGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileStatusGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationStatusGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileStatusGenerator())
	gens["Host"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentityStatusGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceViewStatusGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileStatusGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileStatusGenerator())
	gens["Plan"] = gen.PtrOf(PlanStatusGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Resources"] = gen.SliceOf(VirtualMachineExtensionStatusGenerator())
	gens["ScheduledEventsProfile"] = gen.PtrOf(ScheduledEventsProfileStatusGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileStatusGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileStatusGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_VirtualMachines_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpec, VirtualMachinesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpec runs a test to see if a specific instance of VirtualMachines_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpec(subject VirtualMachines_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec instances for property testing - lazily instantiated by
// VirtualMachinesSpecGenerator()
var virtualMachinesSpecGenerator gopter.Gen

// VirtualMachinesSpecGenerator returns a generator of VirtualMachines_Spec instances for property testing.
// We first initialize virtualMachinesSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecGenerator() gopter.Gen {
	if virtualMachinesSpecGenerator != nil {
		return virtualMachinesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpec(generators)
	virtualMachinesSpecGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpec(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpec(generators)
	virtualMachinesSpecGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec{}), generators)

	return virtualMachinesSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["UserData"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpec(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesGenerator())
	gens["ApplicationProfile"] = gen.PtrOf(ApplicationProfileGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileGenerator())
	gens["CapacityReservation"] = gen.PtrOf(CapacityReservationProfileGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileGenerator())
	gens["Host"] = gen.PtrOf(SubResourceGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentityGenerator())
	gens["NetworkProfile"] = gen.PtrOf(VirtualMachinesSpecPropertiesNetworkProfileGenerator())
	gens["OsProfile"] = gen.PtrOf(VirtualMachinesSpecPropertiesOsProfileGenerator())
	gens["Plan"] = gen.PtrOf(PlanGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceGenerator())
	gens["ScheduledEventsProfile"] = gen.PtrOf(ScheduledEventsProfileGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceGenerator())
}

func Test_AdditionalCapabilities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilities, AdditionalCapabilitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilities runs a test to see if a specific instance of AdditionalCapabilities round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilities(subject AdditionalCapabilities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities instances for property testing - lazily instantiated by
// AdditionalCapabilitiesGenerator()
var additionalCapabilitiesGenerator gopter.Gen

// AdditionalCapabilitiesGenerator returns a generator of AdditionalCapabilities instances for property testing.
func AdditionalCapabilitiesGenerator() gopter.Gen {
	if additionalCapabilitiesGenerator != nil {
		return additionalCapabilitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilities(generators)
	additionalCapabilitiesGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities{}), generators)

	return additionalCapabilitiesGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilities(gens map[string]gopter.Gen) {
	gens["HibernationEnabled"] = gen.PtrOf(gen.Bool())
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_AdditionalCapabilities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalCapabilities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalCapabilitiesStatus, AdditionalCapabilitiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalCapabilitiesStatus runs a test to see if a specific instance of AdditionalCapabilities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalCapabilitiesStatus(subject AdditionalCapabilities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalCapabilities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalCapabilities_Status instances for property testing - lazily instantiated by
// AdditionalCapabilitiesStatusGenerator()
var additionalCapabilitiesStatusGenerator gopter.Gen

// AdditionalCapabilitiesStatusGenerator returns a generator of AdditionalCapabilities_Status instances for property testing.
func AdditionalCapabilitiesStatusGenerator() gopter.Gen {
	if additionalCapabilitiesStatusGenerator != nil {
		return additionalCapabilitiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus(generators)
	additionalCapabilitiesStatusGenerator = gen.Struct(reflect.TypeOf(AdditionalCapabilities_Status{}), generators)

	return additionalCapabilitiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalCapabilitiesStatus(gens map[string]gopter.Gen) {
	gens["HibernationEnabled"] = gen.PtrOf(gen.Bool())
	gens["UltraSSDEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_ApplicationProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationProfile, ApplicationProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationProfile runs a test to see if a specific instance of ApplicationProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationProfile(subject ApplicationProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationProfile instances for property testing - lazily instantiated by ApplicationProfileGenerator()
var applicationProfileGenerator gopter.Gen

// ApplicationProfileGenerator returns a generator of ApplicationProfile instances for property testing.
func ApplicationProfileGenerator() gopter.Gen {
	if applicationProfileGenerator != nil {
		return applicationProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForApplicationProfile(generators)
	applicationProfileGenerator = gen.Struct(reflect.TypeOf(ApplicationProfile{}), generators)

	return applicationProfileGenerator
}

// AddRelatedPropertyGeneratorsForApplicationProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationProfile(gens map[string]gopter.Gen) {
	gens["GalleryApplications"] = gen.SliceOf(VMGalleryApplicationGenerator())
}

func Test_ApplicationProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationProfileStatus, ApplicationProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationProfileStatus runs a test to see if a specific instance of ApplicationProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationProfileStatus(subject ApplicationProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationProfile_Status instances for property testing - lazily instantiated by
// ApplicationProfileStatusGenerator()
var applicationProfileStatusGenerator gopter.Gen

// ApplicationProfileStatusGenerator returns a generator of ApplicationProfile_Status instances for property testing.
func ApplicationProfileStatusGenerator() gopter.Gen {
	if applicationProfileStatusGenerator != nil {
		return applicationProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForApplicationProfileStatus(generators)
	applicationProfileStatusGenerator = gen.Struct(reflect.TypeOf(ApplicationProfile_Status{}), generators)

	return applicationProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForApplicationProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationProfileStatus(gens map[string]gopter.Gen) {
	gens["GalleryApplications"] = gen.SliceOf(VMGalleryApplicationStatusGenerator())
}

func Test_BillingProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile, BillingProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile runs a test to see if a specific instance of BillingProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile(subject BillingProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile instances for property testing - lazily instantiated by BillingProfileGenerator()
var billingProfileGenerator gopter.Gen

// BillingProfileGenerator returns a generator of BillingProfile instances for property testing.
func BillingProfileGenerator() gopter.Gen {
	if billingProfileGenerator != nil {
		return billingProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile(generators)
	billingProfileGenerator = gen.Struct(reflect.TypeOf(BillingProfile{}), generators)

	return billingProfileGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_BillingProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileStatus, BillingProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileStatus runs a test to see if a specific instance of BillingProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileStatus(subject BillingProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_Status instances for property testing - lazily instantiated by
// BillingProfileStatusGenerator()
var billingProfileStatusGenerator gopter.Gen

// BillingProfileStatusGenerator returns a generator of BillingProfile_Status instances for property testing.
func BillingProfileStatusGenerator() gopter.Gen {
	if billingProfileStatusGenerator != nil {
		return billingProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileStatus(generators)
	billingProfileStatusGenerator = gen.Struct(reflect.TypeOf(BillingProfile_Status{}), generators)

	return billingProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileStatus(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_CapacityReservationProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CapacityReservationProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapacityReservationProfile, CapacityReservationProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapacityReservationProfile runs a test to see if a specific instance of CapacityReservationProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForCapacityReservationProfile(subject CapacityReservationProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CapacityReservationProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CapacityReservationProfile instances for property testing - lazily instantiated by
// CapacityReservationProfileGenerator()
var capacityReservationProfileGenerator gopter.Gen

// CapacityReservationProfileGenerator returns a generator of CapacityReservationProfile instances for property testing.
func CapacityReservationProfileGenerator() gopter.Gen {
	if capacityReservationProfileGenerator != nil {
		return capacityReservationProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCapacityReservationProfile(generators)
	capacityReservationProfileGenerator = gen.Struct(reflect.TypeOf(CapacityReservationProfile{}), generators)

	return capacityReservationProfileGenerator
}

// AddRelatedPropertyGeneratorsForCapacityReservationProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCapacityReservationProfile(gens map[string]gopter.Gen) {
	gens["CapacityReservationGroup"] = gen.PtrOf(SubResourceGenerator())
}

func Test_CapacityReservationProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CapacityReservationProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapacityReservationProfileStatus, CapacityReservationProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapacityReservationProfileStatus runs a test to see if a specific instance of CapacityReservationProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCapacityReservationProfileStatus(subject CapacityReservationProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CapacityReservationProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CapacityReservationProfile_Status instances for property testing - lazily instantiated by
// CapacityReservationProfileStatusGenerator()
var capacityReservationProfileStatusGenerator gopter.Gen

// CapacityReservationProfileStatusGenerator returns a generator of CapacityReservationProfile_Status instances for property testing.
func CapacityReservationProfileStatusGenerator() gopter.Gen {
	if capacityReservationProfileStatusGenerator != nil {
		return capacityReservationProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCapacityReservationProfileStatus(generators)
	capacityReservationProfileStatusGenerator = gen.Struct(reflect.TypeOf(CapacityReservationProfile_Status{}), generators)

	return capacityReservationProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForCapacityReservationProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCapacityReservationProfileStatus(gens map[string]gopter.Gen) {
	gens["CapacityReservationGroup"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_DiagnosticsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile, DiagnosticsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile runs a test to see if a specific instance of DiagnosticsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile(subject DiagnosticsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile instances for property testing - lazily instantiated by DiagnosticsProfileGenerator()
var diagnosticsProfileGenerator gopter.Gen

// DiagnosticsProfileGenerator returns a generator of DiagnosticsProfile instances for property testing.
func DiagnosticsProfileGenerator() gopter.Gen {
	if diagnosticsProfileGenerator != nil {
		return diagnosticsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile(generators)
	diagnosticsProfileGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile{}), generators)

	return diagnosticsProfileGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsGenerator())
}

func Test_DiagnosticsProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileStatus, DiagnosticsProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileStatus runs a test to see if a specific instance of DiagnosticsProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileStatus(subject DiagnosticsProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_Status instances for property testing - lazily instantiated by
// DiagnosticsProfileStatusGenerator()
var diagnosticsProfileStatusGenerator gopter.Gen

// DiagnosticsProfileStatusGenerator returns a generator of DiagnosticsProfile_Status instances for property testing.
func DiagnosticsProfileStatusGenerator() gopter.Gen {
	if diagnosticsProfileStatusGenerator != nil {
		return diagnosticsProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus(generators)
	diagnosticsProfileStatusGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_Status{}), generators)

	return diagnosticsProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileStatus(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsStatusGenerator())
}

func Test_HardwareProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile, HardwareProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile runs a test to see if a specific instance of HardwareProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile(subject HardwareProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile instances for property testing - lazily instantiated by HardwareProfileGenerator()
var hardwareProfileGenerator gopter.Gen

// HardwareProfileGenerator returns a generator of HardwareProfile instances for property testing.
// We first initialize hardwareProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HardwareProfileGenerator() gopter.Gen {
	if hardwareProfileGenerator != nil {
		return hardwareProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile(generators)
	hardwareProfileGenerator = gen.Struct(reflect.TypeOf(HardwareProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile(generators)
	AddRelatedPropertyGeneratorsForHardwareProfile(generators)
	hardwareProfileGenerator = gen.Struct(reflect.TypeOf(HardwareProfile{}), generators)

	return hardwareProfileGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHardwareProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHardwareProfile(gens map[string]gopter.Gen) {
	gens["VmSizeProperties"] = gen.PtrOf(VMSizePropertiesGenerator())
}

func Test_HardwareProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileStatus, HardwareProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileStatus runs a test to see if a specific instance of HardwareProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileStatus(subject HardwareProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_Status instances for property testing - lazily instantiated by
// HardwareProfileStatusGenerator()
var hardwareProfileStatusGenerator gopter.Gen

// HardwareProfileStatusGenerator returns a generator of HardwareProfile_Status instances for property testing.
// We first initialize hardwareProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HardwareProfileStatusGenerator() gopter.Gen {
	if hardwareProfileStatusGenerator != nil {
		return hardwareProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileStatus(generators)
	hardwareProfileStatusGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileStatus(generators)
	AddRelatedPropertyGeneratorsForHardwareProfileStatus(generators)
	hardwareProfileStatusGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_Status{}), generators)

	return hardwareProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileStatus(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHardwareProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHardwareProfileStatus(gens map[string]gopter.Gen) {
	gens["VmSizeProperties"] = gen.PtrOf(VMSizePropertiesStatusGenerator())
}

func Test_NetworkProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileStatus, NetworkProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileStatus runs a test to see if a specific instance of NetworkProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileStatus(subject NetworkProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_Status instances for property testing - lazily instantiated by
// NetworkProfileStatusGenerator()
var networkProfileStatusGenerator gopter.Gen

// NetworkProfileStatusGenerator returns a generator of NetworkProfile_Status instances for property testing.
// We first initialize networkProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkProfileStatusGenerator() gopter.Gen {
	if networkProfileStatusGenerator != nil {
		return networkProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfileStatus(generators)
	networkProfileStatusGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfileStatus(generators)
	AddRelatedPropertyGeneratorsForNetworkProfileStatus(generators)
	networkProfileStatusGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_Status{}), generators)

	return networkProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfileStatus(gens map[string]gopter.Gen) {
	gens["NetworkApiVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileStatus(gens map[string]gopter.Gen) {
	gens["NetworkInterfaceConfigurations"] = gen.SliceOf(VirtualMachineNetworkInterfaceConfigurationStatusGenerator())
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceStatusGenerator())
}

func Test_OSProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileStatus, OSProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileStatus runs a test to see if a specific instance of OSProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileStatus(subject OSProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_Status instances for property testing - lazily instantiated by OSProfileStatusGenerator()
var osProfileStatusGenerator gopter.Gen

// OSProfileStatusGenerator returns a generator of OSProfile_Status instances for property testing.
// We first initialize osProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileStatusGenerator() gopter.Gen {
	if osProfileStatusGenerator != nil {
		return osProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileStatus(generators)
	osProfileStatusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileStatus(generators)
	AddRelatedPropertyGeneratorsForOSProfileStatus(generators)
	osProfileStatusGenerator = gen.Struct(reflect.TypeOf(OSProfile_Status{}), generators)

	return osProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileStatus(gens map[string]gopter.Gen) {
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileStatus(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationStatusGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupStatusGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationStatusGenerator())
}

func Test_Plan_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan, PlanGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan runs a test to see if a specific instance of Plan round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan(subject Plan) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan instances for property testing - lazily instantiated by PlanGenerator()
var planGenerator gopter.Gen

// PlanGenerator returns a generator of Plan instances for property testing.
func PlanGenerator() gopter.Gen {
	if planGenerator != nil {
		return planGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan(generators)
	planGenerator = gen.Struct(reflect.TypeOf(Plan{}), generators)

	return planGenerator
}

// AddIndependentPropertyGeneratorsForPlan is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_Plan_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlanStatus, PlanStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlanStatus runs a test to see if a specific instance of Plan_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPlanStatus(subject Plan_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_Status instances for property testing - lazily instantiated by PlanStatusGenerator()
var planStatusGenerator gopter.Gen

// PlanStatusGenerator returns a generator of Plan_Status instances for property testing.
func PlanStatusGenerator() gopter.Gen {
	if planStatusGenerator != nil {
		return planStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlanStatus(generators)
	planStatusGenerator = gen.Struct(reflect.TypeOf(Plan_Status{}), generators)

	return planStatusGenerator
}

// AddIndependentPropertyGeneratorsForPlanStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlanStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScheduledEventsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsProfile, ScheduledEventsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsProfile runs a test to see if a specific instance of ScheduledEventsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsProfile(subject ScheduledEventsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsProfile instances for property testing - lazily instantiated by
// ScheduledEventsProfileGenerator()
var scheduledEventsProfileGenerator gopter.Gen

// ScheduledEventsProfileGenerator returns a generator of ScheduledEventsProfile instances for property testing.
func ScheduledEventsProfileGenerator() gopter.Gen {
	if scheduledEventsProfileGenerator != nil {
		return scheduledEventsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsProfile(generators)
	scheduledEventsProfileGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsProfile{}), generators)

	return scheduledEventsProfileGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsProfile(gens map[string]gopter.Gen) {
	gens["TerminateNotificationProfile"] = gen.PtrOf(TerminateNotificationProfileGenerator())
}

func Test_ScheduledEventsProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsProfileStatus, ScheduledEventsProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsProfileStatus runs a test to see if a specific instance of ScheduledEventsProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsProfileStatus(subject ScheduledEventsProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsProfile_Status instances for property testing - lazily instantiated by
// ScheduledEventsProfileStatusGenerator()
var scheduledEventsProfileStatusGenerator gopter.Gen

// ScheduledEventsProfileStatusGenerator returns a generator of ScheduledEventsProfile_Status instances for property testing.
func ScheduledEventsProfileStatusGenerator() gopter.Gen {
	if scheduledEventsProfileStatusGenerator != nil {
		return scheduledEventsProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsProfileStatus(generators)
	scheduledEventsProfileStatusGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsProfile_Status{}), generators)

	return scheduledEventsProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsProfileStatus(gens map[string]gopter.Gen) {
	gens["TerminateNotificationProfile"] = gen.PtrOf(TerminateNotificationProfileStatusGenerator())
}

func Test_SecurityProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile, SecurityProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile runs a test to see if a specific instance of SecurityProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile(subject SecurityProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile instances for property testing - lazily instantiated by SecurityProfileGenerator()
var securityProfileGenerator gopter.Gen

// SecurityProfileGenerator returns a generator of SecurityProfile instances for property testing.
// We first initialize securityProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileGenerator() gopter.Gen {
	if securityProfileGenerator != nil {
		return securityProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile(generators)
	securityProfileGenerator = gen.Struct(reflect.TypeOf(SecurityProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile(generators)
	securityProfileGenerator = gen.Struct(reflect.TypeOf(SecurityProfile{}), generators)

	return securityProfileGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecurityProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsGenerator())
}

func Test_SecurityProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileStatus, SecurityProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileStatus runs a test to see if a specific instance of SecurityProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileStatus(subject SecurityProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_Status instances for property testing - lazily instantiated by
// SecurityProfileStatusGenerator()
var securityProfileStatusGenerator gopter.Gen

// SecurityProfileStatusGenerator returns a generator of SecurityProfile_Status instances for property testing.
// We first initialize securityProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileStatusGenerator() gopter.Gen {
	if securityProfileStatusGenerator != nil {
		return securityProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileStatus(generators)
	securityProfileStatusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileStatus(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileStatus(generators)
	securityProfileStatusGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_Status{}), generators)

	return securityProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileStatus(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecurityProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileStatus(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsStatusGenerator())
}

func Test_StorageProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile, StorageProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile runs a test to see if a specific instance of StorageProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile(subject StorageProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile instances for property testing - lazily instantiated by StorageProfileGenerator()
var storageProfileGenerator gopter.Gen

// StorageProfileGenerator returns a generator of StorageProfile instances for property testing.
func StorageProfileGenerator() gopter.Gen {
	if storageProfileGenerator != nil {
		return storageProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile(generators)
	storageProfileGenerator = gen.Struct(reflect.TypeOf(StorageProfile{}), generators)

	return storageProfileGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskGenerator())
}

func Test_StorageProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileStatus, StorageProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileStatus runs a test to see if a specific instance of StorageProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileStatus(subject StorageProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_Status instances for property testing - lazily instantiated by
// StorageProfileStatusGenerator()
var storageProfileStatusGenerator gopter.Gen

// StorageProfileStatusGenerator returns a generator of StorageProfile_Status instances for property testing.
func StorageProfileStatusGenerator() gopter.Gen {
	if storageProfileStatusGenerator != nil {
		return storageProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileStatus(generators)
	storageProfileStatusGenerator = gen.Struct(reflect.TypeOf(StorageProfile_Status{}), generators)

	return storageProfileStatusGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileStatus(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskStatusGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceStatusGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskStatusGenerator())
}

func Test_VirtualMachineExtension_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtension_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionStatus, VirtualMachineExtensionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionStatus runs a test to see if a specific instance of VirtualMachineExtension_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionStatus(subject VirtualMachineExtension_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtension_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtension_Status instances for property testing - lazily instantiated by
// VirtualMachineExtensionStatusGenerator()
var virtualMachineExtensionStatusGenerator gopter.Gen

// VirtualMachineExtensionStatusGenerator returns a generator of VirtualMachineExtension_Status instances for property testing.
// We first initialize virtualMachineExtensionStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionStatusGenerator() gopter.Gen {
	if virtualMachineExtensionStatusGenerator != nil {
		return virtualMachineExtensionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	virtualMachineExtensionStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus(generators)
	virtualMachineExtensionStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_Status{}), generators)

	return virtualMachineExtensionStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionStatus(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["ForceUpdateTag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["SuppressFailures"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionStatus(gens map[string]gopter.Gen) {
	gens["InstanceView"] = gen.PtrOf(VirtualMachineExtensionInstanceViewStatusGenerator())
}

func Test_VirtualMachineIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity, VirtualMachineIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity runs a test to see if a specific instance of VirtualMachineIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity(subject VirtualMachineIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity instances for property testing - lazily instantiated by
// VirtualMachineIdentityGenerator()
var virtualMachineIdentityGenerator gopter.Gen

// VirtualMachineIdentityGenerator returns a generator of VirtualMachineIdentity instances for property testing.
func VirtualMachineIdentityGenerator() gopter.Gen {
	if virtualMachineIdentityGenerator != nil {
		return virtualMachineIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity(generators)
	virtualMachineIdentityGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity{}), generators)

	return virtualMachineIdentityGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityStatus, VirtualMachineIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityStatus runs a test to see if a specific instance of VirtualMachineIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityStatus(subject VirtualMachineIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_Status instances for property testing - lazily instantiated by
// VirtualMachineIdentityStatusGenerator()
var virtualMachineIdentityStatusGenerator gopter.Gen

// VirtualMachineIdentityStatusGenerator returns a generator of VirtualMachineIdentity_Status instances for property testing.
func VirtualMachineIdentityStatusGenerator() gopter.Gen {
	if virtualMachineIdentityStatusGenerator != nil {
		return virtualMachineIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus(generators)
	virtualMachineIdentityStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_Status{}), generators)

	return virtualMachineIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceViewStatus, VirtualMachineInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceViewStatus runs a test to see if a specific instance of VirtualMachineInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceViewStatus(subject VirtualMachineInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceView_Status instances for property testing - lazily instantiated by
// VirtualMachineInstanceViewStatusGenerator()
var virtualMachineInstanceViewStatusGenerator gopter.Gen

// VirtualMachineInstanceViewStatusGenerator returns a generator of VirtualMachineInstanceView_Status instances for property testing.
// We first initialize virtualMachineInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineInstanceViewStatusGenerator != nil {
		return virtualMachineInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	virtualMachineInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus(generators)
	virtualMachineInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_Status{}), generators)

	return virtualMachineInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.AlphaString())
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceViewStatusGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceViewStatusGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceViewStatusGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatusStatusGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatusStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceViewStatusGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatusStatusGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfile, VirtualMachinesSpecPropertiesNetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfile runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfile(subject VirtualMachines_Spec_Properties_NetworkProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfile instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesNetworkProfileGenerator()
var virtualMachinesSpecPropertiesNetworkProfileGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfile(generators)
	virtualMachinesSpecPropertiesNetworkProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfile(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfile(generators)
	virtualMachinesSpecPropertiesNetworkProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfile(gens map[string]gopter.Gen) {
	gens["NetworkApiVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfile(gens map[string]gopter.Gen) {
	gens["NetworkInterfaceConfigurations"] = gen.SliceOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator())
	gens["NetworkInterfaces"] = gen.SliceOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator())
}

func Test_VirtualMachines_Spec_Properties_OsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_OsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfile, VirtualMachinesSpecPropertiesOsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfile runs a test to see if a specific instance of VirtualMachines_Spec_Properties_OsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfile(subject VirtualMachines_Spec_Properties_OsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_OsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_OsProfile instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesOsProfileGenerator()
var virtualMachinesSpecPropertiesOsProfileGenerator gopter.Gen

// VirtualMachinesSpecPropertiesOsProfileGenerator returns a generator of VirtualMachines_Spec_Properties_OsProfile instances for property testing.
// We first initialize virtualMachinesSpecPropertiesOsProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesOsProfileGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesOsProfileGenerator != nil {
		return virtualMachinesSpecPropertiesOsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfile(generators)
	virtualMachinesSpecPropertiesOsProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_OsProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfile(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfile(generators)
	virtualMachinesSpecPropertiesOsProfileGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_OsProfile{}), generators)

	return virtualMachinesSpecPropertiesOsProfileGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfile(gens map[string]gopter.Gen) {
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfile(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationGenerator())
}

func Test_BootDiagnostics_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics, BootDiagnosticsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics runs a test to see if a specific instance of BootDiagnostics round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics(subject BootDiagnostics) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics instances for property testing - lazily instantiated by BootDiagnosticsGenerator()
var bootDiagnosticsGenerator gopter.Gen

// BootDiagnosticsGenerator returns a generator of BootDiagnostics instances for property testing.
func BootDiagnosticsGenerator() gopter.Gen {
	if bootDiagnosticsGenerator != nil {
		return bootDiagnosticsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics(generators)
	bootDiagnosticsGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics{}), generators)

	return bootDiagnosticsGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_BootDiagnosticsInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus, BootDiagnosticsInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus runs a test to see if a specific instance of BootDiagnosticsInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceViewStatus(subject BootDiagnosticsInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceView_Status instances for property testing - lazily instantiated by
// BootDiagnosticsInstanceViewStatusGenerator()
var bootDiagnosticsInstanceViewStatusGenerator gopter.Gen

// BootDiagnosticsInstanceViewStatusGenerator returns a generator of BootDiagnosticsInstanceView_Status instances for property testing.
// We first initialize bootDiagnosticsInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceViewStatusGenerator() gopter.Gen {
	if bootDiagnosticsInstanceViewStatusGenerator != nil {
		return bootDiagnosticsInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	bootDiagnosticsInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(generators)
	bootDiagnosticsInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_Status{}), generators)

	return bootDiagnosticsInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_BootDiagnostics_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsStatus, BootDiagnosticsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsStatus runs a test to see if a specific instance of BootDiagnostics_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsStatus(subject BootDiagnostics_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_Status instances for property testing - lazily instantiated by
// BootDiagnosticsStatusGenerator()
var bootDiagnosticsStatusGenerator gopter.Gen

// BootDiagnosticsStatusGenerator returns a generator of BootDiagnostics_Status instances for property testing.
func BootDiagnosticsStatusGenerator() gopter.Gen {
	if bootDiagnosticsStatusGenerator != nil {
		return bootDiagnosticsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsStatus(generators)
	bootDiagnosticsStatusGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_Status{}), generators)

	return bootDiagnosticsStatusGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk, DataDiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk runs a test to see if a specific instance of DataDisk round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk(subject DataDisk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk instances for property testing - lazily instantiated by DataDiskGenerator()
var dataDiskGenerator gopter.Gen

// DataDiskGenerator returns a generator of DataDisk instances for property testing.
// We first initialize dataDiskGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskGenerator() gopter.Gen {
	if dataDiskGenerator != nil {
		return dataDiskGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk(generators)
	dataDiskGenerator = gen.Struct(reflect.TypeOf(DataDisk{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk(generators)
	AddRelatedPropertyGeneratorsForDataDisk(generators)
	dataDiskGenerator = gen.Struct(reflect.TypeOf(DataDisk{}), generators)

	return dataDiskGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["DetachOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskGenerator())
}

func Test_DataDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskStatus, DataDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskStatus runs a test to see if a specific instance of DataDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskStatus(subject DataDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_Status instances for property testing - lazily instantiated by DataDiskStatusGenerator()
var dataDiskStatusGenerator gopter.Gen

// DataDiskStatusGenerator returns a generator of DataDisk_Status instances for property testing.
// We first initialize dataDiskStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskStatusGenerator() gopter.Gen {
	if dataDiskStatusGenerator != nil {
		return dataDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskStatus(generators)
	dataDiskStatusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskStatus(generators)
	AddRelatedPropertyGeneratorsForDataDiskStatus(generators)
	dataDiskStatusGenerator = gen.Struct(reflect.TypeOf(DataDisk_Status{}), generators)

	return dataDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskStatus(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["DetachOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskStatus(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersStatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
}

func Test_DiskInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceViewStatus, DiskInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceViewStatus runs a test to see if a specific instance of DiskInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceViewStatus(subject DiskInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceView_Status instances for property testing - lazily instantiated by
// DiskInstanceViewStatusGenerator()
var diskInstanceViewStatusGenerator gopter.Gen

// DiskInstanceViewStatusGenerator returns a generator of DiskInstanceView_Status instances for property testing.
// We first initialize diskInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceViewStatusGenerator() gopter.Gen {
	if diskInstanceViewStatusGenerator != nil {
		return diskInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(generators)
	diskInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceViewStatus(generators)
	diskInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_Status{}), generators)

	return diskInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettingsStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_ImageReference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference, ImageReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference runs a test to see if a specific instance of ImageReference round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference(subject ImageReference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference instances for property testing - lazily instantiated by ImageReferenceGenerator()
var imageReferenceGenerator gopter.Gen

// ImageReferenceGenerator returns a generator of ImageReference instances for property testing.
func ImageReferenceGenerator() gopter.Gen {
	if imageReferenceGenerator != nil {
		return imageReferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference(generators)
	imageReferenceGenerator = gen.Struct(reflect.TypeOf(ImageReference{}), generators)

	return imageReferenceGenerator
}

// AddIndependentPropertyGeneratorsForImageReference is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference(gens map[string]gopter.Gen) {
	gens["CommunityGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["SharedGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ImageReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceStatus, ImageReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceStatus runs a test to see if a specific instance of ImageReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceStatus(subject ImageReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_Status instances for property testing - lazily instantiated by
// ImageReferenceStatusGenerator()
var imageReferenceStatusGenerator gopter.Gen

// ImageReferenceStatusGenerator returns a generator of ImageReference_Status instances for property testing.
func ImageReferenceStatusGenerator() gopter.Gen {
	if imageReferenceStatusGenerator != nil {
		return imageReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceStatus(generators)
	imageReferenceStatusGenerator = gen.Struct(reflect.TypeOf(ImageReference_Status{}), generators)

	return imageReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceStatus(gens map[string]gopter.Gen) {
	gens["CommunityGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["SharedGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatusStatus, InstanceViewStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatusStatus runs a test to see if a specific instance of InstanceViewStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatusStatus(subject InstanceViewStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_Status instances for property testing - lazily instantiated by
// InstanceViewStatusStatusGenerator()
var instanceViewStatusStatusGenerator gopter.Gen

// InstanceViewStatusStatusGenerator returns a generator of InstanceViewStatus_Status instances for property testing.
func InstanceViewStatusStatusGenerator() gopter.Gen {
	if instanceViewStatusStatusGenerator != nil {
		return instanceViewStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatusStatus(generators)
	instanceViewStatusStatusGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_Status{}), generators)

	return instanceViewStatusStatusGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatusStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatusStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration, LinuxConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration runs a test to see if a specific instance of LinuxConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration(subject LinuxConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration instances for property testing - lazily instantiated by LinuxConfigurationGenerator()
var linuxConfigurationGenerator gopter.Gen

// LinuxConfigurationGenerator returns a generator of LinuxConfiguration instances for property testing.
// We first initialize linuxConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationGenerator() gopter.Gen {
	if linuxConfigurationGenerator != nil {
		return linuxConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration(generators)
	linuxConfigurationGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration(generators)
	linuxConfigurationGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration{}), generators)

	return linuxConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationGenerator())
}

func Test_LinuxConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationStatus, LinuxConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationStatus runs a test to see if a specific instance of LinuxConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationStatus(subject LinuxConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_Status instances for property testing - lazily instantiated by
// LinuxConfigurationStatusGenerator()
var linuxConfigurationStatusGenerator gopter.Gen

// LinuxConfigurationStatusGenerator returns a generator of LinuxConfiguration_Status instances for property testing.
// We first initialize linuxConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationStatusGenerator() gopter.Gen {
	if linuxConfigurationStatusGenerator != nil {
		return linuxConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(generators)
	linuxConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationStatus(generators)
	linuxConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_Status{}), generators)

	return linuxConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationStatus(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsStatusGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationStatusGenerator())
}

func Test_MaintenanceRedeployStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatusStatus, MaintenanceRedeployStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatusStatus runs a test to see if a specific instance of MaintenanceRedeployStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatusStatus(subject MaintenanceRedeployStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatus_Status instances for property testing - lazily instantiated by
// MaintenanceRedeployStatusStatusGenerator()
var maintenanceRedeployStatusStatusGenerator gopter.Gen

// MaintenanceRedeployStatusStatusGenerator returns a generator of MaintenanceRedeployStatus_Status instances for property testing.
func MaintenanceRedeployStatusStatusGenerator() gopter.Gen {
	if maintenanceRedeployStatusStatusGenerator != nil {
		return maintenanceRedeployStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus(generators)
	maintenanceRedeployStatusStatusGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatus_Status{}), generators)

	return maintenanceRedeployStatusStatusGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusStatus(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceStatus, NetworkInterfaceReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceStatus runs a test to see if a specific instance of NetworkInterfaceReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceStatus(subject NetworkInterfaceReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_Status instances for property testing - lazily instantiated by
// NetworkInterfaceReferenceStatusGenerator()
var networkInterfaceReferenceStatusGenerator gopter.Gen

// NetworkInterfaceReferenceStatusGenerator returns a generator of NetworkInterfaceReference_Status instances for property testing.
func NetworkInterfaceReferenceStatusGenerator() gopter.Gen {
	if networkInterfaceReferenceStatusGenerator != nil {
		return networkInterfaceReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus(generators)
	networkInterfaceReferenceStatusGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_Status{}), generators)

	return networkInterfaceReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceStatus(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_OSDisk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk, OSDiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk runs a test to see if a specific instance of OSDisk round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk(subject OSDisk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk instances for property testing - lazily instantiated by OSDiskGenerator()
var osDiskGenerator gopter.Gen

// OSDiskGenerator returns a generator of OSDisk instances for property testing.
// We first initialize osDiskGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskGenerator() gopter.Gen {
	if osDiskGenerator != nil {
		return osDiskGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk(generators)
	osDiskGenerator = gen.Struct(reflect.TypeOf(OSDisk{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk(generators)
	AddRelatedPropertyGeneratorsForOSDisk(generators)
	osDiskGenerator = gen.Struct(reflect.TypeOf(OSDisk{}), generators)

	return osDiskGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskGenerator())
}

func Test_OSDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskStatus, OSDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskStatus runs a test to see if a specific instance of OSDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskStatus(subject OSDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_Status instances for property testing - lazily instantiated by OSDiskStatusGenerator()
var osDiskStatusGenerator gopter.Gen

// OSDiskStatusGenerator returns a generator of OSDisk_Status instances for property testing.
// We first initialize osDiskStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskStatusGenerator() gopter.Gen {
	if osDiskStatusGenerator != nil {
		return osDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskStatus(generators)
	osDiskStatusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskStatus(generators)
	AddRelatedPropertyGeneratorsForOSDiskStatus(generators)
	osDiskStatusGenerator = gen.Struct(reflect.TypeOf(OSDisk_Status{}), generators)

	return osDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskStatus(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.AlphaString())
	gens["CreateOption"] = gen.PtrOf(gen.AlphaString())
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskStatus(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsStatusGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsStatusGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersStatusGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskStatusGenerator())
}

func Test_TerminateNotificationProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TerminateNotificationProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTerminateNotificationProfile, TerminateNotificationProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTerminateNotificationProfile runs a test to see if a specific instance of TerminateNotificationProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForTerminateNotificationProfile(subject TerminateNotificationProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TerminateNotificationProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TerminateNotificationProfile instances for property testing - lazily instantiated by
// TerminateNotificationProfileGenerator()
var terminateNotificationProfileGenerator gopter.Gen

// TerminateNotificationProfileGenerator returns a generator of TerminateNotificationProfile instances for property testing.
func TerminateNotificationProfileGenerator() gopter.Gen {
	if terminateNotificationProfileGenerator != nil {
		return terminateNotificationProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTerminateNotificationProfile(generators)
	terminateNotificationProfileGenerator = gen.Struct(reflect.TypeOf(TerminateNotificationProfile{}), generators)

	return terminateNotificationProfileGenerator
}

// AddIndependentPropertyGeneratorsForTerminateNotificationProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTerminateNotificationProfile(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
	gens["NotBeforeTimeout"] = gen.PtrOf(gen.AlphaString())
}

func Test_TerminateNotificationProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TerminateNotificationProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTerminateNotificationProfileStatus, TerminateNotificationProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTerminateNotificationProfileStatus runs a test to see if a specific instance of TerminateNotificationProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForTerminateNotificationProfileStatus(subject TerminateNotificationProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TerminateNotificationProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TerminateNotificationProfile_Status instances for property testing - lazily instantiated by
// TerminateNotificationProfileStatusGenerator()
var terminateNotificationProfileStatusGenerator gopter.Gen

// TerminateNotificationProfileStatusGenerator returns a generator of TerminateNotificationProfile_Status instances for property testing.
func TerminateNotificationProfileStatusGenerator() gopter.Gen {
	if terminateNotificationProfileStatusGenerator != nil {
		return terminateNotificationProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTerminateNotificationProfileStatus(generators)
	terminateNotificationProfileStatusGenerator = gen.Struct(reflect.TypeOf(TerminateNotificationProfile_Status{}), generators)

	return terminateNotificationProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForTerminateNotificationProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTerminateNotificationProfileStatus(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
	gens["NotBeforeTimeout"] = gen.PtrOf(gen.AlphaString())
}

func Test_UefiSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings, UefiSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings runs a test to see if a specific instance of UefiSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings(subject UefiSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings instances for property testing - lazily instantiated by UefiSettingsGenerator()
var uefiSettingsGenerator gopter.Gen

// UefiSettingsGenerator returns a generator of UefiSettings instances for property testing.
func UefiSettingsGenerator() gopter.Gen {
	if uefiSettingsGenerator != nil {
		return uefiSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings(generators)
	uefiSettingsGenerator = gen.Struct(reflect.TypeOf(UefiSettings{}), generators)

	return uefiSettingsGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_UefiSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsStatus, UefiSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsStatus runs a test to see if a specific instance of UefiSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsStatus(subject UefiSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_Status instances for property testing - lazily instantiated by UefiSettingsStatusGenerator()
var uefiSettingsStatusGenerator gopter.Gen

// UefiSettingsStatusGenerator returns a generator of UefiSettings_Status instances for property testing.
func UefiSettingsStatusGenerator() gopter.Gen {
	if uefiSettingsStatusGenerator != nil {
		return uefiSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsStatus(generators)
	uefiSettingsStatusGenerator = gen.Struct(reflect.TypeOf(UefiSettings_Status{}), generators)

	return uefiSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsStatus(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VMGalleryApplication_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMGalleryApplication via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMGalleryApplication, VMGalleryApplicationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMGalleryApplication runs a test to see if a specific instance of VMGalleryApplication round trips to JSON and back losslessly
func RunJSONSerializationTestForVMGalleryApplication(subject VMGalleryApplication) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMGalleryApplication
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMGalleryApplication instances for property testing - lazily instantiated by
// VMGalleryApplicationGenerator()
var vmGalleryApplicationGenerator gopter.Gen

// VMGalleryApplicationGenerator returns a generator of VMGalleryApplication instances for property testing.
func VMGalleryApplicationGenerator() gopter.Gen {
	if vmGalleryApplicationGenerator != nil {
		return vmGalleryApplicationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMGalleryApplication(generators)
	vmGalleryApplicationGenerator = gen.Struct(reflect.TypeOf(VMGalleryApplication{}), generators)

	return vmGalleryApplicationGenerator
}

// AddIndependentPropertyGeneratorsForVMGalleryApplication is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMGalleryApplication(gens map[string]gopter.Gen) {
	gens["ConfigurationReference"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["Order"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.PtrOf(gen.AlphaString())
	gens["TreatFailureAsDeploymentFailure"] = gen.PtrOf(gen.Bool())
}

func Test_VMGalleryApplication_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMGalleryApplication_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMGalleryApplicationStatus, VMGalleryApplicationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMGalleryApplicationStatus runs a test to see if a specific instance of VMGalleryApplication_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVMGalleryApplicationStatus(subject VMGalleryApplication_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMGalleryApplication_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMGalleryApplication_Status instances for property testing - lazily instantiated by
// VMGalleryApplicationStatusGenerator()
var vmGalleryApplicationStatusGenerator gopter.Gen

// VMGalleryApplicationStatusGenerator returns a generator of VMGalleryApplication_Status instances for property testing.
func VMGalleryApplicationStatusGenerator() gopter.Gen {
	if vmGalleryApplicationStatusGenerator != nil {
		return vmGalleryApplicationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMGalleryApplicationStatus(generators)
	vmGalleryApplicationStatusGenerator = gen.Struct(reflect.TypeOf(VMGalleryApplication_Status{}), generators)

	return vmGalleryApplicationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVMGalleryApplicationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMGalleryApplicationStatus(gens map[string]gopter.Gen) {
	gens["ConfigurationReference"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["Order"] = gen.PtrOf(gen.Int())
	gens["PackageReferenceId"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.PtrOf(gen.AlphaString())
	gens["TreatFailureAsDeploymentFailure"] = gen.PtrOf(gen.Bool())
}

func Test_VMSizeProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMSizeProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMSizeProperties, VMSizePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMSizeProperties runs a test to see if a specific instance of VMSizeProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForVMSizeProperties(subject VMSizeProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMSizeProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMSizeProperties instances for property testing - lazily instantiated by VMSizePropertiesGenerator()
var vmSizePropertiesGenerator gopter.Gen

// VMSizePropertiesGenerator returns a generator of VMSizeProperties instances for property testing.
func VMSizePropertiesGenerator() gopter.Gen {
	if vmSizePropertiesGenerator != nil {
		return vmSizePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMSizeProperties(generators)
	vmSizePropertiesGenerator = gen.Struct(reflect.TypeOf(VMSizeProperties{}), generators)

	return vmSizePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForVMSizeProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMSizeProperties(gens map[string]gopter.Gen) {
	gens["VCPUsAvailable"] = gen.PtrOf(gen.Int())
	gens["VCPUsPerCore"] = gen.PtrOf(gen.Int())
}

func Test_VMSizeProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMSizeProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMSizePropertiesStatus, VMSizePropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMSizePropertiesStatus runs a test to see if a specific instance of VMSizeProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVMSizePropertiesStatus(subject VMSizeProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMSizeProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMSizeProperties_Status instances for property testing - lazily instantiated by
// VMSizePropertiesStatusGenerator()
var vmSizePropertiesStatusGenerator gopter.Gen

// VMSizePropertiesStatusGenerator returns a generator of VMSizeProperties_Status instances for property testing.
func VMSizePropertiesStatusGenerator() gopter.Gen {
	if vmSizePropertiesStatusGenerator != nil {
		return vmSizePropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMSizePropertiesStatus(generators)
	vmSizePropertiesStatusGenerator = gen.Struct(reflect.TypeOf(VMSizeProperties_Status{}), generators)

	return vmSizePropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForVMSizePropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMSizePropertiesStatus(gens map[string]gopter.Gen) {
	gens["VCPUsAvailable"] = gen.PtrOf(gen.Int())
	gens["VCPUsPerCore"] = gen.PtrOf(gen.Int())
}

func Test_VaultSecretGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup, VaultSecretGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup runs a test to see if a specific instance of VaultSecretGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup(subject VaultSecretGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup instances for property testing - lazily instantiated by VaultSecretGroupGenerator()
var vaultSecretGroupGenerator gopter.Gen

// VaultSecretGroupGenerator returns a generator of VaultSecretGroup instances for property testing.
func VaultSecretGroupGenerator() gopter.Gen {
	if vaultSecretGroupGenerator != nil {
		return vaultSecretGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup(generators)
	vaultSecretGroupGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup{}), generators)

	return vaultSecretGroupGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateGenerator())
}

func Test_VaultSecretGroup_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupStatus, VaultSecretGroupStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupStatus runs a test to see if a specific instance of VaultSecretGroup_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupStatus(subject VaultSecretGroup_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_Status instances for property testing - lazily instantiated by
// VaultSecretGroupStatusGenerator()
var vaultSecretGroupStatusGenerator gopter.Gen

// VaultSecretGroupStatusGenerator returns a generator of VaultSecretGroup_Status instances for property testing.
func VaultSecretGroupStatusGenerator() gopter.Gen {
	if vaultSecretGroupStatusGenerator != nil {
		return vaultSecretGroupStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupStatus(generators)
	vaultSecretGroupStatusGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_Status{}), generators)

	return vaultSecretGroupStatusGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateStatusGenerator())
}

func Test_VirtualMachineAgentInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus, VirtualMachineAgentInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus runs a test to see if a specific instance of VirtualMachineAgentInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceViewStatus(subject VirtualMachineAgentInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceView_Status instances for property testing - lazily instantiated by
// VirtualMachineAgentInstanceViewStatusGenerator()
var virtualMachineAgentInstanceViewStatusGenerator gopter.Gen

// VirtualMachineAgentInstanceViewStatusGenerator returns a generator of VirtualMachineAgentInstanceView_Status instances for property testing.
// We first initialize virtualMachineAgentInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineAgentInstanceViewStatusGenerator != nil {
		return virtualMachineAgentInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	virtualMachineAgentInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(generators)
	virtualMachineAgentInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_Status{}), generators)

	return virtualMachineAgentInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceViewStatusGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineExtensionInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus, VirtualMachineExtensionInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus runs a test to see if a specific instance of VirtualMachineExtensionInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceViewStatus(subject VirtualMachineExtensionInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceView_Status instances for property testing - lazily instantiated by
// VirtualMachineExtensionInstanceViewStatusGenerator()
var virtualMachineExtensionInstanceViewStatusGenerator gopter.Gen

// VirtualMachineExtensionInstanceViewStatusGenerator returns a generator of VirtualMachineExtensionInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceViewStatusGenerator != nil {
		return virtualMachineExtensionInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	virtualMachineExtensionInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(generators)
	virtualMachineExtensionInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_Status{}), generators)

	return virtualMachineExtensionInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineHealthStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatusStatus, VirtualMachineHealthStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatusStatus runs a test to see if a specific instance of VirtualMachineHealthStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatusStatus(subject VirtualMachineHealthStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatus_Status instances for property testing - lazily instantiated by
// VirtualMachineHealthStatusStatusGenerator()
var virtualMachineHealthStatusStatusGenerator gopter.Gen

// VirtualMachineHealthStatusStatusGenerator returns a generator of VirtualMachineHealthStatus_Status instances for property testing.
func VirtualMachineHealthStatusStatusGenerator() gopter.Gen {
	if virtualMachineHealthStatusStatusGenerator != nil {
		return virtualMachineHealthStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus(generators)
	virtualMachineHealthStatusStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatus_Status{}), generators)

	return virtualMachineHealthStatusStatusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineNetworkInterfaceConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationStatus, VirtualMachineNetworkInterfaceConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationStatus runs a test to see if a specific instance of VirtualMachineNetworkInterfaceConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationStatus(subject VirtualMachineNetworkInterfaceConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceConfiguration_Status instances for property testing - lazily instantiated
// by VirtualMachineNetworkInterfaceConfigurationStatusGenerator()
var virtualMachineNetworkInterfaceConfigurationStatusGenerator gopter.Gen

// VirtualMachineNetworkInterfaceConfigurationStatusGenerator returns a generator of VirtualMachineNetworkInterfaceConfiguration_Status instances for property testing.
// We first initialize virtualMachineNetworkInterfaceConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineNetworkInterfaceConfigurationStatusGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceConfigurationStatusGenerator != nil {
		return virtualMachineNetworkInterfaceConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationStatus(generators)
	virtualMachineNetworkInterfaceConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationStatus(generators)
	virtualMachineNetworkInterfaceConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceConfiguration_Status{}), generators)

	return virtualMachineNetworkInterfaceConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableFpga"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator())
	gens["DscpConfiguration"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualMachineNetworkInterfaceIPConfigurationStatusGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_VirtualMachinePatchStatus_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatus_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatusStatus, VirtualMachinePatchStatusStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatusStatus runs a test to see if a specific instance of VirtualMachinePatchStatus_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatusStatus(subject VirtualMachinePatchStatus_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatus_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatus_Status instances for property testing - lazily instantiated by
// VirtualMachinePatchStatusStatusGenerator()
var virtualMachinePatchStatusStatusGenerator gopter.Gen

// VirtualMachinePatchStatusStatusGenerator returns a generator of VirtualMachinePatchStatus_Status instances for property testing.
func VirtualMachinePatchStatusStatusGenerator() gopter.Gen {
	if virtualMachinePatchStatusStatusGenerator != nil {
		return virtualMachinePatchStatusStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus(generators)
	virtualMachinePatchStatusStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatus_Status{}), generators)

	return virtualMachinePatchStatusStatusGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusStatus(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummaryStatusGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatusStatusGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummaryStatusGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations instances for property
// testing - lazily instantiated by VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableFpga"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurations(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator())
	gens["DscpConfiguration"] = gen.PtrOf(SubResourceGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(SubResourceGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces instances for property testing - lazily
// instantiated by VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces instances for property testing.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaces{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaces(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_WindowsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration, WindowsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration runs a test to see if a specific instance of WindowsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration(subject WindowsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration instances for property testing - lazily instantiated by
// WindowsConfigurationGenerator()
var windowsConfigurationGenerator gopter.Gen

// WindowsConfigurationGenerator returns a generator of WindowsConfiguration instances for property testing.
// We first initialize windowsConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationGenerator() gopter.Gen {
	if windowsConfigurationGenerator != nil {
		return windowsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration(generators)
	windowsConfigurationGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration(generators)
	windowsConfigurationGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration{}), generators)

	return windowsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationGenerator())
}

func Test_WindowsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationStatus, WindowsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationStatus runs a test to see if a specific instance of WindowsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationStatus(subject WindowsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_Status instances for property testing - lazily instantiated by
// WindowsConfigurationStatusGenerator()
var windowsConfigurationStatusGenerator gopter.Gen

// WindowsConfigurationStatusGenerator returns a generator of WindowsConfiguration_Status instances for property testing.
// We first initialize windowsConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationStatusGenerator() gopter.Gen {
	if windowsConfigurationStatusGenerator != nil {
		return windowsConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(generators)
	windowsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationStatus(generators)
	windowsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_Status{}), generators)

	return windowsConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentStatusGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsStatusGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationStatusGenerator())
}

func Test_AdditionalUnattendContent_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent, AdditionalUnattendContentGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent runs a test to see if a specific instance of AdditionalUnattendContent round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent(subject AdditionalUnattendContent) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent instances for property testing - lazily instantiated by
// AdditionalUnattendContentGenerator()
var additionalUnattendContentGenerator gopter.Gen

// AdditionalUnattendContentGenerator returns a generator of AdditionalUnattendContent instances for property testing.
func AdditionalUnattendContentGenerator() gopter.Gen {
	if additionalUnattendContentGenerator != nil {
		return additionalUnattendContentGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent(generators)
	additionalUnattendContentGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent{}), generators)

	return additionalUnattendContentGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.AlphaString())
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.AlphaString())
	gens["SettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AdditionalUnattendContent_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentStatus, AdditionalUnattendContentStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentStatus runs a test to see if a specific instance of AdditionalUnattendContent_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentStatus(subject AdditionalUnattendContent_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_Status instances for property testing - lazily instantiated by
// AdditionalUnattendContentStatusGenerator()
var additionalUnattendContentStatusGenerator gopter.Gen

// AdditionalUnattendContentStatusGenerator returns a generator of AdditionalUnattendContent_Status instances for property testing.
func AdditionalUnattendContentStatusGenerator() gopter.Gen {
	if additionalUnattendContentStatusGenerator != nil {
		return additionalUnattendContentStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus(generators)
	additionalUnattendContentStatusGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_Status{}), generators)

	return additionalUnattendContentStatusGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentStatus(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.AlphaString())
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.AlphaString())
	gens["SettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AvailablePatchSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummaryStatus, AvailablePatchSummaryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummaryStatus runs a test to see if a specific instance of AvailablePatchSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummaryStatus(subject AvailablePatchSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummary_Status instances for property testing - lazily instantiated by
// AvailablePatchSummaryStatusGenerator()
var availablePatchSummaryStatusGenerator gopter.Gen

// AvailablePatchSummaryStatusGenerator returns a generator of AvailablePatchSummary_Status instances for property testing.
// We first initialize availablePatchSummaryStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummaryStatusGenerator() gopter.Gen {
	if availablePatchSummaryStatusGenerator != nil {
		return availablePatchSummaryStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	availablePatchSummaryStatusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus(generators)
	availablePatchSummaryStatusGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_Status{}), generators)

	return availablePatchSummaryStatusGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummaryStatus(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummaryStatus(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorStatusGenerator())
}

func Test_DiffDiskSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings, DiffDiskSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings runs a test to see if a specific instance of DiffDiskSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings(subject DiffDiskSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings instances for property testing - lazily instantiated by DiffDiskSettingsGenerator()
var diffDiskSettingsGenerator gopter.Gen

// DiffDiskSettingsGenerator returns a generator of DiffDiskSettings instances for property testing.
func DiffDiskSettingsGenerator() gopter.Gen {
	if diffDiskSettingsGenerator != nil {
		return diffDiskSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings(generators)
	diffDiskSettingsGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings{}), generators)

	return diffDiskSettingsGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.AlphaString())
	gens["Placement"] = gen.PtrOf(gen.AlphaString())
}

func Test_DiffDiskSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsStatus, DiffDiskSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsStatus runs a test to see if a specific instance of DiffDiskSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsStatus(subject DiffDiskSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_Status instances for property testing - lazily instantiated by
// DiffDiskSettingsStatusGenerator()
var diffDiskSettingsStatusGenerator gopter.Gen

// DiffDiskSettingsStatusGenerator returns a generator of DiffDiskSettings_Status instances for property testing.
func DiffDiskSettingsStatusGenerator() gopter.Gen {
	if diffDiskSettingsStatusGenerator != nil {
		return diffDiskSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus(generators)
	diffDiskSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_Status{}), generators)

	return diffDiskSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsStatus(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.AlphaString())
	gens["Placement"] = gen.PtrOf(gen.AlphaString())
}

func Test_DiskEncryptionSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings, DiskEncryptionSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings runs a test to see if a specific instance of DiskEncryptionSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings(subject DiskEncryptionSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings instances for property testing - lazily instantiated by
// DiskEncryptionSettingsGenerator()
var diskEncryptionSettingsGenerator gopter.Gen

// DiskEncryptionSettingsGenerator returns a generator of DiskEncryptionSettings instances for property testing.
// We first initialize diskEncryptionSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsGenerator() gopter.Gen {
	if diskEncryptionSettingsGenerator != nil {
		return diskEncryptionSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings(generators)
	diskEncryptionSettingsGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings(generators)
	diskEncryptionSettingsGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings{}), generators)

	return diskEncryptionSettingsGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceGenerator())
}

func Test_DiskEncryptionSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsStatus, DiskEncryptionSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsStatus runs a test to see if a specific instance of DiskEncryptionSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsStatus(subject DiskEncryptionSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_Status instances for property testing - lazily instantiated by
// DiskEncryptionSettingsStatusGenerator()
var diskEncryptionSettingsStatusGenerator gopter.Gen

// DiskEncryptionSettingsStatusGenerator returns a generator of DiskEncryptionSettings_Status instances for property testing.
// We first initialize diskEncryptionSettingsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsStatusGenerator() gopter.Gen {
	if diskEncryptionSettingsStatusGenerator != nil {
		return diskEncryptionSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	diskEncryptionSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus(generators)
	diskEncryptionSettingsStatusGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_Status{}), generators)

	return diskEncryptionSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsStatus(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceStatusGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceStatusGenerator())
}

func Test_LastPatchInstallationSummary_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummary_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummaryStatus, LastPatchInstallationSummaryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummaryStatus runs a test to see if a specific instance of LastPatchInstallationSummary_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummaryStatus(subject LastPatchInstallationSummary_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummary_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummary_Status instances for property testing - lazily instantiated by
// LastPatchInstallationSummaryStatusGenerator()
var lastPatchInstallationSummaryStatusGenerator gopter.Gen

// LastPatchInstallationSummaryStatusGenerator returns a generator of LastPatchInstallationSummary_Status instances for property testing.
// We first initialize lastPatchInstallationSummaryStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummaryStatusGenerator() gopter.Gen {
	if lastPatchInstallationSummaryStatusGenerator != nil {
		return lastPatchInstallationSummaryStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	lastPatchInstallationSummaryStatusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus(generators)
	lastPatchInstallationSummaryStatusGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_Status{}), generators)

	return lastPatchInstallationSummaryStatusGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryStatus(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryStatus(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorStatusGenerator())
}

func Test_LinuxPatchSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings, LinuxPatchSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings runs a test to see if a specific instance of LinuxPatchSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings(subject LinuxPatchSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings instances for property testing - lazily instantiated by LinuxPatchSettingsGenerator()
var linuxPatchSettingsGenerator gopter.Gen

// LinuxPatchSettingsGenerator returns a generator of LinuxPatchSettings instances for property testing.
// We first initialize linuxPatchSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxPatchSettingsGenerator() gopter.Gen {
	if linuxPatchSettingsGenerator != nil {
		return linuxPatchSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings(generators)
	linuxPatchSettingsGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings(generators)
	AddRelatedPropertyGeneratorsForLinuxPatchSettings(generators)
	linuxPatchSettingsGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings{}), generators)

	return linuxPatchSettingsGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings(gens map[string]gopter.Gen) {
	gens["AssessmentMode"] = gen.PtrOf(gen.AlphaString())
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLinuxPatchSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxPatchSettings(gens map[string]gopter.Gen) {
	gens["AutomaticByPlatformSettings"] = gen.PtrOf(LinuxVMGuestPatchAutomaticByPlatformSettingsGenerator())
}

func Test_LinuxPatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsStatus, LinuxPatchSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsStatus runs a test to see if a specific instance of LinuxPatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsStatus(subject LinuxPatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_Status instances for property testing - lazily instantiated by
// LinuxPatchSettingsStatusGenerator()
var linuxPatchSettingsStatusGenerator gopter.Gen

// LinuxPatchSettingsStatusGenerator returns a generator of LinuxPatchSettings_Status instances for property testing.
// We first initialize linuxPatchSettingsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxPatchSettingsStatusGenerator() gopter.Gen {
	if linuxPatchSettingsStatusGenerator != nil {
		return linuxPatchSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus(generators)
	linuxPatchSettingsStatusGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus(generators)
	AddRelatedPropertyGeneratorsForLinuxPatchSettingsStatus(generators)
	linuxPatchSettingsStatusGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_Status{}), generators)

	return linuxPatchSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsStatus(gens map[string]gopter.Gen) {
	gens["AssessmentMode"] = gen.PtrOf(gen.AlphaString())
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLinuxPatchSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxPatchSettingsStatus(gens map[string]gopter.Gen) {
	gens["AutomaticByPlatformSettings"] = gen.PtrOf(LinuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator())
}

func Test_ManagedDiskParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters, ManagedDiskParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters runs a test to see if a specific instance of ManagedDiskParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters(subject ManagedDiskParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters instances for property testing - lazily instantiated by
// ManagedDiskParametersGenerator()
var managedDiskParametersGenerator gopter.Gen

// ManagedDiskParametersGenerator returns a generator of ManagedDiskParameters instances for property testing.
// We first initialize managedDiskParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersGenerator() gopter.Gen {
	if managedDiskParametersGenerator != nil {
		return managedDiskParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters(generators)
	managedDiskParametersGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters(generators)
	managedDiskParametersGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters{}), generators)

	return managedDiskParametersGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters(gens map[string]gopter.Gen) {
	gens["StorageAccountType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(DiskEncryptionSetParametersGenerator())
	gens["SecurityProfile"] = gen.PtrOf(VMDiskSecurityProfileGenerator())
}

func Test_ManagedDiskParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersStatus, ManagedDiskParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersStatus runs a test to see if a specific instance of ManagedDiskParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersStatus(subject ManagedDiskParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_Status instances for property testing - lazily instantiated by
// ManagedDiskParametersStatusGenerator()
var managedDiskParametersStatusGenerator gopter.Gen

// ManagedDiskParametersStatusGenerator returns a generator of ManagedDiskParameters_Status instances for property testing.
// We first initialize managedDiskParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersStatusGenerator() gopter.Gen {
	if managedDiskParametersStatusGenerator != nil {
		return managedDiskParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(generators)
	managedDiskParametersStatusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersStatus(generators)
	managedDiskParametersStatusGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_Status{}), generators)

	return managedDiskParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersStatus(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["SecurityProfile"] = gen.PtrOf(VMDiskSecurityProfileStatusGenerator())
}

func Test_PatchSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings, PatchSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings runs a test to see if a specific instance of PatchSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings(subject PatchSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings instances for property testing - lazily instantiated by PatchSettingsGenerator()
var patchSettingsGenerator gopter.Gen

// PatchSettingsGenerator returns a generator of PatchSettings instances for property testing.
// We first initialize patchSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PatchSettingsGenerator() gopter.Gen {
	if patchSettingsGenerator != nil {
		return patchSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings(generators)
	patchSettingsGenerator = gen.Struct(reflect.TypeOf(PatchSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings(generators)
	AddRelatedPropertyGeneratorsForPatchSettings(generators)
	patchSettingsGenerator = gen.Struct(reflect.TypeOf(PatchSettings{}), generators)

	return patchSettingsGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings(gens map[string]gopter.Gen) {
	gens["AssessmentMode"] = gen.PtrOf(gen.AlphaString())
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPatchSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPatchSettings(gens map[string]gopter.Gen) {
	gens["AutomaticByPlatformSettings"] = gen.PtrOf(WindowsVMGuestPatchAutomaticByPlatformSettingsGenerator())
}

func Test_PatchSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsStatus, PatchSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsStatus runs a test to see if a specific instance of PatchSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsStatus(subject PatchSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_Status instances for property testing - lazily instantiated by
// PatchSettingsStatusGenerator()
var patchSettingsStatusGenerator gopter.Gen

// PatchSettingsStatusGenerator returns a generator of PatchSettings_Status instances for property testing.
// We first initialize patchSettingsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PatchSettingsStatusGenerator() gopter.Gen {
	if patchSettingsStatusGenerator != nil {
		return patchSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsStatus(generators)
	patchSettingsStatusGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsStatus(generators)
	AddRelatedPropertyGeneratorsForPatchSettingsStatus(generators)
	patchSettingsStatusGenerator = gen.Struct(reflect.TypeOf(PatchSettings_Status{}), generators)

	return patchSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsStatus(gens map[string]gopter.Gen) {
	gens["AssessmentMode"] = gen.PtrOf(gen.AlphaString())
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPatchSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPatchSettingsStatus(gens map[string]gopter.Gen) {
	gens["AutomaticByPlatformSettings"] = gen.PtrOf(WindowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator())
}

func Test_SshConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration, SshConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration runs a test to see if a specific instance of SshConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration(subject SshConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration instances for property testing - lazily instantiated by SshConfigurationGenerator()
var sshConfigurationGenerator gopter.Gen

// SshConfigurationGenerator returns a generator of SshConfiguration instances for property testing.
func SshConfigurationGenerator() gopter.Gen {
	if sshConfigurationGenerator != nil {
		return sshConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration(generators)
	sshConfigurationGenerator = gen.Struct(reflect.TypeOf(SshConfiguration{}), generators)

	return sshConfigurationGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeyGenerator())
}

func Test_SshConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationStatus, SshConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationStatus runs a test to see if a specific instance of SshConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationStatus(subject SshConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_Status instances for property testing - lazily instantiated by
// SshConfigurationStatusGenerator()
var sshConfigurationStatusGenerator gopter.Gen

// SshConfigurationStatusGenerator returns a generator of SshConfiguration_Status instances for property testing.
func SshConfigurationStatusGenerator() gopter.Gen {
	if sshConfigurationStatusGenerator != nil {
		return sshConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationStatus(generators)
	sshConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_Status{}), generators)

	return sshConfigurationStatusGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationStatus(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeyStatusGenerator())
}

func Test_VaultCertificate_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate, VaultCertificateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate runs a test to see if a specific instance of VaultCertificate round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate(subject VaultCertificate) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate instances for property testing - lazily instantiated by VaultCertificateGenerator()
var vaultCertificateGenerator gopter.Gen

// VaultCertificateGenerator returns a generator of VaultCertificate instances for property testing.
func VaultCertificateGenerator() gopter.Gen {
	if vaultCertificateGenerator != nil {
		return vaultCertificateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate(generators)
	vaultCertificateGenerator = gen.Struct(reflect.TypeOf(VaultCertificate{}), generators)

	return vaultCertificateGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VaultCertificate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateStatus, VaultCertificateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateStatus runs a test to see if a specific instance of VaultCertificate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateStatus(subject VaultCertificate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_Status instances for property testing - lazily instantiated by
// VaultCertificateStatusGenerator()
var vaultCertificateStatusGenerator gopter.Gen

// VaultCertificateStatusGenerator returns a generator of VaultCertificate_Status instances for property testing.
func VaultCertificateStatusGenerator() gopter.Gen {
	if vaultCertificateStatusGenerator != nil {
		return vaultCertificateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateStatus(generators)
	vaultCertificateStatusGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_Status{}), generators)

	return vaultCertificateStatusGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateStatus(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk, VirtualHardDiskGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk runs a test to see if a specific instance of VirtualHardDisk round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk(subject VirtualHardDisk) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk instances for property testing - lazily instantiated by VirtualHardDiskGenerator()
var virtualHardDiskGenerator gopter.Gen

// VirtualHardDiskGenerator returns a generator of VirtualHardDisk instances for property testing.
func VirtualHardDiskGenerator() gopter.Gen {
	if virtualHardDiskGenerator != nil {
		return virtualHardDiskGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk(generators)
	virtualHardDiskGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk{}), generators)

	return virtualHardDiskGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskStatus, VirtualHardDiskStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskStatus runs a test to see if a specific instance of VirtualHardDisk_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskStatus(subject VirtualHardDisk_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_Status instances for property testing - lazily instantiated by
// VirtualHardDiskStatusGenerator()
var virtualHardDiskStatusGenerator gopter.Gen

// VirtualHardDiskStatusGenerator returns a generator of VirtualHardDisk_Status instances for property testing.
func VirtualHardDiskStatusGenerator() gopter.Gen {
	if virtualHardDiskStatusGenerator != nil {
		return virtualHardDiskStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskStatus(generators)
	virtualHardDiskStatusGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_Status{}), generators)

	return virtualHardDiskStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskStatus(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceView_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceView_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus, VirtualMachineExtensionHandlerInstanceViewStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceView_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewStatus(subject VirtualMachineExtensionHandlerInstanceView_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceView_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing - lazily instantiated
// by VirtualMachineExtensionHandlerInstanceViewStatusGenerator()
var virtualMachineExtensionHandlerInstanceViewStatusGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceViewStatusGenerator returns a generator of VirtualMachineExtensionHandlerInstanceView_Status instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceViewStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceViewStatusGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceViewStatusGenerator != nil {
		return virtualMachineExtensionHandlerInstanceViewStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	virtualMachineExtensionHandlerInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(generators)
	virtualMachineExtensionHandlerInstanceViewStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_Status{}), generators)

	return virtualMachineExtensionHandlerInstanceViewStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewStatus(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusStatusGenerator())
}

func Test_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceDnsSettingsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfiguration, VirtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfiguration runs a test to see if a specific instance of VirtualMachineNetworkInterfaceDnsSettingsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfiguration(subject VirtualMachineNetworkInterfaceDnsSettingsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceDnsSettingsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceDnsSettingsConfiguration instances for property testing - lazily
// instantiated by VirtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator()
var virtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator gopter.Gen

// VirtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator returns a generator of VirtualMachineNetworkInterfaceDnsSettingsConfiguration instances for property testing.
func VirtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator != nil {
		return virtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfiguration(generators)
	virtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceDnsSettingsConfiguration{}), generators)

	return virtualMachineNetworkInterfaceDnsSettingsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfiguration(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
}

func Test_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceDnsSettingsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationStatus, VirtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationStatus runs a test to see if a specific instance of VirtualMachineNetworkInterfaceDnsSettingsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationStatus(subject VirtualMachineNetworkInterfaceDnsSettingsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceDnsSettingsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceDnsSettingsConfiguration_Status instances for property testing - lazily
// instantiated by VirtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator()
var virtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator gopter.Gen

// VirtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator returns a generator of VirtualMachineNetworkInterfaceDnsSettingsConfiguration_Status instances for property testing.
func VirtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator != nil {
		return virtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationStatus(generators)
	virtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceDnsSettingsConfiguration_Status{}), generators)

	return virtualMachineNetworkInterfaceDnsSettingsConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
}

func Test_VirtualMachineNetworkInterfaceIPConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceIPConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationStatus, VirtualMachineNetworkInterfaceIPConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationStatus runs a test to see if a specific instance of VirtualMachineNetworkInterfaceIPConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationStatus(subject VirtualMachineNetworkInterfaceIPConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceIPConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceIPConfiguration_Status instances for property testing - lazily
// instantiated by VirtualMachineNetworkInterfaceIPConfigurationStatusGenerator()
var virtualMachineNetworkInterfaceIPConfigurationStatusGenerator gopter.Gen

// VirtualMachineNetworkInterfaceIPConfigurationStatusGenerator returns a generator of VirtualMachineNetworkInterfaceIPConfiguration_Status instances for property testing.
// We first initialize virtualMachineNetworkInterfaceIPConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineNetworkInterfaceIPConfigurationStatusGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceIPConfigurationStatusGenerator != nil {
		return virtualMachineNetworkInterfaceIPConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationStatus(generators)
	virtualMachineNetworkInterfaceIPConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceIPConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationStatus(generators)
	virtualMachineNetworkInterfaceIPConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceIPConfiguration_Status{}), generators)

	return virtualMachineNetworkInterfaceIPConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationStatus(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(SubResourceStatusGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(SubResourceStatusGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(SubResourceStatusGenerator())
	gens["PublicIPAddressConfiguration"] = gen.PtrOf(VirtualMachinePublicIPAddressConfigurationStatusGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of
// VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations instances for
// property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(SubResourceGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(SubResourceGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(SubResourceGenerator())
	gens["PublicIPAddressConfiguration"] = gen.PtrOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceGenerator())
}

func Test_WinRMConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration, WinRMConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration runs a test to see if a specific instance of WinRMConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration(subject WinRMConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration instances for property testing - lazily instantiated by WinRMConfigurationGenerator()
var winRMConfigurationGenerator gopter.Gen

// WinRMConfigurationGenerator returns a generator of WinRMConfiguration instances for property testing.
func WinRMConfigurationGenerator() gopter.Gen {
	if winRMConfigurationGenerator != nil {
		return winRMConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration(generators)
	winRMConfigurationGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration{}), generators)

	return winRMConfigurationGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerGenerator())
}

func Test_WinRMConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationStatus, WinRMConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationStatus runs a test to see if a specific instance of WinRMConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationStatus(subject WinRMConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_Status instances for property testing - lazily instantiated by
// WinRMConfigurationStatusGenerator()
var winRMConfigurationStatusGenerator gopter.Gen

// WinRMConfigurationStatusGenerator returns a generator of WinRMConfiguration_Status instances for property testing.
func WinRMConfigurationStatusGenerator() gopter.Gen {
	if winRMConfigurationStatusGenerator != nil {
		return winRMConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationStatus(generators)
	winRMConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_Status{}), generators)

	return winRMConfigurationStatusGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationStatus(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerStatusGenerator())
}

func Test_ApiError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorStatus, ApiErrorStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorStatus runs a test to see if a specific instance of ApiError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorStatus(subject ApiError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiError_Status instances for property testing - lazily instantiated by ApiErrorStatusGenerator()
var apiErrorStatusGenerator gopter.Gen

// ApiErrorStatusGenerator returns a generator of ApiError_Status instances for property testing.
// We first initialize apiErrorStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiErrorStatusGenerator() gopter.Gen {
	if apiErrorStatusGenerator != nil {
		return apiErrorStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorStatus(generators)
	apiErrorStatusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorStatus(generators)
	AddRelatedPropertyGeneratorsForApiErrorStatus(generators)
	apiErrorStatusGenerator = gen.Struct(reflect.TypeOf(ApiError_Status{}), generators)

	return apiErrorStatusGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiErrorStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiErrorStatus(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBaseStatusGenerator())
	gens["Innererror"] = gen.PtrOf(InnerErrorStatusGenerator())
}

func Test_KeyVaultKeyReference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference, KeyVaultKeyReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference runs a test to see if a specific instance of KeyVaultKeyReference round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference(subject KeyVaultKeyReference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference instances for property testing - lazily instantiated by
// KeyVaultKeyReferenceGenerator()
var keyVaultKeyReferenceGenerator gopter.Gen

// KeyVaultKeyReferenceGenerator returns a generator of KeyVaultKeyReference instances for property testing.
// We first initialize keyVaultKeyReferenceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceGenerator() gopter.Gen {
	if keyVaultKeyReferenceGenerator != nil {
		return keyVaultKeyReferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference(generators)
	keyVaultKeyReferenceGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference(generators)
	keyVaultKeyReferenceGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference{}), generators)

	return keyVaultKeyReferenceGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceGenerator())
}

func Test_KeyVaultKeyReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceStatus, KeyVaultKeyReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceStatus runs a test to see if a specific instance of KeyVaultKeyReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceStatus(subject KeyVaultKeyReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_Status instances for property testing - lazily instantiated by
// KeyVaultKeyReferenceStatusGenerator()
var keyVaultKeyReferenceStatusGenerator gopter.Gen

// KeyVaultKeyReferenceStatusGenerator returns a generator of KeyVaultKeyReference_Status instances for property testing.
// We first initialize keyVaultKeyReferenceStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceStatusGenerator() gopter.Gen {
	if keyVaultKeyReferenceStatusGenerator != nil {
		return keyVaultKeyReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	keyVaultKeyReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus(generators)
	keyVaultKeyReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_Status{}), generators)

	return keyVaultKeyReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceStatus(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_KeyVaultSecretReference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference, KeyVaultSecretReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference runs a test to see if a specific instance of KeyVaultSecretReference round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference(subject KeyVaultSecretReference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference instances for property testing - lazily instantiated by
// KeyVaultSecretReferenceGenerator()
var keyVaultSecretReferenceGenerator gopter.Gen

// KeyVaultSecretReferenceGenerator returns a generator of KeyVaultSecretReference instances for property testing.
// We first initialize keyVaultSecretReferenceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceGenerator() gopter.Gen {
	if keyVaultSecretReferenceGenerator != nil {
		return keyVaultSecretReferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference(generators)
	keyVaultSecretReferenceGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference(generators)
	keyVaultSecretReferenceGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference{}), generators)

	return keyVaultSecretReferenceGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceGenerator())
}

func Test_KeyVaultSecretReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceStatus, KeyVaultSecretReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceStatus runs a test to see if a specific instance of KeyVaultSecretReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceStatus(subject KeyVaultSecretReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_Status instances for property testing - lazily instantiated by
// KeyVaultSecretReferenceStatusGenerator()
var keyVaultSecretReferenceStatusGenerator gopter.Gen

// KeyVaultSecretReferenceStatusGenerator returns a generator of KeyVaultSecretReference_Status instances for property testing.
// We first initialize keyVaultSecretReferenceStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceStatusGenerator() gopter.Gen {
	if keyVaultSecretReferenceStatusGenerator != nil {
		return keyVaultSecretReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	keyVaultSecretReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus(generators)
	keyVaultSecretReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_Status{}), generators)

	return keyVaultSecretReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceStatus(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceStatus(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_LinuxVMGuestPatchAutomaticByPlatformSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxVMGuestPatchAutomaticByPlatformSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettings, LinuxVMGuestPatchAutomaticByPlatformSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettings runs a test to see if a specific instance of LinuxVMGuestPatchAutomaticByPlatformSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettings(subject LinuxVMGuestPatchAutomaticByPlatformSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxVMGuestPatchAutomaticByPlatformSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxVMGuestPatchAutomaticByPlatformSettings instances for property testing - lazily instantiated by
// LinuxVMGuestPatchAutomaticByPlatformSettingsGenerator()
var linuxVMGuestPatchAutomaticByPlatformSettingsGenerator gopter.Gen

// LinuxVMGuestPatchAutomaticByPlatformSettingsGenerator returns a generator of LinuxVMGuestPatchAutomaticByPlatformSettings instances for property testing.
func LinuxVMGuestPatchAutomaticByPlatformSettingsGenerator() gopter.Gen {
	if linuxVMGuestPatchAutomaticByPlatformSettingsGenerator != nil {
		return linuxVMGuestPatchAutomaticByPlatformSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettings(generators)
	linuxVMGuestPatchAutomaticByPlatformSettingsGenerator = gen.Struct(reflect.TypeOf(LinuxVMGuestPatchAutomaticByPlatformSettings{}), generators)

	return linuxVMGuestPatchAutomaticByPlatformSettingsGenerator
}

// AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettings(gens map[string]gopter.Gen) {
	gens["RebootSetting"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxVMGuestPatchAutomaticByPlatformSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxVMGuestPatchAutomaticByPlatformSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsStatus, LinuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsStatus runs a test to see if a specific instance of LinuxVMGuestPatchAutomaticByPlatformSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsStatus(subject LinuxVMGuestPatchAutomaticByPlatformSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxVMGuestPatchAutomaticByPlatformSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxVMGuestPatchAutomaticByPlatformSettings_Status instances for property testing - lazily instantiated
// by LinuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator()
var linuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator gopter.Gen

// LinuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator returns a generator of LinuxVMGuestPatchAutomaticByPlatformSettings_Status instances for property testing.
func LinuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator() gopter.Gen {
	if linuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator != nil {
		return linuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsStatus(generators)
	linuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator = gen.Struct(reflect.TypeOf(LinuxVMGuestPatchAutomaticByPlatformSettings_Status{}), generators)

	return linuxVMGuestPatchAutomaticByPlatformSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsStatus(gens map[string]gopter.Gen) {
	gens["RebootSetting"] = gen.PtrOf(gen.AlphaString())
}

func Test_SshPublicKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKey, SshPublicKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKey runs a test to see if a specific instance of SshPublicKey round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKey(subject SshPublicKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey instances for property testing - lazily instantiated by SshPublicKeyGenerator()
var sshPublicKeyGenerator gopter.Gen

// SshPublicKeyGenerator returns a generator of SshPublicKey instances for property testing.
func SshPublicKeyGenerator() gopter.Gen {
	if sshPublicKeyGenerator != nil {
		return sshPublicKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKey(generators)
	sshPublicKeyGenerator = gen.Struct(reflect.TypeOf(SshPublicKey{}), generators)

	return sshPublicKeyGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKey is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKey(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_SshPublicKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeyStatus, SshPublicKeyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeyStatus runs a test to see if a specific instance of SshPublicKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeyStatus(subject SshPublicKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_Status instances for property testing - lazily instantiated by SshPublicKeyStatusGenerator()
var sshPublicKeyStatusGenerator gopter.Gen

// SshPublicKeyStatusGenerator returns a generator of SshPublicKey_Status instances for property testing.
func SshPublicKeyStatusGenerator() gopter.Gen {
	if sshPublicKeyStatusGenerator != nil {
		return sshPublicKeyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeyStatus(generators)
	sshPublicKeyStatusGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_Status{}), generators)

	return sshPublicKeyStatusGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeyStatus(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_VMDiskSecurityProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMDiskSecurityProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMDiskSecurityProfile, VMDiskSecurityProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMDiskSecurityProfile runs a test to see if a specific instance of VMDiskSecurityProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVMDiskSecurityProfile(subject VMDiskSecurityProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMDiskSecurityProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMDiskSecurityProfile instances for property testing - lazily instantiated by
// VMDiskSecurityProfileGenerator()
var vmDiskSecurityProfileGenerator gopter.Gen

// VMDiskSecurityProfileGenerator returns a generator of VMDiskSecurityProfile instances for property testing.
// We first initialize vmDiskSecurityProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VMDiskSecurityProfileGenerator() gopter.Gen {
	if vmDiskSecurityProfileGenerator != nil {
		return vmDiskSecurityProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMDiskSecurityProfile(generators)
	vmDiskSecurityProfileGenerator = gen.Struct(reflect.TypeOf(VMDiskSecurityProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMDiskSecurityProfile(generators)
	AddRelatedPropertyGeneratorsForVMDiskSecurityProfile(generators)
	vmDiskSecurityProfileGenerator = gen.Struct(reflect.TypeOf(VMDiskSecurityProfile{}), generators)

	return vmDiskSecurityProfileGenerator
}

// AddIndependentPropertyGeneratorsForVMDiskSecurityProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMDiskSecurityProfile(gens map[string]gopter.Gen) {
	gens["SecurityEncryptionType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVMDiskSecurityProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVMDiskSecurityProfile(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(DiskEncryptionSetParametersGenerator())
}

func Test_VMDiskSecurityProfile_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMDiskSecurityProfile_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMDiskSecurityProfileStatus, VMDiskSecurityProfileStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMDiskSecurityProfileStatus runs a test to see if a specific instance of VMDiskSecurityProfile_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVMDiskSecurityProfileStatus(subject VMDiskSecurityProfile_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMDiskSecurityProfile_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMDiskSecurityProfile_Status instances for property testing - lazily instantiated by
// VMDiskSecurityProfileStatusGenerator()
var vmDiskSecurityProfileStatusGenerator gopter.Gen

// VMDiskSecurityProfileStatusGenerator returns a generator of VMDiskSecurityProfile_Status instances for property testing.
// We first initialize vmDiskSecurityProfileStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VMDiskSecurityProfileStatusGenerator() gopter.Gen {
	if vmDiskSecurityProfileStatusGenerator != nil {
		return vmDiskSecurityProfileStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMDiskSecurityProfileStatus(generators)
	vmDiskSecurityProfileStatusGenerator = gen.Struct(reflect.TypeOf(VMDiskSecurityProfile_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMDiskSecurityProfileStatus(generators)
	AddRelatedPropertyGeneratorsForVMDiskSecurityProfileStatus(generators)
	vmDiskSecurityProfileStatusGenerator = gen.Struct(reflect.TypeOf(VMDiskSecurityProfile_Status{}), generators)

	return vmDiskSecurityProfileStatusGenerator
}

// AddIndependentPropertyGeneratorsForVMDiskSecurityProfileStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMDiskSecurityProfileStatus(gens map[string]gopter.Gen) {
	gens["SecurityEncryptionType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVMDiskSecurityProfileStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVMDiskSecurityProfileStatus(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceStatusGenerator())
}

func Test_VirtualMachinePublicIPAddressConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePublicIPAddressConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationStatus, VirtualMachinePublicIPAddressConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationStatus runs a test to see if a specific instance of VirtualMachinePublicIPAddressConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationStatus(subject VirtualMachinePublicIPAddressConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePublicIPAddressConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePublicIPAddressConfiguration_Status instances for property testing - lazily instantiated
// by VirtualMachinePublicIPAddressConfigurationStatusGenerator()
var virtualMachinePublicIPAddressConfigurationStatusGenerator gopter.Gen

// VirtualMachinePublicIPAddressConfigurationStatusGenerator returns a generator of VirtualMachinePublicIPAddressConfiguration_Status instances for property testing.
// We first initialize virtualMachinePublicIPAddressConfigurationStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePublicIPAddressConfigurationStatusGenerator() gopter.Gen {
	if virtualMachinePublicIPAddressConfigurationStatusGenerator != nil {
		return virtualMachinePublicIPAddressConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationStatus(generators)
	virtualMachinePublicIPAddressConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressConfiguration_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationStatus(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationStatus(generators)
	virtualMachinePublicIPAddressConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressConfiguration_Status{}), generators)

	return virtualMachinePublicIPAddressConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator())
	gens["IpTags"] = gen.SliceOf(VirtualMachineIpTagStatusGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceStatusGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuStatusGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of
// VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
// instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.AlphaString())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachinePublicIPAddressDnsSettingsConfigurationGenerator())
	gens["IpTags"] = gen.SliceOf(VirtualMachineIpTagGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuGenerator())
}

func Test_WinRMListener_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener, WinRMListenerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener runs a test to see if a specific instance of WinRMListener round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener(subject WinRMListener) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener instances for property testing - lazily instantiated by WinRMListenerGenerator()
var winRMListenerGenerator gopter.Gen

// WinRMListenerGenerator returns a generator of WinRMListener instances for property testing.
func WinRMListenerGenerator() gopter.Gen {
	if winRMListenerGenerator != nil {
		return winRMListenerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener(generators)
	winRMListenerGenerator = gen.Struct(reflect.TypeOf(WinRMListener{}), generators)

	return winRMListenerGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerStatus, WinRMListenerStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerStatus runs a test to see if a specific instance of WinRMListener_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerStatus(subject WinRMListener_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_Status instances for property testing - lazily instantiated by
// WinRMListenerStatusGenerator()
var winRMListenerStatusGenerator gopter.Gen

// WinRMListenerStatusGenerator returns a generator of WinRMListener_Status instances for property testing.
func WinRMListenerStatusGenerator() gopter.Gen {
	if winRMListenerStatusGenerator != nil {
		return winRMListenerStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerStatus(generators)
	winRMListenerStatusGenerator = gen.Struct(reflect.TypeOf(WinRMListener_Status{}), generators)

	return winRMListenerStatusGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerStatus(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
}

func Test_WindowsVMGuestPatchAutomaticByPlatformSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsVMGuestPatchAutomaticByPlatformSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettings, WindowsVMGuestPatchAutomaticByPlatformSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettings runs a test to see if a specific instance of WindowsVMGuestPatchAutomaticByPlatformSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettings(subject WindowsVMGuestPatchAutomaticByPlatformSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsVMGuestPatchAutomaticByPlatformSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsVMGuestPatchAutomaticByPlatformSettings instances for property testing - lazily instantiated by
// WindowsVMGuestPatchAutomaticByPlatformSettingsGenerator()
var windowsVMGuestPatchAutomaticByPlatformSettingsGenerator gopter.Gen

// WindowsVMGuestPatchAutomaticByPlatformSettingsGenerator returns a generator of WindowsVMGuestPatchAutomaticByPlatformSettings instances for property testing.
func WindowsVMGuestPatchAutomaticByPlatformSettingsGenerator() gopter.Gen {
	if windowsVMGuestPatchAutomaticByPlatformSettingsGenerator != nil {
		return windowsVMGuestPatchAutomaticByPlatformSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettings(generators)
	windowsVMGuestPatchAutomaticByPlatformSettingsGenerator = gen.Struct(reflect.TypeOf(WindowsVMGuestPatchAutomaticByPlatformSettings{}), generators)

	return windowsVMGuestPatchAutomaticByPlatformSettingsGenerator
}

// AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettings(gens map[string]gopter.Gen) {
	gens["RebootSetting"] = gen.PtrOf(gen.AlphaString())
}

func Test_WindowsVMGuestPatchAutomaticByPlatformSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsVMGuestPatchAutomaticByPlatformSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsStatus, WindowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsStatus runs a test to see if a specific instance of WindowsVMGuestPatchAutomaticByPlatformSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsStatus(subject WindowsVMGuestPatchAutomaticByPlatformSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsVMGuestPatchAutomaticByPlatformSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsVMGuestPatchAutomaticByPlatformSettings_Status instances for property testing - lazily
// instantiated by WindowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator()
var windowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator gopter.Gen

// WindowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator returns a generator of WindowsVMGuestPatchAutomaticByPlatformSettings_Status instances for property testing.
func WindowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator() gopter.Gen {
	if windowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator != nil {
		return windowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsStatus(generators)
	windowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator = gen.Struct(reflect.TypeOf(WindowsVMGuestPatchAutomaticByPlatformSettings_Status{}), generators)

	return windowsVMGuestPatchAutomaticByPlatformSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsStatus(gens map[string]gopter.Gen) {
	gens["RebootSetting"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiErrorBase_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBase_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBaseStatus, ApiErrorBaseStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBaseStatus runs a test to see if a specific instance of ApiErrorBase_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBaseStatus(subject ApiErrorBase_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBase_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBase_Status instances for property testing - lazily instantiated by ApiErrorBaseStatusGenerator()
var apiErrorBaseStatusGenerator gopter.Gen

// ApiErrorBaseStatusGenerator returns a generator of ApiErrorBase_Status instances for property testing.
func ApiErrorBaseStatusGenerator() gopter.Gen {
	if apiErrorBaseStatusGenerator != nil {
		return apiErrorBaseStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBaseStatus(generators)
	apiErrorBaseStatusGenerator = gen.Struct(reflect.TypeOf(ApiErrorBase_Status{}), generators)

	return apiErrorBaseStatusGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBaseStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBaseStatus(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerError_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerErrorStatus, InnerErrorStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerErrorStatus runs a test to see if a specific instance of InnerError_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerErrorStatus(subject InnerError_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_Status instances for property testing - lazily instantiated by InnerErrorStatusGenerator()
var innerErrorStatusGenerator gopter.Gen

// InnerErrorStatusGenerator returns a generator of InnerError_Status instances for property testing.
func InnerErrorStatusGenerator() gopter.Gen {
	if innerErrorStatusGenerator != nil {
		return innerErrorStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerErrorStatus(generators)
	innerErrorStatusGenerator = gen.Struct(reflect.TypeOf(InnerError_Status{}), generators)

	return innerErrorStatusGenerator
}

// AddIndependentPropertyGeneratorsForInnerErrorStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerErrorStatus(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddressSku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSku, PublicIPAddressSkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSku runs a test to see if a specific instance of PublicIPAddressSku round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSku(subject PublicIPAddressSku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSku instances for property testing - lazily instantiated by PublicIPAddressSkuGenerator()
var publicIPAddressSkuGenerator gopter.Gen

// PublicIPAddressSkuGenerator returns a generator of PublicIPAddressSku instances for property testing.
func PublicIPAddressSkuGenerator() gopter.Gen {
	if publicIPAddressSkuGenerator != nil {
		return publicIPAddressSkuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSku(generators)
	publicIPAddressSkuGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSku{}), generators)

	return publicIPAddressSkuGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSku(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicIPAddressSku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSkuStatus, PublicIPAddressSkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSkuStatus runs a test to see if a specific instance of PublicIPAddressSku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSkuStatus(subject PublicIPAddressSku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSku_Status instances for property testing - lazily instantiated by
// PublicIPAddressSkuStatusGenerator()
var publicIPAddressSkuStatusGenerator gopter.Gen

// PublicIPAddressSkuStatusGenerator returns a generator of PublicIPAddressSku_Status instances for property testing.
func PublicIPAddressSkuStatusGenerator() gopter.Gen {
	if publicIPAddressSkuStatusGenerator != nil {
		return publicIPAddressSkuStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSkuStatus(generators)
	publicIPAddressSkuStatusGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSku_Status{}), generators)

	return publicIPAddressSkuStatusGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSkuStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSkuStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineIpTag_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIpTag via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIpTag, VirtualMachineIpTagGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIpTag runs a test to see if a specific instance of VirtualMachineIpTag round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIpTag(subject VirtualMachineIpTag) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIpTag
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIpTag instances for property testing - lazily instantiated by
// VirtualMachineIpTagGenerator()
var virtualMachineIpTagGenerator gopter.Gen

// VirtualMachineIpTagGenerator returns a generator of VirtualMachineIpTag instances for property testing.
func VirtualMachineIpTagGenerator() gopter.Gen {
	if virtualMachineIpTagGenerator != nil {
		return virtualMachineIpTagGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIpTag(generators)
	virtualMachineIpTagGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIpTag{}), generators)

	return virtualMachineIpTagGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIpTag is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIpTag(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineIpTag_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIpTag_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIpTagStatus, VirtualMachineIpTagStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIpTagStatus runs a test to see if a specific instance of VirtualMachineIpTag_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIpTagStatus(subject VirtualMachineIpTag_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIpTag_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIpTag_Status instances for property testing - lazily instantiated by
// VirtualMachineIpTagStatusGenerator()
var virtualMachineIpTagStatusGenerator gopter.Gen

// VirtualMachineIpTagStatusGenerator returns a generator of VirtualMachineIpTag_Status instances for property testing.
func VirtualMachineIpTagStatusGenerator() gopter.Gen {
	if virtualMachineIpTagStatusGenerator != nil {
		return virtualMachineIpTagStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIpTagStatus(generators)
	virtualMachineIpTagStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIpTag_Status{}), generators)

	return virtualMachineIpTagStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIpTagStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIpTagStatus(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinePublicIPAddressDnsSettingsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePublicIPAddressDnsSettingsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfiguration, VirtualMachinePublicIPAddressDnsSettingsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfiguration runs a test to see if a specific instance of VirtualMachinePublicIPAddressDnsSettingsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfiguration(subject VirtualMachinePublicIPAddressDnsSettingsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePublicIPAddressDnsSettingsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePublicIPAddressDnsSettingsConfiguration instances for property testing - lazily
// instantiated by VirtualMachinePublicIPAddressDnsSettingsConfigurationGenerator()
var virtualMachinePublicIPAddressDnsSettingsConfigurationGenerator gopter.Gen

// VirtualMachinePublicIPAddressDnsSettingsConfigurationGenerator returns a generator of VirtualMachinePublicIPAddressDnsSettingsConfiguration instances for property testing.
func VirtualMachinePublicIPAddressDnsSettingsConfigurationGenerator() gopter.Gen {
	if virtualMachinePublicIPAddressDnsSettingsConfigurationGenerator != nil {
		return virtualMachinePublicIPAddressDnsSettingsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfiguration(generators)
	virtualMachinePublicIPAddressDnsSettingsConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressDnsSettingsConfiguration{}), generators)

	return virtualMachinePublicIPAddressDnsSettingsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfiguration(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinePublicIPAddressDnsSettingsConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePublicIPAddressDnsSettingsConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationStatus, VirtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationStatus runs a test to see if a specific instance of VirtualMachinePublicIPAddressDnsSettingsConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationStatus(subject VirtualMachinePublicIPAddressDnsSettingsConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePublicIPAddressDnsSettingsConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePublicIPAddressDnsSettingsConfiguration_Status instances for property testing - lazily
// instantiated by VirtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator()
var virtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator gopter.Gen

// VirtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator returns a generator of VirtualMachinePublicIPAddressDnsSettingsConfiguration_Status instances for property testing.
func VirtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator() gopter.Gen {
	if virtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator != nil {
		return virtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationStatus(generators)
	virtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressDnsSettingsConfiguration_Status{}), generators)

	return virtualMachinePublicIPAddressDnsSettingsConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationStatus(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
}
