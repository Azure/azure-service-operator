// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20200930

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Disks_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disks_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisks_SpecARM, Disks_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisks_SpecARM runs a test to see if a specific instance of Disks_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDisks_SpecARM(subject Disks_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disks_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disks_SpecARM instances for property testing - lazily instantiated by Disks_SpecARMGenerator()
var disks_SpecARMGenerator gopter.Gen

// Disks_SpecARMGenerator returns a generator of Disks_SpecARM instances for property testing.
// We first initialize disks_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disks_SpecARMGenerator() gopter.Gen {
	if disks_SpecARMGenerator != nil {
		return disks_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisks_SpecARM(generators)
	disks_SpecARMGenerator = gen.Struct(reflect.TypeOf(Disks_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisks_SpecARM(generators)
	AddRelatedPropertyGeneratorsForDisks_SpecARM(generators)
	disks_SpecARMGenerator = gen.Struct(reflect.TypeOf(Disks_SpecARM{}), generators)

	return disks_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForDisks_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisks_SpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisks_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisks_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Properties"] = gen.PtrOf(DiskPropertiesARMGenerator())
	gens["Sku"] = gen.PtrOf(DiskSkuARMGenerator())
}

func Test_DiskPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskPropertiesARM, DiskPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskPropertiesARM runs a test to see if a specific instance of DiskPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskPropertiesARM(subject DiskPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskPropertiesARM instances for property testing - lazily instantiated by DiskPropertiesARMGenerator()
var diskPropertiesARMGenerator gopter.Gen

// DiskPropertiesARMGenerator returns a generator of DiskPropertiesARM instances for property testing.
// We first initialize diskPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskPropertiesARMGenerator() gopter.Gen {
	if diskPropertiesARMGenerator != nil {
		return diskPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskPropertiesARM(generators)
	diskPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DiskPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForDiskPropertiesARM(generators)
	diskPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DiskPropertiesARM{}), generators)

	return diskPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskPropertiesARM(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskProperties_HyperVGeneration_V1, DiskProperties_HyperVGeneration_V2))
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(DiskProperties_NetworkAccessPolicy_AllowAll, DiskProperties_NetworkAccessPolicy_AllowPrivate, DiskProperties_NetworkAccessPolicy_DenyAll))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskProperties_OsType_Linux, DiskProperties_OsType_Windows))
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskPropertiesARM(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationDataARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionARMGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollectionARMGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlanARMGenerator())
}

func Test_DiskSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSkuARM, DiskSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSkuARM runs a test to see if a specific instance of DiskSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSkuARM(subject DiskSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSkuARM instances for property testing - lazily instantiated by DiskSkuARMGenerator()
var diskSkuARMGenerator gopter.Gen

// DiskSkuARMGenerator returns a generator of DiskSkuARM instances for property testing.
func DiskSkuARMGenerator() gopter.Gen {
	if diskSkuARMGenerator != nil {
		return diskSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSkuARM(generators)
	diskSkuARMGenerator = gen.Struct(reflect.TypeOf(DiskSkuARM{}), generators)

	return diskSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSku_Name_Premium_LRS,
		DiskSku_Name_StandardSSD_LRS,
		DiskSku_Name_Standard_LRS,
		DiskSku_Name_UltraSSD_LRS))
}

func Test_ExtendedLocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationARM, ExtendedLocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationARM runs a test to see if a specific instance of ExtendedLocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationARM(subject ExtendedLocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocationARM instances for property testing - lazily instantiated by
// ExtendedLocationARMGenerator()
var extendedLocationARMGenerator gopter.Gen

// ExtendedLocationARMGenerator returns a generator of ExtendedLocationARM instances for property testing.
func ExtendedLocationARMGenerator() gopter.Gen {
	if extendedLocationARMGenerator != nil {
		return extendedLocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationARM(generators)
	extendedLocationARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocationARM{}), generators)

	return extendedLocationARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocation_Type_EdgeZone))
}

func Test_CreationDataARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationDataARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationDataARM, CreationDataARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationDataARM runs a test to see if a specific instance of CreationDataARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationDataARM(subject CreationDataARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationDataARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationDataARM instances for property testing - lazily instantiated by CreationDataARMGenerator()
var creationDataARMGenerator gopter.Gen

// CreationDataARMGenerator returns a generator of CreationDataARM instances for property testing.
// We first initialize creationDataARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationDataARMGenerator() gopter.Gen {
	if creationDataARMGenerator != nil {
		return creationDataARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationDataARM(generators)
	creationDataARMGenerator = gen.Struct(reflect.TypeOf(CreationDataARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationDataARM(generators)
	AddRelatedPropertyGeneratorsForCreationDataARM(generators)
	creationDataARMGenerator = gen.Struct(reflect.TypeOf(CreationDataARM{}), generators)

	return creationDataARMGenerator
}

// AddIndependentPropertyGeneratorsForCreationDataARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationDataARM(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(
		CreationData_CreateOption_Attach,
		CreationData_CreateOption_Copy,
		CreationData_CreateOption_Empty,
		CreationData_CreateOption_FromImage,
		CreationData_CreateOption_Import,
		CreationData_CreateOption_Restore,
		CreationData_CreateOption_Upload))
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationDataARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationDataARM(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReferenceARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReferenceARMGenerator())
}

func Test_EncryptionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionARM, EncryptionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionARM runs a test to see if a specific instance of EncryptionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionARM(subject EncryptionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionARM instances for property testing - lazily instantiated by EncryptionARMGenerator()
var encryptionARMGenerator gopter.Gen

// EncryptionARMGenerator returns a generator of EncryptionARM instances for property testing.
func EncryptionARMGenerator() gopter.Gen {
	if encryptionARMGenerator != nil {
		return encryptionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionARM(generators)
	encryptionARMGenerator = gen.Struct(reflect.TypeOf(EncryptionARM{}), generators)

	return encryptionARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Encryption_Type_EncryptionAtRestWithCustomerKey, Encryption_Type_EncryptionAtRestWithPlatformAndCustomerKeys, Encryption_Type_EncryptionAtRestWithPlatformKey))
}

func Test_EncryptionSettingsCollectionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollectionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollectionARM, EncryptionSettingsCollectionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollectionARM runs a test to see if a specific instance of EncryptionSettingsCollectionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollectionARM(subject EncryptionSettingsCollectionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollectionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollectionARM instances for property testing - lazily instantiated by
// EncryptionSettingsCollectionARMGenerator()
var encryptionSettingsCollectionARMGenerator gopter.Gen

// EncryptionSettingsCollectionARMGenerator returns a generator of EncryptionSettingsCollectionARM instances for property testing.
// We first initialize encryptionSettingsCollectionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollectionARMGenerator() gopter.Gen {
	if encryptionSettingsCollectionARMGenerator != nil {
		return encryptionSettingsCollectionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionARM(generators)
	encryptionSettingsCollectionARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollectionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionARM(generators)
	encryptionSettingsCollectionARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollectionARM{}), generators)

	return encryptionSettingsCollectionARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollectionARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollectionARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElementARMGenerator())
}

func Test_PurchasePlanARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlanARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlanARM, PurchasePlanARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlanARM runs a test to see if a specific instance of PurchasePlanARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlanARM(subject PurchasePlanARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlanARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlanARM instances for property testing - lazily instantiated by PurchasePlanARMGenerator()
var purchasePlanARMGenerator gopter.Gen

// PurchasePlanARMGenerator returns a generator of PurchasePlanARM instances for property testing.
func PurchasePlanARMGenerator() gopter.Gen {
	if purchasePlanARMGenerator != nil {
		return purchasePlanARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlanARM(generators)
	purchasePlanARMGenerator = gen.Struct(reflect.TypeOf(PurchasePlanARM{}), generators)

	return purchasePlanARMGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlanARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlanARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettingsElementARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElementARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElementARM, EncryptionSettingsElementARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElementARM runs a test to see if a specific instance of EncryptionSettingsElementARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElementARM(subject EncryptionSettingsElementARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElementARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElementARM instances for property testing - lazily instantiated by
// EncryptionSettingsElementARMGenerator()
var encryptionSettingsElementARMGenerator gopter.Gen

// EncryptionSettingsElementARMGenerator returns a generator of EncryptionSettingsElementARM instances for property testing.
func EncryptionSettingsElementARMGenerator() gopter.Gen {
	if encryptionSettingsElementARMGenerator != nil {
		return encryptionSettingsElementARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElementARM(generators)
	encryptionSettingsElementARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElementARM{}), generators)

	return encryptionSettingsElementARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElementARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElementARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReferenceARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReferenceARMGenerator())
}

func Test_ImageDiskReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReferenceARM, ImageDiskReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReferenceARM runs a test to see if a specific instance of ImageDiskReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReferenceARM(subject ImageDiskReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReferenceARM instances for property testing - lazily instantiated by
// ImageDiskReferenceARMGenerator()
var imageDiskReferenceARMGenerator gopter.Gen

// ImageDiskReferenceARMGenerator returns a generator of ImageDiskReferenceARM instances for property testing.
func ImageDiskReferenceARMGenerator() gopter.Gen {
	if imageDiskReferenceARMGenerator != nil {
		return imageDiskReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReferenceARM(generators)
	imageDiskReferenceARMGenerator = gen.Struct(reflect.TypeOf(ImageDiskReferenceARM{}), generators)

	return imageDiskReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReferenceARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Lun"] = gen.PtrOf(gen.Int())
}

func Test_KeyVaultAndKeyReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReferenceARM, KeyVaultAndKeyReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReferenceARM runs a test to see if a specific instance of KeyVaultAndKeyReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReferenceARM(subject KeyVaultAndKeyReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReferenceARM instances for property testing - lazily instantiated by
// KeyVaultAndKeyReferenceARMGenerator()
var keyVaultAndKeyReferenceARMGenerator gopter.Gen

// KeyVaultAndKeyReferenceARMGenerator returns a generator of KeyVaultAndKeyReferenceARM instances for property testing.
// We first initialize keyVaultAndKeyReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReferenceARMGenerator() gopter.Gen {
	if keyVaultAndKeyReferenceARMGenerator != nil {
		return keyVaultAndKeyReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceARM(generators)
	keyVaultAndKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceARM(generators)
	keyVaultAndKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReferenceARM{}), generators)

	return keyVaultAndKeyReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVaultARMGenerator())
}

func Test_KeyVaultAndSecretReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReferenceARM, KeyVaultAndSecretReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReferenceARM runs a test to see if a specific instance of KeyVaultAndSecretReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReferenceARM(subject KeyVaultAndSecretReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReferenceARM instances for property testing - lazily instantiated by
// KeyVaultAndSecretReferenceARMGenerator()
var keyVaultAndSecretReferenceARMGenerator gopter.Gen

// KeyVaultAndSecretReferenceARMGenerator returns a generator of KeyVaultAndSecretReferenceARM instances for property testing.
// We first initialize keyVaultAndSecretReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReferenceARMGenerator() gopter.Gen {
	if keyVaultAndSecretReferenceARMGenerator != nil {
		return keyVaultAndSecretReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceARM(generators)
	keyVaultAndSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceARM(generators)
	keyVaultAndSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReferenceARM{}), generators)

	return keyVaultAndSecretReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVaultARMGenerator())
}

func Test_SourceVaultARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceVaultARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceVaultARM, SourceVaultARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceVaultARM runs a test to see if a specific instance of SourceVaultARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceVaultARM(subject SourceVaultARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceVaultARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceVaultARM instances for property testing - lazily instantiated by SourceVaultARMGenerator()
var sourceVaultARMGenerator gopter.Gen

// SourceVaultARMGenerator returns a generator of SourceVaultARM instances for property testing.
func SourceVaultARMGenerator() gopter.Gen {
	if sourceVaultARMGenerator != nil {
		return sourceVaultARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSourceVaultARM(generators)
	sourceVaultARMGenerator = gen.Struct(reflect.TypeOf(SourceVaultARM{}), generators)

	return sourceVaultARMGenerator
}

// AddIndependentPropertyGeneratorsForSourceVaultARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSourceVaultARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
