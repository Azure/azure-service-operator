// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240302

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_CreationData_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreationData_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreationData_STATUS_ARM, CreationData_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreationData_STATUS_ARM runs a test to see if a specific instance of CreationData_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCreationData_STATUS_ARM(subject CreationData_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreationData_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreationData_STATUS_ARM instances for property testing - lazily instantiated by
// CreationData_STATUS_ARMGenerator()
var creationData_STATUS_ARMGenerator gopter.Gen

// CreationData_STATUS_ARMGenerator returns a generator of CreationData_STATUS_ARM instances for property testing.
// We first initialize creationData_STATUS_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreationData_STATUS_ARMGenerator() gopter.Gen {
	if creationData_STATUS_ARMGenerator != nil {
		return creationData_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_STATUS_ARM(generators)
	creationData_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(CreationData_STATUS_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreationData_STATUS_ARM(generators)
	AddRelatedPropertyGeneratorsForCreationData_STATUS_ARM(generators)
	creationData_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(CreationData_STATUS_ARM{}), generators)

	return creationData_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCreationData_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreationData_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(
		CreationData_CreateOption_STATUS_Attach,
		CreationData_CreateOption_STATUS_Copy,
		CreationData_CreateOption_STATUS_CopyFromSanSnapshot,
		CreationData_CreateOption_STATUS_CopyStart,
		CreationData_CreateOption_STATUS_Empty,
		CreationData_CreateOption_STATUS_FromImage,
		CreationData_CreateOption_STATUS_Import,
		CreationData_CreateOption_STATUS_ImportSecure,
		CreationData_CreateOption_STATUS_Restore,
		CreationData_CreateOption_STATUS_Upload,
		CreationData_CreateOption_STATUS_UploadPreparedSecure))
	gens["ElasticSanResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["LogicalSectorSize"] = gen.PtrOf(gen.Int())
	gens["PerformancePlus"] = gen.PtrOf(gen.Bool())
	gens["ProvisionedBandwidthCopySpeed"] = gen.PtrOf(gen.OneConstOf(CreationData_ProvisionedBandwidthCopySpeed_STATUS_Enhanced, CreationData_ProvisionedBandwidthCopySpeed_STATUS_None))
	gens["SecurityDataUri"] = gen.PtrOf(gen.AlphaString())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUniqueId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["UploadSizeBytes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreationData_STATUS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreationData_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["GalleryImageReference"] = gen.PtrOf(ImageDiskReference_STATUS_ARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageDiskReference_STATUS_ARMGenerator())
}

func Test_DiskProperties_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskProperties_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskProperties_STATUS_ARM, DiskProperties_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskProperties_STATUS_ARM runs a test to see if a specific instance of DiskProperties_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskProperties_STATUS_ARM(subject DiskProperties_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskProperties_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskProperties_STATUS_ARM instances for property testing - lazily instantiated by
// DiskProperties_STATUS_ARMGenerator()
var diskProperties_STATUS_ARMGenerator gopter.Gen

// DiskProperties_STATUS_ARMGenerator returns a generator of DiskProperties_STATUS_ARM instances for property testing.
// We first initialize diskProperties_STATUS_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskProperties_STATUS_ARMGenerator() gopter.Gen {
	if diskProperties_STATUS_ARMGenerator != nil {
		return diskProperties_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskProperties_STATUS_ARM(generators)
	diskProperties_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_STATUS_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskProperties_STATUS_ARM(generators)
	AddRelatedPropertyGeneratorsForDiskProperties_STATUS_ARM(generators)
	diskProperties_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(DiskProperties_STATUS_ARM{}), generators)

	return diskProperties_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskProperties_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskProperties_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["BurstingEnabled"] = gen.PtrOf(gen.Bool())
	gens["BurstingEnabledTime"] = gen.PtrOf(gen.AlphaString())
	gens["CompletionPercent"] = gen.PtrOf(gen.Float64())
	gens["DataAccessAuthMode"] = gen.PtrOf(gen.OneConstOf(DataAccessAuthMode_STATUS_AzureActiveDirectory, DataAccessAuthMode_STATUS_None))
	gens["DiskAccessId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskIOPSReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadOnly"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeBytes"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["DiskState"] = gen.PtrOf(gen.OneConstOf(
		DiskState_STATUS_ActiveSAS,
		DiskState_STATUS_ActiveSASFrozen,
		DiskState_STATUS_ActiveUpload,
		DiskState_STATUS_Attached,
		DiskState_STATUS_Frozen,
		DiskState_STATUS_ReadyToUpload,
		DiskState_STATUS_Reserved,
		DiskState_STATUS_Unattached))
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(DiskProperties_HyperVGeneration_STATUS_V1, DiskProperties_HyperVGeneration_STATUS_V2))
	gens["LastOwnershipUpdateTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaxShares"] = gen.PtrOf(gen.Int())
	gens["NetworkAccessPolicy"] = gen.PtrOf(gen.OneConstOf(NetworkAccessPolicy_STATUS_AllowAll, NetworkAccessPolicy_STATUS_AllowPrivate, NetworkAccessPolicy_STATUS_DenyAll))
	gens["OptimizedForFrequentAttach"] = gen.PtrOf(gen.Bool())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(DiskProperties_OsType_STATUS_Linux, DiskProperties_OsType_STATUS_Windows))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_STATUS_Disabled, PublicNetworkAccess_STATUS_Enabled))
	gens["SupportsHibernation"] = gen.PtrOf(gen.Bool())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
	gens["TimeCreated"] = gen.PtrOf(gen.AlphaString())
	gens["UniqueId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskProperties_STATUS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskProperties_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["CreationData"] = gen.PtrOf(CreationData_STATUS_ARMGenerator())
	gens["Encryption"] = gen.PtrOf(Encryption_STATUS_ARMGenerator())
	gens["EncryptionSettingsCollection"] = gen.PtrOf(EncryptionSettingsCollection_STATUS_ARMGenerator())
	gens["PropertyUpdatesInProgress"] = gen.PtrOf(PropertyUpdatesInProgress_STATUS_ARMGenerator())
	gens["PurchasePlan"] = gen.PtrOf(PurchasePlan_STATUS_ARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(DiskSecurityProfile_STATUS_ARMGenerator())
	gens["ShareInfo"] = gen.SliceOf(ShareInfoElement_STATUS_ARMGenerator())
	gens["SupportedCapabilities"] = gen.PtrOf(SupportedCapabilities_STATUS_ARMGenerator())
}

func Test_DiskSecurityProfile_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSecurityProfile_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSecurityProfile_STATUS_ARM, DiskSecurityProfile_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSecurityProfile_STATUS_ARM runs a test to see if a specific instance of DiskSecurityProfile_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSecurityProfile_STATUS_ARM(subject DiskSecurityProfile_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSecurityProfile_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSecurityProfile_STATUS_ARM instances for property testing - lazily instantiated by
// DiskSecurityProfile_STATUS_ARMGenerator()
var diskSecurityProfile_STATUS_ARMGenerator gopter.Gen

// DiskSecurityProfile_STATUS_ARMGenerator returns a generator of DiskSecurityProfile_STATUS_ARM instances for property testing.
func DiskSecurityProfile_STATUS_ARMGenerator() gopter.Gen {
	if diskSecurityProfile_STATUS_ARMGenerator != nil {
		return diskSecurityProfile_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSecurityProfile_STATUS_ARM(generators)
	diskSecurityProfile_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(DiskSecurityProfile_STATUS_ARM{}), generators)

	return diskSecurityProfile_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSecurityProfile_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSecurityProfile_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["SecureVMDiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(
		DiskSecurityType_STATUS_ConfidentialVM_DiskEncryptedWithCustomerKey,
		DiskSecurityType_STATUS_ConfidentialVM_DiskEncryptedWithPlatformKey,
		DiskSecurityType_STATUS_ConfidentialVM_NonPersistedTPM,
		DiskSecurityType_STATUS_ConfidentialVM_VMGuestStateOnlyEncryptedWithPlatformKey,
		DiskSecurityType_STATUS_TrustedLaunch))
}

func Test_DiskSku_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskSku_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskSku_STATUS_ARM, DiskSku_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskSku_STATUS_ARM runs a test to see if a specific instance of DiskSku_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskSku_STATUS_ARM(subject DiskSku_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskSku_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskSku_STATUS_ARM instances for property testing - lazily instantiated by DiskSku_STATUS_ARMGenerator()
var diskSku_STATUS_ARMGenerator gopter.Gen

// DiskSku_STATUS_ARMGenerator returns a generator of DiskSku_STATUS_ARM instances for property testing.
func DiskSku_STATUS_ARMGenerator() gopter.Gen {
	if diskSku_STATUS_ARMGenerator != nil {
		return diskSku_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskSku_STATUS_ARM(generators)
	diskSku_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(DiskSku_STATUS_ARM{}), generators)

	return diskSku_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskSku_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskSku_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DiskSku_Name_STATUS_PremiumV2_LRS,
		DiskSku_Name_STATUS_Premium_LRS,
		DiskSku_Name_STATUS_Premium_ZRS,
		DiskSku_Name_STATUS_StandardSSD_LRS,
		DiskSku_Name_STATUS_StandardSSD_ZRS,
		DiskSku_Name_STATUS_Standard_LRS,
		DiskSku_Name_STATUS_UltraSSD_LRS))
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Disk_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Disk_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDisk_STATUS_ARM, Disk_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDisk_STATUS_ARM runs a test to see if a specific instance of Disk_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDisk_STATUS_ARM(subject Disk_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Disk_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Disk_STATUS_ARM instances for property testing - lazily instantiated by Disk_STATUS_ARMGenerator()
var disk_STATUS_ARMGenerator gopter.Gen

// Disk_STATUS_ARMGenerator returns a generator of Disk_STATUS_ARM instances for property testing.
// We first initialize disk_STATUS_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Disk_STATUS_ARMGenerator() gopter.Gen {
	if disk_STATUS_ARMGenerator != nil {
		return disk_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_STATUS_ARM(generators)
	disk_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(Disk_STATUS_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDisk_STATUS_ARM(generators)
	AddRelatedPropertyGeneratorsForDisk_STATUS_ARM(generators)
	disk_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(Disk_STATUS_ARM{}), generators)

	return disk_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDisk_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDisk_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedByExtended"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDisk_STATUS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDisk_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUS_ARMGenerator())
	gens["Properties"] = gen.PtrOf(DiskProperties_STATUS_ARMGenerator())
	gens["Sku"] = gen.PtrOf(DiskSku_STATUS_ARMGenerator())
}

func Test_EncryptionSettingsCollection_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsCollection_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsCollection_STATUS_ARM, EncryptionSettingsCollection_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsCollection_STATUS_ARM runs a test to see if a specific instance of EncryptionSettingsCollection_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsCollection_STATUS_ARM(subject EncryptionSettingsCollection_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsCollection_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsCollection_STATUS_ARM instances for property testing - lazily instantiated by
// EncryptionSettingsCollection_STATUS_ARMGenerator()
var encryptionSettingsCollection_STATUS_ARMGenerator gopter.Gen

// EncryptionSettingsCollection_STATUS_ARMGenerator returns a generator of EncryptionSettingsCollection_STATUS_ARM instances for property testing.
// We first initialize encryptionSettingsCollection_STATUS_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionSettingsCollection_STATUS_ARMGenerator() gopter.Gen {
	if encryptionSettingsCollection_STATUS_ARMGenerator != nil {
		return encryptionSettingsCollection_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_STATUS_ARM(generators)
	encryptionSettingsCollection_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_STATUS_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_STATUS_ARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_STATUS_ARM(generators)
	encryptionSettingsCollection_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsCollection_STATUS_ARM{}), generators)

	return encryptionSettingsCollection_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettingsCollection_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EncryptionSettingsVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_STATUS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsCollection_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(EncryptionSettingsElement_STATUS_ARMGenerator())
}

func Test_EncryptionSettingsElement_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettingsElement_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettingsElement_STATUS_ARM, EncryptionSettingsElement_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettingsElement_STATUS_ARM runs a test to see if a specific instance of EncryptionSettingsElement_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettingsElement_STATUS_ARM(subject EncryptionSettingsElement_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettingsElement_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettingsElement_STATUS_ARM instances for property testing - lazily instantiated by
// EncryptionSettingsElement_STATUS_ARMGenerator()
var encryptionSettingsElement_STATUS_ARMGenerator gopter.Gen

// EncryptionSettingsElement_STATUS_ARMGenerator returns a generator of EncryptionSettingsElement_STATUS_ARM instances for property testing.
func EncryptionSettingsElement_STATUS_ARMGenerator() gopter.Gen {
	if encryptionSettingsElement_STATUS_ARMGenerator != nil {
		return encryptionSettingsElement_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionSettingsElement_STATUS_ARM(generators)
	encryptionSettingsElement_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(EncryptionSettingsElement_STATUS_ARM{}), generators)

	return encryptionSettingsElement_STATUS_ARMGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionSettingsElement_STATUS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionSettingsElement_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultAndSecretReference_STATUS_ARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultAndKeyReference_STATUS_ARMGenerator())
}

func Test_Encryption_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_STATUS_ARM, Encryption_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_STATUS_ARM runs a test to see if a specific instance of Encryption_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_STATUS_ARM(subject Encryption_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_STATUS_ARM instances for property testing - lazily instantiated by
// Encryption_STATUS_ARMGenerator()
var encryption_STATUS_ARMGenerator gopter.Gen

// Encryption_STATUS_ARMGenerator returns a generator of Encryption_STATUS_ARM instances for property testing.
func Encryption_STATUS_ARMGenerator() gopter.Gen {
	if encryption_STATUS_ARMGenerator != nil {
		return encryption_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_STATUS_ARM(generators)
	encryption_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(Encryption_STATUS_ARM{}), generators)

	return encryption_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(EncryptionType_STATUS_EncryptionAtRestWithCustomerKey, EncryptionType_STATUS_EncryptionAtRestWithPlatformAndCustomerKeys, EncryptionType_STATUS_EncryptionAtRestWithPlatformKey))
}

func Test_ImageDiskReference_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageDiskReference_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageDiskReference_STATUS_ARM, ImageDiskReference_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageDiskReference_STATUS_ARM runs a test to see if a specific instance of ImageDiskReference_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageDiskReference_STATUS_ARM(subject ImageDiskReference_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageDiskReference_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageDiskReference_STATUS_ARM instances for property testing - lazily instantiated by
// ImageDiskReference_STATUS_ARMGenerator()
var imageDiskReference_STATUS_ARMGenerator gopter.Gen

// ImageDiskReference_STATUS_ARMGenerator returns a generator of ImageDiskReference_STATUS_ARM instances for property testing.
func ImageDiskReference_STATUS_ARMGenerator() gopter.Gen {
	if imageDiskReference_STATUS_ARMGenerator != nil {
		return imageDiskReference_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageDiskReference_STATUS_ARM(generators)
	imageDiskReference_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(ImageDiskReference_STATUS_ARM{}), generators)

	return imageDiskReference_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForImageDiskReference_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageDiskReference_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["CommunityGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["SharedGalleryImageId"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultAndKeyReference_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndKeyReference_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndKeyReference_STATUS_ARM, KeyVaultAndKeyReference_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndKeyReference_STATUS_ARM runs a test to see if a specific instance of KeyVaultAndKeyReference_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndKeyReference_STATUS_ARM(subject KeyVaultAndKeyReference_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndKeyReference_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndKeyReference_STATUS_ARM instances for property testing - lazily instantiated by
// KeyVaultAndKeyReference_STATUS_ARMGenerator()
var keyVaultAndKeyReference_STATUS_ARMGenerator gopter.Gen

// KeyVaultAndKeyReference_STATUS_ARMGenerator returns a generator of KeyVaultAndKeyReference_STATUS_ARM instances for property testing.
// We first initialize keyVaultAndKeyReference_STATUS_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndKeyReference_STATUS_ARMGenerator() gopter.Gen {
	if keyVaultAndKeyReference_STATUS_ARMGenerator != nil {
		return keyVaultAndKeyReference_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_STATUS_ARM(generators)
	keyVaultAndKeyReference_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_STATUS_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_STATUS_ARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_STATUS_ARM(generators)
	keyVaultAndKeyReference_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndKeyReference_STATUS_ARM{}), generators)

	return keyVaultAndKeyReference_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndKeyReference_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_STATUS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndKeyReference_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVault_STATUS_ARMGenerator())
}

func Test_KeyVaultAndSecretReference_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultAndSecretReference_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultAndSecretReference_STATUS_ARM, KeyVaultAndSecretReference_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultAndSecretReference_STATUS_ARM runs a test to see if a specific instance of KeyVaultAndSecretReference_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultAndSecretReference_STATUS_ARM(subject KeyVaultAndSecretReference_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultAndSecretReference_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultAndSecretReference_STATUS_ARM instances for property testing - lazily instantiated by
// KeyVaultAndSecretReference_STATUS_ARMGenerator()
var keyVaultAndSecretReference_STATUS_ARMGenerator gopter.Gen

// KeyVaultAndSecretReference_STATUS_ARMGenerator returns a generator of KeyVaultAndSecretReference_STATUS_ARM instances for property testing.
// We first initialize keyVaultAndSecretReference_STATUS_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultAndSecretReference_STATUS_ARMGenerator() gopter.Gen {
	if keyVaultAndSecretReference_STATUS_ARMGenerator != nil {
		return keyVaultAndSecretReference_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_STATUS_ARM(generators)
	keyVaultAndSecretReference_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_STATUS_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_STATUS_ARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_STATUS_ARM(generators)
	keyVaultAndSecretReference_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultAndSecretReference_STATUS_ARM{}), generators)

	return keyVaultAndSecretReference_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultAndSecretReference_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_STATUS_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultAndSecretReference_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SourceVault_STATUS_ARMGenerator())
}

func Test_PropertyUpdatesInProgress_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PropertyUpdatesInProgress_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPropertyUpdatesInProgress_STATUS_ARM, PropertyUpdatesInProgress_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPropertyUpdatesInProgress_STATUS_ARM runs a test to see if a specific instance of PropertyUpdatesInProgress_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPropertyUpdatesInProgress_STATUS_ARM(subject PropertyUpdatesInProgress_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PropertyUpdatesInProgress_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PropertyUpdatesInProgress_STATUS_ARM instances for property testing - lazily instantiated by
// PropertyUpdatesInProgress_STATUS_ARMGenerator()
var propertyUpdatesInProgress_STATUS_ARMGenerator gopter.Gen

// PropertyUpdatesInProgress_STATUS_ARMGenerator returns a generator of PropertyUpdatesInProgress_STATUS_ARM instances for property testing.
func PropertyUpdatesInProgress_STATUS_ARMGenerator() gopter.Gen {
	if propertyUpdatesInProgress_STATUS_ARMGenerator != nil {
		return propertyUpdatesInProgress_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPropertyUpdatesInProgress_STATUS_ARM(generators)
	propertyUpdatesInProgress_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(PropertyUpdatesInProgress_STATUS_ARM{}), generators)

	return propertyUpdatesInProgress_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPropertyUpdatesInProgress_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPropertyUpdatesInProgress_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["TargetTier"] = gen.PtrOf(gen.AlphaString())
}

func Test_PurchasePlan_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurchasePlan_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurchasePlan_STATUS_ARM, PurchasePlan_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurchasePlan_STATUS_ARM runs a test to see if a specific instance of PurchasePlan_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPurchasePlan_STATUS_ARM(subject PurchasePlan_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurchasePlan_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurchasePlan_STATUS_ARM instances for property testing - lazily instantiated by
// PurchasePlan_STATUS_ARMGenerator()
var purchasePlan_STATUS_ARMGenerator gopter.Gen

// PurchasePlan_STATUS_ARMGenerator returns a generator of PurchasePlan_STATUS_ARM instances for property testing.
func PurchasePlan_STATUS_ARMGenerator() gopter.Gen {
	if purchasePlan_STATUS_ARMGenerator != nil {
		return purchasePlan_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurchasePlan_STATUS_ARM(generators)
	purchasePlan_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(PurchasePlan_STATUS_ARM{}), generators)

	return purchasePlan_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPurchasePlan_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurchasePlan_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
}

func Test_ShareInfoElement_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShareInfoElement_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShareInfoElement_STATUS_ARM, ShareInfoElement_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShareInfoElement_STATUS_ARM runs a test to see if a specific instance of ShareInfoElement_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForShareInfoElement_STATUS_ARM(subject ShareInfoElement_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShareInfoElement_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShareInfoElement_STATUS_ARM instances for property testing - lazily instantiated by
// ShareInfoElement_STATUS_ARMGenerator()
var shareInfoElement_STATUS_ARMGenerator gopter.Gen

// ShareInfoElement_STATUS_ARMGenerator returns a generator of ShareInfoElement_STATUS_ARM instances for property testing.
func ShareInfoElement_STATUS_ARMGenerator() gopter.Gen {
	if shareInfoElement_STATUS_ARMGenerator != nil {
		return shareInfoElement_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShareInfoElement_STATUS_ARM(generators)
	shareInfoElement_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(ShareInfoElement_STATUS_ARM{}), generators)

	return shareInfoElement_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForShareInfoElement_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShareInfoElement_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["VmUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_SupportedCapabilities_STATUS_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SupportedCapabilities_STATUS_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSupportedCapabilities_STATUS_ARM, SupportedCapabilities_STATUS_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSupportedCapabilities_STATUS_ARM runs a test to see if a specific instance of SupportedCapabilities_STATUS_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSupportedCapabilities_STATUS_ARM(subject SupportedCapabilities_STATUS_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SupportedCapabilities_STATUS_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SupportedCapabilities_STATUS_ARM instances for property testing - lazily instantiated by
// SupportedCapabilities_STATUS_ARMGenerator()
var supportedCapabilities_STATUS_ARMGenerator gopter.Gen

// SupportedCapabilities_STATUS_ARMGenerator returns a generator of SupportedCapabilities_STATUS_ARM instances for property testing.
func SupportedCapabilities_STATUS_ARMGenerator() gopter.Gen {
	if supportedCapabilities_STATUS_ARMGenerator != nil {
		return supportedCapabilities_STATUS_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSupportedCapabilities_STATUS_ARM(generators)
	supportedCapabilities_STATUS_ARMGenerator = gen.Struct(reflect.TypeOf(SupportedCapabilities_STATUS_ARM{}), generators)

	return supportedCapabilities_STATUS_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSupportedCapabilities_STATUS_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSupportedCapabilities_STATUS_ARM(gens map[string]gopter.Gen) {
	gens["AcceleratedNetwork"] = gen.PtrOf(gen.Bool())
	gens["Architecture"] = gen.PtrOf(gen.OneConstOf(SupportedCapabilities_Architecture_STATUS_Arm64, SupportedCapabilities_Architecture_STATUS_X64))
	gens["DiskControllerTypes"] = gen.PtrOf(gen.AlphaString())
}
