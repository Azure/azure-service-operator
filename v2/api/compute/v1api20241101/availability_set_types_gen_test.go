// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20241101

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/compute/v1api20241101/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AvailabilitySet_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AvailabilitySet to hub returns original",
		prop.ForAll(RunResourceConversionTestForAvailabilitySet, AvailabilitySetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForAvailabilitySet tests if a specific instance of AvailabilitySet round trips to the hub storage version and back losslessly
func RunResourceConversionTestForAvailabilitySet(subject AvailabilitySet) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.AvailabilitySet
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual AvailabilitySet
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AvailabilitySet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AvailabilitySet to AvailabilitySet via AssignProperties_To_AvailabilitySet & AssignProperties_From_AvailabilitySet returns original",
		prop.ForAll(RunPropertyAssignmentTestForAvailabilitySet, AvailabilitySetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAvailabilitySet tests if a specific instance of AvailabilitySet can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAvailabilitySet(subject AvailabilitySet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AvailabilitySet
	err := copied.AssignProperties_To_AvailabilitySet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AvailabilitySet
	err = actual.AssignProperties_From_AvailabilitySet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AvailabilitySet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySet, AvailabilitySetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySet runs a test to see if a specific instance of AvailabilitySet round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySet(subject AvailabilitySet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySet instances for property testing - lazily instantiated by AvailabilitySetGenerator()
var availabilitySetGenerator gopter.Gen

// AvailabilitySetGenerator returns a generator of AvailabilitySet instances for property testing.
func AvailabilitySetGenerator() gopter.Gen {
	if availabilitySetGenerator != nil {
		return availabilitySetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAvailabilitySet(generators)
	availabilitySetGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet{}), generators)

	return availabilitySetGenerator
}

// AddRelatedPropertyGeneratorsForAvailabilitySet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailabilitySet(gens map[string]gopter.Gen) {
	gens["Spec"] = AvailabilitySet_SpecGenerator()
	gens["Status"] = AvailabilitySet_STATUSGenerator()
}

func Test_AvailabilitySetOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AvailabilitySetOperatorSpec to AvailabilitySetOperatorSpec via AssignProperties_To_AvailabilitySetOperatorSpec & AssignProperties_From_AvailabilitySetOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAvailabilitySetOperatorSpec, AvailabilitySetOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAvailabilitySetOperatorSpec tests if a specific instance of AvailabilitySetOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAvailabilitySetOperatorSpec(subject AvailabilitySetOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AvailabilitySetOperatorSpec
	err := copied.AssignProperties_To_AvailabilitySetOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AvailabilitySetOperatorSpec
	err = actual.AssignProperties_From_AvailabilitySetOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AvailabilitySetOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySetOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySetOperatorSpec, AvailabilitySetOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySetOperatorSpec runs a test to see if a specific instance of AvailabilitySetOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySetOperatorSpec(subject AvailabilitySetOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySetOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySetOperatorSpec instances for property testing - lazily instantiated by
// AvailabilitySetOperatorSpecGenerator()
var availabilitySetOperatorSpecGenerator gopter.Gen

// AvailabilitySetOperatorSpecGenerator returns a generator of AvailabilitySetOperatorSpec instances for property testing.
func AvailabilitySetOperatorSpecGenerator() gopter.Gen {
	if availabilitySetOperatorSpecGenerator != nil {
		return availabilitySetOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	availabilitySetOperatorSpecGenerator = gen.Struct(reflect.TypeOf(AvailabilitySetOperatorSpec{}), generators)

	return availabilitySetOperatorSpecGenerator
}

func Test_AvailabilitySet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AvailabilitySet_STATUS to AvailabilitySet_STATUS via AssignProperties_To_AvailabilitySet_STATUS & AssignProperties_From_AvailabilitySet_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAvailabilitySet_STATUS, AvailabilitySet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAvailabilitySet_STATUS tests if a specific instance of AvailabilitySet_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAvailabilitySet_STATUS(subject AvailabilitySet_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AvailabilitySet_STATUS
	err := copied.AssignProperties_To_AvailabilitySet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AvailabilitySet_STATUS
	err = actual.AssignProperties_From_AvailabilitySet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AvailabilitySet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySet_STATUS, AvailabilitySet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySet_STATUS runs a test to see if a specific instance of AvailabilitySet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySet_STATUS(subject AvailabilitySet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySet_STATUS instances for property testing - lazily instantiated by
// AvailabilitySet_STATUSGenerator()
var availabilitySet_STATUSGenerator gopter.Gen

// AvailabilitySet_STATUSGenerator returns a generator of AvailabilitySet_STATUS instances for property testing.
// We first initialize availabilitySet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailabilitySet_STATUSGenerator() gopter.Gen {
	if availabilitySet_STATUSGenerator != nil {
		return availabilitySet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_STATUS(generators)
	availabilitySet_STATUSGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_STATUS(generators)
	AddRelatedPropertyGeneratorsForAvailabilitySet_STATUS(generators)
	availabilitySet_STATUSGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_STATUS{}), generators)

	return availabilitySet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAvailabilitySet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailabilitySet_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomainCount"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAvailabilitySet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailabilitySet_STATUS(gens map[string]gopter.Gen) {
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["ScheduledEventsPolicy"] = gen.PtrOf(ScheduledEventsPolicy_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_STATUSGenerator())
	gens["VirtualMachineScaleSetMigrationInfo"] = gen.PtrOf(VirtualMachineScaleSetMigrationInfo_STATUSGenerator())
	gens["VirtualMachines"] = gen.SliceOf(SubResource_STATUSGenerator())
}

func Test_AvailabilitySet_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AvailabilitySet_Spec to AvailabilitySet_Spec via AssignProperties_To_AvailabilitySet_Spec & AssignProperties_From_AvailabilitySet_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAvailabilitySet_Spec, AvailabilitySet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAvailabilitySet_Spec tests if a specific instance of AvailabilitySet_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAvailabilitySet_Spec(subject AvailabilitySet_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AvailabilitySet_Spec
	err := copied.AssignProperties_To_AvailabilitySet_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AvailabilitySet_Spec
	err = actual.AssignProperties_From_AvailabilitySet_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AvailabilitySet_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySet_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySet_Spec, AvailabilitySet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySet_Spec runs a test to see if a specific instance of AvailabilitySet_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySet_Spec(subject AvailabilitySet_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySet_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySet_Spec instances for property testing - lazily instantiated by
// AvailabilitySet_SpecGenerator()
var availabilitySet_SpecGenerator gopter.Gen

// AvailabilitySet_SpecGenerator returns a generator of AvailabilitySet_Spec instances for property testing.
// We first initialize availabilitySet_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailabilitySet_SpecGenerator() gopter.Gen {
	if availabilitySet_SpecGenerator != nil {
		return availabilitySet_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(generators)
	availabilitySet_SpecGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(generators)
	AddRelatedPropertyGeneratorsForAvailabilitySet_Spec(generators)
	availabilitySet_SpecGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_Spec{}), generators)

	return availabilitySet_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAvailabilitySet_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomainCount"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAvailabilitySet_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailabilitySet_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(AvailabilitySetOperatorSpecGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceGenerator())
	gens["ScheduledEventsPolicy"] = gen.PtrOf(ScheduledEventsPolicyGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
	gens["VirtualMachines"] = gen.SliceOf(SubResourceGenerator())
}

func Test_DefaultVirtualMachineScaleSetInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DefaultVirtualMachineScaleSetInfo_STATUS to DefaultVirtualMachineScaleSetInfo_STATUS via AssignProperties_To_DefaultVirtualMachineScaleSetInfo_STATUS & AssignProperties_From_DefaultVirtualMachineScaleSetInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDefaultVirtualMachineScaleSetInfo_STATUS, DefaultVirtualMachineScaleSetInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDefaultVirtualMachineScaleSetInfo_STATUS tests if a specific instance of DefaultVirtualMachineScaleSetInfo_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDefaultVirtualMachineScaleSetInfo_STATUS(subject DefaultVirtualMachineScaleSetInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DefaultVirtualMachineScaleSetInfo_STATUS
	err := copied.AssignProperties_To_DefaultVirtualMachineScaleSetInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DefaultVirtualMachineScaleSetInfo_STATUS
	err = actual.AssignProperties_From_DefaultVirtualMachineScaleSetInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DefaultVirtualMachineScaleSetInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DefaultVirtualMachineScaleSetInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDefaultVirtualMachineScaleSetInfo_STATUS, DefaultVirtualMachineScaleSetInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDefaultVirtualMachineScaleSetInfo_STATUS runs a test to see if a specific instance of DefaultVirtualMachineScaleSetInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDefaultVirtualMachineScaleSetInfo_STATUS(subject DefaultVirtualMachineScaleSetInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DefaultVirtualMachineScaleSetInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DefaultVirtualMachineScaleSetInfo_STATUS instances for property testing - lazily instantiated by
// DefaultVirtualMachineScaleSetInfo_STATUSGenerator()
var defaultVirtualMachineScaleSetInfo_STATUSGenerator gopter.Gen

// DefaultVirtualMachineScaleSetInfo_STATUSGenerator returns a generator of DefaultVirtualMachineScaleSetInfo_STATUS instances for property testing.
// We first initialize defaultVirtualMachineScaleSetInfo_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DefaultVirtualMachineScaleSetInfo_STATUSGenerator() gopter.Gen {
	if defaultVirtualMachineScaleSetInfo_STATUSGenerator != nil {
		return defaultVirtualMachineScaleSetInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(generators)
	defaultVirtualMachineScaleSetInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(DefaultVirtualMachineScaleSetInfo_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(generators)
	AddRelatedPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(generators)
	defaultVirtualMachineScaleSetInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(DefaultVirtualMachineScaleSetInfo_STATUS{}), generators)

	return defaultVirtualMachineScaleSetInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(gens map[string]gopter.Gen) {
	gens["ConstrainedMaximumCapacity"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultVirtualMachineScaleSet"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_EventGridAndResourceGraph_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventGridAndResourceGraph to EventGridAndResourceGraph via AssignProperties_To_EventGridAndResourceGraph & AssignProperties_From_EventGridAndResourceGraph returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventGridAndResourceGraph, EventGridAndResourceGraphGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventGridAndResourceGraph tests if a specific instance of EventGridAndResourceGraph can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventGridAndResourceGraph(subject EventGridAndResourceGraph) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventGridAndResourceGraph
	err := copied.AssignProperties_To_EventGridAndResourceGraph(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventGridAndResourceGraph
	err = actual.AssignProperties_From_EventGridAndResourceGraph(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventGridAndResourceGraph_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridAndResourceGraph via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridAndResourceGraph, EventGridAndResourceGraphGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridAndResourceGraph runs a test to see if a specific instance of EventGridAndResourceGraph round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridAndResourceGraph(subject EventGridAndResourceGraph) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridAndResourceGraph
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridAndResourceGraph instances for property testing - lazily instantiated by
// EventGridAndResourceGraphGenerator()
var eventGridAndResourceGraphGenerator gopter.Gen

// EventGridAndResourceGraphGenerator returns a generator of EventGridAndResourceGraph instances for property testing.
func EventGridAndResourceGraphGenerator() gopter.Gen {
	if eventGridAndResourceGraphGenerator != nil {
		return eventGridAndResourceGraphGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridAndResourceGraph(generators)
	eventGridAndResourceGraphGenerator = gen.Struct(reflect.TypeOf(EventGridAndResourceGraph{}), generators)

	return eventGridAndResourceGraphGenerator
}

// AddIndependentPropertyGeneratorsForEventGridAndResourceGraph is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridAndResourceGraph(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
}

func Test_EventGridAndResourceGraph_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventGridAndResourceGraph_STATUS to EventGridAndResourceGraph_STATUS via AssignProperties_To_EventGridAndResourceGraph_STATUS & AssignProperties_From_EventGridAndResourceGraph_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventGridAndResourceGraph_STATUS, EventGridAndResourceGraph_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventGridAndResourceGraph_STATUS tests if a specific instance of EventGridAndResourceGraph_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventGridAndResourceGraph_STATUS(subject EventGridAndResourceGraph_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventGridAndResourceGraph_STATUS
	err := copied.AssignProperties_To_EventGridAndResourceGraph_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventGridAndResourceGraph_STATUS
	err = actual.AssignProperties_From_EventGridAndResourceGraph_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventGridAndResourceGraph_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridAndResourceGraph_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridAndResourceGraph_STATUS, EventGridAndResourceGraph_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridAndResourceGraph_STATUS runs a test to see if a specific instance of EventGridAndResourceGraph_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridAndResourceGraph_STATUS(subject EventGridAndResourceGraph_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridAndResourceGraph_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridAndResourceGraph_STATUS instances for property testing - lazily instantiated by
// EventGridAndResourceGraph_STATUSGenerator()
var eventGridAndResourceGraph_STATUSGenerator gopter.Gen

// EventGridAndResourceGraph_STATUSGenerator returns a generator of EventGridAndResourceGraph_STATUS instances for property testing.
func EventGridAndResourceGraph_STATUSGenerator() gopter.Gen {
	if eventGridAndResourceGraph_STATUSGenerator != nil {
		return eventGridAndResourceGraph_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridAndResourceGraph_STATUS(generators)
	eventGridAndResourceGraph_STATUSGenerator = gen.Struct(reflect.TypeOf(EventGridAndResourceGraph_STATUS{}), generators)

	return eventGridAndResourceGraph_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventGridAndResourceGraph_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridAndResourceGraph_STATUS(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
}

func Test_InstanceViewStatus_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InstanceViewStatus_STATUS to InstanceViewStatus_STATUS via AssignProperties_To_InstanceViewStatus_STATUS & AssignProperties_From_InstanceViewStatus_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForInstanceViewStatus_STATUS, InstanceViewStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInstanceViewStatus_STATUS tests if a specific instance of InstanceViewStatus_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForInstanceViewStatus_STATUS(subject InstanceViewStatus_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.InstanceViewStatus_STATUS
	err := copied.AssignProperties_To_InstanceViewStatus_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InstanceViewStatus_STATUS
	err = actual.AssignProperties_From_InstanceViewStatus_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InstanceViewStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatus_STATUS, InstanceViewStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatus_STATUS runs a test to see if a specific instance of InstanceViewStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatus_STATUS(subject InstanceViewStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_STATUS instances for property testing - lazily instantiated by
// InstanceViewStatus_STATUSGenerator()
var instanceViewStatus_STATUSGenerator gopter.Gen

// InstanceViewStatus_STATUSGenerator returns a generator of InstanceViewStatus_STATUS instances for property testing.
func InstanceViewStatus_STATUSGenerator() gopter.Gen {
	if instanceViewStatus_STATUSGenerator != nil {
		return instanceViewStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUS(generators)
	instanceViewStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_STATUS{}), generators)

	return instanceViewStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.OneConstOf(InstanceViewStatus_Level_STATUS_Error, InstanceViewStatus_Level_STATUS_Info, InstanceViewStatus_Level_STATUS_Warning))
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScheduledEventsAdditionalPublishingTargets_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScheduledEventsAdditionalPublishingTargets to ScheduledEventsAdditionalPublishingTargets via AssignProperties_To_ScheduledEventsAdditionalPublishingTargets & AssignProperties_From_ScheduledEventsAdditionalPublishingTargets returns original",
		prop.ForAll(RunPropertyAssignmentTestForScheduledEventsAdditionalPublishingTargets, ScheduledEventsAdditionalPublishingTargetsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScheduledEventsAdditionalPublishingTargets tests if a specific instance of ScheduledEventsAdditionalPublishingTargets can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScheduledEventsAdditionalPublishingTargets(subject ScheduledEventsAdditionalPublishingTargets) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScheduledEventsAdditionalPublishingTargets
	err := copied.AssignProperties_To_ScheduledEventsAdditionalPublishingTargets(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScheduledEventsAdditionalPublishingTargets
	err = actual.AssignProperties_From_ScheduledEventsAdditionalPublishingTargets(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScheduledEventsAdditionalPublishingTargets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsAdditionalPublishingTargets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets, ScheduledEventsAdditionalPublishingTargetsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets runs a test to see if a specific instance of ScheduledEventsAdditionalPublishingTargets round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets(subject ScheduledEventsAdditionalPublishingTargets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsAdditionalPublishingTargets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsAdditionalPublishingTargets instances for property testing - lazily instantiated by
// ScheduledEventsAdditionalPublishingTargetsGenerator()
var scheduledEventsAdditionalPublishingTargetsGenerator gopter.Gen

// ScheduledEventsAdditionalPublishingTargetsGenerator returns a generator of ScheduledEventsAdditionalPublishingTargets instances for property testing.
func ScheduledEventsAdditionalPublishingTargetsGenerator() gopter.Gen {
	if scheduledEventsAdditionalPublishingTargetsGenerator != nil {
		return scheduledEventsAdditionalPublishingTargetsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets(generators)
	scheduledEventsAdditionalPublishingTargetsGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsAdditionalPublishingTargets{}), generators)

	return scheduledEventsAdditionalPublishingTargetsGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets(gens map[string]gopter.Gen) {
	gens["EventGridAndResourceGraph"] = gen.PtrOf(EventGridAndResourceGraphGenerator())
}

func Test_ScheduledEventsAdditionalPublishingTargets_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScheduledEventsAdditionalPublishingTargets_STATUS to ScheduledEventsAdditionalPublishingTargets_STATUS via AssignProperties_To_ScheduledEventsAdditionalPublishingTargets_STATUS & AssignProperties_From_ScheduledEventsAdditionalPublishingTargets_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScheduledEventsAdditionalPublishingTargets_STATUS, ScheduledEventsAdditionalPublishingTargets_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScheduledEventsAdditionalPublishingTargets_STATUS tests if a specific instance of ScheduledEventsAdditionalPublishingTargets_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScheduledEventsAdditionalPublishingTargets_STATUS(subject ScheduledEventsAdditionalPublishingTargets_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScheduledEventsAdditionalPublishingTargets_STATUS
	err := copied.AssignProperties_To_ScheduledEventsAdditionalPublishingTargets_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScheduledEventsAdditionalPublishingTargets_STATUS
	err = actual.AssignProperties_From_ScheduledEventsAdditionalPublishingTargets_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScheduledEventsAdditionalPublishingTargets_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsAdditionalPublishingTargets_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets_STATUS, ScheduledEventsAdditionalPublishingTargets_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets_STATUS runs a test to see if a specific instance of ScheduledEventsAdditionalPublishingTargets_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets_STATUS(subject ScheduledEventsAdditionalPublishingTargets_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsAdditionalPublishingTargets_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsAdditionalPublishingTargets_STATUS instances for property testing - lazily instantiated
// by ScheduledEventsAdditionalPublishingTargets_STATUSGenerator()
var scheduledEventsAdditionalPublishingTargets_STATUSGenerator gopter.Gen

// ScheduledEventsAdditionalPublishingTargets_STATUSGenerator returns a generator of ScheduledEventsAdditionalPublishingTargets_STATUS instances for property testing.
func ScheduledEventsAdditionalPublishingTargets_STATUSGenerator() gopter.Gen {
	if scheduledEventsAdditionalPublishingTargets_STATUSGenerator != nil {
		return scheduledEventsAdditionalPublishingTargets_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets_STATUS(generators)
	scheduledEventsAdditionalPublishingTargets_STATUSGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsAdditionalPublishingTargets_STATUS{}), generators)

	return scheduledEventsAdditionalPublishingTargets_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets_STATUS(gens map[string]gopter.Gen) {
	gens["EventGridAndResourceGraph"] = gen.PtrOf(EventGridAndResourceGraph_STATUSGenerator())
}

func Test_ScheduledEventsPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScheduledEventsPolicy to ScheduledEventsPolicy via AssignProperties_To_ScheduledEventsPolicy & AssignProperties_From_ScheduledEventsPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForScheduledEventsPolicy, ScheduledEventsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScheduledEventsPolicy tests if a specific instance of ScheduledEventsPolicy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScheduledEventsPolicy(subject ScheduledEventsPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScheduledEventsPolicy
	err := copied.AssignProperties_To_ScheduledEventsPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScheduledEventsPolicy
	err = actual.AssignProperties_From_ScheduledEventsPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScheduledEventsPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsPolicy, ScheduledEventsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsPolicy runs a test to see if a specific instance of ScheduledEventsPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsPolicy(subject ScheduledEventsPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsPolicy instances for property testing - lazily instantiated by
// ScheduledEventsPolicyGenerator()
var scheduledEventsPolicyGenerator gopter.Gen

// ScheduledEventsPolicyGenerator returns a generator of ScheduledEventsPolicy instances for property testing.
func ScheduledEventsPolicyGenerator() gopter.Gen {
	if scheduledEventsPolicyGenerator != nil {
		return scheduledEventsPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsPolicy(generators)
	scheduledEventsPolicyGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsPolicy{}), generators)

	return scheduledEventsPolicyGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsPolicy(gens map[string]gopter.Gen) {
	gens["ScheduledEventsAdditionalPublishingTargets"] = gen.PtrOf(ScheduledEventsAdditionalPublishingTargetsGenerator())
	gens["UserInitiatedReboot"] = gen.PtrOf(UserInitiatedRebootGenerator())
	gens["UserInitiatedRedeploy"] = gen.PtrOf(UserInitiatedRedeployGenerator())
}

func Test_ScheduledEventsPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScheduledEventsPolicy_STATUS to ScheduledEventsPolicy_STATUS via AssignProperties_To_ScheduledEventsPolicy_STATUS & AssignProperties_From_ScheduledEventsPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScheduledEventsPolicy_STATUS, ScheduledEventsPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScheduledEventsPolicy_STATUS tests if a specific instance of ScheduledEventsPolicy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScheduledEventsPolicy_STATUS(subject ScheduledEventsPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScheduledEventsPolicy_STATUS
	err := copied.AssignProperties_To_ScheduledEventsPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScheduledEventsPolicy_STATUS
	err = actual.AssignProperties_From_ScheduledEventsPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScheduledEventsPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsPolicy_STATUS, ScheduledEventsPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsPolicy_STATUS runs a test to see if a specific instance of ScheduledEventsPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsPolicy_STATUS(subject ScheduledEventsPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsPolicy_STATUS instances for property testing - lazily instantiated by
// ScheduledEventsPolicy_STATUSGenerator()
var scheduledEventsPolicy_STATUSGenerator gopter.Gen

// ScheduledEventsPolicy_STATUSGenerator returns a generator of ScheduledEventsPolicy_STATUS instances for property testing.
func ScheduledEventsPolicy_STATUSGenerator() gopter.Gen {
	if scheduledEventsPolicy_STATUSGenerator != nil {
		return scheduledEventsPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsPolicy_STATUS(generators)
	scheduledEventsPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsPolicy_STATUS{}), generators)

	return scheduledEventsPolicy_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["ScheduledEventsAdditionalPublishingTargets"] = gen.PtrOf(ScheduledEventsAdditionalPublishingTargets_STATUSGenerator())
	gens["UserInitiatedReboot"] = gen.PtrOf(UserInitiatedReboot_STATUSGenerator())
	gens["UserInitiatedRedeploy"] = gen.PtrOf(UserInitiatedRedeploy_STATUSGenerator())
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignProperties_To_Sku & AssignProperties_From_Sku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Sku
	err := copied.AssignProperties_To_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignProperties_From_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_STATUS to Sku_STATUS via AssignProperties_To_Sku_STATUS & AssignProperties_From_Sku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_STATUS tests if a specific instance of Sku_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSku_STATUS(subject Sku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Sku_STATUS
	err := copied.AssignProperties_To_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_STATUS
	err = actual.AssignProperties_From_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SubResource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource to SubResource via AssignProperties_To_SubResource & AssignProperties_From_SubResource returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource tests if a specific instance of SubResource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubResource(subject SubResource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SubResource
	err := copied.AssignProperties_To_SubResource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource
	err = actual.AssignProperties_From_SubResource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource runs a test to see if a specific instance of SubResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource(subject SubResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource instances for property testing - lazily instantiated by SubResourceGenerator()
var subResourceGenerator gopter.Gen

// SubResourceGenerator returns a generator of SubResource instances for property testing.
func SubResourceGenerator() gopter.Gen {
	if subResourceGenerator != nil {
		return subResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResourceGenerator = gen.Struct(reflect.TypeOf(SubResource{}), generators)

	return subResourceGenerator
}

func Test_SubResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_STATUS to SubResource_STATUS via AssignProperties_To_SubResource_STATUS & AssignProperties_From_SubResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource_STATUS tests if a specific instance of SubResource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SubResource_STATUS
	err := copied.AssignProperties_To_SubResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_STATUS
	err = actual.AssignProperties_From_SubResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_STATUS runs a test to see if a specific instance of SubResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_STATUS instances for property testing - lazily instantiated by SubResource_STATUSGenerator()
var subResource_STATUSGenerator gopter.Gen

// SubResource_STATUSGenerator returns a generator of SubResource_STATUS instances for property testing.
func SubResource_STATUSGenerator() gopter.Gen {
	if subResource_STATUSGenerator != nil {
		return subResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_STATUS(generators)
	subResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SubResource_STATUS{}), generators)

	return subResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserInitiatedReboot_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserInitiatedReboot to UserInitiatedReboot via AssignProperties_To_UserInitiatedReboot & AssignProperties_From_UserInitiatedReboot returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserInitiatedReboot, UserInitiatedRebootGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserInitiatedReboot tests if a specific instance of UserInitiatedReboot can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserInitiatedReboot(subject UserInitiatedReboot) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserInitiatedReboot
	err := copied.AssignProperties_To_UserInitiatedReboot(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserInitiatedReboot
	err = actual.AssignProperties_From_UserInitiatedReboot(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserInitiatedReboot_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedReboot via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedReboot, UserInitiatedRebootGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedReboot runs a test to see if a specific instance of UserInitiatedReboot round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedReboot(subject UserInitiatedReboot) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedReboot
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedReboot instances for property testing - lazily instantiated by
// UserInitiatedRebootGenerator()
var userInitiatedRebootGenerator gopter.Gen

// UserInitiatedRebootGenerator returns a generator of UserInitiatedReboot instances for property testing.
func UserInitiatedRebootGenerator() gopter.Gen {
	if userInitiatedRebootGenerator != nil {
		return userInitiatedRebootGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedReboot(generators)
	userInitiatedRebootGenerator = gen.Struct(reflect.TypeOf(UserInitiatedReboot{}), generators)

	return userInitiatedRebootGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedReboot is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedReboot(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_UserInitiatedReboot_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserInitiatedReboot_STATUS to UserInitiatedReboot_STATUS via AssignProperties_To_UserInitiatedReboot_STATUS & AssignProperties_From_UserInitiatedReboot_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserInitiatedReboot_STATUS, UserInitiatedReboot_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserInitiatedReboot_STATUS tests if a specific instance of UserInitiatedReboot_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserInitiatedReboot_STATUS(subject UserInitiatedReboot_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserInitiatedReboot_STATUS
	err := copied.AssignProperties_To_UserInitiatedReboot_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserInitiatedReboot_STATUS
	err = actual.AssignProperties_From_UserInitiatedReboot_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserInitiatedReboot_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedReboot_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedReboot_STATUS, UserInitiatedReboot_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedReboot_STATUS runs a test to see if a specific instance of UserInitiatedReboot_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedReboot_STATUS(subject UserInitiatedReboot_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedReboot_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedReboot_STATUS instances for property testing - lazily instantiated by
// UserInitiatedReboot_STATUSGenerator()
var userInitiatedReboot_STATUSGenerator gopter.Gen

// UserInitiatedReboot_STATUSGenerator returns a generator of UserInitiatedReboot_STATUS instances for property testing.
func UserInitiatedReboot_STATUSGenerator() gopter.Gen {
	if userInitiatedReboot_STATUSGenerator != nil {
		return userInitiatedReboot_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedReboot_STATUS(generators)
	userInitiatedReboot_STATUSGenerator = gen.Struct(reflect.TypeOf(UserInitiatedReboot_STATUS{}), generators)

	return userInitiatedReboot_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedReboot_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedReboot_STATUS(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_UserInitiatedRedeploy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserInitiatedRedeploy to UserInitiatedRedeploy via AssignProperties_To_UserInitiatedRedeploy & AssignProperties_From_UserInitiatedRedeploy returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserInitiatedRedeploy, UserInitiatedRedeployGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserInitiatedRedeploy tests if a specific instance of UserInitiatedRedeploy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserInitiatedRedeploy(subject UserInitiatedRedeploy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserInitiatedRedeploy
	err := copied.AssignProperties_To_UserInitiatedRedeploy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserInitiatedRedeploy
	err = actual.AssignProperties_From_UserInitiatedRedeploy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserInitiatedRedeploy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedRedeploy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedRedeploy, UserInitiatedRedeployGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedRedeploy runs a test to see if a specific instance of UserInitiatedRedeploy round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedRedeploy(subject UserInitiatedRedeploy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedRedeploy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedRedeploy instances for property testing - lazily instantiated by
// UserInitiatedRedeployGenerator()
var userInitiatedRedeployGenerator gopter.Gen

// UserInitiatedRedeployGenerator returns a generator of UserInitiatedRedeploy instances for property testing.
func UserInitiatedRedeployGenerator() gopter.Gen {
	if userInitiatedRedeployGenerator != nil {
		return userInitiatedRedeployGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedRedeploy(generators)
	userInitiatedRedeployGenerator = gen.Struct(reflect.TypeOf(UserInitiatedRedeploy{}), generators)

	return userInitiatedRedeployGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedRedeploy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedRedeploy(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_UserInitiatedRedeploy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserInitiatedRedeploy_STATUS to UserInitiatedRedeploy_STATUS via AssignProperties_To_UserInitiatedRedeploy_STATUS & AssignProperties_From_UserInitiatedRedeploy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserInitiatedRedeploy_STATUS, UserInitiatedRedeploy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserInitiatedRedeploy_STATUS tests if a specific instance of UserInitiatedRedeploy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserInitiatedRedeploy_STATUS(subject UserInitiatedRedeploy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserInitiatedRedeploy_STATUS
	err := copied.AssignProperties_To_UserInitiatedRedeploy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserInitiatedRedeploy_STATUS
	err = actual.AssignProperties_From_UserInitiatedRedeploy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserInitiatedRedeploy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedRedeploy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedRedeploy_STATUS, UserInitiatedRedeploy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedRedeploy_STATUS runs a test to see if a specific instance of UserInitiatedRedeploy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedRedeploy_STATUS(subject UserInitiatedRedeploy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedRedeploy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedRedeploy_STATUS instances for property testing - lazily instantiated by
// UserInitiatedRedeploy_STATUSGenerator()
var userInitiatedRedeploy_STATUSGenerator gopter.Gen

// UserInitiatedRedeploy_STATUSGenerator returns a generator of UserInitiatedRedeploy_STATUS instances for property testing.
func UserInitiatedRedeploy_STATUSGenerator() gopter.Gen {
	if userInitiatedRedeploy_STATUSGenerator != nil {
		return userInitiatedRedeploy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedRedeploy_STATUS(generators)
	userInitiatedRedeploy_STATUSGenerator = gen.Struct(reflect.TypeOf(UserInitiatedRedeploy_STATUS{}), generators)

	return userInitiatedRedeploy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedRedeploy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedRedeploy_STATUS(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_VirtualMachineScaleSetMigrationInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualMachineScaleSetMigrationInfo_STATUS to VirtualMachineScaleSetMigrationInfo_STATUS via AssignProperties_To_VirtualMachineScaleSetMigrationInfo_STATUS & AssignProperties_From_VirtualMachineScaleSetMigrationInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualMachineScaleSetMigrationInfo_STATUS, VirtualMachineScaleSetMigrationInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualMachineScaleSetMigrationInfo_STATUS tests if a specific instance of VirtualMachineScaleSetMigrationInfo_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualMachineScaleSetMigrationInfo_STATUS(subject VirtualMachineScaleSetMigrationInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VirtualMachineScaleSetMigrationInfo_STATUS
	err := copied.AssignProperties_To_VirtualMachineScaleSetMigrationInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualMachineScaleSetMigrationInfo_STATUS
	err = actual.AssignProperties_From_VirtualMachineScaleSetMigrationInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualMachineScaleSetMigrationInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetMigrationInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetMigrationInfo_STATUS, VirtualMachineScaleSetMigrationInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetMigrationInfo_STATUS runs a test to see if a specific instance of VirtualMachineScaleSetMigrationInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetMigrationInfo_STATUS(subject VirtualMachineScaleSetMigrationInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetMigrationInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetMigrationInfo_STATUS instances for property testing - lazily instantiated by
// VirtualMachineScaleSetMigrationInfo_STATUSGenerator()
var virtualMachineScaleSetMigrationInfo_STATUSGenerator gopter.Gen

// VirtualMachineScaleSetMigrationInfo_STATUSGenerator returns a generator of VirtualMachineScaleSetMigrationInfo_STATUS instances for property testing.
func VirtualMachineScaleSetMigrationInfo_STATUSGenerator() gopter.Gen {
	if virtualMachineScaleSetMigrationInfo_STATUSGenerator != nil {
		return virtualMachineScaleSetMigrationInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetMigrationInfo_STATUS(generators)
	virtualMachineScaleSetMigrationInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetMigrationInfo_STATUS{}), generators)

	return virtualMachineScaleSetMigrationInfo_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetMigrationInfo_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetMigrationInfo_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultVirtualMachineScaleSetInfo"] = gen.PtrOf(DefaultVirtualMachineScaleSetInfo_STATUSGenerator())
	gens["MigrateToVirtualMachineScaleSet"] = gen.PtrOf(SubResource_STATUSGenerator())
}
