// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AvailabilitySetProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySetProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySetProperties, AvailabilitySetPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySetProperties runs a test to see if a specific instance of AvailabilitySetProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySetProperties(subject AvailabilitySetProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySetProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySetProperties instances for property testing - lazily instantiated by
// AvailabilitySetPropertiesGenerator()
var availabilitySetPropertiesGenerator gopter.Gen

// AvailabilitySetPropertiesGenerator returns a generator of AvailabilitySetProperties instances for property testing.
// We first initialize availabilitySetPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailabilitySetPropertiesGenerator() gopter.Gen {
	if availabilitySetPropertiesGenerator != nil {
		return availabilitySetPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySetProperties(generators)
	availabilitySetPropertiesGenerator = gen.Struct(reflect.TypeOf(AvailabilitySetProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySetProperties(generators)
	AddRelatedPropertyGeneratorsForAvailabilitySetProperties(generators)
	availabilitySetPropertiesGenerator = gen.Struct(reflect.TypeOf(AvailabilitySetProperties{}), generators)

	return availabilitySetPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAvailabilitySetProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailabilitySetProperties(gens map[string]gopter.Gen) {
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomainCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAvailabilitySetProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailabilitySetProperties(gens map[string]gopter.Gen) {
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceGenerator())
	gens["ScheduledEventsPolicy"] = gen.PtrOf(ScheduledEventsPolicyGenerator())
}

func Test_AvailabilitySet_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySet_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySet_Spec, AvailabilitySet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySet_Spec runs a test to see if a specific instance of AvailabilitySet_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySet_Spec(subject AvailabilitySet_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySet_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySet_Spec instances for property testing - lazily instantiated by
// AvailabilitySet_SpecGenerator()
var availabilitySet_SpecGenerator gopter.Gen

// AvailabilitySet_SpecGenerator returns a generator of AvailabilitySet_Spec instances for property testing.
// We first initialize availabilitySet_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailabilitySet_SpecGenerator() gopter.Gen {
	if availabilitySet_SpecGenerator != nil {
		return availabilitySet_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(generators)
	availabilitySet_SpecGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(generators)
	AddRelatedPropertyGeneratorsForAvailabilitySet_Spec(generators)
	availabilitySet_SpecGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_Spec{}), generators)

	return availabilitySet_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAvailabilitySet_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAvailabilitySet_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailabilitySet_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AvailabilitySetPropertiesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_EventGridAndResourceGraph_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridAndResourceGraph via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridAndResourceGraph, EventGridAndResourceGraphGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridAndResourceGraph runs a test to see if a specific instance of EventGridAndResourceGraph round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridAndResourceGraph(subject EventGridAndResourceGraph) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridAndResourceGraph
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridAndResourceGraph instances for property testing - lazily instantiated by
// EventGridAndResourceGraphGenerator()
var eventGridAndResourceGraphGenerator gopter.Gen

// EventGridAndResourceGraphGenerator returns a generator of EventGridAndResourceGraph instances for property testing.
func EventGridAndResourceGraphGenerator() gopter.Gen {
	if eventGridAndResourceGraphGenerator != nil {
		return eventGridAndResourceGraphGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridAndResourceGraph(generators)
	eventGridAndResourceGraphGenerator = gen.Struct(reflect.TypeOf(EventGridAndResourceGraph{}), generators)

	return eventGridAndResourceGraphGenerator
}

// AddIndependentPropertyGeneratorsForEventGridAndResourceGraph is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridAndResourceGraph(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
}

func Test_ScheduledEventsAdditionalPublishingTargets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsAdditionalPublishingTargets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets, ScheduledEventsAdditionalPublishingTargetsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets runs a test to see if a specific instance of ScheduledEventsAdditionalPublishingTargets round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets(subject ScheduledEventsAdditionalPublishingTargets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsAdditionalPublishingTargets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsAdditionalPublishingTargets instances for property testing - lazily instantiated by
// ScheduledEventsAdditionalPublishingTargetsGenerator()
var scheduledEventsAdditionalPublishingTargetsGenerator gopter.Gen

// ScheduledEventsAdditionalPublishingTargetsGenerator returns a generator of ScheduledEventsAdditionalPublishingTargets instances for property testing.
func ScheduledEventsAdditionalPublishingTargetsGenerator() gopter.Gen {
	if scheduledEventsAdditionalPublishingTargetsGenerator != nil {
		return scheduledEventsAdditionalPublishingTargetsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets(generators)
	scheduledEventsAdditionalPublishingTargetsGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsAdditionalPublishingTargets{}), generators)

	return scheduledEventsAdditionalPublishingTargetsGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets(gens map[string]gopter.Gen) {
	gens["EventGridAndResourceGraph"] = gen.PtrOf(EventGridAndResourceGraphGenerator())
}

func Test_ScheduledEventsPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsPolicy, ScheduledEventsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsPolicy runs a test to see if a specific instance of ScheduledEventsPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsPolicy(subject ScheduledEventsPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsPolicy instances for property testing - lazily instantiated by
// ScheduledEventsPolicyGenerator()
var scheduledEventsPolicyGenerator gopter.Gen

// ScheduledEventsPolicyGenerator returns a generator of ScheduledEventsPolicy instances for property testing.
func ScheduledEventsPolicyGenerator() gopter.Gen {
	if scheduledEventsPolicyGenerator != nil {
		return scheduledEventsPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsPolicy(generators)
	scheduledEventsPolicyGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsPolicy{}), generators)

	return scheduledEventsPolicyGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsPolicy(gens map[string]gopter.Gen) {
	gens["ScheduledEventsAdditionalPublishingTargets"] = gen.PtrOf(ScheduledEventsAdditionalPublishingTargetsGenerator())
	gens["UserInitiatedReboot"] = gen.PtrOf(UserInitiatedRebootGenerator())
	gens["UserInitiatedRedeploy"] = gen.PtrOf(UserInitiatedRedeployGenerator())
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SubResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource runs a test to see if a specific instance of SubResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource(subject SubResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource instances for property testing - lazily instantiated by SubResourceGenerator()
var subResourceGenerator gopter.Gen

// SubResourceGenerator returns a generator of SubResource instances for property testing.
func SubResourceGenerator() gopter.Gen {
	if subResourceGenerator != nil {
		return subResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource(generators)
	subResourceGenerator = gen.Struct(reflect.TypeOf(SubResource{}), generators)

	return subResourceGenerator
}

// AddIndependentPropertyGeneratorsForSubResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserInitiatedReboot_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedReboot via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedReboot, UserInitiatedRebootGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedReboot runs a test to see if a specific instance of UserInitiatedReboot round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedReboot(subject UserInitiatedReboot) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedReboot
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedReboot instances for property testing - lazily instantiated by
// UserInitiatedRebootGenerator()
var userInitiatedRebootGenerator gopter.Gen

// UserInitiatedRebootGenerator returns a generator of UserInitiatedReboot instances for property testing.
func UserInitiatedRebootGenerator() gopter.Gen {
	if userInitiatedRebootGenerator != nil {
		return userInitiatedRebootGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedReboot(generators)
	userInitiatedRebootGenerator = gen.Struct(reflect.TypeOf(UserInitiatedReboot{}), generators)

	return userInitiatedRebootGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedReboot is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedReboot(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_UserInitiatedRedeploy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedRedeploy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedRedeploy, UserInitiatedRedeployGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedRedeploy runs a test to see if a specific instance of UserInitiatedRedeploy round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedRedeploy(subject UserInitiatedRedeploy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedRedeploy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedRedeploy instances for property testing - lazily instantiated by
// UserInitiatedRedeployGenerator()
var userInitiatedRedeployGenerator gopter.Gen

// UserInitiatedRedeployGenerator returns a generator of UserInitiatedRedeploy instances for property testing.
func UserInitiatedRedeployGenerator() gopter.Gen {
	if userInitiatedRedeployGenerator != nil {
		return userInitiatedRedeployGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedRedeploy(generators)
	userInitiatedRedeployGenerator = gen.Struct(reflect.TypeOf(UserInitiatedRedeploy{}), generators)

	return userInitiatedRedeployGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedRedeploy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedRedeploy(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}
