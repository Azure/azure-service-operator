// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AvailabilitySet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySet, AvailabilitySetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySet runs a test to see if a specific instance of AvailabilitySet round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySet(subject AvailabilitySet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySet instances for property testing - lazily instantiated by AvailabilitySetGenerator()
var availabilitySetGenerator gopter.Gen

// AvailabilitySetGenerator returns a generator of AvailabilitySet instances for property testing.
func AvailabilitySetGenerator() gopter.Gen {
	if availabilitySetGenerator != nil {
		return availabilitySetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAvailabilitySet(generators)
	availabilitySetGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet{}), generators)

	return availabilitySetGenerator
}

// AddRelatedPropertyGeneratorsForAvailabilitySet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailabilitySet(gens map[string]gopter.Gen) {
	gens["Spec"] = AvailabilitySet_SpecGenerator()
	gens["Status"] = AvailabilitySet_STATUSGenerator()
}

func Test_AvailabilitySetOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySetOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySetOperatorSpec, AvailabilitySetOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySetOperatorSpec runs a test to see if a specific instance of AvailabilitySetOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySetOperatorSpec(subject AvailabilitySetOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySetOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySetOperatorSpec instances for property testing - lazily instantiated by
// AvailabilitySetOperatorSpecGenerator()
var availabilitySetOperatorSpecGenerator gopter.Gen

// AvailabilitySetOperatorSpecGenerator returns a generator of AvailabilitySetOperatorSpec instances for property testing.
func AvailabilitySetOperatorSpecGenerator() gopter.Gen {
	if availabilitySetOperatorSpecGenerator != nil {
		return availabilitySetOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	availabilitySetOperatorSpecGenerator = gen.Struct(reflect.TypeOf(AvailabilitySetOperatorSpec{}), generators)

	return availabilitySetOperatorSpecGenerator
}

func Test_AvailabilitySet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySet_STATUS, AvailabilitySet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySet_STATUS runs a test to see if a specific instance of AvailabilitySet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySet_STATUS(subject AvailabilitySet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySet_STATUS instances for property testing - lazily instantiated by
// AvailabilitySet_STATUSGenerator()
var availabilitySet_STATUSGenerator gopter.Gen

// AvailabilitySet_STATUSGenerator returns a generator of AvailabilitySet_STATUS instances for property testing.
// We first initialize availabilitySet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailabilitySet_STATUSGenerator() gopter.Gen {
	if availabilitySet_STATUSGenerator != nil {
		return availabilitySet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_STATUS(generators)
	availabilitySet_STATUSGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_STATUS(generators)
	AddRelatedPropertyGeneratorsForAvailabilitySet_STATUS(generators)
	availabilitySet_STATUSGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_STATUS{}), generators)

	return availabilitySet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAvailabilitySet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailabilitySet_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomainCount"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAvailabilitySet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailabilitySet_STATUS(gens map[string]gopter.Gen) {
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["ScheduledEventsPolicy"] = gen.PtrOf(ScheduledEventsPolicy_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatus_STATUSGenerator())
	gens["VirtualMachineScaleSetMigrationInfo"] = gen.PtrOf(VirtualMachineScaleSetMigrationInfo_STATUSGenerator())
	gens["VirtualMachines"] = gen.SliceOf(SubResource_STATUSGenerator())
}

func Test_AvailabilitySet_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailabilitySet_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailabilitySet_Spec, AvailabilitySet_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailabilitySet_Spec runs a test to see if a specific instance of AvailabilitySet_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailabilitySet_Spec(subject AvailabilitySet_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailabilitySet_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailabilitySet_Spec instances for property testing - lazily instantiated by
// AvailabilitySet_SpecGenerator()
var availabilitySet_SpecGenerator gopter.Gen

// AvailabilitySet_SpecGenerator returns a generator of AvailabilitySet_Spec instances for property testing.
// We first initialize availabilitySet_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailabilitySet_SpecGenerator() gopter.Gen {
	if availabilitySet_SpecGenerator != nil {
		return availabilitySet_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(generators)
	availabilitySet_SpecGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(generators)
	AddRelatedPropertyGeneratorsForAvailabilitySet_Spec(generators)
	availabilitySet_SpecGenerator = gen.Struct(reflect.TypeOf(AvailabilitySet_Spec{}), generators)

	return availabilitySet_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAvailabilitySet_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailabilitySet_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["PlatformFaultDomainCount"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomainCount"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAvailabilitySet_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailabilitySet_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(AvailabilitySetOperatorSpecGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceGenerator())
	gens["ScheduledEventsPolicy"] = gen.PtrOf(ScheduledEventsPolicyGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_DefaultVirtualMachineScaleSetInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DefaultVirtualMachineScaleSetInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDefaultVirtualMachineScaleSetInfo_STATUS, DefaultVirtualMachineScaleSetInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDefaultVirtualMachineScaleSetInfo_STATUS runs a test to see if a specific instance of DefaultVirtualMachineScaleSetInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDefaultVirtualMachineScaleSetInfo_STATUS(subject DefaultVirtualMachineScaleSetInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DefaultVirtualMachineScaleSetInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DefaultVirtualMachineScaleSetInfo_STATUS instances for property testing - lazily instantiated by
// DefaultVirtualMachineScaleSetInfo_STATUSGenerator()
var defaultVirtualMachineScaleSetInfo_STATUSGenerator gopter.Gen

// DefaultVirtualMachineScaleSetInfo_STATUSGenerator returns a generator of DefaultVirtualMachineScaleSetInfo_STATUS instances for property testing.
// We first initialize defaultVirtualMachineScaleSetInfo_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DefaultVirtualMachineScaleSetInfo_STATUSGenerator() gopter.Gen {
	if defaultVirtualMachineScaleSetInfo_STATUSGenerator != nil {
		return defaultVirtualMachineScaleSetInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(generators)
	defaultVirtualMachineScaleSetInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(DefaultVirtualMachineScaleSetInfo_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(generators)
	AddRelatedPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(generators)
	defaultVirtualMachineScaleSetInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(DefaultVirtualMachineScaleSetInfo_STATUS{}), generators)

	return defaultVirtualMachineScaleSetInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(gens map[string]gopter.Gen) {
	gens["ConstrainedMaximumCapacity"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDefaultVirtualMachineScaleSetInfo_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultVirtualMachineScaleSet"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_EventGridAndResourceGraph_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridAndResourceGraph via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridAndResourceGraph, EventGridAndResourceGraphGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridAndResourceGraph runs a test to see if a specific instance of EventGridAndResourceGraph round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridAndResourceGraph(subject EventGridAndResourceGraph) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridAndResourceGraph
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridAndResourceGraph instances for property testing - lazily instantiated by
// EventGridAndResourceGraphGenerator()
var eventGridAndResourceGraphGenerator gopter.Gen

// EventGridAndResourceGraphGenerator returns a generator of EventGridAndResourceGraph instances for property testing.
func EventGridAndResourceGraphGenerator() gopter.Gen {
	if eventGridAndResourceGraphGenerator != nil {
		return eventGridAndResourceGraphGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridAndResourceGraph(generators)
	eventGridAndResourceGraphGenerator = gen.Struct(reflect.TypeOf(EventGridAndResourceGraph{}), generators)

	return eventGridAndResourceGraphGenerator
}

// AddIndependentPropertyGeneratorsForEventGridAndResourceGraph is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridAndResourceGraph(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
}

func Test_EventGridAndResourceGraph_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridAndResourceGraph_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridAndResourceGraph_STATUS, EventGridAndResourceGraph_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridAndResourceGraph_STATUS runs a test to see if a specific instance of EventGridAndResourceGraph_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridAndResourceGraph_STATUS(subject EventGridAndResourceGraph_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridAndResourceGraph_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridAndResourceGraph_STATUS instances for property testing - lazily instantiated by
// EventGridAndResourceGraph_STATUSGenerator()
var eventGridAndResourceGraph_STATUSGenerator gopter.Gen

// EventGridAndResourceGraph_STATUSGenerator returns a generator of EventGridAndResourceGraph_STATUS instances for property testing.
func EventGridAndResourceGraph_STATUSGenerator() gopter.Gen {
	if eventGridAndResourceGraph_STATUSGenerator != nil {
		return eventGridAndResourceGraph_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridAndResourceGraph_STATUS(generators)
	eventGridAndResourceGraph_STATUSGenerator = gen.Struct(reflect.TypeOf(EventGridAndResourceGraph_STATUS{}), generators)

	return eventGridAndResourceGraph_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventGridAndResourceGraph_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridAndResourceGraph_STATUS(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
}

func Test_InstanceViewStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatus_STATUS, InstanceViewStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatus_STATUS runs a test to see if a specific instance of InstanceViewStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatus_STATUS(subject InstanceViewStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_STATUS instances for property testing - lazily instantiated by
// InstanceViewStatus_STATUSGenerator()
var instanceViewStatus_STATUSGenerator gopter.Gen

// InstanceViewStatus_STATUSGenerator returns a generator of InstanceViewStatus_STATUS instances for property testing.
func InstanceViewStatus_STATUSGenerator() gopter.Gen {
	if instanceViewStatus_STATUSGenerator != nil {
		return instanceViewStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUS(generators)
	instanceViewStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_STATUS{}), generators)

	return instanceViewStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScheduledEventsAdditionalPublishingTargets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsAdditionalPublishingTargets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets, ScheduledEventsAdditionalPublishingTargetsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets runs a test to see if a specific instance of ScheduledEventsAdditionalPublishingTargets round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets(subject ScheduledEventsAdditionalPublishingTargets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsAdditionalPublishingTargets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsAdditionalPublishingTargets instances for property testing - lazily instantiated by
// ScheduledEventsAdditionalPublishingTargetsGenerator()
var scheduledEventsAdditionalPublishingTargetsGenerator gopter.Gen

// ScheduledEventsAdditionalPublishingTargetsGenerator returns a generator of ScheduledEventsAdditionalPublishingTargets instances for property testing.
func ScheduledEventsAdditionalPublishingTargetsGenerator() gopter.Gen {
	if scheduledEventsAdditionalPublishingTargetsGenerator != nil {
		return scheduledEventsAdditionalPublishingTargetsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets(generators)
	scheduledEventsAdditionalPublishingTargetsGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsAdditionalPublishingTargets{}), generators)

	return scheduledEventsAdditionalPublishingTargetsGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets(gens map[string]gopter.Gen) {
	gens["EventGridAndResourceGraph"] = gen.PtrOf(EventGridAndResourceGraphGenerator())
}

func Test_ScheduledEventsAdditionalPublishingTargets_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsAdditionalPublishingTargets_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets_STATUS, ScheduledEventsAdditionalPublishingTargets_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets_STATUS runs a test to see if a specific instance of ScheduledEventsAdditionalPublishingTargets_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsAdditionalPublishingTargets_STATUS(subject ScheduledEventsAdditionalPublishingTargets_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsAdditionalPublishingTargets_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsAdditionalPublishingTargets_STATUS instances for property testing - lazily instantiated
// by ScheduledEventsAdditionalPublishingTargets_STATUSGenerator()
var scheduledEventsAdditionalPublishingTargets_STATUSGenerator gopter.Gen

// ScheduledEventsAdditionalPublishingTargets_STATUSGenerator returns a generator of ScheduledEventsAdditionalPublishingTargets_STATUS instances for property testing.
func ScheduledEventsAdditionalPublishingTargets_STATUSGenerator() gopter.Gen {
	if scheduledEventsAdditionalPublishingTargets_STATUSGenerator != nil {
		return scheduledEventsAdditionalPublishingTargets_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets_STATUS(generators)
	scheduledEventsAdditionalPublishingTargets_STATUSGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsAdditionalPublishingTargets_STATUS{}), generators)

	return scheduledEventsAdditionalPublishingTargets_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsAdditionalPublishingTargets_STATUS(gens map[string]gopter.Gen) {
	gens["EventGridAndResourceGraph"] = gen.PtrOf(EventGridAndResourceGraph_STATUSGenerator())
}

func Test_ScheduledEventsPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsPolicy, ScheduledEventsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsPolicy runs a test to see if a specific instance of ScheduledEventsPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsPolicy(subject ScheduledEventsPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsPolicy instances for property testing - lazily instantiated by
// ScheduledEventsPolicyGenerator()
var scheduledEventsPolicyGenerator gopter.Gen

// ScheduledEventsPolicyGenerator returns a generator of ScheduledEventsPolicy instances for property testing.
func ScheduledEventsPolicyGenerator() gopter.Gen {
	if scheduledEventsPolicyGenerator != nil {
		return scheduledEventsPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsPolicy(generators)
	scheduledEventsPolicyGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsPolicy{}), generators)

	return scheduledEventsPolicyGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsPolicy(gens map[string]gopter.Gen) {
	gens["ScheduledEventsAdditionalPublishingTargets"] = gen.PtrOf(ScheduledEventsAdditionalPublishingTargetsGenerator())
	gens["UserInitiatedReboot"] = gen.PtrOf(UserInitiatedRebootGenerator())
	gens["UserInitiatedRedeploy"] = gen.PtrOf(UserInitiatedRedeployGenerator())
}

func Test_ScheduledEventsPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsPolicy_STATUS, ScheduledEventsPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsPolicy_STATUS runs a test to see if a specific instance of ScheduledEventsPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsPolicy_STATUS(subject ScheduledEventsPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsPolicy_STATUS instances for property testing - lazily instantiated by
// ScheduledEventsPolicy_STATUSGenerator()
var scheduledEventsPolicy_STATUSGenerator gopter.Gen

// ScheduledEventsPolicy_STATUSGenerator returns a generator of ScheduledEventsPolicy_STATUS instances for property testing.
func ScheduledEventsPolicy_STATUSGenerator() gopter.Gen {
	if scheduledEventsPolicy_STATUSGenerator != nil {
		return scheduledEventsPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsPolicy_STATUS(generators)
	scheduledEventsPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsPolicy_STATUS{}), generators)

	return scheduledEventsPolicy_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["ScheduledEventsAdditionalPublishingTargets"] = gen.PtrOf(ScheduledEventsAdditionalPublishingTargets_STATUSGenerator())
	gens["UserInitiatedReboot"] = gen.PtrOf(UserInitiatedReboot_STATUSGenerator())
	gens["UserInitiatedRedeploy"] = gen.PtrOf(UserInitiatedRedeploy_STATUSGenerator())
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SubResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource runs a test to see if a specific instance of SubResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource(subject SubResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource instances for property testing - lazily instantiated by SubResourceGenerator()
var subResourceGenerator gopter.Gen

// SubResourceGenerator returns a generator of SubResource instances for property testing.
func SubResourceGenerator() gopter.Gen {
	if subResourceGenerator != nil {
		return subResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResourceGenerator = gen.Struct(reflect.TypeOf(SubResource{}), generators)

	return subResourceGenerator
}

func Test_SubResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_STATUS runs a test to see if a specific instance of SubResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_STATUS instances for property testing - lazily instantiated by SubResource_STATUSGenerator()
var subResource_STATUSGenerator gopter.Gen

// SubResource_STATUSGenerator returns a generator of SubResource_STATUS instances for property testing.
func SubResource_STATUSGenerator() gopter.Gen {
	if subResource_STATUSGenerator != nil {
		return subResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_STATUS(generators)
	subResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SubResource_STATUS{}), generators)

	return subResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserInitiatedReboot_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedReboot via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedReboot, UserInitiatedRebootGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedReboot runs a test to see if a specific instance of UserInitiatedReboot round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedReboot(subject UserInitiatedReboot) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedReboot
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedReboot instances for property testing - lazily instantiated by
// UserInitiatedRebootGenerator()
var userInitiatedRebootGenerator gopter.Gen

// UserInitiatedRebootGenerator returns a generator of UserInitiatedReboot instances for property testing.
func UserInitiatedRebootGenerator() gopter.Gen {
	if userInitiatedRebootGenerator != nil {
		return userInitiatedRebootGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedReboot(generators)
	userInitiatedRebootGenerator = gen.Struct(reflect.TypeOf(UserInitiatedReboot{}), generators)

	return userInitiatedRebootGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedReboot is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedReboot(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_UserInitiatedReboot_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedReboot_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedReboot_STATUS, UserInitiatedReboot_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedReboot_STATUS runs a test to see if a specific instance of UserInitiatedReboot_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedReboot_STATUS(subject UserInitiatedReboot_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedReboot_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedReboot_STATUS instances for property testing - lazily instantiated by
// UserInitiatedReboot_STATUSGenerator()
var userInitiatedReboot_STATUSGenerator gopter.Gen

// UserInitiatedReboot_STATUSGenerator returns a generator of UserInitiatedReboot_STATUS instances for property testing.
func UserInitiatedReboot_STATUSGenerator() gopter.Gen {
	if userInitiatedReboot_STATUSGenerator != nil {
		return userInitiatedReboot_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedReboot_STATUS(generators)
	userInitiatedReboot_STATUSGenerator = gen.Struct(reflect.TypeOf(UserInitiatedReboot_STATUS{}), generators)

	return userInitiatedReboot_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedReboot_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedReboot_STATUS(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_UserInitiatedRedeploy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedRedeploy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedRedeploy, UserInitiatedRedeployGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedRedeploy runs a test to see if a specific instance of UserInitiatedRedeploy round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedRedeploy(subject UserInitiatedRedeploy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedRedeploy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedRedeploy instances for property testing - lazily instantiated by
// UserInitiatedRedeployGenerator()
var userInitiatedRedeployGenerator gopter.Gen

// UserInitiatedRedeployGenerator returns a generator of UserInitiatedRedeploy instances for property testing.
func UserInitiatedRedeployGenerator() gopter.Gen {
	if userInitiatedRedeployGenerator != nil {
		return userInitiatedRedeployGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedRedeploy(generators)
	userInitiatedRedeployGenerator = gen.Struct(reflect.TypeOf(UserInitiatedRedeploy{}), generators)

	return userInitiatedRedeployGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedRedeploy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedRedeploy(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_UserInitiatedRedeploy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserInitiatedRedeploy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserInitiatedRedeploy_STATUS, UserInitiatedRedeploy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserInitiatedRedeploy_STATUS runs a test to see if a specific instance of UserInitiatedRedeploy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserInitiatedRedeploy_STATUS(subject UserInitiatedRedeploy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserInitiatedRedeploy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserInitiatedRedeploy_STATUS instances for property testing - lazily instantiated by
// UserInitiatedRedeploy_STATUSGenerator()
var userInitiatedRedeploy_STATUSGenerator gopter.Gen

// UserInitiatedRedeploy_STATUSGenerator returns a generator of UserInitiatedRedeploy_STATUS instances for property testing.
func UserInitiatedRedeploy_STATUSGenerator() gopter.Gen {
	if userInitiatedRedeploy_STATUSGenerator != nil {
		return userInitiatedRedeploy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserInitiatedRedeploy_STATUS(generators)
	userInitiatedRedeploy_STATUSGenerator = gen.Struct(reflect.TypeOf(UserInitiatedRedeploy_STATUS{}), generators)

	return userInitiatedRedeploy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserInitiatedRedeploy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserInitiatedRedeploy_STATUS(gens map[string]gopter.Gen) {
	gens["AutomaticallyApprove"] = gen.PtrOf(gen.Bool())
}

func Test_VirtualMachineScaleSetMigrationInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineScaleSetMigrationInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineScaleSetMigrationInfo_STATUS, VirtualMachineScaleSetMigrationInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineScaleSetMigrationInfo_STATUS runs a test to see if a specific instance of VirtualMachineScaleSetMigrationInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineScaleSetMigrationInfo_STATUS(subject VirtualMachineScaleSetMigrationInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineScaleSetMigrationInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineScaleSetMigrationInfo_STATUS instances for property testing - lazily instantiated by
// VirtualMachineScaleSetMigrationInfo_STATUSGenerator()
var virtualMachineScaleSetMigrationInfo_STATUSGenerator gopter.Gen

// VirtualMachineScaleSetMigrationInfo_STATUSGenerator returns a generator of VirtualMachineScaleSetMigrationInfo_STATUS instances for property testing.
func VirtualMachineScaleSetMigrationInfo_STATUSGenerator() gopter.Gen {
	if virtualMachineScaleSetMigrationInfo_STATUSGenerator != nil {
		return virtualMachineScaleSetMigrationInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineScaleSetMigrationInfo_STATUS(generators)
	virtualMachineScaleSetMigrationInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualMachineScaleSetMigrationInfo_STATUS{}), generators)

	return virtualMachineScaleSetMigrationInfo_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineScaleSetMigrationInfo_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineScaleSetMigrationInfo_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultVirtualMachineScaleSetInfo"] = gen.PtrOf(DefaultVirtualMachineScaleSetInfo_STATUSGenerator())
	gens["MigrateToVirtualMachineScaleSet"] = gen.PtrOf(SubResource_STATUSGenerator())
}
