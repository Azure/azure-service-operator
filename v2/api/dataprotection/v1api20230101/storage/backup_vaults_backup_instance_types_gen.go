// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"fmt"
	v20231201s "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20231201/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20230101.BackupVaultsBackupInstance
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}
type BackupVaultsBackupInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackupVaults_BackupInstance_Spec   `json:"spec,omitempty"`
	Status            BackupVaults_BackupInstance_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &BackupVaultsBackupInstance{}

// GetConditions returns the conditions of the resource
func (instance *BackupVaultsBackupInstance) GetConditions() conditions.Conditions {
	return instance.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (instance *BackupVaultsBackupInstance) SetConditions(conditions conditions.Conditions) {
	instance.Status.Conditions = conditions
}

var _ conversion.Convertible = &BackupVaultsBackupInstance{}

// ConvertFrom populates our BackupVaultsBackupInstance from the provided hub BackupVaultsBackupInstance
func (instance *BackupVaultsBackupInstance) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20231201s.BackupVaultsBackupInstance)
	if !ok {
		return fmt.Errorf("expected dataprotection/v1api20231201/storage/BackupVaultsBackupInstance but received %T instead", hub)
	}

	return instance.AssignProperties_From_BackupVaultsBackupInstance(source)
}

// ConvertTo populates the provided hub BackupVaultsBackupInstance from our BackupVaultsBackupInstance
func (instance *BackupVaultsBackupInstance) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20231201s.BackupVaultsBackupInstance)
	if !ok {
		return fmt.Errorf("expected dataprotection/v1api20231201/storage/BackupVaultsBackupInstance but received %T instead", hub)
	}

	return instance.AssignProperties_To_BackupVaultsBackupInstance(destination)
}

var _ genruntime.KubernetesResource = &BackupVaultsBackupInstance{}

// AzureName returns the Azure name of the resource
func (instance *BackupVaultsBackupInstance) AzureName() string {
	return instance.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-01-01"
func (instance BackupVaultsBackupInstance) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (instance *BackupVaultsBackupInstance) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (instance *BackupVaultsBackupInstance) GetSpec() genruntime.ConvertibleSpec {
	return &instance.Spec
}

// GetStatus returns the status of this resource
func (instance *BackupVaultsBackupInstance) GetStatus() genruntime.ConvertibleStatus {
	return &instance.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (instance *BackupVaultsBackupInstance) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DataProtection/backupVaults/backupInstances"
func (instance *BackupVaultsBackupInstance) GetType() string {
	return "Microsoft.DataProtection/backupVaults/backupInstances"
}

// NewEmptyStatus returns a new empty (blank) status
func (instance *BackupVaultsBackupInstance) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &BackupVaults_BackupInstance_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (instance *BackupVaultsBackupInstance) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(instance.Spec)
	return instance.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (instance *BackupVaultsBackupInstance) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*BackupVaults_BackupInstance_STATUS); ok {
		instance.Status = *st
		return nil
	}

	// Convert status to required version
	var st BackupVaults_BackupInstance_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	instance.Status = st
	return nil
}

// AssignProperties_From_BackupVaultsBackupInstance populates our BackupVaultsBackupInstance from the provided source BackupVaultsBackupInstance
func (instance *BackupVaultsBackupInstance) AssignProperties_From_BackupVaultsBackupInstance(source *v20231201s.BackupVaultsBackupInstance) error {

	// ObjectMeta
	instance.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec BackupVaults_BackupInstance_Spec
	err := spec.AssignProperties_From_BackupVaults_BackupInstance_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVaults_BackupInstance_Spec() to populate field Spec")
	}
	instance.Spec = spec

	// Status
	var status BackupVaults_BackupInstance_STATUS
	err = status.AssignProperties_From_BackupVaults_BackupInstance_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVaults_BackupInstance_STATUS() to populate field Status")
	}
	instance.Status = status

	// Invoke the augmentConversionForBackupVaultsBackupInstance interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupVaultsBackupInstance); ok {
		err := augmentedInstance.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupInstance populates the provided destination BackupVaultsBackupInstance from our BackupVaultsBackupInstance
func (instance *BackupVaultsBackupInstance) AssignProperties_To_BackupVaultsBackupInstance(destination *v20231201s.BackupVaultsBackupInstance) error {

	// ObjectMeta
	destination.ObjectMeta = *instance.ObjectMeta.DeepCopy()

	// Spec
	var spec v20231201s.BackupVaults_BackupInstance_Spec
	err := instance.Spec.AssignProperties_To_BackupVaults_BackupInstance_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVaults_BackupInstance_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20231201s.BackupVaults_BackupInstance_STATUS
	err = instance.Status.AssignProperties_To_BackupVaults_BackupInstance_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVaults_BackupInstance_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForBackupVaultsBackupInstance interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupVaultsBackupInstance); ok {
		err := augmentedInstance.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (instance *BackupVaultsBackupInstance) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: instance.Spec.OriginalVersion,
		Kind:    "BackupVaultsBackupInstance",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20230101.BackupVaultsBackupInstance
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}
type BackupVaultsBackupInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackupVaultsBackupInstance `json:"items"`
}

type augmentConversionForBackupVaultsBackupInstance interface {
	AssignPropertiesFrom(src *v20231201s.BackupVaultsBackupInstance) error
	AssignPropertiesTo(dst *v20231201s.BackupVaultsBackupInstance) error
}

// Storage version of v1api20230101.BackupVaults_BackupInstance_Spec
type BackupVaults_BackupInstance_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName       string `json:"azureName,omitempty"`
	OriginalVersion string `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a dataprotection.azure.com/BackupVault resource
	Owner       *genruntime.KnownResourceReference `group:"dataprotection.azure.com" json:"owner,omitempty" kind:"BackupVault"`
	Properties  *BackupInstance                    `json:"properties,omitempty"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Tags        map[string]string                  `json:"tags,omitempty"`
}

var _ genruntime.ConvertibleSpec = &BackupVaults_BackupInstance_Spec{}

// ConvertSpecFrom populates our BackupVaults_BackupInstance_Spec from the provided source
func (instance *BackupVaults_BackupInstance_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20231201s.BackupVaults_BackupInstance_Spec)
	if ok {
		// Populate our instance from source
		return instance.AssignProperties_From_BackupVaults_BackupInstance_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20231201s.BackupVaults_BackupInstance_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = instance.AssignProperties_From_BackupVaults_BackupInstance_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our BackupVaults_BackupInstance_Spec
func (instance *BackupVaults_BackupInstance_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20231201s.BackupVaults_BackupInstance_Spec)
	if ok {
		// Populate destination from our instance
		return instance.AssignProperties_To_BackupVaults_BackupInstance_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20231201s.BackupVaults_BackupInstance_Spec{}
	err := instance.AssignProperties_To_BackupVaults_BackupInstance_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_BackupVaults_BackupInstance_Spec populates our BackupVaults_BackupInstance_Spec from the provided source BackupVaults_BackupInstance_Spec
func (instance *BackupVaults_BackupInstance_Spec) AssignProperties_From_BackupVaults_BackupInstance_Spec(source *v20231201s.BackupVaults_BackupInstance_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	instance.AzureName = source.AzureName

	// OriginalVersion
	instance.OriginalVersion = source.OriginalVersion

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		instance.Owner = &owner
	} else {
		instance.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property BackupInstance
		err := property.AssignProperties_From_BackupInstance(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupInstance() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// Tags
	instance.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		instance.PropertyBag = propertyBag
	} else {
		instance.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupVaults_BackupInstance_Spec interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupVaults_BackupInstance_Spec); ok {
		err := augmentedInstance.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaults_BackupInstance_Spec populates the provided destination BackupVaults_BackupInstance_Spec from our BackupVaults_BackupInstance_Spec
func (instance *BackupVaults_BackupInstance_Spec) AssignProperties_To_BackupVaults_BackupInstance_Spec(destination *v20231201s.BackupVaults_BackupInstance_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(instance.PropertyBag)

	// AzureName
	destination.AzureName = instance.AzureName

	// OriginalVersion
	destination.OriginalVersion = instance.OriginalVersion

	// Owner
	if instance.Owner != nil {
		owner := instance.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if instance.Properties != nil {
		var property v20231201s.BackupInstance
		err := instance.Properties.AssignProperties_To_BackupInstance(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupInstance() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(instance.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupVaults_BackupInstance_Spec interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupVaults_BackupInstance_Spec); ok {
		err := augmentedInstance.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.BackupVaults_BackupInstance_STATUS
type BackupVaults_BackupInstance_STATUS struct {
	Conditions  []conditions.Condition `json:"conditions,omitempty"`
	Id          *string                `json:"id,omitempty"`
	Name        *string                `json:"name,omitempty"`
	Properties  *BackupInstance_STATUS `json:"properties,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SystemData  *SystemData_STATUS     `json:"systemData,omitempty"`
	Tags        map[string]string      `json:"tags,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &BackupVaults_BackupInstance_STATUS{}

// ConvertStatusFrom populates our BackupVaults_BackupInstance_STATUS from the provided source
func (instance *BackupVaults_BackupInstance_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20231201s.BackupVaults_BackupInstance_STATUS)
	if ok {
		// Populate our instance from source
		return instance.AssignProperties_From_BackupVaults_BackupInstance_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20231201s.BackupVaults_BackupInstance_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = instance.AssignProperties_From_BackupVaults_BackupInstance_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our BackupVaults_BackupInstance_STATUS
func (instance *BackupVaults_BackupInstance_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20231201s.BackupVaults_BackupInstance_STATUS)
	if ok {
		// Populate destination from our instance
		return instance.AssignProperties_To_BackupVaults_BackupInstance_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20231201s.BackupVaults_BackupInstance_STATUS{}
	err := instance.AssignProperties_To_BackupVaults_BackupInstance_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_BackupVaults_BackupInstance_STATUS populates our BackupVaults_BackupInstance_STATUS from the provided source BackupVaults_BackupInstance_STATUS
func (instance *BackupVaults_BackupInstance_STATUS) AssignProperties_From_BackupVaults_BackupInstance_STATUS(source *v20231201s.BackupVaults_BackupInstance_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Conditions
	instance.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	instance.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	instance.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property BackupInstance_STATUS
		err := property.AssignProperties_From_BackupInstance_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupInstance_STATUS() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		instance.SystemData = &systemDatum
	} else {
		instance.SystemData = nil
	}

	// Tags
	instance.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	instance.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		instance.PropertyBag = propertyBag
	} else {
		instance.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupVaults_BackupInstance_STATUS interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupVaults_BackupInstance_STATUS); ok {
		err := augmentedInstance.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaults_BackupInstance_STATUS populates the provided destination BackupVaults_BackupInstance_STATUS from our BackupVaults_BackupInstance_STATUS
func (instance *BackupVaults_BackupInstance_STATUS) AssignProperties_To_BackupVaults_BackupInstance_STATUS(destination *v20231201s.BackupVaults_BackupInstance_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(instance.PropertyBag)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(instance.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(instance.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(instance.Name)

	// Properties
	if instance.Properties != nil {
		var property v20231201s.BackupInstance_STATUS
		err := instance.Properties.AssignProperties_To_BackupInstance_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupInstance_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if instance.SystemData != nil {
		var systemDatum v20231201s.SystemData_STATUS
		err := instance.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(instance.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(instance.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupVaults_BackupInstance_STATUS interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupVaults_BackupInstance_STATUS); ok {
		err := augmentedInstance.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForBackupVaults_BackupInstance_Spec interface {
	AssignPropertiesFrom(src *v20231201s.BackupVaults_BackupInstance_Spec) error
	AssignPropertiesTo(dst *v20231201s.BackupVaults_BackupInstance_Spec) error
}

type augmentConversionForBackupVaults_BackupInstance_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.BackupVaults_BackupInstance_STATUS) error
	AssignPropertiesTo(dst *v20231201s.BackupVaults_BackupInstance_STATUS) error
}

// Storage version of v1api20230101.BackupInstance
// Backup Instance
type BackupInstance struct {
	DataSourceInfo            *Datasource            `json:"dataSourceInfo,omitempty"`
	DataSourceSetInfo         *DatasourceSet         `json:"dataSourceSetInfo,omitempty"`
	DatasourceAuthCredentials *AuthCredentials       `json:"datasourceAuthCredentials,omitempty"`
	FriendlyName              *string                `json:"friendlyName,omitempty"`
	ObjectType                *string                `json:"objectType,omitempty"`
	PolicyInfo                *PolicyInfo            `json:"policyInfo,omitempty"`
	PropertyBag               genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ValidationType            *string                `json:"validationType,omitempty"`
}

// AssignProperties_From_BackupInstance populates our BackupInstance from the provided source BackupInstance
func (instance *BackupInstance) AssignProperties_From_BackupInstance(source *v20231201s.BackupInstance) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataSourceInfo
	if source.DataSourceInfo != nil {
		var dataSourceInfo Datasource
		err := dataSourceInfo.AssignProperties_From_Datasource(source.DataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Datasource() to populate field DataSourceInfo")
		}
		instance.DataSourceInfo = &dataSourceInfo
	} else {
		instance.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if source.DataSourceSetInfo != nil {
		var dataSourceSetInfo DatasourceSet
		err := dataSourceSetInfo.AssignProperties_From_DatasourceSet(source.DataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatasourceSet() to populate field DataSourceSetInfo")
		}
		instance.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		instance.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if source.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential AuthCredentials
		err := datasourceAuthCredential.AssignProperties_From_AuthCredentials(source.DatasourceAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AuthCredentials() to populate field DatasourceAuthCredentials")
		}
		instance.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		instance.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	instance.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// IdentityDetails
	if source.IdentityDetails != nil {
		propertyBag.Add("IdentityDetails", *source.IdentityDetails)
	} else {
		propertyBag.Remove("IdentityDetails")
	}

	// ObjectType
	instance.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// PolicyInfo
	if source.PolicyInfo != nil {
		var policyInfo PolicyInfo
		err := policyInfo.AssignProperties_From_PolicyInfo(source.PolicyInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicyInfo() to populate field PolicyInfo")
		}
		instance.PolicyInfo = &policyInfo
	} else {
		instance.PolicyInfo = nil
	}

	// ValidationType
	instance.ValidationType = genruntime.ClonePointerToString(source.ValidationType)

	// Update the property bag
	if len(propertyBag) > 0 {
		instance.PropertyBag = propertyBag
	} else {
		instance.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupInstance interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupInstance); ok {
		err := augmentedInstance.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackupInstance populates the provided destination BackupInstance from our BackupInstance
func (instance *BackupInstance) AssignProperties_To_BackupInstance(destination *v20231201s.BackupInstance) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(instance.PropertyBag)

	// DataSourceInfo
	if instance.DataSourceInfo != nil {
		var dataSourceInfo v20231201s.Datasource
		err := instance.DataSourceInfo.AssignProperties_To_Datasource(&dataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Datasource() to populate field DataSourceInfo")
		}
		destination.DataSourceInfo = &dataSourceInfo
	} else {
		destination.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if instance.DataSourceSetInfo != nil {
		var dataSourceSetInfo v20231201s.DatasourceSet
		err := instance.DataSourceSetInfo.AssignProperties_To_DatasourceSet(&dataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatasourceSet() to populate field DataSourceSetInfo")
		}
		destination.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		destination.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if instance.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential v20231201s.AuthCredentials
		err := instance.DatasourceAuthCredentials.AssignProperties_To_AuthCredentials(&datasourceAuthCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AuthCredentials() to populate field DatasourceAuthCredentials")
		}
		destination.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		destination.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	destination.FriendlyName = genruntime.ClonePointerToString(instance.FriendlyName)

	// IdentityDetails
	if propertyBag.Contains("IdentityDetails") {
		var identityDetail v20231201s.IdentityDetails
		err := propertyBag.Pull("IdentityDetails", &identityDetail)
		if err != nil {
			return errors.Wrap(err, "pulling 'IdentityDetails' from propertyBag")
		}

		destination.IdentityDetails = &identityDetail
	} else {
		destination.IdentityDetails = nil
	}

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(instance.ObjectType)

	// PolicyInfo
	if instance.PolicyInfo != nil {
		var policyInfo v20231201s.PolicyInfo
		err := instance.PolicyInfo.AssignProperties_To_PolicyInfo(&policyInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicyInfo() to populate field PolicyInfo")
		}
		destination.PolicyInfo = &policyInfo
	} else {
		destination.PolicyInfo = nil
	}

	// ValidationType
	destination.ValidationType = genruntime.ClonePointerToString(instance.ValidationType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupInstance interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupInstance); ok {
		err := augmentedInstance.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.BackupInstance_STATUS
// Backup Instance
type BackupInstance_STATUS struct {
	CurrentProtectionState    *string                         `json:"currentProtectionState,omitempty"`
	DataSourceInfo            *Datasource_STATUS              `json:"dataSourceInfo,omitempty"`
	DataSourceSetInfo         *DatasourceSet_STATUS           `json:"dataSourceSetInfo,omitempty"`
	DatasourceAuthCredentials *AuthCredentials_STATUS         `json:"datasourceAuthCredentials,omitempty"`
	FriendlyName              *string                         `json:"friendlyName,omitempty"`
	ObjectType                *string                         `json:"objectType,omitempty"`
	PolicyInfo                *PolicyInfo_STATUS              `json:"policyInfo,omitempty"`
	PropertyBag               genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	ProtectionErrorDetails    *UserFacingError_STATUS         `json:"protectionErrorDetails,omitempty"`
	ProtectionStatus          *ProtectionStatusDetails_STATUS `json:"protectionStatus,omitempty"`
	ProvisioningState         *string                         `json:"provisioningState,omitempty"`
	ValidationType            *string                         `json:"validationType,omitempty"`
}

// AssignProperties_From_BackupInstance_STATUS populates our BackupInstance_STATUS from the provided source BackupInstance_STATUS
func (instance *BackupInstance_STATUS) AssignProperties_From_BackupInstance_STATUS(source *v20231201s.BackupInstance_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CurrentProtectionState
	instance.CurrentProtectionState = genruntime.ClonePointerToString(source.CurrentProtectionState)

	// DataSourceInfo
	if source.DataSourceInfo != nil {
		var dataSourceInfo Datasource_STATUS
		err := dataSourceInfo.AssignProperties_From_Datasource_STATUS(source.DataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Datasource_STATUS() to populate field DataSourceInfo")
		}
		instance.DataSourceInfo = &dataSourceInfo
	} else {
		instance.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if source.DataSourceSetInfo != nil {
		var dataSourceSetInfo DatasourceSet_STATUS
		err := dataSourceSetInfo.AssignProperties_From_DatasourceSet_STATUS(source.DataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatasourceSet_STATUS() to populate field DataSourceSetInfo")
		}
		instance.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		instance.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if source.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential AuthCredentials_STATUS
		err := datasourceAuthCredential.AssignProperties_From_AuthCredentials_STATUS(source.DatasourceAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AuthCredentials_STATUS() to populate field DatasourceAuthCredentials")
		}
		instance.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		instance.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	instance.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// IdentityDetails
	if source.IdentityDetails != nil {
		propertyBag.Add("IdentityDetails", *source.IdentityDetails)
	} else {
		propertyBag.Remove("IdentityDetails")
	}

	// ObjectType
	instance.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// PolicyInfo
	if source.PolicyInfo != nil {
		var policyInfo PolicyInfo_STATUS
		err := policyInfo.AssignProperties_From_PolicyInfo_STATUS(source.PolicyInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicyInfo_STATUS() to populate field PolicyInfo")
		}
		instance.PolicyInfo = &policyInfo
	} else {
		instance.PolicyInfo = nil
	}

	// ProtectionErrorDetails
	if source.ProtectionErrorDetails != nil {
		var protectionErrorDetail UserFacingError_STATUS
		err := protectionErrorDetail.AssignProperties_From_UserFacingError_STATUS(source.ProtectionErrorDetails)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserFacingError_STATUS() to populate field ProtectionErrorDetails")
		}
		instance.ProtectionErrorDetails = &protectionErrorDetail
	} else {
		instance.ProtectionErrorDetails = nil
	}

	// ProtectionStatus
	if source.ProtectionStatus != nil {
		var protectionStatus ProtectionStatusDetails_STATUS
		err := protectionStatus.AssignProperties_From_ProtectionStatusDetails_STATUS(source.ProtectionStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ProtectionStatusDetails_STATUS() to populate field ProtectionStatus")
		}
		instance.ProtectionStatus = &protectionStatus
	} else {
		instance.ProtectionStatus = nil
	}

	// ProvisioningState
	instance.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ValidationType
	instance.ValidationType = genruntime.ClonePointerToString(source.ValidationType)

	// Update the property bag
	if len(propertyBag) > 0 {
		instance.PropertyBag = propertyBag
	} else {
		instance.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupInstance_STATUS interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupInstance_STATUS); ok {
		err := augmentedInstance.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackupInstance_STATUS populates the provided destination BackupInstance_STATUS from our BackupInstance_STATUS
func (instance *BackupInstance_STATUS) AssignProperties_To_BackupInstance_STATUS(destination *v20231201s.BackupInstance_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(instance.PropertyBag)

	// CurrentProtectionState
	destination.CurrentProtectionState = genruntime.ClonePointerToString(instance.CurrentProtectionState)

	// DataSourceInfo
	if instance.DataSourceInfo != nil {
		var dataSourceInfo v20231201s.Datasource_STATUS
		err := instance.DataSourceInfo.AssignProperties_To_Datasource_STATUS(&dataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Datasource_STATUS() to populate field DataSourceInfo")
		}
		destination.DataSourceInfo = &dataSourceInfo
	} else {
		destination.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if instance.DataSourceSetInfo != nil {
		var dataSourceSetInfo v20231201s.DatasourceSet_STATUS
		err := instance.DataSourceSetInfo.AssignProperties_To_DatasourceSet_STATUS(&dataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatasourceSet_STATUS() to populate field DataSourceSetInfo")
		}
		destination.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		destination.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if instance.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential v20231201s.AuthCredentials_STATUS
		err := instance.DatasourceAuthCredentials.AssignProperties_To_AuthCredentials_STATUS(&datasourceAuthCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AuthCredentials_STATUS() to populate field DatasourceAuthCredentials")
		}
		destination.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		destination.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	destination.FriendlyName = genruntime.ClonePointerToString(instance.FriendlyName)

	// IdentityDetails
	if propertyBag.Contains("IdentityDetails") {
		var identityDetail v20231201s.IdentityDetails_STATUS
		err := propertyBag.Pull("IdentityDetails", &identityDetail)
		if err != nil {
			return errors.Wrap(err, "pulling 'IdentityDetails' from propertyBag")
		}

		destination.IdentityDetails = &identityDetail
	} else {
		destination.IdentityDetails = nil
	}

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(instance.ObjectType)

	// PolicyInfo
	if instance.PolicyInfo != nil {
		var policyInfo v20231201s.PolicyInfo_STATUS
		err := instance.PolicyInfo.AssignProperties_To_PolicyInfo_STATUS(&policyInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicyInfo_STATUS() to populate field PolicyInfo")
		}
		destination.PolicyInfo = &policyInfo
	} else {
		destination.PolicyInfo = nil
	}

	// ProtectionErrorDetails
	if instance.ProtectionErrorDetails != nil {
		var protectionErrorDetail v20231201s.UserFacingError_STATUS
		err := instance.ProtectionErrorDetails.AssignProperties_To_UserFacingError_STATUS(&protectionErrorDetail)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserFacingError_STATUS() to populate field ProtectionErrorDetails")
		}
		destination.ProtectionErrorDetails = &protectionErrorDetail
	} else {
		destination.ProtectionErrorDetails = nil
	}

	// ProtectionStatus
	if instance.ProtectionStatus != nil {
		var protectionStatus v20231201s.ProtectionStatusDetails_STATUS
		err := instance.ProtectionStatus.AssignProperties_To_ProtectionStatusDetails_STATUS(&protectionStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ProtectionStatusDetails_STATUS() to populate field ProtectionStatus")
		}
		destination.ProtectionStatus = &protectionStatus
	} else {
		destination.ProtectionStatus = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(instance.ProvisioningState)

	// ValidationType
	destination.ValidationType = genruntime.ClonePointerToString(instance.ValidationType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupInstance_STATUS interface (if implemented) to customize the conversion
	var instanceAsAny any = instance
	if augmentedInstance, ok := instanceAsAny.(augmentConversionForBackupInstance_STATUS); ok {
		err := augmentedInstance.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForBackupInstance interface {
	AssignPropertiesFrom(src *v20231201s.BackupInstance) error
	AssignPropertiesTo(dst *v20231201s.BackupInstance) error
}

type augmentConversionForBackupInstance_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.BackupInstance_STATUS) error
	AssignPropertiesTo(dst *v20231201s.BackupInstance_STATUS) error
}

// Storage version of v1api20230101.AuthCredentials
type AuthCredentials struct {
	PropertyBag                     genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
	SecretStoreBasedAuthCredentials *SecretStoreBasedAuthCredentials `json:"secretStoreBasedAuthCredentials,omitempty"`
}

// AssignProperties_From_AuthCredentials populates our AuthCredentials from the provided source AuthCredentials
func (credentials *AuthCredentials) AssignProperties_From_AuthCredentials(source *v20231201s.AuthCredentials) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretStoreBasedAuthCredentials
	if source.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential SecretStoreBasedAuthCredentials
		err := secretStoreBasedAuthCredential.AssignProperties_From_SecretStoreBasedAuthCredentials(source.SecretStoreBasedAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecretStoreBasedAuthCredentials() to populate field SecretStoreBasedAuthCredentials")
		}
		credentials.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		credentials.SecretStoreBasedAuthCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		credentials.PropertyBag = propertyBag
	} else {
		credentials.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthCredentials interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForAuthCredentials); ok {
		err := augmentedCredentials.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AuthCredentials populates the provided destination AuthCredentials from our AuthCredentials
func (credentials *AuthCredentials) AssignProperties_To_AuthCredentials(destination *v20231201s.AuthCredentials) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(credentials.PropertyBag)

	// SecretStoreBasedAuthCredentials
	if credentials.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential v20231201s.SecretStoreBasedAuthCredentials
		err := credentials.SecretStoreBasedAuthCredentials.AssignProperties_To_SecretStoreBasedAuthCredentials(&secretStoreBasedAuthCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecretStoreBasedAuthCredentials() to populate field SecretStoreBasedAuthCredentials")
		}
		destination.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		destination.SecretStoreBasedAuthCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthCredentials interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForAuthCredentials); ok {
		err := augmentedCredentials.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.AuthCredentials_STATUS
type AuthCredentials_STATUS struct {
	PropertyBag                     genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
	SecretStoreBasedAuthCredentials *SecretStoreBasedAuthCredentials_STATUS `json:"secretStoreBasedAuthCredentials,omitempty"`
}

// AssignProperties_From_AuthCredentials_STATUS populates our AuthCredentials_STATUS from the provided source AuthCredentials_STATUS
func (credentials *AuthCredentials_STATUS) AssignProperties_From_AuthCredentials_STATUS(source *v20231201s.AuthCredentials_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretStoreBasedAuthCredentials
	if source.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential SecretStoreBasedAuthCredentials_STATUS
		err := secretStoreBasedAuthCredential.AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS(source.SecretStoreBasedAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS() to populate field SecretStoreBasedAuthCredentials")
		}
		credentials.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		credentials.SecretStoreBasedAuthCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		credentials.PropertyBag = propertyBag
	} else {
		credentials.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthCredentials_STATUS interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForAuthCredentials_STATUS); ok {
		err := augmentedCredentials.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AuthCredentials_STATUS populates the provided destination AuthCredentials_STATUS from our AuthCredentials_STATUS
func (credentials *AuthCredentials_STATUS) AssignProperties_To_AuthCredentials_STATUS(destination *v20231201s.AuthCredentials_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(credentials.PropertyBag)

	// SecretStoreBasedAuthCredentials
	if credentials.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential v20231201s.SecretStoreBasedAuthCredentials_STATUS
		err := credentials.SecretStoreBasedAuthCredentials.AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS(&secretStoreBasedAuthCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS() to populate field SecretStoreBasedAuthCredentials")
		}
		destination.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		destination.SecretStoreBasedAuthCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthCredentials_STATUS interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForAuthCredentials_STATUS); ok {
		err := augmentedCredentials.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.Datasource
// Datasource to be backed up
type Datasource struct {
	DatasourceType   *string                `json:"datasourceType,omitempty"`
	ObjectType       *string                `json:"objectType,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceLocation *string                `json:"resourceLocation,omitempty"`
	ResourceName     *string                `json:"resourceName,omitempty"`

	// +kubebuilder:validation:Required
	// ResourceReference: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will
	// be the ID created by backup service via Fabric/Vault.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceID" json:"resourceReference,omitempty"`
	ResourceType      *string                       `json:"resourceType,omitempty"`
	ResourceUri       *string                       `json:"resourceUri,omitempty"`
}

// AssignProperties_From_Datasource populates our Datasource from the provided source Datasource
func (datasource *Datasource) AssignProperties_From_Datasource(source *v20231201s.Datasource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DatasourceType
	datasource.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasource.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceLocation
	datasource.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasource.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		propertyBag.Add("ResourceProperties", *source.ResourceProperties)
	} else {
		propertyBag.Remove("ResourceProperties")
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		datasource.ResourceReference = &resourceReference
	} else {
		datasource.ResourceReference = nil
	}

	// ResourceType
	datasource.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasource.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		datasource.PropertyBag = propertyBag
	} else {
		datasource.PropertyBag = nil
	}

	// Invoke the augmentConversionForDatasource interface (if implemented) to customize the conversion
	var datasourceAsAny any = datasource
	if augmentedDatasource, ok := datasourceAsAny.(augmentConversionForDatasource); ok {
		err := augmentedDatasource.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Datasource populates the provided destination Datasource from our Datasource
func (datasource *Datasource) AssignProperties_To_Datasource(destination *v20231201s.Datasource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(datasource.PropertyBag)

	// DatasourceType
	destination.DatasourceType = genruntime.ClonePointerToString(datasource.DatasourceType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(datasource.ObjectType)

	// ResourceLocation
	destination.ResourceLocation = genruntime.ClonePointerToString(datasource.ResourceLocation)

	// ResourceName
	destination.ResourceName = genruntime.ClonePointerToString(datasource.ResourceName)

	// ResourceProperties
	if propertyBag.Contains("ResourceProperties") {
		var resourceProperty v20231201s.BaseResourceProperties
		err := propertyBag.Pull("ResourceProperties", &resourceProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'ResourceProperties' from propertyBag")
		}

		destination.ResourceProperties = &resourceProperty
	} else {
		destination.ResourceProperties = nil
	}

	// ResourceReference
	if datasource.ResourceReference != nil {
		resourceReference := datasource.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// ResourceType
	destination.ResourceType = genruntime.ClonePointerToString(datasource.ResourceType)

	// ResourceUri
	destination.ResourceUri = genruntime.ClonePointerToString(datasource.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDatasource interface (if implemented) to customize the conversion
	var datasourceAsAny any = datasource
	if augmentedDatasource, ok := datasourceAsAny.(augmentConversionForDatasource); ok {
		err := augmentedDatasource.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.Datasource_STATUS
// Datasource to be backed up
type Datasource_STATUS struct {
	DatasourceType   *string                `json:"datasourceType,omitempty"`
	ObjectType       *string                `json:"objectType,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceID       *string                `json:"resourceID,omitempty"`
	ResourceLocation *string                `json:"resourceLocation,omitempty"`
	ResourceName     *string                `json:"resourceName,omitempty"`
	ResourceType     *string                `json:"resourceType,omitempty"`
	ResourceUri      *string                `json:"resourceUri,omitempty"`
}

// AssignProperties_From_Datasource_STATUS populates our Datasource_STATUS from the provided source Datasource_STATUS
func (datasource *Datasource_STATUS) AssignProperties_From_Datasource_STATUS(source *v20231201s.Datasource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DatasourceType
	datasource.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasource.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceID
	datasource.ResourceID = genruntime.ClonePointerToString(source.ResourceID)

	// ResourceLocation
	datasource.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasource.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		propertyBag.Add("ResourceProperties", *source.ResourceProperties)
	} else {
		propertyBag.Remove("ResourceProperties")
	}

	// ResourceType
	datasource.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasource.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		datasource.PropertyBag = propertyBag
	} else {
		datasource.PropertyBag = nil
	}

	// Invoke the augmentConversionForDatasource_STATUS interface (if implemented) to customize the conversion
	var datasourceAsAny any = datasource
	if augmentedDatasource, ok := datasourceAsAny.(augmentConversionForDatasource_STATUS); ok {
		err := augmentedDatasource.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Datasource_STATUS populates the provided destination Datasource_STATUS from our Datasource_STATUS
func (datasource *Datasource_STATUS) AssignProperties_To_Datasource_STATUS(destination *v20231201s.Datasource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(datasource.PropertyBag)

	// DatasourceType
	destination.DatasourceType = genruntime.ClonePointerToString(datasource.DatasourceType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(datasource.ObjectType)

	// ResourceID
	destination.ResourceID = genruntime.ClonePointerToString(datasource.ResourceID)

	// ResourceLocation
	destination.ResourceLocation = genruntime.ClonePointerToString(datasource.ResourceLocation)

	// ResourceName
	destination.ResourceName = genruntime.ClonePointerToString(datasource.ResourceName)

	// ResourceProperties
	if propertyBag.Contains("ResourceProperties") {
		var resourceProperty v20231201s.BaseResourceProperties_STATUS
		err := propertyBag.Pull("ResourceProperties", &resourceProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'ResourceProperties' from propertyBag")
		}

		destination.ResourceProperties = &resourceProperty
	} else {
		destination.ResourceProperties = nil
	}

	// ResourceType
	destination.ResourceType = genruntime.ClonePointerToString(datasource.ResourceType)

	// ResourceUri
	destination.ResourceUri = genruntime.ClonePointerToString(datasource.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDatasource_STATUS interface (if implemented) to customize the conversion
	var datasourceAsAny any = datasource
	if augmentedDatasource, ok := datasourceAsAny.(augmentConversionForDatasource_STATUS); ok {
		err := augmentedDatasource.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.DatasourceSet
// DatasourceSet details of datasource to be backed up
type DatasourceSet struct {
	DatasourceType   *string                `json:"datasourceType,omitempty"`
	ObjectType       *string                `json:"objectType,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceLocation *string                `json:"resourceLocation,omitempty"`
	ResourceName     *string                `json:"resourceName,omitempty"`

	// +kubebuilder:validation:Required
	// ResourceReference: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will
	// be the ID created by backup service via Fabric/Vault.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceID" json:"resourceReference,omitempty"`
	ResourceType      *string                       `json:"resourceType,omitempty"`
	ResourceUri       *string                       `json:"resourceUri,omitempty"`
}

// AssignProperties_From_DatasourceSet populates our DatasourceSet from the provided source DatasourceSet
func (datasourceSet *DatasourceSet) AssignProperties_From_DatasourceSet(source *v20231201s.DatasourceSet) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DatasourceType
	datasourceSet.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasourceSet.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceLocation
	datasourceSet.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasourceSet.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		propertyBag.Add("ResourceProperties", *source.ResourceProperties)
	} else {
		propertyBag.Remove("ResourceProperties")
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		datasourceSet.ResourceReference = &resourceReference
	} else {
		datasourceSet.ResourceReference = nil
	}

	// ResourceType
	datasourceSet.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasourceSet.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		datasourceSet.PropertyBag = propertyBag
	} else {
		datasourceSet.PropertyBag = nil
	}

	// Invoke the augmentConversionForDatasourceSet interface (if implemented) to customize the conversion
	var datasourceSetAsAny any = datasourceSet
	if augmentedDatasourceSet, ok := datasourceSetAsAny.(augmentConversionForDatasourceSet); ok {
		err := augmentedDatasourceSet.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DatasourceSet populates the provided destination DatasourceSet from our DatasourceSet
func (datasourceSet *DatasourceSet) AssignProperties_To_DatasourceSet(destination *v20231201s.DatasourceSet) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(datasourceSet.PropertyBag)

	// DatasourceType
	destination.DatasourceType = genruntime.ClonePointerToString(datasourceSet.DatasourceType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(datasourceSet.ObjectType)

	// ResourceLocation
	destination.ResourceLocation = genruntime.ClonePointerToString(datasourceSet.ResourceLocation)

	// ResourceName
	destination.ResourceName = genruntime.ClonePointerToString(datasourceSet.ResourceName)

	// ResourceProperties
	if propertyBag.Contains("ResourceProperties") {
		var resourceProperty v20231201s.BaseResourceProperties
		err := propertyBag.Pull("ResourceProperties", &resourceProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'ResourceProperties' from propertyBag")
		}

		destination.ResourceProperties = &resourceProperty
	} else {
		destination.ResourceProperties = nil
	}

	// ResourceReference
	if datasourceSet.ResourceReference != nil {
		resourceReference := datasourceSet.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// ResourceType
	destination.ResourceType = genruntime.ClonePointerToString(datasourceSet.ResourceType)

	// ResourceUri
	destination.ResourceUri = genruntime.ClonePointerToString(datasourceSet.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDatasourceSet interface (if implemented) to customize the conversion
	var datasourceSetAsAny any = datasourceSet
	if augmentedDatasourceSet, ok := datasourceSetAsAny.(augmentConversionForDatasourceSet); ok {
		err := augmentedDatasourceSet.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.DatasourceSet_STATUS
// DatasourceSet details of datasource to be backed up
type DatasourceSet_STATUS struct {
	DatasourceType   *string                `json:"datasourceType,omitempty"`
	ObjectType       *string                `json:"objectType,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceID       *string                `json:"resourceID,omitempty"`
	ResourceLocation *string                `json:"resourceLocation,omitempty"`
	ResourceName     *string                `json:"resourceName,omitempty"`
	ResourceType     *string                `json:"resourceType,omitempty"`
	ResourceUri      *string                `json:"resourceUri,omitempty"`
}

// AssignProperties_From_DatasourceSet_STATUS populates our DatasourceSet_STATUS from the provided source DatasourceSet_STATUS
func (datasourceSet *DatasourceSet_STATUS) AssignProperties_From_DatasourceSet_STATUS(source *v20231201s.DatasourceSet_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DatasourceType
	datasourceSet.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasourceSet.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceID
	datasourceSet.ResourceID = genruntime.ClonePointerToString(source.ResourceID)

	// ResourceLocation
	datasourceSet.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasourceSet.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		propertyBag.Add("ResourceProperties", *source.ResourceProperties)
	} else {
		propertyBag.Remove("ResourceProperties")
	}

	// ResourceType
	datasourceSet.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasourceSet.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		datasourceSet.PropertyBag = propertyBag
	} else {
		datasourceSet.PropertyBag = nil
	}

	// Invoke the augmentConversionForDatasourceSet_STATUS interface (if implemented) to customize the conversion
	var datasourceSetAsAny any = datasourceSet
	if augmentedDatasourceSet, ok := datasourceSetAsAny.(augmentConversionForDatasourceSet_STATUS); ok {
		err := augmentedDatasourceSet.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DatasourceSet_STATUS populates the provided destination DatasourceSet_STATUS from our DatasourceSet_STATUS
func (datasourceSet *DatasourceSet_STATUS) AssignProperties_To_DatasourceSet_STATUS(destination *v20231201s.DatasourceSet_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(datasourceSet.PropertyBag)

	// DatasourceType
	destination.DatasourceType = genruntime.ClonePointerToString(datasourceSet.DatasourceType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(datasourceSet.ObjectType)

	// ResourceID
	destination.ResourceID = genruntime.ClonePointerToString(datasourceSet.ResourceID)

	// ResourceLocation
	destination.ResourceLocation = genruntime.ClonePointerToString(datasourceSet.ResourceLocation)

	// ResourceName
	destination.ResourceName = genruntime.ClonePointerToString(datasourceSet.ResourceName)

	// ResourceProperties
	if propertyBag.Contains("ResourceProperties") {
		var resourceProperty v20231201s.BaseResourceProperties_STATUS
		err := propertyBag.Pull("ResourceProperties", &resourceProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'ResourceProperties' from propertyBag")
		}

		destination.ResourceProperties = &resourceProperty
	} else {
		destination.ResourceProperties = nil
	}

	// ResourceType
	destination.ResourceType = genruntime.ClonePointerToString(datasourceSet.ResourceType)

	// ResourceUri
	destination.ResourceUri = genruntime.ClonePointerToString(datasourceSet.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDatasourceSet_STATUS interface (if implemented) to customize the conversion
	var datasourceSetAsAny any = datasourceSet
	if augmentedDatasourceSet, ok := datasourceSetAsAny.(augmentConversionForDatasourceSet_STATUS); ok {
		err := augmentedDatasourceSet.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.PolicyInfo
// Policy Info in backupInstance
type PolicyInfo struct {
	PolicyParameters *PolicyParameters `json:"policyParameters,omitempty"`

	// +kubebuilder:validation:Required
	PolicyReference *genruntime.ResourceReference `armReference:"PolicyId" json:"policyReference,omitempty"`
	PropertyBag     genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PolicyInfo populates our PolicyInfo from the provided source PolicyInfo
func (info *PolicyInfo) AssignProperties_From_PolicyInfo(source *v20231201s.PolicyInfo) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PolicyParameters
	if source.PolicyParameters != nil {
		var policyParameter PolicyParameters
		err := policyParameter.AssignProperties_From_PolicyParameters(source.PolicyParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicyParameters() to populate field PolicyParameters")
		}
		info.PolicyParameters = &policyParameter
	} else {
		info.PolicyParameters = nil
	}

	// PolicyReference
	if source.PolicyReference != nil {
		policyReference := source.PolicyReference.Copy()
		info.PolicyReference = &policyReference
	} else {
		info.PolicyReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		info.PropertyBag = propertyBag
	} else {
		info.PropertyBag = nil
	}

	// Invoke the augmentConversionForPolicyInfo interface (if implemented) to customize the conversion
	var infoAsAny any = info
	if augmentedInfo, ok := infoAsAny.(augmentConversionForPolicyInfo); ok {
		err := augmentedInfo.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PolicyInfo populates the provided destination PolicyInfo from our PolicyInfo
func (info *PolicyInfo) AssignProperties_To_PolicyInfo(destination *v20231201s.PolicyInfo) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(info.PropertyBag)

	// PolicyParameters
	if info.PolicyParameters != nil {
		var policyParameter v20231201s.PolicyParameters
		err := info.PolicyParameters.AssignProperties_To_PolicyParameters(&policyParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicyParameters() to populate field PolicyParameters")
		}
		destination.PolicyParameters = &policyParameter
	} else {
		destination.PolicyParameters = nil
	}

	// PolicyReference
	if info.PolicyReference != nil {
		policyReference := info.PolicyReference.Copy()
		destination.PolicyReference = &policyReference
	} else {
		destination.PolicyReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPolicyInfo interface (if implemented) to customize the conversion
	var infoAsAny any = info
	if augmentedInfo, ok := infoAsAny.(augmentConversionForPolicyInfo); ok {
		err := augmentedInfo.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.PolicyInfo_STATUS
// Policy Info in backupInstance
type PolicyInfo_STATUS struct {
	PolicyId         *string                  `json:"policyId,omitempty"`
	PolicyParameters *PolicyParameters_STATUS `json:"policyParameters,omitempty"`
	PolicyVersion    *string                  `json:"policyVersion,omitempty"`
	PropertyBag      genruntime.PropertyBag   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PolicyInfo_STATUS populates our PolicyInfo_STATUS from the provided source PolicyInfo_STATUS
func (info *PolicyInfo_STATUS) AssignProperties_From_PolicyInfo_STATUS(source *v20231201s.PolicyInfo_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PolicyId
	info.PolicyId = genruntime.ClonePointerToString(source.PolicyId)

	// PolicyParameters
	if source.PolicyParameters != nil {
		var policyParameter PolicyParameters_STATUS
		err := policyParameter.AssignProperties_From_PolicyParameters_STATUS(source.PolicyParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicyParameters_STATUS() to populate field PolicyParameters")
		}
		info.PolicyParameters = &policyParameter
	} else {
		info.PolicyParameters = nil
	}

	// PolicyVersion
	info.PolicyVersion = genruntime.ClonePointerToString(source.PolicyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		info.PropertyBag = propertyBag
	} else {
		info.PropertyBag = nil
	}

	// Invoke the augmentConversionForPolicyInfo_STATUS interface (if implemented) to customize the conversion
	var infoAsAny any = info
	if augmentedInfo, ok := infoAsAny.(augmentConversionForPolicyInfo_STATUS); ok {
		err := augmentedInfo.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PolicyInfo_STATUS populates the provided destination PolicyInfo_STATUS from our PolicyInfo_STATUS
func (info *PolicyInfo_STATUS) AssignProperties_To_PolicyInfo_STATUS(destination *v20231201s.PolicyInfo_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(info.PropertyBag)

	// PolicyId
	destination.PolicyId = genruntime.ClonePointerToString(info.PolicyId)

	// PolicyParameters
	if info.PolicyParameters != nil {
		var policyParameter v20231201s.PolicyParameters_STATUS
		err := info.PolicyParameters.AssignProperties_To_PolicyParameters_STATUS(&policyParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicyParameters_STATUS() to populate field PolicyParameters")
		}
		destination.PolicyParameters = &policyParameter
	} else {
		destination.PolicyParameters = nil
	}

	// PolicyVersion
	destination.PolicyVersion = genruntime.ClonePointerToString(info.PolicyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPolicyInfo_STATUS interface (if implemented) to customize the conversion
	var infoAsAny any = info
	if augmentedInfo, ok := infoAsAny.(augmentConversionForPolicyInfo_STATUS); ok {
		err := augmentedInfo.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.ProtectionStatusDetails_STATUS
// Protection status details
type ProtectionStatusDetails_STATUS struct {
	ErrorDetails *UserFacingError_STATUS `json:"errorDetails,omitempty"`
	PropertyBag  genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
	Status       *string                 `json:"status,omitempty"`
}

// AssignProperties_From_ProtectionStatusDetails_STATUS populates our ProtectionStatusDetails_STATUS from the provided source ProtectionStatusDetails_STATUS
func (details *ProtectionStatusDetails_STATUS) AssignProperties_From_ProtectionStatusDetails_STATUS(source *v20231201s.ProtectionStatusDetails_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ErrorDetails
	if source.ErrorDetails != nil {
		var errorDetail UserFacingError_STATUS
		err := errorDetail.AssignProperties_From_UserFacingError_STATUS(source.ErrorDetails)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserFacingError_STATUS() to populate field ErrorDetails")
		}
		details.ErrorDetails = &errorDetail
	} else {
		details.ErrorDetails = nil
	}

	// Status
	details.Status = genruntime.ClonePointerToString(source.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		details.PropertyBag = propertyBag
	} else {
		details.PropertyBag = nil
	}

	// Invoke the augmentConversionForProtectionStatusDetails_STATUS interface (if implemented) to customize the conversion
	var detailsAsAny any = details
	if augmentedDetails, ok := detailsAsAny.(augmentConversionForProtectionStatusDetails_STATUS); ok {
		err := augmentedDetails.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ProtectionStatusDetails_STATUS populates the provided destination ProtectionStatusDetails_STATUS from our ProtectionStatusDetails_STATUS
func (details *ProtectionStatusDetails_STATUS) AssignProperties_To_ProtectionStatusDetails_STATUS(destination *v20231201s.ProtectionStatusDetails_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(details.PropertyBag)

	// ErrorDetails
	if details.ErrorDetails != nil {
		var errorDetail v20231201s.UserFacingError_STATUS
		err := details.ErrorDetails.AssignProperties_To_UserFacingError_STATUS(&errorDetail)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserFacingError_STATUS() to populate field ErrorDetails")
		}
		destination.ErrorDetails = &errorDetail
	} else {
		destination.ErrorDetails = nil
	}

	// Status
	destination.Status = genruntime.ClonePointerToString(details.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForProtectionStatusDetails_STATUS interface (if implemented) to customize the conversion
	var detailsAsAny any = details
	if augmentedDetails, ok := detailsAsAny.(augmentConversionForProtectionStatusDetails_STATUS); ok {
		err := augmentedDetails.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.UserFacingError_STATUS
// Error object used by layers that have access to localized content, and propagate that to user
type UserFacingError_STATUS struct {
	Code              *string                           `json:"code,omitempty"`
	Details           []UserFacingError_STATUS_Unrolled `json:"details,omitempty"`
	InnerError        *InnerError_STATUS                `json:"innerError,omitempty"`
	IsRetryable       *bool                             `json:"isRetryable,omitempty"`
	IsUserError       *bool                             `json:"isUserError,omitempty"`
	Message           *string                           `json:"message,omitempty"`
	Properties        map[string]string                 `json:"properties,omitempty"`
	PropertyBag       genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	RecommendedAction []string                          `json:"recommendedAction,omitempty"`
	Target            *string                           `json:"target,omitempty"`
}

// AssignProperties_From_UserFacingError_STATUS populates our UserFacingError_STATUS from the provided source UserFacingError_STATUS
func (error *UserFacingError_STATUS) AssignProperties_From_UserFacingError_STATUS(source *v20231201s.UserFacingError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]UserFacingError_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail UserFacingError_STATUS_Unrolled
			err := detail.AssignProperties_From_UserFacingError_STATUS_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserFacingError_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		error.Details = detailList
	} else {
		error.Details = nil
	}

	// InnerError
	if source.InnerError != nil {
		var innerError InnerError_STATUS
		err := innerError.AssignProperties_From_InnerError_STATUS(source.InnerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS() to populate field InnerError")
		}
		error.InnerError = &innerError
	} else {
		error.InnerError = nil
	}

	// IsRetryable
	if source.IsRetryable != nil {
		isRetryable := *source.IsRetryable
		error.IsRetryable = &isRetryable
	} else {
		error.IsRetryable = nil
	}

	// IsUserError
	if source.IsUserError != nil {
		isUserError := *source.IsUserError
		error.IsUserError = &isUserError
	} else {
		error.IsUserError = nil
	}

	// Message
	error.Message = genruntime.ClonePointerToString(source.Message)

	// Properties
	error.Properties = genruntime.CloneMapOfStringToString(source.Properties)

	// RecommendedAction
	error.RecommendedAction = genruntime.CloneSliceOfString(source.RecommendedAction)

	// Target
	error.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserFacingError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForUserFacingError_STATUS); ok {
		err := augmentedError.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UserFacingError_STATUS populates the provided destination UserFacingError_STATUS from our UserFacingError_STATUS
func (error *UserFacingError_STATUS) AssignProperties_To_UserFacingError_STATUS(destination *v20231201s.UserFacingError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// Details
	if error.Details != nil {
		detailList := make([]v20231201s.UserFacingError_STATUS_Unrolled, len(error.Details))
		for detailIndex, detailItem := range error.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail v20231201s.UserFacingError_STATUS_Unrolled
			err := detailItem.AssignProperties_To_UserFacingError_STATUS_Unrolled(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserFacingError_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// InnerError
	if error.InnerError != nil {
		var innerError v20231201s.InnerError_STATUS
		err := error.InnerError.AssignProperties_To_InnerError_STATUS(&innerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS() to populate field InnerError")
		}
		destination.InnerError = &innerError
	} else {
		destination.InnerError = nil
	}

	// IsRetryable
	if error.IsRetryable != nil {
		isRetryable := *error.IsRetryable
		destination.IsRetryable = &isRetryable
	} else {
		destination.IsRetryable = nil
	}

	// IsUserError
	if error.IsUserError != nil {
		isUserError := *error.IsUserError
		destination.IsUserError = &isUserError
	} else {
		destination.IsUserError = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(error.Message)

	// Properties
	destination.Properties = genruntime.CloneMapOfStringToString(error.Properties)

	// RecommendedAction
	destination.RecommendedAction = genruntime.CloneSliceOfString(error.RecommendedAction)

	// Target
	destination.Target = genruntime.ClonePointerToString(error.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserFacingError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForUserFacingError_STATUS); ok {
		err := augmentedError.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAuthCredentials interface {
	AssignPropertiesFrom(src *v20231201s.AuthCredentials) error
	AssignPropertiesTo(dst *v20231201s.AuthCredentials) error
}

type augmentConversionForAuthCredentials_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.AuthCredentials_STATUS) error
	AssignPropertiesTo(dst *v20231201s.AuthCredentials_STATUS) error
}

type augmentConversionForDatasource interface {
	AssignPropertiesFrom(src *v20231201s.Datasource) error
	AssignPropertiesTo(dst *v20231201s.Datasource) error
}

type augmentConversionForDatasource_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.Datasource_STATUS) error
	AssignPropertiesTo(dst *v20231201s.Datasource_STATUS) error
}

type augmentConversionForDatasourceSet interface {
	AssignPropertiesFrom(src *v20231201s.DatasourceSet) error
	AssignPropertiesTo(dst *v20231201s.DatasourceSet) error
}

type augmentConversionForDatasourceSet_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.DatasourceSet_STATUS) error
	AssignPropertiesTo(dst *v20231201s.DatasourceSet_STATUS) error
}

type augmentConversionForPolicyInfo interface {
	AssignPropertiesFrom(src *v20231201s.PolicyInfo) error
	AssignPropertiesTo(dst *v20231201s.PolicyInfo) error
}

type augmentConversionForPolicyInfo_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.PolicyInfo_STATUS) error
	AssignPropertiesTo(dst *v20231201s.PolicyInfo_STATUS) error
}

type augmentConversionForProtectionStatusDetails_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.ProtectionStatusDetails_STATUS) error
	AssignPropertiesTo(dst *v20231201s.ProtectionStatusDetails_STATUS) error
}

type augmentConversionForUserFacingError_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.UserFacingError_STATUS) error
	AssignPropertiesTo(dst *v20231201s.UserFacingError_STATUS) error
}

// Storage version of v1api20230101.InnerError_STATUS
// Inner Error
type InnerError_STATUS struct {
	AdditionalInfo     map[string]string           `json:"additionalInfo,omitempty"`
	Code               *string                     `json:"code,omitempty"`
	EmbeddedInnerError *InnerError_STATUS_Unrolled `json:"embeddedInnerError,omitempty"`
	PropertyBag        genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_InnerError_STATUS populates our InnerError_STATUS from the provided source InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_From_InnerError_STATUS(source *v20231201s.InnerError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalInfo
	error.AdditionalInfo = genruntime.CloneMapOfStringToString(source.AdditionalInfo)

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// EmbeddedInnerError
	if source.EmbeddedInnerError != nil {
		var embeddedInnerError InnerError_STATUS_Unrolled
		err := embeddedInnerError.AssignProperties_From_InnerError_STATUS_Unrolled(source.EmbeddedInnerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS_Unrolled() to populate field EmbeddedInnerError")
		}
		error.EmbeddedInnerError = &embeddedInnerError
	} else {
		error.EmbeddedInnerError = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// Invoke the augmentConversionForInnerError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForInnerError_STATUS); ok {
		err := augmentedError.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InnerError_STATUS populates the provided destination InnerError_STATUS from our InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_To_InnerError_STATUS(destination *v20231201s.InnerError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// AdditionalInfo
	destination.AdditionalInfo = genruntime.CloneMapOfStringToString(error.AdditionalInfo)

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// EmbeddedInnerError
	if error.EmbeddedInnerError != nil {
		var embeddedInnerError v20231201s.InnerError_STATUS_Unrolled
		err := error.EmbeddedInnerError.AssignProperties_To_InnerError_STATUS_Unrolled(&embeddedInnerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS_Unrolled() to populate field EmbeddedInnerError")
		}
		destination.EmbeddedInnerError = &embeddedInnerError
	} else {
		destination.EmbeddedInnerError = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInnerError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForInnerError_STATUS); ok {
		err := augmentedError.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.PolicyParameters
// Parameters in Policy
type PolicyParameters struct {
	BackupDatasourceParametersList []BackupDatasourceParameters `json:"backupDatasourceParametersList,omitempty"`
	DataStoreParametersList        []DataStoreParameters        `json:"dataStoreParametersList,omitempty"`
	PropertyBag                    genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PolicyParameters populates our PolicyParameters from the provided source PolicyParameters
func (parameters *PolicyParameters) AssignProperties_From_PolicyParameters(source *v20231201s.PolicyParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackupDatasourceParametersList
	if source.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]BackupDatasourceParameters, len(source.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range source.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal BackupDatasourceParameters
			err := backupDatasourceParametersListLocal.AssignProperties_From_BackupDatasourceParameters(&backupDatasourceParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackupDatasourceParameters() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		parameters.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		parameters.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if source.DataStoreParametersList != nil {
		dataStoreParametersList := make([]DataStoreParameters, len(source.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range source.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal DataStoreParameters
			err := dataStoreParametersListLocal.AssignProperties_From_DataStoreParameters(&dataStoreParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataStoreParameters() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		parameters.DataStoreParametersList = dataStoreParametersList
	} else {
		parameters.DataStoreParametersList = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForPolicyParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPolicyParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PolicyParameters populates the provided destination PolicyParameters from our PolicyParameters
func (parameters *PolicyParameters) AssignProperties_To_PolicyParameters(destination *v20231201s.PolicyParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// BackupDatasourceParametersList
	if parameters.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]v20231201s.BackupDatasourceParameters, len(parameters.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range parameters.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal v20231201s.BackupDatasourceParameters
			err := backupDatasourceParametersListItem.AssignProperties_To_BackupDatasourceParameters(&backupDatasourceParametersListLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackupDatasourceParameters() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		destination.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		destination.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if parameters.DataStoreParametersList != nil {
		dataStoreParametersList := make([]v20231201s.DataStoreParameters, len(parameters.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range parameters.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal v20231201s.DataStoreParameters
			err := dataStoreParametersListItem.AssignProperties_To_DataStoreParameters(&dataStoreParametersListLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataStoreParameters() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		destination.DataStoreParametersList = dataStoreParametersList
	} else {
		destination.DataStoreParametersList = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPolicyParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPolicyParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.PolicyParameters_STATUS
// Parameters in Policy
type PolicyParameters_STATUS struct {
	BackupDatasourceParametersList []BackupDatasourceParameters_STATUS `json:"backupDatasourceParametersList,omitempty"`
	DataStoreParametersList        []DataStoreParameters_STATUS        `json:"dataStoreParametersList,omitempty"`
	PropertyBag                    genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PolicyParameters_STATUS populates our PolicyParameters_STATUS from the provided source PolicyParameters_STATUS
func (parameters *PolicyParameters_STATUS) AssignProperties_From_PolicyParameters_STATUS(source *v20231201s.PolicyParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackupDatasourceParametersList
	if source.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]BackupDatasourceParameters_STATUS, len(source.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range source.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal BackupDatasourceParameters_STATUS
			err := backupDatasourceParametersListLocal.AssignProperties_From_BackupDatasourceParameters_STATUS(&backupDatasourceParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackupDatasourceParameters_STATUS() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		parameters.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		parameters.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if source.DataStoreParametersList != nil {
		dataStoreParametersList := make([]DataStoreParameters_STATUS, len(source.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range source.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal DataStoreParameters_STATUS
			err := dataStoreParametersListLocal.AssignProperties_From_DataStoreParameters_STATUS(&dataStoreParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataStoreParameters_STATUS() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		parameters.DataStoreParametersList = dataStoreParametersList
	} else {
		parameters.DataStoreParametersList = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForPolicyParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPolicyParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PolicyParameters_STATUS populates the provided destination PolicyParameters_STATUS from our PolicyParameters_STATUS
func (parameters *PolicyParameters_STATUS) AssignProperties_To_PolicyParameters_STATUS(destination *v20231201s.PolicyParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// BackupDatasourceParametersList
	if parameters.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]v20231201s.BackupDatasourceParameters_STATUS, len(parameters.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range parameters.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal v20231201s.BackupDatasourceParameters_STATUS
			err := backupDatasourceParametersListItem.AssignProperties_To_BackupDatasourceParameters_STATUS(&backupDatasourceParametersListLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackupDatasourceParameters_STATUS() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		destination.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		destination.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if parameters.DataStoreParametersList != nil {
		dataStoreParametersList := make([]v20231201s.DataStoreParameters_STATUS, len(parameters.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range parameters.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal v20231201s.DataStoreParameters_STATUS
			err := dataStoreParametersListItem.AssignProperties_To_DataStoreParameters_STATUS(&dataStoreParametersListLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataStoreParameters_STATUS() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		destination.DataStoreParametersList = dataStoreParametersList
	} else {
		destination.DataStoreParametersList = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPolicyParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPolicyParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.SecretStoreBasedAuthCredentials
type SecretStoreBasedAuthCredentials struct {
	ObjectType          *string                `json:"objectType,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretStoreResource *SecretStoreResource   `json:"secretStoreResource,omitempty"`
}

// AssignProperties_From_SecretStoreBasedAuthCredentials populates our SecretStoreBasedAuthCredentials from the provided source SecretStoreBasedAuthCredentials
func (credentials *SecretStoreBasedAuthCredentials) AssignProperties_From_SecretStoreBasedAuthCredentials(source *v20231201s.SecretStoreBasedAuthCredentials) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ObjectType
	credentials.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// SecretStoreResource
	if source.SecretStoreResource != nil {
		var secretStoreResource SecretStoreResource
		err := secretStoreResource.AssignProperties_From_SecretStoreResource(source.SecretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecretStoreResource() to populate field SecretStoreResource")
		}
		credentials.SecretStoreResource = &secretStoreResource
	} else {
		credentials.SecretStoreResource = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		credentials.PropertyBag = propertyBag
	} else {
		credentials.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretStoreBasedAuthCredentials interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForSecretStoreBasedAuthCredentials); ok {
		err := augmentedCredentials.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecretStoreBasedAuthCredentials populates the provided destination SecretStoreBasedAuthCredentials from our SecretStoreBasedAuthCredentials
func (credentials *SecretStoreBasedAuthCredentials) AssignProperties_To_SecretStoreBasedAuthCredentials(destination *v20231201s.SecretStoreBasedAuthCredentials) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(credentials.PropertyBag)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(credentials.ObjectType)

	// SecretStoreResource
	if credentials.SecretStoreResource != nil {
		var secretStoreResource v20231201s.SecretStoreResource
		err := credentials.SecretStoreResource.AssignProperties_To_SecretStoreResource(&secretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecretStoreResource() to populate field SecretStoreResource")
		}
		destination.SecretStoreResource = &secretStoreResource
	} else {
		destination.SecretStoreResource = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretStoreBasedAuthCredentials interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForSecretStoreBasedAuthCredentials); ok {
		err := augmentedCredentials.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.SecretStoreBasedAuthCredentials_STATUS
type SecretStoreBasedAuthCredentials_STATUS struct {
	ObjectType          *string                     `json:"objectType,omitempty"`
	PropertyBag         genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	SecretStoreResource *SecretStoreResource_STATUS `json:"secretStoreResource,omitempty"`
}

// AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS populates our SecretStoreBasedAuthCredentials_STATUS from the provided source SecretStoreBasedAuthCredentials_STATUS
func (credentials *SecretStoreBasedAuthCredentials_STATUS) AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS(source *v20231201s.SecretStoreBasedAuthCredentials_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ObjectType
	credentials.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// SecretStoreResource
	if source.SecretStoreResource != nil {
		var secretStoreResource SecretStoreResource_STATUS
		err := secretStoreResource.AssignProperties_From_SecretStoreResource_STATUS(source.SecretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecretStoreResource_STATUS() to populate field SecretStoreResource")
		}
		credentials.SecretStoreResource = &secretStoreResource
	} else {
		credentials.SecretStoreResource = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		credentials.PropertyBag = propertyBag
	} else {
		credentials.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretStoreBasedAuthCredentials_STATUS interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForSecretStoreBasedAuthCredentials_STATUS); ok {
		err := augmentedCredentials.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS populates the provided destination SecretStoreBasedAuthCredentials_STATUS from our SecretStoreBasedAuthCredentials_STATUS
func (credentials *SecretStoreBasedAuthCredentials_STATUS) AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS(destination *v20231201s.SecretStoreBasedAuthCredentials_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(credentials.PropertyBag)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(credentials.ObjectType)

	// SecretStoreResource
	if credentials.SecretStoreResource != nil {
		var secretStoreResource v20231201s.SecretStoreResource_STATUS
		err := credentials.SecretStoreResource.AssignProperties_To_SecretStoreResource_STATUS(&secretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecretStoreResource_STATUS() to populate field SecretStoreResource")
		}
		destination.SecretStoreResource = &secretStoreResource
	} else {
		destination.SecretStoreResource = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretStoreBasedAuthCredentials_STATUS interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForSecretStoreBasedAuthCredentials_STATUS); ok {
		err := augmentedCredentials.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.UserFacingError_STATUS_Unrolled
type UserFacingError_STATUS_Unrolled struct {
	Code              *string                `json:"code,omitempty"`
	InnerError        *InnerError_STATUS     `json:"innerError,omitempty"`
	IsRetryable       *bool                  `json:"isRetryable,omitempty"`
	IsUserError       *bool                  `json:"isUserError,omitempty"`
	Message           *string                `json:"message,omitempty"`
	Properties        map[string]string      `json:"properties,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RecommendedAction []string               `json:"recommendedAction,omitempty"`
	Target            *string                `json:"target,omitempty"`
}

// AssignProperties_From_UserFacingError_STATUS_Unrolled populates our UserFacingError_STATUS_Unrolled from the provided source UserFacingError_STATUS_Unrolled
func (unrolled *UserFacingError_STATUS_Unrolled) AssignProperties_From_UserFacingError_STATUS_Unrolled(source *v20231201s.UserFacingError_STATUS_Unrolled) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// InnerError
	if source.InnerError != nil {
		var innerError InnerError_STATUS
		err := innerError.AssignProperties_From_InnerError_STATUS(source.InnerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS() to populate field InnerError")
		}
		unrolled.InnerError = &innerError
	} else {
		unrolled.InnerError = nil
	}

	// IsRetryable
	if source.IsRetryable != nil {
		isRetryable := *source.IsRetryable
		unrolled.IsRetryable = &isRetryable
	} else {
		unrolled.IsRetryable = nil
	}

	// IsUserError
	if source.IsUserError != nil {
		isUserError := *source.IsUserError
		unrolled.IsUserError = &isUserError
	} else {
		unrolled.IsUserError = nil
	}

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Properties
	unrolled.Properties = genruntime.CloneMapOfStringToString(source.Properties)

	// RecommendedAction
	unrolled.RecommendedAction = genruntime.CloneSliceOfString(source.RecommendedAction)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		unrolled.PropertyBag = propertyBag
	} else {
		unrolled.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserFacingError_STATUS_Unrolled interface (if implemented) to customize the conversion
	var unrolledAsAny any = unrolled
	if augmentedUnrolled, ok := unrolledAsAny.(augmentConversionForUserFacingError_STATUS_Unrolled); ok {
		err := augmentedUnrolled.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UserFacingError_STATUS_Unrolled populates the provided destination UserFacingError_STATUS_Unrolled from our UserFacingError_STATUS_Unrolled
func (unrolled *UserFacingError_STATUS_Unrolled) AssignProperties_To_UserFacingError_STATUS_Unrolled(destination *v20231201s.UserFacingError_STATUS_Unrolled) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(unrolled.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// InnerError
	if unrolled.InnerError != nil {
		var innerError v20231201s.InnerError_STATUS
		err := unrolled.InnerError.AssignProperties_To_InnerError_STATUS(&innerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS() to populate field InnerError")
		}
		destination.InnerError = &innerError
	} else {
		destination.InnerError = nil
	}

	// IsRetryable
	if unrolled.IsRetryable != nil {
		isRetryable := *unrolled.IsRetryable
		destination.IsRetryable = &isRetryable
	} else {
		destination.IsRetryable = nil
	}

	// IsUserError
	if unrolled.IsUserError != nil {
		isUserError := *unrolled.IsUserError
		destination.IsUserError = &isUserError
	} else {
		destination.IsUserError = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Properties
	destination.Properties = genruntime.CloneMapOfStringToString(unrolled.Properties)

	// RecommendedAction
	destination.RecommendedAction = genruntime.CloneSliceOfString(unrolled.RecommendedAction)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserFacingError_STATUS_Unrolled interface (if implemented) to customize the conversion
	var unrolledAsAny any = unrolled
	if augmentedUnrolled, ok := unrolledAsAny.(augmentConversionForUserFacingError_STATUS_Unrolled); ok {
		err := augmentedUnrolled.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForInnerError_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.InnerError_STATUS) error
	AssignPropertiesTo(dst *v20231201s.InnerError_STATUS) error
}

type augmentConversionForPolicyParameters interface {
	AssignPropertiesFrom(src *v20231201s.PolicyParameters) error
	AssignPropertiesTo(dst *v20231201s.PolicyParameters) error
}

type augmentConversionForPolicyParameters_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.PolicyParameters_STATUS) error
	AssignPropertiesTo(dst *v20231201s.PolicyParameters_STATUS) error
}

type augmentConversionForSecretStoreBasedAuthCredentials interface {
	AssignPropertiesFrom(src *v20231201s.SecretStoreBasedAuthCredentials) error
	AssignPropertiesTo(dst *v20231201s.SecretStoreBasedAuthCredentials) error
}

type augmentConversionForSecretStoreBasedAuthCredentials_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.SecretStoreBasedAuthCredentials_STATUS) error
	AssignPropertiesTo(dst *v20231201s.SecretStoreBasedAuthCredentials_STATUS) error
}

type augmentConversionForUserFacingError_STATUS_Unrolled interface {
	AssignPropertiesFrom(src *v20231201s.UserFacingError_STATUS_Unrolled) error
	AssignPropertiesTo(dst *v20231201s.UserFacingError_STATUS_Unrolled) error
}

// Storage version of v1api20230101.BackupDatasourceParameters
type BackupDatasourceParameters struct {
	Blob              *BlobBackupDatasourceParameters              `json:"blobBackupDatasourceParameters,omitempty"`
	KubernetesCluster *KubernetesClusterBackupDatasourceParameters `json:"kubernetesClusterBackupDatasourceParameters,omitempty"`
	PropertyBag       genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BackupDatasourceParameters populates our BackupDatasourceParameters from the provided source BackupDatasourceParameters
func (parameters *BackupDatasourceParameters) AssignProperties_From_BackupDatasourceParameters(source *v20231201s.BackupDatasourceParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Blob
	if source.Blob != nil {
		var blob BlobBackupDatasourceParameters
		err := blob.AssignProperties_From_BlobBackupDatasourceParameters(source.Blob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BlobBackupDatasourceParameters() to populate field Blob")
		}
		parameters.Blob = &blob
	} else {
		parameters.Blob = nil
	}

	// KubernetesCluster
	if source.KubernetesCluster != nil {
		var kubernetesCluster KubernetesClusterBackupDatasourceParameters
		err := kubernetesCluster.AssignProperties_From_KubernetesClusterBackupDatasourceParameters(source.KubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubernetesClusterBackupDatasourceParameters() to populate field KubernetesCluster")
		}
		parameters.KubernetesCluster = &kubernetesCluster
	} else {
		parameters.KubernetesCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupDatasourceParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForBackupDatasourceParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackupDatasourceParameters populates the provided destination BackupDatasourceParameters from our BackupDatasourceParameters
func (parameters *BackupDatasourceParameters) AssignProperties_To_BackupDatasourceParameters(destination *v20231201s.BackupDatasourceParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Blob
	if parameters.Blob != nil {
		var blob v20231201s.BlobBackupDatasourceParameters
		err := parameters.Blob.AssignProperties_To_BlobBackupDatasourceParameters(&blob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BlobBackupDatasourceParameters() to populate field Blob")
		}
		destination.Blob = &blob
	} else {
		destination.Blob = nil
	}

	// KubernetesCluster
	if parameters.KubernetesCluster != nil {
		var kubernetesCluster v20231201s.KubernetesClusterBackupDatasourceParameters
		err := parameters.KubernetesCluster.AssignProperties_To_KubernetesClusterBackupDatasourceParameters(&kubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubernetesClusterBackupDatasourceParameters() to populate field KubernetesCluster")
		}
		destination.KubernetesCluster = &kubernetesCluster
	} else {
		destination.KubernetesCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupDatasourceParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForBackupDatasourceParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.BackupDatasourceParameters_STATUS
type BackupDatasourceParameters_STATUS struct {
	Blob              *BlobBackupDatasourceParameters_STATUS              `json:"blobBackupDatasourceParameters,omitempty"`
	KubernetesCluster *KubernetesClusterBackupDatasourceParameters_STATUS `json:"kubernetesClusterBackupDatasourceParameters,omitempty"`
	PropertyBag       genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BackupDatasourceParameters_STATUS populates our BackupDatasourceParameters_STATUS from the provided source BackupDatasourceParameters_STATUS
func (parameters *BackupDatasourceParameters_STATUS) AssignProperties_From_BackupDatasourceParameters_STATUS(source *v20231201s.BackupDatasourceParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Blob
	if source.Blob != nil {
		var blob BlobBackupDatasourceParameters_STATUS
		err := blob.AssignProperties_From_BlobBackupDatasourceParameters_STATUS(source.Blob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BlobBackupDatasourceParameters_STATUS() to populate field Blob")
		}
		parameters.Blob = &blob
	} else {
		parameters.Blob = nil
	}

	// KubernetesCluster
	if source.KubernetesCluster != nil {
		var kubernetesCluster KubernetesClusterBackupDatasourceParameters_STATUS
		err := kubernetesCluster.AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS(source.KubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS() to populate field KubernetesCluster")
		}
		parameters.KubernetesCluster = &kubernetesCluster
	} else {
		parameters.KubernetesCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupDatasourceParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForBackupDatasourceParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackupDatasourceParameters_STATUS populates the provided destination BackupDatasourceParameters_STATUS from our BackupDatasourceParameters_STATUS
func (parameters *BackupDatasourceParameters_STATUS) AssignProperties_To_BackupDatasourceParameters_STATUS(destination *v20231201s.BackupDatasourceParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Blob
	if parameters.Blob != nil {
		var blob v20231201s.BlobBackupDatasourceParameters_STATUS
		err := parameters.Blob.AssignProperties_To_BlobBackupDatasourceParameters_STATUS(&blob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BlobBackupDatasourceParameters_STATUS() to populate field Blob")
		}
		destination.Blob = &blob
	} else {
		destination.Blob = nil
	}

	// KubernetesCluster
	if parameters.KubernetesCluster != nil {
		var kubernetesCluster v20231201s.KubernetesClusterBackupDatasourceParameters_STATUS
		err := parameters.KubernetesCluster.AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS(&kubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS() to populate field KubernetesCluster")
		}
		destination.KubernetesCluster = &kubernetesCluster
	} else {
		destination.KubernetesCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackupDatasourceParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForBackupDatasourceParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.DataStoreParameters
type DataStoreParameters struct {
	AzureOperationalStoreParameters *AzureOperationalStoreParameters `json:"azureOperationalStoreParameters,omitempty"`
	PropertyBag                     genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DataStoreParameters populates our DataStoreParameters from the provided source DataStoreParameters
func (parameters *DataStoreParameters) AssignProperties_From_DataStoreParameters(source *v20231201s.DataStoreParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureOperationalStoreParameters
	if source.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter AzureOperationalStoreParameters
		err := azureOperationalStoreParameter.AssignProperties_From_AzureOperationalStoreParameters(source.AzureOperationalStoreParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureOperationalStoreParameters() to populate field AzureOperationalStoreParameters")
		}
		parameters.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		parameters.AzureOperationalStoreParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataStoreParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForDataStoreParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataStoreParameters populates the provided destination DataStoreParameters from our DataStoreParameters
func (parameters *DataStoreParameters) AssignProperties_To_DataStoreParameters(destination *v20231201s.DataStoreParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// AzureOperationalStoreParameters
	if parameters.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter v20231201s.AzureOperationalStoreParameters
		err := parameters.AzureOperationalStoreParameters.AssignProperties_To_AzureOperationalStoreParameters(&azureOperationalStoreParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureOperationalStoreParameters() to populate field AzureOperationalStoreParameters")
		}
		destination.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		destination.AzureOperationalStoreParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataStoreParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForDataStoreParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.DataStoreParameters_STATUS
type DataStoreParameters_STATUS struct {
	AzureOperationalStoreParameters *AzureOperationalStoreParameters_STATUS `json:"azureOperationalStoreParameters,omitempty"`
	PropertyBag                     genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DataStoreParameters_STATUS populates our DataStoreParameters_STATUS from the provided source DataStoreParameters_STATUS
func (parameters *DataStoreParameters_STATUS) AssignProperties_From_DataStoreParameters_STATUS(source *v20231201s.DataStoreParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureOperationalStoreParameters
	if source.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter AzureOperationalStoreParameters_STATUS
		err := azureOperationalStoreParameter.AssignProperties_From_AzureOperationalStoreParameters_STATUS(source.AzureOperationalStoreParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureOperationalStoreParameters_STATUS() to populate field AzureOperationalStoreParameters")
		}
		parameters.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		parameters.AzureOperationalStoreParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataStoreParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForDataStoreParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataStoreParameters_STATUS populates the provided destination DataStoreParameters_STATUS from our DataStoreParameters_STATUS
func (parameters *DataStoreParameters_STATUS) AssignProperties_To_DataStoreParameters_STATUS(destination *v20231201s.DataStoreParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// AzureOperationalStoreParameters
	if parameters.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter v20231201s.AzureOperationalStoreParameters_STATUS
		err := parameters.AzureOperationalStoreParameters.AssignProperties_To_AzureOperationalStoreParameters_STATUS(&azureOperationalStoreParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureOperationalStoreParameters_STATUS() to populate field AzureOperationalStoreParameters")
		}
		destination.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		destination.AzureOperationalStoreParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataStoreParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForDataStoreParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.InnerError_STATUS_Unrolled
type InnerError_STATUS_Unrolled struct {
	AdditionalInfo map[string]string      `json:"additionalInfo,omitempty"`
	Code           *string                `json:"code,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_InnerError_STATUS_Unrolled populates our InnerError_STATUS_Unrolled from the provided source InnerError_STATUS_Unrolled
func (unrolled *InnerError_STATUS_Unrolled) AssignProperties_From_InnerError_STATUS_Unrolled(source *v20231201s.InnerError_STATUS_Unrolled) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalInfo
	unrolled.AdditionalInfo = genruntime.CloneMapOfStringToString(source.AdditionalInfo)

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Update the property bag
	if len(propertyBag) > 0 {
		unrolled.PropertyBag = propertyBag
	} else {
		unrolled.PropertyBag = nil
	}

	// Invoke the augmentConversionForInnerError_STATUS_Unrolled interface (if implemented) to customize the conversion
	var unrolledAsAny any = unrolled
	if augmentedUnrolled, ok := unrolledAsAny.(augmentConversionForInnerError_STATUS_Unrolled); ok {
		err := augmentedUnrolled.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InnerError_STATUS_Unrolled populates the provided destination InnerError_STATUS_Unrolled from our InnerError_STATUS_Unrolled
func (unrolled *InnerError_STATUS_Unrolled) AssignProperties_To_InnerError_STATUS_Unrolled(destination *v20231201s.InnerError_STATUS_Unrolled) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(unrolled.PropertyBag)

	// AdditionalInfo
	destination.AdditionalInfo = genruntime.CloneMapOfStringToString(unrolled.AdditionalInfo)

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInnerError_STATUS_Unrolled interface (if implemented) to customize the conversion
	var unrolledAsAny any = unrolled
	if augmentedUnrolled, ok := unrolledAsAny.(augmentConversionForInnerError_STATUS_Unrolled); ok {
		err := augmentedUnrolled.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.SecretStoreResource
// Class representing a secret store resource.
type SecretStoreResource struct {
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretStoreType *string                `json:"secretStoreType,omitempty"`
	Uri             *string                `json:"uri,omitempty"`
	Value           *string                `json:"value,omitempty"`
}

// AssignProperties_From_SecretStoreResource populates our SecretStoreResource from the provided source SecretStoreResource
func (resource *SecretStoreResource) AssignProperties_From_SecretStoreResource(source *v20231201s.SecretStoreResource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretStoreType
	resource.SecretStoreType = genruntime.ClonePointerToString(source.SecretStoreType)

	// Uri
	resource.Uri = genruntime.ClonePointerToString(source.Uri)

	// Value
	resource.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretStoreResource interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForSecretStoreResource); ok {
		err := augmentedResource.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecretStoreResource populates the provided destination SecretStoreResource from our SecretStoreResource
func (resource *SecretStoreResource) AssignProperties_To_SecretStoreResource(destination *v20231201s.SecretStoreResource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// SecretStoreType
	destination.SecretStoreType = genruntime.ClonePointerToString(resource.SecretStoreType)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(resource.Uri)

	// Value
	destination.Value = genruntime.ClonePointerToString(resource.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretStoreResource interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForSecretStoreResource); ok {
		err := augmentedResource.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.SecretStoreResource_STATUS
// Class representing a secret store resource.
type SecretStoreResource_STATUS struct {
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretStoreType *string                `json:"secretStoreType,omitempty"`
	Uri             *string                `json:"uri,omitempty"`
	Value           *string                `json:"value,omitempty"`
}

// AssignProperties_From_SecretStoreResource_STATUS populates our SecretStoreResource_STATUS from the provided source SecretStoreResource_STATUS
func (resource *SecretStoreResource_STATUS) AssignProperties_From_SecretStoreResource_STATUS(source *v20231201s.SecretStoreResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretStoreType
	resource.SecretStoreType = genruntime.ClonePointerToString(source.SecretStoreType)

	// Uri
	resource.Uri = genruntime.ClonePointerToString(source.Uri)

	// Value
	resource.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretStoreResource_STATUS interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForSecretStoreResource_STATUS); ok {
		err := augmentedResource.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecretStoreResource_STATUS populates the provided destination SecretStoreResource_STATUS from our SecretStoreResource_STATUS
func (resource *SecretStoreResource_STATUS) AssignProperties_To_SecretStoreResource_STATUS(destination *v20231201s.SecretStoreResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// SecretStoreType
	destination.SecretStoreType = genruntime.ClonePointerToString(resource.SecretStoreType)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(resource.Uri)

	// Value
	destination.Value = genruntime.ClonePointerToString(resource.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretStoreResource_STATUS interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForSecretStoreResource_STATUS); ok {
		err := augmentedResource.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForBackupDatasourceParameters interface {
	AssignPropertiesFrom(src *v20231201s.BackupDatasourceParameters) error
	AssignPropertiesTo(dst *v20231201s.BackupDatasourceParameters) error
}

type augmentConversionForBackupDatasourceParameters_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.BackupDatasourceParameters_STATUS) error
	AssignPropertiesTo(dst *v20231201s.BackupDatasourceParameters_STATUS) error
}

type augmentConversionForDataStoreParameters interface {
	AssignPropertiesFrom(src *v20231201s.DataStoreParameters) error
	AssignPropertiesTo(dst *v20231201s.DataStoreParameters) error
}

type augmentConversionForDataStoreParameters_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.DataStoreParameters_STATUS) error
	AssignPropertiesTo(dst *v20231201s.DataStoreParameters_STATUS) error
}

type augmentConversionForInnerError_STATUS_Unrolled interface {
	AssignPropertiesFrom(src *v20231201s.InnerError_STATUS_Unrolled) error
	AssignPropertiesTo(dst *v20231201s.InnerError_STATUS_Unrolled) error
}

type augmentConversionForSecretStoreResource interface {
	AssignPropertiesFrom(src *v20231201s.SecretStoreResource) error
	AssignPropertiesTo(dst *v20231201s.SecretStoreResource) error
}

type augmentConversionForSecretStoreResource_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.SecretStoreResource_STATUS) error
	AssignPropertiesTo(dst *v20231201s.SecretStoreResource_STATUS) error
}

// Storage version of v1api20230101.AzureOperationalStoreParameters
type AzureOperationalStoreParameters struct {
	DataStoreType   *string                `json:"dataStoreType,omitempty"`
	ObjectType      *string                `json:"objectType,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceGroupId *string                `json:"resourceGroupId,omitempty"`
}

// AssignProperties_From_AzureOperationalStoreParameters populates our AzureOperationalStoreParameters from the provided source AzureOperationalStoreParameters
func (parameters *AzureOperationalStoreParameters) AssignProperties_From_AzureOperationalStoreParameters(source *v20231201s.AzureOperationalStoreParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataStoreType
	parameters.DataStoreType = genruntime.ClonePointerToString(source.DataStoreType)

	// ObjectType
	parameters.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceGroupId
	parameters.ResourceGroupId = genruntime.ClonePointerToString(source.ResourceGroupId)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureOperationalStoreParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForAzureOperationalStoreParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureOperationalStoreParameters populates the provided destination AzureOperationalStoreParameters from our AzureOperationalStoreParameters
func (parameters *AzureOperationalStoreParameters) AssignProperties_To_AzureOperationalStoreParameters(destination *v20231201s.AzureOperationalStoreParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DataStoreType
	destination.DataStoreType = genruntime.ClonePointerToString(parameters.DataStoreType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(parameters.ObjectType)

	// ResourceGroupId
	destination.ResourceGroupId = genruntime.ClonePointerToString(parameters.ResourceGroupId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureOperationalStoreParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForAzureOperationalStoreParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.AzureOperationalStoreParameters_STATUS
type AzureOperationalStoreParameters_STATUS struct {
	DataStoreType   *string                `json:"dataStoreType,omitempty"`
	ObjectType      *string                `json:"objectType,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceGroupId *string                `json:"resourceGroupId,omitempty"`
}

// AssignProperties_From_AzureOperationalStoreParameters_STATUS populates our AzureOperationalStoreParameters_STATUS from the provided source AzureOperationalStoreParameters_STATUS
func (parameters *AzureOperationalStoreParameters_STATUS) AssignProperties_From_AzureOperationalStoreParameters_STATUS(source *v20231201s.AzureOperationalStoreParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataStoreType
	parameters.DataStoreType = genruntime.ClonePointerToString(source.DataStoreType)

	// ObjectType
	parameters.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceGroupId
	parameters.ResourceGroupId = genruntime.ClonePointerToString(source.ResourceGroupId)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureOperationalStoreParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForAzureOperationalStoreParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureOperationalStoreParameters_STATUS populates the provided destination AzureOperationalStoreParameters_STATUS from our AzureOperationalStoreParameters_STATUS
func (parameters *AzureOperationalStoreParameters_STATUS) AssignProperties_To_AzureOperationalStoreParameters_STATUS(destination *v20231201s.AzureOperationalStoreParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DataStoreType
	destination.DataStoreType = genruntime.ClonePointerToString(parameters.DataStoreType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(parameters.ObjectType)

	// ResourceGroupId
	destination.ResourceGroupId = genruntime.ClonePointerToString(parameters.ResourceGroupId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureOperationalStoreParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForAzureOperationalStoreParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.BlobBackupDatasourceParameters
type BlobBackupDatasourceParameters struct {
	ContainersList []string               `json:"containersList,omitempty"`
	ObjectType     *string                `json:"objectType,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BlobBackupDatasourceParameters populates our BlobBackupDatasourceParameters from the provided source BlobBackupDatasourceParameters
func (parameters *BlobBackupDatasourceParameters) AssignProperties_From_BlobBackupDatasourceParameters(source *v20231201s.BlobBackupDatasourceParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ContainersList
	parameters.ContainersList = genruntime.CloneSliceOfString(source.ContainersList)

	// ObjectType
	parameters.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForBlobBackupDatasourceParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForBlobBackupDatasourceParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BlobBackupDatasourceParameters populates the provided destination BlobBackupDatasourceParameters from our BlobBackupDatasourceParameters
func (parameters *BlobBackupDatasourceParameters) AssignProperties_To_BlobBackupDatasourceParameters(destination *v20231201s.BlobBackupDatasourceParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ContainersList
	destination.ContainersList = genruntime.CloneSliceOfString(parameters.ContainersList)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(parameters.ObjectType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBlobBackupDatasourceParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForBlobBackupDatasourceParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.BlobBackupDatasourceParameters_STATUS
type BlobBackupDatasourceParameters_STATUS struct {
	ContainersList []string               `json:"containersList,omitempty"`
	ObjectType     *string                `json:"objectType,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BlobBackupDatasourceParameters_STATUS populates our BlobBackupDatasourceParameters_STATUS from the provided source BlobBackupDatasourceParameters_STATUS
func (parameters *BlobBackupDatasourceParameters_STATUS) AssignProperties_From_BlobBackupDatasourceParameters_STATUS(source *v20231201s.BlobBackupDatasourceParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ContainersList
	parameters.ContainersList = genruntime.CloneSliceOfString(source.ContainersList)

	// ObjectType
	parameters.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForBlobBackupDatasourceParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForBlobBackupDatasourceParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BlobBackupDatasourceParameters_STATUS populates the provided destination BlobBackupDatasourceParameters_STATUS from our BlobBackupDatasourceParameters_STATUS
func (parameters *BlobBackupDatasourceParameters_STATUS) AssignProperties_To_BlobBackupDatasourceParameters_STATUS(destination *v20231201s.BlobBackupDatasourceParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ContainersList
	destination.ContainersList = genruntime.CloneSliceOfString(parameters.ContainersList)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(parameters.ObjectType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBlobBackupDatasourceParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForBlobBackupDatasourceParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.KubernetesClusterBackupDatasourceParameters
type KubernetesClusterBackupDatasourceParameters struct {
	ExcludedNamespaces           []string               `json:"excludedNamespaces,omitempty"`
	ExcludedResourceTypes        []string               `json:"excludedResourceTypes,omitempty"`
	IncludeClusterScopeResources *bool                  `json:"includeClusterScopeResources,omitempty"`
	IncludedNamespaces           []string               `json:"includedNamespaces,omitempty"`
	IncludedResourceTypes        []string               `json:"includedResourceTypes,omitempty"`
	LabelSelectors               []string               `json:"labelSelectors,omitempty"`
	ObjectType                   *string                `json:"objectType,omitempty"`
	PropertyBag                  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SnapshotVolumes              *bool                  `json:"snapshotVolumes,omitempty"`
}

// AssignProperties_From_KubernetesClusterBackupDatasourceParameters populates our KubernetesClusterBackupDatasourceParameters from the provided source KubernetesClusterBackupDatasourceParameters
func (parameters *KubernetesClusterBackupDatasourceParameters) AssignProperties_From_KubernetesClusterBackupDatasourceParameters(source *v20231201s.KubernetesClusterBackupDatasourceParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackupHookReferences
	if len(source.BackupHookReferences) > 0 {
		propertyBag.Add("BackupHookReferences", source.BackupHookReferences)
	} else {
		propertyBag.Remove("BackupHookReferences")
	}

	// ExcludedNamespaces
	parameters.ExcludedNamespaces = genruntime.CloneSliceOfString(source.ExcludedNamespaces)

	// ExcludedResourceTypes
	parameters.ExcludedResourceTypes = genruntime.CloneSliceOfString(source.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if source.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *source.IncludeClusterScopeResources
		parameters.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		parameters.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	parameters.IncludedNamespaces = genruntime.CloneSliceOfString(source.IncludedNamespaces)

	// IncludedResourceTypes
	parameters.IncludedResourceTypes = genruntime.CloneSliceOfString(source.IncludedResourceTypes)

	// LabelSelectors
	parameters.LabelSelectors = genruntime.CloneSliceOfString(source.LabelSelectors)

	// ObjectType
	parameters.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// SnapshotVolumes
	if source.SnapshotVolumes != nil {
		snapshotVolume := *source.SnapshotVolumes
		parameters.SnapshotVolumes = &snapshotVolume
	} else {
		parameters.SnapshotVolumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForKubernetesClusterBackupDatasourceParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForKubernetesClusterBackupDatasourceParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KubernetesClusterBackupDatasourceParameters populates the provided destination KubernetesClusterBackupDatasourceParameters from our KubernetesClusterBackupDatasourceParameters
func (parameters *KubernetesClusterBackupDatasourceParameters) AssignProperties_To_KubernetesClusterBackupDatasourceParameters(destination *v20231201s.KubernetesClusterBackupDatasourceParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// BackupHookReferences
	if propertyBag.Contains("BackupHookReferences") {
		var backupHookReference []v20231201s.NamespacedNameResource
		err := propertyBag.Pull("BackupHookReferences", &backupHookReference)
		if err != nil {
			return errors.Wrap(err, "pulling 'BackupHookReferences' from propertyBag")
		}

		destination.BackupHookReferences = backupHookReference
	} else {
		destination.BackupHookReferences = nil
	}

	// ExcludedNamespaces
	destination.ExcludedNamespaces = genruntime.CloneSliceOfString(parameters.ExcludedNamespaces)

	// ExcludedResourceTypes
	destination.ExcludedResourceTypes = genruntime.CloneSliceOfString(parameters.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if parameters.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *parameters.IncludeClusterScopeResources
		destination.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		destination.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	destination.IncludedNamespaces = genruntime.CloneSliceOfString(parameters.IncludedNamespaces)

	// IncludedResourceTypes
	destination.IncludedResourceTypes = genruntime.CloneSliceOfString(parameters.IncludedResourceTypes)

	// LabelSelectors
	destination.LabelSelectors = genruntime.CloneSliceOfString(parameters.LabelSelectors)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(parameters.ObjectType)

	// SnapshotVolumes
	if parameters.SnapshotVolumes != nil {
		snapshotVolume := *parameters.SnapshotVolumes
		destination.SnapshotVolumes = &snapshotVolume
	} else {
		destination.SnapshotVolumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKubernetesClusterBackupDatasourceParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForKubernetesClusterBackupDatasourceParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230101.KubernetesClusterBackupDatasourceParameters_STATUS
type KubernetesClusterBackupDatasourceParameters_STATUS struct {
	ExcludedNamespaces           []string               `json:"excludedNamespaces,omitempty"`
	ExcludedResourceTypes        []string               `json:"excludedResourceTypes,omitempty"`
	IncludeClusterScopeResources *bool                  `json:"includeClusterScopeResources,omitempty"`
	IncludedNamespaces           []string               `json:"includedNamespaces,omitempty"`
	IncludedResourceTypes        []string               `json:"includedResourceTypes,omitempty"`
	LabelSelectors               []string               `json:"labelSelectors,omitempty"`
	ObjectType                   *string                `json:"objectType,omitempty"`
	PropertyBag                  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SnapshotVolumes              *bool                  `json:"snapshotVolumes,omitempty"`
}

// AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS populates our KubernetesClusterBackupDatasourceParameters_STATUS from the provided source KubernetesClusterBackupDatasourceParameters_STATUS
func (parameters *KubernetesClusterBackupDatasourceParameters_STATUS) AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS(source *v20231201s.KubernetesClusterBackupDatasourceParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackupHookReferences
	if len(source.BackupHookReferences) > 0 {
		propertyBag.Add("BackupHookReferences", source.BackupHookReferences)
	} else {
		propertyBag.Remove("BackupHookReferences")
	}

	// ExcludedNamespaces
	parameters.ExcludedNamespaces = genruntime.CloneSliceOfString(source.ExcludedNamespaces)

	// ExcludedResourceTypes
	parameters.ExcludedResourceTypes = genruntime.CloneSliceOfString(source.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if source.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *source.IncludeClusterScopeResources
		parameters.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		parameters.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	parameters.IncludedNamespaces = genruntime.CloneSliceOfString(source.IncludedNamespaces)

	// IncludedResourceTypes
	parameters.IncludedResourceTypes = genruntime.CloneSliceOfString(source.IncludedResourceTypes)

	// LabelSelectors
	parameters.LabelSelectors = genruntime.CloneSliceOfString(source.LabelSelectors)

	// ObjectType
	parameters.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// SnapshotVolumes
	if source.SnapshotVolumes != nil {
		snapshotVolume := *source.SnapshotVolumes
		parameters.SnapshotVolumes = &snapshotVolume
	} else {
		parameters.SnapshotVolumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForKubernetesClusterBackupDatasourceParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForKubernetesClusterBackupDatasourceParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS populates the provided destination KubernetesClusterBackupDatasourceParameters_STATUS from our KubernetesClusterBackupDatasourceParameters_STATUS
func (parameters *KubernetesClusterBackupDatasourceParameters_STATUS) AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS(destination *v20231201s.KubernetesClusterBackupDatasourceParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// BackupHookReferences
	if propertyBag.Contains("BackupHookReferences") {
		var backupHookReference []v20231201s.NamespacedNameResource_STATUS
		err := propertyBag.Pull("BackupHookReferences", &backupHookReference)
		if err != nil {
			return errors.Wrap(err, "pulling 'BackupHookReferences' from propertyBag")
		}

		destination.BackupHookReferences = backupHookReference
	} else {
		destination.BackupHookReferences = nil
	}

	// ExcludedNamespaces
	destination.ExcludedNamespaces = genruntime.CloneSliceOfString(parameters.ExcludedNamespaces)

	// ExcludedResourceTypes
	destination.ExcludedResourceTypes = genruntime.CloneSliceOfString(parameters.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if parameters.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *parameters.IncludeClusterScopeResources
		destination.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		destination.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	destination.IncludedNamespaces = genruntime.CloneSliceOfString(parameters.IncludedNamespaces)

	// IncludedResourceTypes
	destination.IncludedResourceTypes = genruntime.CloneSliceOfString(parameters.IncludedResourceTypes)

	// LabelSelectors
	destination.LabelSelectors = genruntime.CloneSliceOfString(parameters.LabelSelectors)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(parameters.ObjectType)

	// SnapshotVolumes
	if parameters.SnapshotVolumes != nil {
		snapshotVolume := *parameters.SnapshotVolumes
		destination.SnapshotVolumes = &snapshotVolume
	} else {
		destination.SnapshotVolumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKubernetesClusterBackupDatasourceParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForKubernetesClusterBackupDatasourceParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAzureOperationalStoreParameters interface {
	AssignPropertiesFrom(src *v20231201s.AzureOperationalStoreParameters) error
	AssignPropertiesTo(dst *v20231201s.AzureOperationalStoreParameters) error
}

type augmentConversionForAzureOperationalStoreParameters_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.AzureOperationalStoreParameters_STATUS) error
	AssignPropertiesTo(dst *v20231201s.AzureOperationalStoreParameters_STATUS) error
}

type augmentConversionForBlobBackupDatasourceParameters interface {
	AssignPropertiesFrom(src *v20231201s.BlobBackupDatasourceParameters) error
	AssignPropertiesTo(dst *v20231201s.BlobBackupDatasourceParameters) error
}

type augmentConversionForBlobBackupDatasourceParameters_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.BlobBackupDatasourceParameters_STATUS) error
	AssignPropertiesTo(dst *v20231201s.BlobBackupDatasourceParameters_STATUS) error
}

type augmentConversionForKubernetesClusterBackupDatasourceParameters interface {
	AssignPropertiesFrom(src *v20231201s.KubernetesClusterBackupDatasourceParameters) error
	AssignPropertiesTo(dst *v20231201s.KubernetesClusterBackupDatasourceParameters) error
}

type augmentConversionForKubernetesClusterBackupDatasourceParameters_STATUS interface {
	AssignPropertiesFrom(src *v20231201s.KubernetesClusterBackupDatasourceParameters_STATUS) error
	AssignPropertiesTo(dst *v20231201s.KubernetesClusterBackupDatasourceParameters_STATUS) error
}

func init() {
	SchemeBuilder.Register(&BackupVaultsBackupInstance{}, &BackupVaultsBackupInstanceList{})
}
