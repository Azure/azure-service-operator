// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230101

import (
	"encoding/json"
	v1api20230101s "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20230101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BackupVaultsBackupInstance_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupVaultsBackupInstance to hub returns original",
		prop.ForAll(RunResourceConversionTestForBackupVaultsBackupInstance, BackupVaultsBackupInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForBackupVaultsBackupInstance tests if a specific instance of BackupVaultsBackupInstance round trips to the hub storage version and back losslessly
func RunResourceConversionTestForBackupVaultsBackupInstance(subject BackupVaultsBackupInstance) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1api20230101s.BackupVaultsBackupInstance
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual BackupVaultsBackupInstance
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupVaultsBackupInstance_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupVaultsBackupInstance to BackupVaultsBackupInstance via AssignProperties_To_BackupVaultsBackupInstance & AssignProperties_From_BackupVaultsBackupInstance returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupVaultsBackupInstance, BackupVaultsBackupInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupVaultsBackupInstance tests if a specific instance of BackupVaultsBackupInstance can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBackupVaultsBackupInstance(subject BackupVaultsBackupInstance) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BackupVaultsBackupInstance
	err := copied.AssignProperties_To_BackupVaultsBackupInstance(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupVaultsBackupInstance
	err = actual.AssignProperties_From_BackupVaultsBackupInstance(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupVaultsBackupInstance_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaultsBackupInstance via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaultsBackupInstance, BackupVaultsBackupInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaultsBackupInstance runs a test to see if a specific instance of BackupVaultsBackupInstance round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaultsBackupInstance(subject BackupVaultsBackupInstance) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaultsBackupInstance
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaultsBackupInstance instances for property testing - lazily instantiated by
// BackupVaultsBackupInstanceGenerator()
var backupVaultsBackupInstanceGenerator gopter.Gen

// BackupVaultsBackupInstanceGenerator returns a generator of BackupVaultsBackupInstance instances for property testing.
func BackupVaultsBackupInstanceGenerator() gopter.Gen {
	if backupVaultsBackupInstanceGenerator != nil {
		return backupVaultsBackupInstanceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance(generators)
	backupVaultsBackupInstanceGenerator = gen.Struct(reflect.TypeOf(BackupVaultsBackupInstance{}), generators)

	return backupVaultsBackupInstanceGenerator
}

// AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance(gens map[string]gopter.Gen) {
	gens["Spec"] = BackupVaults_BackupInstance_SpecGenerator()
	gens["Status"] = BackupVaults_BackupInstance_STATUSGenerator()
}

func Test_BackupVaults_BackupInstance_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupVaults_BackupInstance_Spec to BackupVaults_BackupInstance_Spec via AssignProperties_To_BackupVaults_BackupInstance_Spec & AssignProperties_From_BackupVaults_BackupInstance_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupVaults_BackupInstance_Spec, BackupVaults_BackupInstance_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupVaults_BackupInstance_Spec tests if a specific instance of BackupVaults_BackupInstance_Spec can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBackupVaults_BackupInstance_Spec(subject BackupVaults_BackupInstance_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BackupVaults_BackupInstance_Spec
	err := copied.AssignProperties_To_BackupVaults_BackupInstance_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupVaults_BackupInstance_Spec
	err = actual.AssignProperties_From_BackupVaults_BackupInstance_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupVaults_BackupInstance_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaults_BackupInstance_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaults_BackupInstance_Spec, BackupVaults_BackupInstance_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaults_BackupInstance_Spec runs a test to see if a specific instance of BackupVaults_BackupInstance_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaults_BackupInstance_Spec(subject BackupVaults_BackupInstance_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaults_BackupInstance_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaults_BackupInstance_Spec instances for property testing - lazily instantiated by
// BackupVaults_BackupInstance_SpecGenerator()
var backupVaults_BackupInstance_SpecGenerator gopter.Gen

// BackupVaults_BackupInstance_SpecGenerator returns a generator of BackupVaults_BackupInstance_Spec instances for property testing.
// We first initialize backupVaults_BackupInstance_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupVaults_BackupInstance_SpecGenerator() gopter.Gen {
	if backupVaults_BackupInstance_SpecGenerator != nil {
		return backupVaults_BackupInstance_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec(generators)
	backupVaults_BackupInstance_SpecGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec(generators)
	AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec(generators)
	backupVaults_BackupInstance_SpecGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_Spec{}), generators)

	return backupVaults_BackupInstance_SpecGenerator
}

// AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackupInstanceGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
}

func Test_BackupVaults_BackupInstance_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupVaults_BackupInstance_STATUS to BackupVaults_BackupInstance_STATUS via AssignProperties_To_BackupVaults_BackupInstance_STATUS & AssignProperties_From_BackupVaults_BackupInstance_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupVaults_BackupInstance_STATUS, BackupVaults_BackupInstance_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupVaults_BackupInstance_STATUS tests if a specific instance of BackupVaults_BackupInstance_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBackupVaults_BackupInstance_STATUS(subject BackupVaults_BackupInstance_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BackupVaults_BackupInstance_STATUS
	err := copied.AssignProperties_To_BackupVaults_BackupInstance_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupVaults_BackupInstance_STATUS
	err = actual.AssignProperties_From_BackupVaults_BackupInstance_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupVaults_BackupInstance_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaults_BackupInstance_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaults_BackupInstance_STATUS, BackupVaults_BackupInstance_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaults_BackupInstance_STATUS runs a test to see if a specific instance of BackupVaults_BackupInstance_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaults_BackupInstance_STATUS(subject BackupVaults_BackupInstance_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaults_BackupInstance_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaults_BackupInstance_STATUS instances for property testing - lazily instantiated by
// BackupVaults_BackupInstance_STATUSGenerator()
var backupVaults_BackupInstance_STATUSGenerator gopter.Gen

// BackupVaults_BackupInstance_STATUSGenerator returns a generator of BackupVaults_BackupInstance_STATUS instances for property testing.
// We first initialize backupVaults_BackupInstance_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupVaults_BackupInstance_STATUSGenerator() gopter.Gen {
	if backupVaults_BackupInstance_STATUSGenerator != nil {
		return backupVaults_BackupInstance_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(generators)
	backupVaults_BackupInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(generators)
	AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(generators)
	backupVaults_BackupInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_STATUS{}), generators)

	return backupVaults_BackupInstance_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackupInstance_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_BackupInstance_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupInstance to BackupInstance via AssignProperties_To_BackupInstance & AssignProperties_From_BackupInstance returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupInstance, BackupInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupInstance tests if a specific instance of BackupInstance can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBackupInstance(subject BackupInstance) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BackupInstance
	err := copied.AssignProperties_To_BackupInstance(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupInstance
	err = actual.AssignProperties_From_BackupInstance(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupInstance_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupInstance via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupInstance, BackupInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupInstance runs a test to see if a specific instance of BackupInstance round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupInstance(subject BackupInstance) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupInstance
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupInstance instances for property testing - lazily instantiated by BackupInstanceGenerator()
var backupInstanceGenerator gopter.Gen

// BackupInstanceGenerator returns a generator of BackupInstance instances for property testing.
// We first initialize backupInstanceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupInstanceGenerator() gopter.Gen {
	if backupInstanceGenerator != nil {
		return backupInstanceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance(generators)
	backupInstanceGenerator = gen.Struct(reflect.TypeOf(BackupInstance{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance(generators)
	AddRelatedPropertyGeneratorsForBackupInstance(generators)
	backupInstanceGenerator = gen.Struct(reflect.TypeOf(BackupInstance{}), generators)

	return backupInstanceGenerator
}

// AddIndependentPropertyGeneratorsForBackupInstance is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupInstance(gens map[string]gopter.Gen) {
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationType"] = gen.PtrOf(gen.OneConstOf(BackupInstance_ValidationType_DeepValidation, BackupInstance_ValidationType_ShallowValidation))
}

// AddRelatedPropertyGeneratorsForBackupInstance is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupInstance(gens map[string]gopter.Gen) {
	gens["DataSourceInfo"] = gen.PtrOf(DatasourceGenerator())
	gens["DataSourceSetInfo"] = gen.PtrOf(DatasourceSetGenerator())
	gens["DatasourceAuthCredentials"] = gen.PtrOf(AuthCredentialsGenerator())
	gens["PolicyInfo"] = gen.PtrOf(PolicyInfoGenerator())
}

func Test_BackupInstance_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupInstance_STATUS to BackupInstance_STATUS via AssignProperties_To_BackupInstance_STATUS & AssignProperties_From_BackupInstance_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupInstance_STATUS, BackupInstance_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupInstance_STATUS tests if a specific instance of BackupInstance_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBackupInstance_STATUS(subject BackupInstance_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BackupInstance_STATUS
	err := copied.AssignProperties_To_BackupInstance_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupInstance_STATUS
	err = actual.AssignProperties_From_BackupInstance_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupInstance_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupInstance_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupInstance_STATUS, BackupInstance_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupInstance_STATUS runs a test to see if a specific instance of BackupInstance_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupInstance_STATUS(subject BackupInstance_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupInstance_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupInstance_STATUS instances for property testing - lazily instantiated by
// BackupInstance_STATUSGenerator()
var backupInstance_STATUSGenerator gopter.Gen

// BackupInstance_STATUSGenerator returns a generator of BackupInstance_STATUS instances for property testing.
// We first initialize backupInstance_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupInstance_STATUSGenerator() gopter.Gen {
	if backupInstance_STATUSGenerator != nil {
		return backupInstance_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance_STATUS(generators)
	backupInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupInstance_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance_STATUS(generators)
	AddRelatedPropertyGeneratorsForBackupInstance_STATUS(generators)
	backupInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupInstance_STATUS{}), generators)

	return backupInstance_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackupInstance_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupInstance_STATUS(gens map[string]gopter.Gen) {
	gens["CurrentProtectionState"] = gen.PtrOf(gen.OneConstOf(
		BackupInstance_CurrentProtectionState_STATUS_BackupSchedulesSuspended,
		BackupInstance_CurrentProtectionState_STATUS_ConfiguringProtection,
		BackupInstance_CurrentProtectionState_STATUS_ConfiguringProtectionFailed,
		BackupInstance_CurrentProtectionState_STATUS_Invalid,
		BackupInstance_CurrentProtectionState_STATUS_NotProtected,
		BackupInstance_CurrentProtectionState_STATUS_ProtectionConfigured,
		BackupInstance_CurrentProtectionState_STATUS_ProtectionError,
		BackupInstance_CurrentProtectionState_STATUS_ProtectionStopped,
		BackupInstance_CurrentProtectionState_STATUS_RetentionSchedulesSuspended,
		BackupInstance_CurrentProtectionState_STATUS_SoftDeleted,
		BackupInstance_CurrentProtectionState_STATUS_SoftDeleting,
		BackupInstance_CurrentProtectionState_STATUS_UpdatingProtection))
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationType"] = gen.PtrOf(gen.OneConstOf(BackupInstance_ValidationType_STATUS_DeepValidation, BackupInstance_ValidationType_STATUS_ShallowValidation))
}

// AddRelatedPropertyGeneratorsForBackupInstance_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupInstance_STATUS(gens map[string]gopter.Gen) {
	gens["DataSourceInfo"] = gen.PtrOf(Datasource_STATUSGenerator())
	gens["DataSourceSetInfo"] = gen.PtrOf(DatasourceSet_STATUSGenerator())
	gens["DatasourceAuthCredentials"] = gen.PtrOf(AuthCredentials_STATUSGenerator())
	gens["PolicyInfo"] = gen.PtrOf(PolicyInfo_STATUSGenerator())
	gens["ProtectionErrorDetails"] = gen.PtrOf(UserFacingError_STATUSGenerator())
	gens["ProtectionStatus"] = gen.PtrOf(ProtectionStatusDetails_STATUSGenerator())
}

func Test_SystemData_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData to SystemData via AssignProperties_To_SystemData & AssignProperties_From_SystemData returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData, SystemDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData tests if a specific instance of SystemData can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForSystemData(subject SystemData) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.SystemData
	err := copied.AssignProperties_To_SystemData(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData
	err = actual.AssignProperties_From_SystemData(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData, SystemDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData runs a test to see if a specific instance of SystemData round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData(subject SystemData) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData instances for property testing - lazily instantiated by SystemDataGenerator()
var systemDataGenerator gopter.Gen

// SystemDataGenerator returns a generator of SystemData instances for property testing.
func SystemDataGenerator() gopter.Gen {
	if systemDataGenerator != nil {
		return systemDataGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData(generators)
	systemDataGenerator = gen.Struct(reflect.TypeOf(SystemData{}), generators)

	return systemDataGenerator
}

// AddIndependentPropertyGeneratorsForSystemData is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_Application,
		SystemData_CreatedByType_Key,
		SystemData_CreatedByType_ManagedIdentity,
		SystemData_CreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_Application,
		SystemData_LastModifiedByType_Key,
		SystemData_LastModifiedByType_ManagedIdentity,
		SystemData_LastModifiedByType_User))
}

func Test_AuthCredentials_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AuthCredentials to AuthCredentials via AssignProperties_To_AuthCredentials & AssignProperties_From_AuthCredentials returns original",
		prop.ForAll(RunPropertyAssignmentTestForAuthCredentials, AuthCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAuthCredentials tests if a specific instance of AuthCredentials can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAuthCredentials(subject AuthCredentials) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.AuthCredentials
	err := copied.AssignProperties_To_AuthCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AuthCredentials
	err = actual.AssignProperties_From_AuthCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AuthCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthCredentials, AuthCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthCredentials runs a test to see if a specific instance of AuthCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthCredentials(subject AuthCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthCredentials instances for property testing - lazily instantiated by AuthCredentialsGenerator()
var authCredentialsGenerator gopter.Gen

// AuthCredentialsGenerator returns a generator of AuthCredentials instances for property testing.
func AuthCredentialsGenerator() gopter.Gen {
	if authCredentialsGenerator != nil {
		return authCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAuthCredentials(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AuthCredentials{}), map[string]gopter.Gen{propName: propGen}))
	}
	authCredentialsGenerator = gen.OneGenOf(gens...)

	return authCredentialsGenerator
}

// AddRelatedPropertyGeneratorsForAuthCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthCredentials(gens map[string]gopter.Gen) {
	gens["SecretStoreBasedAuthCredentials"] = SecretStoreBasedAuthCredentialsGenerator().Map(func(it SecretStoreBasedAuthCredentials) *SecretStoreBasedAuthCredentials {
		return &it
	}) // generate one case for OneOf type
}

func Test_AuthCredentials_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AuthCredentials_STATUS to AuthCredentials_STATUS via AssignProperties_To_AuthCredentials_STATUS & AssignProperties_From_AuthCredentials_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAuthCredentials_STATUS, AuthCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAuthCredentials_STATUS tests if a specific instance of AuthCredentials_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAuthCredentials_STATUS(subject AuthCredentials_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.AuthCredentials_STATUS
	err := copied.AssignProperties_To_AuthCredentials_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AuthCredentials_STATUS
	err = actual.AssignProperties_From_AuthCredentials_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AuthCredentials_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthCredentials_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthCredentials_STATUS, AuthCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthCredentials_STATUS runs a test to see if a specific instance of AuthCredentials_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthCredentials_STATUS(subject AuthCredentials_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthCredentials_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthCredentials_STATUS instances for property testing - lazily instantiated by
// AuthCredentials_STATUSGenerator()
var authCredentials_STATUSGenerator gopter.Gen

// AuthCredentials_STATUSGenerator returns a generator of AuthCredentials_STATUS instances for property testing.
func AuthCredentials_STATUSGenerator() gopter.Gen {
	if authCredentials_STATUSGenerator != nil {
		return authCredentials_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAuthCredentials_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AuthCredentials_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	authCredentials_STATUSGenerator = gen.OneGenOf(gens...)

	return authCredentials_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForAuthCredentials_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["SecretStoreBasedAuthCredentials"] = SecretStoreBasedAuthCredentials_STATUSGenerator().Map(func(it SecretStoreBasedAuthCredentials_STATUS) *SecretStoreBasedAuthCredentials_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_Datasource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Datasource to Datasource via AssignProperties_To_Datasource & AssignProperties_From_Datasource returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatasource, DatasourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatasource tests if a specific instance of Datasource can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForDatasource(subject Datasource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.Datasource
	err := copied.AssignProperties_To_Datasource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Datasource
	err = actual.AssignProperties_From_Datasource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Datasource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Datasource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasource, DatasourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasource runs a test to see if a specific instance of Datasource round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasource(subject Datasource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Datasource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Datasource instances for property testing - lazily instantiated by DatasourceGenerator()
var datasourceGenerator gopter.Gen

// DatasourceGenerator returns a generator of Datasource instances for property testing.
func DatasourceGenerator() gopter.Gen {
	if datasourceGenerator != nil {
		return datasourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasource(generators)
	datasourceGenerator = gen.Struct(reflect.TypeOf(Datasource{}), generators)

	return datasourceGenerator
}

// AddIndependentPropertyGeneratorsForDatasource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasource(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_Datasource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Datasource_STATUS to Datasource_STATUS via AssignProperties_To_Datasource_STATUS & AssignProperties_From_Datasource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatasource_STATUS, Datasource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatasource_STATUS tests if a specific instance of Datasource_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForDatasource_STATUS(subject Datasource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.Datasource_STATUS
	err := copied.AssignProperties_To_Datasource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Datasource_STATUS
	err = actual.AssignProperties_From_Datasource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Datasource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Datasource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasource_STATUS, Datasource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasource_STATUS runs a test to see if a specific instance of Datasource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasource_STATUS(subject Datasource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Datasource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Datasource_STATUS instances for property testing - lazily instantiated by Datasource_STATUSGenerator()
var datasource_STATUSGenerator gopter.Gen

// Datasource_STATUSGenerator returns a generator of Datasource_STATUS instances for property testing.
func Datasource_STATUSGenerator() gopter.Gen {
	if datasource_STATUSGenerator != nil {
		return datasource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasource_STATUS(generators)
	datasource_STATUSGenerator = gen.Struct(reflect.TypeOf(Datasource_STATUS{}), generators)

	return datasource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDatasource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasource_STATUS(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceID"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DatasourceSet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatasourceSet to DatasourceSet via AssignProperties_To_DatasourceSet & AssignProperties_From_DatasourceSet returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatasourceSet, DatasourceSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatasourceSet tests if a specific instance of DatasourceSet can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForDatasourceSet(subject DatasourceSet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.DatasourceSet
	err := copied.AssignProperties_To_DatasourceSet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatasourceSet
	err = actual.AssignProperties_From_DatasourceSet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatasourceSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatasourceSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasourceSet, DatasourceSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasourceSet runs a test to see if a specific instance of DatasourceSet round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasourceSet(subject DatasourceSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatasourceSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatasourceSet instances for property testing - lazily instantiated by DatasourceSetGenerator()
var datasourceSetGenerator gopter.Gen

// DatasourceSetGenerator returns a generator of DatasourceSet instances for property testing.
func DatasourceSetGenerator() gopter.Gen {
	if datasourceSetGenerator != nil {
		return datasourceSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasourceSet(generators)
	datasourceSetGenerator = gen.Struct(reflect.TypeOf(DatasourceSet{}), generators)

	return datasourceSetGenerator
}

// AddIndependentPropertyGeneratorsForDatasourceSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasourceSet(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DatasourceSet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatasourceSet_STATUS to DatasourceSet_STATUS via AssignProperties_To_DatasourceSet_STATUS & AssignProperties_From_DatasourceSet_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatasourceSet_STATUS, DatasourceSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatasourceSet_STATUS tests if a specific instance of DatasourceSet_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForDatasourceSet_STATUS(subject DatasourceSet_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.DatasourceSet_STATUS
	err := copied.AssignProperties_To_DatasourceSet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatasourceSet_STATUS
	err = actual.AssignProperties_From_DatasourceSet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatasourceSet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatasourceSet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasourceSet_STATUS, DatasourceSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasourceSet_STATUS runs a test to see if a specific instance of DatasourceSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasourceSet_STATUS(subject DatasourceSet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatasourceSet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatasourceSet_STATUS instances for property testing - lazily instantiated by
// DatasourceSet_STATUSGenerator()
var datasourceSet_STATUSGenerator gopter.Gen

// DatasourceSet_STATUSGenerator returns a generator of DatasourceSet_STATUS instances for property testing.
func DatasourceSet_STATUSGenerator() gopter.Gen {
	if datasourceSet_STATUSGenerator != nil {
		return datasourceSet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasourceSet_STATUS(generators)
	datasourceSet_STATUSGenerator = gen.Struct(reflect.TypeOf(DatasourceSet_STATUS{}), generators)

	return datasourceSet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDatasourceSet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasourceSet_STATUS(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceID"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_PolicyInfo_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicyInfo to PolicyInfo via AssignProperties_To_PolicyInfo & AssignProperties_From_PolicyInfo returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicyInfo, PolicyInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicyInfo tests if a specific instance of PolicyInfo can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForPolicyInfo(subject PolicyInfo) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.PolicyInfo
	err := copied.AssignProperties_To_PolicyInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicyInfo
	err = actual.AssignProperties_From_PolicyInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicyInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyInfo, PolicyInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyInfo runs a test to see if a specific instance of PolicyInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyInfo(subject PolicyInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyInfo instances for property testing - lazily instantiated by PolicyInfoGenerator()
var policyInfoGenerator gopter.Gen

// PolicyInfoGenerator returns a generator of PolicyInfo instances for property testing.
// We first initialize policyInfoGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicyInfoGenerator() gopter.Gen {
	if policyInfoGenerator != nil {
		return policyInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo(generators)
	policyInfoGenerator = gen.Struct(reflect.TypeOf(PolicyInfo{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo(generators)
	AddRelatedPropertyGeneratorsForPolicyInfo(generators)
	policyInfoGenerator = gen.Struct(reflect.TypeOf(PolicyInfo{}), generators)

	return policyInfoGenerator
}

// AddIndependentPropertyGeneratorsForPolicyInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicyInfo(gens map[string]gopter.Gen) {
	gens["PolicyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPolicyInfo is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyInfo(gens map[string]gopter.Gen) {
	gens["PolicyParameters"] = gen.PtrOf(PolicyParametersGenerator())
}

func Test_PolicyInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicyInfo_STATUS to PolicyInfo_STATUS via AssignProperties_To_PolicyInfo_STATUS & AssignProperties_From_PolicyInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicyInfo_STATUS, PolicyInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicyInfo_STATUS tests if a specific instance of PolicyInfo_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForPolicyInfo_STATUS(subject PolicyInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.PolicyInfo_STATUS
	err := copied.AssignProperties_To_PolicyInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicyInfo_STATUS
	err = actual.AssignProperties_From_PolicyInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicyInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyInfo_STATUS, PolicyInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyInfo_STATUS runs a test to see if a specific instance of PolicyInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyInfo_STATUS(subject PolicyInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyInfo_STATUS instances for property testing - lazily instantiated by PolicyInfo_STATUSGenerator()
var policyInfo_STATUSGenerator gopter.Gen

// PolicyInfo_STATUSGenerator returns a generator of PolicyInfo_STATUS instances for property testing.
// We first initialize policyInfo_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicyInfo_STATUSGenerator() gopter.Gen {
	if policyInfo_STATUSGenerator != nil {
		return policyInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo_STATUS(generators)
	policyInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicyInfo_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo_STATUS(generators)
	AddRelatedPropertyGeneratorsForPolicyInfo_STATUS(generators)
	policyInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicyInfo_STATUS{}), generators)

	return policyInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPolicyInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicyInfo_STATUS(gens map[string]gopter.Gen) {
	gens["PolicyId"] = gen.PtrOf(gen.AlphaString())
	gens["PolicyVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPolicyInfo_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyInfo_STATUS(gens map[string]gopter.Gen) {
	gens["PolicyParameters"] = gen.PtrOf(PolicyParameters_STATUSGenerator())
}

func Test_ProtectionStatusDetails_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProtectionStatusDetails_STATUS to ProtectionStatusDetails_STATUS via AssignProperties_To_ProtectionStatusDetails_STATUS & AssignProperties_From_ProtectionStatusDetails_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForProtectionStatusDetails_STATUS, ProtectionStatusDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProtectionStatusDetails_STATUS tests if a specific instance of ProtectionStatusDetails_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForProtectionStatusDetails_STATUS(subject ProtectionStatusDetails_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.ProtectionStatusDetails_STATUS
	err := copied.AssignProperties_To_ProtectionStatusDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProtectionStatusDetails_STATUS
	err = actual.AssignProperties_From_ProtectionStatusDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProtectionStatusDetails_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProtectionStatusDetails_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProtectionStatusDetails_STATUS, ProtectionStatusDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProtectionStatusDetails_STATUS runs a test to see if a specific instance of ProtectionStatusDetails_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForProtectionStatusDetails_STATUS(subject ProtectionStatusDetails_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProtectionStatusDetails_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProtectionStatusDetails_STATUS instances for property testing - lazily instantiated by
// ProtectionStatusDetails_STATUSGenerator()
var protectionStatusDetails_STATUSGenerator gopter.Gen

// ProtectionStatusDetails_STATUSGenerator returns a generator of ProtectionStatusDetails_STATUS instances for property testing.
// We first initialize protectionStatusDetails_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProtectionStatusDetails_STATUSGenerator() gopter.Gen {
	if protectionStatusDetails_STATUSGenerator != nil {
		return protectionStatusDetails_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProtectionStatusDetails_STATUS(generators)
	protectionStatusDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(ProtectionStatusDetails_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProtectionStatusDetails_STATUS(generators)
	AddRelatedPropertyGeneratorsForProtectionStatusDetails_STATUS(generators)
	protectionStatusDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(ProtectionStatusDetails_STATUS{}), generators)

	return protectionStatusDetails_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForProtectionStatusDetails_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProtectionStatusDetails_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		ProtectionStatusDetails_Status_STATUS_ConfiguringProtection,
		ProtectionStatusDetails_Status_STATUS_ConfiguringProtectionFailed,
		ProtectionStatusDetails_Status_STATUS_ProtectionConfigured,
		ProtectionStatusDetails_Status_STATUS_ProtectionStopped,
		ProtectionStatusDetails_Status_STATUS_SoftDeleted,
		ProtectionStatusDetails_Status_STATUS_SoftDeleting))
}

// AddRelatedPropertyGeneratorsForProtectionStatusDetails_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProtectionStatusDetails_STATUS(gens map[string]gopter.Gen) {
	gens["ErrorDetails"] = gen.PtrOf(UserFacingError_STATUSGenerator())
}

func Test_UserFacingError_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserFacingError_STATUS to UserFacingError_STATUS via AssignProperties_To_UserFacingError_STATUS & AssignProperties_From_UserFacingError_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserFacingError_STATUS, UserFacingError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserFacingError_STATUS tests if a specific instance of UserFacingError_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForUserFacingError_STATUS(subject UserFacingError_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.UserFacingError_STATUS
	err := copied.AssignProperties_To_UserFacingError_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserFacingError_STATUS
	err = actual.AssignProperties_From_UserFacingError_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserFacingError_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserFacingError_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserFacingError_STATUS, UserFacingError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserFacingError_STATUS runs a test to see if a specific instance of UserFacingError_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserFacingError_STATUS(subject UserFacingError_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserFacingError_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserFacingError_STATUS instances for property testing - lazily instantiated by
// UserFacingError_STATUSGenerator()
var userFacingError_STATUSGenerator gopter.Gen

// UserFacingError_STATUSGenerator returns a generator of UserFacingError_STATUS instances for property testing.
// We first initialize userFacingError_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UserFacingError_STATUSGenerator() gopter.Gen {
	if userFacingError_STATUSGenerator != nil {
		return userFacingError_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserFacingError_STATUS(generators)
	userFacingError_STATUSGenerator = gen.Struct(reflect.TypeOf(UserFacingError_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserFacingError_STATUS(generators)
	AddRelatedPropertyGeneratorsForUserFacingError_STATUS(generators)
	userFacingError_STATUSGenerator = gen.Struct(reflect.TypeOf(UserFacingError_STATUS{}), generators)

	return userFacingError_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserFacingError_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserFacingError_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["IsRetryable"] = gen.PtrOf(gen.Bool())
	gens["IsUserError"] = gen.PtrOf(gen.Bool())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["RecommendedAction"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUserFacingError_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUserFacingError_STATUS(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(UserFacingError_STATUS_UnrolledGenerator())
	gens["InnerError"] = gen.PtrOf(InnerError_STATUSGenerator())
}

func Test_InnerError_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InnerError_STATUS to InnerError_STATUS via AssignProperties_To_InnerError_STATUS & AssignProperties_From_InnerError_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForInnerError_STATUS, InnerError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInnerError_STATUS tests if a specific instance of InnerError_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForInnerError_STATUS(subject InnerError_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.InnerError_STATUS
	err := copied.AssignProperties_To_InnerError_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InnerError_STATUS
	err = actual.AssignProperties_From_InnerError_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InnerError_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerError_STATUS, InnerError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerError_STATUS runs a test to see if a specific instance of InnerError_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerError_STATUS(subject InnerError_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_STATUS instances for property testing - lazily instantiated by InnerError_STATUSGenerator()
var innerError_STATUSGenerator gopter.Gen

// InnerError_STATUSGenerator returns a generator of InnerError_STATUS instances for property testing.
// We first initialize innerError_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InnerError_STATUSGenerator() gopter.Gen {
	if innerError_STATUSGenerator != nil {
		return innerError_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_STATUS(generators)
	innerError_STATUSGenerator = gen.Struct(reflect.TypeOf(InnerError_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_STATUS(generators)
	AddRelatedPropertyGeneratorsForInnerError_STATUS(generators)
	innerError_STATUSGenerator = gen.Struct(reflect.TypeOf(InnerError_STATUS{}), generators)

	return innerError_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForInnerError_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerError_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Code"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInnerError_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInnerError_STATUS(gens map[string]gopter.Gen) {
	gens["EmbeddedInnerError"] = gen.PtrOf(InnerError_STATUS_UnrolledGenerator())
}

func Test_PolicyParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicyParameters to PolicyParameters via AssignProperties_To_PolicyParameters & AssignProperties_From_PolicyParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicyParameters, PolicyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicyParameters tests if a specific instance of PolicyParameters can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForPolicyParameters(subject PolicyParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.PolicyParameters
	err := copied.AssignProperties_To_PolicyParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicyParameters
	err = actual.AssignProperties_From_PolicyParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicyParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyParameters, PolicyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyParameters runs a test to see if a specific instance of PolicyParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyParameters(subject PolicyParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyParameters instances for property testing - lazily instantiated by PolicyParametersGenerator()
var policyParametersGenerator gopter.Gen

// PolicyParametersGenerator returns a generator of PolicyParameters instances for property testing.
func PolicyParametersGenerator() gopter.Gen {
	if policyParametersGenerator != nil {
		return policyParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicyParameters(generators)
	policyParametersGenerator = gen.Struct(reflect.TypeOf(PolicyParameters{}), generators)

	return policyParametersGenerator
}

// AddRelatedPropertyGeneratorsForPolicyParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyParameters(gens map[string]gopter.Gen) {
	gens["BackupDatasourceParametersList"] = gen.SliceOf(BackupDatasourceParametersGenerator())
	gens["DataStoreParametersList"] = gen.SliceOf(DataStoreParametersGenerator())
}

func Test_PolicyParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicyParameters_STATUS to PolicyParameters_STATUS via AssignProperties_To_PolicyParameters_STATUS & AssignProperties_From_PolicyParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicyParameters_STATUS, PolicyParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicyParameters_STATUS tests if a specific instance of PolicyParameters_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForPolicyParameters_STATUS(subject PolicyParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.PolicyParameters_STATUS
	err := copied.AssignProperties_To_PolicyParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicyParameters_STATUS
	err = actual.AssignProperties_From_PolicyParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicyParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyParameters_STATUS, PolicyParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyParameters_STATUS runs a test to see if a specific instance of PolicyParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyParameters_STATUS(subject PolicyParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyParameters_STATUS instances for property testing - lazily instantiated by
// PolicyParameters_STATUSGenerator()
var policyParameters_STATUSGenerator gopter.Gen

// PolicyParameters_STATUSGenerator returns a generator of PolicyParameters_STATUS instances for property testing.
func PolicyParameters_STATUSGenerator() gopter.Gen {
	if policyParameters_STATUSGenerator != nil {
		return policyParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicyParameters_STATUS(generators)
	policyParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicyParameters_STATUS{}), generators)

	return policyParameters_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForPolicyParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyParameters_STATUS(gens map[string]gopter.Gen) {
	gens["BackupDatasourceParametersList"] = gen.SliceOf(BackupDatasourceParameters_STATUSGenerator())
	gens["DataStoreParametersList"] = gen.SliceOf(DataStoreParameters_STATUSGenerator())
}

func Test_SecretStoreBasedAuthCredentials_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecretStoreBasedAuthCredentials to SecretStoreBasedAuthCredentials via AssignProperties_To_SecretStoreBasedAuthCredentials & AssignProperties_From_SecretStoreBasedAuthCredentials returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecretStoreBasedAuthCredentials, SecretStoreBasedAuthCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecretStoreBasedAuthCredentials tests if a specific instance of SecretStoreBasedAuthCredentials can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForSecretStoreBasedAuthCredentials(subject SecretStoreBasedAuthCredentials) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.SecretStoreBasedAuthCredentials
	err := copied.AssignProperties_To_SecretStoreBasedAuthCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecretStoreBasedAuthCredentials
	err = actual.AssignProperties_From_SecretStoreBasedAuthCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecretStoreBasedAuthCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreBasedAuthCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreBasedAuthCredentials, SecretStoreBasedAuthCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreBasedAuthCredentials runs a test to see if a specific instance of SecretStoreBasedAuthCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreBasedAuthCredentials(subject SecretStoreBasedAuthCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreBasedAuthCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreBasedAuthCredentials instances for property testing - lazily instantiated by
// SecretStoreBasedAuthCredentialsGenerator()
var secretStoreBasedAuthCredentialsGenerator gopter.Gen

// SecretStoreBasedAuthCredentialsGenerator returns a generator of SecretStoreBasedAuthCredentials instances for property testing.
// We first initialize secretStoreBasedAuthCredentialsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecretStoreBasedAuthCredentialsGenerator() gopter.Gen {
	if secretStoreBasedAuthCredentialsGenerator != nil {
		return secretStoreBasedAuthCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	secretStoreBasedAuthCredentialsGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	secretStoreBasedAuthCredentialsGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials{}), generators)

	return secretStoreBasedAuthCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.PtrOf(gen.OneConstOf(SecretStoreBasedAuthCredentials_ObjectType_SecretStoreBasedAuthCredentials))
}

// AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials(gens map[string]gopter.Gen) {
	gens["SecretStoreResource"] = gen.PtrOf(SecretStoreResourceGenerator())
}

func Test_SecretStoreBasedAuthCredentials_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecretStoreBasedAuthCredentials_STATUS to SecretStoreBasedAuthCredentials_STATUS via AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS & AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecretStoreBasedAuthCredentials_STATUS, SecretStoreBasedAuthCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecretStoreBasedAuthCredentials_STATUS tests if a specific instance of SecretStoreBasedAuthCredentials_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForSecretStoreBasedAuthCredentials_STATUS(subject SecretStoreBasedAuthCredentials_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.SecretStoreBasedAuthCredentials_STATUS
	err := copied.AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecretStoreBasedAuthCredentials_STATUS
	err = actual.AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecretStoreBasedAuthCredentials_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreBasedAuthCredentials_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreBasedAuthCredentials_STATUS, SecretStoreBasedAuthCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreBasedAuthCredentials_STATUS runs a test to see if a specific instance of SecretStoreBasedAuthCredentials_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreBasedAuthCredentials_STATUS(subject SecretStoreBasedAuthCredentials_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreBasedAuthCredentials_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreBasedAuthCredentials_STATUS instances for property testing - lazily instantiated by
// SecretStoreBasedAuthCredentials_STATUSGenerator()
var secretStoreBasedAuthCredentials_STATUSGenerator gopter.Gen

// SecretStoreBasedAuthCredentials_STATUSGenerator returns a generator of SecretStoreBasedAuthCredentials_STATUS instances for property testing.
// We first initialize secretStoreBasedAuthCredentials_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecretStoreBasedAuthCredentials_STATUSGenerator() gopter.Gen {
	if secretStoreBasedAuthCredentials_STATUSGenerator != nil {
		return secretStoreBasedAuthCredentials_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(generators)
	secretStoreBasedAuthCredentials_STATUSGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(generators)
	AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(generators)
	secretStoreBasedAuthCredentials_STATUSGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials_STATUS{}), generators)

	return secretStoreBasedAuthCredentials_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.PtrOf(gen.OneConstOf(SecretStoreBasedAuthCredentials_ObjectType_STATUS_SecretStoreBasedAuthCredentials))
}

// AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["SecretStoreResource"] = gen.PtrOf(SecretStoreResource_STATUSGenerator())
}

func Test_UserFacingError_STATUS_Unrolled_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserFacingError_STATUS_Unrolled to UserFacingError_STATUS_Unrolled via AssignProperties_To_UserFacingError_STATUS_Unrolled & AssignProperties_From_UserFacingError_STATUS_Unrolled returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserFacingError_STATUS_Unrolled, UserFacingError_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserFacingError_STATUS_Unrolled tests if a specific instance of UserFacingError_STATUS_Unrolled can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForUserFacingError_STATUS_Unrolled(subject UserFacingError_STATUS_Unrolled) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.UserFacingError_STATUS_Unrolled
	err := copied.AssignProperties_To_UserFacingError_STATUS_Unrolled(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserFacingError_STATUS_Unrolled
	err = actual.AssignProperties_From_UserFacingError_STATUS_Unrolled(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserFacingError_STATUS_Unrolled_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserFacingError_STATUS_Unrolled via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserFacingError_STATUS_Unrolled, UserFacingError_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserFacingError_STATUS_Unrolled runs a test to see if a specific instance of UserFacingError_STATUS_Unrolled round trips to JSON and back losslessly
func RunJSONSerializationTestForUserFacingError_STATUS_Unrolled(subject UserFacingError_STATUS_Unrolled) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserFacingError_STATUS_Unrolled
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserFacingError_STATUS_Unrolled instances for property testing - lazily instantiated by
// UserFacingError_STATUS_UnrolledGenerator()
var userFacingError_STATUS_UnrolledGenerator gopter.Gen

// UserFacingError_STATUS_UnrolledGenerator returns a generator of UserFacingError_STATUS_Unrolled instances for property testing.
// We first initialize userFacingError_STATUS_UnrolledGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UserFacingError_STATUS_UnrolledGenerator() gopter.Gen {
	if userFacingError_STATUS_UnrolledGenerator != nil {
		return userFacingError_STATUS_UnrolledGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserFacingError_STATUS_Unrolled(generators)
	userFacingError_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(UserFacingError_STATUS_Unrolled{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserFacingError_STATUS_Unrolled(generators)
	AddRelatedPropertyGeneratorsForUserFacingError_STATUS_Unrolled(generators)
	userFacingError_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(UserFacingError_STATUS_Unrolled{}), generators)

	return userFacingError_STATUS_UnrolledGenerator
}

// AddIndependentPropertyGeneratorsForUserFacingError_STATUS_Unrolled is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserFacingError_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["IsRetryable"] = gen.PtrOf(gen.Bool())
	gens["IsUserError"] = gen.PtrOf(gen.Bool())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["RecommendedAction"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUserFacingError_STATUS_Unrolled is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUserFacingError_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["InnerError"] = gen.PtrOf(InnerError_STATUSGenerator())
}

func Test_BackupDatasourceParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupDatasourceParameters to BackupDatasourceParameters via AssignProperties_To_BackupDatasourceParameters & AssignProperties_From_BackupDatasourceParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupDatasourceParameters, BackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupDatasourceParameters tests if a specific instance of BackupDatasourceParameters can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBackupDatasourceParameters(subject BackupDatasourceParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BackupDatasourceParameters
	err := copied.AssignProperties_To_BackupDatasourceParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupDatasourceParameters
	err = actual.AssignProperties_From_BackupDatasourceParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupDatasourceParameters, BackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupDatasourceParameters runs a test to see if a specific instance of BackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupDatasourceParameters(subject BackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupDatasourceParameters instances for property testing - lazily instantiated by
// BackupDatasourceParametersGenerator()
var backupDatasourceParametersGenerator gopter.Gen

// BackupDatasourceParametersGenerator returns a generator of BackupDatasourceParameters instances for property testing.
func BackupDatasourceParametersGenerator() gopter.Gen {
	if backupDatasourceParametersGenerator != nil {
		return backupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupDatasourceParameters(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupDatasourceParameters{}), map[string]gopter.Gen{propName: propGen}))
	}
	backupDatasourceParametersGenerator = gen.OneGenOf(gens...)

	return backupDatasourceParametersGenerator
}

// AddRelatedPropertyGeneratorsForBackupDatasourceParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["Blob"] = BlobBackupDatasourceParametersGenerator().Map(func(it BlobBackupDatasourceParameters) *BlobBackupDatasourceParameters {
		return &it
	}) // generate one case for OneOf type
	gens["KubernetesCluster"] = KubernetesClusterBackupDatasourceParametersGenerator().Map(func(it KubernetesClusterBackupDatasourceParameters) *KubernetesClusterBackupDatasourceParameters {
		return &it
	}) // generate one case for OneOf type
}

func Test_BackupDatasourceParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupDatasourceParameters_STATUS to BackupDatasourceParameters_STATUS via AssignProperties_To_BackupDatasourceParameters_STATUS & AssignProperties_From_BackupDatasourceParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupDatasourceParameters_STATUS, BackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupDatasourceParameters_STATUS tests if a specific instance of BackupDatasourceParameters_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBackupDatasourceParameters_STATUS(subject BackupDatasourceParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BackupDatasourceParameters_STATUS
	err := copied.AssignProperties_To_BackupDatasourceParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupDatasourceParameters_STATUS
	err = actual.AssignProperties_From_BackupDatasourceParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupDatasourceParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupDatasourceParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupDatasourceParameters_STATUS, BackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupDatasourceParameters_STATUS runs a test to see if a specific instance of BackupDatasourceParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupDatasourceParameters_STATUS(subject BackupDatasourceParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupDatasourceParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupDatasourceParameters_STATUS instances for property testing - lazily instantiated by
// BackupDatasourceParameters_STATUSGenerator()
var backupDatasourceParameters_STATUSGenerator gopter.Gen

// BackupDatasourceParameters_STATUSGenerator returns a generator of BackupDatasourceParameters_STATUS instances for property testing.
func BackupDatasourceParameters_STATUSGenerator() gopter.Gen {
	if backupDatasourceParameters_STATUSGenerator != nil {
		return backupDatasourceParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupDatasourceParameters_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupDatasourceParameters_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	backupDatasourceParameters_STATUSGenerator = gen.OneGenOf(gens...)

	return backupDatasourceParameters_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForBackupDatasourceParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupDatasourceParameters_STATUS(gens map[string]gopter.Gen) {
	gens["Blob"] = BlobBackupDatasourceParameters_STATUSGenerator().Map(func(it BlobBackupDatasourceParameters_STATUS) *BlobBackupDatasourceParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["KubernetesCluster"] = KubernetesClusterBackupDatasourceParameters_STATUSGenerator().Map(func(it KubernetesClusterBackupDatasourceParameters_STATUS) *KubernetesClusterBackupDatasourceParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_DataStoreParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataStoreParameters to DataStoreParameters via AssignProperties_To_DataStoreParameters & AssignProperties_From_DataStoreParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataStoreParameters, DataStoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataStoreParameters tests if a specific instance of DataStoreParameters can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForDataStoreParameters(subject DataStoreParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.DataStoreParameters
	err := copied.AssignProperties_To_DataStoreParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataStoreParameters
	err = actual.AssignProperties_From_DataStoreParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataStoreParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataStoreParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataStoreParameters, DataStoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataStoreParameters runs a test to see if a specific instance of DataStoreParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForDataStoreParameters(subject DataStoreParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataStoreParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataStoreParameters instances for property testing - lazily instantiated by
// DataStoreParametersGenerator()
var dataStoreParametersGenerator gopter.Gen

// DataStoreParametersGenerator returns a generator of DataStoreParameters instances for property testing.
func DataStoreParametersGenerator() gopter.Gen {
	if dataStoreParametersGenerator != nil {
		return dataStoreParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataStoreParameters(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DataStoreParameters{}), map[string]gopter.Gen{propName: propGen}))
	}
	dataStoreParametersGenerator = gen.OneGenOf(gens...)

	return dataStoreParametersGenerator
}

// AddRelatedPropertyGeneratorsForDataStoreParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataStoreParameters(gens map[string]gopter.Gen) {
	gens["AzureOperationalStoreParameters"] = AzureOperationalStoreParametersGenerator().Map(func(it AzureOperationalStoreParameters) *AzureOperationalStoreParameters {
		return &it
	}) // generate one case for OneOf type
}

func Test_DataStoreParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataStoreParameters_STATUS to DataStoreParameters_STATUS via AssignProperties_To_DataStoreParameters_STATUS & AssignProperties_From_DataStoreParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataStoreParameters_STATUS, DataStoreParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataStoreParameters_STATUS tests if a specific instance of DataStoreParameters_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForDataStoreParameters_STATUS(subject DataStoreParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.DataStoreParameters_STATUS
	err := copied.AssignProperties_To_DataStoreParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataStoreParameters_STATUS
	err = actual.AssignProperties_From_DataStoreParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataStoreParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataStoreParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataStoreParameters_STATUS, DataStoreParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataStoreParameters_STATUS runs a test to see if a specific instance of DataStoreParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataStoreParameters_STATUS(subject DataStoreParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataStoreParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataStoreParameters_STATUS instances for property testing - lazily instantiated by
// DataStoreParameters_STATUSGenerator()
var dataStoreParameters_STATUSGenerator gopter.Gen

// DataStoreParameters_STATUSGenerator returns a generator of DataStoreParameters_STATUS instances for property testing.
func DataStoreParameters_STATUSGenerator() gopter.Gen {
	if dataStoreParameters_STATUSGenerator != nil {
		return dataStoreParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataStoreParameters_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DataStoreParameters_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	dataStoreParameters_STATUSGenerator = gen.OneGenOf(gens...)

	return dataStoreParameters_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDataStoreParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataStoreParameters_STATUS(gens map[string]gopter.Gen) {
	gens["AzureOperationalStoreParameters"] = AzureOperationalStoreParameters_STATUSGenerator().Map(func(it AzureOperationalStoreParameters_STATUS) *AzureOperationalStoreParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_InnerError_STATUS_Unrolled_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from InnerError_STATUS_Unrolled to InnerError_STATUS_Unrolled via AssignProperties_To_InnerError_STATUS_Unrolled & AssignProperties_From_InnerError_STATUS_Unrolled returns original",
		prop.ForAll(RunPropertyAssignmentTestForInnerError_STATUS_Unrolled, InnerError_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForInnerError_STATUS_Unrolled tests if a specific instance of InnerError_STATUS_Unrolled can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForInnerError_STATUS_Unrolled(subject InnerError_STATUS_Unrolled) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.InnerError_STATUS_Unrolled
	err := copied.AssignProperties_To_InnerError_STATUS_Unrolled(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual InnerError_STATUS_Unrolled
	err = actual.AssignProperties_From_InnerError_STATUS_Unrolled(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_InnerError_STATUS_Unrolled_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_STATUS_Unrolled via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerError_STATUS_Unrolled, InnerError_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerError_STATUS_Unrolled runs a test to see if a specific instance of InnerError_STATUS_Unrolled round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerError_STATUS_Unrolled(subject InnerError_STATUS_Unrolled) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_STATUS_Unrolled
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_STATUS_Unrolled instances for property testing - lazily instantiated by
// InnerError_STATUS_UnrolledGenerator()
var innerError_STATUS_UnrolledGenerator gopter.Gen

// InnerError_STATUS_UnrolledGenerator returns a generator of InnerError_STATUS_Unrolled instances for property testing.
func InnerError_STATUS_UnrolledGenerator() gopter.Gen {
	if innerError_STATUS_UnrolledGenerator != nil {
		return innerError_STATUS_UnrolledGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_STATUS_Unrolled(generators)
	innerError_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(InnerError_STATUS_Unrolled{}), generators)

	return innerError_STATUS_UnrolledGenerator
}

// AddIndependentPropertyGeneratorsForInnerError_STATUS_Unrolled is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerError_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Code"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecretStoreResource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecretStoreResource to SecretStoreResource via AssignProperties_To_SecretStoreResource & AssignProperties_From_SecretStoreResource returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecretStoreResource, SecretStoreResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecretStoreResource tests if a specific instance of SecretStoreResource can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForSecretStoreResource(subject SecretStoreResource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.SecretStoreResource
	err := copied.AssignProperties_To_SecretStoreResource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecretStoreResource
	err = actual.AssignProperties_From_SecretStoreResource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecretStoreResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreResource, SecretStoreResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreResource runs a test to see if a specific instance of SecretStoreResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreResource(subject SecretStoreResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreResource instances for property testing - lazily instantiated by
// SecretStoreResourceGenerator()
var secretStoreResourceGenerator gopter.Gen

// SecretStoreResourceGenerator returns a generator of SecretStoreResource instances for property testing.
func SecretStoreResourceGenerator() gopter.Gen {
	if secretStoreResourceGenerator != nil {
		return secretStoreResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreResource(generators)
	secretStoreResourceGenerator = gen.Struct(reflect.TypeOf(SecretStoreResource{}), generators)

	return secretStoreResourceGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreResource(gens map[string]gopter.Gen) {
	gens["SecretStoreType"] = gen.PtrOf(gen.OneConstOf(SecretStoreResource_SecretStoreType_AzureKeyVault, SecretStoreResource_SecretStoreType_Invalid))
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecretStoreResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecretStoreResource_STATUS to SecretStoreResource_STATUS via AssignProperties_To_SecretStoreResource_STATUS & AssignProperties_From_SecretStoreResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecretStoreResource_STATUS, SecretStoreResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecretStoreResource_STATUS tests if a specific instance of SecretStoreResource_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForSecretStoreResource_STATUS(subject SecretStoreResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.SecretStoreResource_STATUS
	err := copied.AssignProperties_To_SecretStoreResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecretStoreResource_STATUS
	err = actual.AssignProperties_From_SecretStoreResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecretStoreResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreResource_STATUS, SecretStoreResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreResource_STATUS runs a test to see if a specific instance of SecretStoreResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreResource_STATUS(subject SecretStoreResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreResource_STATUS instances for property testing - lazily instantiated by
// SecretStoreResource_STATUSGenerator()
var secretStoreResource_STATUSGenerator gopter.Gen

// SecretStoreResource_STATUSGenerator returns a generator of SecretStoreResource_STATUS instances for property testing.
func SecretStoreResource_STATUSGenerator() gopter.Gen {
	if secretStoreResource_STATUSGenerator != nil {
		return secretStoreResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreResource_STATUS(generators)
	secretStoreResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SecretStoreResource_STATUS{}), generators)

	return secretStoreResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreResource_STATUS(gens map[string]gopter.Gen) {
	gens["SecretStoreType"] = gen.PtrOf(gen.OneConstOf(SecretStoreResource_SecretStoreType_STATUS_AzureKeyVault, SecretStoreResource_SecretStoreType_STATUS_Invalid))
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureOperationalStoreParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureOperationalStoreParameters to AzureOperationalStoreParameters via AssignProperties_To_AzureOperationalStoreParameters & AssignProperties_From_AzureOperationalStoreParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureOperationalStoreParameters, AzureOperationalStoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureOperationalStoreParameters tests if a specific instance of AzureOperationalStoreParameters can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAzureOperationalStoreParameters(subject AzureOperationalStoreParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.AzureOperationalStoreParameters
	err := copied.AssignProperties_To_AzureOperationalStoreParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureOperationalStoreParameters
	err = actual.AssignProperties_From_AzureOperationalStoreParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureOperationalStoreParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureOperationalStoreParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureOperationalStoreParameters, AzureOperationalStoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureOperationalStoreParameters runs a test to see if a specific instance of AzureOperationalStoreParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureOperationalStoreParameters(subject AzureOperationalStoreParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureOperationalStoreParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureOperationalStoreParameters instances for property testing - lazily instantiated by
// AzureOperationalStoreParametersGenerator()
var azureOperationalStoreParametersGenerator gopter.Gen

// AzureOperationalStoreParametersGenerator returns a generator of AzureOperationalStoreParameters instances for property testing.
func AzureOperationalStoreParametersGenerator() gopter.Gen {
	if azureOperationalStoreParametersGenerator != nil {
		return azureOperationalStoreParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters(generators)
	azureOperationalStoreParametersGenerator = gen.Struct(reflect.TypeOf(AzureOperationalStoreParameters{}), generators)

	return azureOperationalStoreParametersGenerator
}

// AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters(gens map[string]gopter.Gen) {
	gens["DataStoreType"] = gen.PtrOf(gen.OneConstOf(AzureOperationalStoreParameters_DataStoreType_ArchiveStore, AzureOperationalStoreParameters_DataStoreType_OperationalStore, AzureOperationalStoreParameters_DataStoreType_VaultStore))
	gens["ObjectType"] = gen.PtrOf(gen.OneConstOf(AzureOperationalStoreParameters_ObjectType_AzureOperationalStoreParameters))
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureOperationalStoreParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureOperationalStoreParameters_STATUS to AzureOperationalStoreParameters_STATUS via AssignProperties_To_AzureOperationalStoreParameters_STATUS & AssignProperties_From_AzureOperationalStoreParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureOperationalStoreParameters_STATUS, AzureOperationalStoreParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureOperationalStoreParameters_STATUS tests if a specific instance of AzureOperationalStoreParameters_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAzureOperationalStoreParameters_STATUS(subject AzureOperationalStoreParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.AzureOperationalStoreParameters_STATUS
	err := copied.AssignProperties_To_AzureOperationalStoreParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureOperationalStoreParameters_STATUS
	err = actual.AssignProperties_From_AzureOperationalStoreParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureOperationalStoreParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureOperationalStoreParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureOperationalStoreParameters_STATUS, AzureOperationalStoreParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureOperationalStoreParameters_STATUS runs a test to see if a specific instance of AzureOperationalStoreParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureOperationalStoreParameters_STATUS(subject AzureOperationalStoreParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureOperationalStoreParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureOperationalStoreParameters_STATUS instances for property testing - lazily instantiated by
// AzureOperationalStoreParameters_STATUSGenerator()
var azureOperationalStoreParameters_STATUSGenerator gopter.Gen

// AzureOperationalStoreParameters_STATUSGenerator returns a generator of AzureOperationalStoreParameters_STATUS instances for property testing.
func AzureOperationalStoreParameters_STATUSGenerator() gopter.Gen {
	if azureOperationalStoreParameters_STATUSGenerator != nil {
		return azureOperationalStoreParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_STATUS(generators)
	azureOperationalStoreParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureOperationalStoreParameters_STATUS{}), generators)

	return azureOperationalStoreParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_STATUS(gens map[string]gopter.Gen) {
	gens["DataStoreType"] = gen.PtrOf(gen.OneConstOf(AzureOperationalStoreParameters_DataStoreType_STATUS_ArchiveStore, AzureOperationalStoreParameters_DataStoreType_STATUS_OperationalStore, AzureOperationalStoreParameters_DataStoreType_STATUS_VaultStore))
	gens["ObjectType"] = gen.PtrOf(gen.OneConstOf(AzureOperationalStoreParameters_ObjectType_STATUS_AzureOperationalStoreParameters))
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobBackupDatasourceParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BlobBackupDatasourceParameters to BlobBackupDatasourceParameters via AssignProperties_To_BlobBackupDatasourceParameters & AssignProperties_From_BlobBackupDatasourceParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForBlobBackupDatasourceParameters, BlobBackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBlobBackupDatasourceParameters tests if a specific instance of BlobBackupDatasourceParameters can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBlobBackupDatasourceParameters(subject BlobBackupDatasourceParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BlobBackupDatasourceParameters
	err := copied.AssignProperties_To_BlobBackupDatasourceParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BlobBackupDatasourceParameters
	err = actual.AssignProperties_From_BlobBackupDatasourceParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BlobBackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobBackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobBackupDatasourceParameters, BlobBackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobBackupDatasourceParameters runs a test to see if a specific instance of BlobBackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobBackupDatasourceParameters(subject BlobBackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobBackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobBackupDatasourceParameters instances for property testing - lazily instantiated by
// BlobBackupDatasourceParametersGenerator()
var blobBackupDatasourceParametersGenerator gopter.Gen

// BlobBackupDatasourceParametersGenerator returns a generator of BlobBackupDatasourceParameters instances for property testing.
func BlobBackupDatasourceParametersGenerator() gopter.Gen {
	if blobBackupDatasourceParametersGenerator != nil {
		return blobBackupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters(generators)
	blobBackupDatasourceParametersGenerator = gen.Struct(reflect.TypeOf(BlobBackupDatasourceParameters{}), generators)

	return blobBackupDatasourceParametersGenerator
}

// AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["ContainersList"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.OneConstOf(BlobBackupDatasourceParameters_ObjectType_BlobBackupDatasourceParameters))
}

func Test_BlobBackupDatasourceParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BlobBackupDatasourceParameters_STATUS to BlobBackupDatasourceParameters_STATUS via AssignProperties_To_BlobBackupDatasourceParameters_STATUS & AssignProperties_From_BlobBackupDatasourceParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBlobBackupDatasourceParameters_STATUS, BlobBackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBlobBackupDatasourceParameters_STATUS tests if a specific instance of BlobBackupDatasourceParameters_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForBlobBackupDatasourceParameters_STATUS(subject BlobBackupDatasourceParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.BlobBackupDatasourceParameters_STATUS
	err := copied.AssignProperties_To_BlobBackupDatasourceParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BlobBackupDatasourceParameters_STATUS
	err = actual.AssignProperties_From_BlobBackupDatasourceParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BlobBackupDatasourceParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobBackupDatasourceParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobBackupDatasourceParameters_STATUS, BlobBackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobBackupDatasourceParameters_STATUS runs a test to see if a specific instance of BlobBackupDatasourceParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobBackupDatasourceParameters_STATUS(subject BlobBackupDatasourceParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobBackupDatasourceParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobBackupDatasourceParameters_STATUS instances for property testing - lazily instantiated by
// BlobBackupDatasourceParameters_STATUSGenerator()
var blobBackupDatasourceParameters_STATUSGenerator gopter.Gen

// BlobBackupDatasourceParameters_STATUSGenerator returns a generator of BlobBackupDatasourceParameters_STATUS instances for property testing.
func BlobBackupDatasourceParameters_STATUSGenerator() gopter.Gen {
	if blobBackupDatasourceParameters_STATUSGenerator != nil {
		return blobBackupDatasourceParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_STATUS(generators)
	blobBackupDatasourceParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(BlobBackupDatasourceParameters_STATUS{}), generators)

	return blobBackupDatasourceParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ContainersList"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.OneConstOf(BlobBackupDatasourceParameters_ObjectType_STATUS_BlobBackupDatasourceParameters))
}

func Test_KubernetesClusterBackupDatasourceParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KubernetesClusterBackupDatasourceParameters to KubernetesClusterBackupDatasourceParameters via AssignProperties_To_KubernetesClusterBackupDatasourceParameters & AssignProperties_From_KubernetesClusterBackupDatasourceParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForKubernetesClusterBackupDatasourceParameters, KubernetesClusterBackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKubernetesClusterBackupDatasourceParameters tests if a specific instance of KubernetesClusterBackupDatasourceParameters can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForKubernetesClusterBackupDatasourceParameters(subject KubernetesClusterBackupDatasourceParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.KubernetesClusterBackupDatasourceParameters
	err := copied.AssignProperties_To_KubernetesClusterBackupDatasourceParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KubernetesClusterBackupDatasourceParameters
	err = actual.AssignProperties_From_KubernetesClusterBackupDatasourceParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KubernetesClusterBackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubernetesClusterBackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters, KubernetesClusterBackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters runs a test to see if a specific instance of KubernetesClusterBackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters(subject KubernetesClusterBackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubernetesClusterBackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubernetesClusterBackupDatasourceParameters instances for property testing - lazily instantiated by
// KubernetesClusterBackupDatasourceParametersGenerator()
var kubernetesClusterBackupDatasourceParametersGenerator gopter.Gen

// KubernetesClusterBackupDatasourceParametersGenerator returns a generator of KubernetesClusterBackupDatasourceParameters instances for property testing.
func KubernetesClusterBackupDatasourceParametersGenerator() gopter.Gen {
	if kubernetesClusterBackupDatasourceParametersGenerator != nil {
		return kubernetesClusterBackupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(generators)
	kubernetesClusterBackupDatasourceParametersGenerator = gen.Struct(reflect.TypeOf(KubernetesClusterBackupDatasourceParameters{}), generators)

	return kubernetesClusterBackupDatasourceParametersGenerator
}

// AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["ExcludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["ExcludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IncludeClusterScopeResources"] = gen.PtrOf(gen.Bool())
	gens["IncludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["IncludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["LabelSelectors"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.OneConstOf(KubernetesClusterBackupDatasourceParameters_ObjectType_KubernetesClusterBackupDatasourceParameters))
	gens["SnapshotVolumes"] = gen.PtrOf(gen.Bool())
}

func Test_KubernetesClusterBackupDatasourceParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KubernetesClusterBackupDatasourceParameters_STATUS to KubernetesClusterBackupDatasourceParameters_STATUS via AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS & AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKubernetesClusterBackupDatasourceParameters_STATUS, KubernetesClusterBackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKubernetesClusterBackupDatasourceParameters_STATUS tests if a specific instance of KubernetesClusterBackupDatasourceParameters_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForKubernetesClusterBackupDatasourceParameters_STATUS(subject KubernetesClusterBackupDatasourceParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20230101s.KubernetesClusterBackupDatasourceParameters_STATUS
	err := copied.AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KubernetesClusterBackupDatasourceParameters_STATUS
	err = actual.AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KubernetesClusterBackupDatasourceParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubernetesClusterBackupDatasourceParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_STATUS, KubernetesClusterBackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_STATUS runs a test to see if a specific instance of KubernetesClusterBackupDatasourceParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_STATUS(subject KubernetesClusterBackupDatasourceParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubernetesClusterBackupDatasourceParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubernetesClusterBackupDatasourceParameters_STATUS instances for property testing - lazily instantiated
// by KubernetesClusterBackupDatasourceParameters_STATUSGenerator()
var kubernetesClusterBackupDatasourceParameters_STATUSGenerator gopter.Gen

// KubernetesClusterBackupDatasourceParameters_STATUSGenerator returns a generator of KubernetesClusterBackupDatasourceParameters_STATUS instances for property testing.
func KubernetesClusterBackupDatasourceParameters_STATUSGenerator() gopter.Gen {
	if kubernetesClusterBackupDatasourceParameters_STATUSGenerator != nil {
		return kubernetesClusterBackupDatasourceParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_STATUS(generators)
	kubernetesClusterBackupDatasourceParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(KubernetesClusterBackupDatasourceParameters_STATUS{}), generators)

	return kubernetesClusterBackupDatasourceParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ExcludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["ExcludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IncludeClusterScopeResources"] = gen.PtrOf(gen.Bool())
	gens["IncludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["IncludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["LabelSelectors"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.OneConstOf(KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS_KubernetesClusterBackupDatasourceParameters))
	gens["SnapshotVolumes"] = gen.PtrOf(gen.Bool())
}
