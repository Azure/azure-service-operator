// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AbsoluteDeleteOption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AbsoluteDeleteOption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAbsoluteDeleteOption, AbsoluteDeleteOptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAbsoluteDeleteOption runs a test to see if a specific instance of AbsoluteDeleteOption round trips to JSON and back losslessly
func RunJSONSerializationTestForAbsoluteDeleteOption(subject AbsoluteDeleteOption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AbsoluteDeleteOption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AbsoluteDeleteOption instances for property testing - lazily instantiated by
// AbsoluteDeleteOptionGenerator()
var absoluteDeleteOptionGenerator gopter.Gen

// AbsoluteDeleteOptionGenerator returns a generator of AbsoluteDeleteOption instances for property testing.
func AbsoluteDeleteOptionGenerator() gopter.Gen {
	if absoluteDeleteOptionGenerator != nil {
		return absoluteDeleteOptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAbsoluteDeleteOption(generators)
	absoluteDeleteOptionGenerator = gen.Struct(reflect.TypeOf(AbsoluteDeleteOption{}), generators)

	return absoluteDeleteOptionGenerator
}

// AddIndependentPropertyGeneratorsForAbsoluteDeleteOption is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAbsoluteDeleteOption(gens map[string]gopter.Gen) {
	gens["Duration"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(AbsoluteDeleteOption_ObjectType_AbsoluteDeleteOption)
}

func Test_AdhocBasedTaggingCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdhocBasedTaggingCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdhocBasedTaggingCriteria, AdhocBasedTaggingCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdhocBasedTaggingCriteria runs a test to see if a specific instance of AdhocBasedTaggingCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForAdhocBasedTaggingCriteria(subject AdhocBasedTaggingCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdhocBasedTaggingCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdhocBasedTaggingCriteria instances for property testing - lazily instantiated by
// AdhocBasedTaggingCriteriaGenerator()
var adhocBasedTaggingCriteriaGenerator gopter.Gen

// AdhocBasedTaggingCriteriaGenerator returns a generator of AdhocBasedTaggingCriteria instances for property testing.
func AdhocBasedTaggingCriteriaGenerator() gopter.Gen {
	if adhocBasedTaggingCriteriaGenerator != nil {
		return adhocBasedTaggingCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdhocBasedTaggingCriteria(generators)
	adhocBasedTaggingCriteriaGenerator = gen.Struct(reflect.TypeOf(AdhocBasedTaggingCriteria{}), generators)

	return adhocBasedTaggingCriteriaGenerator
}

// AddRelatedPropertyGeneratorsForAdhocBasedTaggingCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdhocBasedTaggingCriteria(gens map[string]gopter.Gen) {
	gens["TagInfo"] = gen.PtrOf(RetentionTagGenerator())
}

func Test_AdhocBasedTriggerContext_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdhocBasedTriggerContext via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdhocBasedTriggerContext, AdhocBasedTriggerContextGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdhocBasedTriggerContext runs a test to see if a specific instance of AdhocBasedTriggerContext round trips to JSON and back losslessly
func RunJSONSerializationTestForAdhocBasedTriggerContext(subject AdhocBasedTriggerContext) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdhocBasedTriggerContext
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdhocBasedTriggerContext instances for property testing - lazily instantiated by
// AdhocBasedTriggerContextGenerator()
var adhocBasedTriggerContextGenerator gopter.Gen

// AdhocBasedTriggerContextGenerator returns a generator of AdhocBasedTriggerContext instances for property testing.
// We first initialize adhocBasedTriggerContextGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AdhocBasedTriggerContextGenerator() gopter.Gen {
	if adhocBasedTriggerContextGenerator != nil {
		return adhocBasedTriggerContextGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdhocBasedTriggerContext(generators)
	adhocBasedTriggerContextGenerator = gen.Struct(reflect.TypeOf(AdhocBasedTriggerContext{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdhocBasedTriggerContext(generators)
	AddRelatedPropertyGeneratorsForAdhocBasedTriggerContext(generators)
	adhocBasedTriggerContextGenerator = gen.Struct(reflect.TypeOf(AdhocBasedTriggerContext{}), generators)

	return adhocBasedTriggerContextGenerator
}

// AddIndependentPropertyGeneratorsForAdhocBasedTriggerContext is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdhocBasedTriggerContext(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(AdhocBasedTriggerContext_ObjectType_AdhocBasedTriggerContext)
}

// AddRelatedPropertyGeneratorsForAdhocBasedTriggerContext is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdhocBasedTriggerContext(gens map[string]gopter.Gen) {
	gens["TaggingCriteria"] = gen.PtrOf(AdhocBasedTaggingCriteriaGenerator())
}

func Test_AzureBackupParams_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureBackupParams via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureBackupParams, AzureBackupParamsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureBackupParams runs a test to see if a specific instance of AzureBackupParams round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureBackupParams(subject AzureBackupParams) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureBackupParams
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureBackupParams instances for property testing - lazily instantiated by AzureBackupParamsGenerator()
var azureBackupParamsGenerator gopter.Gen

// AzureBackupParamsGenerator returns a generator of AzureBackupParams instances for property testing.
func AzureBackupParamsGenerator() gopter.Gen {
	if azureBackupParamsGenerator != nil {
		return azureBackupParamsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBackupParams(generators)
	azureBackupParamsGenerator = gen.Struct(reflect.TypeOf(AzureBackupParams{}), generators)

	return azureBackupParamsGenerator
}

// AddIndependentPropertyGeneratorsForAzureBackupParams is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureBackupParams(gens map[string]gopter.Gen) {
	gens["BackupType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(AzureBackupParams_ObjectType_AzureBackupParams)
}

func Test_AzureBackupRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureBackupRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureBackupRule, AzureBackupRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureBackupRule runs a test to see if a specific instance of AzureBackupRule round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureBackupRule(subject AzureBackupRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureBackupRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureBackupRule instances for property testing - lazily instantiated by AzureBackupRuleGenerator()
var azureBackupRuleGenerator gopter.Gen

// AzureBackupRuleGenerator returns a generator of AzureBackupRule instances for property testing.
// We first initialize azureBackupRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureBackupRuleGenerator() gopter.Gen {
	if azureBackupRuleGenerator != nil {
		return azureBackupRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBackupRule(generators)
	azureBackupRuleGenerator = gen.Struct(reflect.TypeOf(AzureBackupRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBackupRule(generators)
	AddRelatedPropertyGeneratorsForAzureBackupRule(generators)
	azureBackupRuleGenerator = gen.Struct(reflect.TypeOf(AzureBackupRule{}), generators)

	return azureBackupRuleGenerator
}

// AddIndependentPropertyGeneratorsForAzureBackupRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureBackupRule(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(AzureBackupRule_ObjectType_AzureBackupRule)
}

// AddRelatedPropertyGeneratorsForAzureBackupRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureBackupRule(gens map[string]gopter.Gen) {
	gens["BackupParameters"] = gen.PtrOf(BackupParametersGenerator())
	gens["DataStore"] = gen.PtrOf(DataStoreInfoBaseGenerator())
	gens["Trigger"] = gen.PtrOf(TriggerContextGenerator())
}

func Test_AzureRetentionRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureRetentionRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureRetentionRule, AzureRetentionRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureRetentionRule runs a test to see if a specific instance of AzureRetentionRule round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureRetentionRule(subject AzureRetentionRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureRetentionRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureRetentionRule instances for property testing - lazily instantiated by AzureRetentionRuleGenerator()
var azureRetentionRuleGenerator gopter.Gen

// AzureRetentionRuleGenerator returns a generator of AzureRetentionRule instances for property testing.
// We first initialize azureRetentionRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureRetentionRuleGenerator() gopter.Gen {
	if azureRetentionRuleGenerator != nil {
		return azureRetentionRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureRetentionRule(generators)
	azureRetentionRuleGenerator = gen.Struct(reflect.TypeOf(AzureRetentionRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureRetentionRule(generators)
	AddRelatedPropertyGeneratorsForAzureRetentionRule(generators)
	azureRetentionRuleGenerator = gen.Struct(reflect.TypeOf(AzureRetentionRule{}), generators)

	return azureRetentionRuleGenerator
}

// AddIndependentPropertyGeneratorsForAzureRetentionRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureRetentionRule(gens map[string]gopter.Gen) {
	gens["IsDefault"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(AzureRetentionRule_ObjectType_AzureRetentionRule)
}

// AddRelatedPropertyGeneratorsForAzureRetentionRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureRetentionRule(gens map[string]gopter.Gen) {
	gens["Lifecycles"] = gen.SliceOf(SourceLifeCycleGenerator())
}

func Test_BackupCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupCriteria, BackupCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupCriteria runs a test to see if a specific instance of BackupCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupCriteria(subject BackupCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupCriteria instances for property testing - lazily instantiated by BackupCriteriaGenerator()
var backupCriteriaGenerator gopter.Gen

// BackupCriteriaGenerator returns a generator of BackupCriteria instances for property testing.
func BackupCriteriaGenerator() gopter.Gen {
	if backupCriteriaGenerator != nil {
		return backupCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupCriteria(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupCriteria{}), props))
	}
	backupCriteriaGenerator = gen.OneGenOf(gens...)

	return backupCriteriaGenerator
}

// AddRelatedPropertyGeneratorsForBackupCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupCriteria(gens map[string]gopter.Gen) {
	gens["ScheduleBasedBackupCriteria"] = ScheduleBasedBackupCriteriaGenerator().Map(func(it ScheduleBasedBackupCriteria) *ScheduleBasedBackupCriteria {
		return &it
	}) // generate one case for OneOf type
}

func Test_BackupParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupParameters, BackupParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupParameters runs a test to see if a specific instance of BackupParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupParameters(subject BackupParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupParameters instances for property testing - lazily instantiated by BackupParametersGenerator()
var backupParametersGenerator gopter.Gen

// BackupParametersGenerator returns a generator of BackupParameters instances for property testing.
func BackupParametersGenerator() gopter.Gen {
	if backupParametersGenerator != nil {
		return backupParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupParameters(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupParameters{}), props))
	}
	backupParametersGenerator = gen.OneGenOf(gens...)

	return backupParametersGenerator
}

// AddRelatedPropertyGeneratorsForBackupParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupParameters(gens map[string]gopter.Gen) {
	gens["AzureBackupParams"] = AzureBackupParamsGenerator().Map(func(it AzureBackupParams) *AzureBackupParams {
		return &it
	}) // generate one case for OneOf type
}

func Test_BackupPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy, BackupPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy runs a test to see if a specific instance of BackupPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy(subject BackupPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy instances for property testing - lazily instantiated by BackupPolicyGenerator()
var backupPolicyGenerator gopter.Gen

// BackupPolicyGenerator returns a generator of BackupPolicy instances for property testing.
// We first initialize backupPolicyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupPolicyGenerator() gopter.Gen {
	if backupPolicyGenerator != nil {
		return backupPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy(generators)
	backupPolicyGenerator = gen.Struct(reflect.TypeOf(BackupPolicy{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy(generators)
	AddRelatedPropertyGeneratorsForBackupPolicy(generators)
	backupPolicyGenerator = gen.Struct(reflect.TypeOf(BackupPolicy{}), generators)

	return backupPolicyGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy(gens map[string]gopter.Gen) {
	gens["DatasourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(BackupPolicy_ObjectType_BackupPolicy)
}

// AddRelatedPropertyGeneratorsForBackupPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupPolicy(gens map[string]gopter.Gen) {
	gens["PolicyRules"] = gen.SliceOf(BasePolicyRuleGenerator())
}

func Test_BackupSchedule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupSchedule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupSchedule, BackupScheduleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupSchedule runs a test to see if a specific instance of BackupSchedule round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupSchedule(subject BackupSchedule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupSchedule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupSchedule instances for property testing - lazily instantiated by BackupScheduleGenerator()
var backupScheduleGenerator gopter.Gen

// BackupScheduleGenerator returns a generator of BackupSchedule instances for property testing.
func BackupScheduleGenerator() gopter.Gen {
	if backupScheduleGenerator != nil {
		return backupScheduleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupSchedule(generators)
	backupScheduleGenerator = gen.Struct(reflect.TypeOf(BackupSchedule{}), generators)

	return backupScheduleGenerator
}

// AddIndependentPropertyGeneratorsForBackupSchedule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupSchedule(gens map[string]gopter.Gen) {
	gens["RepeatingTimeIntervals"] = gen.SliceOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupVaultsBackupPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaultsBackupPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaultsBackupPolicy_Spec, BackupVaultsBackupPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaultsBackupPolicy_Spec runs a test to see if a specific instance of BackupVaultsBackupPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaultsBackupPolicy_Spec(subject BackupVaultsBackupPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaultsBackupPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaultsBackupPolicy_Spec instances for property testing - lazily instantiated by
// BackupVaultsBackupPolicy_SpecGenerator()
var backupVaultsBackupPolicy_SpecGenerator gopter.Gen

// BackupVaultsBackupPolicy_SpecGenerator returns a generator of BackupVaultsBackupPolicy_Spec instances for property testing.
// We first initialize backupVaultsBackupPolicy_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupVaultsBackupPolicy_SpecGenerator() gopter.Gen {
	if backupVaultsBackupPolicy_SpecGenerator != nil {
		return backupVaultsBackupPolicy_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaultsBackupPolicy_Spec(generators)
	backupVaultsBackupPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(BackupVaultsBackupPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaultsBackupPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForBackupVaultsBackupPolicy_Spec(generators)
	backupVaultsBackupPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(BackupVaultsBackupPolicy_Spec{}), generators)

	return backupVaultsBackupPolicy_SpecGenerator
}

// AddIndependentPropertyGeneratorsForBackupVaultsBackupPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupVaultsBackupPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForBackupVaultsBackupPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaultsBackupPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BaseBackupPolicyGenerator())
}

func Test_BaseBackupPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaseBackupPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaseBackupPolicy, BaseBackupPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaseBackupPolicy runs a test to see if a specific instance of BaseBackupPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForBaseBackupPolicy(subject BaseBackupPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaseBackupPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaseBackupPolicy instances for property testing - lazily instantiated by BaseBackupPolicyGenerator()
var baseBackupPolicyGenerator gopter.Gen

// BaseBackupPolicyGenerator returns a generator of BaseBackupPolicy instances for property testing.
func BaseBackupPolicyGenerator() gopter.Gen {
	if baseBackupPolicyGenerator != nil {
		return baseBackupPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBaseBackupPolicy(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(BaseBackupPolicy{}), props))
	}
	baseBackupPolicyGenerator = gen.OneGenOf(gens...)

	return baseBackupPolicyGenerator
}

// AddRelatedPropertyGeneratorsForBaseBackupPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaseBackupPolicy(gens map[string]gopter.Gen) {
	gens["BackupPolicy"] = BackupPolicyGenerator().Map(func(it BackupPolicy) *BackupPolicy {
		return &it
	}) // generate one case for OneOf type
}

func Test_BasePolicyRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BasePolicyRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBasePolicyRule, BasePolicyRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBasePolicyRule runs a test to see if a specific instance of BasePolicyRule round trips to JSON and back losslessly
func RunJSONSerializationTestForBasePolicyRule(subject BasePolicyRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BasePolicyRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BasePolicyRule instances for property testing - lazily instantiated by BasePolicyRuleGenerator()
var basePolicyRuleGenerator gopter.Gen

// BasePolicyRuleGenerator returns a generator of BasePolicyRule instances for property testing.
func BasePolicyRuleGenerator() gopter.Gen {
	if basePolicyRuleGenerator != nil {
		return basePolicyRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBasePolicyRule(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(BasePolicyRule{}), props))
	}
	basePolicyRuleGenerator = gen.OneGenOf(gens...)

	return basePolicyRuleGenerator
}

// AddRelatedPropertyGeneratorsForBasePolicyRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBasePolicyRule(gens map[string]gopter.Gen) {
	gens["AzureBackup"] = AzureBackupRuleGenerator().Map(func(it AzureBackupRule) *AzureBackupRule {
		return &it
	}) // generate one case for OneOf type
	gens["AzureRetention"] = AzureRetentionRuleGenerator().Map(func(it AzureRetentionRule) *AzureRetentionRule {
		return &it
	}) // generate one case for OneOf type
}

func Test_CopyOnExpiryOption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CopyOnExpiryOption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCopyOnExpiryOption, CopyOnExpiryOptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCopyOnExpiryOption runs a test to see if a specific instance of CopyOnExpiryOption round trips to JSON and back losslessly
func RunJSONSerializationTestForCopyOnExpiryOption(subject CopyOnExpiryOption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CopyOnExpiryOption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CopyOnExpiryOption instances for property testing - lazily instantiated by CopyOnExpiryOptionGenerator()
var copyOnExpiryOptionGenerator gopter.Gen

// CopyOnExpiryOptionGenerator returns a generator of CopyOnExpiryOption instances for property testing.
func CopyOnExpiryOptionGenerator() gopter.Gen {
	if copyOnExpiryOptionGenerator != nil {
		return copyOnExpiryOptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCopyOnExpiryOption(generators)
	copyOnExpiryOptionGenerator = gen.Struct(reflect.TypeOf(CopyOnExpiryOption{}), generators)

	return copyOnExpiryOptionGenerator
}

// AddIndependentPropertyGeneratorsForCopyOnExpiryOption is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCopyOnExpiryOption(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(CopyOnExpiryOption_ObjectType_CopyOnExpiryOption)
}

func Test_CopyOption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CopyOption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCopyOption, CopyOptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCopyOption runs a test to see if a specific instance of CopyOption round trips to JSON and back losslessly
func RunJSONSerializationTestForCopyOption(subject CopyOption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CopyOption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CopyOption instances for property testing - lazily instantiated by CopyOptionGenerator()
var copyOptionGenerator gopter.Gen

// CopyOptionGenerator returns a generator of CopyOption instances for property testing.
func CopyOptionGenerator() gopter.Gen {
	if copyOptionGenerator != nil {
		return copyOptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCopyOption(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(CopyOption{}), props))
	}
	copyOptionGenerator = gen.OneGenOf(gens...)

	return copyOptionGenerator
}

// AddRelatedPropertyGeneratorsForCopyOption is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCopyOption(gens map[string]gopter.Gen) {
	gens["CopyOnExpiry"] = CopyOnExpiryOptionGenerator().Map(func(it CopyOnExpiryOption) *CopyOnExpiryOption {
		return &it
	}) // generate one case for OneOf type
	gens["CustomCopy"] = CustomCopyOptionGenerator().Map(func(it CustomCopyOption) *CustomCopyOption {
		return &it
	}) // generate one case for OneOf type
	gens["ImmediateCopy"] = ImmediateCopyOptionGenerator().Map(func(it ImmediateCopyOption) *ImmediateCopyOption {
		return &it
	}) // generate one case for OneOf type
}

func Test_CustomCopyOption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomCopyOption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomCopyOption, CustomCopyOptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomCopyOption runs a test to see if a specific instance of CustomCopyOption round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomCopyOption(subject CustomCopyOption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomCopyOption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomCopyOption instances for property testing - lazily instantiated by CustomCopyOptionGenerator()
var customCopyOptionGenerator gopter.Gen

// CustomCopyOptionGenerator returns a generator of CustomCopyOption instances for property testing.
func CustomCopyOptionGenerator() gopter.Gen {
	if customCopyOptionGenerator != nil {
		return customCopyOptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomCopyOption(generators)
	customCopyOptionGenerator = gen.Struct(reflect.TypeOf(CustomCopyOption{}), generators)

	return customCopyOptionGenerator
}

// AddIndependentPropertyGeneratorsForCustomCopyOption is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomCopyOption(gens map[string]gopter.Gen) {
	gens["Duration"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(CustomCopyOption_ObjectType_CustomCopyOption)
}

func Test_DataStoreInfoBase_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataStoreInfoBase via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataStoreInfoBase, DataStoreInfoBaseGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataStoreInfoBase runs a test to see if a specific instance of DataStoreInfoBase round trips to JSON and back losslessly
func RunJSONSerializationTestForDataStoreInfoBase(subject DataStoreInfoBase) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataStoreInfoBase
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataStoreInfoBase instances for property testing - lazily instantiated by DataStoreInfoBaseGenerator()
var dataStoreInfoBaseGenerator gopter.Gen

// DataStoreInfoBaseGenerator returns a generator of DataStoreInfoBase instances for property testing.
func DataStoreInfoBaseGenerator() gopter.Gen {
	if dataStoreInfoBaseGenerator != nil {
		return dataStoreInfoBaseGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataStoreInfoBase(generators)
	dataStoreInfoBaseGenerator = gen.Struct(reflect.TypeOf(DataStoreInfoBase{}), generators)

	return dataStoreInfoBaseGenerator
}

// AddIndependentPropertyGeneratorsForDataStoreInfoBase is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataStoreInfoBase(gens map[string]gopter.Gen) {
	gens["DataStoreType"] = gen.PtrOf(gen.OneConstOf(DataStoreInfoBase_DataStoreType_ArchiveStore, DataStoreInfoBase_DataStoreType_OperationalStore, DataStoreInfoBase_DataStoreType_VaultStore))
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
}

func Test_Day_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Day via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDay, DayGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDay runs a test to see if a specific instance of Day round trips to JSON and back losslessly
func RunJSONSerializationTestForDay(subject Day) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Day
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Day instances for property testing - lazily instantiated by DayGenerator()
var dayGenerator gopter.Gen

// DayGenerator returns a generator of Day instances for property testing.
func DayGenerator() gopter.Gen {
	if dayGenerator != nil {
		return dayGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDay(generators)
	dayGenerator = gen.Struct(reflect.TypeOf(Day{}), generators)

	return dayGenerator
}

// AddIndependentPropertyGeneratorsForDay is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDay(gens map[string]gopter.Gen) {
	gens["Date"] = gen.PtrOf(gen.Int())
	gens["IsLast"] = gen.PtrOf(gen.Bool())
}

func Test_DeleteOption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeleteOption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeleteOption, DeleteOptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeleteOption runs a test to see if a specific instance of DeleteOption round trips to JSON and back losslessly
func RunJSONSerializationTestForDeleteOption(subject DeleteOption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeleteOption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeleteOption instances for property testing - lazily instantiated by DeleteOptionGenerator()
var deleteOptionGenerator gopter.Gen

// DeleteOptionGenerator returns a generator of DeleteOption instances for property testing.
func DeleteOptionGenerator() gopter.Gen {
	if deleteOptionGenerator != nil {
		return deleteOptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeleteOption(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(DeleteOption{}), props))
	}
	deleteOptionGenerator = gen.OneGenOf(gens...)

	return deleteOptionGenerator
}

// AddRelatedPropertyGeneratorsForDeleteOption is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeleteOption(gens map[string]gopter.Gen) {
	gens["AbsoluteDeleteOption"] = AbsoluteDeleteOptionGenerator().Map(func(it AbsoluteDeleteOption) *AbsoluteDeleteOption {
		return &it
	}) // generate one case for OneOf type
}

func Test_ImmediateCopyOption_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImmediateCopyOption via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImmediateCopyOption, ImmediateCopyOptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImmediateCopyOption runs a test to see if a specific instance of ImmediateCopyOption round trips to JSON and back losslessly
func RunJSONSerializationTestForImmediateCopyOption(subject ImmediateCopyOption) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImmediateCopyOption
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImmediateCopyOption instances for property testing - lazily instantiated by
// ImmediateCopyOptionGenerator()
var immediateCopyOptionGenerator gopter.Gen

// ImmediateCopyOptionGenerator returns a generator of ImmediateCopyOption instances for property testing.
func ImmediateCopyOptionGenerator() gopter.Gen {
	if immediateCopyOptionGenerator != nil {
		return immediateCopyOptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImmediateCopyOption(generators)
	immediateCopyOptionGenerator = gen.Struct(reflect.TypeOf(ImmediateCopyOption{}), generators)

	return immediateCopyOptionGenerator
}

// AddIndependentPropertyGeneratorsForImmediateCopyOption is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImmediateCopyOption(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(ImmediateCopyOption_ObjectType_ImmediateCopyOption)
}

func Test_RetentionTag_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetentionTag via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetentionTag, RetentionTagGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetentionTag runs a test to see if a specific instance of RetentionTag round trips to JSON and back losslessly
func RunJSONSerializationTestForRetentionTag(subject RetentionTag) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetentionTag
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetentionTag instances for property testing - lazily instantiated by RetentionTagGenerator()
var retentionTagGenerator gopter.Gen

// RetentionTagGenerator returns a generator of RetentionTag instances for property testing.
func RetentionTagGenerator() gopter.Gen {
	if retentionTagGenerator != nil {
		return retentionTagGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetentionTag(generators)
	retentionTagGenerator = gen.Struct(reflect.TypeOf(RetentionTag{}), generators)

	return retentionTagGenerator
}

// AddIndependentPropertyGeneratorsForRetentionTag is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetentionTag(gens map[string]gopter.Gen) {
	gens["TagName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScheduleBasedBackupCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduleBasedBackupCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduleBasedBackupCriteria, ScheduleBasedBackupCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduleBasedBackupCriteria runs a test to see if a specific instance of ScheduleBasedBackupCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduleBasedBackupCriteria(subject ScheduleBasedBackupCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduleBasedBackupCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduleBasedBackupCriteria instances for property testing - lazily instantiated by
// ScheduleBasedBackupCriteriaGenerator()
var scheduleBasedBackupCriteriaGenerator gopter.Gen

// ScheduleBasedBackupCriteriaGenerator returns a generator of ScheduleBasedBackupCriteria instances for property testing.
// We first initialize scheduleBasedBackupCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScheduleBasedBackupCriteriaGenerator() gopter.Gen {
	if scheduleBasedBackupCriteriaGenerator != nil {
		return scheduleBasedBackupCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScheduleBasedBackupCriteria(generators)
	scheduleBasedBackupCriteriaGenerator = gen.Struct(reflect.TypeOf(ScheduleBasedBackupCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScheduleBasedBackupCriteria(generators)
	AddRelatedPropertyGeneratorsForScheduleBasedBackupCriteria(generators)
	scheduleBasedBackupCriteriaGenerator = gen.Struct(reflect.TypeOf(ScheduleBasedBackupCriteria{}), generators)

	return scheduleBasedBackupCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForScheduleBasedBackupCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScheduleBasedBackupCriteria(gens map[string]gopter.Gen) {
	gens["AbsoluteCriteria"] = gen.SliceOf(gen.OneConstOf(
		ScheduleBasedBackupCriteria_AbsoluteCriteria_AllBackup,
		ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfDay,
		ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfMonth,
		ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfWeek,
		ScheduleBasedBackupCriteria_AbsoluteCriteria_FirstOfYear))
	gens["DaysOfTheWeek"] = gen.SliceOf(gen.OneConstOf(
		ScheduleBasedBackupCriteria_DaysOfTheWeek_Friday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_Monday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_Saturday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_Sunday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_Thursday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_Tuesday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_Wednesday))
	gens["MonthsOfYear"] = gen.SliceOf(gen.OneConstOf(
		ScheduleBasedBackupCriteria_MonthsOfYear_April,
		ScheduleBasedBackupCriteria_MonthsOfYear_August,
		ScheduleBasedBackupCriteria_MonthsOfYear_December,
		ScheduleBasedBackupCriteria_MonthsOfYear_February,
		ScheduleBasedBackupCriteria_MonthsOfYear_January,
		ScheduleBasedBackupCriteria_MonthsOfYear_July,
		ScheduleBasedBackupCriteria_MonthsOfYear_June,
		ScheduleBasedBackupCriteria_MonthsOfYear_March,
		ScheduleBasedBackupCriteria_MonthsOfYear_May,
		ScheduleBasedBackupCriteria_MonthsOfYear_November,
		ScheduleBasedBackupCriteria_MonthsOfYear_October,
		ScheduleBasedBackupCriteria_MonthsOfYear_September))
	gens["ObjectType"] = gen.OneConstOf(ScheduleBasedBackupCriteria_ObjectType_ScheduleBasedBackupCriteria)
	gens["ScheduleTimes"] = gen.SliceOf(gen.AlphaString())
	gens["WeeksOfTheMonth"] = gen.SliceOf(gen.OneConstOf(
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_First,
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_Fourth,
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_Last,
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_Second,
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_Third))
}

// AddRelatedPropertyGeneratorsForScheduleBasedBackupCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduleBasedBackupCriteria(gens map[string]gopter.Gen) {
	gens["DaysOfMonth"] = gen.SliceOf(DayGenerator())
}

func Test_ScheduleBasedTriggerContext_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduleBasedTriggerContext via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduleBasedTriggerContext, ScheduleBasedTriggerContextGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduleBasedTriggerContext runs a test to see if a specific instance of ScheduleBasedTriggerContext round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduleBasedTriggerContext(subject ScheduleBasedTriggerContext) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduleBasedTriggerContext
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduleBasedTriggerContext instances for property testing - lazily instantiated by
// ScheduleBasedTriggerContextGenerator()
var scheduleBasedTriggerContextGenerator gopter.Gen

// ScheduleBasedTriggerContextGenerator returns a generator of ScheduleBasedTriggerContext instances for property testing.
// We first initialize scheduleBasedTriggerContextGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScheduleBasedTriggerContextGenerator() gopter.Gen {
	if scheduleBasedTriggerContextGenerator != nil {
		return scheduleBasedTriggerContextGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScheduleBasedTriggerContext(generators)
	scheduleBasedTriggerContextGenerator = gen.Struct(reflect.TypeOf(ScheduleBasedTriggerContext{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScheduleBasedTriggerContext(generators)
	AddRelatedPropertyGeneratorsForScheduleBasedTriggerContext(generators)
	scheduleBasedTriggerContextGenerator = gen.Struct(reflect.TypeOf(ScheduleBasedTriggerContext{}), generators)

	return scheduleBasedTriggerContextGenerator
}

// AddIndependentPropertyGeneratorsForScheduleBasedTriggerContext is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScheduleBasedTriggerContext(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(ScheduleBasedTriggerContext_ObjectType_ScheduleBasedTriggerContext)
}

// AddRelatedPropertyGeneratorsForScheduleBasedTriggerContext is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduleBasedTriggerContext(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(BackupScheduleGenerator())
	gens["TaggingCriteria"] = gen.SliceOf(TaggingCriteriaGenerator())
}

func Test_SourceLifeCycle_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceLifeCycle via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceLifeCycle, SourceLifeCycleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceLifeCycle runs a test to see if a specific instance of SourceLifeCycle round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceLifeCycle(subject SourceLifeCycle) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceLifeCycle
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceLifeCycle instances for property testing - lazily instantiated by SourceLifeCycleGenerator()
var sourceLifeCycleGenerator gopter.Gen

// SourceLifeCycleGenerator returns a generator of SourceLifeCycle instances for property testing.
func SourceLifeCycleGenerator() gopter.Gen {
	if sourceLifeCycleGenerator != nil {
		return sourceLifeCycleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSourceLifeCycle(generators)
	sourceLifeCycleGenerator = gen.Struct(reflect.TypeOf(SourceLifeCycle{}), generators)

	return sourceLifeCycleGenerator
}

// AddRelatedPropertyGeneratorsForSourceLifeCycle is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSourceLifeCycle(gens map[string]gopter.Gen) {
	gens["DeleteAfter"] = gen.PtrOf(DeleteOptionGenerator())
	gens["SourceDataStore"] = gen.PtrOf(DataStoreInfoBaseGenerator())
	gens["TargetDataStoreCopySettings"] = gen.SliceOf(TargetCopySettingGenerator())
}

func Test_TaggingCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TaggingCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTaggingCriteria, TaggingCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTaggingCriteria runs a test to see if a specific instance of TaggingCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForTaggingCriteria(subject TaggingCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TaggingCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TaggingCriteria instances for property testing - lazily instantiated by TaggingCriteriaGenerator()
var taggingCriteriaGenerator gopter.Gen

// TaggingCriteriaGenerator returns a generator of TaggingCriteria instances for property testing.
// We first initialize taggingCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TaggingCriteriaGenerator() gopter.Gen {
	if taggingCriteriaGenerator != nil {
		return taggingCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTaggingCriteria(generators)
	taggingCriteriaGenerator = gen.Struct(reflect.TypeOf(TaggingCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTaggingCriteria(generators)
	AddRelatedPropertyGeneratorsForTaggingCriteria(generators)
	taggingCriteriaGenerator = gen.Struct(reflect.TypeOf(TaggingCriteria{}), generators)

	return taggingCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForTaggingCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTaggingCriteria(gens map[string]gopter.Gen) {
	gens["IsDefault"] = gen.PtrOf(gen.Bool())
	gens["TaggingPriority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForTaggingCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTaggingCriteria(gens map[string]gopter.Gen) {
	gens["Criteria"] = gen.SliceOf(BackupCriteriaGenerator())
	gens["TagInfo"] = gen.PtrOf(RetentionTagGenerator())
}

func Test_TargetCopySetting_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TargetCopySetting via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTargetCopySetting, TargetCopySettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTargetCopySetting runs a test to see if a specific instance of TargetCopySetting round trips to JSON and back losslessly
func RunJSONSerializationTestForTargetCopySetting(subject TargetCopySetting) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TargetCopySetting
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TargetCopySetting instances for property testing - lazily instantiated by TargetCopySettingGenerator()
var targetCopySettingGenerator gopter.Gen

// TargetCopySettingGenerator returns a generator of TargetCopySetting instances for property testing.
func TargetCopySettingGenerator() gopter.Gen {
	if targetCopySettingGenerator != nil {
		return targetCopySettingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForTargetCopySetting(generators)
	targetCopySettingGenerator = gen.Struct(reflect.TypeOf(TargetCopySetting{}), generators)

	return targetCopySettingGenerator
}

// AddRelatedPropertyGeneratorsForTargetCopySetting is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTargetCopySetting(gens map[string]gopter.Gen) {
	gens["CopyAfter"] = gen.PtrOf(CopyOptionGenerator())
	gens["DataStore"] = gen.PtrOf(DataStoreInfoBaseGenerator())
}

func Test_TriggerContext_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TriggerContext via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTriggerContext, TriggerContextGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTriggerContext runs a test to see if a specific instance of TriggerContext round trips to JSON and back losslessly
func RunJSONSerializationTestForTriggerContext(subject TriggerContext) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TriggerContext
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TriggerContext instances for property testing - lazily instantiated by TriggerContextGenerator()
var triggerContextGenerator gopter.Gen

// TriggerContextGenerator returns a generator of TriggerContext instances for property testing.
func TriggerContextGenerator() gopter.Gen {
	if triggerContextGenerator != nil {
		return triggerContextGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForTriggerContext(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(TriggerContext{}), props))
	}
	triggerContextGenerator = gen.OneGenOf(gens...)

	return triggerContextGenerator
}

// AddRelatedPropertyGeneratorsForTriggerContext is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTriggerContext(gens map[string]gopter.Gen) {
	gens["Adhoc"] = AdhocBasedTriggerContextGenerator().Map(func(it AdhocBasedTriggerContext) *AdhocBasedTriggerContext {
		return &it
	}) // generate one case for OneOf type
	gens["Schedule"] = ScheduleBasedTriggerContextGenerator().Map(func(it ScheduleBasedTriggerContext) *ScheduleBasedTriggerContext {
		return &it
	}) // generate one case for OneOf type
}
