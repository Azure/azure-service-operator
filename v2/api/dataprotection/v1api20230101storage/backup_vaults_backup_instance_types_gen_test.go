// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230101storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BackupVaultsBackupInstance_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaultsBackupInstance via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaultsBackupInstance, BackupVaultsBackupInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaultsBackupInstance runs a test to see if a specific instance of BackupVaultsBackupInstance round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaultsBackupInstance(subject BackupVaultsBackupInstance) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaultsBackupInstance
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaultsBackupInstance instances for property testing - lazily instantiated by
// BackupVaultsBackupInstanceGenerator()
var backupVaultsBackupInstanceGenerator gopter.Gen

// BackupVaultsBackupInstanceGenerator returns a generator of BackupVaultsBackupInstance instances for property testing.
func BackupVaultsBackupInstanceGenerator() gopter.Gen {
	if backupVaultsBackupInstanceGenerator != nil {
		return backupVaultsBackupInstanceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance(generators)
	backupVaultsBackupInstanceGenerator = gen.Struct(reflect.TypeOf(BackupVaultsBackupInstance{}), generators)

	return backupVaultsBackupInstanceGenerator
}

// AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance(gens map[string]gopter.Gen) {
	gens["Spec"] = BackupVaults_BackupInstance_SpecGenerator()
	gens["Status"] = BackupVaults_BackupInstance_STATUSGenerator()
}

func Test_BackupVaults_BackupInstance_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaults_BackupInstance_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaults_BackupInstance_Spec, BackupVaults_BackupInstance_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaults_BackupInstance_Spec runs a test to see if a specific instance of BackupVaults_BackupInstance_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaults_BackupInstance_Spec(subject BackupVaults_BackupInstance_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaults_BackupInstance_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaults_BackupInstance_Spec instances for property testing - lazily instantiated by
// BackupVaults_BackupInstance_SpecGenerator()
var backupVaults_BackupInstance_SpecGenerator gopter.Gen

// BackupVaults_BackupInstance_SpecGenerator returns a generator of BackupVaults_BackupInstance_Spec instances for property testing.
// We first initialize backupVaults_BackupInstance_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupVaults_BackupInstance_SpecGenerator() gopter.Gen {
	if backupVaults_BackupInstance_SpecGenerator != nil {
		return backupVaults_BackupInstance_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec(generators)
	backupVaults_BackupInstance_SpecGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec(generators)
	AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec(generators)
	backupVaults_BackupInstance_SpecGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_Spec{}), generators)

	return backupVaults_BackupInstance_SpecGenerator
}

// AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackupInstanceGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
}

func Test_BackupVaults_BackupInstance_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaults_BackupInstance_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaults_BackupInstance_STATUS, BackupVaults_BackupInstance_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaults_BackupInstance_STATUS runs a test to see if a specific instance of BackupVaults_BackupInstance_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaults_BackupInstance_STATUS(subject BackupVaults_BackupInstance_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaults_BackupInstance_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaults_BackupInstance_STATUS instances for property testing - lazily instantiated by
// BackupVaults_BackupInstance_STATUSGenerator()
var backupVaults_BackupInstance_STATUSGenerator gopter.Gen

// BackupVaults_BackupInstance_STATUSGenerator returns a generator of BackupVaults_BackupInstance_STATUS instances for property testing.
// We first initialize backupVaults_BackupInstance_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupVaults_BackupInstance_STATUSGenerator() gopter.Gen {
	if backupVaults_BackupInstance_STATUSGenerator != nil {
		return backupVaults_BackupInstance_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(generators)
	backupVaults_BackupInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(generators)
	AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(generators)
	backupVaults_BackupInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_STATUS{}), generators)

	return backupVaults_BackupInstance_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackupInstance_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_BackupInstance_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupInstance via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupInstance, BackupInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupInstance runs a test to see if a specific instance of BackupInstance round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupInstance(subject BackupInstance) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupInstance
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupInstance instances for property testing - lazily instantiated by BackupInstanceGenerator()
var backupInstanceGenerator gopter.Gen

// BackupInstanceGenerator returns a generator of BackupInstance instances for property testing.
// We first initialize backupInstanceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupInstanceGenerator() gopter.Gen {
	if backupInstanceGenerator != nil {
		return backupInstanceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance(generators)
	backupInstanceGenerator = gen.Struct(reflect.TypeOf(BackupInstance{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance(generators)
	AddRelatedPropertyGeneratorsForBackupInstance(generators)
	backupInstanceGenerator = gen.Struct(reflect.TypeOf(BackupInstance{}), generators)

	return backupInstanceGenerator
}

// AddIndependentPropertyGeneratorsForBackupInstance is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupInstance(gens map[string]gopter.Gen) {
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackupInstance is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupInstance(gens map[string]gopter.Gen) {
	gens["DataSourceInfo"] = gen.PtrOf(DatasourceGenerator())
	gens["DataSourceSetInfo"] = gen.PtrOf(DatasourceSetGenerator())
	gens["DatasourceAuthCredentials"] = gen.PtrOf(AuthCredentialsGenerator())
	gens["PolicyInfo"] = gen.PtrOf(PolicyInfoGenerator())
}

func Test_BackupInstance_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupInstance_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupInstance_STATUS, BackupInstance_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupInstance_STATUS runs a test to see if a specific instance of BackupInstance_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupInstance_STATUS(subject BackupInstance_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupInstance_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupInstance_STATUS instances for property testing - lazily instantiated by
// BackupInstance_STATUSGenerator()
var backupInstance_STATUSGenerator gopter.Gen

// BackupInstance_STATUSGenerator returns a generator of BackupInstance_STATUS instances for property testing.
// We first initialize backupInstance_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupInstance_STATUSGenerator() gopter.Gen {
	if backupInstance_STATUSGenerator != nil {
		return backupInstance_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance_STATUS(generators)
	backupInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupInstance_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance_STATUS(generators)
	AddRelatedPropertyGeneratorsForBackupInstance_STATUS(generators)
	backupInstance_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupInstance_STATUS{}), generators)

	return backupInstance_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackupInstance_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupInstance_STATUS(gens map[string]gopter.Gen) {
	gens["CurrentProtectionState"] = gen.PtrOf(gen.AlphaString())
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackupInstance_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupInstance_STATUS(gens map[string]gopter.Gen) {
	gens["DataSourceInfo"] = gen.PtrOf(Datasource_STATUSGenerator())
	gens["DataSourceSetInfo"] = gen.PtrOf(DatasourceSet_STATUSGenerator())
	gens["DatasourceAuthCredentials"] = gen.PtrOf(AuthCredentials_STATUSGenerator())
	gens["PolicyInfo"] = gen.PtrOf(PolicyInfo_STATUSGenerator())
	gens["ProtectionErrorDetails"] = gen.PtrOf(UserFacingError_STATUSGenerator())
	gens["ProtectionStatus"] = gen.PtrOf(ProtectionStatusDetails_STATUSGenerator())
}

func Test_AuthCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthCredentials, AuthCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthCredentials runs a test to see if a specific instance of AuthCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthCredentials(subject AuthCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthCredentials instances for property testing - lazily instantiated by AuthCredentialsGenerator()
var authCredentialsGenerator gopter.Gen

// AuthCredentialsGenerator returns a generator of AuthCredentials instances for property testing.
func AuthCredentialsGenerator() gopter.Gen {
	if authCredentialsGenerator != nil {
		return authCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAuthCredentials(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AuthCredentials{}), map[string]gopter.Gen{propName: propGen}))
	}
	authCredentialsGenerator = gen.OneGenOf(gens...)

	return authCredentialsGenerator
}

// AddRelatedPropertyGeneratorsForAuthCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthCredentials(gens map[string]gopter.Gen) {
	gens["SecretStoreBasedAuthCredentials"] = SecretStoreBasedAuthCredentialsGenerator().Map(func(it SecretStoreBasedAuthCredentials) *SecretStoreBasedAuthCredentials {
		return &it
	}) // generate one case for OneOf type
}

func Test_AuthCredentials_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthCredentials_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthCredentials_STATUS, AuthCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthCredentials_STATUS runs a test to see if a specific instance of AuthCredentials_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthCredentials_STATUS(subject AuthCredentials_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthCredentials_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthCredentials_STATUS instances for property testing - lazily instantiated by
// AuthCredentials_STATUSGenerator()
var authCredentials_STATUSGenerator gopter.Gen

// AuthCredentials_STATUSGenerator returns a generator of AuthCredentials_STATUS instances for property testing.
func AuthCredentials_STATUSGenerator() gopter.Gen {
	if authCredentials_STATUSGenerator != nil {
		return authCredentials_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAuthCredentials_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AuthCredentials_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	authCredentials_STATUSGenerator = gen.OneGenOf(gens...)

	return authCredentials_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForAuthCredentials_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["SecretStoreBasedAuthCredentials"] = SecretStoreBasedAuthCredentials_STATUSGenerator().Map(func(it SecretStoreBasedAuthCredentials_STATUS) *SecretStoreBasedAuthCredentials_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_Datasource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Datasource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasource, DatasourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasource runs a test to see if a specific instance of Datasource round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasource(subject Datasource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Datasource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Datasource instances for property testing - lazily instantiated by DatasourceGenerator()
var datasourceGenerator gopter.Gen

// DatasourceGenerator returns a generator of Datasource instances for property testing.
func DatasourceGenerator() gopter.Gen {
	if datasourceGenerator != nil {
		return datasourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasource(generators)
	datasourceGenerator = gen.Struct(reflect.TypeOf(Datasource{}), generators)

	return datasourceGenerator
}

// AddIndependentPropertyGeneratorsForDatasource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasource(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_Datasource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Datasource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasource_STATUS, Datasource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasource_STATUS runs a test to see if a specific instance of Datasource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasource_STATUS(subject Datasource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Datasource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Datasource_STATUS instances for property testing - lazily instantiated by Datasource_STATUSGenerator()
var datasource_STATUSGenerator gopter.Gen

// Datasource_STATUSGenerator returns a generator of Datasource_STATUS instances for property testing.
func Datasource_STATUSGenerator() gopter.Gen {
	if datasource_STATUSGenerator != nil {
		return datasource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasource_STATUS(generators)
	datasource_STATUSGenerator = gen.Struct(reflect.TypeOf(Datasource_STATUS{}), generators)

	return datasource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDatasource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasource_STATUS(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceID"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DatasourceSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatasourceSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasourceSet, DatasourceSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasourceSet runs a test to see if a specific instance of DatasourceSet round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasourceSet(subject DatasourceSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatasourceSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatasourceSet instances for property testing - lazily instantiated by DatasourceSetGenerator()
var datasourceSetGenerator gopter.Gen

// DatasourceSetGenerator returns a generator of DatasourceSet instances for property testing.
func DatasourceSetGenerator() gopter.Gen {
	if datasourceSetGenerator != nil {
		return datasourceSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasourceSet(generators)
	datasourceSetGenerator = gen.Struct(reflect.TypeOf(DatasourceSet{}), generators)

	return datasourceSetGenerator
}

// AddIndependentPropertyGeneratorsForDatasourceSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasourceSet(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DatasourceSet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatasourceSet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasourceSet_STATUS, DatasourceSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasourceSet_STATUS runs a test to see if a specific instance of DatasourceSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasourceSet_STATUS(subject DatasourceSet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatasourceSet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatasourceSet_STATUS instances for property testing - lazily instantiated by
// DatasourceSet_STATUSGenerator()
var datasourceSet_STATUSGenerator gopter.Gen

// DatasourceSet_STATUSGenerator returns a generator of DatasourceSet_STATUS instances for property testing.
func DatasourceSet_STATUSGenerator() gopter.Gen {
	if datasourceSet_STATUSGenerator != nil {
		return datasourceSet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasourceSet_STATUS(generators)
	datasourceSet_STATUSGenerator = gen.Struct(reflect.TypeOf(DatasourceSet_STATUS{}), generators)

	return datasourceSet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDatasourceSet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasourceSet_STATUS(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceID"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_PolicyInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyInfo, PolicyInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyInfo runs a test to see if a specific instance of PolicyInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyInfo(subject PolicyInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyInfo instances for property testing - lazily instantiated by PolicyInfoGenerator()
var policyInfoGenerator gopter.Gen

// PolicyInfoGenerator returns a generator of PolicyInfo instances for property testing.
// We first initialize policyInfoGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicyInfoGenerator() gopter.Gen {
	if policyInfoGenerator != nil {
		return policyInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo(generators)
	policyInfoGenerator = gen.Struct(reflect.TypeOf(PolicyInfo{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo(generators)
	AddRelatedPropertyGeneratorsForPolicyInfo(generators)
	policyInfoGenerator = gen.Struct(reflect.TypeOf(PolicyInfo{}), generators)

	return policyInfoGenerator
}

// AddIndependentPropertyGeneratorsForPolicyInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicyInfo(gens map[string]gopter.Gen) {
	gens["PolicyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPolicyInfo is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyInfo(gens map[string]gopter.Gen) {
	gens["PolicyParameters"] = gen.PtrOf(PolicyParametersGenerator())
}

func Test_PolicyInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyInfo_STATUS, PolicyInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyInfo_STATUS runs a test to see if a specific instance of PolicyInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyInfo_STATUS(subject PolicyInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyInfo_STATUS instances for property testing - lazily instantiated by PolicyInfo_STATUSGenerator()
var policyInfo_STATUSGenerator gopter.Gen

// PolicyInfo_STATUSGenerator returns a generator of PolicyInfo_STATUS instances for property testing.
// We first initialize policyInfo_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicyInfo_STATUSGenerator() gopter.Gen {
	if policyInfo_STATUSGenerator != nil {
		return policyInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo_STATUS(generators)
	policyInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicyInfo_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo_STATUS(generators)
	AddRelatedPropertyGeneratorsForPolicyInfo_STATUS(generators)
	policyInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicyInfo_STATUS{}), generators)

	return policyInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPolicyInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicyInfo_STATUS(gens map[string]gopter.Gen) {
	gens["PolicyId"] = gen.PtrOf(gen.AlphaString())
	gens["PolicyVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPolicyInfo_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyInfo_STATUS(gens map[string]gopter.Gen) {
	gens["PolicyParameters"] = gen.PtrOf(PolicyParameters_STATUSGenerator())
}

func Test_ProtectionStatusDetails_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProtectionStatusDetails_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProtectionStatusDetails_STATUS, ProtectionStatusDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProtectionStatusDetails_STATUS runs a test to see if a specific instance of ProtectionStatusDetails_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForProtectionStatusDetails_STATUS(subject ProtectionStatusDetails_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProtectionStatusDetails_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProtectionStatusDetails_STATUS instances for property testing - lazily instantiated by
// ProtectionStatusDetails_STATUSGenerator()
var protectionStatusDetails_STATUSGenerator gopter.Gen

// ProtectionStatusDetails_STATUSGenerator returns a generator of ProtectionStatusDetails_STATUS instances for property testing.
// We first initialize protectionStatusDetails_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProtectionStatusDetails_STATUSGenerator() gopter.Gen {
	if protectionStatusDetails_STATUSGenerator != nil {
		return protectionStatusDetails_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProtectionStatusDetails_STATUS(generators)
	protectionStatusDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(ProtectionStatusDetails_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProtectionStatusDetails_STATUS(generators)
	AddRelatedPropertyGeneratorsForProtectionStatusDetails_STATUS(generators)
	protectionStatusDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(ProtectionStatusDetails_STATUS{}), generators)

	return protectionStatusDetails_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForProtectionStatusDetails_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProtectionStatusDetails_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProtectionStatusDetails_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProtectionStatusDetails_STATUS(gens map[string]gopter.Gen) {
	gens["ErrorDetails"] = gen.PtrOf(UserFacingError_STATUSGenerator())
}

func Test_UserFacingError_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserFacingError_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserFacingError_STATUS, UserFacingError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserFacingError_STATUS runs a test to see if a specific instance of UserFacingError_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserFacingError_STATUS(subject UserFacingError_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserFacingError_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserFacingError_STATUS instances for property testing - lazily instantiated by
// UserFacingError_STATUSGenerator()
var userFacingError_STATUSGenerator gopter.Gen

// UserFacingError_STATUSGenerator returns a generator of UserFacingError_STATUS instances for property testing.
// We first initialize userFacingError_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UserFacingError_STATUSGenerator() gopter.Gen {
	if userFacingError_STATUSGenerator != nil {
		return userFacingError_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserFacingError_STATUS(generators)
	userFacingError_STATUSGenerator = gen.Struct(reflect.TypeOf(UserFacingError_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserFacingError_STATUS(generators)
	AddRelatedPropertyGeneratorsForUserFacingError_STATUS(generators)
	userFacingError_STATUSGenerator = gen.Struct(reflect.TypeOf(UserFacingError_STATUS{}), generators)

	return userFacingError_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserFacingError_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserFacingError_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["IsRetryable"] = gen.PtrOf(gen.Bool())
	gens["IsUserError"] = gen.PtrOf(gen.Bool())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["RecommendedAction"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUserFacingError_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUserFacingError_STATUS(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(UserFacingError_STATUS_UnrolledGenerator())
	gens["InnerError"] = gen.PtrOf(InnerError_STATUSGenerator())
}

func Test_InnerError_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerError_STATUS, InnerError_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerError_STATUS runs a test to see if a specific instance of InnerError_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerError_STATUS(subject InnerError_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_STATUS instances for property testing - lazily instantiated by InnerError_STATUSGenerator()
var innerError_STATUSGenerator gopter.Gen

// InnerError_STATUSGenerator returns a generator of InnerError_STATUS instances for property testing.
// We first initialize innerError_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func InnerError_STATUSGenerator() gopter.Gen {
	if innerError_STATUSGenerator != nil {
		return innerError_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_STATUS(generators)
	innerError_STATUSGenerator = gen.Struct(reflect.TypeOf(InnerError_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_STATUS(generators)
	AddRelatedPropertyGeneratorsForInnerError_STATUS(generators)
	innerError_STATUSGenerator = gen.Struct(reflect.TypeOf(InnerError_STATUS{}), generators)

	return innerError_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForInnerError_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerError_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Code"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForInnerError_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForInnerError_STATUS(gens map[string]gopter.Gen) {
	gens["EmbeddedInnerError"] = gen.PtrOf(InnerError_STATUS_UnrolledGenerator())
}

func Test_PolicyParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyParameters, PolicyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyParameters runs a test to see if a specific instance of PolicyParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyParameters(subject PolicyParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyParameters instances for property testing - lazily instantiated by PolicyParametersGenerator()
var policyParametersGenerator gopter.Gen

// PolicyParametersGenerator returns a generator of PolicyParameters instances for property testing.
func PolicyParametersGenerator() gopter.Gen {
	if policyParametersGenerator != nil {
		return policyParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicyParameters(generators)
	policyParametersGenerator = gen.Struct(reflect.TypeOf(PolicyParameters{}), generators)

	return policyParametersGenerator
}

// AddRelatedPropertyGeneratorsForPolicyParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyParameters(gens map[string]gopter.Gen) {
	gens["BackupDatasourceParametersList"] = gen.SliceOf(BackupDatasourceParametersGenerator())
	gens["DataStoreParametersList"] = gen.SliceOf(DataStoreParametersGenerator())
}

func Test_PolicyParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyParameters_STATUS, PolicyParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyParameters_STATUS runs a test to see if a specific instance of PolicyParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyParameters_STATUS(subject PolicyParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyParameters_STATUS instances for property testing - lazily instantiated by
// PolicyParameters_STATUSGenerator()
var policyParameters_STATUSGenerator gopter.Gen

// PolicyParameters_STATUSGenerator returns a generator of PolicyParameters_STATUS instances for property testing.
func PolicyParameters_STATUSGenerator() gopter.Gen {
	if policyParameters_STATUSGenerator != nil {
		return policyParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicyParameters_STATUS(generators)
	policyParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicyParameters_STATUS{}), generators)

	return policyParameters_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForPolicyParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyParameters_STATUS(gens map[string]gopter.Gen) {
	gens["BackupDatasourceParametersList"] = gen.SliceOf(BackupDatasourceParameters_STATUSGenerator())
	gens["DataStoreParametersList"] = gen.SliceOf(DataStoreParameters_STATUSGenerator())
}

func Test_SecretStoreBasedAuthCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreBasedAuthCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreBasedAuthCredentials, SecretStoreBasedAuthCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreBasedAuthCredentials runs a test to see if a specific instance of SecretStoreBasedAuthCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreBasedAuthCredentials(subject SecretStoreBasedAuthCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreBasedAuthCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreBasedAuthCredentials instances for property testing - lazily instantiated by
// SecretStoreBasedAuthCredentialsGenerator()
var secretStoreBasedAuthCredentialsGenerator gopter.Gen

// SecretStoreBasedAuthCredentialsGenerator returns a generator of SecretStoreBasedAuthCredentials instances for property testing.
// We first initialize secretStoreBasedAuthCredentialsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecretStoreBasedAuthCredentialsGenerator() gopter.Gen {
	if secretStoreBasedAuthCredentialsGenerator != nil {
		return secretStoreBasedAuthCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	secretStoreBasedAuthCredentialsGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	secretStoreBasedAuthCredentialsGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials{}), generators)

	return secretStoreBasedAuthCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials(gens map[string]gopter.Gen) {
	gens["SecretStoreResource"] = gen.PtrOf(SecretStoreResourceGenerator())
}

func Test_SecretStoreBasedAuthCredentials_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreBasedAuthCredentials_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreBasedAuthCredentials_STATUS, SecretStoreBasedAuthCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreBasedAuthCredentials_STATUS runs a test to see if a specific instance of SecretStoreBasedAuthCredentials_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreBasedAuthCredentials_STATUS(subject SecretStoreBasedAuthCredentials_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreBasedAuthCredentials_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreBasedAuthCredentials_STATUS instances for property testing - lazily instantiated by
// SecretStoreBasedAuthCredentials_STATUSGenerator()
var secretStoreBasedAuthCredentials_STATUSGenerator gopter.Gen

// SecretStoreBasedAuthCredentials_STATUSGenerator returns a generator of SecretStoreBasedAuthCredentials_STATUS instances for property testing.
// We first initialize secretStoreBasedAuthCredentials_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecretStoreBasedAuthCredentials_STATUSGenerator() gopter.Gen {
	if secretStoreBasedAuthCredentials_STATUSGenerator != nil {
		return secretStoreBasedAuthCredentials_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(generators)
	secretStoreBasedAuthCredentials_STATUSGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(generators)
	AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(generators)
	secretStoreBasedAuthCredentials_STATUSGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials_STATUS{}), generators)

	return secretStoreBasedAuthCredentials_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["SecretStoreResource"] = gen.PtrOf(SecretStoreResource_STATUSGenerator())
}

func Test_UserFacingError_STATUS_Unrolled_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserFacingError_STATUS_Unrolled via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserFacingError_STATUS_Unrolled, UserFacingError_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserFacingError_STATUS_Unrolled runs a test to see if a specific instance of UserFacingError_STATUS_Unrolled round trips to JSON and back losslessly
func RunJSONSerializationTestForUserFacingError_STATUS_Unrolled(subject UserFacingError_STATUS_Unrolled) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserFacingError_STATUS_Unrolled
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserFacingError_STATUS_Unrolled instances for property testing - lazily instantiated by
// UserFacingError_STATUS_UnrolledGenerator()
var userFacingError_STATUS_UnrolledGenerator gopter.Gen

// UserFacingError_STATUS_UnrolledGenerator returns a generator of UserFacingError_STATUS_Unrolled instances for property testing.
// We first initialize userFacingError_STATUS_UnrolledGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UserFacingError_STATUS_UnrolledGenerator() gopter.Gen {
	if userFacingError_STATUS_UnrolledGenerator != nil {
		return userFacingError_STATUS_UnrolledGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserFacingError_STATUS_Unrolled(generators)
	userFacingError_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(UserFacingError_STATUS_Unrolled{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserFacingError_STATUS_Unrolled(generators)
	AddRelatedPropertyGeneratorsForUserFacingError_STATUS_Unrolled(generators)
	userFacingError_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(UserFacingError_STATUS_Unrolled{}), generators)

	return userFacingError_STATUS_UnrolledGenerator
}

// AddIndependentPropertyGeneratorsForUserFacingError_STATUS_Unrolled is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserFacingError_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["IsRetryable"] = gen.PtrOf(gen.Bool())
	gens["IsUserError"] = gen.PtrOf(gen.Bool())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["RecommendedAction"] = gen.SliceOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUserFacingError_STATUS_Unrolled is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUserFacingError_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["InnerError"] = gen.PtrOf(InnerError_STATUSGenerator())
}

func Test_BackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupDatasourceParameters, BackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupDatasourceParameters runs a test to see if a specific instance of BackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupDatasourceParameters(subject BackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupDatasourceParameters instances for property testing - lazily instantiated by
// BackupDatasourceParametersGenerator()
var backupDatasourceParametersGenerator gopter.Gen

// BackupDatasourceParametersGenerator returns a generator of BackupDatasourceParameters instances for property testing.
func BackupDatasourceParametersGenerator() gopter.Gen {
	if backupDatasourceParametersGenerator != nil {
		return backupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupDatasourceParameters(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupDatasourceParameters{}), map[string]gopter.Gen{propName: propGen}))
	}
	backupDatasourceParametersGenerator = gen.OneGenOf(gens...)

	return backupDatasourceParametersGenerator
}

// AddRelatedPropertyGeneratorsForBackupDatasourceParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["Blob"] = BlobBackupDatasourceParametersGenerator().Map(func(it BlobBackupDatasourceParameters) *BlobBackupDatasourceParameters {
		return &it
	}) // generate one case for OneOf type
	gens["KubernetesCluster"] = KubernetesClusterBackupDatasourceParametersGenerator().Map(func(it KubernetesClusterBackupDatasourceParameters) *KubernetesClusterBackupDatasourceParameters {
		return &it
	}) // generate one case for OneOf type
}

func Test_BackupDatasourceParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupDatasourceParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupDatasourceParameters_STATUS, BackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupDatasourceParameters_STATUS runs a test to see if a specific instance of BackupDatasourceParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupDatasourceParameters_STATUS(subject BackupDatasourceParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupDatasourceParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupDatasourceParameters_STATUS instances for property testing - lazily instantiated by
// BackupDatasourceParameters_STATUSGenerator()
var backupDatasourceParameters_STATUSGenerator gopter.Gen

// BackupDatasourceParameters_STATUSGenerator returns a generator of BackupDatasourceParameters_STATUS instances for property testing.
func BackupDatasourceParameters_STATUSGenerator() gopter.Gen {
	if backupDatasourceParameters_STATUSGenerator != nil {
		return backupDatasourceParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupDatasourceParameters_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupDatasourceParameters_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	backupDatasourceParameters_STATUSGenerator = gen.OneGenOf(gens...)

	return backupDatasourceParameters_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForBackupDatasourceParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupDatasourceParameters_STATUS(gens map[string]gopter.Gen) {
	gens["Blob"] = BlobBackupDatasourceParameters_STATUSGenerator().Map(func(it BlobBackupDatasourceParameters_STATUS) *BlobBackupDatasourceParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["KubernetesCluster"] = KubernetesClusterBackupDatasourceParameters_STATUSGenerator().Map(func(it KubernetesClusterBackupDatasourceParameters_STATUS) *KubernetesClusterBackupDatasourceParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_DataStoreParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataStoreParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataStoreParameters, DataStoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataStoreParameters runs a test to see if a specific instance of DataStoreParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForDataStoreParameters(subject DataStoreParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataStoreParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataStoreParameters instances for property testing - lazily instantiated by
// DataStoreParametersGenerator()
var dataStoreParametersGenerator gopter.Gen

// DataStoreParametersGenerator returns a generator of DataStoreParameters instances for property testing.
func DataStoreParametersGenerator() gopter.Gen {
	if dataStoreParametersGenerator != nil {
		return dataStoreParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataStoreParameters(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DataStoreParameters{}), map[string]gopter.Gen{propName: propGen}))
	}
	dataStoreParametersGenerator = gen.OneGenOf(gens...)

	return dataStoreParametersGenerator
}

// AddRelatedPropertyGeneratorsForDataStoreParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataStoreParameters(gens map[string]gopter.Gen) {
	gens["AzureOperationalStoreParameters"] = AzureOperationalStoreParametersGenerator().Map(func(it AzureOperationalStoreParameters) *AzureOperationalStoreParameters {
		return &it
	}) // generate one case for OneOf type
}

func Test_DataStoreParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataStoreParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataStoreParameters_STATUS, DataStoreParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataStoreParameters_STATUS runs a test to see if a specific instance of DataStoreParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataStoreParameters_STATUS(subject DataStoreParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataStoreParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataStoreParameters_STATUS instances for property testing - lazily instantiated by
// DataStoreParameters_STATUSGenerator()
var dataStoreParameters_STATUSGenerator gopter.Gen

// DataStoreParameters_STATUSGenerator returns a generator of DataStoreParameters_STATUS instances for property testing.
func DataStoreParameters_STATUSGenerator() gopter.Gen {
	if dataStoreParameters_STATUSGenerator != nil {
		return dataStoreParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataStoreParameters_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DataStoreParameters_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	dataStoreParameters_STATUSGenerator = gen.OneGenOf(gens...)

	return dataStoreParameters_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDataStoreParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataStoreParameters_STATUS(gens map[string]gopter.Gen) {
	gens["AzureOperationalStoreParameters"] = AzureOperationalStoreParameters_STATUSGenerator().Map(func(it AzureOperationalStoreParameters_STATUS) *AzureOperationalStoreParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_InnerError_STATUS_Unrolled_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_STATUS_Unrolled via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerError_STATUS_Unrolled, InnerError_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerError_STATUS_Unrolled runs a test to see if a specific instance of InnerError_STATUS_Unrolled round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerError_STATUS_Unrolled(subject InnerError_STATUS_Unrolled) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_STATUS_Unrolled
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_STATUS_Unrolled instances for property testing - lazily instantiated by
// InnerError_STATUS_UnrolledGenerator()
var innerError_STATUS_UnrolledGenerator gopter.Gen

// InnerError_STATUS_UnrolledGenerator returns a generator of InnerError_STATUS_Unrolled instances for property testing.
func InnerError_STATUS_UnrolledGenerator() gopter.Gen {
	if innerError_STATUS_UnrolledGenerator != nil {
		return innerError_STATUS_UnrolledGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerError_STATUS_Unrolled(generators)
	innerError_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(InnerError_STATUS_Unrolled{}), generators)

	return innerError_STATUS_UnrolledGenerator
}

// AddIndependentPropertyGeneratorsForInnerError_STATUS_Unrolled is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerError_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Code"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecretStoreResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreResource, SecretStoreResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreResource runs a test to see if a specific instance of SecretStoreResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreResource(subject SecretStoreResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreResource instances for property testing - lazily instantiated by
// SecretStoreResourceGenerator()
var secretStoreResourceGenerator gopter.Gen

// SecretStoreResourceGenerator returns a generator of SecretStoreResource instances for property testing.
func SecretStoreResourceGenerator() gopter.Gen {
	if secretStoreResourceGenerator != nil {
		return secretStoreResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreResource(generators)
	secretStoreResourceGenerator = gen.Struct(reflect.TypeOf(SecretStoreResource{}), generators)

	return secretStoreResourceGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreResource(gens map[string]gopter.Gen) {
	gens["SecretStoreType"] = gen.PtrOf(gen.AlphaString())
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecretStoreResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreResource_STATUS, SecretStoreResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreResource_STATUS runs a test to see if a specific instance of SecretStoreResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreResource_STATUS(subject SecretStoreResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreResource_STATUS instances for property testing - lazily instantiated by
// SecretStoreResource_STATUSGenerator()
var secretStoreResource_STATUSGenerator gopter.Gen

// SecretStoreResource_STATUSGenerator returns a generator of SecretStoreResource_STATUS instances for property testing.
func SecretStoreResource_STATUSGenerator() gopter.Gen {
	if secretStoreResource_STATUSGenerator != nil {
		return secretStoreResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreResource_STATUS(generators)
	secretStoreResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SecretStoreResource_STATUS{}), generators)

	return secretStoreResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreResource_STATUS(gens map[string]gopter.Gen) {
	gens["SecretStoreType"] = gen.PtrOf(gen.AlphaString())
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureOperationalStoreParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureOperationalStoreParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureOperationalStoreParameters, AzureOperationalStoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureOperationalStoreParameters runs a test to see if a specific instance of AzureOperationalStoreParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureOperationalStoreParameters(subject AzureOperationalStoreParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureOperationalStoreParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureOperationalStoreParameters instances for property testing - lazily instantiated by
// AzureOperationalStoreParametersGenerator()
var azureOperationalStoreParametersGenerator gopter.Gen

// AzureOperationalStoreParametersGenerator returns a generator of AzureOperationalStoreParameters instances for property testing.
func AzureOperationalStoreParametersGenerator() gopter.Gen {
	if azureOperationalStoreParametersGenerator != nil {
		return azureOperationalStoreParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters(generators)
	azureOperationalStoreParametersGenerator = gen.Struct(reflect.TypeOf(AzureOperationalStoreParameters{}), generators)

	return azureOperationalStoreParametersGenerator
}

// AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters(gens map[string]gopter.Gen) {
	gens["DataStoreType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureOperationalStoreParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureOperationalStoreParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureOperationalStoreParameters_STATUS, AzureOperationalStoreParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureOperationalStoreParameters_STATUS runs a test to see if a specific instance of AzureOperationalStoreParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureOperationalStoreParameters_STATUS(subject AzureOperationalStoreParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureOperationalStoreParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureOperationalStoreParameters_STATUS instances for property testing - lazily instantiated by
// AzureOperationalStoreParameters_STATUSGenerator()
var azureOperationalStoreParameters_STATUSGenerator gopter.Gen

// AzureOperationalStoreParameters_STATUSGenerator returns a generator of AzureOperationalStoreParameters_STATUS instances for property testing.
func AzureOperationalStoreParameters_STATUSGenerator() gopter.Gen {
	if azureOperationalStoreParameters_STATUSGenerator != nil {
		return azureOperationalStoreParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_STATUS(generators)
	azureOperationalStoreParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureOperationalStoreParameters_STATUS{}), generators)

	return azureOperationalStoreParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_STATUS(gens map[string]gopter.Gen) {
	gens["DataStoreType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobBackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobBackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobBackupDatasourceParameters, BlobBackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobBackupDatasourceParameters runs a test to see if a specific instance of BlobBackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobBackupDatasourceParameters(subject BlobBackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobBackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobBackupDatasourceParameters instances for property testing - lazily instantiated by
// BlobBackupDatasourceParametersGenerator()
var blobBackupDatasourceParametersGenerator gopter.Gen

// BlobBackupDatasourceParametersGenerator returns a generator of BlobBackupDatasourceParameters instances for property testing.
func BlobBackupDatasourceParametersGenerator() gopter.Gen {
	if blobBackupDatasourceParametersGenerator != nil {
		return blobBackupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters(generators)
	blobBackupDatasourceParametersGenerator = gen.Struct(reflect.TypeOf(BlobBackupDatasourceParameters{}), generators)

	return blobBackupDatasourceParametersGenerator
}

// AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["ContainersList"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobBackupDatasourceParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobBackupDatasourceParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobBackupDatasourceParameters_STATUS, BlobBackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobBackupDatasourceParameters_STATUS runs a test to see if a specific instance of BlobBackupDatasourceParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobBackupDatasourceParameters_STATUS(subject BlobBackupDatasourceParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobBackupDatasourceParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobBackupDatasourceParameters_STATUS instances for property testing - lazily instantiated by
// BlobBackupDatasourceParameters_STATUSGenerator()
var blobBackupDatasourceParameters_STATUSGenerator gopter.Gen

// BlobBackupDatasourceParameters_STATUSGenerator returns a generator of BlobBackupDatasourceParameters_STATUS instances for property testing.
func BlobBackupDatasourceParameters_STATUSGenerator() gopter.Gen {
	if blobBackupDatasourceParameters_STATUSGenerator != nil {
		return blobBackupDatasourceParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_STATUS(generators)
	blobBackupDatasourceParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(BlobBackupDatasourceParameters_STATUS{}), generators)

	return blobBackupDatasourceParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ContainersList"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
}

func Test_KubernetesClusterBackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubernetesClusterBackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters, KubernetesClusterBackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters runs a test to see if a specific instance of KubernetesClusterBackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters(subject KubernetesClusterBackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubernetesClusterBackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubernetesClusterBackupDatasourceParameters instances for property testing - lazily instantiated by
// KubernetesClusterBackupDatasourceParametersGenerator()
var kubernetesClusterBackupDatasourceParametersGenerator gopter.Gen

// KubernetesClusterBackupDatasourceParametersGenerator returns a generator of KubernetesClusterBackupDatasourceParameters instances for property testing.
func KubernetesClusterBackupDatasourceParametersGenerator() gopter.Gen {
	if kubernetesClusterBackupDatasourceParametersGenerator != nil {
		return kubernetesClusterBackupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(generators)
	kubernetesClusterBackupDatasourceParametersGenerator = gen.Struct(reflect.TypeOf(KubernetesClusterBackupDatasourceParameters{}), generators)

	return kubernetesClusterBackupDatasourceParametersGenerator
}

// AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["ExcludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["ExcludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IncludeClusterScopeResources"] = gen.PtrOf(gen.Bool())
	gens["IncludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["IncludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["LabelSelectors"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["SnapshotVolumes"] = gen.PtrOf(gen.Bool())
}

func Test_KubernetesClusterBackupDatasourceParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubernetesClusterBackupDatasourceParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_STATUS, KubernetesClusterBackupDatasourceParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_STATUS runs a test to see if a specific instance of KubernetesClusterBackupDatasourceParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_STATUS(subject KubernetesClusterBackupDatasourceParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubernetesClusterBackupDatasourceParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubernetesClusterBackupDatasourceParameters_STATUS instances for property testing - lazily instantiated
// by KubernetesClusterBackupDatasourceParameters_STATUSGenerator()
var kubernetesClusterBackupDatasourceParameters_STATUSGenerator gopter.Gen

// KubernetesClusterBackupDatasourceParameters_STATUSGenerator returns a generator of KubernetesClusterBackupDatasourceParameters_STATUS instances for property testing.
func KubernetesClusterBackupDatasourceParameters_STATUSGenerator() gopter.Gen {
	if kubernetesClusterBackupDatasourceParameters_STATUSGenerator != nil {
		return kubernetesClusterBackupDatasourceParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_STATUS(generators)
	kubernetesClusterBackupDatasourceParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(KubernetesClusterBackupDatasourceParameters_STATUS{}), generators)

	return kubernetesClusterBackupDatasourceParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ExcludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["ExcludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IncludeClusterScopeResources"] = gen.PtrOf(gen.Bool())
	gens["IncludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["IncludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["LabelSelectors"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["SnapshotVolumes"] = gen.PtrOf(gen.Bool())
}
