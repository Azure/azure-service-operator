// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20231101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AbsoluteDeleteOption_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AbsoluteDeleteOption_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAbsoluteDeleteOption_ARM, AbsoluteDeleteOption_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAbsoluteDeleteOption_ARM runs a test to see if a specific instance of AbsoluteDeleteOption_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAbsoluteDeleteOption_ARM(subject AbsoluteDeleteOption_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AbsoluteDeleteOption_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AbsoluteDeleteOption_ARM instances for property testing - lazily instantiated by
// AbsoluteDeleteOption_ARMGenerator()
var absoluteDeleteOption_ARMGenerator gopter.Gen

// AbsoluteDeleteOption_ARMGenerator returns a generator of AbsoluteDeleteOption_ARM instances for property testing.
func AbsoluteDeleteOption_ARMGenerator() gopter.Gen {
	if absoluteDeleteOption_ARMGenerator != nil {
		return absoluteDeleteOption_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAbsoluteDeleteOption_ARM(generators)
	absoluteDeleteOption_ARMGenerator = gen.Struct(reflect.TypeOf(AbsoluteDeleteOption_ARM{}), generators)

	return absoluteDeleteOption_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAbsoluteDeleteOption_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAbsoluteDeleteOption_ARM(gens map[string]gopter.Gen) {
	gens["Duration"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(AbsoluteDeleteOption_ObjectType_ARM_AbsoluteDeleteOption)
}

func Test_AdhocBasedTaggingCriteria_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdhocBasedTaggingCriteria_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdhocBasedTaggingCriteria_ARM, AdhocBasedTaggingCriteria_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdhocBasedTaggingCriteria_ARM runs a test to see if a specific instance of AdhocBasedTaggingCriteria_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdhocBasedTaggingCriteria_ARM(subject AdhocBasedTaggingCriteria_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdhocBasedTaggingCriteria_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdhocBasedTaggingCriteria_ARM instances for property testing - lazily instantiated by
// AdhocBasedTaggingCriteria_ARMGenerator()
var adhocBasedTaggingCriteria_ARMGenerator gopter.Gen

// AdhocBasedTaggingCriteria_ARMGenerator returns a generator of AdhocBasedTaggingCriteria_ARM instances for property testing.
func AdhocBasedTaggingCriteria_ARMGenerator() gopter.Gen {
	if adhocBasedTaggingCriteria_ARMGenerator != nil {
		return adhocBasedTaggingCriteria_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdhocBasedTaggingCriteria_ARM(generators)
	adhocBasedTaggingCriteria_ARMGenerator = gen.Struct(reflect.TypeOf(AdhocBasedTaggingCriteria_ARM{}), generators)

	return adhocBasedTaggingCriteria_ARMGenerator
}

// AddRelatedPropertyGeneratorsForAdhocBasedTaggingCriteria_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdhocBasedTaggingCriteria_ARM(gens map[string]gopter.Gen) {
	gens["TagInfo"] = gen.PtrOf(RetentionTag_ARMGenerator())
}

func Test_AdhocBasedTriggerContext_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdhocBasedTriggerContext_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdhocBasedTriggerContext_ARM, AdhocBasedTriggerContext_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdhocBasedTriggerContext_ARM runs a test to see if a specific instance of AdhocBasedTriggerContext_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdhocBasedTriggerContext_ARM(subject AdhocBasedTriggerContext_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdhocBasedTriggerContext_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdhocBasedTriggerContext_ARM instances for property testing - lazily instantiated by
// AdhocBasedTriggerContext_ARMGenerator()
var adhocBasedTriggerContext_ARMGenerator gopter.Gen

// AdhocBasedTriggerContext_ARMGenerator returns a generator of AdhocBasedTriggerContext_ARM instances for property testing.
// We first initialize adhocBasedTriggerContext_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AdhocBasedTriggerContext_ARMGenerator() gopter.Gen {
	if adhocBasedTriggerContext_ARMGenerator != nil {
		return adhocBasedTriggerContext_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdhocBasedTriggerContext_ARM(generators)
	adhocBasedTriggerContext_ARMGenerator = gen.Struct(reflect.TypeOf(AdhocBasedTriggerContext_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdhocBasedTriggerContext_ARM(generators)
	AddRelatedPropertyGeneratorsForAdhocBasedTriggerContext_ARM(generators)
	adhocBasedTriggerContext_ARMGenerator = gen.Struct(reflect.TypeOf(AdhocBasedTriggerContext_ARM{}), generators)

	return adhocBasedTriggerContext_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAdhocBasedTriggerContext_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdhocBasedTriggerContext_ARM(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(AdhocBasedTriggerContext_ObjectType_ARM_AdhocBasedTriggerContext)
}

// AddRelatedPropertyGeneratorsForAdhocBasedTriggerContext_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdhocBasedTriggerContext_ARM(gens map[string]gopter.Gen) {
	gens["TaggingCriteria"] = gen.PtrOf(AdhocBasedTaggingCriteria_ARMGenerator())
}

func Test_AzureBackupParams_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureBackupParams_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureBackupParams_ARM, AzureBackupParams_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureBackupParams_ARM runs a test to see if a specific instance of AzureBackupParams_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureBackupParams_ARM(subject AzureBackupParams_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureBackupParams_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureBackupParams_ARM instances for property testing - lazily instantiated by
// AzureBackupParams_ARMGenerator()
var azureBackupParams_ARMGenerator gopter.Gen

// AzureBackupParams_ARMGenerator returns a generator of AzureBackupParams_ARM instances for property testing.
func AzureBackupParams_ARMGenerator() gopter.Gen {
	if azureBackupParams_ARMGenerator != nil {
		return azureBackupParams_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBackupParams_ARM(generators)
	azureBackupParams_ARMGenerator = gen.Struct(reflect.TypeOf(AzureBackupParams_ARM{}), generators)

	return azureBackupParams_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureBackupParams_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureBackupParams_ARM(gens map[string]gopter.Gen) {
	gens["BackupType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(AzureBackupParams_ObjectType_ARM_AzureBackupParams)
}

func Test_AzureBackupRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureBackupRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureBackupRule_ARM, AzureBackupRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureBackupRule_ARM runs a test to see if a specific instance of AzureBackupRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureBackupRule_ARM(subject AzureBackupRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureBackupRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureBackupRule_ARM instances for property testing - lazily instantiated by
// AzureBackupRule_ARMGenerator()
var azureBackupRule_ARMGenerator gopter.Gen

// AzureBackupRule_ARMGenerator returns a generator of AzureBackupRule_ARM instances for property testing.
// We first initialize azureBackupRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureBackupRule_ARMGenerator() gopter.Gen {
	if azureBackupRule_ARMGenerator != nil {
		return azureBackupRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBackupRule_ARM(generators)
	azureBackupRule_ARMGenerator = gen.Struct(reflect.TypeOf(AzureBackupRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBackupRule_ARM(generators)
	AddRelatedPropertyGeneratorsForAzureBackupRule_ARM(generators)
	azureBackupRule_ARMGenerator = gen.Struct(reflect.TypeOf(AzureBackupRule_ARM{}), generators)

	return azureBackupRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureBackupRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureBackupRule_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(AzureBackupRule_ObjectType_ARM_AzureBackupRule)
}

// AddRelatedPropertyGeneratorsForAzureBackupRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureBackupRule_ARM(gens map[string]gopter.Gen) {
	gens["BackupParameters"] = gen.PtrOf(BackupParameters_ARMGenerator())
	gens["DataStore"] = gen.PtrOf(DataStoreInfoBase_ARMGenerator())
	gens["Trigger"] = gen.PtrOf(TriggerContext_ARMGenerator())
}

func Test_AzureRetentionRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureRetentionRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureRetentionRule_ARM, AzureRetentionRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureRetentionRule_ARM runs a test to see if a specific instance of AzureRetentionRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureRetentionRule_ARM(subject AzureRetentionRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureRetentionRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureRetentionRule_ARM instances for property testing - lazily instantiated by
// AzureRetentionRule_ARMGenerator()
var azureRetentionRule_ARMGenerator gopter.Gen

// AzureRetentionRule_ARMGenerator returns a generator of AzureRetentionRule_ARM instances for property testing.
// We first initialize azureRetentionRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureRetentionRule_ARMGenerator() gopter.Gen {
	if azureRetentionRule_ARMGenerator != nil {
		return azureRetentionRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureRetentionRule_ARM(generators)
	azureRetentionRule_ARMGenerator = gen.Struct(reflect.TypeOf(AzureRetentionRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureRetentionRule_ARM(generators)
	AddRelatedPropertyGeneratorsForAzureRetentionRule_ARM(generators)
	azureRetentionRule_ARMGenerator = gen.Struct(reflect.TypeOf(AzureRetentionRule_ARM{}), generators)

	return azureRetentionRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureRetentionRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureRetentionRule_ARM(gens map[string]gopter.Gen) {
	gens["IsDefault"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(AzureRetentionRule_ObjectType_ARM_AzureRetentionRule)
}

// AddRelatedPropertyGeneratorsForAzureRetentionRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureRetentionRule_ARM(gens map[string]gopter.Gen) {
	gens["Lifecycles"] = gen.SliceOf(SourceLifeCycle_ARMGenerator())
}

func Test_BackupCriteria_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupCriteria_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupCriteria_ARM, BackupCriteria_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupCriteria_ARM runs a test to see if a specific instance of BackupCriteria_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupCriteria_ARM(subject BackupCriteria_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupCriteria_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupCriteria_ARM instances for property testing - lazily instantiated by BackupCriteria_ARMGenerator()
var backupCriteria_ARMGenerator gopter.Gen

// BackupCriteria_ARMGenerator returns a generator of BackupCriteria_ARM instances for property testing.
func BackupCriteria_ARMGenerator() gopter.Gen {
	if backupCriteria_ARMGenerator != nil {
		return backupCriteria_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupCriteria_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupCriteria_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	backupCriteria_ARMGenerator = gen.OneGenOf(gens...)

	return backupCriteria_ARMGenerator
}

// AddRelatedPropertyGeneratorsForBackupCriteria_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupCriteria_ARM(gens map[string]gopter.Gen) {
	gens["ScheduleBasedBackupCriteria"] = ScheduleBasedBackupCriteria_ARMGenerator().Map(func(it ScheduleBasedBackupCriteria_ARM) *ScheduleBasedBackupCriteria_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_BackupParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupParameters_ARM, BackupParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupParameters_ARM runs a test to see if a specific instance of BackupParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupParameters_ARM(subject BackupParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupParameters_ARM instances for property testing - lazily instantiated by
// BackupParameters_ARMGenerator()
var backupParameters_ARMGenerator gopter.Gen

// BackupParameters_ARMGenerator returns a generator of BackupParameters_ARM instances for property testing.
func BackupParameters_ARMGenerator() gopter.Gen {
	if backupParameters_ARMGenerator != nil {
		return backupParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupParameters_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupParameters_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	backupParameters_ARMGenerator = gen.OneGenOf(gens...)

	return backupParameters_ARMGenerator
}

// AddRelatedPropertyGeneratorsForBackupParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupParameters_ARM(gens map[string]gopter.Gen) {
	gens["AzureBackupParams"] = AzureBackupParams_ARMGenerator().Map(func(it AzureBackupParams_ARM) *AzureBackupParams_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_BackupPolicy_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_ARM, BackupPolicy_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_ARM runs a test to see if a specific instance of BackupPolicy_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_ARM(subject BackupPolicy_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_ARM instances for property testing - lazily instantiated by BackupPolicy_ARMGenerator()
var backupPolicy_ARMGenerator gopter.Gen

// BackupPolicy_ARMGenerator returns a generator of BackupPolicy_ARM instances for property testing.
// We first initialize backupPolicy_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupPolicy_ARMGenerator() gopter.Gen {
	if backupPolicy_ARMGenerator != nil {
		return backupPolicy_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_ARM(generators)
	backupPolicy_ARMGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_ARM(generators)
	AddRelatedPropertyGeneratorsForBackupPolicy_ARM(generators)
	backupPolicy_ARMGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_ARM{}), generators)

	return backupPolicy_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_ARM(gens map[string]gopter.Gen) {
	gens["DatasourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(BackupPolicy_ObjectType_ARM_BackupPolicy)
}

// AddRelatedPropertyGeneratorsForBackupPolicy_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupPolicy_ARM(gens map[string]gopter.Gen) {
	gens["PolicyRules"] = gen.SliceOf(BasePolicyRule_ARMGenerator())
}

func Test_BackupSchedule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupSchedule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupSchedule_ARM, BackupSchedule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupSchedule_ARM runs a test to see if a specific instance of BackupSchedule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupSchedule_ARM(subject BackupSchedule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupSchedule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupSchedule_ARM instances for property testing - lazily instantiated by BackupSchedule_ARMGenerator()
var backupSchedule_ARMGenerator gopter.Gen

// BackupSchedule_ARMGenerator returns a generator of BackupSchedule_ARM instances for property testing.
func BackupSchedule_ARMGenerator() gopter.Gen {
	if backupSchedule_ARMGenerator != nil {
		return backupSchedule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupSchedule_ARM(generators)
	backupSchedule_ARMGenerator = gen.Struct(reflect.TypeOf(BackupSchedule_ARM{}), generators)

	return backupSchedule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupSchedule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupSchedule_ARM(gens map[string]gopter.Gen) {
	gens["RepeatingTimeIntervals"] = gen.SliceOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupVaults_BackupPolicy_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaults_BackupPolicy_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaults_BackupPolicy_Spec_ARM, BackupVaults_BackupPolicy_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaults_BackupPolicy_Spec_ARM runs a test to see if a specific instance of BackupVaults_BackupPolicy_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaults_BackupPolicy_Spec_ARM(subject BackupVaults_BackupPolicy_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaults_BackupPolicy_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaults_BackupPolicy_Spec_ARM instances for property testing - lazily instantiated by
// BackupVaults_BackupPolicy_Spec_ARMGenerator()
var backupVaults_BackupPolicy_Spec_ARMGenerator gopter.Gen

// BackupVaults_BackupPolicy_Spec_ARMGenerator returns a generator of BackupVaults_BackupPolicy_Spec_ARM instances for property testing.
// We first initialize backupVaults_BackupPolicy_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupVaults_BackupPolicy_Spec_ARMGenerator() gopter.Gen {
	if backupVaults_BackupPolicy_Spec_ARMGenerator != nil {
		return backupVaults_BackupPolicy_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupPolicy_Spec_ARM(generators)
	backupVaults_BackupPolicy_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupPolicy_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupPolicy_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForBackupVaults_BackupPolicy_Spec_ARM(generators)
	backupVaults_BackupPolicy_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupPolicy_Spec_ARM{}), generators)

	return backupVaults_BackupPolicy_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupVaults_BackupPolicy_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupVaults_BackupPolicy_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForBackupVaults_BackupPolicy_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaults_BackupPolicy_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BaseBackupPolicy_ARMGenerator())
}

func Test_BaseBackupPolicy_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaseBackupPolicy_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaseBackupPolicy_ARM, BaseBackupPolicy_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaseBackupPolicy_ARM runs a test to see if a specific instance of BaseBackupPolicy_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBaseBackupPolicy_ARM(subject BaseBackupPolicy_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaseBackupPolicy_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaseBackupPolicy_ARM instances for property testing - lazily instantiated by
// BaseBackupPolicy_ARMGenerator()
var baseBackupPolicy_ARMGenerator gopter.Gen

// BaseBackupPolicy_ARMGenerator returns a generator of BaseBackupPolicy_ARM instances for property testing.
func BaseBackupPolicy_ARMGenerator() gopter.Gen {
	if baseBackupPolicy_ARMGenerator != nil {
		return baseBackupPolicy_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBaseBackupPolicy_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BaseBackupPolicy_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	baseBackupPolicy_ARMGenerator = gen.OneGenOf(gens...)

	return baseBackupPolicy_ARMGenerator
}

// AddRelatedPropertyGeneratorsForBaseBackupPolicy_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaseBackupPolicy_ARM(gens map[string]gopter.Gen) {
	gens["BackupPolicy"] = BackupPolicy_ARMGenerator().Map(func(it BackupPolicy_ARM) *BackupPolicy_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_BasePolicyRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BasePolicyRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBasePolicyRule_ARM, BasePolicyRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBasePolicyRule_ARM runs a test to see if a specific instance of BasePolicyRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBasePolicyRule_ARM(subject BasePolicyRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BasePolicyRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BasePolicyRule_ARM instances for property testing - lazily instantiated by BasePolicyRule_ARMGenerator()
var basePolicyRule_ARMGenerator gopter.Gen

// BasePolicyRule_ARMGenerator returns a generator of BasePolicyRule_ARM instances for property testing.
func BasePolicyRule_ARMGenerator() gopter.Gen {
	if basePolicyRule_ARMGenerator != nil {
		return basePolicyRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBasePolicyRule_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BasePolicyRule_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	basePolicyRule_ARMGenerator = gen.OneGenOf(gens...)

	return basePolicyRule_ARMGenerator
}

// AddRelatedPropertyGeneratorsForBasePolicyRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBasePolicyRule_ARM(gens map[string]gopter.Gen) {
	gens["AzureBackup"] = AzureBackupRule_ARMGenerator().Map(func(it AzureBackupRule_ARM) *AzureBackupRule_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["AzureRetention"] = AzureRetentionRule_ARMGenerator().Map(func(it AzureRetentionRule_ARM) *AzureRetentionRule_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_CopyOnExpiryOption_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CopyOnExpiryOption_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCopyOnExpiryOption_ARM, CopyOnExpiryOption_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCopyOnExpiryOption_ARM runs a test to see if a specific instance of CopyOnExpiryOption_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCopyOnExpiryOption_ARM(subject CopyOnExpiryOption_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CopyOnExpiryOption_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CopyOnExpiryOption_ARM instances for property testing - lazily instantiated by
// CopyOnExpiryOption_ARMGenerator()
var copyOnExpiryOption_ARMGenerator gopter.Gen

// CopyOnExpiryOption_ARMGenerator returns a generator of CopyOnExpiryOption_ARM instances for property testing.
func CopyOnExpiryOption_ARMGenerator() gopter.Gen {
	if copyOnExpiryOption_ARMGenerator != nil {
		return copyOnExpiryOption_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCopyOnExpiryOption_ARM(generators)
	copyOnExpiryOption_ARMGenerator = gen.Struct(reflect.TypeOf(CopyOnExpiryOption_ARM{}), generators)

	return copyOnExpiryOption_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCopyOnExpiryOption_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCopyOnExpiryOption_ARM(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(CopyOnExpiryOption_ObjectType_ARM_CopyOnExpiryOption)
}

func Test_CopyOption_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CopyOption_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCopyOption_ARM, CopyOption_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCopyOption_ARM runs a test to see if a specific instance of CopyOption_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCopyOption_ARM(subject CopyOption_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CopyOption_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CopyOption_ARM instances for property testing - lazily instantiated by CopyOption_ARMGenerator()
var copyOption_ARMGenerator gopter.Gen

// CopyOption_ARMGenerator returns a generator of CopyOption_ARM instances for property testing.
func CopyOption_ARMGenerator() gopter.Gen {
	if copyOption_ARMGenerator != nil {
		return copyOption_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCopyOption_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(CopyOption_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	copyOption_ARMGenerator = gen.OneGenOf(gens...)

	return copyOption_ARMGenerator
}

// AddRelatedPropertyGeneratorsForCopyOption_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCopyOption_ARM(gens map[string]gopter.Gen) {
	gens["CopyOnExpiry"] = CopyOnExpiryOption_ARMGenerator().Map(func(it CopyOnExpiryOption_ARM) *CopyOnExpiryOption_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["CustomCopy"] = CustomCopyOption_ARMGenerator().Map(func(it CustomCopyOption_ARM) *CustomCopyOption_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["ImmediateCopy"] = ImmediateCopyOption_ARMGenerator().Map(func(it ImmediateCopyOption_ARM) *ImmediateCopyOption_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_CustomCopyOption_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomCopyOption_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomCopyOption_ARM, CustomCopyOption_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomCopyOption_ARM runs a test to see if a specific instance of CustomCopyOption_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomCopyOption_ARM(subject CustomCopyOption_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomCopyOption_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomCopyOption_ARM instances for property testing - lazily instantiated by
// CustomCopyOption_ARMGenerator()
var customCopyOption_ARMGenerator gopter.Gen

// CustomCopyOption_ARMGenerator returns a generator of CustomCopyOption_ARM instances for property testing.
func CustomCopyOption_ARMGenerator() gopter.Gen {
	if customCopyOption_ARMGenerator != nil {
		return customCopyOption_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomCopyOption_ARM(generators)
	customCopyOption_ARMGenerator = gen.Struct(reflect.TypeOf(CustomCopyOption_ARM{}), generators)

	return customCopyOption_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomCopyOption_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomCopyOption_ARM(gens map[string]gopter.Gen) {
	gens["Duration"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(CustomCopyOption_ObjectType_ARM_CustomCopyOption)
}

func Test_DataStoreInfoBase_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataStoreInfoBase_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataStoreInfoBase_ARM, DataStoreInfoBase_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataStoreInfoBase_ARM runs a test to see if a specific instance of DataStoreInfoBase_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataStoreInfoBase_ARM(subject DataStoreInfoBase_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataStoreInfoBase_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataStoreInfoBase_ARM instances for property testing - lazily instantiated by
// DataStoreInfoBase_ARMGenerator()
var dataStoreInfoBase_ARMGenerator gopter.Gen

// DataStoreInfoBase_ARMGenerator returns a generator of DataStoreInfoBase_ARM instances for property testing.
func DataStoreInfoBase_ARMGenerator() gopter.Gen {
	if dataStoreInfoBase_ARMGenerator != nil {
		return dataStoreInfoBase_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataStoreInfoBase_ARM(generators)
	dataStoreInfoBase_ARMGenerator = gen.Struct(reflect.TypeOf(DataStoreInfoBase_ARM{}), generators)

	return dataStoreInfoBase_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDataStoreInfoBase_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataStoreInfoBase_ARM(gens map[string]gopter.Gen) {
	gens["DataStoreType"] = gen.PtrOf(gen.OneConstOf(DataStoreInfoBase_DataStoreType_ARM_ArchiveStore, DataStoreInfoBase_DataStoreType_ARM_OperationalStore, DataStoreInfoBase_DataStoreType_ARM_VaultStore))
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
}

func Test_Day_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Day_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDay_ARM, Day_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDay_ARM runs a test to see if a specific instance of Day_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDay_ARM(subject Day_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Day_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Day_ARM instances for property testing - lazily instantiated by Day_ARMGenerator()
var day_ARMGenerator gopter.Gen

// Day_ARMGenerator returns a generator of Day_ARM instances for property testing.
func Day_ARMGenerator() gopter.Gen {
	if day_ARMGenerator != nil {
		return day_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDay_ARM(generators)
	day_ARMGenerator = gen.Struct(reflect.TypeOf(Day_ARM{}), generators)

	return day_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDay_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDay_ARM(gens map[string]gopter.Gen) {
	gens["Date"] = gen.PtrOf(gen.Int())
	gens["IsLast"] = gen.PtrOf(gen.Bool())
}

func Test_DeleteOption_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeleteOption_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeleteOption_ARM, DeleteOption_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeleteOption_ARM runs a test to see if a specific instance of DeleteOption_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeleteOption_ARM(subject DeleteOption_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeleteOption_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeleteOption_ARM instances for property testing - lazily instantiated by DeleteOption_ARMGenerator()
var deleteOption_ARMGenerator gopter.Gen

// DeleteOption_ARMGenerator returns a generator of DeleteOption_ARM instances for property testing.
func DeleteOption_ARMGenerator() gopter.Gen {
	if deleteOption_ARMGenerator != nil {
		return deleteOption_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeleteOption_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeleteOption_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	deleteOption_ARMGenerator = gen.OneGenOf(gens...)

	return deleteOption_ARMGenerator
}

// AddRelatedPropertyGeneratorsForDeleteOption_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeleteOption_ARM(gens map[string]gopter.Gen) {
	gens["AbsoluteDeleteOption"] = AbsoluteDeleteOption_ARMGenerator().Map(func(it AbsoluteDeleteOption_ARM) *AbsoluteDeleteOption_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_ImmediateCopyOption_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImmediateCopyOption_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImmediateCopyOption_ARM, ImmediateCopyOption_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImmediateCopyOption_ARM runs a test to see if a specific instance of ImmediateCopyOption_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImmediateCopyOption_ARM(subject ImmediateCopyOption_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImmediateCopyOption_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImmediateCopyOption_ARM instances for property testing - lazily instantiated by
// ImmediateCopyOption_ARMGenerator()
var immediateCopyOption_ARMGenerator gopter.Gen

// ImmediateCopyOption_ARMGenerator returns a generator of ImmediateCopyOption_ARM instances for property testing.
func ImmediateCopyOption_ARMGenerator() gopter.Gen {
	if immediateCopyOption_ARMGenerator != nil {
		return immediateCopyOption_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImmediateCopyOption_ARM(generators)
	immediateCopyOption_ARMGenerator = gen.Struct(reflect.TypeOf(ImmediateCopyOption_ARM{}), generators)

	return immediateCopyOption_ARMGenerator
}

// AddIndependentPropertyGeneratorsForImmediateCopyOption_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImmediateCopyOption_ARM(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(ImmediateCopyOption_ObjectType_ARM_ImmediateCopyOption)
}

func Test_RetentionTag_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetentionTag_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetentionTag_ARM, RetentionTag_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetentionTag_ARM runs a test to see if a specific instance of RetentionTag_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRetentionTag_ARM(subject RetentionTag_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetentionTag_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetentionTag_ARM instances for property testing - lazily instantiated by RetentionTag_ARMGenerator()
var retentionTag_ARMGenerator gopter.Gen

// RetentionTag_ARMGenerator returns a generator of RetentionTag_ARM instances for property testing.
func RetentionTag_ARMGenerator() gopter.Gen {
	if retentionTag_ARMGenerator != nil {
		return retentionTag_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetentionTag_ARM(generators)
	retentionTag_ARMGenerator = gen.Struct(reflect.TypeOf(RetentionTag_ARM{}), generators)

	return retentionTag_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRetentionTag_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetentionTag_ARM(gens map[string]gopter.Gen) {
	gens["TagName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScheduleBasedBackupCriteria_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduleBasedBackupCriteria_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduleBasedBackupCriteria_ARM, ScheduleBasedBackupCriteria_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduleBasedBackupCriteria_ARM runs a test to see if a specific instance of ScheduleBasedBackupCriteria_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduleBasedBackupCriteria_ARM(subject ScheduleBasedBackupCriteria_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduleBasedBackupCriteria_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduleBasedBackupCriteria_ARM instances for property testing - lazily instantiated by
// ScheduleBasedBackupCriteria_ARMGenerator()
var scheduleBasedBackupCriteria_ARMGenerator gopter.Gen

// ScheduleBasedBackupCriteria_ARMGenerator returns a generator of ScheduleBasedBackupCriteria_ARM instances for property testing.
// We first initialize scheduleBasedBackupCriteria_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScheduleBasedBackupCriteria_ARMGenerator() gopter.Gen {
	if scheduleBasedBackupCriteria_ARMGenerator != nil {
		return scheduleBasedBackupCriteria_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScheduleBasedBackupCriteria_ARM(generators)
	scheduleBasedBackupCriteria_ARMGenerator = gen.Struct(reflect.TypeOf(ScheduleBasedBackupCriteria_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScheduleBasedBackupCriteria_ARM(generators)
	AddRelatedPropertyGeneratorsForScheduleBasedBackupCriteria_ARM(generators)
	scheduleBasedBackupCriteria_ARMGenerator = gen.Struct(reflect.TypeOf(ScheduleBasedBackupCriteria_ARM{}), generators)

	return scheduleBasedBackupCriteria_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScheduleBasedBackupCriteria_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScheduleBasedBackupCriteria_ARM(gens map[string]gopter.Gen) {
	gens["AbsoluteCriteria"] = gen.SliceOf(gen.OneConstOf(
		ScheduleBasedBackupCriteria_AbsoluteCriteria_ARM_AllBackup,
		ScheduleBasedBackupCriteria_AbsoluteCriteria_ARM_FirstOfDay,
		ScheduleBasedBackupCriteria_AbsoluteCriteria_ARM_FirstOfMonth,
		ScheduleBasedBackupCriteria_AbsoluteCriteria_ARM_FirstOfWeek,
		ScheduleBasedBackupCriteria_AbsoluteCriteria_ARM_FirstOfYear))
	gens["DaysOfTheWeek"] = gen.SliceOf(gen.OneConstOf(
		ScheduleBasedBackupCriteria_DaysOfTheWeek_ARM_Friday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_ARM_Monday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_ARM_Saturday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_ARM_Sunday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_ARM_Thursday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_ARM_Tuesday,
		ScheduleBasedBackupCriteria_DaysOfTheWeek_ARM_Wednesday))
	gens["MonthsOfYear"] = gen.SliceOf(gen.OneConstOf(
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_April,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_August,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_December,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_February,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_January,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_July,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_June,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_March,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_May,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_November,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_October,
		ScheduleBasedBackupCriteria_MonthsOfYear_ARM_September))
	gens["ObjectType"] = gen.OneConstOf(ScheduleBasedBackupCriteria_ObjectType_ARM_ScheduleBasedBackupCriteria)
	gens["ScheduleTimes"] = gen.SliceOf(gen.AlphaString())
	gens["WeeksOfTheMonth"] = gen.SliceOf(gen.OneConstOf(
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_ARM_First,
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_ARM_Fourth,
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_ARM_Last,
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_ARM_Second,
		ScheduleBasedBackupCriteria_WeeksOfTheMonth_ARM_Third))
}

// AddRelatedPropertyGeneratorsForScheduleBasedBackupCriteria_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduleBasedBackupCriteria_ARM(gens map[string]gopter.Gen) {
	gens["DaysOfMonth"] = gen.SliceOf(Day_ARMGenerator())
}

func Test_ScheduleBasedTriggerContext_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduleBasedTriggerContext_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduleBasedTriggerContext_ARM, ScheduleBasedTriggerContext_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduleBasedTriggerContext_ARM runs a test to see if a specific instance of ScheduleBasedTriggerContext_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduleBasedTriggerContext_ARM(subject ScheduleBasedTriggerContext_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduleBasedTriggerContext_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduleBasedTriggerContext_ARM instances for property testing - lazily instantiated by
// ScheduleBasedTriggerContext_ARMGenerator()
var scheduleBasedTriggerContext_ARMGenerator gopter.Gen

// ScheduleBasedTriggerContext_ARMGenerator returns a generator of ScheduleBasedTriggerContext_ARM instances for property testing.
// We first initialize scheduleBasedTriggerContext_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScheduleBasedTriggerContext_ARMGenerator() gopter.Gen {
	if scheduleBasedTriggerContext_ARMGenerator != nil {
		return scheduleBasedTriggerContext_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScheduleBasedTriggerContext_ARM(generators)
	scheduleBasedTriggerContext_ARMGenerator = gen.Struct(reflect.TypeOf(ScheduleBasedTriggerContext_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScheduleBasedTriggerContext_ARM(generators)
	AddRelatedPropertyGeneratorsForScheduleBasedTriggerContext_ARM(generators)
	scheduleBasedTriggerContext_ARMGenerator = gen.Struct(reflect.TypeOf(ScheduleBasedTriggerContext_ARM{}), generators)

	return scheduleBasedTriggerContext_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScheduleBasedTriggerContext_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScheduleBasedTriggerContext_ARM(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(ScheduleBasedTriggerContext_ObjectType_ARM_ScheduleBasedTriggerContext)
}

// AddRelatedPropertyGeneratorsForScheduleBasedTriggerContext_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduleBasedTriggerContext_ARM(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(BackupSchedule_ARMGenerator())
	gens["TaggingCriteria"] = gen.SliceOf(TaggingCriteria_ARMGenerator())
}

func Test_SourceLifeCycle_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SourceLifeCycle_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSourceLifeCycle_ARM, SourceLifeCycle_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSourceLifeCycle_ARM runs a test to see if a specific instance of SourceLifeCycle_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSourceLifeCycle_ARM(subject SourceLifeCycle_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SourceLifeCycle_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SourceLifeCycle_ARM instances for property testing - lazily instantiated by
// SourceLifeCycle_ARMGenerator()
var sourceLifeCycle_ARMGenerator gopter.Gen

// SourceLifeCycle_ARMGenerator returns a generator of SourceLifeCycle_ARM instances for property testing.
func SourceLifeCycle_ARMGenerator() gopter.Gen {
	if sourceLifeCycle_ARMGenerator != nil {
		return sourceLifeCycle_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSourceLifeCycle_ARM(generators)
	sourceLifeCycle_ARMGenerator = gen.Struct(reflect.TypeOf(SourceLifeCycle_ARM{}), generators)

	return sourceLifeCycle_ARMGenerator
}

// AddRelatedPropertyGeneratorsForSourceLifeCycle_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSourceLifeCycle_ARM(gens map[string]gopter.Gen) {
	gens["DeleteAfter"] = gen.PtrOf(DeleteOption_ARMGenerator())
	gens["SourceDataStore"] = gen.PtrOf(DataStoreInfoBase_ARMGenerator())
	gens["TargetDataStoreCopySettings"] = gen.SliceOf(TargetCopySetting_ARMGenerator())
}

func Test_TaggingCriteria_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TaggingCriteria_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTaggingCriteria_ARM, TaggingCriteria_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTaggingCriteria_ARM runs a test to see if a specific instance of TaggingCriteria_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTaggingCriteria_ARM(subject TaggingCriteria_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TaggingCriteria_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TaggingCriteria_ARM instances for property testing - lazily instantiated by
// TaggingCriteria_ARMGenerator()
var taggingCriteria_ARMGenerator gopter.Gen

// TaggingCriteria_ARMGenerator returns a generator of TaggingCriteria_ARM instances for property testing.
// We first initialize taggingCriteria_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TaggingCriteria_ARMGenerator() gopter.Gen {
	if taggingCriteria_ARMGenerator != nil {
		return taggingCriteria_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTaggingCriteria_ARM(generators)
	taggingCriteria_ARMGenerator = gen.Struct(reflect.TypeOf(TaggingCriteria_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTaggingCriteria_ARM(generators)
	AddRelatedPropertyGeneratorsForTaggingCriteria_ARM(generators)
	taggingCriteria_ARMGenerator = gen.Struct(reflect.TypeOf(TaggingCriteria_ARM{}), generators)

	return taggingCriteria_ARMGenerator
}

// AddIndependentPropertyGeneratorsForTaggingCriteria_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTaggingCriteria_ARM(gens map[string]gopter.Gen) {
	gens["IsDefault"] = gen.PtrOf(gen.Bool())
	gens["TaggingPriority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForTaggingCriteria_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTaggingCriteria_ARM(gens map[string]gopter.Gen) {
	gens["Criteria"] = gen.SliceOf(BackupCriteria_ARMGenerator())
	gens["TagInfo"] = gen.PtrOf(RetentionTag_ARMGenerator())
}

func Test_TargetCopySetting_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TargetCopySetting_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTargetCopySetting_ARM, TargetCopySetting_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTargetCopySetting_ARM runs a test to see if a specific instance of TargetCopySetting_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTargetCopySetting_ARM(subject TargetCopySetting_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TargetCopySetting_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TargetCopySetting_ARM instances for property testing - lazily instantiated by
// TargetCopySetting_ARMGenerator()
var targetCopySetting_ARMGenerator gopter.Gen

// TargetCopySetting_ARMGenerator returns a generator of TargetCopySetting_ARM instances for property testing.
func TargetCopySetting_ARMGenerator() gopter.Gen {
	if targetCopySetting_ARMGenerator != nil {
		return targetCopySetting_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForTargetCopySetting_ARM(generators)
	targetCopySetting_ARMGenerator = gen.Struct(reflect.TypeOf(TargetCopySetting_ARM{}), generators)

	return targetCopySetting_ARMGenerator
}

// AddRelatedPropertyGeneratorsForTargetCopySetting_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTargetCopySetting_ARM(gens map[string]gopter.Gen) {
	gens["CopyAfter"] = gen.PtrOf(CopyOption_ARMGenerator())
	gens["DataStore"] = gen.PtrOf(DataStoreInfoBase_ARMGenerator())
}

func Test_TriggerContext_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TriggerContext_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTriggerContext_ARM, TriggerContext_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTriggerContext_ARM runs a test to see if a specific instance of TriggerContext_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTriggerContext_ARM(subject TriggerContext_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TriggerContext_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TriggerContext_ARM instances for property testing - lazily instantiated by TriggerContext_ARMGenerator()
var triggerContext_ARMGenerator gopter.Gen

// TriggerContext_ARMGenerator returns a generator of TriggerContext_ARM instances for property testing.
func TriggerContext_ARMGenerator() gopter.Gen {
	if triggerContext_ARMGenerator != nil {
		return triggerContext_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForTriggerContext_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(TriggerContext_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	triggerContext_ARMGenerator = gen.OneGenOf(gens...)

	return triggerContext_ARMGenerator
}

// AddRelatedPropertyGeneratorsForTriggerContext_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTriggerContext_ARM(gens map[string]gopter.Gen) {
	gens["Adhoc"] = AdhocBasedTriggerContext_ARMGenerator().Map(func(it AdhocBasedTriggerContext_ARM) *AdhocBasedTriggerContext_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["Schedule"] = ScheduleBasedTriggerContext_ARMGenerator().Map(func(it ScheduleBasedTriggerContext_ARM) *ScheduleBasedTriggerContext_ARM {
		return &it
	}) // generate one case for OneOf type
}
