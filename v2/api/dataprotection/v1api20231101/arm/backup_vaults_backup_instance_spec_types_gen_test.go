// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AuthCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthCredentials, AuthCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthCredentials runs a test to see if a specific instance of AuthCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthCredentials(subject AuthCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthCredentials instances for property testing - lazily instantiated by AuthCredentialsGenerator()
var authCredentialsGenerator gopter.Gen

// AuthCredentialsGenerator returns a generator of AuthCredentials instances for property testing.
func AuthCredentialsGenerator() gopter.Gen {
	if authCredentialsGenerator != nil {
		return authCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAuthCredentials(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AuthCredentials{}), map[string]gopter.Gen{propName: propGen}))
	}
	authCredentialsGenerator = gen.OneGenOf(gens...)

	return authCredentialsGenerator
}

// AddRelatedPropertyGeneratorsForAuthCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthCredentials(gens map[string]gopter.Gen) {
	gens["SecretStoreBasedAuthCredentials"] = SecretStoreBasedAuthCredentialsGenerator().Map(func(it SecretStoreBasedAuthCredentials) *SecretStoreBasedAuthCredentials {
		return &it
	}) // generate one case for OneOf type
}

func Test_AzureOperationalStoreParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureOperationalStoreParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureOperationalStoreParameters, AzureOperationalStoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureOperationalStoreParameters runs a test to see if a specific instance of AzureOperationalStoreParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureOperationalStoreParameters(subject AzureOperationalStoreParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureOperationalStoreParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureOperationalStoreParameters instances for property testing - lazily instantiated by
// AzureOperationalStoreParametersGenerator()
var azureOperationalStoreParametersGenerator gopter.Gen

// AzureOperationalStoreParametersGenerator returns a generator of AzureOperationalStoreParameters instances for property testing.
func AzureOperationalStoreParametersGenerator() gopter.Gen {
	if azureOperationalStoreParametersGenerator != nil {
		return azureOperationalStoreParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters(generators)
	azureOperationalStoreParametersGenerator = gen.Struct(reflect.TypeOf(AzureOperationalStoreParameters{}), generators)

	return azureOperationalStoreParametersGenerator
}

// AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters(gens map[string]gopter.Gen) {
	gens["DataStoreType"] = gen.PtrOf(gen.OneConstOf(AzureOperationalStoreParameters_DataStoreType_ArchiveStore, AzureOperationalStoreParameters_DataStoreType_OperationalStore, AzureOperationalStoreParameters_DataStoreType_VaultStore))
	gens["ObjectType"] = gen.OneConstOf(AzureOperationalStoreParameters_ObjectType_AzureOperationalStoreParameters)
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupDatasourceParameters, BackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupDatasourceParameters runs a test to see if a specific instance of BackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupDatasourceParameters(subject BackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupDatasourceParameters instances for property testing - lazily instantiated by
// BackupDatasourceParametersGenerator()
var backupDatasourceParametersGenerator gopter.Gen

// BackupDatasourceParametersGenerator returns a generator of BackupDatasourceParameters instances for property testing.
func BackupDatasourceParametersGenerator() gopter.Gen {
	if backupDatasourceParametersGenerator != nil {
		return backupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupDatasourceParameters(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupDatasourceParameters{}), map[string]gopter.Gen{propName: propGen}))
	}
	backupDatasourceParametersGenerator = gen.OneGenOf(gens...)

	return backupDatasourceParametersGenerator
}

// AddRelatedPropertyGeneratorsForBackupDatasourceParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["Blob"] = BlobBackupDatasourceParametersGenerator().Map(func(it BlobBackupDatasourceParameters) *BlobBackupDatasourceParameters {
		return &it
	}) // generate one case for OneOf type
	gens["KubernetesCluster"] = KubernetesClusterBackupDatasourceParametersGenerator().Map(func(it KubernetesClusterBackupDatasourceParameters) *KubernetesClusterBackupDatasourceParameters {
		return &it
	}) // generate one case for OneOf type
}

func Test_BackupInstance_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupInstance via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupInstance, BackupInstanceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupInstance runs a test to see if a specific instance of BackupInstance round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupInstance(subject BackupInstance) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupInstance
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupInstance instances for property testing - lazily instantiated by BackupInstanceGenerator()
var backupInstanceGenerator gopter.Gen

// BackupInstanceGenerator returns a generator of BackupInstance instances for property testing.
// We first initialize backupInstanceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupInstanceGenerator() gopter.Gen {
	if backupInstanceGenerator != nil {
		return backupInstanceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance(generators)
	backupInstanceGenerator = gen.Struct(reflect.TypeOf(BackupInstance{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance(generators)
	AddRelatedPropertyGeneratorsForBackupInstance(generators)
	backupInstanceGenerator = gen.Struct(reflect.TypeOf(BackupInstance{}), generators)

	return backupInstanceGenerator
}

// AddIndependentPropertyGeneratorsForBackupInstance is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupInstance(gens map[string]gopter.Gen) {
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationType"] = gen.PtrOf(gen.OneConstOf(BackupInstance_ValidationType_DeepValidation, BackupInstance_ValidationType_ShallowValidation))
}

// AddRelatedPropertyGeneratorsForBackupInstance is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupInstance(gens map[string]gopter.Gen) {
	gens["DataSourceInfo"] = gen.PtrOf(DatasourceGenerator())
	gens["DataSourceSetInfo"] = gen.PtrOf(DatasourceSetGenerator())
	gens["DatasourceAuthCredentials"] = gen.PtrOf(AuthCredentialsGenerator())
	gens["IdentityDetails"] = gen.PtrOf(IdentityDetailsGenerator())
	gens["PolicyInfo"] = gen.PtrOf(PolicyInfoGenerator())
}

func Test_BackupVaultsBackupInstance_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaultsBackupInstance_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaultsBackupInstance_Spec, BackupVaultsBackupInstance_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaultsBackupInstance_Spec runs a test to see if a specific instance of BackupVaultsBackupInstance_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaultsBackupInstance_Spec(subject BackupVaultsBackupInstance_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaultsBackupInstance_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaultsBackupInstance_Spec instances for property testing - lazily instantiated by
// BackupVaultsBackupInstance_SpecGenerator()
var backupVaultsBackupInstance_SpecGenerator gopter.Gen

// BackupVaultsBackupInstance_SpecGenerator returns a generator of BackupVaultsBackupInstance_Spec instances for property testing.
// We first initialize backupVaultsBackupInstance_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupVaultsBackupInstance_SpecGenerator() gopter.Gen {
	if backupVaultsBackupInstance_SpecGenerator != nil {
		return backupVaultsBackupInstance_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaultsBackupInstance_Spec(generators)
	backupVaultsBackupInstance_SpecGenerator = gen.Struct(reflect.TypeOf(BackupVaultsBackupInstance_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaultsBackupInstance_Spec(generators)
	AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance_Spec(generators)
	backupVaultsBackupInstance_SpecGenerator = gen.Struct(reflect.TypeOf(BackupVaultsBackupInstance_Spec{}), generators)

	return backupVaultsBackupInstance_SpecGenerator
}

// AddIndependentPropertyGeneratorsForBackupVaultsBackupInstance_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupVaultsBackupInstance_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaultsBackupInstance_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackupInstanceGenerator())
}

func Test_BaseResourceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaseResourceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaseResourceProperties, BaseResourcePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaseResourceProperties runs a test to see if a specific instance of BaseResourceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForBaseResourceProperties(subject BaseResourceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaseResourceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaseResourceProperties instances for property testing - lazily instantiated by
// BaseResourcePropertiesGenerator()
var baseResourcePropertiesGenerator gopter.Gen

// BaseResourcePropertiesGenerator returns a generator of BaseResourceProperties instances for property testing.
func BaseResourcePropertiesGenerator() gopter.Gen {
	if baseResourcePropertiesGenerator != nil {
		return baseResourcePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBaseResourceProperties(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BaseResourceProperties{}), map[string]gopter.Gen{propName: propGen}))
	}
	baseResourcePropertiesGenerator = gen.OneGenOf(gens...)

	return baseResourcePropertiesGenerator
}

// AddRelatedPropertyGeneratorsForBaseResourceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaseResourceProperties(gens map[string]gopter.Gen) {
	gens["DefaultResourceProperties"] = DefaultResourcePropertiesGenerator().Map(func(it DefaultResourceProperties) *DefaultResourceProperties {
		return &it
	}) // generate one case for OneOf type
}

func Test_BlobBackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobBackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobBackupDatasourceParameters, BlobBackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobBackupDatasourceParameters runs a test to see if a specific instance of BlobBackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobBackupDatasourceParameters(subject BlobBackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobBackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobBackupDatasourceParameters instances for property testing - lazily instantiated by
// BlobBackupDatasourceParametersGenerator()
var blobBackupDatasourceParametersGenerator gopter.Gen

// BlobBackupDatasourceParametersGenerator returns a generator of BlobBackupDatasourceParameters instances for property testing.
func BlobBackupDatasourceParametersGenerator() gopter.Gen {
	if blobBackupDatasourceParametersGenerator != nil {
		return blobBackupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters(generators)
	blobBackupDatasourceParametersGenerator = gen.Struct(reflect.TypeOf(BlobBackupDatasourceParameters{}), generators)

	return blobBackupDatasourceParametersGenerator
}

// AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["ContainersList"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(BlobBackupDatasourceParameters_ObjectType_BlobBackupDatasourceParameters)
}

func Test_DataStoreParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataStoreParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataStoreParameters, DataStoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataStoreParameters runs a test to see if a specific instance of DataStoreParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForDataStoreParameters(subject DataStoreParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataStoreParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataStoreParameters instances for property testing - lazily instantiated by
// DataStoreParametersGenerator()
var dataStoreParametersGenerator gopter.Gen

// DataStoreParametersGenerator returns a generator of DataStoreParameters instances for property testing.
func DataStoreParametersGenerator() gopter.Gen {
	if dataStoreParametersGenerator != nil {
		return dataStoreParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataStoreParameters(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DataStoreParameters{}), map[string]gopter.Gen{propName: propGen}))
	}
	dataStoreParametersGenerator = gen.OneGenOf(gens...)

	return dataStoreParametersGenerator
}

// AddRelatedPropertyGeneratorsForDataStoreParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataStoreParameters(gens map[string]gopter.Gen) {
	gens["AzureOperationalStoreParameters"] = AzureOperationalStoreParametersGenerator().Map(func(it AzureOperationalStoreParameters) *AzureOperationalStoreParameters {
		return &it
	}) // generate one case for OneOf type
}

func Test_Datasource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Datasource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasource, DatasourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasource runs a test to see if a specific instance of Datasource round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasource(subject Datasource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Datasource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Datasource instances for property testing - lazily instantiated by DatasourceGenerator()
var datasourceGenerator gopter.Gen

// DatasourceGenerator returns a generator of Datasource instances for property testing.
// We first initialize datasourceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatasourceGenerator() gopter.Gen {
	if datasourceGenerator != nil {
		return datasourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasource(generators)
	datasourceGenerator = gen.Struct(reflect.TypeOf(Datasource{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasource(generators)
	AddRelatedPropertyGeneratorsForDatasource(generators)
	datasourceGenerator = gen.Struct(reflect.TypeOf(Datasource{}), generators)

	return datasourceGenerator
}

// AddIndependentPropertyGeneratorsForDatasource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasource(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceID"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatasource is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatasource(gens map[string]gopter.Gen) {
	gens["ResourceProperties"] = gen.PtrOf(BaseResourcePropertiesGenerator())
}

func Test_DatasourceSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatasourceSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasourceSet, DatasourceSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasourceSet runs a test to see if a specific instance of DatasourceSet round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasourceSet(subject DatasourceSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatasourceSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatasourceSet instances for property testing - lazily instantiated by DatasourceSetGenerator()
var datasourceSetGenerator gopter.Gen

// DatasourceSetGenerator returns a generator of DatasourceSet instances for property testing.
// We first initialize datasourceSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatasourceSetGenerator() gopter.Gen {
	if datasourceSetGenerator != nil {
		return datasourceSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasourceSet(generators)
	datasourceSetGenerator = gen.Struct(reflect.TypeOf(DatasourceSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasourceSet(generators)
	AddRelatedPropertyGeneratorsForDatasourceSet(generators)
	datasourceSetGenerator = gen.Struct(reflect.TypeOf(DatasourceSet{}), generators)

	return datasourceSetGenerator
}

// AddIndependentPropertyGeneratorsForDatasourceSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasourceSet(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceID"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatasourceSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatasourceSet(gens map[string]gopter.Gen) {
	gens["ResourceProperties"] = gen.PtrOf(BaseResourcePropertiesGenerator())
}

func Test_DefaultResourceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DefaultResourceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDefaultResourceProperties, DefaultResourcePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDefaultResourceProperties runs a test to see if a specific instance of DefaultResourceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForDefaultResourceProperties(subject DefaultResourceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DefaultResourceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DefaultResourceProperties instances for property testing - lazily instantiated by
// DefaultResourcePropertiesGenerator()
var defaultResourcePropertiesGenerator gopter.Gen

// DefaultResourcePropertiesGenerator returns a generator of DefaultResourceProperties instances for property testing.
func DefaultResourcePropertiesGenerator() gopter.Gen {
	if defaultResourcePropertiesGenerator != nil {
		return defaultResourcePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultResourceProperties(generators)
	defaultResourcePropertiesGenerator = gen.Struct(reflect.TypeOf(DefaultResourceProperties{}), generators)

	return defaultResourcePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForDefaultResourceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDefaultResourceProperties(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(DefaultResourceProperties_ObjectType_DefaultResourceProperties)
}

func Test_IdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityDetails, IdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityDetails runs a test to see if a specific instance of IdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityDetails(subject IdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityDetails instances for property testing - lazily instantiated by IdentityDetailsGenerator()
var identityDetailsGenerator gopter.Gen

// IdentityDetailsGenerator returns a generator of IdentityDetails instances for property testing.
func IdentityDetailsGenerator() gopter.Gen {
	if identityDetailsGenerator != nil {
		return identityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityDetails(generators)
	identityDetailsGenerator = gen.Struct(reflect.TypeOf(IdentityDetails{}), generators)

	return identityDetailsGenerator
}

// AddIndependentPropertyGeneratorsForIdentityDetails is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityDetails(gens map[string]gopter.Gen) {
	gens["UseSystemAssignedIdentity"] = gen.PtrOf(gen.Bool())
	gens["UserAssignedIdentityArmUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_KubernetesClusterBackupDatasourceParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubernetesClusterBackupDatasourceParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters, KubernetesClusterBackupDatasourceParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters runs a test to see if a specific instance of KubernetesClusterBackupDatasourceParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters(subject KubernetesClusterBackupDatasourceParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubernetesClusterBackupDatasourceParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubernetesClusterBackupDatasourceParameters instances for property testing - lazily instantiated by
// KubernetesClusterBackupDatasourceParametersGenerator()
var kubernetesClusterBackupDatasourceParametersGenerator gopter.Gen

// KubernetesClusterBackupDatasourceParametersGenerator returns a generator of KubernetesClusterBackupDatasourceParameters instances for property testing.
// We first initialize kubernetesClusterBackupDatasourceParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KubernetesClusterBackupDatasourceParametersGenerator() gopter.Gen {
	if kubernetesClusterBackupDatasourceParametersGenerator != nil {
		return kubernetesClusterBackupDatasourceParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(generators)
	kubernetesClusterBackupDatasourceParametersGenerator = gen.Struct(reflect.TypeOf(KubernetesClusterBackupDatasourceParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(generators)
	AddRelatedPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(generators)
	kubernetesClusterBackupDatasourceParametersGenerator = gen.Struct(reflect.TypeOf(KubernetesClusterBackupDatasourceParameters{}), generators)

	return kubernetesClusterBackupDatasourceParametersGenerator
}

// AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["ExcludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["ExcludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IncludeClusterScopeResources"] = gen.PtrOf(gen.Bool())
	gens["IncludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["IncludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["LabelSelectors"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(KubernetesClusterBackupDatasourceParameters_ObjectType_KubernetesClusterBackupDatasourceParameters)
	gens["SnapshotVolumes"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters(gens map[string]gopter.Gen) {
	gens["BackupHookReferences"] = gen.SliceOf(NamespacedNameResourceGenerator())
}

func Test_NamespacedNameResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespacedNameResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespacedNameResource, NamespacedNameResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespacedNameResource runs a test to see if a specific instance of NamespacedNameResource round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespacedNameResource(subject NamespacedNameResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespacedNameResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespacedNameResource instances for property testing - lazily instantiated by
// NamespacedNameResourceGenerator()
var namespacedNameResourceGenerator gopter.Gen

// NamespacedNameResourceGenerator returns a generator of NamespacedNameResource instances for property testing.
func NamespacedNameResourceGenerator() gopter.Gen {
	if namespacedNameResourceGenerator != nil {
		return namespacedNameResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespacedNameResource(generators)
	namespacedNameResourceGenerator = gen.Struct(reflect.TypeOf(NamespacedNameResource{}), generators)

	return namespacedNameResourceGenerator
}

// AddIndependentPropertyGeneratorsForNamespacedNameResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespacedNameResource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_PolicyInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyInfo, PolicyInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyInfo runs a test to see if a specific instance of PolicyInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyInfo(subject PolicyInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyInfo instances for property testing - lazily instantiated by PolicyInfoGenerator()
var policyInfoGenerator gopter.Gen

// PolicyInfoGenerator returns a generator of PolicyInfo instances for property testing.
// We first initialize policyInfoGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicyInfoGenerator() gopter.Gen {
	if policyInfoGenerator != nil {
		return policyInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo(generators)
	policyInfoGenerator = gen.Struct(reflect.TypeOf(PolicyInfo{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo(generators)
	AddRelatedPropertyGeneratorsForPolicyInfo(generators)
	policyInfoGenerator = gen.Struct(reflect.TypeOf(PolicyInfo{}), generators)

	return policyInfoGenerator
}

// AddIndependentPropertyGeneratorsForPolicyInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicyInfo(gens map[string]gopter.Gen) {
	gens["PolicyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPolicyInfo is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyInfo(gens map[string]gopter.Gen) {
	gens["PolicyParameters"] = gen.PtrOf(PolicyParametersGenerator())
}

func Test_PolicyParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyParameters, PolicyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyParameters runs a test to see if a specific instance of PolicyParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyParameters(subject PolicyParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyParameters instances for property testing - lazily instantiated by PolicyParametersGenerator()
var policyParametersGenerator gopter.Gen

// PolicyParametersGenerator returns a generator of PolicyParameters instances for property testing.
func PolicyParametersGenerator() gopter.Gen {
	if policyParametersGenerator != nil {
		return policyParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicyParameters(generators)
	policyParametersGenerator = gen.Struct(reflect.TypeOf(PolicyParameters{}), generators)

	return policyParametersGenerator
}

// AddRelatedPropertyGeneratorsForPolicyParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyParameters(gens map[string]gopter.Gen) {
	gens["BackupDatasourceParametersList"] = gen.SliceOf(BackupDatasourceParametersGenerator())
	gens["DataStoreParametersList"] = gen.SliceOf(DataStoreParametersGenerator())
}

func Test_SecretStoreBasedAuthCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreBasedAuthCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreBasedAuthCredentials, SecretStoreBasedAuthCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreBasedAuthCredentials runs a test to see if a specific instance of SecretStoreBasedAuthCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreBasedAuthCredentials(subject SecretStoreBasedAuthCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreBasedAuthCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreBasedAuthCredentials instances for property testing - lazily instantiated by
// SecretStoreBasedAuthCredentialsGenerator()
var secretStoreBasedAuthCredentialsGenerator gopter.Gen

// SecretStoreBasedAuthCredentialsGenerator returns a generator of SecretStoreBasedAuthCredentials instances for property testing.
// We first initialize secretStoreBasedAuthCredentialsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecretStoreBasedAuthCredentialsGenerator() gopter.Gen {
	if secretStoreBasedAuthCredentialsGenerator != nil {
		return secretStoreBasedAuthCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	secretStoreBasedAuthCredentialsGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials(generators)
	secretStoreBasedAuthCredentialsGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials{}), generators)

	return secretStoreBasedAuthCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(SecretStoreBasedAuthCredentials_ObjectType_SecretStoreBasedAuthCredentials)
}

// AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials(gens map[string]gopter.Gen) {
	gens["SecretStoreResource"] = gen.PtrOf(SecretStoreResourceGenerator())
}

func Test_SecretStoreResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreResource, SecretStoreResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreResource runs a test to see if a specific instance of SecretStoreResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreResource(subject SecretStoreResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreResource instances for property testing - lazily instantiated by
// SecretStoreResourceGenerator()
var secretStoreResourceGenerator gopter.Gen

// SecretStoreResourceGenerator returns a generator of SecretStoreResource instances for property testing.
func SecretStoreResourceGenerator() gopter.Gen {
	if secretStoreResourceGenerator != nil {
		return secretStoreResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreResource(generators)
	secretStoreResourceGenerator = gen.Struct(reflect.TypeOf(SecretStoreResource{}), generators)

	return secretStoreResourceGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreResource(gens map[string]gopter.Gen) {
	gens["SecretStoreType"] = gen.PtrOf(gen.OneConstOf(SecretStoreResource_SecretStoreType_AzureKeyVault, SecretStoreResource_SecretStoreType_Invalid))
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}
