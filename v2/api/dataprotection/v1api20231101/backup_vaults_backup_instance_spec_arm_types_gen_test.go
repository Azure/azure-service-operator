// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20231101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BackupVaults_BackupInstance_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupVaults_BackupInstance_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupVaults_BackupInstance_Spec_ARM, BackupVaults_BackupInstance_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupVaults_BackupInstance_Spec_ARM runs a test to see if a specific instance of BackupVaults_BackupInstance_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupVaults_BackupInstance_Spec_ARM(subject BackupVaults_BackupInstance_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupVaults_BackupInstance_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupVaults_BackupInstance_Spec_ARM instances for property testing - lazily instantiated by
// BackupVaults_BackupInstance_Spec_ARMGenerator()
var backupVaults_BackupInstance_Spec_ARMGenerator gopter.Gen

// BackupVaults_BackupInstance_Spec_ARMGenerator returns a generator of BackupVaults_BackupInstance_Spec_ARM instances for property testing.
// We first initialize backupVaults_BackupInstance_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupVaults_BackupInstance_Spec_ARMGenerator() gopter.Gen {
	if backupVaults_BackupInstance_Spec_ARMGenerator != nil {
		return backupVaults_BackupInstance_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec_ARM(generators)
	backupVaults_BackupInstance_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec_ARM(generators)
	backupVaults_BackupInstance_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(BackupVaults_BackupInstance_Spec_ARM{}), generators)

	return backupVaults_BackupInstance_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupVaults_BackupInstance_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupVaults_BackupInstance_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BackupInstance_ARMGenerator())
}

func Test_BackupInstance_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupInstance_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupInstance_ARM, BackupInstance_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupInstance_ARM runs a test to see if a specific instance of BackupInstance_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupInstance_ARM(subject BackupInstance_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupInstance_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupInstance_ARM instances for property testing - lazily instantiated by BackupInstance_ARMGenerator()
var backupInstance_ARMGenerator gopter.Gen

// BackupInstance_ARMGenerator returns a generator of BackupInstance_ARM instances for property testing.
// We first initialize backupInstance_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BackupInstance_ARMGenerator() gopter.Gen {
	if backupInstance_ARMGenerator != nil {
		return backupInstance_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance_ARM(generators)
	backupInstance_ARMGenerator = gen.Struct(reflect.TypeOf(BackupInstance_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupInstance_ARM(generators)
	AddRelatedPropertyGeneratorsForBackupInstance_ARM(generators)
	backupInstance_ARMGenerator = gen.Struct(reflect.TypeOf(BackupInstance_ARM{}), generators)

	return backupInstance_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupInstance_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupInstance_ARM(gens map[string]gopter.Gen) {
	gens["FriendlyName"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationType"] = gen.PtrOf(gen.OneConstOf(BackupInstance_ValidationType_DeepValidation, BackupInstance_ValidationType_ShallowValidation))
}

// AddRelatedPropertyGeneratorsForBackupInstance_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupInstance_ARM(gens map[string]gopter.Gen) {
	gens["DataSourceInfo"] = gen.PtrOf(Datasource_ARMGenerator())
	gens["DataSourceSetInfo"] = gen.PtrOf(DatasourceSet_ARMGenerator())
	gens["DatasourceAuthCredentials"] = gen.PtrOf(AuthCredentials_ARMGenerator())
	gens["IdentityDetails"] = gen.PtrOf(IdentityDetails_ARMGenerator())
	gens["PolicyInfo"] = gen.PtrOf(PolicyInfo_ARMGenerator())
}

func Test_AuthCredentials_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthCredentials_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthCredentials_ARM, AuthCredentials_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthCredentials_ARM runs a test to see if a specific instance of AuthCredentials_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthCredentials_ARM(subject AuthCredentials_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthCredentials_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthCredentials_ARM instances for property testing - lazily instantiated by
// AuthCredentials_ARMGenerator()
var authCredentials_ARMGenerator gopter.Gen

// AuthCredentials_ARMGenerator returns a generator of AuthCredentials_ARM instances for property testing.
func AuthCredentials_ARMGenerator() gopter.Gen {
	if authCredentials_ARMGenerator != nil {
		return authCredentials_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAuthCredentials_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AuthCredentials_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	authCredentials_ARMGenerator = gen.OneGenOf(gens...)

	return authCredentials_ARMGenerator
}

// AddRelatedPropertyGeneratorsForAuthCredentials_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthCredentials_ARM(gens map[string]gopter.Gen) {
	gens["SecretStoreBasedAuthCredentials"] = SecretStoreBasedAuthCredentials_ARMGenerator().Map(func(it SecretStoreBasedAuthCredentials_ARM) *SecretStoreBasedAuthCredentials_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_Datasource_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Datasource_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasource_ARM, Datasource_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasource_ARM runs a test to see if a specific instance of Datasource_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasource_ARM(subject Datasource_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Datasource_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Datasource_ARM instances for property testing - lazily instantiated by Datasource_ARMGenerator()
var datasource_ARMGenerator gopter.Gen

// Datasource_ARMGenerator returns a generator of Datasource_ARM instances for property testing.
// We first initialize datasource_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Datasource_ARMGenerator() gopter.Gen {
	if datasource_ARMGenerator != nil {
		return datasource_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasource_ARM(generators)
	datasource_ARMGenerator = gen.Struct(reflect.TypeOf(Datasource_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasource_ARM(generators)
	AddRelatedPropertyGeneratorsForDatasource_ARM(generators)
	datasource_ARMGenerator = gen.Struct(reflect.TypeOf(Datasource_ARM{}), generators)

	return datasource_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDatasource_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasource_ARM(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceID"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatasource_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatasource_ARM(gens map[string]gopter.Gen) {
	gens["ResourceProperties"] = gen.PtrOf(BaseResourceProperties_ARMGenerator())
}

func Test_DatasourceSet_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatasourceSet_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatasourceSet_ARM, DatasourceSet_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatasourceSet_ARM runs a test to see if a specific instance of DatasourceSet_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatasourceSet_ARM(subject DatasourceSet_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatasourceSet_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatasourceSet_ARM instances for property testing - lazily instantiated by DatasourceSet_ARMGenerator()
var datasourceSet_ARMGenerator gopter.Gen

// DatasourceSet_ARMGenerator returns a generator of DatasourceSet_ARM instances for property testing.
// We first initialize datasourceSet_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatasourceSet_ARMGenerator() gopter.Gen {
	if datasourceSet_ARMGenerator != nil {
		return datasourceSet_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasourceSet_ARM(generators)
	datasourceSet_ARMGenerator = gen.Struct(reflect.TypeOf(DatasourceSet_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatasourceSet_ARM(generators)
	AddRelatedPropertyGeneratorsForDatasourceSet_ARM(generators)
	datasourceSet_ARMGenerator = gen.Struct(reflect.TypeOf(DatasourceSet_ARM{}), generators)

	return datasourceSet_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDatasourceSet_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatasourceSet_ARM(gens map[string]gopter.Gen) {
	gens["DatasourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceID"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatasourceSet_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatasourceSet_ARM(gens map[string]gopter.Gen) {
	gens["ResourceProperties"] = gen.PtrOf(BaseResourceProperties_ARMGenerator())
}

func Test_IdentityDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityDetails_ARM, IdentityDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityDetails_ARM runs a test to see if a specific instance of IdentityDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityDetails_ARM(subject IdentityDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityDetails_ARM instances for property testing - lazily instantiated by
// IdentityDetails_ARMGenerator()
var identityDetails_ARMGenerator gopter.Gen

// IdentityDetails_ARMGenerator returns a generator of IdentityDetails_ARM instances for property testing.
func IdentityDetails_ARMGenerator() gopter.Gen {
	if identityDetails_ARMGenerator != nil {
		return identityDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityDetails_ARM(generators)
	identityDetails_ARMGenerator = gen.Struct(reflect.TypeOf(IdentityDetails_ARM{}), generators)

	return identityDetails_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityDetails_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityDetails_ARM(gens map[string]gopter.Gen) {
	gens["UseSystemAssignedIdentity"] = gen.PtrOf(gen.Bool())
	gens["UserAssignedIdentityArmUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_PolicyInfo_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyInfo_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyInfo_ARM, PolicyInfo_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyInfo_ARM runs a test to see if a specific instance of PolicyInfo_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyInfo_ARM(subject PolicyInfo_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyInfo_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyInfo_ARM instances for property testing - lazily instantiated by PolicyInfo_ARMGenerator()
var policyInfo_ARMGenerator gopter.Gen

// PolicyInfo_ARMGenerator returns a generator of PolicyInfo_ARM instances for property testing.
// We first initialize policyInfo_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicyInfo_ARMGenerator() gopter.Gen {
	if policyInfo_ARMGenerator != nil {
		return policyInfo_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo_ARM(generators)
	policyInfo_ARMGenerator = gen.Struct(reflect.TypeOf(PolicyInfo_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicyInfo_ARM(generators)
	AddRelatedPropertyGeneratorsForPolicyInfo_ARM(generators)
	policyInfo_ARMGenerator = gen.Struct(reflect.TypeOf(PolicyInfo_ARM{}), generators)

	return policyInfo_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPolicyInfo_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicyInfo_ARM(gens map[string]gopter.Gen) {
	gens["PolicyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPolicyInfo_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyInfo_ARM(gens map[string]gopter.Gen) {
	gens["PolicyParameters"] = gen.PtrOf(PolicyParameters_ARMGenerator())
}

func Test_BaseResourceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaseResourceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaseResourceProperties_ARM, BaseResourceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaseResourceProperties_ARM runs a test to see if a specific instance of BaseResourceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBaseResourceProperties_ARM(subject BaseResourceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaseResourceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaseResourceProperties_ARM instances for property testing - lazily instantiated by
// BaseResourceProperties_ARMGenerator()
var baseResourceProperties_ARMGenerator gopter.Gen

// BaseResourceProperties_ARMGenerator returns a generator of BaseResourceProperties_ARM instances for property testing.
func BaseResourceProperties_ARMGenerator() gopter.Gen {
	if baseResourceProperties_ARMGenerator != nil {
		return baseResourceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBaseResourceProperties_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BaseResourceProperties_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	baseResourceProperties_ARMGenerator = gen.OneGenOf(gens...)

	return baseResourceProperties_ARMGenerator
}

// AddRelatedPropertyGeneratorsForBaseResourceProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaseResourceProperties_ARM(gens map[string]gopter.Gen) {
	gens["DefaultResourceProperties"] = DefaultResourceProperties_ARMGenerator().Map(func(it DefaultResourceProperties_ARM) *DefaultResourceProperties_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_PolicyParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicyParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicyParameters_ARM, PolicyParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicyParameters_ARM runs a test to see if a specific instance of PolicyParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicyParameters_ARM(subject PolicyParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicyParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicyParameters_ARM instances for property testing - lazily instantiated by
// PolicyParameters_ARMGenerator()
var policyParameters_ARMGenerator gopter.Gen

// PolicyParameters_ARMGenerator returns a generator of PolicyParameters_ARM instances for property testing.
func PolicyParameters_ARMGenerator() gopter.Gen {
	if policyParameters_ARMGenerator != nil {
		return policyParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicyParameters_ARM(generators)
	policyParameters_ARMGenerator = gen.Struct(reflect.TypeOf(PolicyParameters_ARM{}), generators)

	return policyParameters_ARMGenerator
}

// AddRelatedPropertyGeneratorsForPolicyParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicyParameters_ARM(gens map[string]gopter.Gen) {
	gens["BackupDatasourceParametersList"] = gen.SliceOf(BackupDatasourceParameters_ARMGenerator())
	gens["DataStoreParametersList"] = gen.SliceOf(DataStoreParameters_ARMGenerator())
}

func Test_SecretStoreBasedAuthCredentials_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreBasedAuthCredentials_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreBasedAuthCredentials_ARM, SecretStoreBasedAuthCredentials_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreBasedAuthCredentials_ARM runs a test to see if a specific instance of SecretStoreBasedAuthCredentials_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreBasedAuthCredentials_ARM(subject SecretStoreBasedAuthCredentials_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreBasedAuthCredentials_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreBasedAuthCredentials_ARM instances for property testing - lazily instantiated by
// SecretStoreBasedAuthCredentials_ARMGenerator()
var secretStoreBasedAuthCredentials_ARMGenerator gopter.Gen

// SecretStoreBasedAuthCredentials_ARMGenerator returns a generator of SecretStoreBasedAuthCredentials_ARM instances for property testing.
// We first initialize secretStoreBasedAuthCredentials_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecretStoreBasedAuthCredentials_ARMGenerator() gopter.Gen {
	if secretStoreBasedAuthCredentials_ARMGenerator != nil {
		return secretStoreBasedAuthCredentials_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_ARM(generators)
	secretStoreBasedAuthCredentials_ARMGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_ARM(generators)
	AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_ARM(generators)
	secretStoreBasedAuthCredentials_ARMGenerator = gen.Struct(reflect.TypeOf(SecretStoreBasedAuthCredentials_ARM{}), generators)

	return secretStoreBasedAuthCredentials_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreBasedAuthCredentials_ARM(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(SecretStoreBasedAuthCredentials_ObjectType_SecretStoreBasedAuthCredentials)
}

// AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecretStoreBasedAuthCredentials_ARM(gens map[string]gopter.Gen) {
	gens["SecretStoreResource"] = gen.PtrOf(SecretStoreResource_ARMGenerator())
}

func Test_BackupDatasourceParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupDatasourceParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupDatasourceParameters_ARM, BackupDatasourceParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupDatasourceParameters_ARM runs a test to see if a specific instance of BackupDatasourceParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupDatasourceParameters_ARM(subject BackupDatasourceParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupDatasourceParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupDatasourceParameters_ARM instances for property testing - lazily instantiated by
// BackupDatasourceParameters_ARMGenerator()
var backupDatasourceParameters_ARMGenerator gopter.Gen

// BackupDatasourceParameters_ARMGenerator returns a generator of BackupDatasourceParameters_ARM instances for property testing.
func BackupDatasourceParameters_ARMGenerator() gopter.Gen {
	if backupDatasourceParameters_ARMGenerator != nil {
		return backupDatasourceParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackupDatasourceParameters_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(BackupDatasourceParameters_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	backupDatasourceParameters_ARMGenerator = gen.OneGenOf(gens...)

	return backupDatasourceParameters_ARMGenerator
}

// AddRelatedPropertyGeneratorsForBackupDatasourceParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackupDatasourceParameters_ARM(gens map[string]gopter.Gen) {
	gens["Blob"] = BlobBackupDatasourceParameters_ARMGenerator().Map(func(it BlobBackupDatasourceParameters_ARM) *BlobBackupDatasourceParameters_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["KubernetesCluster"] = KubernetesClusterBackupDatasourceParameters_ARMGenerator().Map(func(it KubernetesClusterBackupDatasourceParameters_ARM) *KubernetesClusterBackupDatasourceParameters_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_DataStoreParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataStoreParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataStoreParameters_ARM, DataStoreParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataStoreParameters_ARM runs a test to see if a specific instance of DataStoreParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataStoreParameters_ARM(subject DataStoreParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataStoreParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataStoreParameters_ARM instances for property testing - lazily instantiated by
// DataStoreParameters_ARMGenerator()
var dataStoreParameters_ARMGenerator gopter.Gen

// DataStoreParameters_ARMGenerator returns a generator of DataStoreParameters_ARM instances for property testing.
func DataStoreParameters_ARMGenerator() gopter.Gen {
	if dataStoreParameters_ARMGenerator != nil {
		return dataStoreParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataStoreParameters_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DataStoreParameters_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	dataStoreParameters_ARMGenerator = gen.OneGenOf(gens...)

	return dataStoreParameters_ARMGenerator
}

// AddRelatedPropertyGeneratorsForDataStoreParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataStoreParameters_ARM(gens map[string]gopter.Gen) {
	gens["AzureOperationalStoreParameters"] = AzureOperationalStoreParameters_ARMGenerator().Map(func(it AzureOperationalStoreParameters_ARM) *AzureOperationalStoreParameters_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_DefaultResourceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DefaultResourceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDefaultResourceProperties_ARM, DefaultResourceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDefaultResourceProperties_ARM runs a test to see if a specific instance of DefaultResourceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDefaultResourceProperties_ARM(subject DefaultResourceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DefaultResourceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DefaultResourceProperties_ARM instances for property testing - lazily instantiated by
// DefaultResourceProperties_ARMGenerator()
var defaultResourceProperties_ARMGenerator gopter.Gen

// DefaultResourceProperties_ARMGenerator returns a generator of DefaultResourceProperties_ARM instances for property testing.
func DefaultResourceProperties_ARMGenerator() gopter.Gen {
	if defaultResourceProperties_ARMGenerator != nil {
		return defaultResourceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultResourceProperties_ARM(generators)
	defaultResourceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(DefaultResourceProperties_ARM{}), generators)

	return defaultResourceProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDefaultResourceProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDefaultResourceProperties_ARM(gens map[string]gopter.Gen) {
	gens["ObjectType"] = gen.OneConstOf(DefaultResourceProperties_ObjectType_DefaultResourceProperties)
}

func Test_SecretStoreResource_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretStoreResource_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretStoreResource_ARM, SecretStoreResource_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretStoreResource_ARM runs a test to see if a specific instance of SecretStoreResource_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretStoreResource_ARM(subject SecretStoreResource_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretStoreResource_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretStoreResource_ARM instances for property testing - lazily instantiated by
// SecretStoreResource_ARMGenerator()
var secretStoreResource_ARMGenerator gopter.Gen

// SecretStoreResource_ARMGenerator returns a generator of SecretStoreResource_ARM instances for property testing.
func SecretStoreResource_ARMGenerator() gopter.Gen {
	if secretStoreResource_ARMGenerator != nil {
		return secretStoreResource_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretStoreResource_ARM(generators)
	secretStoreResource_ARMGenerator = gen.Struct(reflect.TypeOf(SecretStoreResource_ARM{}), generators)

	return secretStoreResource_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSecretStoreResource_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretStoreResource_ARM(gens map[string]gopter.Gen) {
	gens["SecretStoreType"] = gen.PtrOf(gen.OneConstOf(SecretStoreResource_SecretStoreType_AzureKeyVault, SecretStoreResource_SecretStoreType_Invalid))
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureOperationalStoreParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureOperationalStoreParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureOperationalStoreParameters_ARM, AzureOperationalStoreParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureOperationalStoreParameters_ARM runs a test to see if a specific instance of AzureOperationalStoreParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureOperationalStoreParameters_ARM(subject AzureOperationalStoreParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureOperationalStoreParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureOperationalStoreParameters_ARM instances for property testing - lazily instantiated by
// AzureOperationalStoreParameters_ARMGenerator()
var azureOperationalStoreParameters_ARMGenerator gopter.Gen

// AzureOperationalStoreParameters_ARMGenerator returns a generator of AzureOperationalStoreParameters_ARM instances for property testing.
func AzureOperationalStoreParameters_ARMGenerator() gopter.Gen {
	if azureOperationalStoreParameters_ARMGenerator != nil {
		return azureOperationalStoreParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_ARM(generators)
	azureOperationalStoreParameters_ARMGenerator = gen.Struct(reflect.TypeOf(AzureOperationalStoreParameters_ARM{}), generators)

	return azureOperationalStoreParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureOperationalStoreParameters_ARM(gens map[string]gopter.Gen) {
	gens["DataStoreType"] = gen.PtrOf(gen.OneConstOf(AzureOperationalStoreParameters_DataStoreType_ArchiveStore, AzureOperationalStoreParameters_DataStoreType_OperationalStore, AzureOperationalStoreParameters_DataStoreType_VaultStore))
	gens["ObjectType"] = gen.OneConstOf(AzureOperationalStoreParameters_ObjectType_AzureOperationalStoreParameters)
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobBackupDatasourceParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobBackupDatasourceParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobBackupDatasourceParameters_ARM, BlobBackupDatasourceParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobBackupDatasourceParameters_ARM runs a test to see if a specific instance of BlobBackupDatasourceParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobBackupDatasourceParameters_ARM(subject BlobBackupDatasourceParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobBackupDatasourceParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobBackupDatasourceParameters_ARM instances for property testing - lazily instantiated by
// BlobBackupDatasourceParameters_ARMGenerator()
var blobBackupDatasourceParameters_ARMGenerator gopter.Gen

// BlobBackupDatasourceParameters_ARMGenerator returns a generator of BlobBackupDatasourceParameters_ARM instances for property testing.
func BlobBackupDatasourceParameters_ARMGenerator() gopter.Gen {
	if blobBackupDatasourceParameters_ARMGenerator != nil {
		return blobBackupDatasourceParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_ARM(generators)
	blobBackupDatasourceParameters_ARMGenerator = gen.Struct(reflect.TypeOf(BlobBackupDatasourceParameters_ARM{}), generators)

	return blobBackupDatasourceParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobBackupDatasourceParameters_ARM(gens map[string]gopter.Gen) {
	gens["ContainersList"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(BlobBackupDatasourceParameters_ObjectType_BlobBackupDatasourceParameters)
}

func Test_KubernetesClusterBackupDatasourceParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubernetesClusterBackupDatasourceParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_ARM, KubernetesClusterBackupDatasourceParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_ARM runs a test to see if a specific instance of KubernetesClusterBackupDatasourceParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKubernetesClusterBackupDatasourceParameters_ARM(subject KubernetesClusterBackupDatasourceParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubernetesClusterBackupDatasourceParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubernetesClusterBackupDatasourceParameters_ARM instances for property testing - lazily instantiated by
// KubernetesClusterBackupDatasourceParameters_ARMGenerator()
var kubernetesClusterBackupDatasourceParameters_ARMGenerator gopter.Gen

// KubernetesClusterBackupDatasourceParameters_ARMGenerator returns a generator of KubernetesClusterBackupDatasourceParameters_ARM instances for property testing.
// We first initialize kubernetesClusterBackupDatasourceParameters_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KubernetesClusterBackupDatasourceParameters_ARMGenerator() gopter.Gen {
	if kubernetesClusterBackupDatasourceParameters_ARMGenerator != nil {
		return kubernetesClusterBackupDatasourceParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_ARM(generators)
	kubernetesClusterBackupDatasourceParameters_ARMGenerator = gen.Struct(reflect.TypeOf(KubernetesClusterBackupDatasourceParameters_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_ARM(generators)
	AddRelatedPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_ARM(generators)
	kubernetesClusterBackupDatasourceParameters_ARMGenerator = gen.Struct(reflect.TypeOf(KubernetesClusterBackupDatasourceParameters_ARM{}), generators)

	return kubernetesClusterBackupDatasourceParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_ARM(gens map[string]gopter.Gen) {
	gens["ExcludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["ExcludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IncludeClusterScopeResources"] = gen.PtrOf(gen.Bool())
	gens["IncludedNamespaces"] = gen.SliceOf(gen.AlphaString())
	gens["IncludedResourceTypes"] = gen.SliceOf(gen.AlphaString())
	gens["LabelSelectors"] = gen.SliceOf(gen.AlphaString())
	gens["ObjectType"] = gen.OneConstOf(KubernetesClusterBackupDatasourceParameters_ObjectType_KubernetesClusterBackupDatasourceParameters)
	gens["SnapshotVolumes"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKubernetesClusterBackupDatasourceParameters_ARM(gens map[string]gopter.Gen) {
	gens["BackupHookReferences"] = gen.SliceOf(NamespacedNameResource_ARMGenerator())
}

func Test_NamespacedNameResource_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespacedNameResource_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespacedNameResource_ARM, NamespacedNameResource_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespacedNameResource_ARM runs a test to see if a specific instance of NamespacedNameResource_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespacedNameResource_ARM(subject NamespacedNameResource_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespacedNameResource_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespacedNameResource_ARM instances for property testing - lazily instantiated by
// NamespacedNameResource_ARMGenerator()
var namespacedNameResource_ARMGenerator gopter.Gen

// NamespacedNameResource_ARMGenerator returns a generator of NamespacedNameResource_ARM instances for property testing.
func NamespacedNameResource_ARMGenerator() gopter.Gen {
	if namespacedNameResource_ARMGenerator != nil {
		return namespacedNameResource_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespacedNameResource_ARM(generators)
	namespacedNameResource_ARMGenerator = gen.Struct(reflect.TypeOf(NamespacedNameResource_ARM{}), generators)

	return namespacedNameResource_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNamespacedNameResource_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespacedNameResource_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
}
