// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230701

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/keyvault/v1api20230701/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/keyvault/v1api20230701/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,keyvault}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /keyvault/resource-manager/Microsoft.KeyVault/stable/2023-07-01/keys.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}
type VaultsKey struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VaultsKey_Spec   `json:"spec,omitempty"`
	Status            VaultsKey_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VaultsKey{}

// GetConditions returns the conditions of the resource
func (vaultsKey *VaultsKey) GetConditions() conditions.Conditions {
	return vaultsKey.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (vaultsKey *VaultsKey) SetConditions(conditions conditions.Conditions) {
	vaultsKey.Status.Conditions = conditions
}

var _ conversion.Convertible = &VaultsKey{}

// ConvertFrom populates our VaultsKey from the provided hub VaultsKey
func (vaultsKey *VaultsKey) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.VaultsKey)
	if !ok {
		return fmt.Errorf("expected keyvault/v1api20230701/storage/VaultsKey but received %T instead", hub)
	}

	return vaultsKey.AssignProperties_From_VaultsKey(source)
}

// ConvertTo populates the provided hub VaultsKey from our VaultsKey
func (vaultsKey *VaultsKey) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.VaultsKey)
	if !ok {
		return fmt.Errorf("expected keyvault/v1api20230701/storage/VaultsKey but received %T instead", hub)
	}

	return vaultsKey.AssignProperties_To_VaultsKey(destination)
}

var _ configmaps.Exporter = &VaultsKey{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (vaultsKey *VaultsKey) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if vaultsKey.Spec.OperatorSpec == nil {
		return nil
	}
	return vaultsKey.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &VaultsKey{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (vaultsKey *VaultsKey) SecretDestinationExpressions() []*core.DestinationExpression {
	if vaultsKey.Spec.OperatorSpec == nil {
		return nil
	}
	return vaultsKey.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &VaultsKey{}

// InitializeSpec initializes the spec for this resource from the given status
func (vaultsKey *VaultsKey) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*VaultsKey_STATUS); ok {
		return vaultsKey.Spec.Initialize_From_VaultsKey_STATUS(s)
	}

	return fmt.Errorf("expected Status of type VaultsKey_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &VaultsKey{}

// AzureName returns the Azure name of the resource
func (vaultsKey *VaultsKey) AzureName() string {
	return vaultsKey.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-07-01"
func (vaultsKey VaultsKey) GetAPIVersion() string {
	return "2023-07-01"
}

// GetResourceScope returns the scope of the resource
func (vaultsKey *VaultsKey) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (vaultsKey *VaultsKey) GetSpec() genruntime.ConvertibleSpec {
	return &vaultsKey.Spec
}

// GetStatus returns the status of this resource
func (vaultsKey *VaultsKey) GetStatus() genruntime.ConvertibleStatus {
	return &vaultsKey.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (vaultsKey *VaultsKey) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.KeyVault/vaults/keys"
func (vaultsKey *VaultsKey) GetType() string {
	return "Microsoft.KeyVault/vaults/keys"
}

// NewEmptyStatus returns a new empty (blank) status
func (vaultsKey *VaultsKey) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VaultsKey_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (vaultsKey *VaultsKey) Owner() *genruntime.ResourceReference {
	if vaultsKey.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(vaultsKey.Spec)
	return vaultsKey.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (vaultsKey *VaultsKey) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VaultsKey_STATUS); ok {
		vaultsKey.Status = *st
		return nil
	}

	// Convert status to required version
	var st VaultsKey_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	vaultsKey.Status = st
	return nil
}

// AssignProperties_From_VaultsKey populates our VaultsKey from the provided source VaultsKey
func (vaultsKey *VaultsKey) AssignProperties_From_VaultsKey(source *storage.VaultsKey) error {

	// ObjectMeta
	vaultsKey.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VaultsKey_Spec
	err := spec.AssignProperties_From_VaultsKey_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_VaultsKey_Spec() to populate field Spec")
	}
	vaultsKey.Spec = spec

	// Status
	var status VaultsKey_STATUS
	err = status.AssignProperties_From_VaultsKey_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_VaultsKey_STATUS() to populate field Status")
	}
	vaultsKey.Status = status

	// No error
	return nil
}

// AssignProperties_To_VaultsKey populates the provided destination VaultsKey from our VaultsKey
func (vaultsKey *VaultsKey) AssignProperties_To_VaultsKey(destination *storage.VaultsKey) error {

	// ObjectMeta
	destination.ObjectMeta = *vaultsKey.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.VaultsKey_Spec
	err := vaultsKey.Spec.AssignProperties_To_VaultsKey_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_VaultsKey_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.VaultsKey_STATUS
	err = vaultsKey.Status.AssignProperties_To_VaultsKey_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_VaultsKey_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (vaultsKey *VaultsKey) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: vaultsKey.Spec.OriginalVersion(),
		Kind:    "VaultsKey",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /keyvault/resource-manager/Microsoft.KeyVault/stable/2023-07-01/keys.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}
type VaultsKeyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VaultsKey `json:"items"`
}

type VaultsKey_Spec struct {
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9-]{1,127}$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *VaultsKeyOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a keyvault.azure.com/Vault resource
	Owner *genruntime.KnownResourceReference `group:"keyvault.azure.com" json:"owner,omitempty" kind:"Vault"`

	// +kubebuilder:validation:Required
	// Properties: The properties of the key to be created.
	Properties *KeyProperties `json:"properties,omitempty"`

	// Tags: The tags that will be assigned to the key.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultsKey_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vaultsKey *VaultsKey_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vaultsKey == nil {
		return nil, nil
	}
	result := &arm.VaultsKey_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if vaultsKey.Properties != nil {
		properties_ARM, err := vaultsKey.Properties.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.KeyProperties)
		result.Properties = &properties
	}

	// Set property "Tags":
	if vaultsKey.Tags != nil {
		result.Tags = make(map[string]string, len(vaultsKey.Tags))
		for key, value := range vaultsKey.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultsKey *VaultsKey_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VaultsKey_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultsKey *VaultsKey_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VaultsKey_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VaultsKey_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	vaultsKey.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	vaultsKey.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 KeyProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		vaultsKey.Properties = &properties
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		vaultsKey.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			vaultsKey.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VaultsKey_Spec{}

// ConvertSpecFrom populates our VaultsKey_Spec from the provided source
func (vaultsKey *VaultsKey_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.VaultsKey_Spec)
	if ok {
		// Populate our instance from source
		return vaultsKey.AssignProperties_From_VaultsKey_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.VaultsKey_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = vaultsKey.AssignProperties_From_VaultsKey_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VaultsKey_Spec
func (vaultsKey *VaultsKey_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.VaultsKey_Spec)
	if ok {
		// Populate destination from our instance
		return vaultsKey.AssignProperties_To_VaultsKey_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.VaultsKey_Spec{}
	err := vaultsKey.AssignProperties_To_VaultsKey_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_VaultsKey_Spec populates our VaultsKey_Spec from the provided source VaultsKey_Spec
func (vaultsKey *VaultsKey_Spec) AssignProperties_From_VaultsKey_Spec(source *storage.VaultsKey_Spec) error {

	// AzureName
	vaultsKey.AzureName = source.AzureName

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec VaultsKeyOperatorSpec
		err := operatorSpec.AssignProperties_From_VaultsKeyOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VaultsKeyOperatorSpec() to populate field OperatorSpec")
		}
		vaultsKey.OperatorSpec = &operatorSpec
	} else {
		vaultsKey.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		vaultsKey.Owner = &owner
	} else {
		vaultsKey.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property KeyProperties
		err := property.AssignProperties_From_KeyProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyProperties() to populate field Properties")
		}
		vaultsKey.Properties = &property
	} else {
		vaultsKey.Properties = nil
	}

	// Tags
	vaultsKey.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_VaultsKey_Spec populates the provided destination VaultsKey_Spec from our VaultsKey_Spec
func (vaultsKey *VaultsKey_Spec) AssignProperties_To_VaultsKey_Spec(destination *storage.VaultsKey_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = vaultsKey.AzureName

	// OperatorSpec
	if vaultsKey.OperatorSpec != nil {
		var operatorSpec storage.VaultsKeyOperatorSpec
		err := vaultsKey.OperatorSpec.AssignProperties_To_VaultsKeyOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VaultsKeyOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = vaultsKey.OriginalVersion()

	// Owner
	if vaultsKey.Owner != nil {
		owner := vaultsKey.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if vaultsKey.Properties != nil {
		var property storage.KeyProperties
		err := vaultsKey.Properties.AssignProperties_To_KeyProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(vaultsKey.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VaultsKey_STATUS populates our VaultsKey_Spec from the provided source VaultsKey_STATUS
func (vaultsKey *VaultsKey_Spec) Initialize_From_VaultsKey_STATUS(source *VaultsKey_STATUS) error {

	// Tags
	vaultsKey.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (vaultsKey *VaultsKey_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (vaultsKey *VaultsKey_Spec) SetAzureName(azureName string) { vaultsKey.AzureName = azureName }

type VaultsKey_STATUS struct {
	// Attributes: The attributes of the key.
	Attributes *KeyAttributes_STATUS `json:"attributes,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CurveName: The elliptic curve name. For valid values, see JsonWebKeyCurveName.
	CurveName *KeyProperties_CurveName_STATUS `json:"curveName,omitempty"`

	// Id: Fully qualified identifier of the key vault resource.
	Id     *string                       `json:"id,omitempty"`
	KeyOps []KeyProperties_KeyOps_STATUS `json:"keyOps,omitempty"`

	// KeySize: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
	KeySize *int `json:"keySize,omitempty"`

	// KeyUri: The URI to retrieve the current version of the key.
	KeyUri *string `json:"keyUri,omitempty"`

	// KeyUriWithVersion: The URI to retrieve the specific version of the key.
	KeyUriWithVersion *string `json:"keyUriWithVersion,omitempty"`

	// Kty: The type of the key. For valid values, see JsonWebKeyType.
	Kty *KeyProperties_Kty_STATUS `json:"kty,omitempty"`

	// Location: Azure location of the key vault resource.
	Location *string `json:"location,omitempty"`

	// Name: Name of the key vault resource.
	Name *string `json:"name,omitempty"`

	// Release_Policy: Key release policy in response. It will be used for both output and input. Omitted if empty
	Release_Policy *KeyReleasePolicy_STATUS `json:"release_policy,omitempty"`

	// RotationPolicy: Key rotation policy in response. It will be used for both output and input. Omitted if empty
	RotationPolicy *RotationPolicy_STATUS `json:"rotationPolicy,omitempty"`

	// Tags: Tags assigned to the key vault resource.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type of the key vault resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VaultsKey_STATUS{}

// ConvertStatusFrom populates our VaultsKey_STATUS from the provided source
func (vaultsKey *VaultsKey_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.VaultsKey_STATUS)
	if ok {
		// Populate our instance from source
		return vaultsKey.AssignProperties_From_VaultsKey_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.VaultsKey_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = vaultsKey.AssignProperties_From_VaultsKey_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VaultsKey_STATUS
func (vaultsKey *VaultsKey_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.VaultsKey_STATUS)
	if ok {
		// Populate destination from our instance
		return vaultsKey.AssignProperties_To_VaultsKey_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.VaultsKey_STATUS{}
	err := vaultsKey.AssignProperties_To_VaultsKey_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VaultsKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultsKey *VaultsKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VaultsKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultsKey *VaultsKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VaultsKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VaultsKey_STATUS, got %T", armInput)
	}

	// Set property "Attributes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Attributes != nil {
			var attributes1 KeyAttributes_STATUS
			err := attributes1.PopulateFromARM(owner, *typedInput.Properties.Attributes)
			if err != nil {
				return err
			}
			attributes := attributes1
			vaultsKey.Attributes = &attributes
		}
	}

	// no assignment for property "Conditions"

	// Set property "CurveName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CurveName != nil {
			var temp string
			temp = string(*typedInput.Properties.CurveName)
			curveName := KeyProperties_CurveName_STATUS(temp)
			vaultsKey.CurveName = &curveName
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		vaultsKey.Id = &id
	}

	// Set property "KeyOps":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.KeyOps {
			var temp string
			temp = string(item)
			vaultsKey.KeyOps = append(vaultsKey.KeyOps, KeyProperties_KeyOps_STATUS(temp))
		}
	}

	// Set property "KeySize":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeySize != nil {
			keySize := *typedInput.Properties.KeySize
			vaultsKey.KeySize = &keySize
		}
	}

	// Set property "KeyUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyUri != nil {
			keyUri := *typedInput.Properties.KeyUri
			vaultsKey.KeyUri = &keyUri
		}
	}

	// Set property "KeyUriWithVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyUriWithVersion != nil {
			keyUriWithVersion := *typedInput.Properties.KeyUriWithVersion
			vaultsKey.KeyUriWithVersion = &keyUriWithVersion
		}
	}

	// Set property "Kty":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Kty != nil {
			var temp string
			temp = string(*typedInput.Properties.Kty)
			kty := KeyProperties_Kty_STATUS(temp)
			vaultsKey.Kty = &kty
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		vaultsKey.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		vaultsKey.Name = &name
	}

	// Set property "Release_Policy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Release_Policy != nil {
			var releasePolicy1 KeyReleasePolicy_STATUS
			err := releasePolicy1.PopulateFromARM(owner, *typedInput.Properties.Release_Policy)
			if err != nil {
				return err
			}
			releasePolicy := releasePolicy1
			vaultsKey.Release_Policy = &releasePolicy
		}
	}

	// Set property "RotationPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RotationPolicy != nil {
			var rotationPolicy1 RotationPolicy_STATUS
			err := rotationPolicy1.PopulateFromARM(owner, *typedInput.Properties.RotationPolicy)
			if err != nil {
				return err
			}
			rotationPolicy := rotationPolicy1
			vaultsKey.RotationPolicy = &rotationPolicy
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		vaultsKey.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			vaultsKey.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		vaultsKey.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_VaultsKey_STATUS populates our VaultsKey_STATUS from the provided source VaultsKey_STATUS
func (vaultsKey *VaultsKey_STATUS) AssignProperties_From_VaultsKey_STATUS(source *storage.VaultsKey_STATUS) error {

	// Attributes
	if source.Attributes != nil {
		var attribute KeyAttributes_STATUS
		err := attribute.AssignProperties_From_KeyAttributes_STATUS(source.Attributes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyAttributes_STATUS() to populate field Attributes")
		}
		vaultsKey.Attributes = &attribute
	} else {
		vaultsKey.Attributes = nil
	}

	// Conditions
	vaultsKey.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CurveName
	if source.CurveName != nil {
		curveName := *source.CurveName
		curveNameTemp := genruntime.ToEnum(curveName, keyProperties_CurveName_STATUS_Values)
		vaultsKey.CurveName = &curveNameTemp
	} else {
		vaultsKey.CurveName = nil
	}

	// Id
	vaultsKey.Id = genruntime.ClonePointerToString(source.Id)

	// KeyOps
	if source.KeyOps != nil {
		keyOpList := make([]KeyProperties_KeyOps_STATUS, len(source.KeyOps))
		for keyOpIndex, keyOpItem := range source.KeyOps {
			keyOpList[keyOpIndex] = genruntime.ToEnum(keyOpItem, keyProperties_KeyOps_STATUS_Values)
		}
		vaultsKey.KeyOps = keyOpList
	} else {
		vaultsKey.KeyOps = nil
	}

	// KeySize
	vaultsKey.KeySize = genruntime.ClonePointerToInt(source.KeySize)

	// KeyUri
	vaultsKey.KeyUri = genruntime.ClonePointerToString(source.KeyUri)

	// KeyUriWithVersion
	vaultsKey.KeyUriWithVersion = genruntime.ClonePointerToString(source.KeyUriWithVersion)

	// Kty
	if source.Kty != nil {
		kty := *source.Kty
		ktyTemp := genruntime.ToEnum(kty, keyProperties_Kty_STATUS_Values)
		vaultsKey.Kty = &ktyTemp
	} else {
		vaultsKey.Kty = nil
	}

	// Location
	vaultsKey.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	vaultsKey.Name = genruntime.ClonePointerToString(source.Name)

	// Release_Policy
	if source.Release_Policy != nil {
		var releasePolicy KeyReleasePolicy_STATUS
		err := releasePolicy.AssignProperties_From_KeyReleasePolicy_STATUS(source.Release_Policy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyReleasePolicy_STATUS() to populate field Release_Policy")
		}
		vaultsKey.Release_Policy = &releasePolicy
	} else {
		vaultsKey.Release_Policy = nil
	}

	// RotationPolicy
	if source.RotationPolicy != nil {
		var rotationPolicy RotationPolicy_STATUS
		err := rotationPolicy.AssignProperties_From_RotationPolicy_STATUS(source.RotationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RotationPolicy_STATUS() to populate field RotationPolicy")
		}
		vaultsKey.RotationPolicy = &rotationPolicy
	} else {
		vaultsKey.RotationPolicy = nil
	}

	// Tags
	vaultsKey.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	vaultsKey.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_VaultsKey_STATUS populates the provided destination VaultsKey_STATUS from our VaultsKey_STATUS
func (vaultsKey *VaultsKey_STATUS) AssignProperties_To_VaultsKey_STATUS(destination *storage.VaultsKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Attributes
	if vaultsKey.Attributes != nil {
		var attribute storage.KeyAttributes_STATUS
		err := vaultsKey.Attributes.AssignProperties_To_KeyAttributes_STATUS(&attribute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyAttributes_STATUS() to populate field Attributes")
		}
		destination.Attributes = &attribute
	} else {
		destination.Attributes = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(vaultsKey.Conditions)

	// CurveName
	if vaultsKey.CurveName != nil {
		curveName := string(*vaultsKey.CurveName)
		destination.CurveName = &curveName
	} else {
		destination.CurveName = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(vaultsKey.Id)

	// KeyOps
	if vaultsKey.KeyOps != nil {
		keyOpList := make([]string, len(vaultsKey.KeyOps))
		for keyOpIndex, keyOpItem := range vaultsKey.KeyOps {
			keyOpList[keyOpIndex] = string(keyOpItem)
		}
		destination.KeyOps = keyOpList
	} else {
		destination.KeyOps = nil
	}

	// KeySize
	destination.KeySize = genruntime.ClonePointerToInt(vaultsKey.KeySize)

	// KeyUri
	destination.KeyUri = genruntime.ClonePointerToString(vaultsKey.KeyUri)

	// KeyUriWithVersion
	destination.KeyUriWithVersion = genruntime.ClonePointerToString(vaultsKey.KeyUriWithVersion)

	// Kty
	if vaultsKey.Kty != nil {
		kty := string(*vaultsKey.Kty)
		destination.Kty = &kty
	} else {
		destination.Kty = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(vaultsKey.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(vaultsKey.Name)

	// Release_Policy
	if vaultsKey.Release_Policy != nil {
		var releasePolicy storage.KeyReleasePolicy_STATUS
		err := vaultsKey.Release_Policy.AssignProperties_To_KeyReleasePolicy_STATUS(&releasePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyReleasePolicy_STATUS() to populate field Release_Policy")
		}
		destination.Release_Policy = &releasePolicy
	} else {
		destination.Release_Policy = nil
	}

	// RotationPolicy
	if vaultsKey.RotationPolicy != nil {
		var rotationPolicy storage.RotationPolicy_STATUS
		err := vaultsKey.RotationPolicy.AssignProperties_To_RotationPolicy_STATUS(&rotationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RotationPolicy_STATUS() to populate field RotationPolicy")
		}
		destination.RotationPolicy = &rotationPolicy
	} else {
		destination.RotationPolicy = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(vaultsKey.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(vaultsKey.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The object attributes managed by the Azure Key Vault service.
type KeyAttributes_STATUS struct {
	// Created: Creation time in seconds since 1970-01-01T00:00:00Z.
	Created *int `json:"created,omitempty"`

	// Enabled: Determines whether or not the object is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Exp: Expiry date in seconds since 1970-01-01T00:00:00Z.
	Exp *int `json:"exp,omitempty"`

	// Exportable: Indicates if the private key can be exported.
	Exportable *bool `json:"exportable,omitempty"`

	// Nbf: Not before date in seconds since 1970-01-01T00:00:00Z.
	Nbf *int `json:"nbf,omitempty"`

	// RecoveryLevel: The deletion recovery level currently in effect for the object. If it contains 'Purgeable', then the
	// object can be permanently deleted by a privileged user; otherwise, only the system can purge the object at the end of
	// the retention interval.
	RecoveryLevel *KeyAttributes_RecoveryLevel_STATUS `json:"recoveryLevel,omitempty"`

	// Updated: Last updated time in seconds since 1970-01-01T00:00:00Z.
	Updated *int `json:"updated,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyAttributes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (attributes *KeyAttributes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyAttributes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (attributes *KeyAttributes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyAttributes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyAttributes_STATUS, got %T", armInput)
	}

	// Set property "Created":
	if typedInput.Created != nil {
		created := *typedInput.Created
		attributes.Created = &created
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		attributes.Enabled = &enabled
	}

	// Set property "Exp":
	if typedInput.Exp != nil {
		exp := *typedInput.Exp
		attributes.Exp = &exp
	}

	// Set property "Exportable":
	if typedInput.Exportable != nil {
		exportable := *typedInput.Exportable
		attributes.Exportable = &exportable
	}

	// Set property "Nbf":
	if typedInput.Nbf != nil {
		nbf := *typedInput.Nbf
		attributes.Nbf = &nbf
	}

	// Set property "RecoveryLevel":
	if typedInput.RecoveryLevel != nil {
		var temp string
		temp = string(*typedInput.RecoveryLevel)
		recoveryLevel := KeyAttributes_RecoveryLevel_STATUS(temp)
		attributes.RecoveryLevel = &recoveryLevel
	}

	// Set property "Updated":
	if typedInput.Updated != nil {
		updated := *typedInput.Updated
		attributes.Updated = &updated
	}

	// No error
	return nil
}

// AssignProperties_From_KeyAttributes_STATUS populates our KeyAttributes_STATUS from the provided source KeyAttributes_STATUS
func (attributes *KeyAttributes_STATUS) AssignProperties_From_KeyAttributes_STATUS(source *storage.KeyAttributes_STATUS) error {

	// Created
	attributes.Created = genruntime.ClonePointerToInt(source.Created)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		attributes.Enabled = &enabled
	} else {
		attributes.Enabled = nil
	}

	// Exp
	attributes.Exp = genruntime.ClonePointerToInt(source.Exp)

	// Exportable
	if source.Exportable != nil {
		exportable := *source.Exportable
		attributes.Exportable = &exportable
	} else {
		attributes.Exportable = nil
	}

	// Nbf
	attributes.Nbf = genruntime.ClonePointerToInt(source.Nbf)

	// RecoveryLevel
	if source.RecoveryLevel != nil {
		recoveryLevel := *source.RecoveryLevel
		recoveryLevelTemp := genruntime.ToEnum(recoveryLevel, keyAttributes_RecoveryLevel_STATUS_Values)
		attributes.RecoveryLevel = &recoveryLevelTemp
	} else {
		attributes.RecoveryLevel = nil
	}

	// Updated
	attributes.Updated = genruntime.ClonePointerToInt(source.Updated)

	// No error
	return nil
}

// AssignProperties_To_KeyAttributes_STATUS populates the provided destination KeyAttributes_STATUS from our KeyAttributes_STATUS
func (attributes *KeyAttributes_STATUS) AssignProperties_To_KeyAttributes_STATUS(destination *storage.KeyAttributes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Created
	destination.Created = genruntime.ClonePointerToInt(attributes.Created)

	// Enabled
	if attributes.Enabled != nil {
		enabled := *attributes.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Exp
	destination.Exp = genruntime.ClonePointerToInt(attributes.Exp)

	// Exportable
	if attributes.Exportable != nil {
		exportable := *attributes.Exportable
		destination.Exportable = &exportable
	} else {
		destination.Exportable = nil
	}

	// Nbf
	destination.Nbf = genruntime.ClonePointerToInt(attributes.Nbf)

	// RecoveryLevel
	if attributes.RecoveryLevel != nil {
		recoveryLevel := string(*attributes.RecoveryLevel)
		destination.RecoveryLevel = &recoveryLevel
	} else {
		destination.RecoveryLevel = nil
	}

	// Updated
	destination.Updated = genruntime.ClonePointerToInt(attributes.Updated)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the key.
type KeyProperties struct {
	// Attributes: The attributes of the key.
	Attributes *KeyAttributes `json:"attributes,omitempty"`

	// CurveName: The elliptic curve name. For valid values, see JsonWebKeyCurveName.
	CurveName *KeyProperties_CurveName `json:"curveName,omitempty"`
	KeyOps    []KeyProperties_KeyOps   `json:"keyOps,omitempty"`

	// KeySize: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
	KeySize *int `json:"keySize,omitempty"`

	// Kty: The type of the key. For valid values, see JsonWebKeyType.
	Kty *KeyProperties_Kty `json:"kty,omitempty"`

	// Release_Policy: Key release policy in response. It will be used for both output and input. Omitted if empty
	Release_Policy *KeyReleasePolicy `json:"release_policy,omitempty"`

	// RotationPolicy: Key rotation policy in response. It will be used for both output and input. Omitted if empty
	RotationPolicy *RotationPolicy `json:"rotationPolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *KeyProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.KeyProperties{}

	// Set property "Attributes":
	if properties.Attributes != nil {
		attributes_ARM, err := properties.Attributes.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		attributes := *attributes_ARM.(*arm.KeyAttributes)
		result.Attributes = &attributes
	}

	// Set property "CurveName":
	if properties.CurveName != nil {
		var temp string
		temp = string(*properties.CurveName)
		curveName := arm.KeyProperties_CurveName(temp)
		result.CurveName = &curveName
	}

	// Set property "KeyOps":
	for _, item := range properties.KeyOps {
		var temp string
		temp = string(item)
		result.KeyOps = append(result.KeyOps, arm.KeyProperties_KeyOps(temp))
	}

	// Set property "KeySize":
	if properties.KeySize != nil {
		keySize := *properties.KeySize
		result.KeySize = &keySize
	}

	// Set property "Kty":
	if properties.Kty != nil {
		var temp string
		temp = string(*properties.Kty)
		kty := arm.KeyProperties_Kty(temp)
		result.Kty = &kty
	}

	// Set property "Release_Policy":
	if properties.Release_Policy != nil {
		releasePolicy_ARM, err := properties.Release_Policy.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		releasePolicy := *releasePolicy_ARM.(*arm.KeyReleasePolicy)
		result.Release_Policy = &releasePolicy
	}

	// Set property "RotationPolicy":
	if properties.RotationPolicy != nil {
		rotationPolicy_ARM, err := properties.RotationPolicy.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		rotationPolicy := *rotationPolicy_ARM.(*arm.RotationPolicy)
		result.RotationPolicy = &rotationPolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KeyProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KeyProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyProperties, got %T", armInput)
	}

	// Set property "Attributes":
	if typedInput.Attributes != nil {
		var attributes1 KeyAttributes
		err := attributes1.PopulateFromARM(owner, *typedInput.Attributes)
		if err != nil {
			return err
		}
		attributes := attributes1
		properties.Attributes = &attributes
	}

	// Set property "CurveName":
	if typedInput.CurveName != nil {
		var temp string
		temp = string(*typedInput.CurveName)
		curveName := KeyProperties_CurveName(temp)
		properties.CurveName = &curveName
	}

	// Set property "KeyOps":
	for _, item := range typedInput.KeyOps {
		var temp string
		temp = string(item)
		properties.KeyOps = append(properties.KeyOps, KeyProperties_KeyOps(temp))
	}

	// Set property "KeySize":
	if typedInput.KeySize != nil {
		keySize := *typedInput.KeySize
		properties.KeySize = &keySize
	}

	// Set property "Kty":
	if typedInput.Kty != nil {
		var temp string
		temp = string(*typedInput.Kty)
		kty := KeyProperties_Kty(temp)
		properties.Kty = &kty
	}

	// Set property "Release_Policy":
	if typedInput.Release_Policy != nil {
		var releasePolicy1 KeyReleasePolicy
		err := releasePolicy1.PopulateFromARM(owner, *typedInput.Release_Policy)
		if err != nil {
			return err
		}
		releasePolicy := releasePolicy1
		properties.Release_Policy = &releasePolicy
	}

	// Set property "RotationPolicy":
	if typedInput.RotationPolicy != nil {
		var rotationPolicy1 RotationPolicy
		err := rotationPolicy1.PopulateFromARM(owner, *typedInput.RotationPolicy)
		if err != nil {
			return err
		}
		rotationPolicy := rotationPolicy1
		properties.RotationPolicy = &rotationPolicy
	}

	// No error
	return nil
}

// AssignProperties_From_KeyProperties populates our KeyProperties from the provided source KeyProperties
func (properties *KeyProperties) AssignProperties_From_KeyProperties(source *storage.KeyProperties) error {

	// Attributes
	if source.Attributes != nil {
		var attribute KeyAttributes
		err := attribute.AssignProperties_From_KeyAttributes(source.Attributes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyAttributes() to populate field Attributes")
		}
		properties.Attributes = &attribute
	} else {
		properties.Attributes = nil
	}

	// CurveName
	if source.CurveName != nil {
		curveName := *source.CurveName
		curveNameTemp := genruntime.ToEnum(curveName, keyProperties_CurveName_Values)
		properties.CurveName = &curveNameTemp
	} else {
		properties.CurveName = nil
	}

	// KeyOps
	if source.KeyOps != nil {
		keyOpList := make([]KeyProperties_KeyOps, len(source.KeyOps))
		for keyOpIndex, keyOpItem := range source.KeyOps {
			keyOpList[keyOpIndex] = genruntime.ToEnum(keyOpItem, keyProperties_KeyOps_Values)
		}
		properties.KeyOps = keyOpList
	} else {
		properties.KeyOps = nil
	}

	// KeySize
	properties.KeySize = genruntime.ClonePointerToInt(source.KeySize)

	// Kty
	if source.Kty != nil {
		kty := *source.Kty
		ktyTemp := genruntime.ToEnum(kty, keyProperties_Kty_Values)
		properties.Kty = &ktyTemp
	} else {
		properties.Kty = nil
	}

	// Release_Policy
	if source.Release_Policy != nil {
		var releasePolicy KeyReleasePolicy
		err := releasePolicy.AssignProperties_From_KeyReleasePolicy(source.Release_Policy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyReleasePolicy() to populate field Release_Policy")
		}
		properties.Release_Policy = &releasePolicy
	} else {
		properties.Release_Policy = nil
	}

	// RotationPolicy
	if source.RotationPolicy != nil {
		var rotationPolicy RotationPolicy
		err := rotationPolicy.AssignProperties_From_RotationPolicy(source.RotationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RotationPolicy() to populate field RotationPolicy")
		}
		properties.RotationPolicy = &rotationPolicy
	} else {
		properties.RotationPolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KeyProperties populates the provided destination KeyProperties from our KeyProperties
func (properties *KeyProperties) AssignProperties_To_KeyProperties(destination *storage.KeyProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Attributes
	if properties.Attributes != nil {
		var attribute storage.KeyAttributes
		err := properties.Attributes.AssignProperties_To_KeyAttributes(&attribute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyAttributes() to populate field Attributes")
		}
		destination.Attributes = &attribute
	} else {
		destination.Attributes = nil
	}

	// CurveName
	if properties.CurveName != nil {
		curveName := string(*properties.CurveName)
		destination.CurveName = &curveName
	} else {
		destination.CurveName = nil
	}

	// KeyOps
	if properties.KeyOps != nil {
		keyOpList := make([]string, len(properties.KeyOps))
		for keyOpIndex, keyOpItem := range properties.KeyOps {
			keyOpList[keyOpIndex] = string(keyOpItem)
		}
		destination.KeyOps = keyOpList
	} else {
		destination.KeyOps = nil
	}

	// KeySize
	destination.KeySize = genruntime.ClonePointerToInt(properties.KeySize)

	// Kty
	if properties.Kty != nil {
		kty := string(*properties.Kty)
		destination.Kty = &kty
	} else {
		destination.Kty = nil
	}

	// Release_Policy
	if properties.Release_Policy != nil {
		var releasePolicy storage.KeyReleasePolicy
		err := properties.Release_Policy.AssignProperties_To_KeyReleasePolicy(&releasePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyReleasePolicy() to populate field Release_Policy")
		}
		destination.Release_Policy = &releasePolicy
	} else {
		destination.Release_Policy = nil
	}

	// RotationPolicy
	if properties.RotationPolicy != nil {
		var rotationPolicy storage.RotationPolicy
		err := properties.RotationPolicy.AssignProperties_To_RotationPolicy(&rotationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RotationPolicy() to populate field RotationPolicy")
		}
		destination.RotationPolicy = &rotationPolicy
	} else {
		destination.RotationPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type KeyProperties_CurveName_STATUS string

const (
	KeyProperties_CurveName_STATUS_P256  = KeyProperties_CurveName_STATUS("P-256")
	KeyProperties_CurveName_STATUS_P256K = KeyProperties_CurveName_STATUS("P-256K")
	KeyProperties_CurveName_STATUS_P384  = KeyProperties_CurveName_STATUS("P-384")
	KeyProperties_CurveName_STATUS_P521  = KeyProperties_CurveName_STATUS("P-521")
)

// Mapping from string to KeyProperties_CurveName_STATUS
var keyProperties_CurveName_STATUS_Values = map[string]KeyProperties_CurveName_STATUS{
	"p-256":  KeyProperties_CurveName_STATUS_P256,
	"p-256k": KeyProperties_CurveName_STATUS_P256K,
	"p-384":  KeyProperties_CurveName_STATUS_P384,
	"p-521":  KeyProperties_CurveName_STATUS_P521,
}

type KeyProperties_KeyOps_STATUS string

const (
	KeyProperties_KeyOps_STATUS_Decrypt   = KeyProperties_KeyOps_STATUS("decrypt")
	KeyProperties_KeyOps_STATUS_Encrypt   = KeyProperties_KeyOps_STATUS("encrypt")
	KeyProperties_KeyOps_STATUS_Import    = KeyProperties_KeyOps_STATUS("import")
	KeyProperties_KeyOps_STATUS_Release   = KeyProperties_KeyOps_STATUS("release")
	KeyProperties_KeyOps_STATUS_Sign      = KeyProperties_KeyOps_STATUS("sign")
	KeyProperties_KeyOps_STATUS_UnwrapKey = KeyProperties_KeyOps_STATUS("unwrapKey")
	KeyProperties_KeyOps_STATUS_Verify    = KeyProperties_KeyOps_STATUS("verify")
	KeyProperties_KeyOps_STATUS_WrapKey   = KeyProperties_KeyOps_STATUS("wrapKey")
)

// Mapping from string to KeyProperties_KeyOps_STATUS
var keyProperties_KeyOps_STATUS_Values = map[string]KeyProperties_KeyOps_STATUS{
	"decrypt":   KeyProperties_KeyOps_STATUS_Decrypt,
	"encrypt":   KeyProperties_KeyOps_STATUS_Encrypt,
	"import":    KeyProperties_KeyOps_STATUS_Import,
	"release":   KeyProperties_KeyOps_STATUS_Release,
	"sign":      KeyProperties_KeyOps_STATUS_Sign,
	"unwrapkey": KeyProperties_KeyOps_STATUS_UnwrapKey,
	"verify":    KeyProperties_KeyOps_STATUS_Verify,
	"wrapkey":   KeyProperties_KeyOps_STATUS_WrapKey,
}

type KeyProperties_Kty_STATUS string

const (
	KeyProperties_Kty_STATUS_EC     = KeyProperties_Kty_STATUS("EC")
	KeyProperties_Kty_STATUS_ECHSM  = KeyProperties_Kty_STATUS("EC-HSM")
	KeyProperties_Kty_STATUS_RSA    = KeyProperties_Kty_STATUS("RSA")
	KeyProperties_Kty_STATUS_RSAHSM = KeyProperties_Kty_STATUS("RSA-HSM")
)

// Mapping from string to KeyProperties_Kty_STATUS
var keyProperties_Kty_STATUS_Values = map[string]KeyProperties_Kty_STATUS{
	"ec":      KeyProperties_Kty_STATUS_EC,
	"ec-hsm":  KeyProperties_Kty_STATUS_ECHSM,
	"rsa":     KeyProperties_Kty_STATUS_RSA,
	"rsa-hsm": KeyProperties_Kty_STATUS_RSAHSM,
}

type KeyReleasePolicy_STATUS struct {
	// ContentType: Content type and version of key release policy
	ContentType *string `json:"contentType,omitempty"`

	// Data: Blob encoding the policy rules under which the key can be released.
	Data *string `json:"data,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyReleasePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *KeyReleasePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyReleasePolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *KeyReleasePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyReleasePolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyReleasePolicy_STATUS, got %T", armInput)
	}

	// Set property "ContentType":
	if typedInput.ContentType != nil {
		contentType := *typedInput.ContentType
		policy.ContentType = &contentType
	}

	// Set property "Data":
	if typedInput.Data != nil {
		data := *typedInput.Data
		policy.Data = &data
	}

	// No error
	return nil
}

// AssignProperties_From_KeyReleasePolicy_STATUS populates our KeyReleasePolicy_STATUS from the provided source KeyReleasePolicy_STATUS
func (policy *KeyReleasePolicy_STATUS) AssignProperties_From_KeyReleasePolicy_STATUS(source *storage.KeyReleasePolicy_STATUS) error {

	// ContentType
	policy.ContentType = genruntime.ClonePointerToString(source.ContentType)

	// Data
	policy.Data = genruntime.ClonePointerToString(source.Data)

	// No error
	return nil
}

// AssignProperties_To_KeyReleasePolicy_STATUS populates the provided destination KeyReleasePolicy_STATUS from our KeyReleasePolicy_STATUS
func (policy *KeyReleasePolicy_STATUS) AssignProperties_To_KeyReleasePolicy_STATUS(destination *storage.KeyReleasePolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContentType
	destination.ContentType = genruntime.ClonePointerToString(policy.ContentType)

	// Data
	destination.Data = genruntime.ClonePointerToString(policy.Data)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type RotationPolicy_STATUS struct {
	// Attributes: The attributes of key rotation policy.
	Attributes *KeyRotationPolicyAttributes_STATUS `json:"attributes,omitempty"`

	// LifetimeActions: The lifetimeActions for key rotation action.
	LifetimeActions []LifetimeAction_STATUS `json:"lifetimeActions,omitempty"`
}

var _ genruntime.FromARMConverter = &RotationPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *RotationPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RotationPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *RotationPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RotationPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RotationPolicy_STATUS, got %T", armInput)
	}

	// Set property "Attributes":
	if typedInput.Attributes != nil {
		var attributes1 KeyRotationPolicyAttributes_STATUS
		err := attributes1.PopulateFromARM(owner, *typedInput.Attributes)
		if err != nil {
			return err
		}
		attributes := attributes1
		policy.Attributes = &attributes
	}

	// Set property "LifetimeActions":
	for _, item := range typedInput.LifetimeActions {
		var item1 LifetimeAction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.LifetimeActions = append(policy.LifetimeActions, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_RotationPolicy_STATUS populates our RotationPolicy_STATUS from the provided source RotationPolicy_STATUS
func (policy *RotationPolicy_STATUS) AssignProperties_From_RotationPolicy_STATUS(source *storage.RotationPolicy_STATUS) error {

	// Attributes
	if source.Attributes != nil {
		var attribute KeyRotationPolicyAttributes_STATUS
		err := attribute.AssignProperties_From_KeyRotationPolicyAttributes_STATUS(source.Attributes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyRotationPolicyAttributes_STATUS() to populate field Attributes")
		}
		policy.Attributes = &attribute
	} else {
		policy.Attributes = nil
	}

	// LifetimeActions
	if source.LifetimeActions != nil {
		lifetimeActionList := make([]LifetimeAction_STATUS, len(source.LifetimeActions))
		for lifetimeActionIndex, lifetimeActionItem := range source.LifetimeActions {
			var lifetimeAction LifetimeAction_STATUS
			err := lifetimeAction.AssignProperties_From_LifetimeAction_STATUS(&lifetimeActionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LifetimeAction_STATUS() to populate field LifetimeActions")
			}
			lifetimeActionList[lifetimeActionIndex] = lifetimeAction
		}
		policy.LifetimeActions = lifetimeActionList
	} else {
		policy.LifetimeActions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RotationPolicy_STATUS populates the provided destination RotationPolicy_STATUS from our RotationPolicy_STATUS
func (policy *RotationPolicy_STATUS) AssignProperties_To_RotationPolicy_STATUS(destination *storage.RotationPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Attributes
	if policy.Attributes != nil {
		var attribute storage.KeyRotationPolicyAttributes_STATUS
		err := policy.Attributes.AssignProperties_To_KeyRotationPolicyAttributes_STATUS(&attribute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyRotationPolicyAttributes_STATUS() to populate field Attributes")
		}
		destination.Attributes = &attribute
	} else {
		destination.Attributes = nil
	}

	// LifetimeActions
	if policy.LifetimeActions != nil {
		lifetimeActionList := make([]storage.LifetimeAction_STATUS, len(policy.LifetimeActions))
		for lifetimeActionIndex, lifetimeActionItem := range policy.LifetimeActions {
			var lifetimeAction storage.LifetimeAction_STATUS
			err := lifetimeActionItem.AssignProperties_To_LifetimeAction_STATUS(&lifetimeAction)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LifetimeAction_STATUS() to populate field LifetimeActions")
			}
			lifetimeActionList[lifetimeActionIndex] = lifetimeAction
		}
		destination.LifetimeActions = lifetimeActionList
	} else {
		destination.LifetimeActions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type VaultsKeyOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_VaultsKeyOperatorSpec populates our VaultsKeyOperatorSpec from the provided source VaultsKeyOperatorSpec
func (operator *VaultsKeyOperatorSpec) AssignProperties_From_VaultsKeyOperatorSpec(source *storage.VaultsKeyOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VaultsKeyOperatorSpec populates the provided destination VaultsKeyOperatorSpec from our VaultsKeyOperatorSpec
func (operator *VaultsKeyOperatorSpec) AssignProperties_To_VaultsKeyOperatorSpec(destination *storage.VaultsKeyOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The object attributes managed by the Azure Key Vault service.
type KeyAttributes struct {
	// Enabled: Determines whether or not the object is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Exp: Expiry date in seconds since 1970-01-01T00:00:00Z.
	Exp *int `json:"exp,omitempty"`

	// Exportable: Indicates if the private key can be exported.
	Exportable *bool `json:"exportable,omitempty"`

	// Nbf: Not before date in seconds since 1970-01-01T00:00:00Z.
	Nbf *int `json:"nbf,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyAttributes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (attributes *KeyAttributes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if attributes == nil {
		return nil, nil
	}
	result := &arm.KeyAttributes{}

	// Set property "Enabled":
	if attributes.Enabled != nil {
		enabled := *attributes.Enabled
		result.Enabled = &enabled
	}

	// Set property "Exp":
	if attributes.Exp != nil {
		exp := *attributes.Exp
		result.Exp = &exp
	}

	// Set property "Exportable":
	if attributes.Exportable != nil {
		exportable := *attributes.Exportable
		result.Exportable = &exportable
	}

	// Set property "Nbf":
	if attributes.Nbf != nil {
		nbf := *attributes.Nbf
		result.Nbf = &nbf
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (attributes *KeyAttributes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyAttributes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (attributes *KeyAttributes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyAttributes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyAttributes, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		attributes.Enabled = &enabled
	}

	// Set property "Exp":
	if typedInput.Exp != nil {
		exp := *typedInput.Exp
		attributes.Exp = &exp
	}

	// Set property "Exportable":
	if typedInput.Exportable != nil {
		exportable := *typedInput.Exportable
		attributes.Exportable = &exportable
	}

	// Set property "Nbf":
	if typedInput.Nbf != nil {
		nbf := *typedInput.Nbf
		attributes.Nbf = &nbf
	}

	// No error
	return nil
}

// AssignProperties_From_KeyAttributes populates our KeyAttributes from the provided source KeyAttributes
func (attributes *KeyAttributes) AssignProperties_From_KeyAttributes(source *storage.KeyAttributes) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		attributes.Enabled = &enabled
	} else {
		attributes.Enabled = nil
	}

	// Exp
	attributes.Exp = genruntime.ClonePointerToInt(source.Exp)

	// Exportable
	if source.Exportable != nil {
		exportable := *source.Exportable
		attributes.Exportable = &exportable
	} else {
		attributes.Exportable = nil
	}

	// Nbf
	attributes.Nbf = genruntime.ClonePointerToInt(source.Nbf)

	// No error
	return nil
}

// AssignProperties_To_KeyAttributes populates the provided destination KeyAttributes from our KeyAttributes
func (attributes *KeyAttributes) AssignProperties_To_KeyAttributes(destination *storage.KeyAttributes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if attributes.Enabled != nil {
		enabled := *attributes.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Exp
	destination.Exp = genruntime.ClonePointerToInt(attributes.Exp)

	// Exportable
	if attributes.Exportable != nil {
		exportable := *attributes.Exportable
		destination.Exportable = &exportable
	} else {
		destination.Exportable = nil
	}

	// Nbf
	destination.Nbf = genruntime.ClonePointerToInt(attributes.Nbf)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type KeyAttributes_RecoveryLevel_STATUS string

const (
	KeyAttributes_RecoveryLevel_STATUS_Purgeable                        = KeyAttributes_RecoveryLevel_STATUS("Purgeable")
	KeyAttributes_RecoveryLevel_STATUS_Recoverable                      = KeyAttributes_RecoveryLevel_STATUS("Recoverable")
	KeyAttributes_RecoveryLevel_STATUS_RecoverableProtectedSubscription = KeyAttributes_RecoveryLevel_STATUS("Recoverable+ProtectedSubscription")
	KeyAttributes_RecoveryLevel_STATUS_RecoverablePurgeable             = KeyAttributes_RecoveryLevel_STATUS("Recoverable+Purgeable")
)

// Mapping from string to KeyAttributes_RecoveryLevel_STATUS
var keyAttributes_RecoveryLevel_STATUS_Values = map[string]KeyAttributes_RecoveryLevel_STATUS{
	"purgeable":                         KeyAttributes_RecoveryLevel_STATUS_Purgeable,
	"recoverable":                       KeyAttributes_RecoveryLevel_STATUS_Recoverable,
	"recoverable+protectedsubscription": KeyAttributes_RecoveryLevel_STATUS_RecoverableProtectedSubscription,
	"recoverable+purgeable":             KeyAttributes_RecoveryLevel_STATUS_RecoverablePurgeable,
}

// +kubebuilder:validation:Enum={"P-256","P-256K","P-384","P-521"}
type KeyProperties_CurveName string

const (
	KeyProperties_CurveName_P256  = KeyProperties_CurveName("P-256")
	KeyProperties_CurveName_P256K = KeyProperties_CurveName("P-256K")
	KeyProperties_CurveName_P384  = KeyProperties_CurveName("P-384")
	KeyProperties_CurveName_P521  = KeyProperties_CurveName("P-521")
)

// Mapping from string to KeyProperties_CurveName
var keyProperties_CurveName_Values = map[string]KeyProperties_CurveName{
	"p-256":  KeyProperties_CurveName_P256,
	"p-256k": KeyProperties_CurveName_P256K,
	"p-384":  KeyProperties_CurveName_P384,
	"p-521":  KeyProperties_CurveName_P521,
}

// +kubebuilder:validation:Enum={"decrypt","encrypt","import","release","sign","unwrapKey","verify","wrapKey"}
type KeyProperties_KeyOps string

const (
	KeyProperties_KeyOps_Decrypt   = KeyProperties_KeyOps("decrypt")
	KeyProperties_KeyOps_Encrypt   = KeyProperties_KeyOps("encrypt")
	KeyProperties_KeyOps_Import    = KeyProperties_KeyOps("import")
	KeyProperties_KeyOps_Release   = KeyProperties_KeyOps("release")
	KeyProperties_KeyOps_Sign      = KeyProperties_KeyOps("sign")
	KeyProperties_KeyOps_UnwrapKey = KeyProperties_KeyOps("unwrapKey")
	KeyProperties_KeyOps_Verify    = KeyProperties_KeyOps("verify")
	KeyProperties_KeyOps_WrapKey   = KeyProperties_KeyOps("wrapKey")
)

// Mapping from string to KeyProperties_KeyOps
var keyProperties_KeyOps_Values = map[string]KeyProperties_KeyOps{
	"decrypt":   KeyProperties_KeyOps_Decrypt,
	"encrypt":   KeyProperties_KeyOps_Encrypt,
	"import":    KeyProperties_KeyOps_Import,
	"release":   KeyProperties_KeyOps_Release,
	"sign":      KeyProperties_KeyOps_Sign,
	"unwrapkey": KeyProperties_KeyOps_UnwrapKey,
	"verify":    KeyProperties_KeyOps_Verify,
	"wrapkey":   KeyProperties_KeyOps_WrapKey,
}

// +kubebuilder:validation:Enum={"EC","EC-HSM","RSA","RSA-HSM"}
type KeyProperties_Kty string

const (
	KeyProperties_Kty_EC     = KeyProperties_Kty("EC")
	KeyProperties_Kty_ECHSM  = KeyProperties_Kty("EC-HSM")
	KeyProperties_Kty_RSA    = KeyProperties_Kty("RSA")
	KeyProperties_Kty_RSAHSM = KeyProperties_Kty("RSA-HSM")
)

// Mapping from string to KeyProperties_Kty
var keyProperties_Kty_Values = map[string]KeyProperties_Kty{
	"ec":      KeyProperties_Kty_EC,
	"ec-hsm":  KeyProperties_Kty_ECHSM,
	"rsa":     KeyProperties_Kty_RSA,
	"rsa-hsm": KeyProperties_Kty_RSAHSM,
}

type KeyReleasePolicy struct {
	// ContentType: Content type and version of key release policy
	ContentType *string `json:"contentType,omitempty"`

	// +kubebuilder:validation:Pattern="^[-A-Za-z0-9_]$"
	// Data: Blob encoding the policy rules under which the key can be released.
	Data *string `json:"data,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyReleasePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *KeyReleasePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.KeyReleasePolicy{}

	// Set property "ContentType":
	if policy.ContentType != nil {
		contentType := *policy.ContentType
		result.ContentType = &contentType
	}

	// Set property "Data":
	if policy.Data != nil {
		data := *policy.Data
		result.Data = &data
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *KeyReleasePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyReleasePolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *KeyReleasePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyReleasePolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyReleasePolicy, got %T", armInput)
	}

	// Set property "ContentType":
	if typedInput.ContentType != nil {
		contentType := *typedInput.ContentType
		policy.ContentType = &contentType
	}

	// Set property "Data":
	if typedInput.Data != nil {
		data := *typedInput.Data
		policy.Data = &data
	}

	// No error
	return nil
}

// AssignProperties_From_KeyReleasePolicy populates our KeyReleasePolicy from the provided source KeyReleasePolicy
func (policy *KeyReleasePolicy) AssignProperties_From_KeyReleasePolicy(source *storage.KeyReleasePolicy) error {

	// ContentType
	policy.ContentType = genruntime.ClonePointerToString(source.ContentType)

	// Data
	policy.Data = genruntime.ClonePointerToString(source.Data)

	// No error
	return nil
}

// AssignProperties_To_KeyReleasePolicy populates the provided destination KeyReleasePolicy from our KeyReleasePolicy
func (policy *KeyReleasePolicy) AssignProperties_To_KeyReleasePolicy(destination *storage.KeyReleasePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContentType
	destination.ContentType = genruntime.ClonePointerToString(policy.ContentType)

	// Data
	destination.Data = genruntime.ClonePointerToString(policy.Data)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type KeyRotationPolicyAttributes_STATUS struct {
	// Created: Creation time in seconds since 1970-01-01T00:00:00Z.
	Created *int `json:"created,omitempty"`

	// ExpiryTime: The expiration time for the new key version. It should be in ISO8601 format. Eg: 'P90D', 'P1Y'.
	ExpiryTime *string `json:"expiryTime,omitempty"`

	// Updated: Last updated time in seconds since 1970-01-01T00:00:00Z.
	Updated *int `json:"updated,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyRotationPolicyAttributes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (attributes *KeyRotationPolicyAttributes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyRotationPolicyAttributes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (attributes *KeyRotationPolicyAttributes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyRotationPolicyAttributes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyRotationPolicyAttributes_STATUS, got %T", armInput)
	}

	// Set property "Created":
	if typedInput.Created != nil {
		created := *typedInput.Created
		attributes.Created = &created
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		attributes.ExpiryTime = &expiryTime
	}

	// Set property "Updated":
	if typedInput.Updated != nil {
		updated := *typedInput.Updated
		attributes.Updated = &updated
	}

	// No error
	return nil
}

// AssignProperties_From_KeyRotationPolicyAttributes_STATUS populates our KeyRotationPolicyAttributes_STATUS from the provided source KeyRotationPolicyAttributes_STATUS
func (attributes *KeyRotationPolicyAttributes_STATUS) AssignProperties_From_KeyRotationPolicyAttributes_STATUS(source *storage.KeyRotationPolicyAttributes_STATUS) error {

	// Created
	attributes.Created = genruntime.ClonePointerToInt(source.Created)

	// ExpiryTime
	attributes.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Updated
	attributes.Updated = genruntime.ClonePointerToInt(source.Updated)

	// No error
	return nil
}

// AssignProperties_To_KeyRotationPolicyAttributes_STATUS populates the provided destination KeyRotationPolicyAttributes_STATUS from our KeyRotationPolicyAttributes_STATUS
func (attributes *KeyRotationPolicyAttributes_STATUS) AssignProperties_To_KeyRotationPolicyAttributes_STATUS(destination *storage.KeyRotationPolicyAttributes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Created
	destination.Created = genruntime.ClonePointerToInt(attributes.Created)

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(attributes.ExpiryTime)

	// Updated
	destination.Updated = genruntime.ClonePointerToInt(attributes.Updated)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LifetimeAction_STATUS struct {
	// Action: The action of key rotation policy lifetimeAction.
	Action *Action_STATUS `json:"action,omitempty"`

	// Trigger: The trigger of key rotation policy lifetimeAction.
	Trigger *Trigger_STATUS `json:"trigger,omitempty"`
}

var _ genruntime.FromARMConverter = &LifetimeAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *LifetimeAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LifetimeAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *LifetimeAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LifetimeAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LifetimeAction_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var action2 Action_STATUS
		err := action2.PopulateFromARM(owner, *typedInput.Action)
		if err != nil {
			return err
		}
		action1 := action2
		action.Action = &action1
	}

	// Set property "Trigger":
	if typedInput.Trigger != nil {
		var trigger1 Trigger_STATUS
		err := trigger1.PopulateFromARM(owner, *typedInput.Trigger)
		if err != nil {
			return err
		}
		trigger := trigger1
		action.Trigger = &trigger
	}

	// No error
	return nil
}

// AssignProperties_From_LifetimeAction_STATUS populates our LifetimeAction_STATUS from the provided source LifetimeAction_STATUS
func (action *LifetimeAction_STATUS) AssignProperties_From_LifetimeAction_STATUS(source *storage.LifetimeAction_STATUS) error {

	// Action
	if source.Action != nil {
		var actionLocal Action_STATUS
		err := actionLocal.AssignProperties_From_Action_STATUS(source.Action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Action_STATUS() to populate field Action")
		}
		action.Action = &actionLocal
	} else {
		action.Action = nil
	}

	// Trigger
	if source.Trigger != nil {
		var trigger Trigger_STATUS
		err := trigger.AssignProperties_From_Trigger_STATUS(source.Trigger)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Trigger_STATUS() to populate field Trigger")
		}
		action.Trigger = &trigger
	} else {
		action.Trigger = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LifetimeAction_STATUS populates the provided destination LifetimeAction_STATUS from our LifetimeAction_STATUS
func (action *LifetimeAction_STATUS) AssignProperties_To_LifetimeAction_STATUS(destination *storage.LifetimeAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if action.Action != nil {
		var actionLocal storage.Action_STATUS
		err := action.Action.AssignProperties_To_Action_STATUS(&actionLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Action_STATUS() to populate field Action")
		}
		destination.Action = &actionLocal
	} else {
		destination.Action = nil
	}

	// Trigger
	if action.Trigger != nil {
		var trigger storage.Trigger_STATUS
		err := action.Trigger.AssignProperties_To_Trigger_STATUS(&trigger)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Trigger_STATUS() to populate field Trigger")
		}
		destination.Trigger = &trigger
	} else {
		destination.Trigger = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type RotationPolicy struct {
	// Attributes: The attributes of key rotation policy.
	Attributes *KeyRotationPolicyAttributes `json:"attributes,omitempty"`

	// LifetimeActions: The lifetimeActions for key rotation action.
	LifetimeActions []LifetimeAction `json:"lifetimeActions,omitempty"`
}

var _ genruntime.ARMTransformer = &RotationPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *RotationPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.RotationPolicy{}

	// Set property "Attributes":
	if policy.Attributes != nil {
		attributes_ARM, err := policy.Attributes.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		attributes := *attributes_ARM.(*arm.KeyRotationPolicyAttributes)
		result.Attributes = &attributes
	}

	// Set property "LifetimeActions":
	for _, item := range policy.LifetimeActions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.LifetimeActions = append(result.LifetimeActions, *item_ARM.(*arm.LifetimeAction))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *RotationPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RotationPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *RotationPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RotationPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RotationPolicy, got %T", armInput)
	}

	// Set property "Attributes":
	if typedInput.Attributes != nil {
		var attributes1 KeyRotationPolicyAttributes
		err := attributes1.PopulateFromARM(owner, *typedInput.Attributes)
		if err != nil {
			return err
		}
		attributes := attributes1
		policy.Attributes = &attributes
	}

	// Set property "LifetimeActions":
	for _, item := range typedInput.LifetimeActions {
		var item1 LifetimeAction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.LifetimeActions = append(policy.LifetimeActions, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_RotationPolicy populates our RotationPolicy from the provided source RotationPolicy
func (policy *RotationPolicy) AssignProperties_From_RotationPolicy(source *storage.RotationPolicy) error {

	// Attributes
	if source.Attributes != nil {
		var attribute KeyRotationPolicyAttributes
		err := attribute.AssignProperties_From_KeyRotationPolicyAttributes(source.Attributes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyRotationPolicyAttributes() to populate field Attributes")
		}
		policy.Attributes = &attribute
	} else {
		policy.Attributes = nil
	}

	// LifetimeActions
	if source.LifetimeActions != nil {
		lifetimeActionList := make([]LifetimeAction, len(source.LifetimeActions))
		for lifetimeActionIndex, lifetimeActionItem := range source.LifetimeActions {
			var lifetimeAction LifetimeAction
			err := lifetimeAction.AssignProperties_From_LifetimeAction(&lifetimeActionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LifetimeAction() to populate field LifetimeActions")
			}
			lifetimeActionList[lifetimeActionIndex] = lifetimeAction
		}
		policy.LifetimeActions = lifetimeActionList
	} else {
		policy.LifetimeActions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RotationPolicy populates the provided destination RotationPolicy from our RotationPolicy
func (policy *RotationPolicy) AssignProperties_To_RotationPolicy(destination *storage.RotationPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Attributes
	if policy.Attributes != nil {
		var attribute storage.KeyRotationPolicyAttributes
		err := policy.Attributes.AssignProperties_To_KeyRotationPolicyAttributes(&attribute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyRotationPolicyAttributes() to populate field Attributes")
		}
		destination.Attributes = &attribute
	} else {
		destination.Attributes = nil
	}

	// LifetimeActions
	if policy.LifetimeActions != nil {
		lifetimeActionList := make([]storage.LifetimeAction, len(policy.LifetimeActions))
		for lifetimeActionIndex, lifetimeActionItem := range policy.LifetimeActions {
			var lifetimeAction storage.LifetimeAction
			err := lifetimeActionItem.AssignProperties_To_LifetimeAction(&lifetimeAction)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LifetimeAction() to populate field LifetimeActions")
			}
			lifetimeActionList[lifetimeActionIndex] = lifetimeAction
		}
		destination.LifetimeActions = lifetimeActionList
	} else {
		destination.LifetimeActions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Action_STATUS struct {
	// Type: The type of action.
	Type *Action_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Action_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *Action_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Action_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *Action_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Action_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Action_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Action_Type_STATUS(temp)
		action.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Action_STATUS populates our Action_STATUS from the provided source Action_STATUS
func (action *Action_STATUS) AssignProperties_From_Action_STATUS(source *storage.Action_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, action_Type_STATUS_Values)
		action.Type = &typeTemp
	} else {
		action.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Action_STATUS populates the provided destination Action_STATUS from our Action_STATUS
func (action *Action_STATUS) AssignProperties_To_Action_STATUS(destination *storage.Action_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if action.Type != nil {
		typeVar := string(*action.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type KeyRotationPolicyAttributes struct {
	// ExpiryTime: The expiration time for the new key version. It should be in ISO8601 format. Eg: 'P90D', 'P1Y'.
	ExpiryTime *string `json:"expiryTime,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyRotationPolicyAttributes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (attributes *KeyRotationPolicyAttributes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if attributes == nil {
		return nil, nil
	}
	result := &arm.KeyRotationPolicyAttributes{}

	// Set property "ExpiryTime":
	if attributes.ExpiryTime != nil {
		expiryTime := *attributes.ExpiryTime
		result.ExpiryTime = &expiryTime
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (attributes *KeyRotationPolicyAttributes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyRotationPolicyAttributes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (attributes *KeyRotationPolicyAttributes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyRotationPolicyAttributes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyRotationPolicyAttributes, got %T", armInput)
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		attributes.ExpiryTime = &expiryTime
	}

	// No error
	return nil
}

// AssignProperties_From_KeyRotationPolicyAttributes populates our KeyRotationPolicyAttributes from the provided source KeyRotationPolicyAttributes
func (attributes *KeyRotationPolicyAttributes) AssignProperties_From_KeyRotationPolicyAttributes(source *storage.KeyRotationPolicyAttributes) error {

	// ExpiryTime
	attributes.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// No error
	return nil
}

// AssignProperties_To_KeyRotationPolicyAttributes populates the provided destination KeyRotationPolicyAttributes from our KeyRotationPolicyAttributes
func (attributes *KeyRotationPolicyAttributes) AssignProperties_To_KeyRotationPolicyAttributes(destination *storage.KeyRotationPolicyAttributes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(attributes.ExpiryTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LifetimeAction struct {
	// Action: The action of key rotation policy lifetimeAction.
	Action *Action `json:"action,omitempty"`

	// Trigger: The trigger of key rotation policy lifetimeAction.
	Trigger *Trigger `json:"trigger,omitempty"`
}

var _ genruntime.ARMTransformer = &LifetimeAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *LifetimeAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.LifetimeAction{}

	// Set property "Action":
	if action.Action != nil {
		action_ARM, err := action.Action.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		action1 := *action_ARM.(*arm.Action)
		result.Action = &action1
	}

	// Set property "Trigger":
	if action.Trigger != nil {
		trigger_ARM, err := action.Trigger.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		trigger := *trigger_ARM.(*arm.Trigger)
		result.Trigger = &trigger
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *LifetimeAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LifetimeAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *LifetimeAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LifetimeAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LifetimeAction, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var action2 Action
		err := action2.PopulateFromARM(owner, *typedInput.Action)
		if err != nil {
			return err
		}
		action1 := action2
		action.Action = &action1
	}

	// Set property "Trigger":
	if typedInput.Trigger != nil {
		var trigger1 Trigger
		err := trigger1.PopulateFromARM(owner, *typedInput.Trigger)
		if err != nil {
			return err
		}
		trigger := trigger1
		action.Trigger = &trigger
	}

	// No error
	return nil
}

// AssignProperties_From_LifetimeAction populates our LifetimeAction from the provided source LifetimeAction
func (action *LifetimeAction) AssignProperties_From_LifetimeAction(source *storage.LifetimeAction) error {

	// Action
	if source.Action != nil {
		var actionLocal Action
		err := actionLocal.AssignProperties_From_Action(source.Action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Action() to populate field Action")
		}
		action.Action = &actionLocal
	} else {
		action.Action = nil
	}

	// Trigger
	if source.Trigger != nil {
		var trigger Trigger
		err := trigger.AssignProperties_From_Trigger(source.Trigger)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Trigger() to populate field Trigger")
		}
		action.Trigger = &trigger
	} else {
		action.Trigger = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LifetimeAction populates the provided destination LifetimeAction from our LifetimeAction
func (action *LifetimeAction) AssignProperties_To_LifetimeAction(destination *storage.LifetimeAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if action.Action != nil {
		var actionLocal storage.Action
		err := action.Action.AssignProperties_To_Action(&actionLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Action() to populate field Action")
		}
		destination.Action = &actionLocal
	} else {
		destination.Action = nil
	}

	// Trigger
	if action.Trigger != nil {
		var trigger storage.Trigger
		err := action.Trigger.AssignProperties_To_Trigger(&trigger)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Trigger() to populate field Trigger")
		}
		destination.Trigger = &trigger
	} else {
		destination.Trigger = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Trigger_STATUS struct {
	// TimeAfterCreate: The time duration after key creation to rotate the key. It only applies to rotate. It will be in ISO
	// 8601 duration format. Eg: 'P90D', 'P1Y'.
	TimeAfterCreate *string `json:"timeAfterCreate,omitempty"`

	// TimeBeforeExpiry: The time duration before key expiring to rotate or notify. It will be in ISO 8601 duration format. Eg:
	// 'P90D', 'P1Y'.
	TimeBeforeExpiry *string `json:"timeBeforeExpiry,omitempty"`
}

var _ genruntime.FromARMConverter = &Trigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *Trigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Trigger_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *Trigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Trigger_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Trigger_STATUS, got %T", armInput)
	}

	// Set property "TimeAfterCreate":
	if typedInput.TimeAfterCreate != nil {
		timeAfterCreate := *typedInput.TimeAfterCreate
		trigger.TimeAfterCreate = &timeAfterCreate
	}

	// Set property "TimeBeforeExpiry":
	if typedInput.TimeBeforeExpiry != nil {
		timeBeforeExpiry := *typedInput.TimeBeforeExpiry
		trigger.TimeBeforeExpiry = &timeBeforeExpiry
	}

	// No error
	return nil
}

// AssignProperties_From_Trigger_STATUS populates our Trigger_STATUS from the provided source Trigger_STATUS
func (trigger *Trigger_STATUS) AssignProperties_From_Trigger_STATUS(source *storage.Trigger_STATUS) error {

	// TimeAfterCreate
	trigger.TimeAfterCreate = genruntime.ClonePointerToString(source.TimeAfterCreate)

	// TimeBeforeExpiry
	trigger.TimeBeforeExpiry = genruntime.ClonePointerToString(source.TimeBeforeExpiry)

	// No error
	return nil
}

// AssignProperties_To_Trigger_STATUS populates the provided destination Trigger_STATUS from our Trigger_STATUS
func (trigger *Trigger_STATUS) AssignProperties_To_Trigger_STATUS(destination *storage.Trigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TimeAfterCreate
	destination.TimeAfterCreate = genruntime.ClonePointerToString(trigger.TimeAfterCreate)

	// TimeBeforeExpiry
	destination.TimeBeforeExpiry = genruntime.ClonePointerToString(trigger.TimeBeforeExpiry)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Action struct {
	// Type: The type of action.
	Type *Action_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Action{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *Action) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.Action{}

	// Set property "Type":
	if action.Type != nil {
		var temp string
		temp = string(*action.Type)
		typeVar := arm.Action_Type(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *Action) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Action{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *Action) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Action)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Action, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Action_Type(temp)
		action.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Action populates our Action from the provided source Action
func (action *Action) AssignProperties_From_Action(source *storage.Action) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, action_Type_Values)
		action.Type = &typeTemp
	} else {
		action.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Action populates the provided destination Action from our Action
func (action *Action) AssignProperties_To_Action(destination *storage.Action) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if action.Type != nil {
		typeVar := string(*action.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Action_Type_STATUS string

const (
	Action_Type_STATUS_Notify = Action_Type_STATUS("notify")
	Action_Type_STATUS_Rotate = Action_Type_STATUS("rotate")
)

// Mapping from string to Action_Type_STATUS
var action_Type_STATUS_Values = map[string]Action_Type_STATUS{
	"notify": Action_Type_STATUS_Notify,
	"rotate": Action_Type_STATUS_Rotate,
}

type Trigger struct {
	// TimeAfterCreate: The time duration after key creation to rotate the key. It only applies to rotate. It will be in ISO
	// 8601 duration format. Eg: 'P90D', 'P1Y'.
	TimeAfterCreate *string `json:"timeAfterCreate,omitempty"`

	// TimeBeforeExpiry: The time duration before key expiring to rotate or notify. It will be in ISO 8601 duration format. Eg:
	// 'P90D', 'P1Y'.
	TimeBeforeExpiry *string `json:"timeBeforeExpiry,omitempty"`
}

var _ genruntime.ARMTransformer = &Trigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *Trigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &arm.Trigger{}

	// Set property "TimeAfterCreate":
	if trigger.TimeAfterCreate != nil {
		timeAfterCreate := *trigger.TimeAfterCreate
		result.TimeAfterCreate = &timeAfterCreate
	}

	// Set property "TimeBeforeExpiry":
	if trigger.TimeBeforeExpiry != nil {
		timeBeforeExpiry := *trigger.TimeBeforeExpiry
		result.TimeBeforeExpiry = &timeBeforeExpiry
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *Trigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Trigger{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *Trigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Trigger)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Trigger, got %T", armInput)
	}

	// Set property "TimeAfterCreate":
	if typedInput.TimeAfterCreate != nil {
		timeAfterCreate := *typedInput.TimeAfterCreate
		trigger.TimeAfterCreate = &timeAfterCreate
	}

	// Set property "TimeBeforeExpiry":
	if typedInput.TimeBeforeExpiry != nil {
		timeBeforeExpiry := *typedInput.TimeBeforeExpiry
		trigger.TimeBeforeExpiry = &timeBeforeExpiry
	}

	// No error
	return nil
}

// AssignProperties_From_Trigger populates our Trigger from the provided source Trigger
func (trigger *Trigger) AssignProperties_From_Trigger(source *storage.Trigger) error {

	// TimeAfterCreate
	trigger.TimeAfterCreate = genruntime.ClonePointerToString(source.TimeAfterCreate)

	// TimeBeforeExpiry
	trigger.TimeBeforeExpiry = genruntime.ClonePointerToString(source.TimeBeforeExpiry)

	// No error
	return nil
}

// AssignProperties_To_Trigger populates the provided destination Trigger from our Trigger
func (trigger *Trigger) AssignProperties_To_Trigger(destination *storage.Trigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TimeAfterCreate
	destination.TimeAfterCreate = genruntime.ClonePointerToString(trigger.TimeAfterCreate)

	// TimeBeforeExpiry
	destination.TimeBeforeExpiry = genruntime.ClonePointerToString(trigger.TimeBeforeExpiry)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"notify","rotate"}
type Action_Type string

const (
	Action_Type_Notify = Action_Type("notify")
	Action_Type_Rotate = Action_Type("rotate")
)

// Mapping from string to Action_Type
var action_Type_Values = map[string]Action_Type{
	"notify": Action_Type_Notify,
	"rotate": Action_Type_Rotate,
}

func init() {
	SchemeBuilder.Register(&VaultsKey{}, &VaultsKeyList{})
}
