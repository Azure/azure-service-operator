// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Action_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Action via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAction, ActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAction runs a test to see if a specific instance of Action round trips to JSON and back losslessly
func RunJSONSerializationTestForAction(subject Action) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Action
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Action instances for property testing - lazily instantiated by ActionGenerator()
var actionGenerator gopter.Gen

// ActionGenerator returns a generator of Action instances for property testing.
func ActionGenerator() gopter.Gen {
	if actionGenerator != nil {
		return actionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAction(generators)
	actionGenerator = gen.Struct(reflect.TypeOf(Action{}), generators)

	return actionGenerator
}

// AddIndependentPropertyGeneratorsForAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Action_Type_Notify, Action_Type_Rotate))
}

func Test_KeyAttributes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyAttributes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyAttributes, KeyAttributesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyAttributes runs a test to see if a specific instance of KeyAttributes round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyAttributes(subject KeyAttributes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyAttributes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyAttributes instances for property testing - lazily instantiated by KeyAttributesGenerator()
var keyAttributesGenerator gopter.Gen

// KeyAttributesGenerator returns a generator of KeyAttributes instances for property testing.
func KeyAttributesGenerator() gopter.Gen {
	if keyAttributesGenerator != nil {
		return keyAttributesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyAttributes(generators)
	keyAttributesGenerator = gen.Struct(reflect.TypeOf(KeyAttributes{}), generators)

	return keyAttributesGenerator
}

// AddIndependentPropertyGeneratorsForKeyAttributes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyAttributes(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Exp"] = gen.PtrOf(gen.Int())
	gens["Exportable"] = gen.PtrOf(gen.Bool())
	gens["Nbf"] = gen.PtrOf(gen.Int())
}

func Test_KeyProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyProperties, KeyPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyProperties runs a test to see if a specific instance of KeyProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyProperties(subject KeyProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyProperties instances for property testing - lazily instantiated by KeyPropertiesGenerator()
var keyPropertiesGenerator gopter.Gen

// KeyPropertiesGenerator returns a generator of KeyProperties instances for property testing.
// We first initialize keyPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyPropertiesGenerator() gopter.Gen {
	if keyPropertiesGenerator != nil {
		return keyPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyProperties(generators)
	keyPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyProperties(generators)
	AddRelatedPropertyGeneratorsForKeyProperties(generators)
	keyPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyProperties{}), generators)

	return keyPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForKeyProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyProperties(gens map[string]gopter.Gen) {
	gens["CurveName"] = gen.PtrOf(gen.OneConstOf(
		KeyProperties_CurveName_P256,
		KeyProperties_CurveName_P256K,
		KeyProperties_CurveName_P384,
		KeyProperties_CurveName_P521))
	gens["KeyOps"] = gen.SliceOf(gen.OneConstOf(
		KeyProperties_KeyOps_Decrypt,
		KeyProperties_KeyOps_Encrypt,
		KeyProperties_KeyOps_Import,
		KeyProperties_KeyOps_Release,
		KeyProperties_KeyOps_Sign,
		KeyProperties_KeyOps_UnwrapKey,
		KeyProperties_KeyOps_Verify,
		KeyProperties_KeyOps_WrapKey))
	gens["KeySize"] = gen.PtrOf(gen.Int())
	gens["Kty"] = gen.PtrOf(gen.OneConstOf(
		KeyProperties_Kty_EC,
		KeyProperties_Kty_ECHSM,
		KeyProperties_Kty_RSA,
		KeyProperties_Kty_RSAHSM))
}

// AddRelatedPropertyGeneratorsForKeyProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyProperties(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyAttributesGenerator())
	gens["Release_Policy"] = gen.PtrOf(KeyReleasePolicyGenerator())
	gens["RotationPolicy"] = gen.PtrOf(RotationPolicyGenerator())
}

func Test_KeyReleasePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyReleasePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyReleasePolicy, KeyReleasePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyReleasePolicy runs a test to see if a specific instance of KeyReleasePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyReleasePolicy(subject KeyReleasePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyReleasePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyReleasePolicy instances for property testing - lazily instantiated by KeyReleasePolicyGenerator()
var keyReleasePolicyGenerator gopter.Gen

// KeyReleasePolicyGenerator returns a generator of KeyReleasePolicy instances for property testing.
func KeyReleasePolicyGenerator() gopter.Gen {
	if keyReleasePolicyGenerator != nil {
		return keyReleasePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyReleasePolicy(generators)
	keyReleasePolicyGenerator = gen.Struct(reflect.TypeOf(KeyReleasePolicy{}), generators)

	return keyReleasePolicyGenerator
}

// AddIndependentPropertyGeneratorsForKeyReleasePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyReleasePolicy(gens map[string]gopter.Gen) {
	gens["ContentType"] = gen.PtrOf(gen.AlphaString())
	gens["Data"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyRotationPolicyAttributes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyRotationPolicyAttributes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyRotationPolicyAttributes, KeyRotationPolicyAttributesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyRotationPolicyAttributes runs a test to see if a specific instance of KeyRotationPolicyAttributes round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyRotationPolicyAttributes(subject KeyRotationPolicyAttributes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyRotationPolicyAttributes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyRotationPolicyAttributes instances for property testing - lazily instantiated by
// KeyRotationPolicyAttributesGenerator()
var keyRotationPolicyAttributesGenerator gopter.Gen

// KeyRotationPolicyAttributesGenerator returns a generator of KeyRotationPolicyAttributes instances for property testing.
func KeyRotationPolicyAttributesGenerator() gopter.Gen {
	if keyRotationPolicyAttributesGenerator != nil {
		return keyRotationPolicyAttributesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes(generators)
	keyRotationPolicyAttributesGenerator = gen.Struct(reflect.TypeOf(KeyRotationPolicyAttributes{}), generators)

	return keyRotationPolicyAttributesGenerator
}

// AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes(gens map[string]gopter.Gen) {
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_LifetimeAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LifetimeAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLifetimeAction, LifetimeActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLifetimeAction runs a test to see if a specific instance of LifetimeAction round trips to JSON and back losslessly
func RunJSONSerializationTestForLifetimeAction(subject LifetimeAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LifetimeAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LifetimeAction instances for property testing - lazily instantiated by LifetimeActionGenerator()
var lifetimeActionGenerator gopter.Gen

// LifetimeActionGenerator returns a generator of LifetimeAction instances for property testing.
func LifetimeActionGenerator() gopter.Gen {
	if lifetimeActionGenerator != nil {
		return lifetimeActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLifetimeAction(generators)
	lifetimeActionGenerator = gen.Struct(reflect.TypeOf(LifetimeAction{}), generators)

	return lifetimeActionGenerator
}

// AddRelatedPropertyGeneratorsForLifetimeAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLifetimeAction(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(ActionGenerator())
	gens["Trigger"] = gen.PtrOf(TriggerGenerator())
}

func Test_RotationPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RotationPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRotationPolicy, RotationPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRotationPolicy runs a test to see if a specific instance of RotationPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForRotationPolicy(subject RotationPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RotationPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RotationPolicy instances for property testing - lazily instantiated by RotationPolicyGenerator()
var rotationPolicyGenerator gopter.Gen

// RotationPolicyGenerator returns a generator of RotationPolicy instances for property testing.
func RotationPolicyGenerator() gopter.Gen {
	if rotationPolicyGenerator != nil {
		return rotationPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRotationPolicy(generators)
	rotationPolicyGenerator = gen.Struct(reflect.TypeOf(RotationPolicy{}), generators)

	return rotationPolicyGenerator
}

// AddRelatedPropertyGeneratorsForRotationPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRotationPolicy(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyRotationPolicyAttributesGenerator())
	gens["LifetimeActions"] = gen.SliceOf(LifetimeActionGenerator())
}

func Test_Trigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Trigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrigger, TriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrigger runs a test to see if a specific instance of Trigger round trips to JSON and back losslessly
func RunJSONSerializationTestForTrigger(subject Trigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Trigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Trigger instances for property testing - lazily instantiated by TriggerGenerator()
var triggerGenerator gopter.Gen

// TriggerGenerator returns a generator of Trigger instances for property testing.
func TriggerGenerator() gopter.Gen {
	if triggerGenerator != nil {
		return triggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrigger(generators)
	triggerGenerator = gen.Struct(reflect.TypeOf(Trigger{}), generators)

	return triggerGenerator
}

// AddIndependentPropertyGeneratorsForTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrigger(gens map[string]gopter.Gen) {
	gens["TimeAfterCreate"] = gen.PtrOf(gen.AlphaString())
	gens["TimeBeforeExpiry"] = gen.PtrOf(gen.AlphaString())
}

func Test_VaultsKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKey_Spec, VaultsKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKey_Spec runs a test to see if a specific instance of VaultsKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKey_Spec(subject VaultsKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKey_Spec instances for property testing - lazily instantiated by VaultsKey_SpecGenerator()
var vaultsKey_SpecGenerator gopter.Gen

// VaultsKey_SpecGenerator returns a generator of VaultsKey_Spec instances for property testing.
// We first initialize vaultsKey_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultsKey_SpecGenerator() gopter.Gen {
	if vaultsKey_SpecGenerator != nil {
		return vaultsKey_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_Spec(generators)
	vaultsKey_SpecGenerator = gen.Struct(reflect.TypeOf(VaultsKey_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_Spec(generators)
	AddRelatedPropertyGeneratorsForVaultsKey_Spec(generators)
	vaultsKey_SpecGenerator = gen.Struct(reflect.TypeOf(VaultsKey_Spec{}), generators)

	return vaultsKey_SpecGenerator
}

// AddIndependentPropertyGeneratorsForVaultsKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultsKey_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultsKey_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultsKey_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(KeyPropertiesGenerator())
}
