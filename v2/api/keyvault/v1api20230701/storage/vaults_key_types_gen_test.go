// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Action_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Action via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAction, ActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAction runs a test to see if a specific instance of Action round trips to JSON and back losslessly
func RunJSONSerializationTestForAction(subject Action) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Action
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Action instances for property testing - lazily instantiated by ActionGenerator()
var actionGenerator gopter.Gen

// ActionGenerator returns a generator of Action instances for property testing.
func ActionGenerator() gopter.Gen {
	if actionGenerator != nil {
		return actionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAction(generators)
	actionGenerator = gen.Struct(reflect.TypeOf(Action{}), generators)

	return actionGenerator
}

// AddIndependentPropertyGeneratorsForAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Action_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Action_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAction_STATUS, Action_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAction_STATUS runs a test to see if a specific instance of Action_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAction_STATUS(subject Action_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Action_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Action_STATUS instances for property testing - lazily instantiated by Action_STATUSGenerator()
var action_STATUSGenerator gopter.Gen

// Action_STATUSGenerator returns a generator of Action_STATUS instances for property testing.
func Action_STATUSGenerator() gopter.Gen {
	if action_STATUSGenerator != nil {
		return action_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAction_STATUS(generators)
	action_STATUSGenerator = gen.Struct(reflect.TypeOf(Action_STATUS{}), generators)

	return action_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAction_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyAttributes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyAttributes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyAttributes, KeyAttributesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyAttributes runs a test to see if a specific instance of KeyAttributes round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyAttributes(subject KeyAttributes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyAttributes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyAttributes instances for property testing - lazily instantiated by KeyAttributesGenerator()
var keyAttributesGenerator gopter.Gen

// KeyAttributesGenerator returns a generator of KeyAttributes instances for property testing.
func KeyAttributesGenerator() gopter.Gen {
	if keyAttributesGenerator != nil {
		return keyAttributesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyAttributes(generators)
	keyAttributesGenerator = gen.Struct(reflect.TypeOf(KeyAttributes{}), generators)

	return keyAttributesGenerator
}

// AddIndependentPropertyGeneratorsForKeyAttributes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyAttributes(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Exp"] = gen.PtrOf(gen.Int())
	gens["Exportable"] = gen.PtrOf(gen.Bool())
	gens["Nbf"] = gen.PtrOf(gen.Int())
}

func Test_KeyAttributes_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyAttributes_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyAttributes_STATUS, KeyAttributes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyAttributes_STATUS runs a test to see if a specific instance of KeyAttributes_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyAttributes_STATUS(subject KeyAttributes_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyAttributes_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyAttributes_STATUS instances for property testing - lazily instantiated by
// KeyAttributes_STATUSGenerator()
var keyAttributes_STATUSGenerator gopter.Gen

// KeyAttributes_STATUSGenerator returns a generator of KeyAttributes_STATUS instances for property testing.
func KeyAttributes_STATUSGenerator() gopter.Gen {
	if keyAttributes_STATUSGenerator != nil {
		return keyAttributes_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyAttributes_STATUS(generators)
	keyAttributes_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyAttributes_STATUS{}), generators)

	return keyAttributes_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyAttributes_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyAttributes_STATUS(gens map[string]gopter.Gen) {
	gens["Created"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Exp"] = gen.PtrOf(gen.Int())
	gens["Exportable"] = gen.PtrOf(gen.Bool())
	gens["Nbf"] = gen.PtrOf(gen.Int())
	gens["RecoveryLevel"] = gen.PtrOf(gen.AlphaString())
	gens["Updated"] = gen.PtrOf(gen.Int())
}

func Test_KeyProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyProperties, KeyPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyProperties runs a test to see if a specific instance of KeyProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyProperties(subject KeyProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyProperties instances for property testing - lazily instantiated by KeyPropertiesGenerator()
var keyPropertiesGenerator gopter.Gen

// KeyPropertiesGenerator returns a generator of KeyProperties instances for property testing.
// We first initialize keyPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyPropertiesGenerator() gopter.Gen {
	if keyPropertiesGenerator != nil {
		return keyPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyProperties(generators)
	keyPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyProperties(generators)
	AddRelatedPropertyGeneratorsForKeyProperties(generators)
	keyPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyProperties{}), generators)

	return keyPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForKeyProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyProperties(gens map[string]gopter.Gen) {
	gens["CurveName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyOps"] = gen.SliceOf(gen.AlphaString())
	gens["KeySize"] = gen.PtrOf(gen.Int())
	gens["Kty"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyProperties(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyAttributesGenerator())
	gens["Release_Policy"] = gen.PtrOf(KeyReleasePolicyGenerator())
	gens["RotationPolicy"] = gen.PtrOf(RotationPolicyGenerator())
}

func Test_KeyReleasePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyReleasePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyReleasePolicy, KeyReleasePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyReleasePolicy runs a test to see if a specific instance of KeyReleasePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyReleasePolicy(subject KeyReleasePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyReleasePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyReleasePolicy instances for property testing - lazily instantiated by KeyReleasePolicyGenerator()
var keyReleasePolicyGenerator gopter.Gen

// KeyReleasePolicyGenerator returns a generator of KeyReleasePolicy instances for property testing.
func KeyReleasePolicyGenerator() gopter.Gen {
	if keyReleasePolicyGenerator != nil {
		return keyReleasePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyReleasePolicy(generators)
	keyReleasePolicyGenerator = gen.Struct(reflect.TypeOf(KeyReleasePolicy{}), generators)

	return keyReleasePolicyGenerator
}

// AddIndependentPropertyGeneratorsForKeyReleasePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyReleasePolicy(gens map[string]gopter.Gen) {
	gens["ContentType"] = gen.PtrOf(gen.AlphaString())
	gens["Data"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyReleasePolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyReleasePolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyReleasePolicy_STATUS, KeyReleasePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyReleasePolicy_STATUS runs a test to see if a specific instance of KeyReleasePolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyReleasePolicy_STATUS(subject KeyReleasePolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyReleasePolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyReleasePolicy_STATUS instances for property testing - lazily instantiated by
// KeyReleasePolicy_STATUSGenerator()
var keyReleasePolicy_STATUSGenerator gopter.Gen

// KeyReleasePolicy_STATUSGenerator returns a generator of KeyReleasePolicy_STATUS instances for property testing.
func KeyReleasePolicy_STATUSGenerator() gopter.Gen {
	if keyReleasePolicy_STATUSGenerator != nil {
		return keyReleasePolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyReleasePolicy_STATUS(generators)
	keyReleasePolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyReleasePolicy_STATUS{}), generators)

	return keyReleasePolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyReleasePolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyReleasePolicy_STATUS(gens map[string]gopter.Gen) {
	gens["ContentType"] = gen.PtrOf(gen.AlphaString())
	gens["Data"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyRotationPolicyAttributes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyRotationPolicyAttributes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyRotationPolicyAttributes, KeyRotationPolicyAttributesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyRotationPolicyAttributes runs a test to see if a specific instance of KeyRotationPolicyAttributes round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyRotationPolicyAttributes(subject KeyRotationPolicyAttributes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyRotationPolicyAttributes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyRotationPolicyAttributes instances for property testing - lazily instantiated by
// KeyRotationPolicyAttributesGenerator()
var keyRotationPolicyAttributesGenerator gopter.Gen

// KeyRotationPolicyAttributesGenerator returns a generator of KeyRotationPolicyAttributes instances for property testing.
func KeyRotationPolicyAttributesGenerator() gopter.Gen {
	if keyRotationPolicyAttributesGenerator != nil {
		return keyRotationPolicyAttributesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes(generators)
	keyRotationPolicyAttributesGenerator = gen.Struct(reflect.TypeOf(KeyRotationPolicyAttributes{}), generators)

	return keyRotationPolicyAttributesGenerator
}

// AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes(gens map[string]gopter.Gen) {
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyRotationPolicyAttributes_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyRotationPolicyAttributes_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyRotationPolicyAttributes_STATUS, KeyRotationPolicyAttributes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyRotationPolicyAttributes_STATUS runs a test to see if a specific instance of KeyRotationPolicyAttributes_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyRotationPolicyAttributes_STATUS(subject KeyRotationPolicyAttributes_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyRotationPolicyAttributes_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyRotationPolicyAttributes_STATUS instances for property testing - lazily instantiated by
// KeyRotationPolicyAttributes_STATUSGenerator()
var keyRotationPolicyAttributes_STATUSGenerator gopter.Gen

// KeyRotationPolicyAttributes_STATUSGenerator returns a generator of KeyRotationPolicyAttributes_STATUS instances for property testing.
func KeyRotationPolicyAttributes_STATUSGenerator() gopter.Gen {
	if keyRotationPolicyAttributes_STATUSGenerator != nil {
		return keyRotationPolicyAttributes_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes_STATUS(generators)
	keyRotationPolicyAttributes_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyRotationPolicyAttributes_STATUS{}), generators)

	return keyRotationPolicyAttributes_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes_STATUS(gens map[string]gopter.Gen) {
	gens["Created"] = gen.PtrOf(gen.Int())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Updated"] = gen.PtrOf(gen.Int())
}

func Test_LifetimeAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LifetimeAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLifetimeAction, LifetimeActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLifetimeAction runs a test to see if a specific instance of LifetimeAction round trips to JSON and back losslessly
func RunJSONSerializationTestForLifetimeAction(subject LifetimeAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LifetimeAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LifetimeAction instances for property testing - lazily instantiated by LifetimeActionGenerator()
var lifetimeActionGenerator gopter.Gen

// LifetimeActionGenerator returns a generator of LifetimeAction instances for property testing.
func LifetimeActionGenerator() gopter.Gen {
	if lifetimeActionGenerator != nil {
		return lifetimeActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLifetimeAction(generators)
	lifetimeActionGenerator = gen.Struct(reflect.TypeOf(LifetimeAction{}), generators)

	return lifetimeActionGenerator
}

// AddRelatedPropertyGeneratorsForLifetimeAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLifetimeAction(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(ActionGenerator())
	gens["Trigger"] = gen.PtrOf(TriggerGenerator())
}

func Test_LifetimeAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LifetimeAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLifetimeAction_STATUS, LifetimeAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLifetimeAction_STATUS runs a test to see if a specific instance of LifetimeAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLifetimeAction_STATUS(subject LifetimeAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LifetimeAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LifetimeAction_STATUS instances for property testing - lazily instantiated by
// LifetimeAction_STATUSGenerator()
var lifetimeAction_STATUSGenerator gopter.Gen

// LifetimeAction_STATUSGenerator returns a generator of LifetimeAction_STATUS instances for property testing.
func LifetimeAction_STATUSGenerator() gopter.Gen {
	if lifetimeAction_STATUSGenerator != nil {
		return lifetimeAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLifetimeAction_STATUS(generators)
	lifetimeAction_STATUSGenerator = gen.Struct(reflect.TypeOf(LifetimeAction_STATUS{}), generators)

	return lifetimeAction_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForLifetimeAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLifetimeAction_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(Action_STATUSGenerator())
	gens["Trigger"] = gen.PtrOf(Trigger_STATUSGenerator())
}

func Test_RotationPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RotationPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRotationPolicy, RotationPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRotationPolicy runs a test to see if a specific instance of RotationPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForRotationPolicy(subject RotationPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RotationPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RotationPolicy instances for property testing - lazily instantiated by RotationPolicyGenerator()
var rotationPolicyGenerator gopter.Gen

// RotationPolicyGenerator returns a generator of RotationPolicy instances for property testing.
func RotationPolicyGenerator() gopter.Gen {
	if rotationPolicyGenerator != nil {
		return rotationPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRotationPolicy(generators)
	rotationPolicyGenerator = gen.Struct(reflect.TypeOf(RotationPolicy{}), generators)

	return rotationPolicyGenerator
}

// AddRelatedPropertyGeneratorsForRotationPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRotationPolicy(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyRotationPolicyAttributesGenerator())
	gens["LifetimeActions"] = gen.SliceOf(LifetimeActionGenerator())
}

func Test_RotationPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RotationPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRotationPolicy_STATUS, RotationPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRotationPolicy_STATUS runs a test to see if a specific instance of RotationPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRotationPolicy_STATUS(subject RotationPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RotationPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RotationPolicy_STATUS instances for property testing - lazily instantiated by
// RotationPolicy_STATUSGenerator()
var rotationPolicy_STATUSGenerator gopter.Gen

// RotationPolicy_STATUSGenerator returns a generator of RotationPolicy_STATUS instances for property testing.
func RotationPolicy_STATUSGenerator() gopter.Gen {
	if rotationPolicy_STATUSGenerator != nil {
		return rotationPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRotationPolicy_STATUS(generators)
	rotationPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(RotationPolicy_STATUS{}), generators)

	return rotationPolicy_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRotationPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRotationPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyRotationPolicyAttributes_STATUSGenerator())
	gens["LifetimeActions"] = gen.SliceOf(LifetimeAction_STATUSGenerator())
}

func Test_Trigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Trigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrigger, TriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrigger runs a test to see if a specific instance of Trigger round trips to JSON and back losslessly
func RunJSONSerializationTestForTrigger(subject Trigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Trigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Trigger instances for property testing - lazily instantiated by TriggerGenerator()
var triggerGenerator gopter.Gen

// TriggerGenerator returns a generator of Trigger instances for property testing.
func TriggerGenerator() gopter.Gen {
	if triggerGenerator != nil {
		return triggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrigger(generators)
	triggerGenerator = gen.Struct(reflect.TypeOf(Trigger{}), generators)

	return triggerGenerator
}

// AddIndependentPropertyGeneratorsForTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrigger(gens map[string]gopter.Gen) {
	gens["TimeAfterCreate"] = gen.PtrOf(gen.AlphaString())
	gens["TimeBeforeExpiry"] = gen.PtrOf(gen.AlphaString())
}

func Test_Trigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Trigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrigger_STATUS, Trigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrigger_STATUS runs a test to see if a specific instance of Trigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTrigger_STATUS(subject Trigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Trigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Trigger_STATUS instances for property testing - lazily instantiated by Trigger_STATUSGenerator()
var trigger_STATUSGenerator gopter.Gen

// Trigger_STATUSGenerator returns a generator of Trigger_STATUS instances for property testing.
func Trigger_STATUSGenerator() gopter.Gen {
	if trigger_STATUSGenerator != nil {
		return trigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrigger_STATUS(generators)
	trigger_STATUSGenerator = gen.Struct(reflect.TypeOf(Trigger_STATUS{}), generators)

	return trigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["TimeAfterCreate"] = gen.PtrOf(gen.AlphaString())
	gens["TimeBeforeExpiry"] = gen.PtrOf(gen.AlphaString())
}

func Test_VaultsKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKey, VaultsKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKey runs a test to see if a specific instance of VaultsKey round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKey(subject VaultsKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKey instances for property testing - lazily instantiated by VaultsKeyGenerator()
var vaultsKeyGenerator gopter.Gen

// VaultsKeyGenerator returns a generator of VaultsKey instances for property testing.
func VaultsKeyGenerator() gopter.Gen {
	if vaultsKeyGenerator != nil {
		return vaultsKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultsKey(generators)
	vaultsKeyGenerator = gen.Struct(reflect.TypeOf(VaultsKey{}), generators)

	return vaultsKeyGenerator
}

// AddRelatedPropertyGeneratorsForVaultsKey is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultsKey(gens map[string]gopter.Gen) {
	gens["Spec"] = VaultsKey_SpecGenerator()
	gens["Status"] = VaultsKey_STATUSGenerator()
}

func Test_VaultsKeyOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKeyOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKeyOperatorSpec, VaultsKeyOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKeyOperatorSpec runs a test to see if a specific instance of VaultsKeyOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKeyOperatorSpec(subject VaultsKeyOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKeyOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKeyOperatorSpec instances for property testing - lazily instantiated by
// VaultsKeyOperatorSpecGenerator()
var vaultsKeyOperatorSpecGenerator gopter.Gen

// VaultsKeyOperatorSpecGenerator returns a generator of VaultsKeyOperatorSpec instances for property testing.
func VaultsKeyOperatorSpecGenerator() gopter.Gen {
	if vaultsKeyOperatorSpecGenerator != nil {
		return vaultsKeyOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	vaultsKeyOperatorSpecGenerator = gen.Struct(reflect.TypeOf(VaultsKeyOperatorSpec{}), generators)

	return vaultsKeyOperatorSpecGenerator
}

func Test_VaultsKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKey_STATUS, VaultsKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKey_STATUS runs a test to see if a specific instance of VaultsKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKey_STATUS(subject VaultsKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKey_STATUS instances for property testing - lazily instantiated by VaultsKey_STATUSGenerator()
var vaultsKey_STATUSGenerator gopter.Gen

// VaultsKey_STATUSGenerator returns a generator of VaultsKey_STATUS instances for property testing.
// We first initialize vaultsKey_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultsKey_STATUSGenerator() gopter.Gen {
	if vaultsKey_STATUSGenerator != nil {
		return vaultsKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_STATUS(generators)
	vaultsKey_STATUSGenerator = gen.Struct(reflect.TypeOf(VaultsKey_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_STATUS(generators)
	AddRelatedPropertyGeneratorsForVaultsKey_STATUS(generators)
	vaultsKey_STATUSGenerator = gen.Struct(reflect.TypeOf(VaultsKey_STATUS{}), generators)

	return vaultsKey_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVaultsKey_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultsKey_STATUS(gens map[string]gopter.Gen) {
	gens["CurveName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["KeyOps"] = gen.SliceOf(gen.AlphaString())
	gens["KeySize"] = gen.PtrOf(gen.Int())
	gens["KeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["KeyUriWithVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Kty"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultsKey_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultsKey_STATUS(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyAttributes_STATUSGenerator())
	gens["Release_Policy"] = gen.PtrOf(KeyReleasePolicy_STATUSGenerator())
	gens["RotationPolicy"] = gen.PtrOf(RotationPolicy_STATUSGenerator())
}

func Test_VaultsKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKey_Spec, VaultsKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKey_Spec runs a test to see if a specific instance of VaultsKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKey_Spec(subject VaultsKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKey_Spec instances for property testing - lazily instantiated by VaultsKey_SpecGenerator()
var vaultsKey_SpecGenerator gopter.Gen

// VaultsKey_SpecGenerator returns a generator of VaultsKey_Spec instances for property testing.
// We first initialize vaultsKey_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultsKey_SpecGenerator() gopter.Gen {
	if vaultsKey_SpecGenerator != nil {
		return vaultsKey_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_Spec(generators)
	vaultsKey_SpecGenerator = gen.Struct(reflect.TypeOf(VaultsKey_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_Spec(generators)
	AddRelatedPropertyGeneratorsForVaultsKey_Spec(generators)
	vaultsKey_SpecGenerator = gen.Struct(reflect.TypeOf(VaultsKey_Spec{}), generators)

	return vaultsKey_SpecGenerator
}

// AddIndependentPropertyGeneratorsForVaultsKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultsKey_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultsKey_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultsKey_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(VaultsKeyOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(KeyPropertiesGenerator())
}
