// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230701

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/keyvault/v1api20230701/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Action_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Action to Action via AssignProperties_To_Action & AssignProperties_From_Action returns original",
		prop.ForAll(RunPropertyAssignmentTestForAction, ActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAction tests if a specific instance of Action can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAction(subject Action) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Action
	err := copied.AssignProperties_To_Action(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Action
	err = actual.AssignProperties_From_Action(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Action_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Action via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAction, ActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAction runs a test to see if a specific instance of Action round trips to JSON and back losslessly
func RunJSONSerializationTestForAction(subject Action) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Action
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Action instances for property testing - lazily instantiated by ActionGenerator()
var actionGenerator gopter.Gen

// ActionGenerator returns a generator of Action instances for property testing.
func ActionGenerator() gopter.Gen {
	if actionGenerator != nil {
		return actionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAction(generators)
	actionGenerator = gen.Struct(reflect.TypeOf(Action{}), generators)

	return actionGenerator
}

// AddIndependentPropertyGeneratorsForAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Action_Type_Notify, Action_Type_Rotate))
}

func Test_Action_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Action_STATUS to Action_STATUS via AssignProperties_To_Action_STATUS & AssignProperties_From_Action_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAction_STATUS, Action_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAction_STATUS tests if a specific instance of Action_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAction_STATUS(subject Action_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Action_STATUS
	err := copied.AssignProperties_To_Action_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Action_STATUS
	err = actual.AssignProperties_From_Action_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Action_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Action_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAction_STATUS, Action_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAction_STATUS runs a test to see if a specific instance of Action_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAction_STATUS(subject Action_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Action_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Action_STATUS instances for property testing - lazily instantiated by Action_STATUSGenerator()
var action_STATUSGenerator gopter.Gen

// Action_STATUSGenerator returns a generator of Action_STATUS instances for property testing.
func Action_STATUSGenerator() gopter.Gen {
	if action_STATUSGenerator != nil {
		return action_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAction_STATUS(generators)
	action_STATUSGenerator = gen.Struct(reflect.TypeOf(Action_STATUS{}), generators)

	return action_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAction_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Action_Type_STATUS_Notify, Action_Type_STATUS_Rotate))
}

func Test_KeyAttributes_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyAttributes to KeyAttributes via AssignProperties_To_KeyAttributes & AssignProperties_From_KeyAttributes returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyAttributes, KeyAttributesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyAttributes tests if a specific instance of KeyAttributes can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKeyAttributes(subject KeyAttributes) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KeyAttributes
	err := copied.AssignProperties_To_KeyAttributes(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyAttributes
	err = actual.AssignProperties_From_KeyAttributes(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyAttributes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyAttributes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyAttributes, KeyAttributesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyAttributes runs a test to see if a specific instance of KeyAttributes round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyAttributes(subject KeyAttributes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyAttributes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyAttributes instances for property testing - lazily instantiated by KeyAttributesGenerator()
var keyAttributesGenerator gopter.Gen

// KeyAttributesGenerator returns a generator of KeyAttributes instances for property testing.
func KeyAttributesGenerator() gopter.Gen {
	if keyAttributesGenerator != nil {
		return keyAttributesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyAttributes(generators)
	keyAttributesGenerator = gen.Struct(reflect.TypeOf(KeyAttributes{}), generators)

	return keyAttributesGenerator
}

// AddIndependentPropertyGeneratorsForKeyAttributes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyAttributes(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Exp"] = gen.PtrOf(gen.Int())
	gens["Exportable"] = gen.PtrOf(gen.Bool())
	gens["Nbf"] = gen.PtrOf(gen.Int())
}

func Test_KeyAttributes_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyAttributes_STATUS to KeyAttributes_STATUS via AssignProperties_To_KeyAttributes_STATUS & AssignProperties_From_KeyAttributes_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyAttributes_STATUS, KeyAttributes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyAttributes_STATUS tests if a specific instance of KeyAttributes_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKeyAttributes_STATUS(subject KeyAttributes_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KeyAttributes_STATUS
	err := copied.AssignProperties_To_KeyAttributes_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyAttributes_STATUS
	err = actual.AssignProperties_From_KeyAttributes_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyAttributes_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyAttributes_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyAttributes_STATUS, KeyAttributes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyAttributes_STATUS runs a test to see if a specific instance of KeyAttributes_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyAttributes_STATUS(subject KeyAttributes_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyAttributes_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyAttributes_STATUS instances for property testing - lazily instantiated by
// KeyAttributes_STATUSGenerator()
var keyAttributes_STATUSGenerator gopter.Gen

// KeyAttributes_STATUSGenerator returns a generator of KeyAttributes_STATUS instances for property testing.
func KeyAttributes_STATUSGenerator() gopter.Gen {
	if keyAttributes_STATUSGenerator != nil {
		return keyAttributes_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyAttributes_STATUS(generators)
	keyAttributes_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyAttributes_STATUS{}), generators)

	return keyAttributes_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyAttributes_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyAttributes_STATUS(gens map[string]gopter.Gen) {
	gens["Created"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Exp"] = gen.PtrOf(gen.Int())
	gens["Exportable"] = gen.PtrOf(gen.Bool())
	gens["Nbf"] = gen.PtrOf(gen.Int())
	gens["RecoveryLevel"] = gen.PtrOf(gen.OneConstOf(
		KeyAttributes_RecoveryLevel_STATUS_Purgeable,
		KeyAttributes_RecoveryLevel_STATUS_Recoverable,
		KeyAttributes_RecoveryLevel_STATUS_RecoverableProtectedSubscription,
		KeyAttributes_RecoveryLevel_STATUS_RecoverablePurgeable))
	gens["Updated"] = gen.PtrOf(gen.Int())
}

func Test_KeyProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyProperties to KeyProperties via AssignProperties_To_KeyProperties & AssignProperties_From_KeyProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyProperties, KeyPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyProperties tests if a specific instance of KeyProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKeyProperties(subject KeyProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KeyProperties
	err := copied.AssignProperties_To_KeyProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyProperties
	err = actual.AssignProperties_From_KeyProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyProperties, KeyPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyProperties runs a test to see if a specific instance of KeyProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyProperties(subject KeyProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyProperties instances for property testing - lazily instantiated by KeyPropertiesGenerator()
var keyPropertiesGenerator gopter.Gen

// KeyPropertiesGenerator returns a generator of KeyProperties instances for property testing.
// We first initialize keyPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyPropertiesGenerator() gopter.Gen {
	if keyPropertiesGenerator != nil {
		return keyPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyProperties(generators)
	keyPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyProperties(generators)
	AddRelatedPropertyGeneratorsForKeyProperties(generators)
	keyPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyProperties{}), generators)

	return keyPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForKeyProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyProperties(gens map[string]gopter.Gen) {
	gens["CurveName"] = gen.PtrOf(gen.OneConstOf(
		KeyProperties_CurveName_P256,
		KeyProperties_CurveName_P256K,
		KeyProperties_CurveName_P384,
		KeyProperties_CurveName_P521))
	gens["KeyOps"] = gen.SliceOf(gen.OneConstOf(
		KeyProperties_KeyOps_Decrypt,
		KeyProperties_KeyOps_Encrypt,
		KeyProperties_KeyOps_Import,
		KeyProperties_KeyOps_Release,
		KeyProperties_KeyOps_Sign,
		KeyProperties_KeyOps_UnwrapKey,
		KeyProperties_KeyOps_Verify,
		KeyProperties_KeyOps_WrapKey))
	gens["KeySize"] = gen.PtrOf(gen.Int())
	gens["Kty"] = gen.PtrOf(gen.OneConstOf(
		KeyProperties_Kty_EC,
		KeyProperties_Kty_ECHSM,
		KeyProperties_Kty_RSA,
		KeyProperties_Kty_RSAHSM))
}

// AddRelatedPropertyGeneratorsForKeyProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyProperties(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyAttributesGenerator())
	gens["Release_Policy"] = gen.PtrOf(KeyReleasePolicyGenerator())
	gens["RotationPolicy"] = gen.PtrOf(RotationPolicyGenerator())
}

func Test_KeyReleasePolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyReleasePolicy to KeyReleasePolicy via AssignProperties_To_KeyReleasePolicy & AssignProperties_From_KeyReleasePolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyReleasePolicy, KeyReleasePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyReleasePolicy tests if a specific instance of KeyReleasePolicy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKeyReleasePolicy(subject KeyReleasePolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KeyReleasePolicy
	err := copied.AssignProperties_To_KeyReleasePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyReleasePolicy
	err = actual.AssignProperties_From_KeyReleasePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyReleasePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyReleasePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyReleasePolicy, KeyReleasePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyReleasePolicy runs a test to see if a specific instance of KeyReleasePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyReleasePolicy(subject KeyReleasePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyReleasePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyReleasePolicy instances for property testing - lazily instantiated by KeyReleasePolicyGenerator()
var keyReleasePolicyGenerator gopter.Gen

// KeyReleasePolicyGenerator returns a generator of KeyReleasePolicy instances for property testing.
func KeyReleasePolicyGenerator() gopter.Gen {
	if keyReleasePolicyGenerator != nil {
		return keyReleasePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyReleasePolicy(generators)
	keyReleasePolicyGenerator = gen.Struct(reflect.TypeOf(KeyReleasePolicy{}), generators)

	return keyReleasePolicyGenerator
}

// AddIndependentPropertyGeneratorsForKeyReleasePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyReleasePolicy(gens map[string]gopter.Gen) {
	gens["ContentType"] = gen.PtrOf(gen.AlphaString())
	gens["Data"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyReleasePolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyReleasePolicy_STATUS to KeyReleasePolicy_STATUS via AssignProperties_To_KeyReleasePolicy_STATUS & AssignProperties_From_KeyReleasePolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyReleasePolicy_STATUS, KeyReleasePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyReleasePolicy_STATUS tests if a specific instance of KeyReleasePolicy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKeyReleasePolicy_STATUS(subject KeyReleasePolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KeyReleasePolicy_STATUS
	err := copied.AssignProperties_To_KeyReleasePolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyReleasePolicy_STATUS
	err = actual.AssignProperties_From_KeyReleasePolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyReleasePolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyReleasePolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyReleasePolicy_STATUS, KeyReleasePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyReleasePolicy_STATUS runs a test to see if a specific instance of KeyReleasePolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyReleasePolicy_STATUS(subject KeyReleasePolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyReleasePolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyReleasePolicy_STATUS instances for property testing - lazily instantiated by
// KeyReleasePolicy_STATUSGenerator()
var keyReleasePolicy_STATUSGenerator gopter.Gen

// KeyReleasePolicy_STATUSGenerator returns a generator of KeyReleasePolicy_STATUS instances for property testing.
func KeyReleasePolicy_STATUSGenerator() gopter.Gen {
	if keyReleasePolicy_STATUSGenerator != nil {
		return keyReleasePolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyReleasePolicy_STATUS(generators)
	keyReleasePolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyReleasePolicy_STATUS{}), generators)

	return keyReleasePolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyReleasePolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyReleasePolicy_STATUS(gens map[string]gopter.Gen) {
	gens["ContentType"] = gen.PtrOf(gen.AlphaString())
	gens["Data"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyRotationPolicyAttributes_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyRotationPolicyAttributes to KeyRotationPolicyAttributes via AssignProperties_To_KeyRotationPolicyAttributes & AssignProperties_From_KeyRotationPolicyAttributes returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyRotationPolicyAttributes, KeyRotationPolicyAttributesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyRotationPolicyAttributes tests if a specific instance of KeyRotationPolicyAttributes can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKeyRotationPolicyAttributes(subject KeyRotationPolicyAttributes) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KeyRotationPolicyAttributes
	err := copied.AssignProperties_To_KeyRotationPolicyAttributes(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyRotationPolicyAttributes
	err = actual.AssignProperties_From_KeyRotationPolicyAttributes(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyRotationPolicyAttributes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyRotationPolicyAttributes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyRotationPolicyAttributes, KeyRotationPolicyAttributesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyRotationPolicyAttributes runs a test to see if a specific instance of KeyRotationPolicyAttributes round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyRotationPolicyAttributes(subject KeyRotationPolicyAttributes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyRotationPolicyAttributes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyRotationPolicyAttributes instances for property testing - lazily instantiated by
// KeyRotationPolicyAttributesGenerator()
var keyRotationPolicyAttributesGenerator gopter.Gen

// KeyRotationPolicyAttributesGenerator returns a generator of KeyRotationPolicyAttributes instances for property testing.
func KeyRotationPolicyAttributesGenerator() gopter.Gen {
	if keyRotationPolicyAttributesGenerator != nil {
		return keyRotationPolicyAttributesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes(generators)
	keyRotationPolicyAttributesGenerator = gen.Struct(reflect.TypeOf(KeyRotationPolicyAttributes{}), generators)

	return keyRotationPolicyAttributesGenerator
}

// AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes(gens map[string]gopter.Gen) {
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyRotationPolicyAttributes_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyRotationPolicyAttributes_STATUS to KeyRotationPolicyAttributes_STATUS via AssignProperties_To_KeyRotationPolicyAttributes_STATUS & AssignProperties_From_KeyRotationPolicyAttributes_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyRotationPolicyAttributes_STATUS, KeyRotationPolicyAttributes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyRotationPolicyAttributes_STATUS tests if a specific instance of KeyRotationPolicyAttributes_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKeyRotationPolicyAttributes_STATUS(subject KeyRotationPolicyAttributes_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KeyRotationPolicyAttributes_STATUS
	err := copied.AssignProperties_To_KeyRotationPolicyAttributes_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyRotationPolicyAttributes_STATUS
	err = actual.AssignProperties_From_KeyRotationPolicyAttributes_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyRotationPolicyAttributes_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyRotationPolicyAttributes_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyRotationPolicyAttributes_STATUS, KeyRotationPolicyAttributes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyRotationPolicyAttributes_STATUS runs a test to see if a specific instance of KeyRotationPolicyAttributes_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyRotationPolicyAttributes_STATUS(subject KeyRotationPolicyAttributes_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyRotationPolicyAttributes_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyRotationPolicyAttributes_STATUS instances for property testing - lazily instantiated by
// KeyRotationPolicyAttributes_STATUSGenerator()
var keyRotationPolicyAttributes_STATUSGenerator gopter.Gen

// KeyRotationPolicyAttributes_STATUSGenerator returns a generator of KeyRotationPolicyAttributes_STATUS instances for property testing.
func KeyRotationPolicyAttributes_STATUSGenerator() gopter.Gen {
	if keyRotationPolicyAttributes_STATUSGenerator != nil {
		return keyRotationPolicyAttributes_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes_STATUS(generators)
	keyRotationPolicyAttributes_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyRotationPolicyAttributes_STATUS{}), generators)

	return keyRotationPolicyAttributes_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyRotationPolicyAttributes_STATUS(gens map[string]gopter.Gen) {
	gens["Created"] = gen.PtrOf(gen.Int())
	gens["ExpiryTime"] = gen.PtrOf(gen.AlphaString())
	gens["Updated"] = gen.PtrOf(gen.Int())
}

func Test_LifetimeAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LifetimeAction to LifetimeAction via AssignProperties_To_LifetimeAction & AssignProperties_From_LifetimeAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForLifetimeAction, LifetimeActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLifetimeAction tests if a specific instance of LifetimeAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLifetimeAction(subject LifetimeAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LifetimeAction
	err := copied.AssignProperties_To_LifetimeAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LifetimeAction
	err = actual.AssignProperties_From_LifetimeAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LifetimeAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LifetimeAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLifetimeAction, LifetimeActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLifetimeAction runs a test to see if a specific instance of LifetimeAction round trips to JSON and back losslessly
func RunJSONSerializationTestForLifetimeAction(subject LifetimeAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LifetimeAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LifetimeAction instances for property testing - lazily instantiated by LifetimeActionGenerator()
var lifetimeActionGenerator gopter.Gen

// LifetimeActionGenerator returns a generator of LifetimeAction instances for property testing.
func LifetimeActionGenerator() gopter.Gen {
	if lifetimeActionGenerator != nil {
		return lifetimeActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLifetimeAction(generators)
	lifetimeActionGenerator = gen.Struct(reflect.TypeOf(LifetimeAction{}), generators)

	return lifetimeActionGenerator
}

// AddRelatedPropertyGeneratorsForLifetimeAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLifetimeAction(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(ActionGenerator())
	gens["Trigger"] = gen.PtrOf(TriggerGenerator())
}

func Test_LifetimeAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LifetimeAction_STATUS to LifetimeAction_STATUS via AssignProperties_To_LifetimeAction_STATUS & AssignProperties_From_LifetimeAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLifetimeAction_STATUS, LifetimeAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLifetimeAction_STATUS tests if a specific instance of LifetimeAction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLifetimeAction_STATUS(subject LifetimeAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LifetimeAction_STATUS
	err := copied.AssignProperties_To_LifetimeAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LifetimeAction_STATUS
	err = actual.AssignProperties_From_LifetimeAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LifetimeAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LifetimeAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLifetimeAction_STATUS, LifetimeAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLifetimeAction_STATUS runs a test to see if a specific instance of LifetimeAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLifetimeAction_STATUS(subject LifetimeAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LifetimeAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LifetimeAction_STATUS instances for property testing - lazily instantiated by
// LifetimeAction_STATUSGenerator()
var lifetimeAction_STATUSGenerator gopter.Gen

// LifetimeAction_STATUSGenerator returns a generator of LifetimeAction_STATUS instances for property testing.
func LifetimeAction_STATUSGenerator() gopter.Gen {
	if lifetimeAction_STATUSGenerator != nil {
		return lifetimeAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLifetimeAction_STATUS(generators)
	lifetimeAction_STATUSGenerator = gen.Struct(reflect.TypeOf(LifetimeAction_STATUS{}), generators)

	return lifetimeAction_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForLifetimeAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLifetimeAction_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(Action_STATUSGenerator())
	gens["Trigger"] = gen.PtrOf(Trigger_STATUSGenerator())
}

func Test_RotationPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RotationPolicy to RotationPolicy via AssignProperties_To_RotationPolicy & AssignProperties_From_RotationPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForRotationPolicy, RotationPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRotationPolicy tests if a specific instance of RotationPolicy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRotationPolicy(subject RotationPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RotationPolicy
	err := copied.AssignProperties_To_RotationPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RotationPolicy
	err = actual.AssignProperties_From_RotationPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RotationPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RotationPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRotationPolicy, RotationPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRotationPolicy runs a test to see if a specific instance of RotationPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForRotationPolicy(subject RotationPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RotationPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RotationPolicy instances for property testing - lazily instantiated by RotationPolicyGenerator()
var rotationPolicyGenerator gopter.Gen

// RotationPolicyGenerator returns a generator of RotationPolicy instances for property testing.
func RotationPolicyGenerator() gopter.Gen {
	if rotationPolicyGenerator != nil {
		return rotationPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRotationPolicy(generators)
	rotationPolicyGenerator = gen.Struct(reflect.TypeOf(RotationPolicy{}), generators)

	return rotationPolicyGenerator
}

// AddRelatedPropertyGeneratorsForRotationPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRotationPolicy(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyRotationPolicyAttributesGenerator())
	gens["LifetimeActions"] = gen.SliceOf(LifetimeActionGenerator())
}

func Test_RotationPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RotationPolicy_STATUS to RotationPolicy_STATUS via AssignProperties_To_RotationPolicy_STATUS & AssignProperties_From_RotationPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRotationPolicy_STATUS, RotationPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRotationPolicy_STATUS tests if a specific instance of RotationPolicy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRotationPolicy_STATUS(subject RotationPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RotationPolicy_STATUS
	err := copied.AssignProperties_To_RotationPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RotationPolicy_STATUS
	err = actual.AssignProperties_From_RotationPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RotationPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RotationPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRotationPolicy_STATUS, RotationPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRotationPolicy_STATUS runs a test to see if a specific instance of RotationPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRotationPolicy_STATUS(subject RotationPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RotationPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RotationPolicy_STATUS instances for property testing - lazily instantiated by
// RotationPolicy_STATUSGenerator()
var rotationPolicy_STATUSGenerator gopter.Gen

// RotationPolicy_STATUSGenerator returns a generator of RotationPolicy_STATUS instances for property testing.
func RotationPolicy_STATUSGenerator() gopter.Gen {
	if rotationPolicy_STATUSGenerator != nil {
		return rotationPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRotationPolicy_STATUS(generators)
	rotationPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(RotationPolicy_STATUS{}), generators)

	return rotationPolicy_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRotationPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRotationPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyRotationPolicyAttributes_STATUSGenerator())
	gens["LifetimeActions"] = gen.SliceOf(LifetimeAction_STATUSGenerator())
}

func Test_Trigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Trigger to Trigger via AssignProperties_To_Trigger & AssignProperties_From_Trigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForTrigger, TriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTrigger tests if a specific instance of Trigger can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTrigger(subject Trigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Trigger
	err := copied.AssignProperties_To_Trigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Trigger
	err = actual.AssignProperties_From_Trigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Trigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Trigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrigger, TriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrigger runs a test to see if a specific instance of Trigger round trips to JSON and back losslessly
func RunJSONSerializationTestForTrigger(subject Trigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Trigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Trigger instances for property testing - lazily instantiated by TriggerGenerator()
var triggerGenerator gopter.Gen

// TriggerGenerator returns a generator of Trigger instances for property testing.
func TriggerGenerator() gopter.Gen {
	if triggerGenerator != nil {
		return triggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrigger(generators)
	triggerGenerator = gen.Struct(reflect.TypeOf(Trigger{}), generators)

	return triggerGenerator
}

// AddIndependentPropertyGeneratorsForTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrigger(gens map[string]gopter.Gen) {
	gens["TimeAfterCreate"] = gen.PtrOf(gen.AlphaString())
	gens["TimeBeforeExpiry"] = gen.PtrOf(gen.AlphaString())
}

func Test_Trigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Trigger_STATUS to Trigger_STATUS via AssignProperties_To_Trigger_STATUS & AssignProperties_From_Trigger_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTrigger_STATUS, Trigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTrigger_STATUS tests if a specific instance of Trigger_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTrigger_STATUS(subject Trigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Trigger_STATUS
	err := copied.AssignProperties_To_Trigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Trigger_STATUS
	err = actual.AssignProperties_From_Trigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Trigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Trigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrigger_STATUS, Trigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrigger_STATUS runs a test to see if a specific instance of Trigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTrigger_STATUS(subject Trigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Trigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Trigger_STATUS instances for property testing - lazily instantiated by Trigger_STATUSGenerator()
var trigger_STATUSGenerator gopter.Gen

// Trigger_STATUSGenerator returns a generator of Trigger_STATUS instances for property testing.
func Trigger_STATUSGenerator() gopter.Gen {
	if trigger_STATUSGenerator != nil {
		return trigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrigger_STATUS(generators)
	trigger_STATUSGenerator = gen.Struct(reflect.TypeOf(Trigger_STATUS{}), generators)

	return trigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["TimeAfterCreate"] = gen.PtrOf(gen.AlphaString())
	gens["TimeBeforeExpiry"] = gen.PtrOf(gen.AlphaString())
}

func Test_VaultsKey_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultsKey to hub returns original",
		prop.ForAll(RunResourceConversionTestForVaultsKey, VaultsKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForVaultsKey tests if a specific instance of VaultsKey round trips to the hub storage version and back losslessly
func RunResourceConversionTestForVaultsKey(subject VaultsKey) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.VaultsKey
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual VaultsKey
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultsKey_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultsKey to VaultsKey via AssignProperties_To_VaultsKey & AssignProperties_From_VaultsKey returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultsKey, VaultsKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultsKey tests if a specific instance of VaultsKey can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVaultsKey(subject VaultsKey) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VaultsKey
	err := copied.AssignProperties_To_VaultsKey(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultsKey
	err = actual.AssignProperties_From_VaultsKey(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultsKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKey, VaultsKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKey runs a test to see if a specific instance of VaultsKey round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKey(subject VaultsKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKey instances for property testing - lazily instantiated by VaultsKeyGenerator()
var vaultsKeyGenerator gopter.Gen

// VaultsKeyGenerator returns a generator of VaultsKey instances for property testing.
func VaultsKeyGenerator() gopter.Gen {
	if vaultsKeyGenerator != nil {
		return vaultsKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultsKey(generators)
	vaultsKeyGenerator = gen.Struct(reflect.TypeOf(VaultsKey{}), generators)

	return vaultsKeyGenerator
}

// AddRelatedPropertyGeneratorsForVaultsKey is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultsKey(gens map[string]gopter.Gen) {
	gens["Spec"] = VaultsKey_SpecGenerator()
	gens["Status"] = VaultsKey_STATUSGenerator()
}

func Test_VaultsKeyOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultsKeyOperatorSpec to VaultsKeyOperatorSpec via AssignProperties_To_VaultsKeyOperatorSpec & AssignProperties_From_VaultsKeyOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultsKeyOperatorSpec, VaultsKeyOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultsKeyOperatorSpec tests if a specific instance of VaultsKeyOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVaultsKeyOperatorSpec(subject VaultsKeyOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VaultsKeyOperatorSpec
	err := copied.AssignProperties_To_VaultsKeyOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultsKeyOperatorSpec
	err = actual.AssignProperties_From_VaultsKeyOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultsKeyOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKeyOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKeyOperatorSpec, VaultsKeyOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKeyOperatorSpec runs a test to see if a specific instance of VaultsKeyOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKeyOperatorSpec(subject VaultsKeyOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKeyOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKeyOperatorSpec instances for property testing - lazily instantiated by
// VaultsKeyOperatorSpecGenerator()
var vaultsKeyOperatorSpecGenerator gopter.Gen

// VaultsKeyOperatorSpecGenerator returns a generator of VaultsKeyOperatorSpec instances for property testing.
func VaultsKeyOperatorSpecGenerator() gopter.Gen {
	if vaultsKeyOperatorSpecGenerator != nil {
		return vaultsKeyOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	vaultsKeyOperatorSpecGenerator = gen.Struct(reflect.TypeOf(VaultsKeyOperatorSpec{}), generators)

	return vaultsKeyOperatorSpecGenerator
}

func Test_VaultsKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultsKey_STATUS to VaultsKey_STATUS via AssignProperties_To_VaultsKey_STATUS & AssignProperties_From_VaultsKey_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultsKey_STATUS, VaultsKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultsKey_STATUS tests if a specific instance of VaultsKey_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVaultsKey_STATUS(subject VaultsKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VaultsKey_STATUS
	err := copied.AssignProperties_To_VaultsKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultsKey_STATUS
	err = actual.AssignProperties_From_VaultsKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultsKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKey_STATUS, VaultsKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKey_STATUS runs a test to see if a specific instance of VaultsKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKey_STATUS(subject VaultsKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKey_STATUS instances for property testing - lazily instantiated by VaultsKey_STATUSGenerator()
var vaultsKey_STATUSGenerator gopter.Gen

// VaultsKey_STATUSGenerator returns a generator of VaultsKey_STATUS instances for property testing.
// We first initialize vaultsKey_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultsKey_STATUSGenerator() gopter.Gen {
	if vaultsKey_STATUSGenerator != nil {
		return vaultsKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_STATUS(generators)
	vaultsKey_STATUSGenerator = gen.Struct(reflect.TypeOf(VaultsKey_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_STATUS(generators)
	AddRelatedPropertyGeneratorsForVaultsKey_STATUS(generators)
	vaultsKey_STATUSGenerator = gen.Struct(reflect.TypeOf(VaultsKey_STATUS{}), generators)

	return vaultsKey_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVaultsKey_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultsKey_STATUS(gens map[string]gopter.Gen) {
	gens["CurveName"] = gen.PtrOf(gen.OneConstOf(
		KeyProperties_CurveName_STATUS_P256,
		KeyProperties_CurveName_STATUS_P256K,
		KeyProperties_CurveName_STATUS_P384,
		KeyProperties_CurveName_STATUS_P521))
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["KeyOps"] = gen.SliceOf(gen.OneConstOf(
		KeyProperties_KeyOps_STATUS_Decrypt,
		KeyProperties_KeyOps_STATUS_Encrypt,
		KeyProperties_KeyOps_STATUS_Import,
		KeyProperties_KeyOps_STATUS_Release,
		KeyProperties_KeyOps_STATUS_Sign,
		KeyProperties_KeyOps_STATUS_UnwrapKey,
		KeyProperties_KeyOps_STATUS_Verify,
		KeyProperties_KeyOps_STATUS_WrapKey))
	gens["KeySize"] = gen.PtrOf(gen.Int())
	gens["KeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["KeyUriWithVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Kty"] = gen.PtrOf(gen.OneConstOf(
		KeyProperties_Kty_STATUS_EC,
		KeyProperties_Kty_STATUS_ECHSM,
		KeyProperties_Kty_STATUS_RSA,
		KeyProperties_Kty_STATUS_RSAHSM))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultsKey_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultsKey_STATUS(gens map[string]gopter.Gen) {
	gens["Attributes"] = gen.PtrOf(KeyAttributes_STATUSGenerator())
	gens["Release_Policy"] = gen.PtrOf(KeyReleasePolicy_STATUSGenerator())
	gens["RotationPolicy"] = gen.PtrOf(RotationPolicy_STATUSGenerator())
}

func Test_VaultsKey_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultsKey_Spec to VaultsKey_Spec via AssignProperties_To_VaultsKey_Spec & AssignProperties_From_VaultsKey_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultsKey_Spec, VaultsKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultsKey_Spec tests if a specific instance of VaultsKey_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVaultsKey_Spec(subject VaultsKey_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VaultsKey_Spec
	err := copied.AssignProperties_To_VaultsKey_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultsKey_Spec
	err = actual.AssignProperties_From_VaultsKey_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultsKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultsKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsKey_Spec, VaultsKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsKey_Spec runs a test to see if a specific instance of VaultsKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsKey_Spec(subject VaultsKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultsKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultsKey_Spec instances for property testing - lazily instantiated by VaultsKey_SpecGenerator()
var vaultsKey_SpecGenerator gopter.Gen

// VaultsKey_SpecGenerator returns a generator of VaultsKey_Spec instances for property testing.
// We first initialize vaultsKey_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultsKey_SpecGenerator() gopter.Gen {
	if vaultsKey_SpecGenerator != nil {
		return vaultsKey_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_Spec(generators)
	vaultsKey_SpecGenerator = gen.Struct(reflect.TypeOf(VaultsKey_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsKey_Spec(generators)
	AddRelatedPropertyGeneratorsForVaultsKey_Spec(generators)
	vaultsKey_SpecGenerator = gen.Struct(reflect.TypeOf(VaultsKey_Spec{}), generators)

	return vaultsKey_SpecGenerator
}

// AddIndependentPropertyGeneratorsForVaultsKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultsKey_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultsKey_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultsKey_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(VaultsKeyOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(KeyPropertiesGenerator())
}
