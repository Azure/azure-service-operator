// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210401preview

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Vault_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Vault_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSTATUSARM, VaultSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSTATUSARM runs a test to see if a specific instance of Vault_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSTATUSARM(subject Vault_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Vault_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Vault_STATUSARM instances for property testing - lazily instantiated by VaultSTATUSARMGenerator()
var vaultSTATUSARMGenerator gopter.Gen

// VaultSTATUSARMGenerator returns a generator of Vault_STATUSARM instances for property testing.
// We first initialize vaultSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultSTATUSARMGenerator() gopter.Gen {
	if vaultSTATUSARMGenerator != nil {
		return vaultSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultSTATUSARM(generators)
	vaultSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Vault_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVaultSTATUSARM(generators)
	vaultSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Vault_STATUSARM{}), generators)

	return vaultSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VaultPropertiesSTATUSARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSARMGenerator())
}

func Test_SystemData_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataSTATUSARM, SystemDataSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataSTATUSARM runs a test to see if a specific instance of SystemData_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataSTATUSARM(subject SystemData_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUSARM instances for property testing - lazily instantiated by
// SystemDataSTATUSARMGenerator()
var systemDataSTATUSARMGenerator gopter.Gen

// SystemDataSTATUSARMGenerator returns a generator of SystemData_STATUSARM instances for property testing.
func SystemDataSTATUSARMGenerator() gopter.Gen {
	if systemDataSTATUSARMGenerator != nil {
		return systemDataSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataSTATUSARM(generators)
	systemDataSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUSARM{}), generators)

	return systemDataSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataSTATUSARM(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		IdentityType_STATUS_Application,
		IdentityType_STATUS_Key,
		IdentityType_STATUS_ManagedIdentity,
		IdentityType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		IdentityType_STATUS_Application,
		IdentityType_STATUS_Key,
		IdentityType_STATUS_ManagedIdentity,
		IdentityType_STATUS_User))
}

func Test_VaultProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultPropertiesSTATUSARM, VaultPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultPropertiesSTATUSARM runs a test to see if a specific instance of VaultProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultPropertiesSTATUSARM(subject VaultProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultProperties_STATUSARM instances for property testing - lazily instantiated by
// VaultPropertiesSTATUSARMGenerator()
var vaultPropertiesSTATUSARMGenerator gopter.Gen

// VaultPropertiesSTATUSARMGenerator returns a generator of VaultProperties_STATUSARM instances for property testing.
// We first initialize vaultPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultPropertiesSTATUSARMGenerator() gopter.Gen {
	if vaultPropertiesSTATUSARMGenerator != nil {
		return vaultPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultPropertiesSTATUSARM(generators)
	vaultPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VaultProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVaultPropertiesSTATUSARM(generators)
	vaultPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VaultProperties_STATUSARM{}), generators)

	return vaultPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["CreateMode"] = gen.PtrOf(gen.OneConstOf(VaultPropertiesSTATUSCreateMode_Default, VaultPropertiesSTATUSCreateMode_Recover))
	gens["EnablePurgeProtection"] = gen.PtrOf(gen.Bool())
	gens["EnableRbacAuthorization"] = gen.PtrOf(gen.Bool())
	gens["EnableSoftDelete"] = gen.PtrOf(gen.Bool())
	gens["EnabledForDeployment"] = gen.PtrOf(gen.Bool())
	gens["EnabledForDiskEncryption"] = gen.PtrOf(gen.Bool())
	gens["EnabledForTemplateDeployment"] = gen.PtrOf(gen.Bool())
	gens["HsmPoolResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(VaultPropertiesSTATUSProvisioningState_RegisteringDns, VaultPropertiesSTATUSProvisioningState_Succeeded))
	gens["SoftDeleteRetentionInDays"] = gen.PtrOf(gen.Int())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["VaultUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AccessPolicies"] = gen.SliceOf(AccessPolicyEntrySTATUSARMGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetSTATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionItemSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuSTATUSARMGenerator())
}

func Test_AccessPolicyEntry_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccessPolicyEntry_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccessPolicyEntrySTATUSARM, AccessPolicyEntrySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccessPolicyEntrySTATUSARM runs a test to see if a specific instance of AccessPolicyEntry_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAccessPolicyEntrySTATUSARM(subject AccessPolicyEntry_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccessPolicyEntry_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccessPolicyEntry_STATUSARM instances for property testing - lazily instantiated by
// AccessPolicyEntrySTATUSARMGenerator()
var accessPolicyEntrySTATUSARMGenerator gopter.Gen

// AccessPolicyEntrySTATUSARMGenerator returns a generator of AccessPolicyEntry_STATUSARM instances for property testing.
// We first initialize accessPolicyEntrySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccessPolicyEntrySTATUSARMGenerator() gopter.Gen {
	if accessPolicyEntrySTATUSARMGenerator != nil {
		return accessPolicyEntrySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessPolicyEntrySTATUSARM(generators)
	accessPolicyEntrySTATUSARMGenerator = gen.Struct(reflect.TypeOf(AccessPolicyEntry_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessPolicyEntrySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForAccessPolicyEntrySTATUSARM(generators)
	accessPolicyEntrySTATUSARMGenerator = gen.Struct(reflect.TypeOf(AccessPolicyEntry_STATUSARM{}), generators)

	return accessPolicyEntrySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAccessPolicyEntrySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccessPolicyEntrySTATUSARM(gens map[string]gopter.Gen) {
	gens["ApplicationId"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAccessPolicyEntrySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccessPolicyEntrySTATUSARM(gens map[string]gopter.Gen) {
	gens["Permissions"] = gen.PtrOf(PermissionsSTATUSARMGenerator())
}

func Test_NetworkRuleSet_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetSTATUSARM, NetworkRuleSetSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetSTATUSARM runs a test to see if a specific instance of NetworkRuleSet_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetSTATUSARM(subject NetworkRuleSet_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUSARM instances for property testing - lazily instantiated by
// NetworkRuleSetSTATUSARMGenerator()
var networkRuleSetSTATUSARMGenerator gopter.Gen

// NetworkRuleSetSTATUSARMGenerator returns a generator of NetworkRuleSet_STATUSARM instances for property testing.
// We first initialize networkRuleSetSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetSTATUSARMGenerator() gopter.Gen {
	if networkRuleSetSTATUSARMGenerator != nil {
		return networkRuleSetSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	networkRuleSetSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	networkRuleSetSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	return networkRuleSetSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetSTATUSBypass_AzureServices, NetworkRuleSetSTATUSBypass_None))
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetSTATUSDefaultAction_Allow, NetworkRuleSetSTATUSDefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleSTATUSARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleSTATUSARMGenerator())
}

func Test_PrivateEndpointConnectionItem_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionItem_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionItemSTATUSARM, PrivateEndpointConnectionItemSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionItemSTATUSARM runs a test to see if a specific instance of PrivateEndpointConnectionItem_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionItemSTATUSARM(subject PrivateEndpointConnectionItem_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionItem_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionItem_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointConnectionItemSTATUSARMGenerator()
var privateEndpointConnectionItemSTATUSARMGenerator gopter.Gen

// PrivateEndpointConnectionItemSTATUSARMGenerator returns a generator of PrivateEndpointConnectionItem_STATUSARM instances for property testing.
// We first initialize privateEndpointConnectionItemSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionItemSTATUSARMGenerator() gopter.Gen {
	if privateEndpointConnectionItemSTATUSARMGenerator != nil {
		return privateEndpointConnectionItemSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionItemSTATUSARM(generators)
	privateEndpointConnectionItemSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionItem_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionItemSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionItemSTATUSARM(generators)
	privateEndpointConnectionItemSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionItem_STATUSARM{}), generators)

	return privateEndpointConnectionItemSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionItemSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionItemSTATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionItemSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionItemSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateEndpointConnectionPropertiesSTATUSARMGenerator())
}

func Test_Sku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuSTATUSARM, SkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuSTATUSARM runs a test to see if a specific instance of Sku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuSTATUSARM(subject Sku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUSARM instances for property testing - lazily instantiated by SkuSTATUSARMGenerator()
var skuSTATUSARMGenerator gopter.Gen

// SkuSTATUSARMGenerator returns a generator of Sku_STATUSARM instances for property testing.
func SkuSTATUSARMGenerator() gopter.Gen {
	if skuSTATUSARMGenerator != nil {
		return skuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuSTATUSARM(generators)
	skuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Sku_STATUSARM{}), generators)

	return skuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Family"] = gen.PtrOf(gen.OneConstOf(SkuSTATUSFamily_A))
	gens["Name"] = gen.PtrOf(gen.OneConstOf(SkuSTATUSName_Premium, SkuSTATUSName_Standard))
}

func Test_IPRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleSTATUSARM, IPRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleSTATUSARM runs a test to see if a specific instance of IPRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleSTATUSARM(subject IPRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_STATUSARM instances for property testing - lazily instantiated by IPRuleSTATUSARMGenerator()
var ipRuleSTATUSARMGenerator gopter.Gen

// IPRuleSTATUSARMGenerator returns a generator of IPRule_STATUSARM instances for property testing.
func IPRuleSTATUSARMGenerator() gopter.Gen {
	if ipRuleSTATUSARMGenerator != nil {
		return ipRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleSTATUSARM(generators)
	ipRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUSARM{}), generators)

	return ipRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_Permissions_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Permissions_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPermissionsSTATUSARM, PermissionsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPermissionsSTATUSARM runs a test to see if a specific instance of Permissions_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPermissionsSTATUSARM(subject Permissions_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Permissions_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Permissions_STATUSARM instances for property testing - lazily instantiated by
// PermissionsSTATUSARMGenerator()
var permissionsSTATUSARMGenerator gopter.Gen

// PermissionsSTATUSARMGenerator returns a generator of Permissions_STATUSARM instances for property testing.
func PermissionsSTATUSARMGenerator() gopter.Gen {
	if permissionsSTATUSARMGenerator != nil {
		return permissionsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPermissionsSTATUSARM(generators)
	permissionsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Permissions_STATUSARM{}), generators)

	return permissionsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPermissionsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPermissionsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Certificates"] = gen.SliceOf(gen.OneConstOf(
		PermissionsSTATUSCertificates_Backup,
		PermissionsSTATUSCertificates_Create,
		PermissionsSTATUSCertificates_Delete,
		PermissionsSTATUSCertificates_Deleteissuers,
		PermissionsSTATUSCertificates_Get,
		PermissionsSTATUSCertificates_Getissuers,
		PermissionsSTATUSCertificates_Import,
		PermissionsSTATUSCertificates_List,
		PermissionsSTATUSCertificates_Listissuers,
		PermissionsSTATUSCertificates_Managecontacts,
		PermissionsSTATUSCertificates_Manageissuers,
		PermissionsSTATUSCertificates_Purge,
		PermissionsSTATUSCertificates_Recover,
		PermissionsSTATUSCertificates_Restore,
		PermissionsSTATUSCertificates_Setissuers,
		PermissionsSTATUSCertificates_Update))
	gens["Keys"] = gen.SliceOf(gen.OneConstOf(
		PermissionsSTATUSKeys_Backup,
		PermissionsSTATUSKeys_Create,
		PermissionsSTATUSKeys_Decrypt,
		PermissionsSTATUSKeys_Delete,
		PermissionsSTATUSKeys_Encrypt,
		PermissionsSTATUSKeys_Get,
		PermissionsSTATUSKeys_Import,
		PermissionsSTATUSKeys_List,
		PermissionsSTATUSKeys_Purge,
		PermissionsSTATUSKeys_Recover,
		PermissionsSTATUSKeys_Release,
		PermissionsSTATUSKeys_Restore,
		PermissionsSTATUSKeys_Sign,
		PermissionsSTATUSKeys_UnwrapKey,
		PermissionsSTATUSKeys_Update,
		PermissionsSTATUSKeys_Verify,
		PermissionsSTATUSKeys_WrapKey))
	gens["Secrets"] = gen.SliceOf(gen.OneConstOf(
		PermissionsSTATUSSecrets_Backup,
		PermissionsSTATUSSecrets_Delete,
		PermissionsSTATUSSecrets_Get,
		PermissionsSTATUSSecrets_List,
		PermissionsSTATUSSecrets_Purge,
		PermissionsSTATUSSecrets_Recover,
		PermissionsSTATUSSecrets_Restore,
		PermissionsSTATUSSecrets_Set))
	gens["Storage"] = gen.SliceOf(gen.OneConstOf(
		PermissionsSTATUSStorage_Backup,
		PermissionsSTATUSStorage_Delete,
		PermissionsSTATUSStorage_Deletesas,
		PermissionsSTATUSStorage_Get,
		PermissionsSTATUSStorage_Getsas,
		PermissionsSTATUSStorage_List,
		PermissionsSTATUSStorage_Listsas,
		PermissionsSTATUSStorage_Purge,
		PermissionsSTATUSStorage_Recover,
		PermissionsSTATUSStorage_Regeneratekey,
		PermissionsSTATUSStorage_Restore,
		PermissionsSTATUSStorage_Set,
		PermissionsSTATUSStorage_Setsas,
		PermissionsSTATUSStorage_Update))
}

func Test_PrivateEndpointConnectionProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionPropertiesSTATUSARM, PrivateEndpointConnectionPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionPropertiesSTATUSARM runs a test to see if a specific instance of PrivateEndpointConnectionProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionPropertiesSTATUSARM(subject PrivateEndpointConnectionProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionProperties_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointConnectionPropertiesSTATUSARMGenerator()
var privateEndpointConnectionPropertiesSTATUSARMGenerator gopter.Gen

// PrivateEndpointConnectionPropertiesSTATUSARMGenerator returns a generator of PrivateEndpointConnectionProperties_STATUSARM instances for property testing.
// We first initialize privateEndpointConnectionPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionPropertiesSTATUSARMGenerator() gopter.Gen {
	if privateEndpointConnectionPropertiesSTATUSARMGenerator != nil {
		return privateEndpointConnectionPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(generators)
	privateEndpointConnectionPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(generators)
	privateEndpointConnectionPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_STATUSARM{}), generators)

	return privateEndpointConnectionPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointConnectionProvisioningState_STATUS_Creating,
		PrivateEndpointConnectionProvisioningState_STATUS_Deleting,
		PrivateEndpointConnectionProvisioningState_STATUS_Disconnected,
		PrivateEndpointConnectionProvisioningState_STATUS_Failed,
		PrivateEndpointConnectionProvisioningState_STATUS_Succeeded,
		PrivateEndpointConnectionProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpointSTATUSARMGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(PrivateLinkServiceConnectionStateSTATUSARMGenerator())
}

func Test_VirtualNetworkRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleSTATUSARM, VirtualNetworkRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleSTATUSARM runs a test to see if a specific instance of VirtualNetworkRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleSTATUSARM(subject VirtualNetworkRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_STATUSARM instances for property testing - lazily instantiated by
// VirtualNetworkRuleSTATUSARMGenerator()
var virtualNetworkRuleSTATUSARMGenerator gopter.Gen

// VirtualNetworkRuleSTATUSARMGenerator returns a generator of VirtualNetworkRule_STATUSARM instances for property testing.
func VirtualNetworkRuleSTATUSARMGenerator() gopter.Gen {
	if virtualNetworkRuleSTATUSARMGenerator != nil {
		return virtualNetworkRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUSARM(generators)
	virtualNetworkRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_STATUSARM{}), generators)

	return virtualNetworkRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVnetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_PrivateEndpoint_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointSTATUSARM, PrivateEndpointSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointSTATUSARM runs a test to see if a specific instance of PrivateEndpoint_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointSTATUSARM(subject PrivateEndpoint_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointSTATUSARMGenerator()
var privateEndpointSTATUSARMGenerator gopter.Gen

// PrivateEndpointSTATUSARMGenerator returns a generator of PrivateEndpoint_STATUSARM instances for property testing.
func PrivateEndpointSTATUSARMGenerator() gopter.Gen {
	if privateEndpointSTATUSARMGenerator != nil {
		return privateEndpointSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointSTATUSARM(generators)
	privateEndpointSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_STATUSARM{}), generators)

	return privateEndpointSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceConnectionState_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceConnectionState_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceConnectionStateSTATUSARM, PrivateLinkServiceConnectionStateSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceConnectionStateSTATUSARM runs a test to see if a specific instance of PrivateLinkServiceConnectionState_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceConnectionStateSTATUSARM(subject PrivateLinkServiceConnectionState_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceConnectionState_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceConnectionState_STATUSARM instances for property testing - lazily instantiated by
// PrivateLinkServiceConnectionStateSTATUSARMGenerator()
var privateLinkServiceConnectionStateSTATUSARMGenerator gopter.Gen

// PrivateLinkServiceConnectionStateSTATUSARMGenerator returns a generator of PrivateLinkServiceConnectionState_STATUSARM instances for property testing.
func PrivateLinkServiceConnectionStateSTATUSARMGenerator() gopter.Gen {
	if privateLinkServiceConnectionStateSTATUSARMGenerator != nil {
		return privateLinkServiceConnectionStateSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateSTATUSARM(generators)
	privateLinkServiceConnectionStateSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState_STATUSARM{}), generators)

	return privateLinkServiceConnectionStateSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateSTATUSARM(gens map[string]gopter.Gen) {
	gens["ActionsRequired"] = gen.PtrOf(gen.OneConstOf(PrivateLinkServiceConnectionStateSTATUSActionsRequired_None))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointServiceConnectionStatus_STATUS_Approved,
		PrivateEndpointServiceConnectionStatus_STATUS_Disconnected,
		PrivateEndpointServiceConnectionStatus_STATUS_Pending,
		PrivateEndpointServiceConnectionStatus_STATUS_Rejected))
}
