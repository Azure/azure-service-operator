// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210401preview

import (
	"encoding/json"
	v20210401ps "github.com/Azure/azure-service-operator/v2/api/keyvault/v1beta20210401previewstorage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Vault_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Vault to hub returns original",
		prop.ForAll(RunResourceConversionTestForVault, VaultGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForVault tests if a specific instance of Vault round trips to the hub storage version and back losslessly
func RunResourceConversionTestForVault(subject Vault) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210401ps.Vault
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Vault
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Vault_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Vault to Vault via AssignPropertiesToVault & AssignPropertiesFromVault returns original",
		prop.ForAll(RunPropertyAssignmentTestForVault, VaultGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVault tests if a specific instance of Vault can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForVault(subject Vault) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.Vault
	err := copied.AssignPropertiesToVault(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Vault
	err = actual.AssignPropertiesFromVault(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Vault_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Vault via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVault, VaultGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVault runs a test to see if a specific instance of Vault round trips to JSON and back losslessly
func RunJSONSerializationTestForVault(subject Vault) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Vault
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Vault instances for property testing - lazily instantiated by VaultGenerator()
var vaultGenerator gopter.Gen

// VaultGenerator returns a generator of Vault instances for property testing.
func VaultGenerator() gopter.Gen {
	if vaultGenerator != nil {
		return vaultGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVault(generators)
	vaultGenerator = gen.Struct(reflect.TypeOf(Vault{}), generators)

	return vaultGenerator
}

// AddRelatedPropertyGeneratorsForVault is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVault(gens map[string]gopter.Gen) {
	gens["Spec"] = VaultsSpecGenerator()
	gens["Status"] = VaultStatusGenerator()
}

func Test_Vault_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Vault_Status to Vault_Status via AssignPropertiesToVaultStatus & AssignPropertiesFromVaultStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultStatus, VaultStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultStatus tests if a specific instance of Vault_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForVaultStatus(subject Vault_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.Vault_Status
	err := copied.AssignPropertiesToVaultStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Vault_Status
	err = actual.AssignPropertiesFromVaultStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Vault_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Vault_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultStatus, VaultStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultStatus runs a test to see if a specific instance of Vault_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultStatus(subject Vault_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Vault_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Vault_Status instances for property testing - lazily instantiated by VaultStatusGenerator()
var vaultStatusGenerator gopter.Gen

// VaultStatusGenerator returns a generator of Vault_Status instances for property testing.
// We first initialize vaultStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultStatusGenerator() gopter.Gen {
	if vaultStatusGenerator != nil {
		return vaultStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultStatus(generators)
	vaultStatusGenerator = gen.Struct(reflect.TypeOf(Vault_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultStatus(generators)
	AddRelatedPropertyGeneratorsForVaultStatus(generators)
	vaultStatusGenerator = gen.Struct(reflect.TypeOf(Vault_Status{}), generators)

	return vaultStatusGenerator
}

// AddIndependentPropertyGeneratorsForVaultStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultStatus(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VaultPropertiesStatusGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataStatusGenerator())
}

func Test_Vaults_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Vaults_Spec to Vaults_Spec via AssignPropertiesToVaultsSpec & AssignPropertiesFromVaultsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultsSpec, VaultsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultsSpec tests if a specific instance of Vaults_Spec can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForVaultsSpec(subject Vaults_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.Vaults_Spec
	err := copied.AssignPropertiesToVaultsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Vaults_Spec
	err = actual.AssignPropertiesFromVaultsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Vaults_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Vaults_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultsSpec, VaultsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultsSpec runs a test to see if a specific instance of Vaults_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultsSpec(subject Vaults_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Vaults_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Vaults_Spec instances for property testing - lazily instantiated by VaultsSpecGenerator()
var vaultsSpecGenerator gopter.Gen

// VaultsSpecGenerator returns a generator of Vaults_Spec instances for property testing.
// We first initialize vaultsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultsSpecGenerator() gopter.Gen {
	if vaultsSpecGenerator != nil {
		return vaultsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsSpec(generators)
	vaultsSpecGenerator = gen.Struct(reflect.TypeOf(Vaults_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultsSpec(generators)
	AddRelatedPropertyGeneratorsForVaultsSpec(generators)
	vaultsSpecGenerator = gen.Struct(reflect.TypeOf(Vaults_Spec{}), generators)

	return vaultsSpecGenerator
}

// AddIndependentPropertyGeneratorsForVaultsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultsSpec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultsSpec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VaultPropertiesGenerator())
}

func Test_SystemData_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_Status to SystemData_Status via AssignPropertiesToSystemDataStatus & AssignPropertiesFromSystemDataStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemDataStatus, SystemDataStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemDataStatus tests if a specific instance of SystemData_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForSystemDataStatus(subject SystemData_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.SystemData_Status
	err := copied.AssignPropertiesToSystemDataStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_Status
	err = actual.AssignPropertiesFromSystemDataStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataStatus, SystemDataStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataStatus runs a test to see if a specific instance of SystemData_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataStatus(subject SystemData_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_Status instances for property testing - lazily instantiated by SystemDataStatusGenerator()
var systemDataStatusGenerator gopter.Gen

// SystemDataStatusGenerator returns a generator of SystemData_Status instances for property testing.
func SystemDataStatusGenerator() gopter.Gen {
	if systemDataStatusGenerator != nil {
		return systemDataStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataStatus(generators)
	systemDataStatusGenerator = gen.Struct(reflect.TypeOf(SystemData_Status{}), generators)

	return systemDataStatusGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataStatus(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		IdentityType_StatusApplication,
		IdentityType_StatusKey,
		IdentityType_StatusManagedIdentity,
		IdentityType_StatusUser))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		IdentityType_StatusApplication,
		IdentityType_StatusKey,
		IdentityType_StatusManagedIdentity,
		IdentityType_StatusUser))
}

func Test_VaultProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultProperties to VaultProperties via AssignPropertiesToVaultProperties & AssignPropertiesFromVaultProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultProperties, VaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultProperties tests if a specific instance of VaultProperties can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForVaultProperties(subject VaultProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.VaultProperties
	err := copied.AssignPropertiesToVaultProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultProperties
	err = actual.AssignPropertiesFromVaultProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultProperties, VaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultProperties runs a test to see if a specific instance of VaultProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultProperties(subject VaultProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultProperties instances for property testing - lazily instantiated by VaultPropertiesGenerator()
var vaultPropertiesGenerator gopter.Gen

// VaultPropertiesGenerator returns a generator of VaultProperties instances for property testing.
// We first initialize vaultPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultPropertiesGenerator() gopter.Gen {
	if vaultPropertiesGenerator != nil {
		return vaultPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultProperties(generators)
	vaultPropertiesGenerator = gen.Struct(reflect.TypeOf(VaultProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultProperties(generators)
	AddRelatedPropertyGeneratorsForVaultProperties(generators)
	vaultPropertiesGenerator = gen.Struct(reflect.TypeOf(VaultProperties{}), generators)

	return vaultPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForVaultProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultProperties(gens map[string]gopter.Gen) {
	gens["CreateMode"] = gen.PtrOf(gen.OneConstOf(VaultPropertiesCreateModeDefault, VaultPropertiesCreateModeRecover))
	gens["EnablePurgeProtection"] = gen.PtrOf(gen.Bool())
	gens["EnableRbacAuthorization"] = gen.PtrOf(gen.Bool())
	gens["EnableSoftDelete"] = gen.PtrOf(gen.Bool())
	gens["EnabledForDeployment"] = gen.PtrOf(gen.Bool())
	gens["EnabledForDiskEncryption"] = gen.PtrOf(gen.Bool())
	gens["EnabledForTemplateDeployment"] = gen.PtrOf(gen.Bool())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(VaultPropertiesProvisioningStateRegisteringDns, VaultPropertiesProvisioningStateSucceeded))
	gens["SoftDeleteRetentionInDays"] = gen.PtrOf(gen.Int())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["VaultUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultProperties(gens map[string]gopter.Gen) {
	gens["AccessPolicies"] = gen.SliceOf(AccessPolicyEntryGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_VaultProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VaultProperties_Status to VaultProperties_Status via AssignPropertiesToVaultPropertiesStatus & AssignPropertiesFromVaultPropertiesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVaultPropertiesStatus, VaultPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVaultPropertiesStatus tests if a specific instance of VaultProperties_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForVaultPropertiesStatus(subject VaultProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.VaultProperties_Status
	err := copied.AssignPropertiesToVaultPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VaultProperties_Status
	err = actual.AssignPropertiesFromVaultPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VaultProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultPropertiesStatus, VaultPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultPropertiesStatus runs a test to see if a specific instance of VaultProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultPropertiesStatus(subject VaultProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultProperties_Status instances for property testing - lazily instantiated by
// VaultPropertiesStatusGenerator()
var vaultPropertiesStatusGenerator gopter.Gen

// VaultPropertiesStatusGenerator returns a generator of VaultProperties_Status instances for property testing.
// We first initialize vaultPropertiesStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VaultPropertiesStatusGenerator() gopter.Gen {
	if vaultPropertiesStatusGenerator != nil {
		return vaultPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultPropertiesStatus(generators)
	vaultPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(VaultProperties_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultPropertiesStatus(generators)
	AddRelatedPropertyGeneratorsForVaultPropertiesStatus(generators)
	vaultPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(VaultProperties_Status{}), generators)

	return vaultPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForVaultPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultPropertiesStatus(gens map[string]gopter.Gen) {
	gens["CreateMode"] = gen.PtrOf(gen.OneConstOf(VaultPropertiesStatusCreateModeDefault, VaultPropertiesStatusCreateModeRecover))
	gens["EnablePurgeProtection"] = gen.PtrOf(gen.Bool())
	gens["EnableRbacAuthorization"] = gen.PtrOf(gen.Bool())
	gens["EnableSoftDelete"] = gen.PtrOf(gen.Bool())
	gens["EnabledForDeployment"] = gen.PtrOf(gen.Bool())
	gens["EnabledForDiskEncryption"] = gen.PtrOf(gen.Bool())
	gens["EnabledForTemplateDeployment"] = gen.PtrOf(gen.Bool())
	gens["HsmPoolResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(VaultPropertiesStatusProvisioningStateRegisteringDns, VaultPropertiesStatusProvisioningStateSucceeded))
	gens["SoftDeleteRetentionInDays"] = gen.PtrOf(gen.Int())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["VaultUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVaultPropertiesStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultPropertiesStatus(gens map[string]gopter.Gen) {
	gens["AccessPolicies"] = gen.SliceOf(AccessPolicyEntryStatusGenerator())
	gens["NetworkAcls"] = gen.PtrOf(NetworkRuleSetStatusGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionItemStatusGenerator())
	gens["Sku"] = gen.PtrOf(SkuStatusGenerator())
}

func Test_AccessPolicyEntry_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AccessPolicyEntry to AccessPolicyEntry via AssignPropertiesToAccessPolicyEntry & AssignPropertiesFromAccessPolicyEntry returns original",
		prop.ForAll(RunPropertyAssignmentTestForAccessPolicyEntry, AccessPolicyEntryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAccessPolicyEntry tests if a specific instance of AccessPolicyEntry can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForAccessPolicyEntry(subject AccessPolicyEntry) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.AccessPolicyEntry
	err := copied.AssignPropertiesToAccessPolicyEntry(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AccessPolicyEntry
	err = actual.AssignPropertiesFromAccessPolicyEntry(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AccessPolicyEntry_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccessPolicyEntry via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccessPolicyEntry, AccessPolicyEntryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccessPolicyEntry runs a test to see if a specific instance of AccessPolicyEntry round trips to JSON and back losslessly
func RunJSONSerializationTestForAccessPolicyEntry(subject AccessPolicyEntry) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccessPolicyEntry
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccessPolicyEntry instances for property testing - lazily instantiated by AccessPolicyEntryGenerator()
var accessPolicyEntryGenerator gopter.Gen

// AccessPolicyEntryGenerator returns a generator of AccessPolicyEntry instances for property testing.
// We first initialize accessPolicyEntryGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccessPolicyEntryGenerator() gopter.Gen {
	if accessPolicyEntryGenerator != nil {
		return accessPolicyEntryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessPolicyEntry(generators)
	accessPolicyEntryGenerator = gen.Struct(reflect.TypeOf(AccessPolicyEntry{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessPolicyEntry(generators)
	AddRelatedPropertyGeneratorsForAccessPolicyEntry(generators)
	accessPolicyEntryGenerator = gen.Struct(reflect.TypeOf(AccessPolicyEntry{}), generators)

	return accessPolicyEntryGenerator
}

// AddIndependentPropertyGeneratorsForAccessPolicyEntry is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccessPolicyEntry(gens map[string]gopter.Gen) {
	gens["ApplicationId"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAccessPolicyEntry is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccessPolicyEntry(gens map[string]gopter.Gen) {
	gens["Permissions"] = gen.PtrOf(PermissionsGenerator())
}

func Test_AccessPolicyEntry_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AccessPolicyEntry_Status to AccessPolicyEntry_Status via AssignPropertiesToAccessPolicyEntryStatus & AssignPropertiesFromAccessPolicyEntryStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAccessPolicyEntryStatus, AccessPolicyEntryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAccessPolicyEntryStatus tests if a specific instance of AccessPolicyEntry_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForAccessPolicyEntryStatus(subject AccessPolicyEntry_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.AccessPolicyEntry_Status
	err := copied.AssignPropertiesToAccessPolicyEntryStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AccessPolicyEntry_Status
	err = actual.AssignPropertiesFromAccessPolicyEntryStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AccessPolicyEntry_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AccessPolicyEntry_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAccessPolicyEntryStatus, AccessPolicyEntryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAccessPolicyEntryStatus runs a test to see if a specific instance of AccessPolicyEntry_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAccessPolicyEntryStatus(subject AccessPolicyEntry_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AccessPolicyEntry_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AccessPolicyEntry_Status instances for property testing - lazily instantiated by
// AccessPolicyEntryStatusGenerator()
var accessPolicyEntryStatusGenerator gopter.Gen

// AccessPolicyEntryStatusGenerator returns a generator of AccessPolicyEntry_Status instances for property testing.
// We first initialize accessPolicyEntryStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AccessPolicyEntryStatusGenerator() gopter.Gen {
	if accessPolicyEntryStatusGenerator != nil {
		return accessPolicyEntryStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessPolicyEntryStatus(generators)
	accessPolicyEntryStatusGenerator = gen.Struct(reflect.TypeOf(AccessPolicyEntry_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAccessPolicyEntryStatus(generators)
	AddRelatedPropertyGeneratorsForAccessPolicyEntryStatus(generators)
	accessPolicyEntryStatusGenerator = gen.Struct(reflect.TypeOf(AccessPolicyEntry_Status{}), generators)

	return accessPolicyEntryStatusGenerator
}

// AddIndependentPropertyGeneratorsForAccessPolicyEntryStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAccessPolicyEntryStatus(gens map[string]gopter.Gen) {
	gens["ApplicationId"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAccessPolicyEntryStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAccessPolicyEntryStatus(gens map[string]gopter.Gen) {
	gens["Permissions"] = gen.PtrOf(PermissionsStatusGenerator())
}

func Test_NetworkRuleSet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSet to NetworkRuleSet via AssignPropertiesToNetworkRuleSet & AssignPropertiesFromNetworkRuleSet returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSet, NetworkRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSet tests if a specific instance of NetworkRuleSet can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSet(subject NetworkRuleSet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.NetworkRuleSet
	err := copied.AssignPropertiesToNetworkRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSet
	err = actual.AssignPropertiesFromNetworkRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet, NetworkRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet runs a test to see if a specific instance of NetworkRuleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet(subject NetworkRuleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet instances for property testing - lazily instantiated by NetworkRuleSetGenerator()
var networkRuleSetGenerator gopter.Gen

// NetworkRuleSetGenerator returns a generator of NetworkRuleSet instances for property testing.
// We first initialize networkRuleSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetGenerator() gopter.Gen {
	if networkRuleSetGenerator != nil {
		return networkRuleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	return networkRuleSetGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetBypassAzureServices, NetworkRuleSetBypassNone))
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetDefaultActionAllow, NetworkRuleSetDefaultActionDeny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleGenerator())
}

func Test_NetworkRuleSet_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSet_Status to NetworkRuleSet_Status via AssignPropertiesToNetworkRuleSetStatus & AssignPropertiesFromNetworkRuleSetStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSetStatus, NetworkRuleSetStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSetStatus tests if a specific instance of NetworkRuleSet_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSetStatus(subject NetworkRuleSet_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.NetworkRuleSet_Status
	err := copied.AssignPropertiesToNetworkRuleSetStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSet_Status
	err = actual.AssignPropertiesFromNetworkRuleSetStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSet_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetStatus, NetworkRuleSetStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetStatus runs a test to see if a specific instance of NetworkRuleSet_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetStatus(subject NetworkRuleSet_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_Status instances for property testing - lazily instantiated by
// NetworkRuleSetStatusGenerator()
var networkRuleSetStatusGenerator gopter.Gen

// NetworkRuleSetStatusGenerator returns a generator of NetworkRuleSet_Status instances for property testing.
// We first initialize networkRuleSetStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetStatusGenerator() gopter.Gen {
	if networkRuleSetStatusGenerator != nil {
		return networkRuleSetStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatus(generators)
	networkRuleSetStatusGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatus(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetStatus(generators)
	networkRuleSetStatusGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_Status{}), generators)

	return networkRuleSetStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetStatus(gens map[string]gopter.Gen) {
	gens["Bypass"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetStatusBypassAzureServices, NetworkRuleSetStatusBypassNone))
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetStatusDefaultActionAllow, NetworkRuleSetStatusDefaultActionDeny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetStatus(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleStatusGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleStatusGenerator())
}

func Test_PrivateEndpointConnectionItem_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnectionItem_Status to PrivateEndpointConnectionItem_Status via AssignPropertiesToPrivateEndpointConnectionItemStatus & AssignPropertiesFromPrivateEndpointConnectionItemStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnectionItemStatus, PrivateEndpointConnectionItemStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnectionItemStatus tests if a specific instance of PrivateEndpointConnectionItem_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnectionItemStatus(subject PrivateEndpointConnectionItem_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.PrivateEndpointConnectionItem_Status
	err := copied.AssignPropertiesToPrivateEndpointConnectionItemStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnectionItem_Status
	err = actual.AssignPropertiesFromPrivateEndpointConnectionItemStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnectionItem_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionItem_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionItemStatus, PrivateEndpointConnectionItemStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionItemStatus runs a test to see if a specific instance of PrivateEndpointConnectionItem_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionItemStatus(subject PrivateEndpointConnectionItem_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionItem_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionItem_Status instances for property testing - lazily instantiated by
// PrivateEndpointConnectionItemStatusGenerator()
var privateEndpointConnectionItemStatusGenerator gopter.Gen

// PrivateEndpointConnectionItemStatusGenerator returns a generator of PrivateEndpointConnectionItem_Status instances for property testing.
// We first initialize privateEndpointConnectionItemStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionItemStatusGenerator() gopter.Gen {
	if privateEndpointConnectionItemStatusGenerator != nil {
		return privateEndpointConnectionItemStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionItemStatus(generators)
	privateEndpointConnectionItemStatusGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionItem_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionItemStatus(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionItemStatus(generators)
	privateEndpointConnectionItemStatusGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionItem_Status{}), generators)

	return privateEndpointConnectionItemStatusGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionItemStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionItemStatus(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointConnectionProvisioningState_StatusCreating,
		PrivateEndpointConnectionProvisioningState_StatusDeleting,
		PrivateEndpointConnectionProvisioningState_StatusDisconnected,
		PrivateEndpointConnectionProvisioningState_StatusFailed,
		PrivateEndpointConnectionProvisioningState_StatusSucceeded,
		PrivateEndpointConnectionProvisioningState_StatusUpdating))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionItemStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionItemStatus(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpointStatusGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(PrivateLinkServiceConnectionStateStatusGenerator())
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignPropertiesToSku & AssignPropertiesFromSku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.Sku
	err := copied.AssignPropertiesToSku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignPropertiesFromSku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Family"] = gen.PtrOf(gen.OneConstOf(SkuFamilyA))
	gens["Name"] = gen.PtrOf(gen.OneConstOf(SkuNamePremium, SkuNameStandard))
}

func Test_Sku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_Status to Sku_Status via AssignPropertiesToSkuStatus & AssignPropertiesFromSkuStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSkuStatus, SkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSkuStatus tests if a specific instance of Sku_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForSkuStatus(subject Sku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.Sku_Status
	err := copied.AssignPropertiesToSkuStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_Status
	err = actual.AssignPropertiesFromSkuStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuStatus, SkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuStatus runs a test to see if a specific instance of Sku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuStatus(subject Sku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_Status instances for property testing - lazily instantiated by SkuStatusGenerator()
var skuStatusGenerator gopter.Gen

// SkuStatusGenerator returns a generator of Sku_Status instances for property testing.
func SkuStatusGenerator() gopter.Gen {
	if skuStatusGenerator != nil {
		return skuStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuStatus(generators)
	skuStatusGenerator = gen.Struct(reflect.TypeOf(Sku_Status{}), generators)

	return skuStatusGenerator
}

// AddIndependentPropertyGeneratorsForSkuStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuStatus(gens map[string]gopter.Gen) {
	gens["Family"] = gen.PtrOf(gen.OneConstOf(SkuStatusFamilyA))
	gens["Name"] = gen.PtrOf(gen.OneConstOf(SkuStatusNamePremium, SkuStatusNameStandard))
}

func Test_IPRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPRule to IPRule via AssignPropertiesToIPRule & AssignPropertiesFromIPRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPRule, IPRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPRule tests if a specific instance of IPRule can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForIPRule(subject IPRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.IPRule
	err := copied.AssignPropertiesToIPRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPRule
	err = actual.AssignPropertiesFromIPRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule, IPRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule runs a test to see if a specific instance of IPRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule(subject IPRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule instances for property testing - lazily instantiated by IPRuleGenerator()
var ipRuleGenerator gopter.Gen

// IPRuleGenerator returns a generator of IPRule instances for property testing.
func IPRuleGenerator() gopter.Gen {
	if ipRuleGenerator != nil {
		return ipRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule(generators)
	ipRuleGenerator = gen.Struct(reflect.TypeOf(IPRule{}), generators)

	return ipRuleGenerator
}

// AddIndependentPropertyGeneratorsForIPRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule(gens map[string]gopter.Gen) {
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPRule_Status to IPRule_Status via AssignPropertiesToIPRuleStatus & AssignPropertiesFromIPRuleStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPRuleStatus, IPRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPRuleStatus tests if a specific instance of IPRule_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForIPRuleStatus(subject IPRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.IPRule_Status
	err := copied.AssignPropertiesToIPRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPRule_Status
	err = actual.AssignPropertiesFromIPRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleStatus, IPRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleStatus runs a test to see if a specific instance of IPRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleStatus(subject IPRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_Status instances for property testing - lazily instantiated by IPRuleStatusGenerator()
var ipRuleStatusGenerator gopter.Gen

// IPRuleStatusGenerator returns a generator of IPRule_Status instances for property testing.
func IPRuleStatusGenerator() gopter.Gen {
	if ipRuleStatusGenerator != nil {
		return ipRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleStatus(generators)
	ipRuleStatusGenerator = gen.Struct(reflect.TypeOf(IPRule_Status{}), generators)

	return ipRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleStatus(gens map[string]gopter.Gen) {
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_Permissions_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Permissions to Permissions via AssignPropertiesToPermissions & AssignPropertiesFromPermissions returns original",
		prop.ForAll(RunPropertyAssignmentTestForPermissions, PermissionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPermissions tests if a specific instance of Permissions can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForPermissions(subject Permissions) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.Permissions
	err := copied.AssignPropertiesToPermissions(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Permissions
	err = actual.AssignPropertiesFromPermissions(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Permissions_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Permissions via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPermissions, PermissionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPermissions runs a test to see if a specific instance of Permissions round trips to JSON and back losslessly
func RunJSONSerializationTestForPermissions(subject Permissions) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Permissions
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Permissions instances for property testing - lazily instantiated by PermissionsGenerator()
var permissionsGenerator gopter.Gen

// PermissionsGenerator returns a generator of Permissions instances for property testing.
func PermissionsGenerator() gopter.Gen {
	if permissionsGenerator != nil {
		return permissionsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPermissions(generators)
	permissionsGenerator = gen.Struct(reflect.TypeOf(Permissions{}), generators)

	return permissionsGenerator
}

// AddIndependentPropertyGeneratorsForPermissions is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPermissions(gens map[string]gopter.Gen) {
	gens["Certificates"] = gen.SliceOf(gen.OneConstOf(
		PermissionsCertificatesBackup,
		PermissionsCertificatesCreate,
		PermissionsCertificatesDelete,
		PermissionsCertificatesDeleteissuers,
		PermissionsCertificatesGet,
		PermissionsCertificatesGetissuers,
		PermissionsCertificatesImport,
		PermissionsCertificatesList,
		PermissionsCertificatesListissuers,
		PermissionsCertificatesManagecontacts,
		PermissionsCertificatesManageissuers,
		PermissionsCertificatesPurge,
		PermissionsCertificatesRecover,
		PermissionsCertificatesRestore,
		PermissionsCertificatesSetissuers,
		PermissionsCertificatesUpdate))
	gens["Keys"] = gen.SliceOf(gen.OneConstOf(
		PermissionsKeysBackup,
		PermissionsKeysCreate,
		PermissionsKeysDecrypt,
		PermissionsKeysDelete,
		PermissionsKeysEncrypt,
		PermissionsKeysGet,
		PermissionsKeysImport,
		PermissionsKeysList,
		PermissionsKeysPurge,
		PermissionsKeysRecover,
		PermissionsKeysRelease,
		PermissionsKeysRestore,
		PermissionsKeysSign,
		PermissionsKeysUnwrapKey,
		PermissionsKeysUpdate,
		PermissionsKeysVerify,
		PermissionsKeysWrapKey))
	gens["Secrets"] = gen.SliceOf(gen.OneConstOf(
		PermissionsSecretsBackup,
		PermissionsSecretsDelete,
		PermissionsSecretsGet,
		PermissionsSecretsList,
		PermissionsSecretsPurge,
		PermissionsSecretsRecover,
		PermissionsSecretsRestore,
		PermissionsSecretsSet))
	gens["Storage"] = gen.SliceOf(gen.OneConstOf(
		PermissionsStorageBackup,
		PermissionsStorageDelete,
		PermissionsStorageDeletesas,
		PermissionsStorageGet,
		PermissionsStorageGetsas,
		PermissionsStorageList,
		PermissionsStorageListsas,
		PermissionsStoragePurge,
		PermissionsStorageRecover,
		PermissionsStorageRegeneratekey,
		PermissionsStorageRestore,
		PermissionsStorageSet,
		PermissionsStorageSetsas,
		PermissionsStorageUpdate))
}

func Test_Permissions_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Permissions_Status to Permissions_Status via AssignPropertiesToPermissionsStatus & AssignPropertiesFromPermissionsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForPermissionsStatus, PermissionsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPermissionsStatus tests if a specific instance of Permissions_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForPermissionsStatus(subject Permissions_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.Permissions_Status
	err := copied.AssignPropertiesToPermissionsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Permissions_Status
	err = actual.AssignPropertiesFromPermissionsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Permissions_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Permissions_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPermissionsStatus, PermissionsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPermissionsStatus runs a test to see if a specific instance of Permissions_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPermissionsStatus(subject Permissions_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Permissions_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Permissions_Status instances for property testing - lazily instantiated by PermissionsStatusGenerator()
var permissionsStatusGenerator gopter.Gen

// PermissionsStatusGenerator returns a generator of Permissions_Status instances for property testing.
func PermissionsStatusGenerator() gopter.Gen {
	if permissionsStatusGenerator != nil {
		return permissionsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPermissionsStatus(generators)
	permissionsStatusGenerator = gen.Struct(reflect.TypeOf(Permissions_Status{}), generators)

	return permissionsStatusGenerator
}

// AddIndependentPropertyGeneratorsForPermissionsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPermissionsStatus(gens map[string]gopter.Gen) {
	gens["Certificates"] = gen.SliceOf(gen.OneConstOf(
		PermissionsStatusCertificatesBackup,
		PermissionsStatusCertificatesCreate,
		PermissionsStatusCertificatesDelete,
		PermissionsStatusCertificatesDeleteissuers,
		PermissionsStatusCertificatesGet,
		PermissionsStatusCertificatesGetissuers,
		PermissionsStatusCertificatesImport,
		PermissionsStatusCertificatesList,
		PermissionsStatusCertificatesListissuers,
		PermissionsStatusCertificatesManagecontacts,
		PermissionsStatusCertificatesManageissuers,
		PermissionsStatusCertificatesPurge,
		PermissionsStatusCertificatesRecover,
		PermissionsStatusCertificatesRestore,
		PermissionsStatusCertificatesSetissuers,
		PermissionsStatusCertificatesUpdate))
	gens["Keys"] = gen.SliceOf(gen.OneConstOf(
		PermissionsStatusKeysBackup,
		PermissionsStatusKeysCreate,
		PermissionsStatusKeysDecrypt,
		PermissionsStatusKeysDelete,
		PermissionsStatusKeysEncrypt,
		PermissionsStatusKeysGet,
		PermissionsStatusKeysImport,
		PermissionsStatusKeysList,
		PermissionsStatusKeysPurge,
		PermissionsStatusKeysRecover,
		PermissionsStatusKeysRelease,
		PermissionsStatusKeysRestore,
		PermissionsStatusKeysSign,
		PermissionsStatusKeysUnwrapKey,
		PermissionsStatusKeysUpdate,
		PermissionsStatusKeysVerify,
		PermissionsStatusKeysWrapKey))
	gens["Secrets"] = gen.SliceOf(gen.OneConstOf(
		PermissionsStatusSecretsBackup,
		PermissionsStatusSecretsDelete,
		PermissionsStatusSecretsGet,
		PermissionsStatusSecretsList,
		PermissionsStatusSecretsPurge,
		PermissionsStatusSecretsRecover,
		PermissionsStatusSecretsRestore,
		PermissionsStatusSecretsSet))
	gens["Storage"] = gen.SliceOf(gen.OneConstOf(
		PermissionsStatusStorageBackup,
		PermissionsStatusStorageDelete,
		PermissionsStatusStorageDeletesas,
		PermissionsStatusStorageGet,
		PermissionsStatusStorageGetsas,
		PermissionsStatusStorageList,
		PermissionsStatusStorageListsas,
		PermissionsStatusStoragePurge,
		PermissionsStatusStorageRecover,
		PermissionsStatusStorageRegeneratekey,
		PermissionsStatusStorageRestore,
		PermissionsStatusStorageSet,
		PermissionsStatusStorageSetsas,
		PermissionsStatusStorageUpdate))
}

func Test_PrivateEndpoint_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpoint_Status to PrivateEndpoint_Status via AssignPropertiesToPrivateEndpointStatus & AssignPropertiesFromPrivateEndpointStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointStatus, PrivateEndpointStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointStatus tests if a specific instance of PrivateEndpoint_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointStatus(subject PrivateEndpoint_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.PrivateEndpoint_Status
	err := copied.AssignPropertiesToPrivateEndpointStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpoint_Status
	err = actual.AssignPropertiesFromPrivateEndpointStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpoint_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointStatus, PrivateEndpointStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointStatus runs a test to see if a specific instance of PrivateEndpoint_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointStatus(subject PrivateEndpoint_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_Status instances for property testing - lazily instantiated by
// PrivateEndpointStatusGenerator()
var privateEndpointStatusGenerator gopter.Gen

// PrivateEndpointStatusGenerator returns a generator of PrivateEndpoint_Status instances for property testing.
func PrivateEndpointStatusGenerator() gopter.Gen {
	if privateEndpointStatusGenerator != nil {
		return privateEndpointStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointStatus(generators)
	privateEndpointStatusGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Status{}), generators)

	return privateEndpointStatusGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceConnectionState_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateLinkServiceConnectionState_Status to PrivateLinkServiceConnectionState_Status via AssignPropertiesToPrivateLinkServiceConnectionStateStatus & AssignPropertiesFromPrivateLinkServiceConnectionStateStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateLinkServiceConnectionStateStatus, PrivateLinkServiceConnectionStateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateLinkServiceConnectionStateStatus tests if a specific instance of PrivateLinkServiceConnectionState_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForPrivateLinkServiceConnectionStateStatus(subject PrivateLinkServiceConnectionState_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.PrivateLinkServiceConnectionState_Status
	err := copied.AssignPropertiesToPrivateLinkServiceConnectionStateStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateLinkServiceConnectionState_Status
	err = actual.AssignPropertiesFromPrivateLinkServiceConnectionStateStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateLinkServiceConnectionState_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceConnectionState_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceConnectionStateStatus, PrivateLinkServiceConnectionStateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceConnectionStateStatus runs a test to see if a specific instance of PrivateLinkServiceConnectionState_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceConnectionStateStatus(subject PrivateLinkServiceConnectionState_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceConnectionState_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceConnectionState_Status instances for property testing - lazily instantiated by
// PrivateLinkServiceConnectionStateStatusGenerator()
var privateLinkServiceConnectionStateStatusGenerator gopter.Gen

// PrivateLinkServiceConnectionStateStatusGenerator returns a generator of PrivateLinkServiceConnectionState_Status instances for property testing.
func PrivateLinkServiceConnectionStateStatusGenerator() gopter.Gen {
	if privateLinkServiceConnectionStateStatusGenerator != nil {
		return privateLinkServiceConnectionStateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateStatus(generators)
	privateLinkServiceConnectionStateStatusGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState_Status{}), generators)

	return privateLinkServiceConnectionStateStatusGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateStatus(gens map[string]gopter.Gen) {
	gens["ActionsRequired"] = gen.PtrOf(gen.OneConstOf(PrivateLinkServiceConnectionStateStatusActionsRequiredNone))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointServiceConnectionStatus_StatusApproved,
		PrivateEndpointServiceConnectionStatus_StatusDisconnected,
		PrivateEndpointServiceConnectionStatus_StatusPending,
		PrivateEndpointServiceConnectionStatus_StatusRejected))
}

func Test_VirtualNetworkRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule to VirtualNetworkRule via AssignPropertiesToVirtualNetworkRule & AssignPropertiesFromVirtualNetworkRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRule, VirtualNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRule tests if a specific instance of VirtualNetworkRule can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRule(subject VirtualNetworkRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.VirtualNetworkRule
	err := copied.AssignPropertiesToVirtualNetworkRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule
	err = actual.AssignPropertiesFromVirtualNetworkRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule, VirtualNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule runs a test to see if a specific instance of VirtualNetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule(subject VirtualNetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule instances for property testing - lazily instantiated by VirtualNetworkRuleGenerator()
var virtualNetworkRuleGenerator gopter.Gen

// VirtualNetworkRuleGenerator returns a generator of VirtualNetworkRule instances for property testing.
func VirtualNetworkRuleGenerator() gopter.Gen {
	if virtualNetworkRuleGenerator != nil {
		return virtualNetworkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule(generators)
	virtualNetworkRuleGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule{}), generators)

	return virtualNetworkRuleGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule(gens map[string]gopter.Gen) {
	gens["IgnoreMissingVnetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_VirtualNetworkRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule_Status to VirtualNetworkRule_Status via AssignPropertiesToVirtualNetworkRuleStatus & AssignPropertiesFromVirtualNetworkRuleStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRuleStatus, VirtualNetworkRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRuleStatus tests if a specific instance of VirtualNetworkRule_Status can be assigned to v1beta20210401previewstorage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRuleStatus(subject VirtualNetworkRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210401ps.VirtualNetworkRule_Status
	err := copied.AssignPropertiesToVirtualNetworkRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule_Status
	err = actual.AssignPropertiesFromVirtualNetworkRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleStatus, VirtualNetworkRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleStatus runs a test to see if a specific instance of VirtualNetworkRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleStatus(subject VirtualNetworkRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Status instances for property testing - lazily instantiated by
// VirtualNetworkRuleStatusGenerator()
var virtualNetworkRuleStatusGenerator gopter.Gen

// VirtualNetworkRuleStatusGenerator returns a generator of VirtualNetworkRule_Status instances for property testing.
func VirtualNetworkRuleStatusGenerator() gopter.Gen {
	if virtualNetworkRuleStatusGenerator != nil {
		return virtualNetworkRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus(generators)
	virtualNetworkRuleStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Status{}), generators)

	return virtualNetworkRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVnetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}
