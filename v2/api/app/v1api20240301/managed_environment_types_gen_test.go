// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AppLogsConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AppLogsConfiguration to AppLogsConfiguration via AssignProperties_To_AppLogsConfiguration & AssignProperties_From_AppLogsConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForAppLogsConfiguration, AppLogsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAppLogsConfiguration tests if a specific instance of AppLogsConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAppLogsConfiguration(subject AppLogsConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AppLogsConfiguration
	err := copied.AssignProperties_To_AppLogsConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AppLogsConfiguration
	err = actual.AssignProperties_From_AppLogsConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AppLogsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AppLogsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAppLogsConfiguration, AppLogsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAppLogsConfiguration runs a test to see if a specific instance of AppLogsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForAppLogsConfiguration(subject AppLogsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AppLogsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AppLogsConfiguration instances for property testing - lazily instantiated by
// AppLogsConfigurationGenerator()
var appLogsConfigurationGenerator gopter.Gen

// AppLogsConfigurationGenerator returns a generator of AppLogsConfiguration instances for property testing.
// We first initialize appLogsConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AppLogsConfigurationGenerator() gopter.Gen {
	if appLogsConfigurationGenerator != nil {
		return appLogsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppLogsConfiguration(generators)
	appLogsConfigurationGenerator = gen.Struct(reflect.TypeOf(AppLogsConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppLogsConfiguration(generators)
	AddRelatedPropertyGeneratorsForAppLogsConfiguration(generators)
	appLogsConfigurationGenerator = gen.Struct(reflect.TypeOf(AppLogsConfiguration{}), generators)

	return appLogsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForAppLogsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAppLogsConfiguration(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAppLogsConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAppLogsConfiguration(gens map[string]gopter.Gen) {
	gens["LogAnalyticsConfiguration"] = gen.PtrOf(LogAnalyticsConfigurationGenerator())
}

func Test_AppLogsConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AppLogsConfiguration_STATUS to AppLogsConfiguration_STATUS via AssignProperties_To_AppLogsConfiguration_STATUS & AssignProperties_From_AppLogsConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAppLogsConfiguration_STATUS, AppLogsConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAppLogsConfiguration_STATUS tests if a specific instance of AppLogsConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAppLogsConfiguration_STATUS(subject AppLogsConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AppLogsConfiguration_STATUS
	err := copied.AssignProperties_To_AppLogsConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AppLogsConfiguration_STATUS
	err = actual.AssignProperties_From_AppLogsConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AppLogsConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AppLogsConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAppLogsConfiguration_STATUS, AppLogsConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAppLogsConfiguration_STATUS runs a test to see if a specific instance of AppLogsConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAppLogsConfiguration_STATUS(subject AppLogsConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AppLogsConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AppLogsConfiguration_STATUS instances for property testing - lazily instantiated by
// AppLogsConfiguration_STATUSGenerator()
var appLogsConfiguration_STATUSGenerator gopter.Gen

// AppLogsConfiguration_STATUSGenerator returns a generator of AppLogsConfiguration_STATUS instances for property testing.
// We first initialize appLogsConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AppLogsConfiguration_STATUSGenerator() gopter.Gen {
	if appLogsConfiguration_STATUSGenerator != nil {
		return appLogsConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppLogsConfiguration_STATUS(generators)
	appLogsConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(AppLogsConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppLogsConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForAppLogsConfiguration_STATUS(generators)
	appLogsConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(AppLogsConfiguration_STATUS{}), generators)

	return appLogsConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAppLogsConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAppLogsConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAppLogsConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAppLogsConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["LogAnalyticsConfiguration"] = gen.PtrOf(LogAnalyticsConfiguration_STATUSGenerator())
}

func Test_CustomDomainConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomainConfiguration to CustomDomainConfiguration via AssignProperties_To_CustomDomainConfiguration & AssignProperties_From_CustomDomainConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomainConfiguration, CustomDomainConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomainConfiguration tests if a specific instance of CustomDomainConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomDomainConfiguration(subject CustomDomainConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomDomainConfiguration
	err := copied.AssignProperties_To_CustomDomainConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomainConfiguration
	err = actual.AssignProperties_From_CustomDomainConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomainConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomainConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainConfiguration, CustomDomainConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainConfiguration runs a test to see if a specific instance of CustomDomainConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainConfiguration(subject CustomDomainConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomainConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomainConfiguration instances for property testing - lazily instantiated by
// CustomDomainConfigurationGenerator()
var customDomainConfigurationGenerator gopter.Gen

// CustomDomainConfigurationGenerator returns a generator of CustomDomainConfiguration instances for property testing.
func CustomDomainConfigurationGenerator() gopter.Gen {
	if customDomainConfigurationGenerator != nil {
		return customDomainConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainConfiguration(generators)
	customDomainConfigurationGenerator = gen.Struct(reflect.TypeOf(CustomDomainConfiguration{}), generators)

	return customDomainConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainConfiguration(gens map[string]gopter.Gen) {
	gens["DnsSuffix"] = gen.PtrOf(gen.AlphaString())
}

func Test_CustomDomainConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomainConfiguration_STATUS to CustomDomainConfiguration_STATUS via AssignProperties_To_CustomDomainConfiguration_STATUS & AssignProperties_From_CustomDomainConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomainConfiguration_STATUS, CustomDomainConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomainConfiguration_STATUS tests if a specific instance of CustomDomainConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomDomainConfiguration_STATUS(subject CustomDomainConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomDomainConfiguration_STATUS
	err := copied.AssignProperties_To_CustomDomainConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomainConfiguration_STATUS
	err = actual.AssignProperties_From_CustomDomainConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomainConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomainConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainConfiguration_STATUS, CustomDomainConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainConfiguration_STATUS runs a test to see if a specific instance of CustomDomainConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainConfiguration_STATUS(subject CustomDomainConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomainConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomainConfiguration_STATUS instances for property testing - lazily instantiated by
// CustomDomainConfiguration_STATUSGenerator()
var customDomainConfiguration_STATUSGenerator gopter.Gen

// CustomDomainConfiguration_STATUSGenerator returns a generator of CustomDomainConfiguration_STATUS instances for property testing.
func CustomDomainConfiguration_STATUSGenerator() gopter.Gen {
	if customDomainConfiguration_STATUSGenerator != nil {
		return customDomainConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainConfiguration_STATUS(generators)
	customDomainConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomDomainConfiguration_STATUS{}), generators)

	return customDomainConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["DnsSuffix"] = gen.PtrOf(gen.AlphaString())
	gens["ExpirationDate"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectName"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_DaprConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DaprConfiguration_STATUS to DaprConfiguration_STATUS via AssignProperties_To_DaprConfiguration_STATUS & AssignProperties_From_DaprConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDaprConfiguration_STATUS, DaprConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDaprConfiguration_STATUS tests if a specific instance of DaprConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDaprConfiguration_STATUS(subject DaprConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DaprConfiguration_STATUS
	err := copied.AssignProperties_To_DaprConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DaprConfiguration_STATUS
	err = actual.AssignProperties_From_DaprConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DaprConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DaprConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDaprConfiguration_STATUS, DaprConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDaprConfiguration_STATUS runs a test to see if a specific instance of DaprConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDaprConfiguration_STATUS(subject DaprConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DaprConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DaprConfiguration_STATUS instances for property testing - lazily instantiated by
// DaprConfiguration_STATUSGenerator()
var daprConfiguration_STATUSGenerator gopter.Gen

// DaprConfiguration_STATUSGenerator returns a generator of DaprConfiguration_STATUS instances for property testing.
func DaprConfiguration_STATUSGenerator() gopter.Gen {
	if daprConfiguration_STATUSGenerator != nil {
		return daprConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDaprConfiguration_STATUS(generators)
	daprConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(DaprConfiguration_STATUS{}), generators)

	return daprConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDaprConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDaprConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_KedaConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KedaConfiguration_STATUS to KedaConfiguration_STATUS via AssignProperties_To_KedaConfiguration_STATUS & AssignProperties_From_KedaConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKedaConfiguration_STATUS, KedaConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKedaConfiguration_STATUS tests if a specific instance of KedaConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKedaConfiguration_STATUS(subject KedaConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KedaConfiguration_STATUS
	err := copied.AssignProperties_To_KedaConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KedaConfiguration_STATUS
	err = actual.AssignProperties_From_KedaConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KedaConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KedaConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKedaConfiguration_STATUS, KedaConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKedaConfiguration_STATUS runs a test to see if a specific instance of KedaConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKedaConfiguration_STATUS(subject KedaConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KedaConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KedaConfiguration_STATUS instances for property testing - lazily instantiated by
// KedaConfiguration_STATUSGenerator()
var kedaConfiguration_STATUSGenerator gopter.Gen

// KedaConfiguration_STATUSGenerator returns a generator of KedaConfiguration_STATUS instances for property testing.
func KedaConfiguration_STATUSGenerator() gopter.Gen {
	if kedaConfiguration_STATUSGenerator != nil {
		return kedaConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKedaConfiguration_STATUS(generators)
	kedaConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(KedaConfiguration_STATUS{}), generators)

	return kedaConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKedaConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKedaConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalyticsConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogAnalyticsConfiguration to LogAnalyticsConfiguration via AssignProperties_To_LogAnalyticsConfiguration & AssignProperties_From_LogAnalyticsConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogAnalyticsConfiguration, LogAnalyticsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogAnalyticsConfiguration tests if a specific instance of LogAnalyticsConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogAnalyticsConfiguration(subject LogAnalyticsConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogAnalyticsConfiguration
	err := copied.AssignProperties_To_LogAnalyticsConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogAnalyticsConfiguration
	err = actual.AssignProperties_From_LogAnalyticsConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogAnalyticsConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalyticsConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsConfiguration, LogAnalyticsConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsConfiguration runs a test to see if a specific instance of LogAnalyticsConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsConfiguration(subject LogAnalyticsConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalyticsConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalyticsConfiguration instances for property testing - lazily instantiated by
// LogAnalyticsConfigurationGenerator()
var logAnalyticsConfigurationGenerator gopter.Gen

// LogAnalyticsConfigurationGenerator returns a generator of LogAnalyticsConfiguration instances for property testing.
func LogAnalyticsConfigurationGenerator() gopter.Gen {
	if logAnalyticsConfigurationGenerator != nil {
		return logAnalyticsConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsConfiguration(generators)
	logAnalyticsConfigurationGenerator = gen.Struct(reflect.TypeOf(LogAnalyticsConfiguration{}), generators)

	return logAnalyticsConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsConfiguration(gens map[string]gopter.Gen) {
	gens["CustomerId"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalyticsConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogAnalyticsConfiguration_STATUS to LogAnalyticsConfiguration_STATUS via AssignProperties_To_LogAnalyticsConfiguration_STATUS & AssignProperties_From_LogAnalyticsConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogAnalyticsConfiguration_STATUS, LogAnalyticsConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogAnalyticsConfiguration_STATUS tests if a specific instance of LogAnalyticsConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogAnalyticsConfiguration_STATUS(subject LogAnalyticsConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogAnalyticsConfiguration_STATUS
	err := copied.AssignProperties_To_LogAnalyticsConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogAnalyticsConfiguration_STATUS
	err = actual.AssignProperties_From_LogAnalyticsConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogAnalyticsConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalyticsConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsConfiguration_STATUS, LogAnalyticsConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsConfiguration_STATUS runs a test to see if a specific instance of LogAnalyticsConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsConfiguration_STATUS(subject LogAnalyticsConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalyticsConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalyticsConfiguration_STATUS instances for property testing - lazily instantiated by
// LogAnalyticsConfiguration_STATUSGenerator()
var logAnalyticsConfiguration_STATUSGenerator gopter.Gen

// LogAnalyticsConfiguration_STATUSGenerator returns a generator of LogAnalyticsConfiguration_STATUS instances for property testing.
func LogAnalyticsConfiguration_STATUSGenerator() gopter.Gen {
	if logAnalyticsConfiguration_STATUSGenerator != nil {
		return logAnalyticsConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsConfiguration_STATUS(generators)
	logAnalyticsConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(LogAnalyticsConfiguration_STATUS{}), generators)

	return logAnalyticsConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CustomerId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedEnvironment_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment to hub returns original",
		prop.ForAll(RunResourceConversionTestForManagedEnvironment, ManagedEnvironmentGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForManagedEnvironment tests if a specific instance of ManagedEnvironment round trips to the hub storage version and back losslessly
func RunResourceConversionTestForManagedEnvironment(subject ManagedEnvironment) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.ManagedEnvironment
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ManagedEnvironment
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment to ManagedEnvironment via AssignProperties_To_ManagedEnvironment & AssignProperties_From_ManagedEnvironment returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment, ManagedEnvironmentGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment tests if a specific instance of ManagedEnvironment can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment(subject ManagedEnvironment) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment
	err := copied.AssignProperties_To_ManagedEnvironment(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment
	err = actual.AssignProperties_From_ManagedEnvironment(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment, ManagedEnvironmentGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment runs a test to see if a specific instance of ManagedEnvironment round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment(subject ManagedEnvironment) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment instances for property testing - lazily instantiated by ManagedEnvironmentGenerator()
var managedEnvironmentGenerator gopter.Gen

// ManagedEnvironmentGenerator returns a generator of ManagedEnvironment instances for property testing.
func ManagedEnvironmentGenerator() gopter.Gen {
	if managedEnvironmentGenerator != nil {
		return managedEnvironmentGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedEnvironment(generators)
	managedEnvironmentGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment{}), generators)

	return managedEnvironmentGenerator
}

// AddRelatedPropertyGeneratorsForManagedEnvironment is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedEnvironment(gens map[string]gopter.Gen) {
	gens["Spec"] = ManagedEnvironment_SpecGenerator()
	gens["Status"] = ManagedEnvironment_STATUSGenerator()
}

func Test_ManagedEnvironmentOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironmentOperatorSpec to ManagedEnvironmentOperatorSpec via AssignProperties_To_ManagedEnvironmentOperatorSpec & AssignProperties_From_ManagedEnvironmentOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironmentOperatorSpec, ManagedEnvironmentOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironmentOperatorSpec tests if a specific instance of ManagedEnvironmentOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironmentOperatorSpec(subject ManagedEnvironmentOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironmentOperatorSpec
	err := copied.AssignProperties_To_ManagedEnvironmentOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironmentOperatorSpec
	err = actual.AssignProperties_From_ManagedEnvironmentOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironmentOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironmentOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironmentOperatorSpec, ManagedEnvironmentOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironmentOperatorSpec runs a test to see if a specific instance of ManagedEnvironmentOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironmentOperatorSpec(subject ManagedEnvironmentOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironmentOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironmentOperatorSpec instances for property testing - lazily instantiated by
// ManagedEnvironmentOperatorSpecGenerator()
var managedEnvironmentOperatorSpecGenerator gopter.Gen

// ManagedEnvironmentOperatorSpecGenerator returns a generator of ManagedEnvironmentOperatorSpec instances for property testing.
func ManagedEnvironmentOperatorSpecGenerator() gopter.Gen {
	if managedEnvironmentOperatorSpecGenerator != nil {
		return managedEnvironmentOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	managedEnvironmentOperatorSpecGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironmentOperatorSpec{}), generators)

	return managedEnvironmentOperatorSpecGenerator
}

func Test_ManagedEnvironment_Properties_PeerAuthentication_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment_Properties_PeerAuthentication_STATUS to ManagedEnvironment_Properties_PeerAuthentication_STATUS via AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_STATUS & AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerAuthentication_STATUS, ManagedEnvironment_Properties_PeerAuthentication_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerAuthentication_STATUS tests if a specific instance of ManagedEnvironment_Properties_PeerAuthentication_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerAuthentication_STATUS(subject ManagedEnvironment_Properties_PeerAuthentication_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment_Properties_PeerAuthentication_STATUS
	err := copied.AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment_Properties_PeerAuthentication_STATUS
	err = actual.AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_Properties_PeerAuthentication_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment_Properties_PeerAuthentication_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment_Properties_PeerAuthentication_STATUS, ManagedEnvironment_Properties_PeerAuthentication_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment_Properties_PeerAuthentication_STATUS runs a test to see if a specific instance of ManagedEnvironment_Properties_PeerAuthentication_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment_Properties_PeerAuthentication_STATUS(subject ManagedEnvironment_Properties_PeerAuthentication_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment_Properties_PeerAuthentication_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment_Properties_PeerAuthentication_STATUS instances for property testing - lazily
// instantiated by ManagedEnvironment_Properties_PeerAuthentication_STATUSGenerator()
var managedEnvironment_Properties_PeerAuthentication_STATUSGenerator gopter.Gen

// ManagedEnvironment_Properties_PeerAuthentication_STATUSGenerator returns a generator of ManagedEnvironment_Properties_PeerAuthentication_STATUS instances for property testing.
func ManagedEnvironment_Properties_PeerAuthentication_STATUSGenerator() gopter.Gen {
	if managedEnvironment_Properties_PeerAuthentication_STATUSGenerator != nil {
		return managedEnvironment_Properties_PeerAuthentication_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerAuthentication_STATUS(generators)
	managedEnvironment_Properties_PeerAuthentication_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_Properties_PeerAuthentication_STATUS{}), generators)

	return managedEnvironment_Properties_PeerAuthentication_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerAuthentication_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerAuthentication_STATUS(gens map[string]gopter.Gen) {
	gens["Mtls"] = gen.PtrOf(Mtls_STATUSGenerator())
}

func Test_ManagedEnvironment_Properties_PeerAuthentication_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment_Properties_PeerAuthentication_Spec to ManagedEnvironment_Properties_PeerAuthentication_Spec via AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_Spec & AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerAuthentication_Spec, ManagedEnvironment_Properties_PeerAuthentication_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerAuthentication_Spec tests if a specific instance of ManagedEnvironment_Properties_PeerAuthentication_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerAuthentication_Spec(subject ManagedEnvironment_Properties_PeerAuthentication_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment_Properties_PeerAuthentication_Spec
	err := copied.AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment_Properties_PeerAuthentication_Spec
	err = actual.AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_Properties_PeerAuthentication_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment_Properties_PeerAuthentication_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment_Properties_PeerAuthentication_Spec, ManagedEnvironment_Properties_PeerAuthentication_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment_Properties_PeerAuthentication_Spec runs a test to see if a specific instance of ManagedEnvironment_Properties_PeerAuthentication_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment_Properties_PeerAuthentication_Spec(subject ManagedEnvironment_Properties_PeerAuthentication_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment_Properties_PeerAuthentication_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment_Properties_PeerAuthentication_Spec instances for property testing - lazily
// instantiated by ManagedEnvironment_Properties_PeerAuthentication_SpecGenerator()
var managedEnvironment_Properties_PeerAuthentication_SpecGenerator gopter.Gen

// ManagedEnvironment_Properties_PeerAuthentication_SpecGenerator returns a generator of ManagedEnvironment_Properties_PeerAuthentication_Spec instances for property testing.
func ManagedEnvironment_Properties_PeerAuthentication_SpecGenerator() gopter.Gen {
	if managedEnvironment_Properties_PeerAuthentication_SpecGenerator != nil {
		return managedEnvironment_Properties_PeerAuthentication_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerAuthentication_Spec(generators)
	managedEnvironment_Properties_PeerAuthentication_SpecGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_Properties_PeerAuthentication_Spec{}), generators)

	return managedEnvironment_Properties_PeerAuthentication_SpecGenerator
}

// AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerAuthentication_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerAuthentication_Spec(gens map[string]gopter.Gen) {
	gens["Mtls"] = gen.PtrOf(MtlsGenerator())
}

func Test_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS to ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS via AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS & AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS, ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS tests if a specific instance of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(subject ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
	err := copied.AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
	err = actual.AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS, ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS runs a test to see if a specific instance of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(subject ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS instances for property testing
// - lazily instantiated by ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator()
var managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator gopter.Gen

// ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator returns a generator of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS instances for property testing.
func ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator() gopter.Gen {
	if managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator != nil {
		return managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(generators)
	managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS{}), generators)

	return managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec to ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec via AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec & AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec, ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec tests if a specific instance of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(subject ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
	err := copied.AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
	err = actual.AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec, ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec runs a test to see if a specific instance of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(subject ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec instances for property testing -
// lazily instantiated by ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator()
var managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator gopter.Gen

// ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator returns a generator of ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec instances for property testing.
func ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator() gopter.Gen {
	if managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator != nil {
		return managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(generators)
	managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec{}), generators)

	return managedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS to ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS via AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS & AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS, ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS tests if a specific instance of ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(subject ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
	err := copied.AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
	err = actual.AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS, ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS runs a test to see if a specific instance of ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(subject ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS instances for property testing - lazily
// instantiated by ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator()
var managedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator gopter.Gen

// ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator returns a generator of ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS instances for property testing.
func ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator() gopter.Gen {
	if managedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator != nil {
		return managedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(generators)
	managedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS{}), generators)

	return managedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUSGenerator())
}

func Test_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec to ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec via AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec & AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec, ManagedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec tests if a specific instance of ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(subject ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
	err := copied.AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
	err = actual.AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec, ManagedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec runs a test to see if a specific instance of ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(subject ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec instances for property testing - lazily
// instantiated by ManagedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator()
var managedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator gopter.Gen

// ManagedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator returns a generator of ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec instances for property testing.
func ManagedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator() gopter.Gen {
	if managedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator != nil {
		return managedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(generators)
	managedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec{}), generators)

	return managedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator
}

// AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_SpecGenerator())
}

func Test_ManagedEnvironment_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment_STATUS to ManagedEnvironment_STATUS via AssignProperties_To_ManagedEnvironment_STATUS & AssignProperties_From_ManagedEnvironment_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment_STATUS, ManagedEnvironment_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment_STATUS tests if a specific instance of ManagedEnvironment_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment_STATUS(subject ManagedEnvironment_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment_STATUS
	err := copied.AssignProperties_To_ManagedEnvironment_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment_STATUS
	err = actual.AssignProperties_From_ManagedEnvironment_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment_STATUS, ManagedEnvironment_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment_STATUS runs a test to see if a specific instance of ManagedEnvironment_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment_STATUS(subject ManagedEnvironment_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment_STATUS instances for property testing - lazily instantiated by
// ManagedEnvironment_STATUSGenerator()
var managedEnvironment_STATUSGenerator gopter.Gen

// ManagedEnvironment_STATUSGenerator returns a generator of ManagedEnvironment_STATUS instances for property testing.
// We first initialize managedEnvironment_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedEnvironment_STATUSGenerator() gopter.Gen {
	if managedEnvironment_STATUSGenerator != nil {
		return managedEnvironment_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedEnvironment_STATUS(generators)
	managedEnvironment_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedEnvironment_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedEnvironment_STATUS(generators)
	managedEnvironment_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_STATUS{}), generators)

	return managedEnvironment_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedEnvironment_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedEnvironment_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultDomain"] = gen.PtrOf(gen.AlphaString())
	gens["DeploymentErrors"] = gen.PtrOf(gen.AlphaString())
	gens["EventStreamEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["InfrastructureResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ManagedEnvironment_Properties_ProvisioningState_STATUS_Canceled,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_Failed,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_InfrastructureSetupComplete,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_InfrastructureSetupInProgress,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_InitializationInProgress,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_ScheduledForDelete,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_Succeeded,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_UpgradeFailed,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_UpgradeRequested,
		ManagedEnvironment_Properties_ProvisioningState_STATUS_Waiting))
	gens["StaticIp"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundant"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagedEnvironment_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedEnvironment_STATUS(gens map[string]gopter.Gen) {
	gens["AppLogsConfiguration"] = gen.PtrOf(AppLogsConfiguration_STATUSGenerator())
	gens["CustomDomainConfiguration"] = gen.PtrOf(CustomDomainConfiguration_STATUSGenerator())
	gens["DaprConfiguration"] = gen.PtrOf(DaprConfiguration_STATUSGenerator())
	gens["KedaConfiguration"] = gen.PtrOf(KedaConfiguration_STATUSGenerator())
	gens["PeerAuthentication"] = gen.PtrOf(ManagedEnvironment_Properties_PeerAuthentication_STATUSGenerator())
	gens["PeerTrafficConfiguration"] = gen.PtrOf(ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
	gens["VnetConfiguration"] = gen.PtrOf(VnetConfiguration_STATUSGenerator())
	gens["WorkloadProfiles"] = gen.SliceOf(WorkloadProfile_STATUSGenerator())
}

func Test_ManagedEnvironment_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedEnvironment_Spec to ManagedEnvironment_Spec via AssignProperties_To_ManagedEnvironment_Spec & AssignProperties_From_ManagedEnvironment_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedEnvironment_Spec, ManagedEnvironment_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedEnvironment_Spec tests if a specific instance of ManagedEnvironment_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedEnvironment_Spec(subject ManagedEnvironment_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedEnvironment_Spec
	err := copied.AssignProperties_To_ManagedEnvironment_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedEnvironment_Spec
	err = actual.AssignProperties_From_ManagedEnvironment_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedEnvironment_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedEnvironment_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedEnvironment_Spec, ManagedEnvironment_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedEnvironment_Spec runs a test to see if a specific instance of ManagedEnvironment_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedEnvironment_Spec(subject ManagedEnvironment_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedEnvironment_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedEnvironment_Spec instances for property testing - lazily instantiated by
// ManagedEnvironment_SpecGenerator()
var managedEnvironment_SpecGenerator gopter.Gen

// ManagedEnvironment_SpecGenerator returns a generator of ManagedEnvironment_Spec instances for property testing.
// We first initialize managedEnvironment_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedEnvironment_SpecGenerator() gopter.Gen {
	if managedEnvironment_SpecGenerator != nil {
		return managedEnvironment_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedEnvironment_Spec(generators)
	managedEnvironment_SpecGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedEnvironment_Spec(generators)
	AddRelatedPropertyGeneratorsForManagedEnvironment_Spec(generators)
	managedEnvironment_SpecGenerator = gen.Struct(reflect.TypeOf(ManagedEnvironment_Spec{}), generators)

	return managedEnvironment_SpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedEnvironment_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedEnvironment_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["InfrastructureResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ZoneRedundant"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagedEnvironment_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedEnvironment_Spec(gens map[string]gopter.Gen) {
	gens["AppLogsConfiguration"] = gen.PtrOf(AppLogsConfigurationGenerator())
	gens["CustomDomainConfiguration"] = gen.PtrOf(CustomDomainConfigurationGenerator())
	gens["OperatorSpec"] = gen.PtrOf(ManagedEnvironmentOperatorSpecGenerator())
	gens["PeerAuthentication"] = gen.PtrOf(ManagedEnvironment_Properties_PeerAuthentication_SpecGenerator())
	gens["PeerTrafficConfiguration"] = gen.PtrOf(ManagedEnvironment_Properties_PeerTrafficConfiguration_SpecGenerator())
	gens["VnetConfiguration"] = gen.PtrOf(VnetConfigurationGenerator())
	gens["WorkloadProfiles"] = gen.SliceOf(WorkloadProfileGenerator())
}

func Test_Mtls_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Mtls to Mtls via AssignProperties_To_Mtls & AssignProperties_From_Mtls returns original",
		prop.ForAll(RunPropertyAssignmentTestForMtls, MtlsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMtls tests if a specific instance of Mtls can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMtls(subject Mtls) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Mtls
	err := copied.AssignProperties_To_Mtls(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Mtls
	err = actual.AssignProperties_From_Mtls(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Mtls_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Mtls via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMtls, MtlsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMtls runs a test to see if a specific instance of Mtls round trips to JSON and back losslessly
func RunJSONSerializationTestForMtls(subject Mtls) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Mtls
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Mtls instances for property testing - lazily instantiated by MtlsGenerator()
var mtlsGenerator gopter.Gen

// MtlsGenerator returns a generator of Mtls instances for property testing.
func MtlsGenerator() gopter.Gen {
	if mtlsGenerator != nil {
		return mtlsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMtls(generators)
	mtlsGenerator = gen.Struct(reflect.TypeOf(Mtls{}), generators)

	return mtlsGenerator
}

// AddIndependentPropertyGeneratorsForMtls is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMtls(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_Mtls_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Mtls_STATUS to Mtls_STATUS via AssignProperties_To_Mtls_STATUS & AssignProperties_From_Mtls_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMtls_STATUS, Mtls_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMtls_STATUS tests if a specific instance of Mtls_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMtls_STATUS(subject Mtls_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Mtls_STATUS
	err := copied.AssignProperties_To_Mtls_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Mtls_STATUS
	err = actual.AssignProperties_From_Mtls_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Mtls_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Mtls_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMtls_STATUS, Mtls_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMtls_STATUS runs a test to see if a specific instance of Mtls_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMtls_STATUS(subject Mtls_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Mtls_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Mtls_STATUS instances for property testing - lazily instantiated by Mtls_STATUSGenerator()
var mtls_STATUSGenerator gopter.Gen

// Mtls_STATUSGenerator returns a generator of Mtls_STATUS instances for property testing.
func Mtls_STATUSGenerator() gopter.Gen {
	if mtls_STATUSGenerator != nil {
		return mtls_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMtls_STATUS(generators)
	mtls_STATUSGenerator = gen.Struct(reflect.TypeOf(Mtls_STATUS{}), generators)

	return mtls_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMtls_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMtls_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_VnetConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VnetConfiguration to VnetConfiguration via AssignProperties_To_VnetConfiguration & AssignProperties_From_VnetConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForVnetConfiguration, VnetConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVnetConfiguration tests if a specific instance of VnetConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVnetConfiguration(subject VnetConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VnetConfiguration
	err := copied.AssignProperties_To_VnetConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VnetConfiguration
	err = actual.AssignProperties_From_VnetConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VnetConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VnetConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVnetConfiguration, VnetConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVnetConfiguration runs a test to see if a specific instance of VnetConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVnetConfiguration(subject VnetConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VnetConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VnetConfiguration instances for property testing - lazily instantiated by VnetConfigurationGenerator()
var vnetConfigurationGenerator gopter.Gen

// VnetConfigurationGenerator returns a generator of VnetConfiguration instances for property testing.
func VnetConfigurationGenerator() gopter.Gen {
	if vnetConfigurationGenerator != nil {
		return vnetConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVnetConfiguration(generators)
	vnetConfigurationGenerator = gen.Struct(reflect.TypeOf(VnetConfiguration{}), generators)

	return vnetConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForVnetConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVnetConfiguration(gens map[string]gopter.Gen) {
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["Internal"] = gen.PtrOf(gen.Bool())
	gens["PlatformReservedCidr"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformReservedDnsIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_VnetConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VnetConfiguration_STATUS to VnetConfiguration_STATUS via AssignProperties_To_VnetConfiguration_STATUS & AssignProperties_From_VnetConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVnetConfiguration_STATUS, VnetConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVnetConfiguration_STATUS tests if a specific instance of VnetConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVnetConfiguration_STATUS(subject VnetConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VnetConfiguration_STATUS
	err := copied.AssignProperties_To_VnetConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VnetConfiguration_STATUS
	err = actual.AssignProperties_From_VnetConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VnetConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VnetConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVnetConfiguration_STATUS, VnetConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVnetConfiguration_STATUS runs a test to see if a specific instance of VnetConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVnetConfiguration_STATUS(subject VnetConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VnetConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VnetConfiguration_STATUS instances for property testing - lazily instantiated by
// VnetConfiguration_STATUSGenerator()
var vnetConfiguration_STATUSGenerator gopter.Gen

// VnetConfiguration_STATUSGenerator returns a generator of VnetConfiguration_STATUS instances for property testing.
func VnetConfiguration_STATUSGenerator() gopter.Gen {
	if vnetConfiguration_STATUSGenerator != nil {
		return vnetConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVnetConfiguration_STATUS(generators)
	vnetConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(VnetConfiguration_STATUS{}), generators)

	return vnetConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVnetConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVnetConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["InfrastructureSubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["Internal"] = gen.PtrOf(gen.Bool())
	gens["PlatformReservedCidr"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformReservedDnsIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkloadProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkloadProfile to WorkloadProfile via AssignProperties_To_WorkloadProfile & AssignProperties_From_WorkloadProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkloadProfile, WorkloadProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkloadProfile tests if a specific instance of WorkloadProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkloadProfile(subject WorkloadProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkloadProfile
	err := copied.AssignProperties_To_WorkloadProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkloadProfile
	err = actual.AssignProperties_From_WorkloadProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkloadProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkloadProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkloadProfile, WorkloadProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkloadProfile runs a test to see if a specific instance of WorkloadProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkloadProfile(subject WorkloadProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkloadProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkloadProfile instances for property testing - lazily instantiated by WorkloadProfileGenerator()
var workloadProfileGenerator gopter.Gen

// WorkloadProfileGenerator returns a generator of WorkloadProfile instances for property testing.
func WorkloadProfileGenerator() gopter.Gen {
	if workloadProfileGenerator != nil {
		return workloadProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkloadProfile(generators)
	workloadProfileGenerator = gen.Struct(reflect.TypeOf(WorkloadProfile{}), generators)

	return workloadProfileGenerator
}

// AddIndependentPropertyGeneratorsForWorkloadProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkloadProfile(gens map[string]gopter.Gen) {
	gens["MaximumCount"] = gen.PtrOf(gen.Int())
	gens["MinimumCount"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WorkloadProfileType"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkloadProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkloadProfile_STATUS to WorkloadProfile_STATUS via AssignProperties_To_WorkloadProfile_STATUS & AssignProperties_From_WorkloadProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkloadProfile_STATUS, WorkloadProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkloadProfile_STATUS tests if a specific instance of WorkloadProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkloadProfile_STATUS(subject WorkloadProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkloadProfile_STATUS
	err := copied.AssignProperties_To_WorkloadProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkloadProfile_STATUS
	err = actual.AssignProperties_From_WorkloadProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkloadProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkloadProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkloadProfile_STATUS, WorkloadProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkloadProfile_STATUS runs a test to see if a specific instance of WorkloadProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkloadProfile_STATUS(subject WorkloadProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkloadProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkloadProfile_STATUS instances for property testing - lazily instantiated by
// WorkloadProfile_STATUSGenerator()
var workloadProfile_STATUSGenerator gopter.Gen

// WorkloadProfile_STATUSGenerator returns a generator of WorkloadProfile_STATUS instances for property testing.
func WorkloadProfile_STATUSGenerator() gopter.Gen {
	if workloadProfile_STATUSGenerator != nil {
		return workloadProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkloadProfile_STATUS(generators)
	workloadProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkloadProfile_STATUS{}), generators)

	return workloadProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkloadProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkloadProfile_STATUS(gens map[string]gopter.Gen) {
	gens["MaximumCount"] = gen.PtrOf(gen.Int())
	gens["MinimumCount"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WorkloadProfileType"] = gen.PtrOf(gen.AlphaString())
}
