// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"fmt"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20250101/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,app}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20240301.AuthConfig
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/ContainerApps/stable/2024-03-01/AuthConfigs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/authConfigs/{authConfigName}
type AuthConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AuthConfig_Spec   `json:"spec,omitempty"`
	Status            AuthConfig_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &AuthConfig{}

// GetConditions returns the conditions of the resource
func (config *AuthConfig) GetConditions() conditions.Conditions {
	return config.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (config *AuthConfig) SetConditions(conditions conditions.Conditions) {
	config.Status.Conditions = conditions
}

var _ conversion.Convertible = &AuthConfig{}

// ConvertFrom populates our AuthConfig from the provided hub AuthConfig
func (config *AuthConfig) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.AuthConfig)
	if !ok {
		return fmt.Errorf("expected app/v1api20250101/storage/AuthConfig but received %T instead", hub)
	}

	return config.AssignProperties_From_AuthConfig(source)
}

// ConvertTo populates the provided hub AuthConfig from our AuthConfig
func (config *AuthConfig) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.AuthConfig)
	if !ok {
		return fmt.Errorf("expected app/v1api20250101/storage/AuthConfig but received %T instead", hub)
	}

	return config.AssignProperties_To_AuthConfig(destination)
}

var _ configmaps.Exporter = &AuthConfig{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (config *AuthConfig) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if config.Spec.OperatorSpec == nil {
		return nil
	}
	return config.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &AuthConfig{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (config *AuthConfig) SecretDestinationExpressions() []*core.DestinationExpression {
	if config.Spec.OperatorSpec == nil {
		return nil
	}
	return config.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &AuthConfig{}

// AzureName returns the Azure name of the resource
func (config *AuthConfig) AzureName() string {
	return config.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (config AuthConfig) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (config *AuthConfig) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (config *AuthConfig) GetSpec() genruntime.ConvertibleSpec {
	return &config.Spec
}

// GetStatus returns the status of this resource
func (config *AuthConfig) GetStatus() genruntime.ConvertibleStatus {
	return &config.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (config *AuthConfig) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.App/containerApps/authConfigs"
func (config *AuthConfig) GetType() string {
	return "Microsoft.App/containerApps/authConfigs"
}

// NewEmptyStatus returns a new empty (blank) status
func (config *AuthConfig) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &AuthConfig_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (config *AuthConfig) Owner() *genruntime.ResourceReference {
	if config.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(config.Spec)
	return config.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (config *AuthConfig) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*AuthConfig_STATUS); ok {
		config.Status = *st
		return nil
	}

	// Convert status to required version
	var st AuthConfig_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	config.Status = st
	return nil
}

// AssignProperties_From_AuthConfig populates our AuthConfig from the provided source AuthConfig
func (config *AuthConfig) AssignProperties_From_AuthConfig(source *storage.AuthConfig) error {

	// ObjectMeta
	config.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec AuthConfig_Spec
	err := spec.AssignProperties_From_AuthConfig_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_AuthConfig_Spec() to populate field Spec")
	}
	config.Spec = spec

	// Status
	var status AuthConfig_STATUS
	err = status.AssignProperties_From_AuthConfig_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_AuthConfig_STATUS() to populate field Status")
	}
	config.Status = status

	// Invoke the augmentConversionForAuthConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForAuthConfig); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AuthConfig populates the provided destination AuthConfig from our AuthConfig
func (config *AuthConfig) AssignProperties_To_AuthConfig(destination *storage.AuthConfig) error {

	// ObjectMeta
	destination.ObjectMeta = *config.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.AuthConfig_Spec
	err := config.Spec.AssignProperties_To_AuthConfig_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_AuthConfig_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.AuthConfig_STATUS
	err = config.Status.AssignProperties_To_AuthConfig_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_AuthConfig_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForAuthConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForAuthConfig); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (config *AuthConfig) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: config.Spec.OriginalVersion,
		Kind:    "AuthConfig",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20240301.AuthConfig
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/ContainerApps/stable/2024-03-01/AuthConfigs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/authConfigs/{authConfigName}
type AuthConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AuthConfig `json:"items"`
}

// Storage version of v1api20240301.APIVersion
// +kubebuilder:validation:Enum={"2024-03-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2024-03-01")

type augmentConversionForAuthConfig interface {
	AssignPropertiesFrom(src *storage.AuthConfig) error
	AssignPropertiesTo(dst *storage.AuthConfig) error
}

// Storage version of v1api20240301.AuthConfig_Spec
type AuthConfig_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName          string                  `json:"azureName,omitempty"`
	EncryptionSettings *EncryptionSettings     `json:"encryptionSettings,omitempty"`
	GlobalValidation   *GlobalValidation       `json:"globalValidation,omitempty"`
	HttpSettings       *HttpSettings           `json:"httpSettings,omitempty"`
	IdentityProviders  *IdentityProviders      `json:"identityProviders,omitempty"`
	Login              *Login                  `json:"login,omitempty"`
	OperatorSpec       *AuthConfigOperatorSpec `json:"operatorSpec,omitempty"`
	OriginalVersion    string                  `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a app.azure.com/ContainerApp resource
	Owner       *genruntime.KnownResourceReference `group:"app.azure.com" json:"owner,omitempty" kind:"ContainerApp"`
	Platform    *AuthPlatform                      `json:"platform,omitempty"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
}

var _ genruntime.ConvertibleSpec = &AuthConfig_Spec{}

// ConvertSpecFrom populates our AuthConfig_Spec from the provided source
func (config *AuthConfig_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.AuthConfig_Spec)
	if ok {
		// Populate our instance from source
		return config.AssignProperties_From_AuthConfig_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.AuthConfig_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = config.AssignProperties_From_AuthConfig_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our AuthConfig_Spec
func (config *AuthConfig_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.AuthConfig_Spec)
	if ok {
		// Populate destination from our instance
		return config.AssignProperties_To_AuthConfig_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.AuthConfig_Spec{}
	err := config.AssignProperties_To_AuthConfig_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_AuthConfig_Spec populates our AuthConfig_Spec from the provided source AuthConfig_Spec
func (config *AuthConfig_Spec) AssignProperties_From_AuthConfig_Spec(source *storage.AuthConfig_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	config.AzureName = source.AzureName

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting EncryptionSettings
		err := encryptionSetting.AssignProperties_From_EncryptionSettings(source.EncryptionSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionSettings() to populate field EncryptionSettings")
		}
		config.EncryptionSettings = &encryptionSetting
	} else {
		config.EncryptionSettings = nil
	}

	// GlobalValidation
	if source.GlobalValidation != nil {
		var globalValidation GlobalValidation
		err := globalValidation.AssignProperties_From_GlobalValidation(source.GlobalValidation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GlobalValidation() to populate field GlobalValidation")
		}
		config.GlobalValidation = &globalValidation
	} else {
		config.GlobalValidation = nil
	}

	// HttpSettings
	if source.HttpSettings != nil {
		var httpSetting HttpSettings
		err := httpSetting.AssignProperties_From_HttpSettings(source.HttpSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpSettings() to populate field HttpSettings")
		}
		config.HttpSettings = &httpSetting
	} else {
		config.HttpSettings = nil
	}

	// IdentityProviders
	if source.IdentityProviders != nil {
		var identityProvider IdentityProviders
		err := identityProvider.AssignProperties_From_IdentityProviders(source.IdentityProviders)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IdentityProviders() to populate field IdentityProviders")
		}
		config.IdentityProviders = &identityProvider
	} else {
		config.IdentityProviders = nil
	}

	// Login
	if source.Login != nil {
		var login Login
		err := login.AssignProperties_From_Login(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Login() to populate field Login")
		}
		config.Login = &login
	} else {
		config.Login = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec AuthConfigOperatorSpec
		err := operatorSpec.AssignProperties_From_AuthConfigOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AuthConfigOperatorSpec() to populate field OperatorSpec")
		}
		config.OperatorSpec = &operatorSpec
	} else {
		config.OperatorSpec = nil
	}

	// OriginalVersion
	config.OriginalVersion = source.OriginalVersion

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		config.Owner = &owner
	} else {
		config.Owner = nil
	}

	// Platform
	if source.Platform != nil {
		var platform AuthPlatform
		err := platform.AssignProperties_From_AuthPlatform(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AuthPlatform() to populate field Platform")
		}
		config.Platform = &platform
	} else {
		config.Platform = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthConfig_Spec interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForAuthConfig_Spec); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AuthConfig_Spec populates the provided destination AuthConfig_Spec from our AuthConfig_Spec
func (config *AuthConfig_Spec) AssignProperties_To_AuthConfig_Spec(destination *storage.AuthConfig_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// AzureName
	destination.AzureName = config.AzureName

	// EncryptionSettings
	if config.EncryptionSettings != nil {
		var encryptionSetting storage.EncryptionSettings
		err := config.EncryptionSettings.AssignProperties_To_EncryptionSettings(&encryptionSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionSettings() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// GlobalValidation
	if config.GlobalValidation != nil {
		var globalValidation storage.GlobalValidation
		err := config.GlobalValidation.AssignProperties_To_GlobalValidation(&globalValidation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GlobalValidation() to populate field GlobalValidation")
		}
		destination.GlobalValidation = &globalValidation
	} else {
		destination.GlobalValidation = nil
	}

	// HttpSettings
	if config.HttpSettings != nil {
		var httpSetting storage.HttpSettings
		err := config.HttpSettings.AssignProperties_To_HttpSettings(&httpSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpSettings() to populate field HttpSettings")
		}
		destination.HttpSettings = &httpSetting
	} else {
		destination.HttpSettings = nil
	}

	// IdentityProviders
	if config.IdentityProviders != nil {
		var identityProvider storage.IdentityProviders
		err := config.IdentityProviders.AssignProperties_To_IdentityProviders(&identityProvider)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IdentityProviders() to populate field IdentityProviders")
		}
		destination.IdentityProviders = &identityProvider
	} else {
		destination.IdentityProviders = nil
	}

	// Login
	if config.Login != nil {
		var login storage.Login
		err := config.Login.AssignProperties_To_Login(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Login() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// OperatorSpec
	if config.OperatorSpec != nil {
		var operatorSpec storage.AuthConfigOperatorSpec
		err := config.OperatorSpec.AssignProperties_To_AuthConfigOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AuthConfigOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = config.OriginalVersion

	// Owner
	if config.Owner != nil {
		owner := config.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Platform
	if config.Platform != nil {
		var platform storage.AuthPlatform
		err := config.Platform.AssignProperties_To_AuthPlatform(&platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AuthPlatform() to populate field Platform")
		}
		destination.Platform = &platform
	} else {
		destination.Platform = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthConfig_Spec interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForAuthConfig_Spec); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AuthConfig_STATUS
type AuthConfig_STATUS struct {
	Conditions         []conditions.Condition     `json:"conditions,omitempty"`
	EncryptionSettings *EncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	GlobalValidation   *GlobalValidation_STATUS   `json:"globalValidation,omitempty"`
	HttpSettings       *HttpSettings_STATUS       `json:"httpSettings,omitempty"`
	Id                 *string                    `json:"id,omitempty"`
	IdentityProviders  *IdentityProviders_STATUS  `json:"identityProviders,omitempty"`
	Login              *Login_STATUS              `json:"login,omitempty"`
	Name               *string                    `json:"name,omitempty"`
	Platform           *AuthPlatform_STATUS       `json:"platform,omitempty"`
	PropertyBag        genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	SystemData         *SystemData_STATUS         `json:"systemData,omitempty"`
	Type               *string                    `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &AuthConfig_STATUS{}

// ConvertStatusFrom populates our AuthConfig_STATUS from the provided source
func (config *AuthConfig_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.AuthConfig_STATUS)
	if ok {
		// Populate our instance from source
		return config.AssignProperties_From_AuthConfig_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.AuthConfig_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = config.AssignProperties_From_AuthConfig_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our AuthConfig_STATUS
func (config *AuthConfig_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.AuthConfig_STATUS)
	if ok {
		// Populate destination from our instance
		return config.AssignProperties_To_AuthConfig_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.AuthConfig_STATUS{}
	err := config.AssignProperties_To_AuthConfig_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_AuthConfig_STATUS populates our AuthConfig_STATUS from the provided source AuthConfig_STATUS
func (config *AuthConfig_STATUS) AssignProperties_From_AuthConfig_STATUS(source *storage.AuthConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Conditions
	config.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting EncryptionSettings_STATUS
		err := encryptionSetting.AssignProperties_From_EncryptionSettings_STATUS(source.EncryptionSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		config.EncryptionSettings = &encryptionSetting
	} else {
		config.EncryptionSettings = nil
	}

	// GlobalValidation
	if source.GlobalValidation != nil {
		var globalValidation GlobalValidation_STATUS
		err := globalValidation.AssignProperties_From_GlobalValidation_STATUS(source.GlobalValidation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GlobalValidation_STATUS() to populate field GlobalValidation")
		}
		config.GlobalValidation = &globalValidation
	} else {
		config.GlobalValidation = nil
	}

	// HttpSettings
	if source.HttpSettings != nil {
		var httpSetting HttpSettings_STATUS
		err := httpSetting.AssignProperties_From_HttpSettings_STATUS(source.HttpSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpSettings_STATUS() to populate field HttpSettings")
		}
		config.HttpSettings = &httpSetting
	} else {
		config.HttpSettings = nil
	}

	// Id
	config.Id = genruntime.ClonePointerToString(source.Id)

	// IdentityProviders
	if source.IdentityProviders != nil {
		var identityProvider IdentityProviders_STATUS
		err := identityProvider.AssignProperties_From_IdentityProviders_STATUS(source.IdentityProviders)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IdentityProviders_STATUS() to populate field IdentityProviders")
		}
		config.IdentityProviders = &identityProvider
	} else {
		config.IdentityProviders = nil
	}

	// Login
	if source.Login != nil {
		var login Login_STATUS
		err := login.AssignProperties_From_Login_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Login_STATUS() to populate field Login")
		}
		config.Login = &login
	} else {
		config.Login = nil
	}

	// Name
	config.Name = genruntime.ClonePointerToString(source.Name)

	// Platform
	if source.Platform != nil {
		var platform AuthPlatform_STATUS
		err := platform.AssignProperties_From_AuthPlatform_STATUS(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AuthPlatform_STATUS() to populate field Platform")
		}
		config.Platform = &platform
	} else {
		config.Platform = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		config.SystemData = &systemDatum
	} else {
		config.SystemData = nil
	}

	// Type
	config.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForAuthConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AuthConfig_STATUS populates the provided destination AuthConfig_STATUS from our AuthConfig_STATUS
func (config *AuthConfig_STATUS) AssignProperties_To_AuthConfig_STATUS(destination *storage.AuthConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(config.Conditions)

	// EncryptionSettings
	if config.EncryptionSettings != nil {
		var encryptionSetting storage.EncryptionSettings_STATUS
		err := config.EncryptionSettings.AssignProperties_To_EncryptionSettings_STATUS(&encryptionSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// GlobalValidation
	if config.GlobalValidation != nil {
		var globalValidation storage.GlobalValidation_STATUS
		err := config.GlobalValidation.AssignProperties_To_GlobalValidation_STATUS(&globalValidation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GlobalValidation_STATUS() to populate field GlobalValidation")
		}
		destination.GlobalValidation = &globalValidation
	} else {
		destination.GlobalValidation = nil
	}

	// HttpSettings
	if config.HttpSettings != nil {
		var httpSetting storage.HttpSettings_STATUS
		err := config.HttpSettings.AssignProperties_To_HttpSettings_STATUS(&httpSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpSettings_STATUS() to populate field HttpSettings")
		}
		destination.HttpSettings = &httpSetting
	} else {
		destination.HttpSettings = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(config.Id)

	// IdentityProviders
	if config.IdentityProviders != nil {
		var identityProvider storage.IdentityProviders_STATUS
		err := config.IdentityProviders.AssignProperties_To_IdentityProviders_STATUS(&identityProvider)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IdentityProviders_STATUS() to populate field IdentityProviders")
		}
		destination.IdentityProviders = &identityProvider
	} else {
		destination.IdentityProviders = nil
	}

	// Login
	if config.Login != nil {
		var login storage.Login_STATUS
		err := config.Login.AssignProperties_To_Login_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Login_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(config.Name)

	// Platform
	if config.Platform != nil {
		var platform storage.AuthPlatform_STATUS
		err := config.Platform.AssignProperties_To_AuthPlatform_STATUS(&platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AuthPlatform_STATUS() to populate field Platform")
		}
		destination.Platform = &platform
	} else {
		destination.Platform = nil
	}

	// SystemData
	if config.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := config.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(config.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForAuthConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAuthConfig_Spec interface {
	AssignPropertiesFrom(src *storage.AuthConfig_Spec) error
	AssignPropertiesTo(dst *storage.AuthConfig_Spec) error
}

type augmentConversionForAuthConfig_STATUS interface {
	AssignPropertiesFrom(src *storage.AuthConfig_STATUS) error
	AssignPropertiesTo(dst *storage.AuthConfig_STATUS) error
}

// Storage version of v1api20240301.AuthConfigOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type AuthConfigOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_AuthConfigOperatorSpec populates our AuthConfigOperatorSpec from the provided source AuthConfigOperatorSpec
func (operator *AuthConfigOperatorSpec) AssignProperties_From_AuthConfigOperatorSpec(source *storage.AuthConfigOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		operator.PropertyBag = propertyBag
	} else {
		operator.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthConfigOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForAuthConfigOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AuthConfigOperatorSpec populates the provided destination AuthConfigOperatorSpec from our AuthConfigOperatorSpec
func (operator *AuthConfigOperatorSpec) AssignProperties_To_AuthConfigOperatorSpec(destination *storage.AuthConfigOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(operator.PropertyBag)

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthConfigOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForAuthConfigOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AuthPlatform
// The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
type AuthPlatform struct {
	Enabled        *bool                  `json:"enabled,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RuntimeVersion *string                `json:"runtimeVersion,omitempty"`
}

// AssignProperties_From_AuthPlatform populates our AuthPlatform from the provided source AuthPlatform
func (platform *AuthPlatform) AssignProperties_From_AuthPlatform(source *storage.AuthPlatform) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		platform.Enabled = &enabled
	} else {
		platform.Enabled = nil
	}

	// RuntimeVersion
	platform.RuntimeVersion = genruntime.ClonePointerToString(source.RuntimeVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		platform.PropertyBag = propertyBag
	} else {
		platform.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthPlatform interface (if implemented) to customize the conversion
	var platformAsAny any = platform
	if augmentedPlatform, ok := platformAsAny.(augmentConversionForAuthPlatform); ok {
		err := augmentedPlatform.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AuthPlatform populates the provided destination AuthPlatform from our AuthPlatform
func (platform *AuthPlatform) AssignProperties_To_AuthPlatform(destination *storage.AuthPlatform) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(platform.PropertyBag)

	// Enabled
	if platform.Enabled != nil {
		enabled := *platform.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RuntimeVersion
	destination.RuntimeVersion = genruntime.ClonePointerToString(platform.RuntimeVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthPlatform interface (if implemented) to customize the conversion
	var platformAsAny any = platform
	if augmentedPlatform, ok := platformAsAny.(augmentConversionForAuthPlatform); ok {
		err := augmentedPlatform.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AuthPlatform_STATUS
// The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
type AuthPlatform_STATUS struct {
	Enabled        *bool                  `json:"enabled,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RuntimeVersion *string                `json:"runtimeVersion,omitempty"`
}

// AssignProperties_From_AuthPlatform_STATUS populates our AuthPlatform_STATUS from the provided source AuthPlatform_STATUS
func (platform *AuthPlatform_STATUS) AssignProperties_From_AuthPlatform_STATUS(source *storage.AuthPlatform_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		platform.Enabled = &enabled
	} else {
		platform.Enabled = nil
	}

	// RuntimeVersion
	platform.RuntimeVersion = genruntime.ClonePointerToString(source.RuntimeVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		platform.PropertyBag = propertyBag
	} else {
		platform.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthPlatform_STATUS interface (if implemented) to customize the conversion
	var platformAsAny any = platform
	if augmentedPlatform, ok := platformAsAny.(augmentConversionForAuthPlatform_STATUS); ok {
		err := augmentedPlatform.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AuthPlatform_STATUS populates the provided destination AuthPlatform_STATUS from our AuthPlatform_STATUS
func (platform *AuthPlatform_STATUS) AssignProperties_To_AuthPlatform_STATUS(destination *storage.AuthPlatform_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(platform.PropertyBag)

	// Enabled
	if platform.Enabled != nil {
		enabled := *platform.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RuntimeVersion
	destination.RuntimeVersion = genruntime.ClonePointerToString(platform.RuntimeVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAuthPlatform_STATUS interface (if implemented) to customize the conversion
	var platformAsAny any = platform
	if augmentedPlatform, ok := platformAsAny.(augmentConversionForAuthPlatform_STATUS); ok {
		err := augmentedPlatform.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.EncryptionSettings
// The configuration settings of the secrets references of encryption key and signing key for ContainerApp Service
// Authentication/Authorization.
type EncryptionSettings struct {
	ContainerAppAuthEncryptionSecretName *string                `json:"containerAppAuthEncryptionSecretName,omitempty"`
	ContainerAppAuthSigningSecretName    *string                `json:"containerAppAuthSigningSecretName,omitempty"`
	PropertyBag                          genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_EncryptionSettings populates our EncryptionSettings from the provided source EncryptionSettings
func (settings *EncryptionSettings) AssignProperties_From_EncryptionSettings(source *storage.EncryptionSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ContainerAppAuthEncryptionSecretName
	settings.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	settings.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthSigningSecretName)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForEncryptionSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForEncryptionSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionSettings populates the provided destination EncryptionSettings from our EncryptionSettings
func (settings *EncryptionSettings) AssignProperties_To_EncryptionSettings(destination *storage.EncryptionSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// ContainerAppAuthEncryptionSecretName
	destination.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(settings.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	destination.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(settings.ContainerAppAuthSigningSecretName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEncryptionSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForEncryptionSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.EncryptionSettings_STATUS
// The configuration settings of the secrets references of encryption key and signing key for ContainerApp Service
// Authentication/Authorization.
type EncryptionSettings_STATUS struct {
	ContainerAppAuthEncryptionSecretName *string                `json:"containerAppAuthEncryptionSecretName,omitempty"`
	ContainerAppAuthSigningSecretName    *string                `json:"containerAppAuthSigningSecretName,omitempty"`
	PropertyBag                          genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_EncryptionSettings_STATUS populates our EncryptionSettings_STATUS from the provided source EncryptionSettings_STATUS
func (settings *EncryptionSettings_STATUS) AssignProperties_From_EncryptionSettings_STATUS(source *storage.EncryptionSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ContainerAppAuthEncryptionSecretName
	settings.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	settings.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(source.ContainerAppAuthSigningSecretName)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForEncryptionSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForEncryptionSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionSettings_STATUS populates the provided destination EncryptionSettings_STATUS from our EncryptionSettings_STATUS
func (settings *EncryptionSettings_STATUS) AssignProperties_To_EncryptionSettings_STATUS(destination *storage.EncryptionSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// ContainerAppAuthEncryptionSecretName
	destination.ContainerAppAuthEncryptionSecretName = genruntime.ClonePointerToString(settings.ContainerAppAuthEncryptionSecretName)

	// ContainerAppAuthSigningSecretName
	destination.ContainerAppAuthSigningSecretName = genruntime.ClonePointerToString(settings.ContainerAppAuthSigningSecretName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEncryptionSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForEncryptionSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.GlobalValidation
// The configuration settings that determines the validation flow of users using ContainerApp Service
// Authentication/Authorization.
type GlobalValidation struct {
	ExcludedPaths               []string               `json:"excludedPaths,omitempty"`
	PropertyBag                 genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RedirectToProvider          *string                `json:"redirectToProvider,omitempty"`
	UnauthenticatedClientAction *string                `json:"unauthenticatedClientAction,omitempty"`
}

// AssignProperties_From_GlobalValidation populates our GlobalValidation from the provided source GlobalValidation
func (validation *GlobalValidation) AssignProperties_From_GlobalValidation(source *storage.GlobalValidation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExcludedPaths
	validation.ExcludedPaths = genruntime.CloneSliceOfString(source.ExcludedPaths)

	// RedirectToProvider
	validation.RedirectToProvider = genruntime.ClonePointerToString(source.RedirectToProvider)

	// UnauthenticatedClientAction
	validation.UnauthenticatedClientAction = genruntime.ClonePointerToString(source.UnauthenticatedClientAction)

	// Update the property bag
	if len(propertyBag) > 0 {
		validation.PropertyBag = propertyBag
	} else {
		validation.PropertyBag = nil
	}

	// Invoke the augmentConversionForGlobalValidation interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForGlobalValidation); ok {
		err := augmentedValidation.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_GlobalValidation populates the provided destination GlobalValidation from our GlobalValidation
func (validation *GlobalValidation) AssignProperties_To_GlobalValidation(destination *storage.GlobalValidation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(validation.PropertyBag)

	// ExcludedPaths
	destination.ExcludedPaths = genruntime.CloneSliceOfString(validation.ExcludedPaths)

	// RedirectToProvider
	destination.RedirectToProvider = genruntime.ClonePointerToString(validation.RedirectToProvider)

	// UnauthenticatedClientAction
	destination.UnauthenticatedClientAction = genruntime.ClonePointerToString(validation.UnauthenticatedClientAction)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForGlobalValidation interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForGlobalValidation); ok {
		err := augmentedValidation.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.GlobalValidation_STATUS
// The configuration settings that determines the validation flow of users using ContainerApp Service
// Authentication/Authorization.
type GlobalValidation_STATUS struct {
	ExcludedPaths               []string               `json:"excludedPaths,omitempty"`
	PropertyBag                 genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RedirectToProvider          *string                `json:"redirectToProvider,omitempty"`
	UnauthenticatedClientAction *string                `json:"unauthenticatedClientAction,omitempty"`
}

// AssignProperties_From_GlobalValidation_STATUS populates our GlobalValidation_STATUS from the provided source GlobalValidation_STATUS
func (validation *GlobalValidation_STATUS) AssignProperties_From_GlobalValidation_STATUS(source *storage.GlobalValidation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExcludedPaths
	validation.ExcludedPaths = genruntime.CloneSliceOfString(source.ExcludedPaths)

	// RedirectToProvider
	validation.RedirectToProvider = genruntime.ClonePointerToString(source.RedirectToProvider)

	// UnauthenticatedClientAction
	validation.UnauthenticatedClientAction = genruntime.ClonePointerToString(source.UnauthenticatedClientAction)

	// Update the property bag
	if len(propertyBag) > 0 {
		validation.PropertyBag = propertyBag
	} else {
		validation.PropertyBag = nil
	}

	// Invoke the augmentConversionForGlobalValidation_STATUS interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForGlobalValidation_STATUS); ok {
		err := augmentedValidation.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_GlobalValidation_STATUS populates the provided destination GlobalValidation_STATUS from our GlobalValidation_STATUS
func (validation *GlobalValidation_STATUS) AssignProperties_To_GlobalValidation_STATUS(destination *storage.GlobalValidation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(validation.PropertyBag)

	// ExcludedPaths
	destination.ExcludedPaths = genruntime.CloneSliceOfString(validation.ExcludedPaths)

	// RedirectToProvider
	destination.RedirectToProvider = genruntime.ClonePointerToString(validation.RedirectToProvider)

	// UnauthenticatedClientAction
	destination.UnauthenticatedClientAction = genruntime.ClonePointerToString(validation.UnauthenticatedClientAction)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForGlobalValidation_STATUS interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForGlobalValidation_STATUS); ok {
		err := augmentedValidation.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.HttpSettings
// The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp
// Service Authentication/Authorization.
type HttpSettings struct {
	ForwardProxy *ForwardProxy          `json:"forwardProxy,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RequireHttps *bool                  `json:"requireHttps,omitempty"`
	Routes       *HttpSettingsRoutes    `json:"routes,omitempty"`
}

// AssignProperties_From_HttpSettings populates our HttpSettings from the provided source HttpSettings
func (settings *HttpSettings) AssignProperties_From_HttpSettings(source *storage.HttpSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForwardProxy
	if source.ForwardProxy != nil {
		var forwardProxy ForwardProxy
		err := forwardProxy.AssignProperties_From_ForwardProxy(source.ForwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ForwardProxy() to populate field ForwardProxy")
		}
		settings.ForwardProxy = &forwardProxy
	} else {
		settings.ForwardProxy = nil
	}

	// RequireHttps
	if source.RequireHttps != nil {
		requireHttpsHTTPS := *source.RequireHttps
		settings.RequireHttps = &requireHttpsHTTPS
	} else {
		settings.RequireHttps = nil
	}

	// Routes
	if source.Routes != nil {
		var route HttpSettingsRoutes
		err := route.AssignProperties_From_HttpSettingsRoutes(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpSettingsRoutes() to populate field Routes")
		}
		settings.Routes = &route
	} else {
		settings.Routes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForHttpSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpSettings populates the provided destination HttpSettings from our HttpSettings
func (settings *HttpSettings) AssignProperties_To_HttpSettings(destination *storage.HttpSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// ForwardProxy
	if settings.ForwardProxy != nil {
		var forwardProxy storage.ForwardProxy
		err := settings.ForwardProxy.AssignProperties_To_ForwardProxy(&forwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ForwardProxy() to populate field ForwardProxy")
		}
		destination.ForwardProxy = &forwardProxy
	} else {
		destination.ForwardProxy = nil
	}

	// RequireHttps
	if settings.RequireHttps != nil {
		requireHttpsHTTPS := *settings.RequireHttps
		destination.RequireHttps = &requireHttpsHTTPS
	} else {
		destination.RequireHttps = nil
	}

	// Routes
	if settings.Routes != nil {
		var route storage.HttpSettingsRoutes
		err := settings.Routes.AssignProperties_To_HttpSettingsRoutes(&route)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpSettingsRoutes() to populate field Routes")
		}
		destination.Routes = &route
	} else {
		destination.Routes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForHttpSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.HttpSettings_STATUS
// The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp
// Service Authentication/Authorization.
type HttpSettings_STATUS struct {
	ForwardProxy *ForwardProxy_STATUS       `json:"forwardProxy,omitempty"`
	PropertyBag  genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	RequireHttps *bool                      `json:"requireHttps,omitempty"`
	Routes       *HttpSettingsRoutes_STATUS `json:"routes,omitempty"`
}

// AssignProperties_From_HttpSettings_STATUS populates our HttpSettings_STATUS from the provided source HttpSettings_STATUS
func (settings *HttpSettings_STATUS) AssignProperties_From_HttpSettings_STATUS(source *storage.HttpSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForwardProxy
	if source.ForwardProxy != nil {
		var forwardProxy ForwardProxy_STATUS
		err := forwardProxy.AssignProperties_From_ForwardProxy_STATUS(source.ForwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ForwardProxy_STATUS() to populate field ForwardProxy")
		}
		settings.ForwardProxy = &forwardProxy
	} else {
		settings.ForwardProxy = nil
	}

	// RequireHttps
	if source.RequireHttps != nil {
		requireHttpsHTTPS := *source.RequireHttps
		settings.RequireHttps = &requireHttpsHTTPS
	} else {
		settings.RequireHttps = nil
	}

	// Routes
	if source.Routes != nil {
		var route HttpSettingsRoutes_STATUS
		err := route.AssignProperties_From_HttpSettingsRoutes_STATUS(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpSettingsRoutes_STATUS() to populate field Routes")
		}
		settings.Routes = &route
	} else {
		settings.Routes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForHttpSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpSettings_STATUS populates the provided destination HttpSettings_STATUS from our HttpSettings_STATUS
func (settings *HttpSettings_STATUS) AssignProperties_To_HttpSettings_STATUS(destination *storage.HttpSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// ForwardProxy
	if settings.ForwardProxy != nil {
		var forwardProxy storage.ForwardProxy_STATUS
		err := settings.ForwardProxy.AssignProperties_To_ForwardProxy_STATUS(&forwardProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ForwardProxy_STATUS() to populate field ForwardProxy")
		}
		destination.ForwardProxy = &forwardProxy
	} else {
		destination.ForwardProxy = nil
	}

	// RequireHttps
	if settings.RequireHttps != nil {
		requireHttpsHTTPS := *settings.RequireHttps
		destination.RequireHttps = &requireHttpsHTTPS
	} else {
		destination.RequireHttps = nil
	}

	// Routes
	if settings.Routes != nil {
		var route storage.HttpSettingsRoutes_STATUS
		err := settings.Routes.AssignProperties_To_HttpSettingsRoutes_STATUS(&route)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpSettingsRoutes_STATUS() to populate field Routes")
		}
		destination.Routes = &route
	} else {
		destination.Routes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForHttpSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.IdentityProviders
// The configuration settings of each of the identity providers used to configure ContainerApp Service
// Authentication/Authorization.
type IdentityProviders struct {
	Apple                        *Apple                                 `json:"apple,omitempty"`
	AzureActiveDirectory         *AzureActiveDirectory                  `json:"azureActiveDirectory,omitempty"`
	AzureStaticWebApps           *AzureStaticWebApps                    `json:"azureStaticWebApps,omitempty"`
	CustomOpenIdConnectProviders map[string]CustomOpenIdConnectProvider `json:"customOpenIdConnectProviders,omitempty"`
	Facebook                     *Facebook                              `json:"facebook,omitempty"`
	GitHub                       *GitHub                                `json:"gitHub,omitempty"`
	Google                       *Google                                `json:"google,omitempty"`
	PropertyBag                  genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	Twitter                      *Twitter                               `json:"twitter,omitempty"`
}

// AssignProperties_From_IdentityProviders populates our IdentityProviders from the provided source IdentityProviders
func (providers *IdentityProviders) AssignProperties_From_IdentityProviders(source *storage.IdentityProviders) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Apple
	if source.Apple != nil {
		var apple Apple
		err := apple.AssignProperties_From_Apple(source.Apple)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Apple() to populate field Apple")
		}
		providers.Apple = &apple
	} else {
		providers.Apple = nil
	}

	// AzureActiveDirectory
	if source.AzureActiveDirectory != nil {
		var azureActiveDirectory AzureActiveDirectory
		err := azureActiveDirectory.AssignProperties_From_AzureActiveDirectory(source.AzureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectory() to populate field AzureActiveDirectory")
		}
		providers.AzureActiveDirectory = &azureActiveDirectory
	} else {
		providers.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if source.AzureStaticWebApps != nil {
		var azureStaticWebApp AzureStaticWebApps
		err := azureStaticWebApp.AssignProperties_From_AzureStaticWebApps(source.AzureStaticWebApps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureStaticWebApps() to populate field AzureStaticWebApps")
		}
		providers.AzureStaticWebApps = &azureStaticWebApp
	} else {
		providers.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if source.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]CustomOpenIdConnectProvider, len(source.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range source.CustomOpenIdConnectProviders {
			var customOpenIdConnectProvider CustomOpenIdConnectProvider
			err := customOpenIdConnectProvider.AssignProperties_From_CustomOpenIdConnectProvider(&customOpenIdConnectProviderValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CustomOpenIdConnectProvider() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		providers.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		providers.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if source.Facebook != nil {
		var facebook Facebook
		err := facebook.AssignProperties_From_Facebook(source.Facebook)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Facebook() to populate field Facebook")
		}
		providers.Facebook = &facebook
	} else {
		providers.Facebook = nil
	}

	// GitHub
	if source.GitHub != nil {
		var gitHub GitHub
		err := gitHub.AssignProperties_From_GitHub(source.GitHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GitHub() to populate field GitHub")
		}
		providers.GitHub = &gitHub
	} else {
		providers.GitHub = nil
	}

	// Google
	if source.Google != nil {
		var google Google
		err := google.AssignProperties_From_Google(source.Google)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Google() to populate field Google")
		}
		providers.Google = &google
	} else {
		providers.Google = nil
	}

	// Twitter
	if source.Twitter != nil {
		var twitter Twitter
		err := twitter.AssignProperties_From_Twitter(source.Twitter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Twitter() to populate field Twitter")
		}
		providers.Twitter = &twitter
	} else {
		providers.Twitter = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		providers.PropertyBag = propertyBag
	} else {
		providers.PropertyBag = nil
	}

	// Invoke the augmentConversionForIdentityProviders interface (if implemented) to customize the conversion
	var providersAsAny any = providers
	if augmentedProviders, ok := providersAsAny.(augmentConversionForIdentityProviders); ok {
		err := augmentedProviders.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IdentityProviders populates the provided destination IdentityProviders from our IdentityProviders
func (providers *IdentityProviders) AssignProperties_To_IdentityProviders(destination *storage.IdentityProviders) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(providers.PropertyBag)

	// Apple
	if providers.Apple != nil {
		var apple storage.Apple
		err := providers.Apple.AssignProperties_To_Apple(&apple)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Apple() to populate field Apple")
		}
		destination.Apple = &apple
	} else {
		destination.Apple = nil
	}

	// AzureActiveDirectory
	if providers.AzureActiveDirectory != nil {
		var azureActiveDirectory storage.AzureActiveDirectory
		err := providers.AzureActiveDirectory.AssignProperties_To_AzureActiveDirectory(&azureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectory() to populate field AzureActiveDirectory")
		}
		destination.AzureActiveDirectory = &azureActiveDirectory
	} else {
		destination.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if providers.AzureStaticWebApps != nil {
		var azureStaticWebApp storage.AzureStaticWebApps
		err := providers.AzureStaticWebApps.AssignProperties_To_AzureStaticWebApps(&azureStaticWebApp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureStaticWebApps() to populate field AzureStaticWebApps")
		}
		destination.AzureStaticWebApps = &azureStaticWebApp
	} else {
		destination.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if providers.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]storage.CustomOpenIdConnectProvider, len(providers.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range providers.CustomOpenIdConnectProviders {
			var customOpenIdConnectProvider storage.CustomOpenIdConnectProvider
			err := customOpenIdConnectProviderValue.AssignProperties_To_CustomOpenIdConnectProvider(&customOpenIdConnectProvider)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CustomOpenIdConnectProvider() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		destination.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		destination.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if providers.Facebook != nil {
		var facebook storage.Facebook
		err := providers.Facebook.AssignProperties_To_Facebook(&facebook)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Facebook() to populate field Facebook")
		}
		destination.Facebook = &facebook
	} else {
		destination.Facebook = nil
	}

	// GitHub
	if providers.GitHub != nil {
		var gitHub storage.GitHub
		err := providers.GitHub.AssignProperties_To_GitHub(&gitHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GitHub() to populate field GitHub")
		}
		destination.GitHub = &gitHub
	} else {
		destination.GitHub = nil
	}

	// Google
	if providers.Google != nil {
		var google storage.Google
		err := providers.Google.AssignProperties_To_Google(&google)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Google() to populate field Google")
		}
		destination.Google = &google
	} else {
		destination.Google = nil
	}

	// Twitter
	if providers.Twitter != nil {
		var twitter storage.Twitter
		err := providers.Twitter.AssignProperties_To_Twitter(&twitter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Twitter() to populate field Twitter")
		}
		destination.Twitter = &twitter
	} else {
		destination.Twitter = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIdentityProviders interface (if implemented) to customize the conversion
	var providersAsAny any = providers
	if augmentedProviders, ok := providersAsAny.(augmentConversionForIdentityProviders); ok {
		err := augmentedProviders.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.IdentityProviders_STATUS
// The configuration settings of each of the identity providers used to configure ContainerApp Service
// Authentication/Authorization.
type IdentityProviders_STATUS struct {
	Apple                        *Apple_STATUS                                 `json:"apple,omitempty"`
	AzureActiveDirectory         *AzureActiveDirectory_STATUS                  `json:"azureActiveDirectory,omitempty"`
	AzureStaticWebApps           *AzureStaticWebApps_STATUS                    `json:"azureStaticWebApps,omitempty"`
	CustomOpenIdConnectProviders map[string]CustomOpenIdConnectProvider_STATUS `json:"customOpenIdConnectProviders,omitempty"`
	Facebook                     *Facebook_STATUS                              `json:"facebook,omitempty"`
	GitHub                       *GitHub_STATUS                                `json:"gitHub,omitempty"`
	Google                       *Google_STATUS                                `json:"google,omitempty"`
	PropertyBag                  genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
	Twitter                      *Twitter_STATUS                               `json:"twitter,omitempty"`
}

// AssignProperties_From_IdentityProviders_STATUS populates our IdentityProviders_STATUS from the provided source IdentityProviders_STATUS
func (providers *IdentityProviders_STATUS) AssignProperties_From_IdentityProviders_STATUS(source *storage.IdentityProviders_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Apple
	if source.Apple != nil {
		var apple Apple_STATUS
		err := apple.AssignProperties_From_Apple_STATUS(source.Apple)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Apple_STATUS() to populate field Apple")
		}
		providers.Apple = &apple
	} else {
		providers.Apple = nil
	}

	// AzureActiveDirectory
	if source.AzureActiveDirectory != nil {
		var azureActiveDirectory AzureActiveDirectory_STATUS
		err := azureActiveDirectory.AssignProperties_From_AzureActiveDirectory_STATUS(source.AzureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectory_STATUS() to populate field AzureActiveDirectory")
		}
		providers.AzureActiveDirectory = &azureActiveDirectory
	} else {
		providers.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if source.AzureStaticWebApps != nil {
		var azureStaticWebApp AzureStaticWebApps_STATUS
		err := azureStaticWebApp.AssignProperties_From_AzureStaticWebApps_STATUS(source.AzureStaticWebApps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureStaticWebApps_STATUS() to populate field AzureStaticWebApps")
		}
		providers.AzureStaticWebApps = &azureStaticWebApp
	} else {
		providers.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if source.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]CustomOpenIdConnectProvider_STATUS, len(source.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range source.CustomOpenIdConnectProviders {
			var customOpenIdConnectProvider CustomOpenIdConnectProvider_STATUS
			err := customOpenIdConnectProvider.AssignProperties_From_CustomOpenIdConnectProvider_STATUS(&customOpenIdConnectProviderValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CustomOpenIdConnectProvider_STATUS() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		providers.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		providers.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if source.Facebook != nil {
		var facebook Facebook_STATUS
		err := facebook.AssignProperties_From_Facebook_STATUS(source.Facebook)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Facebook_STATUS() to populate field Facebook")
		}
		providers.Facebook = &facebook
	} else {
		providers.Facebook = nil
	}

	// GitHub
	if source.GitHub != nil {
		var gitHub GitHub_STATUS
		err := gitHub.AssignProperties_From_GitHub_STATUS(source.GitHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GitHub_STATUS() to populate field GitHub")
		}
		providers.GitHub = &gitHub
	} else {
		providers.GitHub = nil
	}

	// Google
	if source.Google != nil {
		var google Google_STATUS
		err := google.AssignProperties_From_Google_STATUS(source.Google)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Google_STATUS() to populate field Google")
		}
		providers.Google = &google
	} else {
		providers.Google = nil
	}

	// Twitter
	if source.Twitter != nil {
		var twitter Twitter_STATUS
		err := twitter.AssignProperties_From_Twitter_STATUS(source.Twitter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Twitter_STATUS() to populate field Twitter")
		}
		providers.Twitter = &twitter
	} else {
		providers.Twitter = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		providers.PropertyBag = propertyBag
	} else {
		providers.PropertyBag = nil
	}

	// Invoke the augmentConversionForIdentityProviders_STATUS interface (if implemented) to customize the conversion
	var providersAsAny any = providers
	if augmentedProviders, ok := providersAsAny.(augmentConversionForIdentityProviders_STATUS); ok {
		err := augmentedProviders.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IdentityProviders_STATUS populates the provided destination IdentityProviders_STATUS from our IdentityProviders_STATUS
func (providers *IdentityProviders_STATUS) AssignProperties_To_IdentityProviders_STATUS(destination *storage.IdentityProviders_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(providers.PropertyBag)

	// Apple
	if providers.Apple != nil {
		var apple storage.Apple_STATUS
		err := providers.Apple.AssignProperties_To_Apple_STATUS(&apple)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Apple_STATUS() to populate field Apple")
		}
		destination.Apple = &apple
	} else {
		destination.Apple = nil
	}

	// AzureActiveDirectory
	if providers.AzureActiveDirectory != nil {
		var azureActiveDirectory storage.AzureActiveDirectory_STATUS
		err := providers.AzureActiveDirectory.AssignProperties_To_AzureActiveDirectory_STATUS(&azureActiveDirectory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectory_STATUS() to populate field AzureActiveDirectory")
		}
		destination.AzureActiveDirectory = &azureActiveDirectory
	} else {
		destination.AzureActiveDirectory = nil
	}

	// AzureStaticWebApps
	if providers.AzureStaticWebApps != nil {
		var azureStaticWebApp storage.AzureStaticWebApps_STATUS
		err := providers.AzureStaticWebApps.AssignProperties_To_AzureStaticWebApps_STATUS(&azureStaticWebApp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureStaticWebApps_STATUS() to populate field AzureStaticWebApps")
		}
		destination.AzureStaticWebApps = &azureStaticWebApp
	} else {
		destination.AzureStaticWebApps = nil
	}

	// CustomOpenIdConnectProviders
	if providers.CustomOpenIdConnectProviders != nil {
		customOpenIdConnectProviderMap := make(map[string]storage.CustomOpenIdConnectProvider_STATUS, len(providers.CustomOpenIdConnectProviders))
		for customOpenIdConnectProviderKey, customOpenIdConnectProviderValue := range providers.CustomOpenIdConnectProviders {
			var customOpenIdConnectProvider storage.CustomOpenIdConnectProvider_STATUS
			err := customOpenIdConnectProviderValue.AssignProperties_To_CustomOpenIdConnectProvider_STATUS(&customOpenIdConnectProvider)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CustomOpenIdConnectProvider_STATUS() to populate field CustomOpenIdConnectProviders")
			}
			customOpenIdConnectProviderMap[customOpenIdConnectProviderKey] = customOpenIdConnectProvider
		}
		destination.CustomOpenIdConnectProviders = customOpenIdConnectProviderMap
	} else {
		destination.CustomOpenIdConnectProviders = nil
	}

	// Facebook
	if providers.Facebook != nil {
		var facebook storage.Facebook_STATUS
		err := providers.Facebook.AssignProperties_To_Facebook_STATUS(&facebook)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Facebook_STATUS() to populate field Facebook")
		}
		destination.Facebook = &facebook
	} else {
		destination.Facebook = nil
	}

	// GitHub
	if providers.GitHub != nil {
		var gitHub storage.GitHub_STATUS
		err := providers.GitHub.AssignProperties_To_GitHub_STATUS(&gitHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GitHub_STATUS() to populate field GitHub")
		}
		destination.GitHub = &gitHub
	} else {
		destination.GitHub = nil
	}

	// Google
	if providers.Google != nil {
		var google storage.Google_STATUS
		err := providers.Google.AssignProperties_To_Google_STATUS(&google)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Google_STATUS() to populate field Google")
		}
		destination.Google = &google
	} else {
		destination.Google = nil
	}

	// Twitter
	if providers.Twitter != nil {
		var twitter storage.Twitter_STATUS
		err := providers.Twitter.AssignProperties_To_Twitter_STATUS(&twitter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Twitter_STATUS() to populate field Twitter")
		}
		destination.Twitter = &twitter
	} else {
		destination.Twitter = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIdentityProviders_STATUS interface (if implemented) to customize the conversion
	var providersAsAny any = providers
	if augmentedProviders, ok := providersAsAny.(augmentConversionForIdentityProviders_STATUS); ok {
		err := augmentedProviders.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Login
// The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
type Login struct {
	AllowedExternalRedirectUrls   []string               `json:"allowedExternalRedirectUrls,omitempty"`
	CookieExpiration              *CookieExpiration      `json:"cookieExpiration,omitempty"`
	Nonce                         *Nonce                 `json:"nonce,omitempty"`
	PreserveUrlFragmentsForLogins *bool                  `json:"preserveUrlFragmentsForLogins,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Routes                        *LoginRoutes           `json:"routes,omitempty"`
	TokenStore                    *TokenStore            `json:"tokenStore,omitempty"`
}

// AssignProperties_From_Login populates our Login from the provided source Login
func (login *Login) AssignProperties_From_Login(source *storage.Login) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedExternalRedirectUrls
	login.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(source.AllowedExternalRedirectUrls)

	// CookieExpiration
	if source.CookieExpiration != nil {
		var cookieExpiration CookieExpiration
		err := cookieExpiration.AssignProperties_From_CookieExpiration(source.CookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CookieExpiration() to populate field CookieExpiration")
		}
		login.CookieExpiration = &cookieExpiration
	} else {
		login.CookieExpiration = nil
	}

	// Nonce
	if source.Nonce != nil {
		var nonce Nonce
		err := nonce.AssignProperties_From_Nonce(source.Nonce)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Nonce() to populate field Nonce")
		}
		login.Nonce = &nonce
	} else {
		login.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if source.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *source.PreserveUrlFragmentsForLogins
		login.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		login.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if source.Routes != nil {
		var route LoginRoutes
		err := route.AssignProperties_From_LoginRoutes(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginRoutes() to populate field Routes")
		}
		login.Routes = &route
	} else {
		login.Routes = nil
	}

	// TokenStore
	if source.TokenStore != nil {
		var tokenStore TokenStore
		err := tokenStore.AssignProperties_From_TokenStore(source.TokenStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenStore() to populate field TokenStore")
		}
		login.TokenStore = &tokenStore
	} else {
		login.TokenStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		login.PropertyBag = propertyBag
	} else {
		login.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogin interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForLogin); ok {
		err := augmentedLogin.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Login populates the provided destination Login from our Login
func (login *Login) AssignProperties_To_Login(destination *storage.Login) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(login.PropertyBag)

	// AllowedExternalRedirectUrls
	destination.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(login.AllowedExternalRedirectUrls)

	// CookieExpiration
	if login.CookieExpiration != nil {
		var cookieExpiration storage.CookieExpiration
		err := login.CookieExpiration.AssignProperties_To_CookieExpiration(&cookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CookieExpiration() to populate field CookieExpiration")
		}
		destination.CookieExpiration = &cookieExpiration
	} else {
		destination.CookieExpiration = nil
	}

	// Nonce
	if login.Nonce != nil {
		var nonce storage.Nonce
		err := login.Nonce.AssignProperties_To_Nonce(&nonce)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Nonce() to populate field Nonce")
		}
		destination.Nonce = &nonce
	} else {
		destination.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if login.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *login.PreserveUrlFragmentsForLogins
		destination.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		destination.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if login.Routes != nil {
		var route storage.LoginRoutes
		err := login.Routes.AssignProperties_To_LoginRoutes(&route)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginRoutes() to populate field Routes")
		}
		destination.Routes = &route
	} else {
		destination.Routes = nil
	}

	// TokenStore
	if login.TokenStore != nil {
		var tokenStore storage.TokenStore
		err := login.TokenStore.AssignProperties_To_TokenStore(&tokenStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenStore() to populate field TokenStore")
		}
		destination.TokenStore = &tokenStore
	} else {
		destination.TokenStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogin interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForLogin); ok {
		err := augmentedLogin.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Login_STATUS
// The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
type Login_STATUS struct {
	AllowedExternalRedirectUrls   []string                 `json:"allowedExternalRedirectUrls,omitempty"`
	CookieExpiration              *CookieExpiration_STATUS `json:"cookieExpiration,omitempty"`
	Nonce                         *Nonce_STATUS            `json:"nonce,omitempty"`
	PreserveUrlFragmentsForLogins *bool                    `json:"preserveUrlFragmentsForLogins,omitempty"`
	PropertyBag                   genruntime.PropertyBag   `json:"$propertyBag,omitempty"`
	Routes                        *LoginRoutes_STATUS      `json:"routes,omitempty"`
	TokenStore                    *TokenStore_STATUS       `json:"tokenStore,omitempty"`
}

// AssignProperties_From_Login_STATUS populates our Login_STATUS from the provided source Login_STATUS
func (login *Login_STATUS) AssignProperties_From_Login_STATUS(source *storage.Login_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedExternalRedirectUrls
	login.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(source.AllowedExternalRedirectUrls)

	// CookieExpiration
	if source.CookieExpiration != nil {
		var cookieExpiration CookieExpiration_STATUS
		err := cookieExpiration.AssignProperties_From_CookieExpiration_STATUS(source.CookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CookieExpiration_STATUS() to populate field CookieExpiration")
		}
		login.CookieExpiration = &cookieExpiration
	} else {
		login.CookieExpiration = nil
	}

	// Nonce
	if source.Nonce != nil {
		var nonce Nonce_STATUS
		err := nonce.AssignProperties_From_Nonce_STATUS(source.Nonce)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Nonce_STATUS() to populate field Nonce")
		}
		login.Nonce = &nonce
	} else {
		login.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if source.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *source.PreserveUrlFragmentsForLogins
		login.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		login.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if source.Routes != nil {
		var route LoginRoutes_STATUS
		err := route.AssignProperties_From_LoginRoutes_STATUS(source.Routes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginRoutes_STATUS() to populate field Routes")
		}
		login.Routes = &route
	} else {
		login.Routes = nil
	}

	// TokenStore
	if source.TokenStore != nil {
		var tokenStore TokenStore_STATUS
		err := tokenStore.AssignProperties_From_TokenStore_STATUS(source.TokenStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenStore_STATUS() to populate field TokenStore")
		}
		login.TokenStore = &tokenStore
	} else {
		login.TokenStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		login.PropertyBag = propertyBag
	} else {
		login.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogin_STATUS interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForLogin_STATUS); ok {
		err := augmentedLogin.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Login_STATUS populates the provided destination Login_STATUS from our Login_STATUS
func (login *Login_STATUS) AssignProperties_To_Login_STATUS(destination *storage.Login_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(login.PropertyBag)

	// AllowedExternalRedirectUrls
	destination.AllowedExternalRedirectUrls = genruntime.CloneSliceOfString(login.AllowedExternalRedirectUrls)

	// CookieExpiration
	if login.CookieExpiration != nil {
		var cookieExpiration storage.CookieExpiration_STATUS
		err := login.CookieExpiration.AssignProperties_To_CookieExpiration_STATUS(&cookieExpiration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CookieExpiration_STATUS() to populate field CookieExpiration")
		}
		destination.CookieExpiration = &cookieExpiration
	} else {
		destination.CookieExpiration = nil
	}

	// Nonce
	if login.Nonce != nil {
		var nonce storage.Nonce_STATUS
		err := login.Nonce.AssignProperties_To_Nonce_STATUS(&nonce)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Nonce_STATUS() to populate field Nonce")
		}
		destination.Nonce = &nonce
	} else {
		destination.Nonce = nil
	}

	// PreserveUrlFragmentsForLogins
	if login.PreserveUrlFragmentsForLogins != nil {
		preserveUrlFragmentsForLogin := *login.PreserveUrlFragmentsForLogins
		destination.PreserveUrlFragmentsForLogins = &preserveUrlFragmentsForLogin
	} else {
		destination.PreserveUrlFragmentsForLogins = nil
	}

	// Routes
	if login.Routes != nil {
		var route storage.LoginRoutes_STATUS
		err := login.Routes.AssignProperties_To_LoginRoutes_STATUS(&route)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginRoutes_STATUS() to populate field Routes")
		}
		destination.Routes = &route
	} else {
		destination.Routes = nil
	}

	// TokenStore
	if login.TokenStore != nil {
		var tokenStore storage.TokenStore_STATUS
		err := login.TokenStore.AssignProperties_To_TokenStore_STATUS(&tokenStore)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenStore_STATUS() to populate field TokenStore")
		}
		destination.TokenStore = &tokenStore
	} else {
		destination.TokenStore = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogin_STATUS interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForLogin_STATUS); ok {
		err := augmentedLogin.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.SystemData_STATUS
// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	CreatedAt          *string                `json:"createdAt,omitempty"`
	CreatedBy          *string                `json:"createdBy,omitempty"`
	CreatedByType      *string                `json:"createdByType,omitempty"`
	LastModifiedAt     *string                `json:"lastModifiedAt,omitempty"`
	LastModifiedBy     *string                `json:"lastModifiedBy,omitempty"`
	LastModifiedByType *string                `json:"lastModifiedByType,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	data.CreatedByType = genruntime.ClonePointerToString(source.CreatedByType)

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	data.LastModifiedByType = genruntime.ClonePointerToString(source.LastModifiedByType)

	// Update the property bag
	if len(propertyBag) > 0 {
		data.PropertyBag = propertyBag
	} else {
		data.PropertyBag = nil
	}

	// Invoke the augmentConversionForSystemData_STATUS interface (if implemented) to customize the conversion
	var dataAsAny any = data
	if augmentedData, ok := dataAsAny.(augmentConversionForSystemData_STATUS); ok {
		err := augmentedData.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(data.PropertyBag)

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	destination.CreatedByType = genruntime.ClonePointerToString(data.CreatedByType)

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	destination.LastModifiedByType = genruntime.ClonePointerToString(data.LastModifiedByType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSystemData_STATUS interface (if implemented) to customize the conversion
	var dataAsAny any = data
	if augmentedData, ok := dataAsAny.(augmentConversionForSystemData_STATUS); ok {
		err := augmentedData.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Apple
// The configuration settings of the Apple provider.
type Apple struct {
	Enabled      *bool                  `json:"enabled,omitempty"`
	Login        *LoginScopes           `json:"login,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Registration *AppleRegistration     `json:"registration,omitempty"`
}

// AssignProperties_From_Apple populates our Apple from the provided source Apple
func (apple *Apple) AssignProperties_From_Apple(source *storage.Apple) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apple.Enabled = &enabled
	} else {
		apple.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.AssignProperties_From_LoginScopes(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes() to populate field Login")
		}
		apple.Login = &login
	} else {
		apple.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppleRegistration
		err := registration.AssignProperties_From_AppleRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppleRegistration() to populate field Registration")
		}
		apple.Registration = &registration
	} else {
		apple.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		apple.PropertyBag = propertyBag
	} else {
		apple.PropertyBag = nil
	}

	// Invoke the augmentConversionForApple interface (if implemented) to customize the conversion
	var appleAsAny any = apple
	if augmentedApple, ok := appleAsAny.(augmentConversionForApple); ok {
		err := augmentedApple.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Apple populates the provided destination Apple from our Apple
func (apple *Apple) AssignProperties_To_Apple(destination *storage.Apple) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(apple.PropertyBag)

	// Enabled
	if apple.Enabled != nil {
		enabled := *apple.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if apple.Login != nil {
		var login storage.LoginScopes
		err := apple.Login.AssignProperties_To_LoginScopes(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if apple.Registration != nil {
		var registration storage.AppleRegistration
		err := apple.Registration.AssignProperties_To_AppleRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppleRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApple interface (if implemented) to customize the conversion
	var appleAsAny any = apple
	if augmentedApple, ok := appleAsAny.(augmentConversionForApple); ok {
		err := augmentedApple.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Apple_STATUS
// The configuration settings of the Apple provider.
type Apple_STATUS struct {
	Enabled      *bool                     `json:"enabled,omitempty"`
	Login        *LoginScopes_STATUS       `json:"login,omitempty"`
	PropertyBag  genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
	Registration *AppleRegistration_STATUS `json:"registration,omitempty"`
}

// AssignProperties_From_Apple_STATUS populates our Apple_STATUS from the provided source Apple_STATUS
func (apple *Apple_STATUS) AssignProperties_From_Apple_STATUS(source *storage.Apple_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apple.Enabled = &enabled
	} else {
		apple.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes_STATUS
		err := login.AssignProperties_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes_STATUS() to populate field Login")
		}
		apple.Login = &login
	} else {
		apple.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppleRegistration_STATUS
		err := registration.AssignProperties_From_AppleRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppleRegistration_STATUS() to populate field Registration")
		}
		apple.Registration = &registration
	} else {
		apple.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		apple.PropertyBag = propertyBag
	} else {
		apple.PropertyBag = nil
	}

	// Invoke the augmentConversionForApple_STATUS interface (if implemented) to customize the conversion
	var appleAsAny any = apple
	if augmentedApple, ok := appleAsAny.(augmentConversionForApple_STATUS); ok {
		err := augmentedApple.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Apple_STATUS populates the provided destination Apple_STATUS from our Apple_STATUS
func (apple *Apple_STATUS) AssignProperties_To_Apple_STATUS(destination *storage.Apple_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(apple.PropertyBag)

	// Enabled
	if apple.Enabled != nil {
		enabled := *apple.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if apple.Login != nil {
		var login storage.LoginScopes_STATUS
		err := apple.Login.AssignProperties_To_LoginScopes_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if apple.Registration != nil {
		var registration storage.AppleRegistration_STATUS
		err := apple.Registration.AssignProperties_To_AppleRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppleRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApple_STATUS interface (if implemented) to customize the conversion
	var appleAsAny any = apple
	if augmentedApple, ok := appleAsAny.(augmentConversionForApple_STATUS); ok {
		err := augmentedApple.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAuthConfigOperatorSpec interface {
	AssignPropertiesFrom(src *storage.AuthConfigOperatorSpec) error
	AssignPropertiesTo(dst *storage.AuthConfigOperatorSpec) error
}

type augmentConversionForAuthPlatform interface {
	AssignPropertiesFrom(src *storage.AuthPlatform) error
	AssignPropertiesTo(dst *storage.AuthPlatform) error
}

type augmentConversionForAuthPlatform_STATUS interface {
	AssignPropertiesFrom(src *storage.AuthPlatform_STATUS) error
	AssignPropertiesTo(dst *storage.AuthPlatform_STATUS) error
}

type augmentConversionForEncryptionSettings interface {
	AssignPropertiesFrom(src *storage.EncryptionSettings) error
	AssignPropertiesTo(dst *storage.EncryptionSettings) error
}

type augmentConversionForEncryptionSettings_STATUS interface {
	AssignPropertiesFrom(src *storage.EncryptionSettings_STATUS) error
	AssignPropertiesTo(dst *storage.EncryptionSettings_STATUS) error
}

type augmentConversionForGlobalValidation interface {
	AssignPropertiesFrom(src *storage.GlobalValidation) error
	AssignPropertiesTo(dst *storage.GlobalValidation) error
}

type augmentConversionForGlobalValidation_STATUS interface {
	AssignPropertiesFrom(src *storage.GlobalValidation_STATUS) error
	AssignPropertiesTo(dst *storage.GlobalValidation_STATUS) error
}

type augmentConversionForHttpSettings interface {
	AssignPropertiesFrom(src *storage.HttpSettings) error
	AssignPropertiesTo(dst *storage.HttpSettings) error
}

type augmentConversionForHttpSettings_STATUS interface {
	AssignPropertiesFrom(src *storage.HttpSettings_STATUS) error
	AssignPropertiesTo(dst *storage.HttpSettings_STATUS) error
}

type augmentConversionForIdentityProviders interface {
	AssignPropertiesFrom(src *storage.IdentityProviders) error
	AssignPropertiesTo(dst *storage.IdentityProviders) error
}

type augmentConversionForIdentityProviders_STATUS interface {
	AssignPropertiesFrom(src *storage.IdentityProviders_STATUS) error
	AssignPropertiesTo(dst *storage.IdentityProviders_STATUS) error
}

type augmentConversionForLogin interface {
	AssignPropertiesFrom(src *storage.Login) error
	AssignPropertiesTo(dst *storage.Login) error
}

type augmentConversionForLogin_STATUS interface {
	AssignPropertiesFrom(src *storage.Login_STATUS) error
	AssignPropertiesTo(dst *storage.Login_STATUS) error
}

type augmentConversionForSystemData_STATUS interface {
	AssignPropertiesFrom(src *storage.SystemData_STATUS) error
	AssignPropertiesTo(dst *storage.SystemData_STATUS) error
}

// Storage version of v1api20240301.AzureActiveDirectory
// The configuration settings of the Azure Active directory provider.
type AzureActiveDirectory struct {
	Enabled           *bool                             `json:"enabled,omitempty"`
	IsAutoProvisioned *bool                             `json:"isAutoProvisioned,omitempty"`
	Login             *AzureActiveDirectoryLogin        `json:"login,omitempty"`
	PropertyBag       genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	Registration      *AzureActiveDirectoryRegistration `json:"registration,omitempty"`
	Validation        *AzureActiveDirectoryValidation   `json:"validation,omitempty"`
}

// AssignProperties_From_AzureActiveDirectory populates our AzureActiveDirectory from the provided source AzureActiveDirectory
func (directory *AzureActiveDirectory) AssignProperties_From_AzureActiveDirectory(source *storage.AzureActiveDirectory) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		directory.Enabled = &enabled
	} else {
		directory.Enabled = nil
	}

	// IsAutoProvisioned
	if source.IsAutoProvisioned != nil {
		isAutoProvisioned := *source.IsAutoProvisioned
		directory.IsAutoProvisioned = &isAutoProvisioned
	} else {
		directory.IsAutoProvisioned = nil
	}

	// Login
	if source.Login != nil {
		var login AzureActiveDirectoryLogin
		err := login.AssignProperties_From_AzureActiveDirectoryLogin(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryLogin() to populate field Login")
		}
		directory.Login = &login
	} else {
		directory.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureActiveDirectoryRegistration
		err := registration.AssignProperties_From_AzureActiveDirectoryRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryRegistration() to populate field Registration")
		}
		directory.Registration = &registration
	} else {
		directory.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AzureActiveDirectoryValidation
		err := validation.AssignProperties_From_AzureActiveDirectoryValidation(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryValidation() to populate field Validation")
		}
		directory.Validation = &validation
	} else {
		directory.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		directory.PropertyBag = propertyBag
	} else {
		directory.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectory interface (if implemented) to customize the conversion
	var directoryAsAny any = directory
	if augmentedDirectory, ok := directoryAsAny.(augmentConversionForAzureActiveDirectory); ok {
		err := augmentedDirectory.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectory populates the provided destination AzureActiveDirectory from our AzureActiveDirectory
func (directory *AzureActiveDirectory) AssignProperties_To_AzureActiveDirectory(destination *storage.AzureActiveDirectory) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(directory.PropertyBag)

	// Enabled
	if directory.Enabled != nil {
		enabled := *directory.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IsAutoProvisioned
	if directory.IsAutoProvisioned != nil {
		isAutoProvisioned := *directory.IsAutoProvisioned
		destination.IsAutoProvisioned = &isAutoProvisioned
	} else {
		destination.IsAutoProvisioned = nil
	}

	// Login
	if directory.Login != nil {
		var login storage.AzureActiveDirectoryLogin
		err := directory.Login.AssignProperties_To_AzureActiveDirectoryLogin(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryLogin() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if directory.Registration != nil {
		var registration storage.AzureActiveDirectoryRegistration
		err := directory.Registration.AssignProperties_To_AzureActiveDirectoryRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Validation
	if directory.Validation != nil {
		var validation storage.AzureActiveDirectoryValidation
		err := directory.Validation.AssignProperties_To_AzureActiveDirectoryValidation(&validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryValidation() to populate field Validation")
		}
		destination.Validation = &validation
	} else {
		destination.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectory interface (if implemented) to customize the conversion
	var directoryAsAny any = directory
	if augmentedDirectory, ok := directoryAsAny.(augmentConversionForAzureActiveDirectory); ok {
		err := augmentedDirectory.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureActiveDirectory_STATUS
// The configuration settings of the Azure Active directory provider.
type AzureActiveDirectory_STATUS struct {
	Enabled           *bool                                    `json:"enabled,omitempty"`
	IsAutoProvisioned *bool                                    `json:"isAutoProvisioned,omitempty"`
	Login             *AzureActiveDirectoryLogin_STATUS        `json:"login,omitempty"`
	PropertyBag       genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
	Registration      *AzureActiveDirectoryRegistration_STATUS `json:"registration,omitempty"`
	Validation        *AzureActiveDirectoryValidation_STATUS   `json:"validation,omitempty"`
}

// AssignProperties_From_AzureActiveDirectory_STATUS populates our AzureActiveDirectory_STATUS from the provided source AzureActiveDirectory_STATUS
func (directory *AzureActiveDirectory_STATUS) AssignProperties_From_AzureActiveDirectory_STATUS(source *storage.AzureActiveDirectory_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		directory.Enabled = &enabled
	} else {
		directory.Enabled = nil
	}

	// IsAutoProvisioned
	if source.IsAutoProvisioned != nil {
		isAutoProvisioned := *source.IsAutoProvisioned
		directory.IsAutoProvisioned = &isAutoProvisioned
	} else {
		directory.IsAutoProvisioned = nil
	}

	// Login
	if source.Login != nil {
		var login AzureActiveDirectoryLogin_STATUS
		err := login.AssignProperties_From_AzureActiveDirectoryLogin_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryLogin_STATUS() to populate field Login")
		}
		directory.Login = &login
	} else {
		directory.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureActiveDirectoryRegistration_STATUS
		err := registration.AssignProperties_From_AzureActiveDirectoryRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryRegistration_STATUS() to populate field Registration")
		}
		directory.Registration = &registration
	} else {
		directory.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AzureActiveDirectoryValidation_STATUS
		err := validation.AssignProperties_From_AzureActiveDirectoryValidation_STATUS(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureActiveDirectoryValidation_STATUS() to populate field Validation")
		}
		directory.Validation = &validation
	} else {
		directory.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		directory.PropertyBag = propertyBag
	} else {
		directory.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectory_STATUS interface (if implemented) to customize the conversion
	var directoryAsAny any = directory
	if augmentedDirectory, ok := directoryAsAny.(augmentConversionForAzureActiveDirectory_STATUS); ok {
		err := augmentedDirectory.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectory_STATUS populates the provided destination AzureActiveDirectory_STATUS from our AzureActiveDirectory_STATUS
func (directory *AzureActiveDirectory_STATUS) AssignProperties_To_AzureActiveDirectory_STATUS(destination *storage.AzureActiveDirectory_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(directory.PropertyBag)

	// Enabled
	if directory.Enabled != nil {
		enabled := *directory.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IsAutoProvisioned
	if directory.IsAutoProvisioned != nil {
		isAutoProvisioned := *directory.IsAutoProvisioned
		destination.IsAutoProvisioned = &isAutoProvisioned
	} else {
		destination.IsAutoProvisioned = nil
	}

	// Login
	if directory.Login != nil {
		var login storage.AzureActiveDirectoryLogin_STATUS
		err := directory.Login.AssignProperties_To_AzureActiveDirectoryLogin_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryLogin_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if directory.Registration != nil {
		var registration storage.AzureActiveDirectoryRegistration_STATUS
		err := directory.Registration.AssignProperties_To_AzureActiveDirectoryRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Validation
	if directory.Validation != nil {
		var validation storage.AzureActiveDirectoryValidation_STATUS
		err := directory.Validation.AssignProperties_To_AzureActiveDirectoryValidation_STATUS(&validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureActiveDirectoryValidation_STATUS() to populate field Validation")
		}
		destination.Validation = &validation
	} else {
		destination.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectory_STATUS interface (if implemented) to customize the conversion
	var directoryAsAny any = directory
	if augmentedDirectory, ok := directoryAsAny.(augmentConversionForAzureActiveDirectory_STATUS); ok {
		err := augmentedDirectory.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureStaticWebApps
// The configuration settings of the Azure Static Web Apps provider.
type AzureStaticWebApps struct {
	Enabled      *bool                           `json:"enabled,omitempty"`
	PropertyBag  genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	Registration *AzureStaticWebAppsRegistration `json:"registration,omitempty"`
}

// AssignProperties_From_AzureStaticWebApps populates our AzureStaticWebApps from the provided source AzureStaticWebApps
func (apps *AzureStaticWebApps) AssignProperties_From_AzureStaticWebApps(source *storage.AzureStaticWebApps) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apps.Enabled = &enabled
	} else {
		apps.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureStaticWebAppsRegistration
		err := registration.AssignProperties_From_AzureStaticWebAppsRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureStaticWebAppsRegistration() to populate field Registration")
		}
		apps.Registration = &registration
	} else {
		apps.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		apps.PropertyBag = propertyBag
	} else {
		apps.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureStaticWebApps interface (if implemented) to customize the conversion
	var appsAsAny any = apps
	if augmentedApps, ok := appsAsAny.(augmentConversionForAzureStaticWebApps); ok {
		err := augmentedApps.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStaticWebApps populates the provided destination AzureStaticWebApps from our AzureStaticWebApps
func (apps *AzureStaticWebApps) AssignProperties_To_AzureStaticWebApps(destination *storage.AzureStaticWebApps) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(apps.PropertyBag)

	// Enabled
	if apps.Enabled != nil {
		enabled := *apps.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Registration
	if apps.Registration != nil {
		var registration storage.AzureStaticWebAppsRegistration
		err := apps.Registration.AssignProperties_To_AzureStaticWebAppsRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureStaticWebAppsRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureStaticWebApps interface (if implemented) to customize the conversion
	var appsAsAny any = apps
	if augmentedApps, ok := appsAsAny.(augmentConversionForAzureStaticWebApps); ok {
		err := augmentedApps.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureStaticWebApps_STATUS
// The configuration settings of the Azure Static Web Apps provider.
type AzureStaticWebApps_STATUS struct {
	Enabled      *bool                                  `json:"enabled,omitempty"`
	PropertyBag  genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	Registration *AzureStaticWebAppsRegistration_STATUS `json:"registration,omitempty"`
}

// AssignProperties_From_AzureStaticWebApps_STATUS populates our AzureStaticWebApps_STATUS from the provided source AzureStaticWebApps_STATUS
func (apps *AzureStaticWebApps_STATUS) AssignProperties_From_AzureStaticWebApps_STATUS(source *storage.AzureStaticWebApps_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		apps.Enabled = &enabled
	} else {
		apps.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AzureStaticWebAppsRegistration_STATUS
		err := registration.AssignProperties_From_AzureStaticWebAppsRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureStaticWebAppsRegistration_STATUS() to populate field Registration")
		}
		apps.Registration = &registration
	} else {
		apps.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		apps.PropertyBag = propertyBag
	} else {
		apps.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureStaticWebApps_STATUS interface (if implemented) to customize the conversion
	var appsAsAny any = apps
	if augmentedApps, ok := appsAsAny.(augmentConversionForAzureStaticWebApps_STATUS); ok {
		err := augmentedApps.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStaticWebApps_STATUS populates the provided destination AzureStaticWebApps_STATUS from our AzureStaticWebApps_STATUS
func (apps *AzureStaticWebApps_STATUS) AssignProperties_To_AzureStaticWebApps_STATUS(destination *storage.AzureStaticWebApps_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(apps.PropertyBag)

	// Enabled
	if apps.Enabled != nil {
		enabled := *apps.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Registration
	if apps.Registration != nil {
		var registration storage.AzureStaticWebAppsRegistration_STATUS
		err := apps.Registration.AssignProperties_To_AzureStaticWebAppsRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureStaticWebAppsRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureStaticWebApps_STATUS interface (if implemented) to customize the conversion
	var appsAsAny any = apps
	if augmentedApps, ok := appsAsAny.(augmentConversionForAzureStaticWebApps_STATUS); ok {
		err := augmentedApps.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CookieExpiration
// The configuration settings of the session cookie's expiration.
type CookieExpiration struct {
	Convention       *string                `json:"convention,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TimeToExpiration *string                `json:"timeToExpiration,omitempty"`
}

// AssignProperties_From_CookieExpiration populates our CookieExpiration from the provided source CookieExpiration
func (expiration *CookieExpiration) AssignProperties_From_CookieExpiration(source *storage.CookieExpiration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Convention
	expiration.Convention = genruntime.ClonePointerToString(source.Convention)

	// TimeToExpiration
	expiration.TimeToExpiration = genruntime.ClonePointerToString(source.TimeToExpiration)

	// Update the property bag
	if len(propertyBag) > 0 {
		expiration.PropertyBag = propertyBag
	} else {
		expiration.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookieExpiration interface (if implemented) to customize the conversion
	var expirationAsAny any = expiration
	if augmentedExpiration, ok := expirationAsAny.(augmentConversionForCookieExpiration); ok {
		err := augmentedExpiration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CookieExpiration populates the provided destination CookieExpiration from our CookieExpiration
func (expiration *CookieExpiration) AssignProperties_To_CookieExpiration(destination *storage.CookieExpiration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(expiration.PropertyBag)

	// Convention
	destination.Convention = genruntime.ClonePointerToString(expiration.Convention)

	// TimeToExpiration
	destination.TimeToExpiration = genruntime.ClonePointerToString(expiration.TimeToExpiration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookieExpiration interface (if implemented) to customize the conversion
	var expirationAsAny any = expiration
	if augmentedExpiration, ok := expirationAsAny.(augmentConversionForCookieExpiration); ok {
		err := augmentedExpiration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CookieExpiration_STATUS
// The configuration settings of the session cookie's expiration.
type CookieExpiration_STATUS struct {
	Convention       *string                `json:"convention,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TimeToExpiration *string                `json:"timeToExpiration,omitempty"`
}

// AssignProperties_From_CookieExpiration_STATUS populates our CookieExpiration_STATUS from the provided source CookieExpiration_STATUS
func (expiration *CookieExpiration_STATUS) AssignProperties_From_CookieExpiration_STATUS(source *storage.CookieExpiration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Convention
	expiration.Convention = genruntime.ClonePointerToString(source.Convention)

	// TimeToExpiration
	expiration.TimeToExpiration = genruntime.ClonePointerToString(source.TimeToExpiration)

	// Update the property bag
	if len(propertyBag) > 0 {
		expiration.PropertyBag = propertyBag
	} else {
		expiration.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookieExpiration_STATUS interface (if implemented) to customize the conversion
	var expirationAsAny any = expiration
	if augmentedExpiration, ok := expirationAsAny.(augmentConversionForCookieExpiration_STATUS); ok {
		err := augmentedExpiration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CookieExpiration_STATUS populates the provided destination CookieExpiration_STATUS from our CookieExpiration_STATUS
func (expiration *CookieExpiration_STATUS) AssignProperties_To_CookieExpiration_STATUS(destination *storage.CookieExpiration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(expiration.PropertyBag)

	// Convention
	destination.Convention = genruntime.ClonePointerToString(expiration.Convention)

	// TimeToExpiration
	destination.TimeToExpiration = genruntime.ClonePointerToString(expiration.TimeToExpiration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookieExpiration_STATUS interface (if implemented) to customize the conversion
	var expirationAsAny any = expiration
	if augmentedExpiration, ok := expirationAsAny.(augmentConversionForCookieExpiration_STATUS); ok {
		err := augmentedExpiration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CustomOpenIdConnectProvider
// The configuration settings of the custom Open ID Connect provider.
type CustomOpenIdConnectProvider struct {
	Enabled      *bool                      `json:"enabled,omitempty"`
	Login        *OpenIdConnectLogin        `json:"login,omitempty"`
	PropertyBag  genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Registration *OpenIdConnectRegistration `json:"registration,omitempty"`
}

// AssignProperties_From_CustomOpenIdConnectProvider populates our CustomOpenIdConnectProvider from the provided source CustomOpenIdConnectProvider
func (provider *CustomOpenIdConnectProvider) AssignProperties_From_CustomOpenIdConnectProvider(source *storage.CustomOpenIdConnectProvider) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		provider.Enabled = &enabled
	} else {
		provider.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login OpenIdConnectLogin
		err := login.AssignProperties_From_OpenIdConnectLogin(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectLogin() to populate field Login")
		}
		provider.Login = &login
	} else {
		provider.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration OpenIdConnectRegistration
		err := registration.AssignProperties_From_OpenIdConnectRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectRegistration() to populate field Registration")
		}
		provider.Registration = &registration
	} else {
		provider.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		provider.PropertyBag = propertyBag
	} else {
		provider.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomOpenIdConnectProvider interface (if implemented) to customize the conversion
	var providerAsAny any = provider
	if augmentedProvider, ok := providerAsAny.(augmentConversionForCustomOpenIdConnectProvider); ok {
		err := augmentedProvider.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CustomOpenIdConnectProvider populates the provided destination CustomOpenIdConnectProvider from our CustomOpenIdConnectProvider
func (provider *CustomOpenIdConnectProvider) AssignProperties_To_CustomOpenIdConnectProvider(destination *storage.CustomOpenIdConnectProvider) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(provider.PropertyBag)

	// Enabled
	if provider.Enabled != nil {
		enabled := *provider.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if provider.Login != nil {
		var login storage.OpenIdConnectLogin
		err := provider.Login.AssignProperties_To_OpenIdConnectLogin(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectLogin() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if provider.Registration != nil {
		var registration storage.OpenIdConnectRegistration
		err := provider.Registration.AssignProperties_To_OpenIdConnectRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomOpenIdConnectProvider interface (if implemented) to customize the conversion
	var providerAsAny any = provider
	if augmentedProvider, ok := providerAsAny.(augmentConversionForCustomOpenIdConnectProvider); ok {
		err := augmentedProvider.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CustomOpenIdConnectProvider_STATUS
// The configuration settings of the custom Open ID Connect provider.
type CustomOpenIdConnectProvider_STATUS struct {
	Enabled      *bool                             `json:"enabled,omitempty"`
	Login        *OpenIdConnectLogin_STATUS        `json:"login,omitempty"`
	PropertyBag  genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	Registration *OpenIdConnectRegistration_STATUS `json:"registration,omitempty"`
}

// AssignProperties_From_CustomOpenIdConnectProvider_STATUS populates our CustomOpenIdConnectProvider_STATUS from the provided source CustomOpenIdConnectProvider_STATUS
func (provider *CustomOpenIdConnectProvider_STATUS) AssignProperties_From_CustomOpenIdConnectProvider_STATUS(source *storage.CustomOpenIdConnectProvider_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		provider.Enabled = &enabled
	} else {
		provider.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login OpenIdConnectLogin_STATUS
		err := login.AssignProperties_From_OpenIdConnectLogin_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectLogin_STATUS() to populate field Login")
		}
		provider.Login = &login
	} else {
		provider.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration OpenIdConnectRegistration_STATUS
		err := registration.AssignProperties_From_OpenIdConnectRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectRegistration_STATUS() to populate field Registration")
		}
		provider.Registration = &registration
	} else {
		provider.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		provider.PropertyBag = propertyBag
	} else {
		provider.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomOpenIdConnectProvider_STATUS interface (if implemented) to customize the conversion
	var providerAsAny any = provider
	if augmentedProvider, ok := providerAsAny.(augmentConversionForCustomOpenIdConnectProvider_STATUS); ok {
		err := augmentedProvider.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CustomOpenIdConnectProvider_STATUS populates the provided destination CustomOpenIdConnectProvider_STATUS from our CustomOpenIdConnectProvider_STATUS
func (provider *CustomOpenIdConnectProvider_STATUS) AssignProperties_To_CustomOpenIdConnectProvider_STATUS(destination *storage.CustomOpenIdConnectProvider_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(provider.PropertyBag)

	// Enabled
	if provider.Enabled != nil {
		enabled := *provider.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if provider.Login != nil {
		var login storage.OpenIdConnectLogin_STATUS
		err := provider.Login.AssignProperties_To_OpenIdConnectLogin_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectLogin_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if provider.Registration != nil {
		var registration storage.OpenIdConnectRegistration_STATUS
		err := provider.Registration.AssignProperties_To_OpenIdConnectRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomOpenIdConnectProvider_STATUS interface (if implemented) to customize the conversion
	var providerAsAny any = provider
	if augmentedProvider, ok := providerAsAny.(augmentConversionForCustomOpenIdConnectProvider_STATUS); ok {
		err := augmentedProvider.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Facebook
// The configuration settings of the Facebook provider.
type Facebook struct {
	Enabled         *bool                  `json:"enabled,omitempty"`
	GraphApiVersion *string                `json:"graphApiVersion,omitempty"`
	Login           *LoginScopes           `json:"login,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Registration    *AppRegistration       `json:"registration,omitempty"`
}

// AssignProperties_From_Facebook populates our Facebook from the provided source Facebook
func (facebook *Facebook) AssignProperties_From_Facebook(source *storage.Facebook) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		facebook.Enabled = &enabled
	} else {
		facebook.Enabled = nil
	}

	// GraphApiVersion
	facebook.GraphApiVersion = genruntime.ClonePointerToString(source.GraphApiVersion)

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.AssignProperties_From_LoginScopes(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes() to populate field Login")
		}
		facebook.Login = &login
	} else {
		facebook.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppRegistration
		err := registration.AssignProperties_From_AppRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppRegistration() to populate field Registration")
		}
		facebook.Registration = &registration
	} else {
		facebook.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		facebook.PropertyBag = propertyBag
	} else {
		facebook.PropertyBag = nil
	}

	// Invoke the augmentConversionForFacebook interface (if implemented) to customize the conversion
	var facebookAsAny any = facebook
	if augmentedFacebook, ok := facebookAsAny.(augmentConversionForFacebook); ok {
		err := augmentedFacebook.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Facebook populates the provided destination Facebook from our Facebook
func (facebook *Facebook) AssignProperties_To_Facebook(destination *storage.Facebook) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(facebook.PropertyBag)

	// Enabled
	if facebook.Enabled != nil {
		enabled := *facebook.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GraphApiVersion
	destination.GraphApiVersion = genruntime.ClonePointerToString(facebook.GraphApiVersion)

	// Login
	if facebook.Login != nil {
		var login storage.LoginScopes
		err := facebook.Login.AssignProperties_To_LoginScopes(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if facebook.Registration != nil {
		var registration storage.AppRegistration
		err := facebook.Registration.AssignProperties_To_AppRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForFacebook interface (if implemented) to customize the conversion
	var facebookAsAny any = facebook
	if augmentedFacebook, ok := facebookAsAny.(augmentConversionForFacebook); ok {
		err := augmentedFacebook.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Facebook_STATUS
// The configuration settings of the Facebook provider.
type Facebook_STATUS struct {
	Enabled         *bool                   `json:"enabled,omitempty"`
	GraphApiVersion *string                 `json:"graphApiVersion,omitempty"`
	Login           *LoginScopes_STATUS     `json:"login,omitempty"`
	PropertyBag     genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
	Registration    *AppRegistration_STATUS `json:"registration,omitempty"`
}

// AssignProperties_From_Facebook_STATUS populates our Facebook_STATUS from the provided source Facebook_STATUS
func (facebook *Facebook_STATUS) AssignProperties_From_Facebook_STATUS(source *storage.Facebook_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		facebook.Enabled = &enabled
	} else {
		facebook.Enabled = nil
	}

	// GraphApiVersion
	facebook.GraphApiVersion = genruntime.ClonePointerToString(source.GraphApiVersion)

	// Login
	if source.Login != nil {
		var login LoginScopes_STATUS
		err := login.AssignProperties_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes_STATUS() to populate field Login")
		}
		facebook.Login = &login
	} else {
		facebook.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration AppRegistration_STATUS
		err := registration.AssignProperties_From_AppRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppRegistration_STATUS() to populate field Registration")
		}
		facebook.Registration = &registration
	} else {
		facebook.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		facebook.PropertyBag = propertyBag
	} else {
		facebook.PropertyBag = nil
	}

	// Invoke the augmentConversionForFacebook_STATUS interface (if implemented) to customize the conversion
	var facebookAsAny any = facebook
	if augmentedFacebook, ok := facebookAsAny.(augmentConversionForFacebook_STATUS); ok {
		err := augmentedFacebook.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Facebook_STATUS populates the provided destination Facebook_STATUS from our Facebook_STATUS
func (facebook *Facebook_STATUS) AssignProperties_To_Facebook_STATUS(destination *storage.Facebook_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(facebook.PropertyBag)

	// Enabled
	if facebook.Enabled != nil {
		enabled := *facebook.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GraphApiVersion
	destination.GraphApiVersion = genruntime.ClonePointerToString(facebook.GraphApiVersion)

	// Login
	if facebook.Login != nil {
		var login storage.LoginScopes_STATUS
		err := facebook.Login.AssignProperties_To_LoginScopes_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if facebook.Registration != nil {
		var registration storage.AppRegistration_STATUS
		err := facebook.Registration.AssignProperties_To_AppRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForFacebook_STATUS interface (if implemented) to customize the conversion
	var facebookAsAny any = facebook
	if augmentedFacebook, ok := facebookAsAny.(augmentConversionForFacebook_STATUS); ok {
		err := augmentedFacebook.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ForwardProxy
// The configuration settings of a forward proxy used to make the requests.
type ForwardProxy struct {
	Convention            *string                `json:"convention,omitempty"`
	CustomHostHeaderName  *string                `json:"customHostHeaderName,omitempty"`
	CustomProtoHeaderName *string                `json:"customProtoHeaderName,omitempty"`
	PropertyBag           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ForwardProxy populates our ForwardProxy from the provided source ForwardProxy
func (proxy *ForwardProxy) AssignProperties_From_ForwardProxy(source *storage.ForwardProxy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Convention
	proxy.Convention = genruntime.ClonePointerToString(source.Convention)

	// CustomHostHeaderName
	proxy.CustomHostHeaderName = genruntime.ClonePointerToString(source.CustomHostHeaderName)

	// CustomProtoHeaderName
	proxy.CustomProtoHeaderName = genruntime.ClonePointerToString(source.CustomProtoHeaderName)

	// Update the property bag
	if len(propertyBag) > 0 {
		proxy.PropertyBag = propertyBag
	} else {
		proxy.PropertyBag = nil
	}

	// Invoke the augmentConversionForForwardProxy interface (if implemented) to customize the conversion
	var proxyAsAny any = proxy
	if augmentedProxy, ok := proxyAsAny.(augmentConversionForForwardProxy); ok {
		err := augmentedProxy.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ForwardProxy populates the provided destination ForwardProxy from our ForwardProxy
func (proxy *ForwardProxy) AssignProperties_To_ForwardProxy(destination *storage.ForwardProxy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(proxy.PropertyBag)

	// Convention
	destination.Convention = genruntime.ClonePointerToString(proxy.Convention)

	// CustomHostHeaderName
	destination.CustomHostHeaderName = genruntime.ClonePointerToString(proxy.CustomHostHeaderName)

	// CustomProtoHeaderName
	destination.CustomProtoHeaderName = genruntime.ClonePointerToString(proxy.CustomProtoHeaderName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForForwardProxy interface (if implemented) to customize the conversion
	var proxyAsAny any = proxy
	if augmentedProxy, ok := proxyAsAny.(augmentConversionForForwardProxy); ok {
		err := augmentedProxy.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ForwardProxy_STATUS
// The configuration settings of a forward proxy used to make the requests.
type ForwardProxy_STATUS struct {
	Convention            *string                `json:"convention,omitempty"`
	CustomHostHeaderName  *string                `json:"customHostHeaderName,omitempty"`
	CustomProtoHeaderName *string                `json:"customProtoHeaderName,omitempty"`
	PropertyBag           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ForwardProxy_STATUS populates our ForwardProxy_STATUS from the provided source ForwardProxy_STATUS
func (proxy *ForwardProxy_STATUS) AssignProperties_From_ForwardProxy_STATUS(source *storage.ForwardProxy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Convention
	proxy.Convention = genruntime.ClonePointerToString(source.Convention)

	// CustomHostHeaderName
	proxy.CustomHostHeaderName = genruntime.ClonePointerToString(source.CustomHostHeaderName)

	// CustomProtoHeaderName
	proxy.CustomProtoHeaderName = genruntime.ClonePointerToString(source.CustomProtoHeaderName)

	// Update the property bag
	if len(propertyBag) > 0 {
		proxy.PropertyBag = propertyBag
	} else {
		proxy.PropertyBag = nil
	}

	// Invoke the augmentConversionForForwardProxy_STATUS interface (if implemented) to customize the conversion
	var proxyAsAny any = proxy
	if augmentedProxy, ok := proxyAsAny.(augmentConversionForForwardProxy_STATUS); ok {
		err := augmentedProxy.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ForwardProxy_STATUS populates the provided destination ForwardProxy_STATUS from our ForwardProxy_STATUS
func (proxy *ForwardProxy_STATUS) AssignProperties_To_ForwardProxy_STATUS(destination *storage.ForwardProxy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(proxy.PropertyBag)

	// Convention
	destination.Convention = genruntime.ClonePointerToString(proxy.Convention)

	// CustomHostHeaderName
	destination.CustomHostHeaderName = genruntime.ClonePointerToString(proxy.CustomHostHeaderName)

	// CustomProtoHeaderName
	destination.CustomProtoHeaderName = genruntime.ClonePointerToString(proxy.CustomProtoHeaderName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForForwardProxy_STATUS interface (if implemented) to customize the conversion
	var proxyAsAny any = proxy
	if augmentedProxy, ok := proxyAsAny.(augmentConversionForForwardProxy_STATUS); ok {
		err := augmentedProxy.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.GitHub
// The configuration settings of the GitHub provider.
type GitHub struct {
	Enabled      *bool                  `json:"enabled,omitempty"`
	Login        *LoginScopes           `json:"login,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Registration *ClientRegistration    `json:"registration,omitempty"`
}

// AssignProperties_From_GitHub populates our GitHub from the provided source GitHub
func (gitHub *GitHub) AssignProperties_From_GitHub(source *storage.GitHub) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gitHub.Enabled = &enabled
	} else {
		gitHub.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.AssignProperties_From_LoginScopes(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes() to populate field Login")
		}
		gitHub.Login = &login
	} else {
		gitHub.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration
		err := registration.AssignProperties_From_ClientRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClientRegistration() to populate field Registration")
		}
		gitHub.Registration = &registration
	} else {
		gitHub.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		gitHub.PropertyBag = propertyBag
	} else {
		gitHub.PropertyBag = nil
	}

	// Invoke the augmentConversionForGitHub interface (if implemented) to customize the conversion
	var gitHubAsAny any = gitHub
	if augmentedGitHub, ok := gitHubAsAny.(augmentConversionForGitHub); ok {
		err := augmentedGitHub.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_GitHub populates the provided destination GitHub from our GitHub
func (gitHub *GitHub) AssignProperties_To_GitHub(destination *storage.GitHub) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(gitHub.PropertyBag)

	// Enabled
	if gitHub.Enabled != nil {
		enabled := *gitHub.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if gitHub.Login != nil {
		var login storage.LoginScopes
		err := gitHub.Login.AssignProperties_To_LoginScopes(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if gitHub.Registration != nil {
		var registration storage.ClientRegistration
		err := gitHub.Registration.AssignProperties_To_ClientRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClientRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForGitHub interface (if implemented) to customize the conversion
	var gitHubAsAny any = gitHub
	if augmentedGitHub, ok := gitHubAsAny.(augmentConversionForGitHub); ok {
		err := augmentedGitHub.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.GitHub_STATUS
// The configuration settings of the GitHub provider.
type GitHub_STATUS struct {
	Enabled      *bool                      `json:"enabled,omitempty"`
	Login        *LoginScopes_STATUS        `json:"login,omitempty"`
	PropertyBag  genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Registration *ClientRegistration_STATUS `json:"registration,omitempty"`
}

// AssignProperties_From_GitHub_STATUS populates our GitHub_STATUS from the provided source GitHub_STATUS
func (gitHub *GitHub_STATUS) AssignProperties_From_GitHub_STATUS(source *storage.GitHub_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gitHub.Enabled = &enabled
	} else {
		gitHub.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes_STATUS
		err := login.AssignProperties_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes_STATUS() to populate field Login")
		}
		gitHub.Login = &login
	} else {
		gitHub.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration_STATUS
		err := registration.AssignProperties_From_ClientRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClientRegistration_STATUS() to populate field Registration")
		}
		gitHub.Registration = &registration
	} else {
		gitHub.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		gitHub.PropertyBag = propertyBag
	} else {
		gitHub.PropertyBag = nil
	}

	// Invoke the augmentConversionForGitHub_STATUS interface (if implemented) to customize the conversion
	var gitHubAsAny any = gitHub
	if augmentedGitHub, ok := gitHubAsAny.(augmentConversionForGitHub_STATUS); ok {
		err := augmentedGitHub.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_GitHub_STATUS populates the provided destination GitHub_STATUS from our GitHub_STATUS
func (gitHub *GitHub_STATUS) AssignProperties_To_GitHub_STATUS(destination *storage.GitHub_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(gitHub.PropertyBag)

	// Enabled
	if gitHub.Enabled != nil {
		enabled := *gitHub.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if gitHub.Login != nil {
		var login storage.LoginScopes_STATUS
		err := gitHub.Login.AssignProperties_To_LoginScopes_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if gitHub.Registration != nil {
		var registration storage.ClientRegistration_STATUS
		err := gitHub.Registration.AssignProperties_To_ClientRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClientRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForGitHub_STATUS interface (if implemented) to customize the conversion
	var gitHubAsAny any = gitHub
	if augmentedGitHub, ok := gitHubAsAny.(augmentConversionForGitHub_STATUS); ok {
		err := augmentedGitHub.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Google
// The configuration settings of the Google provider.
type Google struct {
	Enabled      *bool                       `json:"enabled,omitempty"`
	Login        *LoginScopes                `json:"login,omitempty"`
	PropertyBag  genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	Registration *ClientRegistration         `json:"registration,omitempty"`
	Validation   *AllowedAudiencesValidation `json:"validation,omitempty"`
}

// AssignProperties_From_Google populates our Google from the provided source Google
func (google *Google) AssignProperties_From_Google(source *storage.Google) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		google.Enabled = &enabled
	} else {
		google.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes
		err := login.AssignProperties_From_LoginScopes(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes() to populate field Login")
		}
		google.Login = &login
	} else {
		google.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration
		err := registration.AssignProperties_From_ClientRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClientRegistration() to populate field Registration")
		}
		google.Registration = &registration
	} else {
		google.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AllowedAudiencesValidation
		err := validation.AssignProperties_From_AllowedAudiencesValidation(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AllowedAudiencesValidation() to populate field Validation")
		}
		google.Validation = &validation
	} else {
		google.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		google.PropertyBag = propertyBag
	} else {
		google.PropertyBag = nil
	}

	// Invoke the augmentConversionForGoogle interface (if implemented) to customize the conversion
	var googleAsAny any = google
	if augmentedGoogle, ok := googleAsAny.(augmentConversionForGoogle); ok {
		err := augmentedGoogle.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Google populates the provided destination Google from our Google
func (google *Google) AssignProperties_To_Google(destination *storage.Google) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(google.PropertyBag)

	// Enabled
	if google.Enabled != nil {
		enabled := *google.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if google.Login != nil {
		var login storage.LoginScopes
		err := google.Login.AssignProperties_To_LoginScopes(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if google.Registration != nil {
		var registration storage.ClientRegistration
		err := google.Registration.AssignProperties_To_ClientRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClientRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Validation
	if google.Validation != nil {
		var validation storage.AllowedAudiencesValidation
		err := google.Validation.AssignProperties_To_AllowedAudiencesValidation(&validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AllowedAudiencesValidation() to populate field Validation")
		}
		destination.Validation = &validation
	} else {
		destination.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForGoogle interface (if implemented) to customize the conversion
	var googleAsAny any = google
	if augmentedGoogle, ok := googleAsAny.(augmentConversionForGoogle); ok {
		err := augmentedGoogle.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Google_STATUS
// The configuration settings of the Google provider.
type Google_STATUS struct {
	Enabled      *bool                              `json:"enabled,omitempty"`
	Login        *LoginScopes_STATUS                `json:"login,omitempty"`
	PropertyBag  genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Registration *ClientRegistration_STATUS         `json:"registration,omitempty"`
	Validation   *AllowedAudiencesValidation_STATUS `json:"validation,omitempty"`
}

// AssignProperties_From_Google_STATUS populates our Google_STATUS from the provided source Google_STATUS
func (google *Google_STATUS) AssignProperties_From_Google_STATUS(source *storage.Google_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		google.Enabled = &enabled
	} else {
		google.Enabled = nil
	}

	// Login
	if source.Login != nil {
		var login LoginScopes_STATUS
		err := login.AssignProperties_From_LoginScopes_STATUS(source.Login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LoginScopes_STATUS() to populate field Login")
		}
		google.Login = &login
	} else {
		google.Login = nil
	}

	// Registration
	if source.Registration != nil {
		var registration ClientRegistration_STATUS
		err := registration.AssignProperties_From_ClientRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClientRegistration_STATUS() to populate field Registration")
		}
		google.Registration = &registration
	} else {
		google.Registration = nil
	}

	// Validation
	if source.Validation != nil {
		var validation AllowedAudiencesValidation_STATUS
		err := validation.AssignProperties_From_AllowedAudiencesValidation_STATUS(source.Validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AllowedAudiencesValidation_STATUS() to populate field Validation")
		}
		google.Validation = &validation
	} else {
		google.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		google.PropertyBag = propertyBag
	} else {
		google.PropertyBag = nil
	}

	// Invoke the augmentConversionForGoogle_STATUS interface (if implemented) to customize the conversion
	var googleAsAny any = google
	if augmentedGoogle, ok := googleAsAny.(augmentConversionForGoogle_STATUS); ok {
		err := augmentedGoogle.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Google_STATUS populates the provided destination Google_STATUS from our Google_STATUS
func (google *Google_STATUS) AssignProperties_To_Google_STATUS(destination *storage.Google_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(google.PropertyBag)

	// Enabled
	if google.Enabled != nil {
		enabled := *google.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Login
	if google.Login != nil {
		var login storage.LoginScopes_STATUS
		err := google.Login.AssignProperties_To_LoginScopes_STATUS(&login)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LoginScopes_STATUS() to populate field Login")
		}
		destination.Login = &login
	} else {
		destination.Login = nil
	}

	// Registration
	if google.Registration != nil {
		var registration storage.ClientRegistration_STATUS
		err := google.Registration.AssignProperties_To_ClientRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClientRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Validation
	if google.Validation != nil {
		var validation storage.AllowedAudiencesValidation_STATUS
		err := google.Validation.AssignProperties_To_AllowedAudiencesValidation_STATUS(&validation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AllowedAudiencesValidation_STATUS() to populate field Validation")
		}
		destination.Validation = &validation
	} else {
		destination.Validation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForGoogle_STATUS interface (if implemented) to customize the conversion
	var googleAsAny any = google
	if augmentedGoogle, ok := googleAsAny.(augmentConversionForGoogle_STATUS); ok {
		err := augmentedGoogle.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.HttpSettingsRoutes
// The configuration settings of the paths HTTP requests.
type HttpSettingsRoutes struct {
	ApiPrefix   *string                `json:"apiPrefix,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HttpSettingsRoutes populates our HttpSettingsRoutes from the provided source HttpSettingsRoutes
func (routes *HttpSettingsRoutes) AssignProperties_From_HttpSettingsRoutes(source *storage.HttpSettingsRoutes) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApiPrefix
	routes.ApiPrefix = genruntime.ClonePointerToString(source.ApiPrefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		routes.PropertyBag = propertyBag
	} else {
		routes.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpSettingsRoutes interface (if implemented) to customize the conversion
	var routesAsAny any = routes
	if augmentedRoutes, ok := routesAsAny.(augmentConversionForHttpSettingsRoutes); ok {
		err := augmentedRoutes.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpSettingsRoutes populates the provided destination HttpSettingsRoutes from our HttpSettingsRoutes
func (routes *HttpSettingsRoutes) AssignProperties_To_HttpSettingsRoutes(destination *storage.HttpSettingsRoutes) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(routes.PropertyBag)

	// ApiPrefix
	destination.ApiPrefix = genruntime.ClonePointerToString(routes.ApiPrefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpSettingsRoutes interface (if implemented) to customize the conversion
	var routesAsAny any = routes
	if augmentedRoutes, ok := routesAsAny.(augmentConversionForHttpSettingsRoutes); ok {
		err := augmentedRoutes.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.HttpSettingsRoutes_STATUS
// The configuration settings of the paths HTTP requests.
type HttpSettingsRoutes_STATUS struct {
	ApiPrefix   *string                `json:"apiPrefix,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HttpSettingsRoutes_STATUS populates our HttpSettingsRoutes_STATUS from the provided source HttpSettingsRoutes_STATUS
func (routes *HttpSettingsRoutes_STATUS) AssignProperties_From_HttpSettingsRoutes_STATUS(source *storage.HttpSettingsRoutes_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApiPrefix
	routes.ApiPrefix = genruntime.ClonePointerToString(source.ApiPrefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		routes.PropertyBag = propertyBag
	} else {
		routes.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpSettingsRoutes_STATUS interface (if implemented) to customize the conversion
	var routesAsAny any = routes
	if augmentedRoutes, ok := routesAsAny.(augmentConversionForHttpSettingsRoutes_STATUS); ok {
		err := augmentedRoutes.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpSettingsRoutes_STATUS populates the provided destination HttpSettingsRoutes_STATUS from our HttpSettingsRoutes_STATUS
func (routes *HttpSettingsRoutes_STATUS) AssignProperties_To_HttpSettingsRoutes_STATUS(destination *storage.HttpSettingsRoutes_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(routes.PropertyBag)

	// ApiPrefix
	destination.ApiPrefix = genruntime.ClonePointerToString(routes.ApiPrefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpSettingsRoutes_STATUS interface (if implemented) to customize the conversion
	var routesAsAny any = routes
	if augmentedRoutes, ok := routesAsAny.(augmentConversionForHttpSettingsRoutes_STATUS); ok {
		err := augmentedRoutes.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.LoginRoutes
// The routes that specify the endpoints used for login and logout requests.
type LoginRoutes struct {
	LogoutEndpoint *string                `json:"logoutEndpoint,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_LoginRoutes populates our LoginRoutes from the provided source LoginRoutes
func (routes *LoginRoutes) AssignProperties_From_LoginRoutes(source *storage.LoginRoutes) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// LogoutEndpoint
	routes.LogoutEndpoint = genruntime.ClonePointerToString(source.LogoutEndpoint)

	// Update the property bag
	if len(propertyBag) > 0 {
		routes.PropertyBag = propertyBag
	} else {
		routes.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoginRoutes interface (if implemented) to customize the conversion
	var routesAsAny any = routes
	if augmentedRoutes, ok := routesAsAny.(augmentConversionForLoginRoutes); ok {
		err := augmentedRoutes.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoginRoutes populates the provided destination LoginRoutes from our LoginRoutes
func (routes *LoginRoutes) AssignProperties_To_LoginRoutes(destination *storage.LoginRoutes) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(routes.PropertyBag)

	// LogoutEndpoint
	destination.LogoutEndpoint = genruntime.ClonePointerToString(routes.LogoutEndpoint)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoginRoutes interface (if implemented) to customize the conversion
	var routesAsAny any = routes
	if augmentedRoutes, ok := routesAsAny.(augmentConversionForLoginRoutes); ok {
		err := augmentedRoutes.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.LoginRoutes_STATUS
// The routes that specify the endpoints used for login and logout requests.
type LoginRoutes_STATUS struct {
	LogoutEndpoint *string                `json:"logoutEndpoint,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_LoginRoutes_STATUS populates our LoginRoutes_STATUS from the provided source LoginRoutes_STATUS
func (routes *LoginRoutes_STATUS) AssignProperties_From_LoginRoutes_STATUS(source *storage.LoginRoutes_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// LogoutEndpoint
	routes.LogoutEndpoint = genruntime.ClonePointerToString(source.LogoutEndpoint)

	// Update the property bag
	if len(propertyBag) > 0 {
		routes.PropertyBag = propertyBag
	} else {
		routes.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoginRoutes_STATUS interface (if implemented) to customize the conversion
	var routesAsAny any = routes
	if augmentedRoutes, ok := routesAsAny.(augmentConversionForLoginRoutes_STATUS); ok {
		err := augmentedRoutes.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoginRoutes_STATUS populates the provided destination LoginRoutes_STATUS from our LoginRoutes_STATUS
func (routes *LoginRoutes_STATUS) AssignProperties_To_LoginRoutes_STATUS(destination *storage.LoginRoutes_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(routes.PropertyBag)

	// LogoutEndpoint
	destination.LogoutEndpoint = genruntime.ClonePointerToString(routes.LogoutEndpoint)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoginRoutes_STATUS interface (if implemented) to customize the conversion
	var routesAsAny any = routes
	if augmentedRoutes, ok := routesAsAny.(augmentConversionForLoginRoutes_STATUS); ok {
		err := augmentedRoutes.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Nonce
// The configuration settings of the nonce used in the login flow.
type Nonce struct {
	NonceExpirationInterval *string                `json:"nonceExpirationInterval,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ValidateNonce           *bool                  `json:"validateNonce,omitempty"`
}

// AssignProperties_From_Nonce populates our Nonce from the provided source Nonce
func (nonce *Nonce) AssignProperties_From_Nonce(source *storage.Nonce) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NonceExpirationInterval
	nonce.NonceExpirationInterval = genruntime.ClonePointerToString(source.NonceExpirationInterval)

	// ValidateNonce
	if source.ValidateNonce != nil {
		validateNonce := *source.ValidateNonce
		nonce.ValidateNonce = &validateNonce
	} else {
		nonce.ValidateNonce = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		nonce.PropertyBag = propertyBag
	} else {
		nonce.PropertyBag = nil
	}

	// Invoke the augmentConversionForNonce interface (if implemented) to customize the conversion
	var nonceAsAny any = nonce
	if augmentedNonce, ok := nonceAsAny.(augmentConversionForNonce); ok {
		err := augmentedNonce.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Nonce populates the provided destination Nonce from our Nonce
func (nonce *Nonce) AssignProperties_To_Nonce(destination *storage.Nonce) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(nonce.PropertyBag)

	// NonceExpirationInterval
	destination.NonceExpirationInterval = genruntime.ClonePointerToString(nonce.NonceExpirationInterval)

	// ValidateNonce
	if nonce.ValidateNonce != nil {
		validateNonce := *nonce.ValidateNonce
		destination.ValidateNonce = &validateNonce
	} else {
		destination.ValidateNonce = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNonce interface (if implemented) to customize the conversion
	var nonceAsAny any = nonce
	if augmentedNonce, ok := nonceAsAny.(augmentConversionForNonce); ok {
		err := augmentedNonce.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Nonce_STATUS
// The configuration settings of the nonce used in the login flow.
type Nonce_STATUS struct {
	NonceExpirationInterval *string                `json:"nonceExpirationInterval,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ValidateNonce           *bool                  `json:"validateNonce,omitempty"`
}

// AssignProperties_From_Nonce_STATUS populates our Nonce_STATUS from the provided source Nonce_STATUS
func (nonce *Nonce_STATUS) AssignProperties_From_Nonce_STATUS(source *storage.Nonce_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NonceExpirationInterval
	nonce.NonceExpirationInterval = genruntime.ClonePointerToString(source.NonceExpirationInterval)

	// ValidateNonce
	if source.ValidateNonce != nil {
		validateNonce := *source.ValidateNonce
		nonce.ValidateNonce = &validateNonce
	} else {
		nonce.ValidateNonce = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		nonce.PropertyBag = propertyBag
	} else {
		nonce.PropertyBag = nil
	}

	// Invoke the augmentConversionForNonce_STATUS interface (if implemented) to customize the conversion
	var nonceAsAny any = nonce
	if augmentedNonce, ok := nonceAsAny.(augmentConversionForNonce_STATUS); ok {
		err := augmentedNonce.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Nonce_STATUS populates the provided destination Nonce_STATUS from our Nonce_STATUS
func (nonce *Nonce_STATUS) AssignProperties_To_Nonce_STATUS(destination *storage.Nonce_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(nonce.PropertyBag)

	// NonceExpirationInterval
	destination.NonceExpirationInterval = genruntime.ClonePointerToString(nonce.NonceExpirationInterval)

	// ValidateNonce
	if nonce.ValidateNonce != nil {
		validateNonce := *nonce.ValidateNonce
		destination.ValidateNonce = &validateNonce
	} else {
		destination.ValidateNonce = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNonce_STATUS interface (if implemented) to customize the conversion
	var nonceAsAny any = nonce
	if augmentedNonce, ok := nonceAsAny.(augmentConversionForNonce_STATUS); ok {
		err := augmentedNonce.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.TokenStore
// The configuration settings of the token store.
type TokenStore struct {
	AzureBlobStorage           *BlobStorageTokenStore `json:"azureBlobStorage,omitempty"`
	Enabled                    *bool                  `json:"enabled,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TokenRefreshExtensionHours *float64               `json:"tokenRefreshExtensionHours,omitempty"`
}

// AssignProperties_From_TokenStore populates our TokenStore from the provided source TokenStore
func (store *TokenStore) AssignProperties_From_TokenStore(source *storage.TokenStore) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureBlobStorage
	if source.AzureBlobStorage != nil {
		var azureBlobStorage BlobStorageTokenStore
		err := azureBlobStorage.AssignProperties_From_BlobStorageTokenStore(source.AzureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BlobStorageTokenStore() to populate field AzureBlobStorage")
		}
		store.AzureBlobStorage = &azureBlobStorage
	} else {
		store.AzureBlobStorage = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		store.Enabled = &enabled
	} else {
		store.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if source.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *source.TokenRefreshExtensionHours
		store.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		store.TokenRefreshExtensionHours = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		store.PropertyBag = propertyBag
	} else {
		store.PropertyBag = nil
	}

	// Invoke the augmentConversionForTokenStore interface (if implemented) to customize the conversion
	var storeAsAny any = store
	if augmentedStore, ok := storeAsAny.(augmentConversionForTokenStore); ok {
		err := augmentedStore.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TokenStore populates the provided destination TokenStore from our TokenStore
func (store *TokenStore) AssignProperties_To_TokenStore(destination *storage.TokenStore) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(store.PropertyBag)

	// AzureBlobStorage
	if store.AzureBlobStorage != nil {
		var azureBlobStorage storage.BlobStorageTokenStore
		err := store.AzureBlobStorage.AssignProperties_To_BlobStorageTokenStore(&azureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BlobStorageTokenStore() to populate field AzureBlobStorage")
		}
		destination.AzureBlobStorage = &azureBlobStorage
	} else {
		destination.AzureBlobStorage = nil
	}

	// Enabled
	if store.Enabled != nil {
		enabled := *store.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if store.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *store.TokenRefreshExtensionHours
		destination.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		destination.TokenRefreshExtensionHours = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTokenStore interface (if implemented) to customize the conversion
	var storeAsAny any = store
	if augmentedStore, ok := storeAsAny.(augmentConversionForTokenStore); ok {
		err := augmentedStore.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.TokenStore_STATUS
// The configuration settings of the token store.
type TokenStore_STATUS struct {
	AzureBlobStorage           *BlobStorageTokenStore_STATUS `json:"azureBlobStorage,omitempty"`
	Enabled                    *bool                         `json:"enabled,omitempty"`
	PropertyBag                genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	TokenRefreshExtensionHours *float64                      `json:"tokenRefreshExtensionHours,omitempty"`
}

// AssignProperties_From_TokenStore_STATUS populates our TokenStore_STATUS from the provided source TokenStore_STATUS
func (store *TokenStore_STATUS) AssignProperties_From_TokenStore_STATUS(source *storage.TokenStore_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureBlobStorage
	if source.AzureBlobStorage != nil {
		var azureBlobStorage BlobStorageTokenStore_STATUS
		err := azureBlobStorage.AssignProperties_From_BlobStorageTokenStore_STATUS(source.AzureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BlobStorageTokenStore_STATUS() to populate field AzureBlobStorage")
		}
		store.AzureBlobStorage = &azureBlobStorage
	} else {
		store.AzureBlobStorage = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		store.Enabled = &enabled
	} else {
		store.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if source.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *source.TokenRefreshExtensionHours
		store.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		store.TokenRefreshExtensionHours = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		store.PropertyBag = propertyBag
	} else {
		store.PropertyBag = nil
	}

	// Invoke the augmentConversionForTokenStore_STATUS interface (if implemented) to customize the conversion
	var storeAsAny any = store
	if augmentedStore, ok := storeAsAny.(augmentConversionForTokenStore_STATUS); ok {
		err := augmentedStore.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TokenStore_STATUS populates the provided destination TokenStore_STATUS from our TokenStore_STATUS
func (store *TokenStore_STATUS) AssignProperties_To_TokenStore_STATUS(destination *storage.TokenStore_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(store.PropertyBag)

	// AzureBlobStorage
	if store.AzureBlobStorage != nil {
		var azureBlobStorage storage.BlobStorageTokenStore_STATUS
		err := store.AzureBlobStorage.AssignProperties_To_BlobStorageTokenStore_STATUS(&azureBlobStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BlobStorageTokenStore_STATUS() to populate field AzureBlobStorage")
		}
		destination.AzureBlobStorage = &azureBlobStorage
	} else {
		destination.AzureBlobStorage = nil
	}

	// Enabled
	if store.Enabled != nil {
		enabled := *store.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// TokenRefreshExtensionHours
	if store.TokenRefreshExtensionHours != nil {
		tokenRefreshExtensionHour := *store.TokenRefreshExtensionHours
		destination.TokenRefreshExtensionHours = &tokenRefreshExtensionHour
	} else {
		destination.TokenRefreshExtensionHours = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTokenStore_STATUS interface (if implemented) to customize the conversion
	var storeAsAny any = store
	if augmentedStore, ok := storeAsAny.(augmentConversionForTokenStore_STATUS); ok {
		err := augmentedStore.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Twitter
// The configuration settings of the Twitter provider.
type Twitter struct {
	Enabled      *bool                  `json:"enabled,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Registration *TwitterRegistration   `json:"registration,omitempty"`
}

// AssignProperties_From_Twitter populates our Twitter from the provided source Twitter
func (twitter *Twitter) AssignProperties_From_Twitter(source *storage.Twitter) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		twitter.Enabled = &enabled
	} else {
		twitter.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration TwitterRegistration
		err := registration.AssignProperties_From_TwitterRegistration(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TwitterRegistration() to populate field Registration")
		}
		twitter.Registration = &registration
	} else {
		twitter.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		twitter.PropertyBag = propertyBag
	} else {
		twitter.PropertyBag = nil
	}

	// Invoke the augmentConversionForTwitter interface (if implemented) to customize the conversion
	var twitterAsAny any = twitter
	if augmentedTwitter, ok := twitterAsAny.(augmentConversionForTwitter); ok {
		err := augmentedTwitter.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Twitter populates the provided destination Twitter from our Twitter
func (twitter *Twitter) AssignProperties_To_Twitter(destination *storage.Twitter) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(twitter.PropertyBag)

	// Enabled
	if twitter.Enabled != nil {
		enabled := *twitter.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Registration
	if twitter.Registration != nil {
		var registration storage.TwitterRegistration
		err := twitter.Registration.AssignProperties_To_TwitterRegistration(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TwitterRegistration() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTwitter interface (if implemented) to customize the conversion
	var twitterAsAny any = twitter
	if augmentedTwitter, ok := twitterAsAny.(augmentConversionForTwitter); ok {
		err := augmentedTwitter.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Twitter_STATUS
// The configuration settings of the Twitter provider.
type Twitter_STATUS struct {
	Enabled      *bool                       `json:"enabled,omitempty"`
	PropertyBag  genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	Registration *TwitterRegistration_STATUS `json:"registration,omitempty"`
}

// AssignProperties_From_Twitter_STATUS populates our Twitter_STATUS from the provided source Twitter_STATUS
func (twitter *Twitter_STATUS) AssignProperties_From_Twitter_STATUS(source *storage.Twitter_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		twitter.Enabled = &enabled
	} else {
		twitter.Enabled = nil
	}

	// Registration
	if source.Registration != nil {
		var registration TwitterRegistration_STATUS
		err := registration.AssignProperties_From_TwitterRegistration_STATUS(source.Registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TwitterRegistration_STATUS() to populate field Registration")
		}
		twitter.Registration = &registration
	} else {
		twitter.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		twitter.PropertyBag = propertyBag
	} else {
		twitter.PropertyBag = nil
	}

	// Invoke the augmentConversionForTwitter_STATUS interface (if implemented) to customize the conversion
	var twitterAsAny any = twitter
	if augmentedTwitter, ok := twitterAsAny.(augmentConversionForTwitter_STATUS); ok {
		err := augmentedTwitter.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Twitter_STATUS populates the provided destination Twitter_STATUS from our Twitter_STATUS
func (twitter *Twitter_STATUS) AssignProperties_To_Twitter_STATUS(destination *storage.Twitter_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(twitter.PropertyBag)

	// Enabled
	if twitter.Enabled != nil {
		enabled := *twitter.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Registration
	if twitter.Registration != nil {
		var registration storage.TwitterRegistration_STATUS
		err := twitter.Registration.AssignProperties_To_TwitterRegistration_STATUS(&registration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TwitterRegistration_STATUS() to populate field Registration")
		}
		destination.Registration = &registration
	} else {
		destination.Registration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTwitter_STATUS interface (if implemented) to customize the conversion
	var twitterAsAny any = twitter
	if augmentedTwitter, ok := twitterAsAny.(augmentConversionForTwitter_STATUS); ok {
		err := augmentedTwitter.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AllowedAudiencesValidation
// The configuration settings of the Allowed Audiences validation flow.
type AllowedAudiencesValidation struct {
	AllowedAudiences []string               `json:"allowedAudiences,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AllowedAudiencesValidation populates our AllowedAudiencesValidation from the provided source AllowedAudiencesValidation
func (validation *AllowedAudiencesValidation) AssignProperties_From_AllowedAudiencesValidation(source *storage.AllowedAudiencesValidation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// Update the property bag
	if len(propertyBag) > 0 {
		validation.PropertyBag = propertyBag
	} else {
		validation.PropertyBag = nil
	}

	// Invoke the augmentConversionForAllowedAudiencesValidation interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForAllowedAudiencesValidation); ok {
		err := augmentedValidation.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AllowedAudiencesValidation populates the provided destination AllowedAudiencesValidation from our AllowedAudiencesValidation
func (validation *AllowedAudiencesValidation) AssignProperties_To_AllowedAudiencesValidation(destination *storage.AllowedAudiencesValidation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(validation.PropertyBag)

	// AllowedAudiences
	destination.AllowedAudiences = genruntime.CloneSliceOfString(validation.AllowedAudiences)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAllowedAudiencesValidation interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForAllowedAudiencesValidation); ok {
		err := augmentedValidation.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AllowedAudiencesValidation_STATUS
// The configuration settings of the Allowed Audiences validation flow.
type AllowedAudiencesValidation_STATUS struct {
	AllowedAudiences []string               `json:"allowedAudiences,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AllowedAudiencesValidation_STATUS populates our AllowedAudiencesValidation_STATUS from the provided source AllowedAudiencesValidation_STATUS
func (validation *AllowedAudiencesValidation_STATUS) AssignProperties_From_AllowedAudiencesValidation_STATUS(source *storage.AllowedAudiencesValidation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// Update the property bag
	if len(propertyBag) > 0 {
		validation.PropertyBag = propertyBag
	} else {
		validation.PropertyBag = nil
	}

	// Invoke the augmentConversionForAllowedAudiencesValidation_STATUS interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForAllowedAudiencesValidation_STATUS); ok {
		err := augmentedValidation.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AllowedAudiencesValidation_STATUS populates the provided destination AllowedAudiencesValidation_STATUS from our AllowedAudiencesValidation_STATUS
func (validation *AllowedAudiencesValidation_STATUS) AssignProperties_To_AllowedAudiencesValidation_STATUS(destination *storage.AllowedAudiencesValidation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(validation.PropertyBag)

	// AllowedAudiences
	destination.AllowedAudiences = genruntime.CloneSliceOfString(validation.AllowedAudiences)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAllowedAudiencesValidation_STATUS interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForAllowedAudiencesValidation_STATUS); ok {
		err := augmentedValidation.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AppleRegistration
// The configuration settings of the registration for the Apple provider
type AppleRegistration struct {
	ClientId                *string                `json:"clientId,omitempty"`
	ClientSecretSettingName *string                `json:"clientSecretSettingName,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AppleRegistration populates our AppleRegistration from the provided source AppleRegistration
func (registration *AppleRegistration) AssignProperties_From_AppleRegistration(source *storage.AppleRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForAppleRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAppleRegistration); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AppleRegistration populates the provided destination AppleRegistration from our AppleRegistration
func (registration *AppleRegistration) AssignProperties_To_AppleRegistration(destination *storage.AppleRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAppleRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAppleRegistration); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AppleRegistration_STATUS
// The configuration settings of the registration for the Apple provider
type AppleRegistration_STATUS struct {
	ClientId                *string                `json:"clientId,omitempty"`
	ClientSecretSettingName *string                `json:"clientSecretSettingName,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AppleRegistration_STATUS populates our AppleRegistration_STATUS from the provided source AppleRegistration_STATUS
func (registration *AppleRegistration_STATUS) AssignProperties_From_AppleRegistration_STATUS(source *storage.AppleRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForAppleRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAppleRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AppleRegistration_STATUS populates the provided destination AppleRegistration_STATUS from our AppleRegistration_STATUS
func (registration *AppleRegistration_STATUS) AssignProperties_To_AppleRegistration_STATUS(destination *storage.AppleRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAppleRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAppleRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AppRegistration
// The configuration settings of the app registration for providers that have app ids and app secrets
type AppRegistration struct {
	AppId                *string                `json:"appId,omitempty"`
	AppSecretSettingName *string                `json:"appSecretSettingName,omitempty"`
	PropertyBag          genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AppRegistration populates our AppRegistration from the provided source AppRegistration
func (registration *AppRegistration) AssignProperties_From_AppRegistration(source *storage.AppRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AppId
	registration.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppSecretSettingName
	registration.AppSecretSettingName = genruntime.ClonePointerToString(source.AppSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForAppRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAppRegistration); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AppRegistration populates the provided destination AppRegistration from our AppRegistration
func (registration *AppRegistration) AssignProperties_To_AppRegistration(destination *storage.AppRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// AppId
	destination.AppId = genruntime.ClonePointerToString(registration.AppId)

	// AppSecretSettingName
	destination.AppSecretSettingName = genruntime.ClonePointerToString(registration.AppSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAppRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAppRegistration); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AppRegistration_STATUS
// The configuration settings of the app registration for providers that have app ids and app secrets
type AppRegistration_STATUS struct {
	AppId                *string                `json:"appId,omitempty"`
	AppSecretSettingName *string                `json:"appSecretSettingName,omitempty"`
	PropertyBag          genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AppRegistration_STATUS populates our AppRegistration_STATUS from the provided source AppRegistration_STATUS
func (registration *AppRegistration_STATUS) AssignProperties_From_AppRegistration_STATUS(source *storage.AppRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AppId
	registration.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppSecretSettingName
	registration.AppSecretSettingName = genruntime.ClonePointerToString(source.AppSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForAppRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAppRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AppRegistration_STATUS populates the provided destination AppRegistration_STATUS from our AppRegistration_STATUS
func (registration *AppRegistration_STATUS) AssignProperties_To_AppRegistration_STATUS(destination *storage.AppRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// AppId
	destination.AppId = genruntime.ClonePointerToString(registration.AppId)

	// AppSecretSettingName
	destination.AppSecretSettingName = genruntime.ClonePointerToString(registration.AppSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAppRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAppRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForApple interface {
	AssignPropertiesFrom(src *storage.Apple) error
	AssignPropertiesTo(dst *storage.Apple) error
}

type augmentConversionForApple_STATUS interface {
	AssignPropertiesFrom(src *storage.Apple_STATUS) error
	AssignPropertiesTo(dst *storage.Apple_STATUS) error
}

type augmentConversionForAzureActiveDirectory interface {
	AssignPropertiesFrom(src *storage.AzureActiveDirectory) error
	AssignPropertiesTo(dst *storage.AzureActiveDirectory) error
}

type augmentConversionForAzureActiveDirectory_STATUS interface {
	AssignPropertiesFrom(src *storage.AzureActiveDirectory_STATUS) error
	AssignPropertiesTo(dst *storage.AzureActiveDirectory_STATUS) error
}

type augmentConversionForAzureStaticWebApps interface {
	AssignPropertiesFrom(src *storage.AzureStaticWebApps) error
	AssignPropertiesTo(dst *storage.AzureStaticWebApps) error
}

type augmentConversionForAzureStaticWebApps_STATUS interface {
	AssignPropertiesFrom(src *storage.AzureStaticWebApps_STATUS) error
	AssignPropertiesTo(dst *storage.AzureStaticWebApps_STATUS) error
}

type augmentConversionForCookieExpiration interface {
	AssignPropertiesFrom(src *storage.CookieExpiration) error
	AssignPropertiesTo(dst *storage.CookieExpiration) error
}

type augmentConversionForCookieExpiration_STATUS interface {
	AssignPropertiesFrom(src *storage.CookieExpiration_STATUS) error
	AssignPropertiesTo(dst *storage.CookieExpiration_STATUS) error
}

type augmentConversionForCustomOpenIdConnectProvider interface {
	AssignPropertiesFrom(src *storage.CustomOpenIdConnectProvider) error
	AssignPropertiesTo(dst *storage.CustomOpenIdConnectProvider) error
}

type augmentConversionForCustomOpenIdConnectProvider_STATUS interface {
	AssignPropertiesFrom(src *storage.CustomOpenIdConnectProvider_STATUS) error
	AssignPropertiesTo(dst *storage.CustomOpenIdConnectProvider_STATUS) error
}

type augmentConversionForFacebook interface {
	AssignPropertiesFrom(src *storage.Facebook) error
	AssignPropertiesTo(dst *storage.Facebook) error
}

type augmentConversionForFacebook_STATUS interface {
	AssignPropertiesFrom(src *storage.Facebook_STATUS) error
	AssignPropertiesTo(dst *storage.Facebook_STATUS) error
}

type augmentConversionForForwardProxy interface {
	AssignPropertiesFrom(src *storage.ForwardProxy) error
	AssignPropertiesTo(dst *storage.ForwardProxy) error
}

type augmentConversionForForwardProxy_STATUS interface {
	AssignPropertiesFrom(src *storage.ForwardProxy_STATUS) error
	AssignPropertiesTo(dst *storage.ForwardProxy_STATUS) error
}

type augmentConversionForGitHub interface {
	AssignPropertiesFrom(src *storage.GitHub) error
	AssignPropertiesTo(dst *storage.GitHub) error
}

type augmentConversionForGitHub_STATUS interface {
	AssignPropertiesFrom(src *storage.GitHub_STATUS) error
	AssignPropertiesTo(dst *storage.GitHub_STATUS) error
}

type augmentConversionForGoogle interface {
	AssignPropertiesFrom(src *storage.Google) error
	AssignPropertiesTo(dst *storage.Google) error
}

type augmentConversionForGoogle_STATUS interface {
	AssignPropertiesFrom(src *storage.Google_STATUS) error
	AssignPropertiesTo(dst *storage.Google_STATUS) error
}

type augmentConversionForHttpSettingsRoutes interface {
	AssignPropertiesFrom(src *storage.HttpSettingsRoutes) error
	AssignPropertiesTo(dst *storage.HttpSettingsRoutes) error
}

type augmentConversionForHttpSettingsRoutes_STATUS interface {
	AssignPropertiesFrom(src *storage.HttpSettingsRoutes_STATUS) error
	AssignPropertiesTo(dst *storage.HttpSettingsRoutes_STATUS) error
}

type augmentConversionForLoginRoutes interface {
	AssignPropertiesFrom(src *storage.LoginRoutes) error
	AssignPropertiesTo(dst *storage.LoginRoutes) error
}

type augmentConversionForLoginRoutes_STATUS interface {
	AssignPropertiesFrom(src *storage.LoginRoutes_STATUS) error
	AssignPropertiesTo(dst *storage.LoginRoutes_STATUS) error
}

type augmentConversionForNonce interface {
	AssignPropertiesFrom(src *storage.Nonce) error
	AssignPropertiesTo(dst *storage.Nonce) error
}

type augmentConversionForNonce_STATUS interface {
	AssignPropertiesFrom(src *storage.Nonce_STATUS) error
	AssignPropertiesTo(dst *storage.Nonce_STATUS) error
}

type augmentConversionForTokenStore interface {
	AssignPropertiesFrom(src *storage.TokenStore) error
	AssignPropertiesTo(dst *storage.TokenStore) error
}

type augmentConversionForTokenStore_STATUS interface {
	AssignPropertiesFrom(src *storage.TokenStore_STATUS) error
	AssignPropertiesTo(dst *storage.TokenStore_STATUS) error
}

type augmentConversionForTwitter interface {
	AssignPropertiesFrom(src *storage.Twitter) error
	AssignPropertiesTo(dst *storage.Twitter) error
}

type augmentConversionForTwitter_STATUS interface {
	AssignPropertiesFrom(src *storage.Twitter_STATUS) error
	AssignPropertiesTo(dst *storage.Twitter_STATUS) error
}

// Storage version of v1api20240301.AzureActiveDirectoryLogin
// The configuration settings of the Azure Active Directory login flow.
type AzureActiveDirectoryLogin struct {
	DisableWWWAuthenticate *bool                  `json:"disableWWWAuthenticate,omitempty"`
	LoginParameters        []string               `json:"loginParameters,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureActiveDirectoryLogin populates our AzureActiveDirectoryLogin from the provided source AzureActiveDirectoryLogin
func (login *AzureActiveDirectoryLogin) AssignProperties_From_AzureActiveDirectoryLogin(source *storage.AzureActiveDirectoryLogin) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisableWWWAuthenticate
	if source.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *source.DisableWWWAuthenticate
		login.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		login.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	login.LoginParameters = genruntime.CloneSliceOfString(source.LoginParameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		login.PropertyBag = propertyBag
	} else {
		login.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryLogin interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForAzureActiveDirectoryLogin); ok {
		err := augmentedLogin.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryLogin populates the provided destination AzureActiveDirectoryLogin from our AzureActiveDirectoryLogin
func (login *AzureActiveDirectoryLogin) AssignProperties_To_AzureActiveDirectoryLogin(destination *storage.AzureActiveDirectoryLogin) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(login.PropertyBag)

	// DisableWWWAuthenticate
	if login.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *login.DisableWWWAuthenticate
		destination.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		destination.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	destination.LoginParameters = genruntime.CloneSliceOfString(login.LoginParameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryLogin interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForAzureActiveDirectoryLogin); ok {
		err := augmentedLogin.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureActiveDirectoryLogin_STATUS
// The configuration settings of the Azure Active Directory login flow.
type AzureActiveDirectoryLogin_STATUS struct {
	DisableWWWAuthenticate *bool                  `json:"disableWWWAuthenticate,omitempty"`
	LoginParameters        []string               `json:"loginParameters,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureActiveDirectoryLogin_STATUS populates our AzureActiveDirectoryLogin_STATUS from the provided source AzureActiveDirectoryLogin_STATUS
func (login *AzureActiveDirectoryLogin_STATUS) AssignProperties_From_AzureActiveDirectoryLogin_STATUS(source *storage.AzureActiveDirectoryLogin_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisableWWWAuthenticate
	if source.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *source.DisableWWWAuthenticate
		login.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		login.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	login.LoginParameters = genruntime.CloneSliceOfString(source.LoginParameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		login.PropertyBag = propertyBag
	} else {
		login.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryLogin_STATUS interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForAzureActiveDirectoryLogin_STATUS); ok {
		err := augmentedLogin.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryLogin_STATUS populates the provided destination AzureActiveDirectoryLogin_STATUS from our AzureActiveDirectoryLogin_STATUS
func (login *AzureActiveDirectoryLogin_STATUS) AssignProperties_To_AzureActiveDirectoryLogin_STATUS(destination *storage.AzureActiveDirectoryLogin_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(login.PropertyBag)

	// DisableWWWAuthenticate
	if login.DisableWWWAuthenticate != nil {
		disableWWWAuthenticate := *login.DisableWWWAuthenticate
		destination.DisableWWWAuthenticate = &disableWWWAuthenticate
	} else {
		destination.DisableWWWAuthenticate = nil
	}

	// LoginParameters
	destination.LoginParameters = genruntime.CloneSliceOfString(login.LoginParameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryLogin_STATUS interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForAzureActiveDirectoryLogin_STATUS); ok {
		err := augmentedLogin.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureActiveDirectoryRegistration
// The configuration settings of the Azure Active Directory app registration.
type AzureActiveDirectoryRegistration struct {
	ClientId                                      *string                `json:"clientId,omitempty"`
	ClientSecretCertificateIssuer                 *string                `json:"clientSecretCertificateIssuer,omitempty"`
	ClientSecretCertificateSubjectAlternativeName *string                `json:"clientSecretCertificateSubjectAlternativeName,omitempty"`
	ClientSecretCertificateThumbprint             *string                `json:"clientSecretCertificateThumbprint,omitempty"`
	ClientSecretSettingName                       *string                `json:"clientSecretSettingName,omitempty"`
	OpenIdIssuer                                  *string                `json:"openIdIssuer,omitempty"`
	PropertyBag                                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureActiveDirectoryRegistration populates our AzureActiveDirectoryRegistration from the provided source AzureActiveDirectoryRegistration
func (registration *AzureActiveDirectoryRegistration) AssignProperties_From_AzureActiveDirectoryRegistration(source *storage.AzureActiveDirectoryRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretCertificateIssuer
	registration.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(source.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	registration.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(source.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	registration.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(source.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// OpenIdIssuer
	registration.OpenIdIssuer = genruntime.ClonePointerToString(source.OpenIdIssuer)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAzureActiveDirectoryRegistration); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryRegistration populates the provided destination AzureActiveDirectoryRegistration from our AzureActiveDirectoryRegistration
func (registration *AzureActiveDirectoryRegistration) AssignProperties_To_AzureActiveDirectoryRegistration(destination *storage.AzureActiveDirectoryRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretCertificateIssuer
	destination.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(registration.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	destination.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(registration.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	destination.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(registration.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// OpenIdIssuer
	destination.OpenIdIssuer = genruntime.ClonePointerToString(registration.OpenIdIssuer)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAzureActiveDirectoryRegistration); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureActiveDirectoryRegistration_STATUS
// The configuration settings of the Azure Active Directory app registration.
type AzureActiveDirectoryRegistration_STATUS struct {
	ClientId                                      *string                `json:"clientId,omitempty"`
	ClientSecretCertificateIssuer                 *string                `json:"clientSecretCertificateIssuer,omitempty"`
	ClientSecretCertificateSubjectAlternativeName *string                `json:"clientSecretCertificateSubjectAlternativeName,omitempty"`
	ClientSecretCertificateThumbprint             *string                `json:"clientSecretCertificateThumbprint,omitempty"`
	ClientSecretSettingName                       *string                `json:"clientSecretSettingName,omitempty"`
	OpenIdIssuer                                  *string                `json:"openIdIssuer,omitempty"`
	PropertyBag                                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureActiveDirectoryRegistration_STATUS populates our AzureActiveDirectoryRegistration_STATUS from the provided source AzureActiveDirectoryRegistration_STATUS
func (registration *AzureActiveDirectoryRegistration_STATUS) AssignProperties_From_AzureActiveDirectoryRegistration_STATUS(source *storage.AzureActiveDirectoryRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretCertificateIssuer
	registration.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(source.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	registration.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(source.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	registration.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(source.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// OpenIdIssuer
	registration.OpenIdIssuer = genruntime.ClonePointerToString(source.OpenIdIssuer)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAzureActiveDirectoryRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryRegistration_STATUS populates the provided destination AzureActiveDirectoryRegistration_STATUS from our AzureActiveDirectoryRegistration_STATUS
func (registration *AzureActiveDirectoryRegistration_STATUS) AssignProperties_To_AzureActiveDirectoryRegistration_STATUS(destination *storage.AzureActiveDirectoryRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretCertificateIssuer
	destination.ClientSecretCertificateIssuer = genruntime.ClonePointerToString(registration.ClientSecretCertificateIssuer)

	// ClientSecretCertificateSubjectAlternativeName
	destination.ClientSecretCertificateSubjectAlternativeName = genruntime.ClonePointerToString(registration.ClientSecretCertificateSubjectAlternativeName)

	// ClientSecretCertificateThumbprint
	destination.ClientSecretCertificateThumbprint = genruntime.ClonePointerToString(registration.ClientSecretCertificateThumbprint)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// OpenIdIssuer
	destination.OpenIdIssuer = genruntime.ClonePointerToString(registration.OpenIdIssuer)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAzureActiveDirectoryRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureActiveDirectoryValidation
// The configuration settings of the Azure Active Directory token validation flow.
type AzureActiveDirectoryValidation struct {
	AllowedAudiences           []string                    `json:"allowedAudiences,omitempty"`
	DefaultAuthorizationPolicy *DefaultAuthorizationPolicy `json:"defaultAuthorizationPolicy,omitempty"`
	JwtClaimChecks             *JwtClaimChecks             `json:"jwtClaimChecks,omitempty"`
	PropertyBag                genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureActiveDirectoryValidation populates our AzureActiveDirectoryValidation from the provided source AzureActiveDirectoryValidation
func (validation *AzureActiveDirectoryValidation) AssignProperties_From_AzureActiveDirectoryValidation(source *storage.AzureActiveDirectoryValidation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if source.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy DefaultAuthorizationPolicy
		err := defaultAuthorizationPolicy.AssignProperties_From_DefaultAuthorizationPolicy(source.DefaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DefaultAuthorizationPolicy() to populate field DefaultAuthorizationPolicy")
		}
		validation.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		validation.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if source.JwtClaimChecks != nil {
		var jwtClaimCheck JwtClaimChecks
		err := jwtClaimCheck.AssignProperties_From_JwtClaimChecks(source.JwtClaimChecks)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JwtClaimChecks() to populate field JwtClaimChecks")
		}
		validation.JwtClaimChecks = &jwtClaimCheck
	} else {
		validation.JwtClaimChecks = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		validation.PropertyBag = propertyBag
	} else {
		validation.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryValidation interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForAzureActiveDirectoryValidation); ok {
		err := augmentedValidation.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryValidation populates the provided destination AzureActiveDirectoryValidation from our AzureActiveDirectoryValidation
func (validation *AzureActiveDirectoryValidation) AssignProperties_To_AzureActiveDirectoryValidation(destination *storage.AzureActiveDirectoryValidation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(validation.PropertyBag)

	// AllowedAudiences
	destination.AllowedAudiences = genruntime.CloneSliceOfString(validation.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if validation.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy storage.DefaultAuthorizationPolicy
		err := validation.DefaultAuthorizationPolicy.AssignProperties_To_DefaultAuthorizationPolicy(&defaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DefaultAuthorizationPolicy() to populate field DefaultAuthorizationPolicy")
		}
		destination.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		destination.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if validation.JwtClaimChecks != nil {
		var jwtClaimCheck storage.JwtClaimChecks
		err := validation.JwtClaimChecks.AssignProperties_To_JwtClaimChecks(&jwtClaimCheck)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JwtClaimChecks() to populate field JwtClaimChecks")
		}
		destination.JwtClaimChecks = &jwtClaimCheck
	} else {
		destination.JwtClaimChecks = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryValidation interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForAzureActiveDirectoryValidation); ok {
		err := augmentedValidation.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureActiveDirectoryValidation_STATUS
// The configuration settings of the Azure Active Directory token validation flow.
type AzureActiveDirectoryValidation_STATUS struct {
	AllowedAudiences           []string                           `json:"allowedAudiences,omitempty"`
	DefaultAuthorizationPolicy *DefaultAuthorizationPolicy_STATUS `json:"defaultAuthorizationPolicy,omitempty"`
	JwtClaimChecks             *JwtClaimChecks_STATUS             `json:"jwtClaimChecks,omitempty"`
	PropertyBag                genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureActiveDirectoryValidation_STATUS populates our AzureActiveDirectoryValidation_STATUS from the provided source AzureActiveDirectoryValidation_STATUS
func (validation *AzureActiveDirectoryValidation_STATUS) AssignProperties_From_AzureActiveDirectoryValidation_STATUS(source *storage.AzureActiveDirectoryValidation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedAudiences
	validation.AllowedAudiences = genruntime.CloneSliceOfString(source.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if source.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy DefaultAuthorizationPolicy_STATUS
		err := defaultAuthorizationPolicy.AssignProperties_From_DefaultAuthorizationPolicy_STATUS(source.DefaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DefaultAuthorizationPolicy_STATUS() to populate field DefaultAuthorizationPolicy")
		}
		validation.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		validation.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if source.JwtClaimChecks != nil {
		var jwtClaimCheck JwtClaimChecks_STATUS
		err := jwtClaimCheck.AssignProperties_From_JwtClaimChecks_STATUS(source.JwtClaimChecks)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JwtClaimChecks_STATUS() to populate field JwtClaimChecks")
		}
		validation.JwtClaimChecks = &jwtClaimCheck
	} else {
		validation.JwtClaimChecks = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		validation.PropertyBag = propertyBag
	} else {
		validation.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryValidation_STATUS interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForAzureActiveDirectoryValidation_STATUS); ok {
		err := augmentedValidation.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureActiveDirectoryValidation_STATUS populates the provided destination AzureActiveDirectoryValidation_STATUS from our AzureActiveDirectoryValidation_STATUS
func (validation *AzureActiveDirectoryValidation_STATUS) AssignProperties_To_AzureActiveDirectoryValidation_STATUS(destination *storage.AzureActiveDirectoryValidation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(validation.PropertyBag)

	// AllowedAudiences
	destination.AllowedAudiences = genruntime.CloneSliceOfString(validation.AllowedAudiences)

	// DefaultAuthorizationPolicy
	if validation.DefaultAuthorizationPolicy != nil {
		var defaultAuthorizationPolicy storage.DefaultAuthorizationPolicy_STATUS
		err := validation.DefaultAuthorizationPolicy.AssignProperties_To_DefaultAuthorizationPolicy_STATUS(&defaultAuthorizationPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DefaultAuthorizationPolicy_STATUS() to populate field DefaultAuthorizationPolicy")
		}
		destination.DefaultAuthorizationPolicy = &defaultAuthorizationPolicy
	} else {
		destination.DefaultAuthorizationPolicy = nil
	}

	// JwtClaimChecks
	if validation.JwtClaimChecks != nil {
		var jwtClaimCheck storage.JwtClaimChecks_STATUS
		err := validation.JwtClaimChecks.AssignProperties_To_JwtClaimChecks_STATUS(&jwtClaimCheck)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JwtClaimChecks_STATUS() to populate field JwtClaimChecks")
		}
		destination.JwtClaimChecks = &jwtClaimCheck
	} else {
		destination.JwtClaimChecks = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureActiveDirectoryValidation_STATUS interface (if implemented) to customize the conversion
	var validationAsAny any = validation
	if augmentedValidation, ok := validationAsAny.(augmentConversionForAzureActiveDirectoryValidation_STATUS); ok {
		err := augmentedValidation.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureStaticWebAppsRegistration
// The configuration settings of the registration for the Azure Static Web Apps provider
type AzureStaticWebAppsRegistration struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureStaticWebAppsRegistration populates our AzureStaticWebAppsRegistration from the provided source AzureStaticWebAppsRegistration
func (registration *AzureStaticWebAppsRegistration) AssignProperties_From_AzureStaticWebAppsRegistration(source *storage.AzureStaticWebAppsRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureStaticWebAppsRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAzureStaticWebAppsRegistration); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStaticWebAppsRegistration populates the provided destination AzureStaticWebAppsRegistration from our AzureStaticWebAppsRegistration
func (registration *AzureStaticWebAppsRegistration) AssignProperties_To_AzureStaticWebAppsRegistration(destination *storage.AzureStaticWebAppsRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureStaticWebAppsRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAzureStaticWebAppsRegistration); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AzureStaticWebAppsRegistration_STATUS
// The configuration settings of the registration for the Azure Static Web Apps provider
type AzureStaticWebAppsRegistration_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureStaticWebAppsRegistration_STATUS populates our AzureStaticWebAppsRegistration_STATUS from the provided source AzureStaticWebAppsRegistration_STATUS
func (registration *AzureStaticWebAppsRegistration_STATUS) AssignProperties_From_AzureStaticWebAppsRegistration_STATUS(source *storage.AzureStaticWebAppsRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureStaticWebAppsRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAzureStaticWebAppsRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStaticWebAppsRegistration_STATUS populates the provided destination AzureStaticWebAppsRegistration_STATUS from our AzureStaticWebAppsRegistration_STATUS
func (registration *AzureStaticWebAppsRegistration_STATUS) AssignProperties_To_AzureStaticWebAppsRegistration_STATUS(destination *storage.AzureStaticWebAppsRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureStaticWebAppsRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForAzureStaticWebAppsRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.BlobStorageTokenStore
// The configuration settings of the storage of the tokens if blob storage is used.
type BlobStorageTokenStore struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SasUrlSettingName *string                `json:"sasUrlSettingName,omitempty"`
}

// AssignProperties_From_BlobStorageTokenStore populates our BlobStorageTokenStore from the provided source BlobStorageTokenStore
func (store *BlobStorageTokenStore) AssignProperties_From_BlobStorageTokenStore(source *storage.BlobStorageTokenStore) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SasUrlSettingName
	store.SasUrlSettingName = genruntime.ClonePointerToString(source.SasUrlSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		store.PropertyBag = propertyBag
	} else {
		store.PropertyBag = nil
	}

	// Invoke the augmentConversionForBlobStorageTokenStore interface (if implemented) to customize the conversion
	var storeAsAny any = store
	if augmentedStore, ok := storeAsAny.(augmentConversionForBlobStorageTokenStore); ok {
		err := augmentedStore.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BlobStorageTokenStore populates the provided destination BlobStorageTokenStore from our BlobStorageTokenStore
func (store *BlobStorageTokenStore) AssignProperties_To_BlobStorageTokenStore(destination *storage.BlobStorageTokenStore) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(store.PropertyBag)

	// SasUrlSettingName
	destination.SasUrlSettingName = genruntime.ClonePointerToString(store.SasUrlSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBlobStorageTokenStore interface (if implemented) to customize the conversion
	var storeAsAny any = store
	if augmentedStore, ok := storeAsAny.(augmentConversionForBlobStorageTokenStore); ok {
		err := augmentedStore.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.BlobStorageTokenStore_STATUS
// The configuration settings of the storage of the tokens if blob storage is used.
type BlobStorageTokenStore_STATUS struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SasUrlSettingName *string                `json:"sasUrlSettingName,omitempty"`
}

// AssignProperties_From_BlobStorageTokenStore_STATUS populates our BlobStorageTokenStore_STATUS from the provided source BlobStorageTokenStore_STATUS
func (store *BlobStorageTokenStore_STATUS) AssignProperties_From_BlobStorageTokenStore_STATUS(source *storage.BlobStorageTokenStore_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SasUrlSettingName
	store.SasUrlSettingName = genruntime.ClonePointerToString(source.SasUrlSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		store.PropertyBag = propertyBag
	} else {
		store.PropertyBag = nil
	}

	// Invoke the augmentConversionForBlobStorageTokenStore_STATUS interface (if implemented) to customize the conversion
	var storeAsAny any = store
	if augmentedStore, ok := storeAsAny.(augmentConversionForBlobStorageTokenStore_STATUS); ok {
		err := augmentedStore.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BlobStorageTokenStore_STATUS populates the provided destination BlobStorageTokenStore_STATUS from our BlobStorageTokenStore_STATUS
func (store *BlobStorageTokenStore_STATUS) AssignProperties_To_BlobStorageTokenStore_STATUS(destination *storage.BlobStorageTokenStore_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(store.PropertyBag)

	// SasUrlSettingName
	destination.SasUrlSettingName = genruntime.ClonePointerToString(store.SasUrlSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBlobStorageTokenStore_STATUS interface (if implemented) to customize the conversion
	var storeAsAny any = store
	if augmentedStore, ok := storeAsAny.(augmentConversionForBlobStorageTokenStore_STATUS); ok {
		err := augmentedStore.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ClientRegistration
// The configuration settings of the app registration for providers that have client ids and client secrets
type ClientRegistration struct {
	ClientId                *string                `json:"clientId,omitempty"`
	ClientSecretSettingName *string                `json:"clientSecretSettingName,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ClientRegistration populates our ClientRegistration from the provided source ClientRegistration
func (registration *ClientRegistration) AssignProperties_From_ClientRegistration(source *storage.ClientRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForClientRegistration); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ClientRegistration populates the provided destination ClientRegistration from our ClientRegistration
func (registration *ClientRegistration) AssignProperties_To_ClientRegistration(destination *storage.ClientRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForClientRegistration); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ClientRegistration_STATUS
// The configuration settings of the app registration for providers that have client ids and client secrets
type ClientRegistration_STATUS struct {
	ClientId                *string                `json:"clientId,omitempty"`
	ClientSecretSettingName *string                `json:"clientSecretSettingName,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ClientRegistration_STATUS populates our ClientRegistration_STATUS from the provided source ClientRegistration_STATUS
func (registration *ClientRegistration_STATUS) AssignProperties_From_ClientRegistration_STATUS(source *storage.ClientRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecretSettingName
	registration.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForClientRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ClientRegistration_STATUS populates the provided destination ClientRegistration_STATUS from our ClientRegistration_STATUS
func (registration *ClientRegistration_STATUS) AssignProperties_To_ClientRegistration_STATUS(destination *storage.ClientRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(registration.ClientSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForClientRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.LoginScopes
// The configuration settings of the login flow, including the scopes that should be requested.
type LoginScopes struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Scopes      []string               `json:"scopes,omitempty"`
}

// AssignProperties_From_LoginScopes populates our LoginScopes from the provided source LoginScopes
func (scopes *LoginScopes) AssignProperties_From_LoginScopes(source *storage.LoginScopes) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Scopes
	scopes.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		scopes.PropertyBag = propertyBag
	} else {
		scopes.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoginScopes interface (if implemented) to customize the conversion
	var scopesAsAny any = scopes
	if augmentedScopes, ok := scopesAsAny.(augmentConversionForLoginScopes); ok {
		err := augmentedScopes.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoginScopes populates the provided destination LoginScopes from our LoginScopes
func (scopes *LoginScopes) AssignProperties_To_LoginScopes(destination *storage.LoginScopes) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(scopes.PropertyBag)

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(scopes.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoginScopes interface (if implemented) to customize the conversion
	var scopesAsAny any = scopes
	if augmentedScopes, ok := scopesAsAny.(augmentConversionForLoginScopes); ok {
		err := augmentedScopes.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.LoginScopes_STATUS
// The configuration settings of the login flow, including the scopes that should be requested.
type LoginScopes_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Scopes      []string               `json:"scopes,omitempty"`
}

// AssignProperties_From_LoginScopes_STATUS populates our LoginScopes_STATUS from the provided source LoginScopes_STATUS
func (scopes *LoginScopes_STATUS) AssignProperties_From_LoginScopes_STATUS(source *storage.LoginScopes_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Scopes
	scopes.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		scopes.PropertyBag = propertyBag
	} else {
		scopes.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoginScopes_STATUS interface (if implemented) to customize the conversion
	var scopesAsAny any = scopes
	if augmentedScopes, ok := scopesAsAny.(augmentConversionForLoginScopes_STATUS); ok {
		err := augmentedScopes.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LoginScopes_STATUS populates the provided destination LoginScopes_STATUS from our LoginScopes_STATUS
func (scopes *LoginScopes_STATUS) AssignProperties_To_LoginScopes_STATUS(destination *storage.LoginScopes_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(scopes.PropertyBag)

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(scopes.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLoginScopes_STATUS interface (if implemented) to customize the conversion
	var scopesAsAny any = scopes
	if augmentedScopes, ok := scopesAsAny.(augmentConversionForLoginScopes_STATUS); ok {
		err := augmentedScopes.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.OpenIdConnectLogin
// The configuration settings of the login flow of the custom Open ID Connect provider.
type OpenIdConnectLogin struct {
	NameClaimType *string                `json:"nameClaimType,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Scopes        []string               `json:"scopes,omitempty"`
}

// AssignProperties_From_OpenIdConnectLogin populates our OpenIdConnectLogin from the provided source OpenIdConnectLogin
func (login *OpenIdConnectLogin) AssignProperties_From_OpenIdConnectLogin(source *storage.OpenIdConnectLogin) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NameClaimType
	login.NameClaimType = genruntime.ClonePointerToString(source.NameClaimType)

	// Scopes
	login.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		login.PropertyBag = propertyBag
	} else {
		login.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectLogin interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForOpenIdConnectLogin); ok {
		err := augmentedLogin.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectLogin populates the provided destination OpenIdConnectLogin from our OpenIdConnectLogin
func (login *OpenIdConnectLogin) AssignProperties_To_OpenIdConnectLogin(destination *storage.OpenIdConnectLogin) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(login.PropertyBag)

	// NameClaimType
	destination.NameClaimType = genruntime.ClonePointerToString(login.NameClaimType)

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(login.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectLogin interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForOpenIdConnectLogin); ok {
		err := augmentedLogin.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.OpenIdConnectLogin_STATUS
// The configuration settings of the login flow of the custom Open ID Connect provider.
type OpenIdConnectLogin_STATUS struct {
	NameClaimType *string                `json:"nameClaimType,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Scopes        []string               `json:"scopes,omitempty"`
}

// AssignProperties_From_OpenIdConnectLogin_STATUS populates our OpenIdConnectLogin_STATUS from the provided source OpenIdConnectLogin_STATUS
func (login *OpenIdConnectLogin_STATUS) AssignProperties_From_OpenIdConnectLogin_STATUS(source *storage.OpenIdConnectLogin_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NameClaimType
	login.NameClaimType = genruntime.ClonePointerToString(source.NameClaimType)

	// Scopes
	login.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		login.PropertyBag = propertyBag
	} else {
		login.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectLogin_STATUS interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForOpenIdConnectLogin_STATUS); ok {
		err := augmentedLogin.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectLogin_STATUS populates the provided destination OpenIdConnectLogin_STATUS from our OpenIdConnectLogin_STATUS
func (login *OpenIdConnectLogin_STATUS) AssignProperties_To_OpenIdConnectLogin_STATUS(destination *storage.OpenIdConnectLogin_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(login.PropertyBag)

	// NameClaimType
	destination.NameClaimType = genruntime.ClonePointerToString(login.NameClaimType)

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(login.Scopes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectLogin_STATUS interface (if implemented) to customize the conversion
	var loginAsAny any = login
	if augmentedLogin, ok := loginAsAny.(augmentConversionForOpenIdConnectLogin_STATUS); ok {
		err := augmentedLogin.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.OpenIdConnectRegistration
// The configuration settings of the app registration for the custom Open ID Connect provider.
type OpenIdConnectRegistration struct {
	ClientCredential           *OpenIdConnectClientCredential `json:"clientCredential,omitempty"`
	ClientId                   *string                        `json:"clientId,omitempty"`
	OpenIdConnectConfiguration *OpenIdConnectConfig           `json:"openIdConnectConfiguration,omitempty"`
	PropertyBag                genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OpenIdConnectRegistration populates our OpenIdConnectRegistration from the provided source OpenIdConnectRegistration
func (registration *OpenIdConnectRegistration) AssignProperties_From_OpenIdConnectRegistration(source *storage.OpenIdConnectRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientCredential
	if source.ClientCredential != nil {
		var clientCredential OpenIdConnectClientCredential
		err := clientCredential.AssignProperties_From_OpenIdConnectClientCredential(source.ClientCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectClientCredential() to populate field ClientCredential")
		}
		registration.ClientCredential = &clientCredential
	} else {
		registration.ClientCredential = nil
	}

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// OpenIdConnectConfiguration
	if source.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration OpenIdConnectConfig
		err := openIdConnectConfiguration.AssignProperties_From_OpenIdConnectConfig(source.OpenIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectConfig() to populate field OpenIdConnectConfiguration")
		}
		registration.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		registration.OpenIdConnectConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForOpenIdConnectRegistration); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectRegistration populates the provided destination OpenIdConnectRegistration from our OpenIdConnectRegistration
func (registration *OpenIdConnectRegistration) AssignProperties_To_OpenIdConnectRegistration(destination *storage.OpenIdConnectRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientCredential
	if registration.ClientCredential != nil {
		var clientCredential storage.OpenIdConnectClientCredential
		err := registration.ClientCredential.AssignProperties_To_OpenIdConnectClientCredential(&clientCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectClientCredential() to populate field ClientCredential")
		}
		destination.ClientCredential = &clientCredential
	} else {
		destination.ClientCredential = nil
	}

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// OpenIdConnectConfiguration
	if registration.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration storage.OpenIdConnectConfig
		err := registration.OpenIdConnectConfiguration.AssignProperties_To_OpenIdConnectConfig(&openIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectConfig() to populate field OpenIdConnectConfiguration")
		}
		destination.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		destination.OpenIdConnectConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForOpenIdConnectRegistration); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.OpenIdConnectRegistration_STATUS
// The configuration settings of the app registration for the custom Open ID Connect provider.
type OpenIdConnectRegistration_STATUS struct {
	ClientCredential           *OpenIdConnectClientCredential_STATUS `json:"clientCredential,omitempty"`
	ClientId                   *string                               `json:"clientId,omitempty"`
	OpenIdConnectConfiguration *OpenIdConnectConfig_STATUS           `json:"openIdConnectConfiguration,omitempty"`
	PropertyBag                genruntime.PropertyBag                `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OpenIdConnectRegistration_STATUS populates our OpenIdConnectRegistration_STATUS from the provided source OpenIdConnectRegistration_STATUS
func (registration *OpenIdConnectRegistration_STATUS) AssignProperties_From_OpenIdConnectRegistration_STATUS(source *storage.OpenIdConnectRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientCredential
	if source.ClientCredential != nil {
		var clientCredential OpenIdConnectClientCredential_STATUS
		err := clientCredential.AssignProperties_From_OpenIdConnectClientCredential_STATUS(source.ClientCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectClientCredential_STATUS() to populate field ClientCredential")
		}
		registration.ClientCredential = &clientCredential
	} else {
		registration.ClientCredential = nil
	}

	// ClientId
	registration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// OpenIdConnectConfiguration
	if source.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration OpenIdConnectConfig_STATUS
		err := openIdConnectConfiguration.AssignProperties_From_OpenIdConnectConfig_STATUS(source.OpenIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OpenIdConnectConfig_STATUS() to populate field OpenIdConnectConfiguration")
		}
		registration.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		registration.OpenIdConnectConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForOpenIdConnectRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectRegistration_STATUS populates the provided destination OpenIdConnectRegistration_STATUS from our OpenIdConnectRegistration_STATUS
func (registration *OpenIdConnectRegistration_STATUS) AssignProperties_To_OpenIdConnectRegistration_STATUS(destination *storage.OpenIdConnectRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ClientCredential
	if registration.ClientCredential != nil {
		var clientCredential storage.OpenIdConnectClientCredential_STATUS
		err := registration.ClientCredential.AssignProperties_To_OpenIdConnectClientCredential_STATUS(&clientCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectClientCredential_STATUS() to populate field ClientCredential")
		}
		destination.ClientCredential = &clientCredential
	} else {
		destination.ClientCredential = nil
	}

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(registration.ClientId)

	// OpenIdConnectConfiguration
	if registration.OpenIdConnectConfiguration != nil {
		var openIdConnectConfiguration storage.OpenIdConnectConfig_STATUS
		err := registration.OpenIdConnectConfiguration.AssignProperties_To_OpenIdConnectConfig_STATUS(&openIdConnectConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OpenIdConnectConfig_STATUS() to populate field OpenIdConnectConfiguration")
		}
		destination.OpenIdConnectConfiguration = &openIdConnectConfiguration
	} else {
		destination.OpenIdConnectConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForOpenIdConnectRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.TwitterRegistration
// The configuration settings of the app registration for the Twitter provider.
type TwitterRegistration struct {
	ConsumerKey               *string                `json:"consumerKey,omitempty"`
	ConsumerSecretSettingName *string                `json:"consumerSecretSettingName,omitempty"`
	PropertyBag               genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_TwitterRegistration populates our TwitterRegistration from the provided source TwitterRegistration
func (registration *TwitterRegistration) AssignProperties_From_TwitterRegistration(source *storage.TwitterRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConsumerKey
	registration.ConsumerKey = genruntime.ClonePointerToString(source.ConsumerKey)

	// ConsumerSecretSettingName
	registration.ConsumerSecretSettingName = genruntime.ClonePointerToString(source.ConsumerSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForTwitterRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForTwitterRegistration); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TwitterRegistration populates the provided destination TwitterRegistration from our TwitterRegistration
func (registration *TwitterRegistration) AssignProperties_To_TwitterRegistration(destination *storage.TwitterRegistration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ConsumerKey
	destination.ConsumerKey = genruntime.ClonePointerToString(registration.ConsumerKey)

	// ConsumerSecretSettingName
	destination.ConsumerSecretSettingName = genruntime.ClonePointerToString(registration.ConsumerSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTwitterRegistration interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForTwitterRegistration); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.TwitterRegistration_STATUS
// The configuration settings of the app registration for the Twitter provider.
type TwitterRegistration_STATUS struct {
	ConsumerKey               *string                `json:"consumerKey,omitempty"`
	ConsumerSecretSettingName *string                `json:"consumerSecretSettingName,omitempty"`
	PropertyBag               genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_TwitterRegistration_STATUS populates our TwitterRegistration_STATUS from the provided source TwitterRegistration_STATUS
func (registration *TwitterRegistration_STATUS) AssignProperties_From_TwitterRegistration_STATUS(source *storage.TwitterRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConsumerKey
	registration.ConsumerKey = genruntime.ClonePointerToString(source.ConsumerKey)

	// ConsumerSecretSettingName
	registration.ConsumerSecretSettingName = genruntime.ClonePointerToString(source.ConsumerSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		registration.PropertyBag = propertyBag
	} else {
		registration.PropertyBag = nil
	}

	// Invoke the augmentConversionForTwitterRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForTwitterRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TwitterRegistration_STATUS populates the provided destination TwitterRegistration_STATUS from our TwitterRegistration_STATUS
func (registration *TwitterRegistration_STATUS) AssignProperties_To_TwitterRegistration_STATUS(destination *storage.TwitterRegistration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(registration.PropertyBag)

	// ConsumerKey
	destination.ConsumerKey = genruntime.ClonePointerToString(registration.ConsumerKey)

	// ConsumerSecretSettingName
	destination.ConsumerSecretSettingName = genruntime.ClonePointerToString(registration.ConsumerSecretSettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTwitterRegistration_STATUS interface (if implemented) to customize the conversion
	var registrationAsAny any = registration
	if augmentedRegistration, ok := registrationAsAny.(augmentConversionForTwitterRegistration_STATUS); ok {
		err := augmentedRegistration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAllowedAudiencesValidation interface {
	AssignPropertiesFrom(src *storage.AllowedAudiencesValidation) error
	AssignPropertiesTo(dst *storage.AllowedAudiencesValidation) error
}

type augmentConversionForAllowedAudiencesValidation_STATUS interface {
	AssignPropertiesFrom(src *storage.AllowedAudiencesValidation_STATUS) error
	AssignPropertiesTo(dst *storage.AllowedAudiencesValidation_STATUS) error
}

type augmentConversionForAppleRegistration interface {
	AssignPropertiesFrom(src *storage.AppleRegistration) error
	AssignPropertiesTo(dst *storage.AppleRegistration) error
}

type augmentConversionForAppleRegistration_STATUS interface {
	AssignPropertiesFrom(src *storage.AppleRegistration_STATUS) error
	AssignPropertiesTo(dst *storage.AppleRegistration_STATUS) error
}

type augmentConversionForAppRegistration interface {
	AssignPropertiesFrom(src *storage.AppRegistration) error
	AssignPropertiesTo(dst *storage.AppRegistration) error
}

type augmentConversionForAppRegistration_STATUS interface {
	AssignPropertiesFrom(src *storage.AppRegistration_STATUS) error
	AssignPropertiesTo(dst *storage.AppRegistration_STATUS) error
}

type augmentConversionForAzureActiveDirectoryLogin interface {
	AssignPropertiesFrom(src *storage.AzureActiveDirectoryLogin) error
	AssignPropertiesTo(dst *storage.AzureActiveDirectoryLogin) error
}

type augmentConversionForAzureActiveDirectoryLogin_STATUS interface {
	AssignPropertiesFrom(src *storage.AzureActiveDirectoryLogin_STATUS) error
	AssignPropertiesTo(dst *storage.AzureActiveDirectoryLogin_STATUS) error
}

type augmentConversionForAzureActiveDirectoryRegistration interface {
	AssignPropertiesFrom(src *storage.AzureActiveDirectoryRegistration) error
	AssignPropertiesTo(dst *storage.AzureActiveDirectoryRegistration) error
}

type augmentConversionForAzureActiveDirectoryRegistration_STATUS interface {
	AssignPropertiesFrom(src *storage.AzureActiveDirectoryRegistration_STATUS) error
	AssignPropertiesTo(dst *storage.AzureActiveDirectoryRegistration_STATUS) error
}

type augmentConversionForAzureActiveDirectoryValidation interface {
	AssignPropertiesFrom(src *storage.AzureActiveDirectoryValidation) error
	AssignPropertiesTo(dst *storage.AzureActiveDirectoryValidation) error
}

type augmentConversionForAzureActiveDirectoryValidation_STATUS interface {
	AssignPropertiesFrom(src *storage.AzureActiveDirectoryValidation_STATUS) error
	AssignPropertiesTo(dst *storage.AzureActiveDirectoryValidation_STATUS) error
}

type augmentConversionForAzureStaticWebAppsRegistration interface {
	AssignPropertiesFrom(src *storage.AzureStaticWebAppsRegistration) error
	AssignPropertiesTo(dst *storage.AzureStaticWebAppsRegistration) error
}

type augmentConversionForAzureStaticWebAppsRegistration_STATUS interface {
	AssignPropertiesFrom(src *storage.AzureStaticWebAppsRegistration_STATUS) error
	AssignPropertiesTo(dst *storage.AzureStaticWebAppsRegistration_STATUS) error
}

type augmentConversionForBlobStorageTokenStore interface {
	AssignPropertiesFrom(src *storage.BlobStorageTokenStore) error
	AssignPropertiesTo(dst *storage.BlobStorageTokenStore) error
}

type augmentConversionForBlobStorageTokenStore_STATUS interface {
	AssignPropertiesFrom(src *storage.BlobStorageTokenStore_STATUS) error
	AssignPropertiesTo(dst *storage.BlobStorageTokenStore_STATUS) error
}

type augmentConversionForClientRegistration interface {
	AssignPropertiesFrom(src *storage.ClientRegistration) error
	AssignPropertiesTo(dst *storage.ClientRegistration) error
}

type augmentConversionForClientRegistration_STATUS interface {
	AssignPropertiesFrom(src *storage.ClientRegistration_STATUS) error
	AssignPropertiesTo(dst *storage.ClientRegistration_STATUS) error
}

type augmentConversionForLoginScopes interface {
	AssignPropertiesFrom(src *storage.LoginScopes) error
	AssignPropertiesTo(dst *storage.LoginScopes) error
}

type augmentConversionForLoginScopes_STATUS interface {
	AssignPropertiesFrom(src *storage.LoginScopes_STATUS) error
	AssignPropertiesTo(dst *storage.LoginScopes_STATUS) error
}

type augmentConversionForOpenIdConnectLogin interface {
	AssignPropertiesFrom(src *storage.OpenIdConnectLogin) error
	AssignPropertiesTo(dst *storage.OpenIdConnectLogin) error
}

type augmentConversionForOpenIdConnectLogin_STATUS interface {
	AssignPropertiesFrom(src *storage.OpenIdConnectLogin_STATUS) error
	AssignPropertiesTo(dst *storage.OpenIdConnectLogin_STATUS) error
}

type augmentConversionForOpenIdConnectRegistration interface {
	AssignPropertiesFrom(src *storage.OpenIdConnectRegistration) error
	AssignPropertiesTo(dst *storage.OpenIdConnectRegistration) error
}

type augmentConversionForOpenIdConnectRegistration_STATUS interface {
	AssignPropertiesFrom(src *storage.OpenIdConnectRegistration_STATUS) error
	AssignPropertiesTo(dst *storage.OpenIdConnectRegistration_STATUS) error
}

type augmentConversionForTwitterRegistration interface {
	AssignPropertiesFrom(src *storage.TwitterRegistration) error
	AssignPropertiesTo(dst *storage.TwitterRegistration) error
}

type augmentConversionForTwitterRegistration_STATUS interface {
	AssignPropertiesFrom(src *storage.TwitterRegistration_STATUS) error
	AssignPropertiesTo(dst *storage.TwitterRegistration_STATUS) error
}

// Storage version of v1api20240301.DefaultAuthorizationPolicy
// The configuration settings of the Azure Active Directory default authorization policy.
type DefaultAuthorizationPolicy struct {
	AllowedApplications []string               `json:"allowedApplications,omitempty"`
	AllowedPrincipals   *AllowedPrincipals     `json:"allowedPrincipals,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DefaultAuthorizationPolicy populates our DefaultAuthorizationPolicy from the provided source DefaultAuthorizationPolicy
func (policy *DefaultAuthorizationPolicy) AssignProperties_From_DefaultAuthorizationPolicy(source *storage.DefaultAuthorizationPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedApplications
	policy.AllowedApplications = genruntime.CloneSliceOfString(source.AllowedApplications)

	// AllowedPrincipals
	if source.AllowedPrincipals != nil {
		var allowedPrincipal AllowedPrincipals
		err := allowedPrincipal.AssignProperties_From_AllowedPrincipals(source.AllowedPrincipals)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AllowedPrincipals() to populate field AllowedPrincipals")
		}
		policy.AllowedPrincipals = &allowedPrincipal
	} else {
		policy.AllowedPrincipals = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForDefaultAuthorizationPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForDefaultAuthorizationPolicy); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DefaultAuthorizationPolicy populates the provided destination DefaultAuthorizationPolicy from our DefaultAuthorizationPolicy
func (policy *DefaultAuthorizationPolicy) AssignProperties_To_DefaultAuthorizationPolicy(destination *storage.DefaultAuthorizationPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// AllowedApplications
	destination.AllowedApplications = genruntime.CloneSliceOfString(policy.AllowedApplications)

	// AllowedPrincipals
	if policy.AllowedPrincipals != nil {
		var allowedPrincipal storage.AllowedPrincipals
		err := policy.AllowedPrincipals.AssignProperties_To_AllowedPrincipals(&allowedPrincipal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AllowedPrincipals() to populate field AllowedPrincipals")
		}
		destination.AllowedPrincipals = &allowedPrincipal
	} else {
		destination.AllowedPrincipals = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDefaultAuthorizationPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForDefaultAuthorizationPolicy); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.DefaultAuthorizationPolicy_STATUS
// The configuration settings of the Azure Active Directory default authorization policy.
type DefaultAuthorizationPolicy_STATUS struct {
	AllowedApplications []string                  `json:"allowedApplications,omitempty"`
	AllowedPrincipals   *AllowedPrincipals_STATUS `json:"allowedPrincipals,omitempty"`
	PropertyBag         genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DefaultAuthorizationPolicy_STATUS populates our DefaultAuthorizationPolicy_STATUS from the provided source DefaultAuthorizationPolicy_STATUS
func (policy *DefaultAuthorizationPolicy_STATUS) AssignProperties_From_DefaultAuthorizationPolicy_STATUS(source *storage.DefaultAuthorizationPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedApplications
	policy.AllowedApplications = genruntime.CloneSliceOfString(source.AllowedApplications)

	// AllowedPrincipals
	if source.AllowedPrincipals != nil {
		var allowedPrincipal AllowedPrincipals_STATUS
		err := allowedPrincipal.AssignProperties_From_AllowedPrincipals_STATUS(source.AllowedPrincipals)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AllowedPrincipals_STATUS() to populate field AllowedPrincipals")
		}
		policy.AllowedPrincipals = &allowedPrincipal
	} else {
		policy.AllowedPrincipals = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForDefaultAuthorizationPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForDefaultAuthorizationPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DefaultAuthorizationPolicy_STATUS populates the provided destination DefaultAuthorizationPolicy_STATUS from our DefaultAuthorizationPolicy_STATUS
func (policy *DefaultAuthorizationPolicy_STATUS) AssignProperties_To_DefaultAuthorizationPolicy_STATUS(destination *storage.DefaultAuthorizationPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// AllowedApplications
	destination.AllowedApplications = genruntime.CloneSliceOfString(policy.AllowedApplications)

	// AllowedPrincipals
	if policy.AllowedPrincipals != nil {
		var allowedPrincipal storage.AllowedPrincipals_STATUS
		err := policy.AllowedPrincipals.AssignProperties_To_AllowedPrincipals_STATUS(&allowedPrincipal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AllowedPrincipals_STATUS() to populate field AllowedPrincipals")
		}
		destination.AllowedPrincipals = &allowedPrincipal
	} else {
		destination.AllowedPrincipals = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDefaultAuthorizationPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForDefaultAuthorizationPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JwtClaimChecks
// The configuration settings of the checks that should be made while validating the JWT Claims.
type JwtClaimChecks struct {
	AllowedClientApplications []string               `json:"allowedClientApplications,omitempty"`
	AllowedGroups             []string               `json:"allowedGroups,omitempty"`
	PropertyBag               genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_JwtClaimChecks populates our JwtClaimChecks from the provided source JwtClaimChecks
func (checks *JwtClaimChecks) AssignProperties_From_JwtClaimChecks(source *storage.JwtClaimChecks) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedClientApplications
	checks.AllowedClientApplications = genruntime.CloneSliceOfString(source.AllowedClientApplications)

	// AllowedGroups
	checks.AllowedGroups = genruntime.CloneSliceOfString(source.AllowedGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		checks.PropertyBag = propertyBag
	} else {
		checks.PropertyBag = nil
	}

	// Invoke the augmentConversionForJwtClaimChecks interface (if implemented) to customize the conversion
	var checksAsAny any = checks
	if augmentedChecks, ok := checksAsAny.(augmentConversionForJwtClaimChecks); ok {
		err := augmentedChecks.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JwtClaimChecks populates the provided destination JwtClaimChecks from our JwtClaimChecks
func (checks *JwtClaimChecks) AssignProperties_To_JwtClaimChecks(destination *storage.JwtClaimChecks) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(checks.PropertyBag)

	// AllowedClientApplications
	destination.AllowedClientApplications = genruntime.CloneSliceOfString(checks.AllowedClientApplications)

	// AllowedGroups
	destination.AllowedGroups = genruntime.CloneSliceOfString(checks.AllowedGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJwtClaimChecks interface (if implemented) to customize the conversion
	var checksAsAny any = checks
	if augmentedChecks, ok := checksAsAny.(augmentConversionForJwtClaimChecks); ok {
		err := augmentedChecks.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JwtClaimChecks_STATUS
// The configuration settings of the checks that should be made while validating the JWT Claims.
type JwtClaimChecks_STATUS struct {
	AllowedClientApplications []string               `json:"allowedClientApplications,omitempty"`
	AllowedGroups             []string               `json:"allowedGroups,omitempty"`
	PropertyBag               genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_JwtClaimChecks_STATUS populates our JwtClaimChecks_STATUS from the provided source JwtClaimChecks_STATUS
func (checks *JwtClaimChecks_STATUS) AssignProperties_From_JwtClaimChecks_STATUS(source *storage.JwtClaimChecks_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowedClientApplications
	checks.AllowedClientApplications = genruntime.CloneSliceOfString(source.AllowedClientApplications)

	// AllowedGroups
	checks.AllowedGroups = genruntime.CloneSliceOfString(source.AllowedGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		checks.PropertyBag = propertyBag
	} else {
		checks.PropertyBag = nil
	}

	// Invoke the augmentConversionForJwtClaimChecks_STATUS interface (if implemented) to customize the conversion
	var checksAsAny any = checks
	if augmentedChecks, ok := checksAsAny.(augmentConversionForJwtClaimChecks_STATUS); ok {
		err := augmentedChecks.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JwtClaimChecks_STATUS populates the provided destination JwtClaimChecks_STATUS from our JwtClaimChecks_STATUS
func (checks *JwtClaimChecks_STATUS) AssignProperties_To_JwtClaimChecks_STATUS(destination *storage.JwtClaimChecks_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(checks.PropertyBag)

	// AllowedClientApplications
	destination.AllowedClientApplications = genruntime.CloneSliceOfString(checks.AllowedClientApplications)

	// AllowedGroups
	destination.AllowedGroups = genruntime.CloneSliceOfString(checks.AllowedGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJwtClaimChecks_STATUS interface (if implemented) to customize the conversion
	var checksAsAny any = checks
	if augmentedChecks, ok := checksAsAny.(augmentConversionForJwtClaimChecks_STATUS); ok {
		err := augmentedChecks.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.OpenIdConnectClientCredential
// The authentication client credentials of the custom Open ID Connect provider.
type OpenIdConnectClientCredential struct {
	ClientSecretSettingName *string                `json:"clientSecretSettingName,omitempty"`
	Method                  *string                `json:"method,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OpenIdConnectClientCredential populates our OpenIdConnectClientCredential from the provided source OpenIdConnectClientCredential
func (credential *OpenIdConnectClientCredential) AssignProperties_From_OpenIdConnectClientCredential(source *storage.OpenIdConnectClientCredential) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientSecretSettingName
	credential.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Method
	credential.Method = genruntime.ClonePointerToString(source.Method)

	// Update the property bag
	if len(propertyBag) > 0 {
		credential.PropertyBag = propertyBag
	} else {
		credential.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectClientCredential interface (if implemented) to customize the conversion
	var credentialAsAny any = credential
	if augmentedCredential, ok := credentialAsAny.(augmentConversionForOpenIdConnectClientCredential); ok {
		err := augmentedCredential.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectClientCredential populates the provided destination OpenIdConnectClientCredential from our OpenIdConnectClientCredential
func (credential *OpenIdConnectClientCredential) AssignProperties_To_OpenIdConnectClientCredential(destination *storage.OpenIdConnectClientCredential) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(credential.PropertyBag)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(credential.ClientSecretSettingName)

	// Method
	destination.Method = genruntime.ClonePointerToString(credential.Method)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectClientCredential interface (if implemented) to customize the conversion
	var credentialAsAny any = credential
	if augmentedCredential, ok := credentialAsAny.(augmentConversionForOpenIdConnectClientCredential); ok {
		err := augmentedCredential.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.OpenIdConnectClientCredential_STATUS
// The authentication client credentials of the custom Open ID Connect provider.
type OpenIdConnectClientCredential_STATUS struct {
	ClientSecretSettingName *string                `json:"clientSecretSettingName,omitempty"`
	Method                  *string                `json:"method,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OpenIdConnectClientCredential_STATUS populates our OpenIdConnectClientCredential_STATUS from the provided source OpenIdConnectClientCredential_STATUS
func (credential *OpenIdConnectClientCredential_STATUS) AssignProperties_From_OpenIdConnectClientCredential_STATUS(source *storage.OpenIdConnectClientCredential_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientSecretSettingName
	credential.ClientSecretSettingName = genruntime.ClonePointerToString(source.ClientSecretSettingName)

	// Method
	credential.Method = genruntime.ClonePointerToString(source.Method)

	// Update the property bag
	if len(propertyBag) > 0 {
		credential.PropertyBag = propertyBag
	} else {
		credential.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectClientCredential_STATUS interface (if implemented) to customize the conversion
	var credentialAsAny any = credential
	if augmentedCredential, ok := credentialAsAny.(augmentConversionForOpenIdConnectClientCredential_STATUS); ok {
		err := augmentedCredential.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectClientCredential_STATUS populates the provided destination OpenIdConnectClientCredential_STATUS from our OpenIdConnectClientCredential_STATUS
func (credential *OpenIdConnectClientCredential_STATUS) AssignProperties_To_OpenIdConnectClientCredential_STATUS(destination *storage.OpenIdConnectClientCredential_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(credential.PropertyBag)

	// ClientSecretSettingName
	destination.ClientSecretSettingName = genruntime.ClonePointerToString(credential.ClientSecretSettingName)

	// Method
	destination.Method = genruntime.ClonePointerToString(credential.Method)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectClientCredential_STATUS interface (if implemented) to customize the conversion
	var credentialAsAny any = credential
	if augmentedCredential, ok := credentialAsAny.(augmentConversionForOpenIdConnectClientCredential_STATUS); ok {
		err := augmentedCredential.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.OpenIdConnectConfig
// The configuration settings of the endpoints used for the custom Open ID Connect provider.
type OpenIdConnectConfig struct {
	AuthorizationEndpoint        *string                `json:"authorizationEndpoint,omitempty"`
	CertificationUri             *string                `json:"certificationUri,omitempty"`
	Issuer                       *string                `json:"issuer,omitempty"`
	PropertyBag                  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TokenEndpoint                *string                `json:"tokenEndpoint,omitempty"`
	WellKnownOpenIdConfiguration *string                `json:"wellKnownOpenIdConfiguration,omitempty"`
}

// AssignProperties_From_OpenIdConnectConfig populates our OpenIdConnectConfig from the provided source OpenIdConnectConfig
func (config *OpenIdConnectConfig) AssignProperties_From_OpenIdConnectConfig(source *storage.OpenIdConnectConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AuthorizationEndpoint
	config.AuthorizationEndpoint = genruntime.ClonePointerToString(source.AuthorizationEndpoint)

	// CertificationUri
	config.CertificationUri = genruntime.ClonePointerToString(source.CertificationUri)

	// Issuer
	config.Issuer = genruntime.ClonePointerToString(source.Issuer)

	// TokenEndpoint
	config.TokenEndpoint = genruntime.ClonePointerToString(source.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	config.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(source.WellKnownOpenIdConfiguration)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForOpenIdConnectConfig); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectConfig populates the provided destination OpenIdConnectConfig from our OpenIdConnectConfig
func (config *OpenIdConnectConfig) AssignProperties_To_OpenIdConnectConfig(destination *storage.OpenIdConnectConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// AuthorizationEndpoint
	destination.AuthorizationEndpoint = genruntime.ClonePointerToString(config.AuthorizationEndpoint)

	// CertificationUri
	destination.CertificationUri = genruntime.ClonePointerToString(config.CertificationUri)

	// Issuer
	destination.Issuer = genruntime.ClonePointerToString(config.Issuer)

	// TokenEndpoint
	destination.TokenEndpoint = genruntime.ClonePointerToString(config.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	destination.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(config.WellKnownOpenIdConfiguration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForOpenIdConnectConfig); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.OpenIdConnectConfig_STATUS
// The configuration settings of the endpoints used for the custom Open ID Connect provider.
type OpenIdConnectConfig_STATUS struct {
	AuthorizationEndpoint        *string                `json:"authorizationEndpoint,omitempty"`
	CertificationUri             *string                `json:"certificationUri,omitempty"`
	Issuer                       *string                `json:"issuer,omitempty"`
	PropertyBag                  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TokenEndpoint                *string                `json:"tokenEndpoint,omitempty"`
	WellKnownOpenIdConfiguration *string                `json:"wellKnownOpenIdConfiguration,omitempty"`
}

// AssignProperties_From_OpenIdConnectConfig_STATUS populates our OpenIdConnectConfig_STATUS from the provided source OpenIdConnectConfig_STATUS
func (config *OpenIdConnectConfig_STATUS) AssignProperties_From_OpenIdConnectConfig_STATUS(source *storage.OpenIdConnectConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AuthorizationEndpoint
	config.AuthorizationEndpoint = genruntime.ClonePointerToString(source.AuthorizationEndpoint)

	// CertificationUri
	config.CertificationUri = genruntime.ClonePointerToString(source.CertificationUri)

	// Issuer
	config.Issuer = genruntime.ClonePointerToString(source.Issuer)

	// TokenEndpoint
	config.TokenEndpoint = genruntime.ClonePointerToString(source.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	config.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(source.WellKnownOpenIdConfiguration)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForOpenIdConnectConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OpenIdConnectConfig_STATUS populates the provided destination OpenIdConnectConfig_STATUS from our OpenIdConnectConfig_STATUS
func (config *OpenIdConnectConfig_STATUS) AssignProperties_To_OpenIdConnectConfig_STATUS(destination *storage.OpenIdConnectConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// AuthorizationEndpoint
	destination.AuthorizationEndpoint = genruntime.ClonePointerToString(config.AuthorizationEndpoint)

	// CertificationUri
	destination.CertificationUri = genruntime.ClonePointerToString(config.CertificationUri)

	// Issuer
	destination.Issuer = genruntime.ClonePointerToString(config.Issuer)

	// TokenEndpoint
	destination.TokenEndpoint = genruntime.ClonePointerToString(config.TokenEndpoint)

	// WellKnownOpenIdConfiguration
	destination.WellKnownOpenIdConfiguration = genruntime.ClonePointerToString(config.WellKnownOpenIdConfiguration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOpenIdConnectConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForOpenIdConnectConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AllowedPrincipals
// The configuration settings of the Azure Active Directory allowed principals.
type AllowedPrincipals struct {
	Groups      []string               `json:"groups,omitempty"`
	Identities  []string               `json:"identities,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AllowedPrincipals populates our AllowedPrincipals from the provided source AllowedPrincipals
func (principals *AllowedPrincipals) AssignProperties_From_AllowedPrincipals(source *storage.AllowedPrincipals) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Groups
	principals.Groups = genruntime.CloneSliceOfString(source.Groups)

	// Identities
	principals.Identities = genruntime.CloneSliceOfString(source.Identities)

	// Update the property bag
	if len(propertyBag) > 0 {
		principals.PropertyBag = propertyBag
	} else {
		principals.PropertyBag = nil
	}

	// Invoke the augmentConversionForAllowedPrincipals interface (if implemented) to customize the conversion
	var principalsAsAny any = principals
	if augmentedPrincipals, ok := principalsAsAny.(augmentConversionForAllowedPrincipals); ok {
		err := augmentedPrincipals.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AllowedPrincipals populates the provided destination AllowedPrincipals from our AllowedPrincipals
func (principals *AllowedPrincipals) AssignProperties_To_AllowedPrincipals(destination *storage.AllowedPrincipals) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(principals.PropertyBag)

	// Groups
	destination.Groups = genruntime.CloneSliceOfString(principals.Groups)

	// Identities
	destination.Identities = genruntime.CloneSliceOfString(principals.Identities)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAllowedPrincipals interface (if implemented) to customize the conversion
	var principalsAsAny any = principals
	if augmentedPrincipals, ok := principalsAsAny.(augmentConversionForAllowedPrincipals); ok {
		err := augmentedPrincipals.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.AllowedPrincipals_STATUS
// The configuration settings of the Azure Active Directory allowed principals.
type AllowedPrincipals_STATUS struct {
	Groups      []string               `json:"groups,omitempty"`
	Identities  []string               `json:"identities,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AllowedPrincipals_STATUS populates our AllowedPrincipals_STATUS from the provided source AllowedPrincipals_STATUS
func (principals *AllowedPrincipals_STATUS) AssignProperties_From_AllowedPrincipals_STATUS(source *storage.AllowedPrincipals_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Groups
	principals.Groups = genruntime.CloneSliceOfString(source.Groups)

	// Identities
	principals.Identities = genruntime.CloneSliceOfString(source.Identities)

	// Update the property bag
	if len(propertyBag) > 0 {
		principals.PropertyBag = propertyBag
	} else {
		principals.PropertyBag = nil
	}

	// Invoke the augmentConversionForAllowedPrincipals_STATUS interface (if implemented) to customize the conversion
	var principalsAsAny any = principals
	if augmentedPrincipals, ok := principalsAsAny.(augmentConversionForAllowedPrincipals_STATUS); ok {
		err := augmentedPrincipals.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AllowedPrincipals_STATUS populates the provided destination AllowedPrincipals_STATUS from our AllowedPrincipals_STATUS
func (principals *AllowedPrincipals_STATUS) AssignProperties_To_AllowedPrincipals_STATUS(destination *storage.AllowedPrincipals_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(principals.PropertyBag)

	// Groups
	destination.Groups = genruntime.CloneSliceOfString(principals.Groups)

	// Identities
	destination.Identities = genruntime.CloneSliceOfString(principals.Identities)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAllowedPrincipals_STATUS interface (if implemented) to customize the conversion
	var principalsAsAny any = principals
	if augmentedPrincipals, ok := principalsAsAny.(augmentConversionForAllowedPrincipals_STATUS); ok {
		err := augmentedPrincipals.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForDefaultAuthorizationPolicy interface {
	AssignPropertiesFrom(src *storage.DefaultAuthorizationPolicy) error
	AssignPropertiesTo(dst *storage.DefaultAuthorizationPolicy) error
}

type augmentConversionForDefaultAuthorizationPolicy_STATUS interface {
	AssignPropertiesFrom(src *storage.DefaultAuthorizationPolicy_STATUS) error
	AssignPropertiesTo(dst *storage.DefaultAuthorizationPolicy_STATUS) error
}

type augmentConversionForJwtClaimChecks interface {
	AssignPropertiesFrom(src *storage.JwtClaimChecks) error
	AssignPropertiesTo(dst *storage.JwtClaimChecks) error
}

type augmentConversionForJwtClaimChecks_STATUS interface {
	AssignPropertiesFrom(src *storage.JwtClaimChecks_STATUS) error
	AssignPropertiesTo(dst *storage.JwtClaimChecks_STATUS) error
}

type augmentConversionForOpenIdConnectClientCredential interface {
	AssignPropertiesFrom(src *storage.OpenIdConnectClientCredential) error
	AssignPropertiesTo(dst *storage.OpenIdConnectClientCredential) error
}

type augmentConversionForOpenIdConnectClientCredential_STATUS interface {
	AssignPropertiesFrom(src *storage.OpenIdConnectClientCredential_STATUS) error
	AssignPropertiesTo(dst *storage.OpenIdConnectClientCredential_STATUS) error
}

type augmentConversionForOpenIdConnectConfig interface {
	AssignPropertiesFrom(src *storage.OpenIdConnectConfig) error
	AssignPropertiesTo(dst *storage.OpenIdConnectConfig) error
}

type augmentConversionForOpenIdConnectConfig_STATUS interface {
	AssignPropertiesFrom(src *storage.OpenIdConnectConfig_STATUS) error
	AssignPropertiesTo(dst *storage.OpenIdConnectConfig_STATUS) error
}

type augmentConversionForAllowedPrincipals interface {
	AssignPropertiesFrom(src *storage.AllowedPrincipals) error
	AssignPropertiesTo(dst *storage.AllowedPrincipals) error
}

type augmentConversionForAllowedPrincipals_STATUS interface {
	AssignPropertiesFrom(src *storage.AllowedPrincipals_STATUS) error
	AssignPropertiesTo(dst *storage.AllowedPrincipals_STATUS) error
}

func init() {
	SchemeBuilder.Register(&AuthConfig{}, &AuthConfigList{})
}
