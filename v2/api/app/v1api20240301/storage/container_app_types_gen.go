// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"context"
	"fmt"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20250101/storage"
	"github.com/Azure/azure-service-operator/v2/internal/genericarmclient"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/go-logr/logr"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,app}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20240301.ContainerApp
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/ContainerApps/stable/2024-03-01/ContainerApps.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}
type ContainerApp struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ContainerApp_Spec   `json:"spec,omitempty"`
	Status            ContainerApp_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ContainerApp{}

// GetConditions returns the conditions of the resource
func (containerApp *ContainerApp) GetConditions() conditions.Conditions {
	return containerApp.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (containerApp *ContainerApp) SetConditions(conditions conditions.Conditions) {
	containerApp.Status.Conditions = conditions
}

var _ conversion.Convertible = &ContainerApp{}

// ConvertFrom populates our ContainerApp from the provided hub ContainerApp
func (containerApp *ContainerApp) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.ContainerApp)
	if !ok {
		return fmt.Errorf("expected app/v1api20250101/storage/ContainerApp but received %T instead", hub)
	}

	return containerApp.AssignProperties_From_ContainerApp(source)
}

// ConvertTo populates the provided hub ContainerApp from our ContainerApp
func (containerApp *ContainerApp) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.ContainerApp)
	if !ok {
		return fmt.Errorf("expected app/v1api20250101/storage/ContainerApp but received %T instead", hub)
	}

	return containerApp.AssignProperties_To_ContainerApp(destination)
}

var _ configmaps.Exporter = &ContainerApp{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (containerApp *ContainerApp) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if containerApp.Spec.OperatorSpec == nil {
		return nil
	}
	return containerApp.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ContainerApp{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (containerApp *ContainerApp) SecretDestinationExpressions() []*core.DestinationExpression {
	if containerApp.Spec.OperatorSpec == nil {
		return nil
	}
	return containerApp.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesConfigExporter = &ContainerApp{}

// ExportKubernetesConfigMaps defines a resource which can create ConfigMaps in Kubernetes.
func (containerApp *ContainerApp) ExportKubernetesConfigMaps(_ context.Context, _ genruntime.MetaObject, _ *genericarmclient.GenericClient, _ logr.Logger) ([]client.Object, error) {
	collector := configmaps.NewCollector(containerApp.Namespace)
	if containerApp.Spec.OperatorSpec != nil && containerApp.Spec.OperatorSpec.ConfigMaps != nil {
		if containerApp.Status.EventStreamEndpoint != nil {
			collector.AddValue(containerApp.Spec.OperatorSpec.ConfigMaps.EventStreamEndpoint, *containerApp.Status.EventStreamEndpoint)
		}
	}
	if containerApp.Spec.OperatorSpec != nil && containerApp.Spec.OperatorSpec.ConfigMaps != nil {
		if containerApp.Status.LatestRevisionFqdn != nil {
			collector.AddValue(containerApp.Spec.OperatorSpec.ConfigMaps.Fqdn, *containerApp.Status.LatestRevisionFqdn)
		}
	}
	result, err := collector.Values()
	if err != nil {
		return nil, err
	}
	return configmaps.SliceToClientObjectSlice(result), nil
}

var _ genruntime.KubernetesResource = &ContainerApp{}

// AzureName returns the Azure name of the resource
func (containerApp *ContainerApp) AzureName() string {
	return containerApp.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (containerApp ContainerApp) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (containerApp *ContainerApp) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (containerApp *ContainerApp) GetSpec() genruntime.ConvertibleSpec {
	return &containerApp.Spec
}

// GetStatus returns the status of this resource
func (containerApp *ContainerApp) GetStatus() genruntime.ConvertibleStatus {
	return &containerApp.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (containerApp *ContainerApp) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.App/containerApps"
func (containerApp *ContainerApp) GetType() string {
	return "Microsoft.App/containerApps"
}

// NewEmptyStatus returns a new empty (blank) status
func (containerApp *ContainerApp) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ContainerApp_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (containerApp *ContainerApp) Owner() *genruntime.ResourceReference {
	if containerApp.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(containerApp.Spec)
	return containerApp.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (containerApp *ContainerApp) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ContainerApp_STATUS); ok {
		containerApp.Status = *st
		return nil
	}

	// Convert status to required version
	var st ContainerApp_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	containerApp.Status = st
	return nil
}

// AssignProperties_From_ContainerApp populates our ContainerApp from the provided source ContainerApp
func (containerApp *ContainerApp) AssignProperties_From_ContainerApp(source *storage.ContainerApp) error {

	// ObjectMeta
	containerApp.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ContainerApp_Spec
	err := spec.AssignProperties_From_ContainerApp_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ContainerApp_Spec() to populate field Spec")
	}
	containerApp.Spec = spec

	// Status
	var status ContainerApp_STATUS
	err = status.AssignProperties_From_ContainerApp_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ContainerApp_STATUS() to populate field Status")
	}
	containerApp.Status = status

	// Invoke the augmentConversionForContainerApp interface (if implemented) to customize the conversion
	var containerAppAsAny any = containerApp
	if augmentedContainerApp, ok := containerAppAsAny.(augmentConversionForContainerApp); ok {
		err := augmentedContainerApp.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerApp populates the provided destination ContainerApp from our ContainerApp
func (containerApp *ContainerApp) AssignProperties_To_ContainerApp(destination *storage.ContainerApp) error {

	// ObjectMeta
	destination.ObjectMeta = *containerApp.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ContainerApp_Spec
	err := containerApp.Spec.AssignProperties_To_ContainerApp_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ContainerApp_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ContainerApp_STATUS
	err = containerApp.Status.AssignProperties_To_ContainerApp_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ContainerApp_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForContainerApp interface (if implemented) to customize the conversion
	var containerAppAsAny any = containerApp
	if augmentedContainerApp, ok := containerAppAsAny.(augmentConversionForContainerApp); ok {
		err := augmentedContainerApp.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (containerApp *ContainerApp) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: containerApp.Spec.OriginalVersion,
		Kind:    "ContainerApp",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20240301.ContainerApp
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/ContainerApps/stable/2024-03-01/ContainerApps.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}
type ContainerAppList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ContainerApp `json:"items"`
}

type augmentConversionForContainerApp interface {
	AssignPropertiesFrom(src *storage.ContainerApp) error
	AssignPropertiesTo(dst *storage.ContainerApp) error
}

// Storage version of v1api20240301.ContainerApp_Spec
type ContainerApp_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName     string         `json:"azureName,omitempty"`
	Configuration *Configuration `json:"configuration,omitempty"`

	// EnvironmentReference: Resource ID of environment.
	EnvironmentReference *genruntime.ResourceReference `armReference:"EnvironmentId" json:"environmentReference,omitempty"`
	ExtendedLocation     *ExtendedLocation             `json:"extendedLocation,omitempty"`
	Identity             *ManagedServiceIdentity       `json:"identity,omitempty"`
	Location             *string                       `json:"location,omitempty"`

	// ManagedByReference: The fully qualified resource ID of the resource that manages this resource. Indicates if this
	// resource is managed by another Azure resource. If this is present, complete mode deployment will not delete the resource
	// if it is removed from the template since it is managed by another resource.
	ManagedByReference *genruntime.ResourceReference `armReference:"ManagedBy" json:"managedByReference,omitempty"`

	// ManagedEnvironmentReference: Deprecated. Resource ID of the Container App's environment.
	ManagedEnvironmentReference *genruntime.ResourceReference `armReference:"ManagedEnvironmentId" json:"managedEnvironmentReference,omitempty"`
	OperatorSpec                *ContainerAppOperatorSpec     `json:"operatorSpec,omitempty"`
	OriginalVersion             string                        `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner               *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	PropertyBag         genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Tags                map[string]string                  `json:"tags,omitempty"`
	Template            *Template                          `json:"template,omitempty"`
	WorkloadProfileName *string                            `json:"workloadProfileName,omitempty"`
}

var _ genruntime.ConvertibleSpec = &ContainerApp_Spec{}

// ConvertSpecFrom populates our ContainerApp_Spec from the provided source
func (containerApp *ContainerApp_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ContainerApp_Spec)
	if ok {
		// Populate our instance from source
		return containerApp.AssignProperties_From_ContainerApp_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ContainerApp_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = containerApp.AssignProperties_From_ContainerApp_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ContainerApp_Spec
func (containerApp *ContainerApp_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ContainerApp_Spec)
	if ok {
		// Populate destination from our instance
		return containerApp.AssignProperties_To_ContainerApp_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ContainerApp_Spec{}
	err := containerApp.AssignProperties_To_ContainerApp_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ContainerApp_Spec populates our ContainerApp_Spec from the provided source ContainerApp_Spec
func (containerApp *ContainerApp_Spec) AssignProperties_From_ContainerApp_Spec(source *storage.ContainerApp_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	containerApp.AzureName = source.AzureName

	// Configuration
	if source.Configuration != nil {
		var configuration Configuration
		err := configuration.AssignProperties_From_Configuration(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Configuration() to populate field Configuration")
		}
		containerApp.Configuration = &configuration
	} else {
		containerApp.Configuration = nil
	}

	// EnvironmentReference
	if source.EnvironmentReference != nil {
		environmentReference := source.EnvironmentReference.Copy()
		containerApp.EnvironmentReference = &environmentReference
	} else {
		containerApp.EnvironmentReference = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		containerApp.ExtendedLocation = &extendedLocation
	} else {
		containerApp.ExtendedLocation = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		containerApp.Identity = &identity
	} else {
		containerApp.Identity = nil
	}

	// Location
	containerApp.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedByReference
	if source.ManagedByReference != nil {
		managedByReference := source.ManagedByReference.Copy()
		containerApp.ManagedByReference = &managedByReference
	} else {
		containerApp.ManagedByReference = nil
	}

	// ManagedEnvironmentReference
	if source.ManagedEnvironmentReference != nil {
		managedEnvironmentReference := source.ManagedEnvironmentReference.Copy()
		containerApp.ManagedEnvironmentReference = &managedEnvironmentReference
	} else {
		containerApp.ManagedEnvironmentReference = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ContainerAppOperatorSpec
		err := operatorSpec.AssignProperties_From_ContainerAppOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppOperatorSpec() to populate field OperatorSpec")
		}
		containerApp.OperatorSpec = &operatorSpec
	} else {
		containerApp.OperatorSpec = nil
	}

	// OriginalVersion
	containerApp.OriginalVersion = source.OriginalVersion

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		containerApp.Owner = &owner
	} else {
		containerApp.Owner = nil
	}

	// Tags
	containerApp.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template Template
		err := template.AssignProperties_From_Template(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Template() to populate field Template")
		}
		containerApp.Template = &template
	} else {
		containerApp.Template = nil
	}

	// WorkloadProfileName
	containerApp.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		containerApp.PropertyBag = propertyBag
	} else {
		containerApp.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerApp_Spec interface (if implemented) to customize the conversion
	var containerAppAsAny any = containerApp
	if augmentedContainerApp, ok := containerAppAsAny.(augmentConversionForContainerApp_Spec); ok {
		err := augmentedContainerApp.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerApp_Spec populates the provided destination ContainerApp_Spec from our ContainerApp_Spec
func (containerApp *ContainerApp_Spec) AssignProperties_To_ContainerApp_Spec(destination *storage.ContainerApp_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(containerApp.PropertyBag)

	// AzureName
	destination.AzureName = containerApp.AzureName

	// Configuration
	if containerApp.Configuration != nil {
		var configuration storage.Configuration
		err := containerApp.Configuration.AssignProperties_To_Configuration(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Configuration() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// EnvironmentReference
	if containerApp.EnvironmentReference != nil {
		environmentReference := containerApp.EnvironmentReference.Copy()
		destination.EnvironmentReference = &environmentReference
	} else {
		destination.EnvironmentReference = nil
	}

	// ExtendedLocation
	if containerApp.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation
		err := containerApp.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Identity
	if containerApp.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := containerApp.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(containerApp.Location)

	// ManagedByReference
	if containerApp.ManagedByReference != nil {
		managedByReference := containerApp.ManagedByReference.Copy()
		destination.ManagedByReference = &managedByReference
	} else {
		destination.ManagedByReference = nil
	}

	// ManagedEnvironmentReference
	if containerApp.ManagedEnvironmentReference != nil {
		managedEnvironmentReference := containerApp.ManagedEnvironmentReference.Copy()
		destination.ManagedEnvironmentReference = &managedEnvironmentReference
	} else {
		destination.ManagedEnvironmentReference = nil
	}

	// OperatorSpec
	if containerApp.OperatorSpec != nil {
		var operatorSpec storage.ContainerAppOperatorSpec
		err := containerApp.OperatorSpec.AssignProperties_To_ContainerAppOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = containerApp.OriginalVersion

	// Owner
	if containerApp.Owner != nil {
		owner := containerApp.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(containerApp.Tags)

	// Template
	if containerApp.Template != nil {
		var template storage.Template
		err := containerApp.Template.AssignProperties_To_Template(&template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Template() to populate field Template")
		}
		destination.Template = &template
	} else {
		destination.Template = nil
	}

	// WorkloadProfileName
	destination.WorkloadProfileName = genruntime.ClonePointerToString(containerApp.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerApp_Spec interface (if implemented) to customize the conversion
	var containerAppAsAny any = containerApp
	if augmentedContainerApp, ok := containerAppAsAny.(augmentConversionForContainerApp_Spec); ok {
		err := augmentedContainerApp.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerApp_STATUS
// Container App.
type ContainerApp_STATUS struct {
	Conditions                 []conditions.Condition         `json:"conditions,omitempty"`
	Configuration              *Configuration_STATUS          `json:"configuration,omitempty"`
	CustomDomainVerificationId *string                        `json:"customDomainVerificationId,omitempty"`
	EnvironmentId              *string                        `json:"environmentId,omitempty"`
	EventStreamEndpoint        *string                        `json:"eventStreamEndpoint,omitempty"`
	ExtendedLocation           *ExtendedLocation_STATUS       `json:"extendedLocation,omitempty"`
	Id                         *string                        `json:"id,omitempty"`
	Identity                   *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`
	LatestReadyRevisionName    *string                        `json:"latestReadyRevisionName,omitempty"`
	LatestRevisionFqdn         *string                        `json:"latestRevisionFqdn,omitempty"`
	LatestRevisionName         *string                        `json:"latestRevisionName,omitempty"`
	Location                   *string                        `json:"location,omitempty"`
	ManagedBy                  *string                        `json:"managedBy,omitempty"`
	ManagedEnvironmentId       *string                        `json:"managedEnvironmentId,omitempty"`
	Name                       *string                        `json:"name,omitempty"`
	OutboundIpAddresses        []string                       `json:"outboundIpAddresses,omitempty"`
	PropertyBag                genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	ProvisioningState          *string                        `json:"provisioningState,omitempty"`
	SystemData                 *SystemData_STATUS             `json:"systemData,omitempty"`
	Tags                       map[string]string              `json:"tags,omitempty"`
	Template                   *Template_STATUS               `json:"template,omitempty"`
	Type                       *string                        `json:"type,omitempty"`
	WorkloadProfileName        *string                        `json:"workloadProfileName,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ContainerApp_STATUS{}

// ConvertStatusFrom populates our ContainerApp_STATUS from the provided source
func (containerApp *ContainerApp_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ContainerApp_STATUS)
	if ok {
		// Populate our instance from source
		return containerApp.AssignProperties_From_ContainerApp_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.ContainerApp_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = containerApp.AssignProperties_From_ContainerApp_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ContainerApp_STATUS
func (containerApp *ContainerApp_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ContainerApp_STATUS)
	if ok {
		// Populate destination from our instance
		return containerApp.AssignProperties_To_ContainerApp_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ContainerApp_STATUS{}
	err := containerApp.AssignProperties_To_ContainerApp_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_ContainerApp_STATUS populates our ContainerApp_STATUS from the provided source ContainerApp_STATUS
func (containerApp *ContainerApp_STATUS) AssignProperties_From_ContainerApp_STATUS(source *storage.ContainerApp_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Conditions
	containerApp.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Configuration
	if source.Configuration != nil {
		var configuration Configuration_STATUS
		err := configuration.AssignProperties_From_Configuration_STATUS(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Configuration_STATUS() to populate field Configuration")
		}
		containerApp.Configuration = &configuration
	} else {
		containerApp.Configuration = nil
	}

	// CustomDomainVerificationId
	containerApp.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// EnvironmentId
	containerApp.EnvironmentId = genruntime.ClonePointerToString(source.EnvironmentId)

	// EventStreamEndpoint
	containerApp.EventStreamEndpoint = genruntime.ClonePointerToString(source.EventStreamEndpoint)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		containerApp.ExtendedLocation = &extendedLocation
	} else {
		containerApp.ExtendedLocation = nil
	}

	// Id
	containerApp.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		containerApp.Identity = &identity
	} else {
		containerApp.Identity = nil
	}

	// LatestReadyRevisionName
	containerApp.LatestReadyRevisionName = genruntime.ClonePointerToString(source.LatestReadyRevisionName)

	// LatestRevisionFqdn
	containerApp.LatestRevisionFqdn = genruntime.ClonePointerToString(source.LatestRevisionFqdn)

	// LatestRevisionName
	containerApp.LatestRevisionName = genruntime.ClonePointerToString(source.LatestRevisionName)

	// Location
	containerApp.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedBy
	containerApp.ManagedBy = genruntime.ClonePointerToString(source.ManagedBy)

	// ManagedEnvironmentId
	containerApp.ManagedEnvironmentId = genruntime.ClonePointerToString(source.ManagedEnvironmentId)

	// Name
	containerApp.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundIpAddresses
	containerApp.OutboundIpAddresses = genruntime.CloneSliceOfString(source.OutboundIpAddresses)

	// ProvisioningState
	containerApp.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// RunningStatus
	if source.RunningStatus != nil {
		propertyBag.Add("RunningStatus", *source.RunningStatus)
	} else {
		propertyBag.Remove("RunningStatus")
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		containerApp.SystemData = &systemDatum
	} else {
		containerApp.SystemData = nil
	}

	// Tags
	containerApp.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template Template_STATUS
		err := template.AssignProperties_From_Template_STATUS(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Template_STATUS() to populate field Template")
		}
		containerApp.Template = &template
	} else {
		containerApp.Template = nil
	}

	// Type
	containerApp.Type = genruntime.ClonePointerToString(source.Type)

	// WorkloadProfileName
	containerApp.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		containerApp.PropertyBag = propertyBag
	} else {
		containerApp.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerApp_STATUS interface (if implemented) to customize the conversion
	var containerAppAsAny any = containerApp
	if augmentedContainerApp, ok := containerAppAsAny.(augmentConversionForContainerApp_STATUS); ok {
		err := augmentedContainerApp.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerApp_STATUS populates the provided destination ContainerApp_STATUS from our ContainerApp_STATUS
func (containerApp *ContainerApp_STATUS) AssignProperties_To_ContainerApp_STATUS(destination *storage.ContainerApp_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(containerApp.PropertyBag)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(containerApp.Conditions)

	// Configuration
	if containerApp.Configuration != nil {
		var configuration storage.Configuration_STATUS
		err := containerApp.Configuration.AssignProperties_To_Configuration_STATUS(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Configuration_STATUS() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(containerApp.CustomDomainVerificationId)

	// EnvironmentId
	destination.EnvironmentId = genruntime.ClonePointerToString(containerApp.EnvironmentId)

	// EventStreamEndpoint
	destination.EventStreamEndpoint = genruntime.ClonePointerToString(containerApp.EventStreamEndpoint)

	// ExtendedLocation
	if containerApp.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation_STATUS
		err := containerApp.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(containerApp.Id)

	// Identity
	if containerApp.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := containerApp.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LatestReadyRevisionName
	destination.LatestReadyRevisionName = genruntime.ClonePointerToString(containerApp.LatestReadyRevisionName)

	// LatestRevisionFqdn
	destination.LatestRevisionFqdn = genruntime.ClonePointerToString(containerApp.LatestRevisionFqdn)

	// LatestRevisionName
	destination.LatestRevisionName = genruntime.ClonePointerToString(containerApp.LatestRevisionName)

	// Location
	destination.Location = genruntime.ClonePointerToString(containerApp.Location)

	// ManagedBy
	destination.ManagedBy = genruntime.ClonePointerToString(containerApp.ManagedBy)

	// ManagedEnvironmentId
	destination.ManagedEnvironmentId = genruntime.ClonePointerToString(containerApp.ManagedEnvironmentId)

	// Name
	destination.Name = genruntime.ClonePointerToString(containerApp.Name)

	// OutboundIpAddresses
	destination.OutboundIpAddresses = genruntime.CloneSliceOfString(containerApp.OutboundIpAddresses)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(containerApp.ProvisioningState)

	// RunningStatus
	if propertyBag.Contains("RunningStatus") {
		var runningStatus string
		err := propertyBag.Pull("RunningStatus", &runningStatus)
		if err != nil {
			return eris.Wrap(err, "pulling 'RunningStatus' from propertyBag")
		}

		destination.RunningStatus = &runningStatus
	} else {
		destination.RunningStatus = nil
	}

	// SystemData
	if containerApp.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := containerApp.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(containerApp.Tags)

	// Template
	if containerApp.Template != nil {
		var template storage.Template_STATUS
		err := containerApp.Template.AssignProperties_To_Template_STATUS(&template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Template_STATUS() to populate field Template")
		}
		destination.Template = &template
	} else {
		destination.Template = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(containerApp.Type)

	// WorkloadProfileName
	destination.WorkloadProfileName = genruntime.ClonePointerToString(containerApp.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerApp_STATUS interface (if implemented) to customize the conversion
	var containerAppAsAny any = containerApp
	if augmentedContainerApp, ok := containerAppAsAny.(augmentConversionForContainerApp_STATUS); ok {
		err := augmentedContainerApp.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForContainerApp_Spec interface {
	AssignPropertiesFrom(src *storage.ContainerApp_Spec) error
	AssignPropertiesTo(dst *storage.ContainerApp_Spec) error
}

type augmentConversionForContainerApp_STATUS interface {
	AssignPropertiesFrom(src *storage.ContainerApp_STATUS) error
	AssignPropertiesTo(dst *storage.ContainerApp_STATUS) error
}

// Storage version of v1api20240301.Configuration
// Non versioned Container App configuration properties that define the mutable settings of a Container app
type Configuration struct {
	ActiveRevisionsMode  *string                `json:"activeRevisionsMode,omitempty"`
	Dapr                 *Dapr                  `json:"dapr,omitempty"`
	Ingress              *Ingress               `json:"ingress,omitempty"`
	MaxInactiveRevisions *int                   `json:"maxInactiveRevisions,omitempty"`
	PropertyBag          genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Registries           []RegistryCredentials  `json:"registries,omitempty"`
	Secrets              []Secret               `json:"secrets,omitempty"`
	Service              *Service               `json:"service,omitempty"`
}

// AssignProperties_From_Configuration populates our Configuration from the provided source Configuration
func (configuration *Configuration) AssignProperties_From_Configuration(source *storage.Configuration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ActiveRevisionsMode
	configuration.ActiveRevisionsMode = genruntime.ClonePointerToString(source.ActiveRevisionsMode)

	// Dapr
	if source.Dapr != nil {
		var dapr Dapr
		err := dapr.AssignProperties_From_Dapr(source.Dapr)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Dapr() to populate field Dapr")
		}
		configuration.Dapr = &dapr
	} else {
		configuration.Dapr = nil
	}

	// IdentitySettings
	if len(source.IdentitySettings) > 0 {
		propertyBag.Add("IdentitySettings", source.IdentitySettings)
	} else {
		propertyBag.Remove("IdentitySettings")
	}

	// Ingress
	if source.Ingress != nil {
		var ingress Ingress
		err := ingress.AssignProperties_From_Ingress(source.Ingress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Ingress() to populate field Ingress")
		}
		configuration.Ingress = &ingress
	} else {
		configuration.Ingress = nil
	}

	// MaxInactiveRevisions
	configuration.MaxInactiveRevisions = genruntime.ClonePointerToInt(source.MaxInactiveRevisions)

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials
			err := registry.AssignProperties_From_RegistryCredentials(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegistryCredentials() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// Runtime
	if source.Runtime != nil {
		propertyBag.Add("Runtime", *source.Runtime)
	} else {
		propertyBag.Remove("Runtime")
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret
			err := secret.AssignProperties_From_Secret(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Secret() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// Service
	if source.Service != nil {
		var service Service
		err := service.AssignProperties_From_Service(source.Service)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Service() to populate field Service")
		}
		configuration.Service = &service
	} else {
		configuration.Service = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Configuration populates the provided destination Configuration from our Configuration
func (configuration *Configuration) AssignProperties_To_Configuration(destination *storage.Configuration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// ActiveRevisionsMode
	destination.ActiveRevisionsMode = genruntime.ClonePointerToString(configuration.ActiveRevisionsMode)

	// Dapr
	if configuration.Dapr != nil {
		var dapr storage.Dapr
		err := configuration.Dapr.AssignProperties_To_Dapr(&dapr)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Dapr() to populate field Dapr")
		}
		destination.Dapr = &dapr
	} else {
		destination.Dapr = nil
	}

	// IdentitySettings
	if propertyBag.Contains("IdentitySettings") {
		var identitySetting []storage.IdentitySettings
		err := propertyBag.Pull("IdentitySettings", &identitySetting)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentitySettings' from propertyBag")
		}

		destination.IdentitySettings = identitySetting
	} else {
		destination.IdentitySettings = nil
	}

	// Ingress
	if configuration.Ingress != nil {
		var ingress storage.Ingress
		err := configuration.Ingress.AssignProperties_To_Ingress(&ingress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Ingress() to populate field Ingress")
		}
		destination.Ingress = &ingress
	} else {
		destination.Ingress = nil
	}

	// MaxInactiveRevisions
	destination.MaxInactiveRevisions = genruntime.ClonePointerToInt(configuration.MaxInactiveRevisions)

	// Registries
	if configuration.Registries != nil {
		registryList := make([]storage.RegistryCredentials, len(configuration.Registries))
		for registryIndex, registryItem := range configuration.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry storage.RegistryCredentials
			err := registryItem.AssignProperties_To_RegistryCredentials(&registry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegistryCredentials() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		destination.Registries = registryList
	} else {
		destination.Registries = nil
	}

	// Runtime
	if propertyBag.Contains("Runtime") {
		var runtime storage.Runtime
		err := propertyBag.Pull("Runtime", &runtime)
		if err != nil {
			return eris.Wrap(err, "pulling 'Runtime' from propertyBag")
		}

		destination.Runtime = &runtime
	} else {
		destination.Runtime = nil
	}

	// Secrets
	if configuration.Secrets != nil {
		secretList := make([]storage.Secret, len(configuration.Secrets))
		for secretIndex, secretItem := range configuration.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.Secret
			err := secretItem.AssignProperties_To_Secret(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Secret() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// Service
	if configuration.Service != nil {
		var service storage.Service
		err := configuration.Service.AssignProperties_To_Service(&service)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Service() to populate field Service")
		}
		destination.Service = &service
	} else {
		destination.Service = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Configuration_STATUS
// Non versioned Container App configuration properties that define the mutable settings of a Container app
type Configuration_STATUS struct {
	ActiveRevisionsMode  *string                      `json:"activeRevisionsMode,omitempty"`
	Dapr                 *Dapr_STATUS                 `json:"dapr,omitempty"`
	Ingress              *Ingress_STATUS              `json:"ingress,omitempty"`
	MaxInactiveRevisions *int                         `json:"maxInactiveRevisions,omitempty"`
	PropertyBag          genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	Registries           []RegistryCredentials_STATUS `json:"registries,omitempty"`
	Secrets              []Secret_STATUS              `json:"secrets,omitempty"`
	Service              *Service_STATUS              `json:"service,omitempty"`
}

// AssignProperties_From_Configuration_STATUS populates our Configuration_STATUS from the provided source Configuration_STATUS
func (configuration *Configuration_STATUS) AssignProperties_From_Configuration_STATUS(source *storage.Configuration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ActiveRevisionsMode
	configuration.ActiveRevisionsMode = genruntime.ClonePointerToString(source.ActiveRevisionsMode)

	// Dapr
	if source.Dapr != nil {
		var dapr Dapr_STATUS
		err := dapr.AssignProperties_From_Dapr_STATUS(source.Dapr)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Dapr_STATUS() to populate field Dapr")
		}
		configuration.Dapr = &dapr
	} else {
		configuration.Dapr = nil
	}

	// IdentitySettings
	if len(source.IdentitySettings) > 0 {
		propertyBag.Add("IdentitySettings", source.IdentitySettings)
	} else {
		propertyBag.Remove("IdentitySettings")
	}

	// Ingress
	if source.Ingress != nil {
		var ingress Ingress_STATUS
		err := ingress.AssignProperties_From_Ingress_STATUS(source.Ingress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Ingress_STATUS() to populate field Ingress")
		}
		configuration.Ingress = &ingress
	} else {
		configuration.Ingress = nil
	}

	// MaxInactiveRevisions
	configuration.MaxInactiveRevisions = genruntime.ClonePointerToInt(source.MaxInactiveRevisions)

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials_STATUS, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials_STATUS
			err := registry.AssignProperties_From_RegistryCredentials_STATUS(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// Runtime
	if source.Runtime != nil {
		propertyBag.Add("Runtime", *source.Runtime)
	} else {
		propertyBag.Remove("Runtime")
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret_STATUS
			err := secret.AssignProperties_From_Secret_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// Service
	if source.Service != nil {
		var service Service_STATUS
		err := service.AssignProperties_From_Service_STATUS(source.Service)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Service_STATUS() to populate field Service")
		}
		configuration.Service = &service
	} else {
		configuration.Service = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Configuration_STATUS populates the provided destination Configuration_STATUS from our Configuration_STATUS
func (configuration *Configuration_STATUS) AssignProperties_To_Configuration_STATUS(destination *storage.Configuration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// ActiveRevisionsMode
	destination.ActiveRevisionsMode = genruntime.ClonePointerToString(configuration.ActiveRevisionsMode)

	// Dapr
	if configuration.Dapr != nil {
		var dapr storage.Dapr_STATUS
		err := configuration.Dapr.AssignProperties_To_Dapr_STATUS(&dapr)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Dapr_STATUS() to populate field Dapr")
		}
		destination.Dapr = &dapr
	} else {
		destination.Dapr = nil
	}

	// IdentitySettings
	if propertyBag.Contains("IdentitySettings") {
		var identitySetting []storage.IdentitySettings_STATUS
		err := propertyBag.Pull("IdentitySettings", &identitySetting)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentitySettings' from propertyBag")
		}

		destination.IdentitySettings = identitySetting
	} else {
		destination.IdentitySettings = nil
	}

	// Ingress
	if configuration.Ingress != nil {
		var ingress storage.Ingress_STATUS
		err := configuration.Ingress.AssignProperties_To_Ingress_STATUS(&ingress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Ingress_STATUS() to populate field Ingress")
		}
		destination.Ingress = &ingress
	} else {
		destination.Ingress = nil
	}

	// MaxInactiveRevisions
	destination.MaxInactiveRevisions = genruntime.ClonePointerToInt(configuration.MaxInactiveRevisions)

	// Registries
	if configuration.Registries != nil {
		registryList := make([]storage.RegistryCredentials_STATUS, len(configuration.Registries))
		for registryIndex, registryItem := range configuration.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry storage.RegistryCredentials_STATUS
			err := registryItem.AssignProperties_To_RegistryCredentials_STATUS(&registry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		destination.Registries = registryList
	} else {
		destination.Registries = nil
	}

	// Runtime
	if propertyBag.Contains("Runtime") {
		var runtime storage.Runtime_STATUS
		err := propertyBag.Pull("Runtime", &runtime)
		if err != nil {
			return eris.Wrap(err, "pulling 'Runtime' from propertyBag")
		}

		destination.Runtime = &runtime
	} else {
		destination.Runtime = nil
	}

	// Secrets
	if configuration.Secrets != nil {
		secretList := make([]storage.Secret_STATUS, len(configuration.Secrets))
		for secretIndex, secretItem := range configuration.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.Secret_STATUS
			err := secretItem.AssignProperties_To_Secret_STATUS(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// Service
	if configuration.Service != nil {
		var service storage.Service_STATUS
		err := configuration.Service.AssignProperties_To_Service_STATUS(&service)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Service_STATUS() to populate field Service")
		}
		destination.Service = &service
	} else {
		destination.Service = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerAppOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ContainerAppOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression   `json:"configMapExpressions,omitempty"`
	ConfigMaps           *ContainerAppOperatorConfigMaps `json:"configMaps,omitempty"`
	PropertyBag          genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression   `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_ContainerAppOperatorSpec populates our ContainerAppOperatorSpec from the provided source ContainerAppOperatorSpec
func (operator *ContainerAppOperatorSpec) AssignProperties_From_ContainerAppOperatorSpec(source *storage.ContainerAppOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if source.ConfigMaps != nil {
		var configMap ContainerAppOperatorConfigMaps
		err := configMap.AssignProperties_From_ContainerAppOperatorConfigMaps(source.ConfigMaps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppOperatorConfigMaps() to populate field ConfigMaps")
		}
		operator.ConfigMaps = &configMap
	} else {
		operator.ConfigMaps = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		operator.PropertyBag = propertyBag
	} else {
		operator.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForContainerAppOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppOperatorSpec populates the provided destination ContainerAppOperatorSpec from our ContainerAppOperatorSpec
func (operator *ContainerAppOperatorSpec) AssignProperties_To_ContainerAppOperatorSpec(destination *storage.ContainerAppOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(operator.PropertyBag)

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if operator.ConfigMaps != nil {
		var configMap storage.ContainerAppOperatorConfigMaps
		err := operator.ConfigMaps.AssignProperties_To_ContainerAppOperatorConfigMaps(&configMap)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppOperatorConfigMaps() to populate field ConfigMaps")
		}
		destination.ConfigMaps = &configMap
	} else {
		destination.ConfigMaps = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForContainerAppOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ExtendedLocation
// The complex type of the extended location.
type ExtendedLocation struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignProperties_From_ExtendedLocation(source *storage.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation); ok {
		err := augmentedLocation.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignProperties_To_ExtendedLocation(destination *storage.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation); ok {
		err := augmentedLocation.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ExtendedLocation_STATUS
// The complex type of the extended location.
type ExtendedLocation_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_From_ExtendedLocation_STATUS(source *storage.ExtendedLocation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation_STATUS interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation_STATUS); ok {
		err := augmentedLocation.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_To_ExtendedLocation_STATUS(destination *storage.ExtendedLocation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation_STATUS interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation_STATUS); ok {
		err := augmentedLocation.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ManagedServiceIdentity
// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	PropertyBag            genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Type                   *string                       `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedServiceIdentity interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForManagedServiceIdentity); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedServiceIdentity interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForManagedServiceIdentity); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ManagedServiceIdentity_STATUS
// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity_STATUS struct {
	PrincipalId            *string                                `json:"principalId,omitempty"`
	PropertyBag            genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	TenantId               *string                                `json:"tenantId,omitempty"`
	Type                   *string                                `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedServiceIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForManagedServiceIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedServiceIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForManagedServiceIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Template
// Container App versioned application definition.
// Defines the desired state of an immutable revision.
// Any changes to this
// section Will result in a new revision being created
type Template struct {
	Containers                    []Container            `json:"containers,omitempty"`
	InitContainers                []BaseContainer        `json:"initContainers,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RevisionSuffix                *string                `json:"revisionSuffix,omitempty"`
	Scale                         *Scale                 `json:"scale,omitempty"`
	ServiceBinds                  []ServiceBind          `json:"serviceBinds,omitempty"`
	TerminationGracePeriodSeconds *int                   `json:"terminationGracePeriodSeconds,omitempty"`
	Volumes                       []Volume               `json:"volumes,omitempty"`
}

// AssignProperties_From_Template populates our Template from the provided source Template
func (template *Template) AssignProperties_From_Template(source *storage.Template) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Containers
	if source.Containers != nil {
		containerList := make([]Container, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container
			err := container.AssignProperties_From_Container(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer
			err := initContainer.AssignProperties_From_BaseContainer(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BaseContainer() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// RevisionSuffix
	template.RevisionSuffix = genruntime.ClonePointerToString(source.RevisionSuffix)

	// Scale
	if source.Scale != nil {
		var scale Scale
		err := scale.AssignProperties_From_Scale(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Scale() to populate field Scale")
		}
		template.Scale = &scale
	} else {
		template.Scale = nil
	}

	// ServiceBinds
	if source.ServiceBinds != nil {
		serviceBindList := make([]ServiceBind, len(source.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range source.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind ServiceBind
			err := serviceBind.AssignProperties_From_ServiceBind(&serviceBindItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ServiceBind() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		template.ServiceBinds = serviceBindList
	} else {
		template.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	template.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.AssignProperties_From_Volume(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		template.PropertyBag = propertyBag
	} else {
		template.PropertyBag = nil
	}

	// Invoke the augmentConversionForTemplate interface (if implemented) to customize the conversion
	var templateAsAny any = template
	if augmentedTemplate, ok := templateAsAny.(augmentConversionForTemplate); ok {
		err := augmentedTemplate.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Template populates the provided destination Template from our Template
func (template *Template) AssignProperties_To_Template(destination *storage.Template) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(template.PropertyBag)

	// Containers
	if template.Containers != nil {
		containerList := make([]storage.Container, len(template.Containers))
		for containerIndex, containerItem := range template.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container
			err := containerItem.AssignProperties_To_Container(&container)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// InitContainers
	if template.InitContainers != nil {
		initContainerList := make([]storage.BaseContainer, len(template.InitContainers))
		for initContainerIndex, initContainerItem := range template.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.BaseContainer
			err := initContainerItem.AssignProperties_To_BaseContainer(&initContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BaseContainer() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// RevisionSuffix
	destination.RevisionSuffix = genruntime.ClonePointerToString(template.RevisionSuffix)

	// Scale
	if template.Scale != nil {
		var scale storage.Scale
		err := template.Scale.AssignProperties_To_Scale(&scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Scale() to populate field Scale")
		}
		destination.Scale = &scale
	} else {
		destination.Scale = nil
	}

	// ServiceBinds
	if template.ServiceBinds != nil {
		serviceBindList := make([]storage.ServiceBind, len(template.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range template.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind storage.ServiceBind
			err := serviceBindItem.AssignProperties_To_ServiceBind(&serviceBind)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ServiceBind() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		destination.ServiceBinds = serviceBindList
	} else {
		destination.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	destination.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(template.TerminationGracePeriodSeconds)

	// Volumes
	if template.Volumes != nil {
		volumeList := make([]storage.Volume, len(template.Volumes))
		for volumeIndex, volumeItem := range template.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume
			err := volumeItem.AssignProperties_To_Volume(&volume)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTemplate interface (if implemented) to customize the conversion
	var templateAsAny any = template
	if augmentedTemplate, ok := templateAsAny.(augmentConversionForTemplate); ok {
		err := augmentedTemplate.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Template_STATUS
// Container App versioned application definition.
// Defines the desired state of an immutable revision.
// Any changes to this
// section Will result in a new revision being created
type Template_STATUS struct {
	Containers                    []Container_STATUS     `json:"containers,omitempty"`
	InitContainers                []BaseContainer_STATUS `json:"initContainers,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RevisionSuffix                *string                `json:"revisionSuffix,omitempty"`
	Scale                         *Scale_STATUS          `json:"scale,omitempty"`
	ServiceBinds                  []ServiceBind_STATUS   `json:"serviceBinds,omitempty"`
	TerminationGracePeriodSeconds *int                   `json:"terminationGracePeriodSeconds,omitempty"`
	Volumes                       []Volume_STATUS        `json:"volumes,omitempty"`
}

// AssignProperties_From_Template_STATUS populates our Template_STATUS from the provided source Template_STATUS
func (template *Template_STATUS) AssignProperties_From_Template_STATUS(source *storage.Template_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Containers
	if source.Containers != nil {
		containerList := make([]Container_STATUS, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container_STATUS
			err := container.AssignProperties_From_Container_STATUS(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer_STATUS, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer_STATUS
			err := initContainer.AssignProperties_From_BaseContainer_STATUS(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// RevisionSuffix
	template.RevisionSuffix = genruntime.ClonePointerToString(source.RevisionSuffix)

	// Scale
	if source.Scale != nil {
		var scale Scale_STATUS
		err := scale.AssignProperties_From_Scale_STATUS(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Scale_STATUS() to populate field Scale")
		}
		template.Scale = &scale
	} else {
		template.Scale = nil
	}

	// ServiceBinds
	if source.ServiceBinds != nil {
		serviceBindList := make([]ServiceBind_STATUS, len(source.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range source.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind ServiceBind_STATUS
			err := serviceBind.AssignProperties_From_ServiceBind_STATUS(&serviceBindItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ServiceBind_STATUS() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		template.ServiceBinds = serviceBindList
	} else {
		template.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	template.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume_STATUS, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume_STATUS
			err := volume.AssignProperties_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		template.PropertyBag = propertyBag
	} else {
		template.PropertyBag = nil
	}

	// Invoke the augmentConversionForTemplate_STATUS interface (if implemented) to customize the conversion
	var templateAsAny any = template
	if augmentedTemplate, ok := templateAsAny.(augmentConversionForTemplate_STATUS); ok {
		err := augmentedTemplate.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Template_STATUS populates the provided destination Template_STATUS from our Template_STATUS
func (template *Template_STATUS) AssignProperties_To_Template_STATUS(destination *storage.Template_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(template.PropertyBag)

	// Containers
	if template.Containers != nil {
		containerList := make([]storage.Container_STATUS, len(template.Containers))
		for containerIndex, containerItem := range template.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container_STATUS
			err := containerItem.AssignProperties_To_Container_STATUS(&container)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// InitContainers
	if template.InitContainers != nil {
		initContainerList := make([]storage.BaseContainer_STATUS, len(template.InitContainers))
		for initContainerIndex, initContainerItem := range template.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.BaseContainer_STATUS
			err := initContainerItem.AssignProperties_To_BaseContainer_STATUS(&initContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// RevisionSuffix
	destination.RevisionSuffix = genruntime.ClonePointerToString(template.RevisionSuffix)

	// Scale
	if template.Scale != nil {
		var scale storage.Scale_STATUS
		err := template.Scale.AssignProperties_To_Scale_STATUS(&scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Scale_STATUS() to populate field Scale")
		}
		destination.Scale = &scale
	} else {
		destination.Scale = nil
	}

	// ServiceBinds
	if template.ServiceBinds != nil {
		serviceBindList := make([]storage.ServiceBind_STATUS, len(template.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range template.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind storage.ServiceBind_STATUS
			err := serviceBindItem.AssignProperties_To_ServiceBind_STATUS(&serviceBind)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ServiceBind_STATUS() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		destination.ServiceBinds = serviceBindList
	} else {
		destination.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	destination.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(template.TerminationGracePeriodSeconds)

	// Volumes
	if template.Volumes != nil {
		volumeList := make([]storage.Volume_STATUS, len(template.Volumes))
		for volumeIndex, volumeItem := range template.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume_STATUS
			err := volumeItem.AssignProperties_To_Volume_STATUS(&volume)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTemplate_STATUS interface (if implemented) to customize the conversion
	var templateAsAny any = template
	if augmentedTemplate, ok := templateAsAny.(augmentConversionForTemplate_STATUS); ok {
		err := augmentedTemplate.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForConfiguration interface {
	AssignPropertiesFrom(src *storage.Configuration) error
	AssignPropertiesTo(dst *storage.Configuration) error
}

type augmentConversionForConfiguration_STATUS interface {
	AssignPropertiesFrom(src *storage.Configuration_STATUS) error
	AssignPropertiesTo(dst *storage.Configuration_STATUS) error
}

type augmentConversionForContainerAppOperatorSpec interface {
	AssignPropertiesFrom(src *storage.ContainerAppOperatorSpec) error
	AssignPropertiesTo(dst *storage.ContainerAppOperatorSpec) error
}

type augmentConversionForExtendedLocation interface {
	AssignPropertiesFrom(src *storage.ExtendedLocation) error
	AssignPropertiesTo(dst *storage.ExtendedLocation) error
}

type augmentConversionForExtendedLocation_STATUS interface {
	AssignPropertiesFrom(src *storage.ExtendedLocation_STATUS) error
	AssignPropertiesTo(dst *storage.ExtendedLocation_STATUS) error
}

type augmentConversionForManagedServiceIdentity interface {
	AssignPropertiesFrom(src *storage.ManagedServiceIdentity) error
	AssignPropertiesTo(dst *storage.ManagedServiceIdentity) error
}

type augmentConversionForManagedServiceIdentity_STATUS interface {
	AssignPropertiesFrom(src *storage.ManagedServiceIdentity_STATUS) error
	AssignPropertiesTo(dst *storage.ManagedServiceIdentity_STATUS) error
}

type augmentConversionForTemplate interface {
	AssignPropertiesFrom(src *storage.Template) error
	AssignPropertiesTo(dst *storage.Template) error
}

type augmentConversionForTemplate_STATUS interface {
	AssignPropertiesFrom(src *storage.Template_STATUS) error
	AssignPropertiesTo(dst *storage.Template_STATUS) error
}

// Storage version of v1api20240301.BaseContainer
// Container App base container definition.
type BaseContainer struct {
	Args         []string               `json:"args,omitempty"`
	Command      []string               `json:"command,omitempty"`
	Env          []EnvironmentVar       `json:"env,omitempty"`
	Image        *string                `json:"image,omitempty"`
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Resources    *ContainerResources    `json:"resources,omitempty"`
	VolumeMounts []VolumeMount          `json:"volumeMounts,omitempty"`
}

// AssignProperties_From_BaseContainer populates our BaseContainer from the provided source BaseContainer
func (container *BaseContainer) AssignProperties_From_BaseContainer(source *storage.BaseContainer) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar
			err := env.AssignProperties_From_EnvironmentVar(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnvironmentVar() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Resources
	if source.Resources != nil {
		var resource ContainerResources
		err := resource.AssignProperties_From_ContainerResources(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerResources() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignProperties_From_VolumeMount(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		container.PropertyBag = propertyBag
	} else {
		container.PropertyBag = nil
	}

	// Invoke the augmentConversionForBaseContainer interface (if implemented) to customize the conversion
	var containerAsAny any = container
	if augmentedContainer, ok := containerAsAny.(augmentConversionForBaseContainer); ok {
		err := augmentedContainer.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BaseContainer populates the provided destination BaseContainer from our BaseContainer
func (container *BaseContainer) AssignProperties_To_BaseContainer(destination *storage.BaseContainer) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(container.PropertyBag)

	// Args
	destination.Args = genruntime.CloneSliceOfString(container.Args)

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// Env
	if container.Env != nil {
		envList := make([]storage.EnvironmentVar, len(container.Env))
		for envIndex, envItem := range container.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env storage.EnvironmentVar
			err := envItem.AssignProperties_To_EnvironmentVar(&env)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnvironmentVar() to populate field Env")
			}
			envList[envIndex] = env
		}
		destination.Env = envList
	} else {
		destination.Env = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Resources
	if container.Resources != nil {
		var resource storage.ContainerResources
		err := container.Resources.AssignProperties_To_ContainerResources(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerResources() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount
			err := volumeMountItem.AssignProperties_To_VolumeMount(&volumeMount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBaseContainer interface (if implemented) to customize the conversion
	var containerAsAny any = container
	if augmentedContainer, ok := containerAsAny.(augmentConversionForBaseContainer); ok {
		err := augmentedContainer.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.BaseContainer_STATUS
// Container App base container definition.
type BaseContainer_STATUS struct {
	Args         []string                   `json:"args,omitempty"`
	Command      []string                   `json:"command,omitempty"`
	Env          []EnvironmentVar_STATUS    `json:"env,omitempty"`
	Image        *string                    `json:"image,omitempty"`
	Name         *string                    `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Resources    *ContainerResources_STATUS `json:"resources,omitempty"`
	VolumeMounts []VolumeMount_STATUS       `json:"volumeMounts,omitempty"`
}

// AssignProperties_From_BaseContainer_STATUS populates our BaseContainer_STATUS from the provided source BaseContainer_STATUS
func (container *BaseContainer_STATUS) AssignProperties_From_BaseContainer_STATUS(source *storage.BaseContainer_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar_STATUS, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar_STATUS
			err := env.AssignProperties_From_EnvironmentVar_STATUS(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Resources
	if source.Resources != nil {
		var resource ContainerResources_STATUS
		err := resource.AssignProperties_From_ContainerResources_STATUS(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerResources_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_STATUS, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_STATUS
			err := volumeMount.AssignProperties_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		container.PropertyBag = propertyBag
	} else {
		container.PropertyBag = nil
	}

	// Invoke the augmentConversionForBaseContainer_STATUS interface (if implemented) to customize the conversion
	var containerAsAny any = container
	if augmentedContainer, ok := containerAsAny.(augmentConversionForBaseContainer_STATUS); ok {
		err := augmentedContainer.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BaseContainer_STATUS populates the provided destination BaseContainer_STATUS from our BaseContainer_STATUS
func (container *BaseContainer_STATUS) AssignProperties_To_BaseContainer_STATUS(destination *storage.BaseContainer_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(container.PropertyBag)

	// Args
	destination.Args = genruntime.CloneSliceOfString(container.Args)

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// Env
	if container.Env != nil {
		envList := make([]storage.EnvironmentVar_STATUS, len(container.Env))
		for envIndex, envItem := range container.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env storage.EnvironmentVar_STATUS
			err := envItem.AssignProperties_To_EnvironmentVar_STATUS(&env)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		destination.Env = envList
	} else {
		destination.Env = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Resources
	if container.Resources != nil {
		var resource storage.ContainerResources_STATUS
		err := container.Resources.AssignProperties_To_ContainerResources_STATUS(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerResources_STATUS() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount_STATUS, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount_STATUS
			err := volumeMountItem.AssignProperties_To_VolumeMount_STATUS(&volumeMount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBaseContainer_STATUS interface (if implemented) to customize the conversion
	var containerAsAny any = container
	if augmentedContainer, ok := containerAsAny.(augmentConversionForBaseContainer_STATUS); ok {
		err := augmentedContainer.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Container
// Container App container definition
type Container struct {
	Args         []string               `json:"args,omitempty"`
	Command      []string               `json:"command,omitempty"`
	Env          []EnvironmentVar       `json:"env,omitempty"`
	Image        *string                `json:"image,omitempty"`
	Name         *string                `json:"name,omitempty"`
	Probes       []ContainerAppProbe    `json:"probes,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Resources    *ContainerResources    `json:"resources,omitempty"`
	VolumeMounts []VolumeMount          `json:"volumeMounts,omitempty"`
}

// AssignProperties_From_Container populates our Container from the provided source Container
func (container *Container) AssignProperties_From_Container(source *storage.Container) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar
			err := env.AssignProperties_From_EnvironmentVar(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnvironmentVar() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Probes
	if source.Probes != nil {
		probeList := make([]ContainerAppProbe, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe ContainerAppProbe
			err := probe.AssignProperties_From_ContainerAppProbe(&probeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		container.Probes = probeList
	} else {
		container.Probes = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ContainerResources
		err := resource.AssignProperties_From_ContainerResources(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerResources() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignProperties_From_VolumeMount(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		container.PropertyBag = propertyBag
	} else {
		container.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainer interface (if implemented) to customize the conversion
	var containerAsAny any = container
	if augmentedContainer, ok := containerAsAny.(augmentConversionForContainer); ok {
		err := augmentedContainer.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Container populates the provided destination Container from our Container
func (container *Container) AssignProperties_To_Container(destination *storage.Container) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(container.PropertyBag)

	// Args
	destination.Args = genruntime.CloneSliceOfString(container.Args)

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// Env
	if container.Env != nil {
		envList := make([]storage.EnvironmentVar, len(container.Env))
		for envIndex, envItem := range container.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env storage.EnvironmentVar
			err := envItem.AssignProperties_To_EnvironmentVar(&env)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnvironmentVar() to populate field Env")
			}
			envList[envIndex] = env
		}
		destination.Env = envList
	} else {
		destination.Env = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Probes
	if container.Probes != nil {
		probeList := make([]storage.ContainerAppProbe, len(container.Probes))
		for probeIndex, probeItem := range container.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe storage.ContainerAppProbe
			err := probeItem.AssignProperties_To_ContainerAppProbe(&probe)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// Resources
	if container.Resources != nil {
		var resource storage.ContainerResources
		err := container.Resources.AssignProperties_To_ContainerResources(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerResources() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount
			err := volumeMountItem.AssignProperties_To_VolumeMount(&volumeMount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainer interface (if implemented) to customize the conversion
	var containerAsAny any = container
	if augmentedContainer, ok := containerAsAny.(augmentConversionForContainer); ok {
		err := augmentedContainer.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Container_STATUS
// Container App container definition
type Container_STATUS struct {
	Args         []string                   `json:"args,omitempty"`
	Command      []string                   `json:"command,omitempty"`
	Env          []EnvironmentVar_STATUS    `json:"env,omitempty"`
	Image        *string                    `json:"image,omitempty"`
	Name         *string                    `json:"name,omitempty"`
	Probes       []ContainerAppProbe_STATUS `json:"probes,omitempty"`
	PropertyBag  genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Resources    *ContainerResources_STATUS `json:"resources,omitempty"`
	VolumeMounts []VolumeMount_STATUS       `json:"volumeMounts,omitempty"`
}

// AssignProperties_From_Container_STATUS populates our Container_STATUS from the provided source Container_STATUS
func (container *Container_STATUS) AssignProperties_From_Container_STATUS(source *storage.Container_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar_STATUS, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar_STATUS
			err := env.AssignProperties_From_EnvironmentVar_STATUS(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Probes
	if source.Probes != nil {
		probeList := make([]ContainerAppProbe_STATUS, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe ContainerAppProbe_STATUS
			err := probe.AssignProperties_From_ContainerAppProbe_STATUS(&probeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		container.Probes = probeList
	} else {
		container.Probes = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ContainerResources_STATUS
		err := resource.AssignProperties_From_ContainerResources_STATUS(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerResources_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_STATUS, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_STATUS
			err := volumeMount.AssignProperties_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		container.PropertyBag = propertyBag
	} else {
		container.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainer_STATUS interface (if implemented) to customize the conversion
	var containerAsAny any = container
	if augmentedContainer, ok := containerAsAny.(augmentConversionForContainer_STATUS); ok {
		err := augmentedContainer.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Container_STATUS populates the provided destination Container_STATUS from our Container_STATUS
func (container *Container_STATUS) AssignProperties_To_Container_STATUS(destination *storage.Container_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(container.PropertyBag)

	// Args
	destination.Args = genruntime.CloneSliceOfString(container.Args)

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// Env
	if container.Env != nil {
		envList := make([]storage.EnvironmentVar_STATUS, len(container.Env))
		for envIndex, envItem := range container.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env storage.EnvironmentVar_STATUS
			err := envItem.AssignProperties_To_EnvironmentVar_STATUS(&env)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		destination.Env = envList
	} else {
		destination.Env = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Probes
	if container.Probes != nil {
		probeList := make([]storage.ContainerAppProbe_STATUS, len(container.Probes))
		for probeIndex, probeItem := range container.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe storage.ContainerAppProbe_STATUS
			err := probeItem.AssignProperties_To_ContainerAppProbe_STATUS(&probe)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// Resources
	if container.Resources != nil {
		var resource storage.ContainerResources_STATUS
		err := container.Resources.AssignProperties_To_ContainerResources_STATUS(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerResources_STATUS() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount_STATUS, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount_STATUS
			err := volumeMountItem.AssignProperties_To_VolumeMount_STATUS(&volumeMount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainer_STATUS interface (if implemented) to customize the conversion
	var containerAsAny any = container
	if augmentedContainer, ok := containerAsAny.(augmentConversionForContainer_STATUS); ok {
		err := augmentedContainer.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerAppOperatorConfigMaps
type ContainerAppOperatorConfigMaps struct {
	EventStreamEndpoint *genruntime.ConfigMapDestination `json:"eventStreamEndpoint,omitempty"`
	Fqdn                *genruntime.ConfigMapDestination `json:"fqdn,omitempty"`
	PropertyBag         genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ContainerAppOperatorConfigMaps populates our ContainerAppOperatorConfigMaps from the provided source ContainerAppOperatorConfigMaps
func (maps *ContainerAppOperatorConfigMaps) AssignProperties_From_ContainerAppOperatorConfigMaps(source *storage.ContainerAppOperatorConfigMaps) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventStreamEndpoint
	if source.EventStreamEndpoint != nil {
		eventStreamEndpoint := source.EventStreamEndpoint.Copy()
		maps.EventStreamEndpoint = &eventStreamEndpoint
	} else {
		maps.EventStreamEndpoint = nil
	}

	// Fqdn
	if source.Fqdn != nil {
		fqdn := source.Fqdn.Copy()
		maps.Fqdn = &fqdn
	} else {
		maps.Fqdn = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		maps.PropertyBag = propertyBag
	} else {
		maps.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppOperatorConfigMaps interface (if implemented) to customize the conversion
	var mapsAsAny any = maps
	if augmentedMaps, ok := mapsAsAny.(augmentConversionForContainerAppOperatorConfigMaps); ok {
		err := augmentedMaps.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppOperatorConfigMaps populates the provided destination ContainerAppOperatorConfigMaps from our ContainerAppOperatorConfigMaps
func (maps *ContainerAppOperatorConfigMaps) AssignProperties_To_ContainerAppOperatorConfigMaps(destination *storage.ContainerAppOperatorConfigMaps) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(maps.PropertyBag)

	// EventStreamEndpoint
	if maps.EventStreamEndpoint != nil {
		eventStreamEndpoint := maps.EventStreamEndpoint.Copy()
		destination.EventStreamEndpoint = &eventStreamEndpoint
	} else {
		destination.EventStreamEndpoint = nil
	}

	// Fqdn
	if maps.Fqdn != nil {
		fqdn := maps.Fqdn.Copy()
		destination.Fqdn = &fqdn
	} else {
		destination.Fqdn = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppOperatorConfigMaps interface (if implemented) to customize the conversion
	var mapsAsAny any = maps
	if augmentedMaps, ok := mapsAsAny.(augmentConversionForContainerAppOperatorConfigMaps); ok {
		err := augmentedMaps.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Dapr
// Container App Dapr configuration.
type Dapr struct {
	AppId              *string                `json:"appId,omitempty"`
	AppPort            *int                   `json:"appPort,omitempty"`
	AppProtocol        *string                `json:"appProtocol,omitempty"`
	EnableApiLogging   *bool                  `json:"enableApiLogging,omitempty"`
	Enabled            *bool                  `json:"enabled,omitempty"`
	HttpMaxRequestSize *int                   `json:"httpMaxRequestSize,omitempty"`
	HttpReadBufferSize *int                   `json:"httpReadBufferSize,omitempty"`
	LogLevel           *string                `json:"logLevel,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_Dapr populates our Dapr from the provided source Dapr
func (dapr *Dapr) AssignProperties_From_Dapr(source *storage.Dapr) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AppId
	dapr.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppPort
	dapr.AppPort = genruntime.ClonePointerToInt(source.AppPort)

	// AppProtocol
	dapr.AppProtocol = genruntime.ClonePointerToString(source.AppProtocol)

	// EnableApiLogging
	if source.EnableApiLogging != nil {
		enableApiLogging := *source.EnableApiLogging
		dapr.EnableApiLogging = &enableApiLogging
	} else {
		dapr.EnableApiLogging = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		dapr.Enabled = &enabled
	} else {
		dapr.Enabled = nil
	}

	// HttpMaxRequestSize
	dapr.HttpMaxRequestSize = genruntime.ClonePointerToInt(source.HttpMaxRequestSize)

	// HttpReadBufferSize
	dapr.HttpReadBufferSize = genruntime.ClonePointerToInt(source.HttpReadBufferSize)

	// LogLevel
	dapr.LogLevel = genruntime.ClonePointerToString(source.LogLevel)

	// Update the property bag
	if len(propertyBag) > 0 {
		dapr.PropertyBag = propertyBag
	} else {
		dapr.PropertyBag = nil
	}

	// Invoke the augmentConversionForDapr interface (if implemented) to customize the conversion
	var daprAsAny any = dapr
	if augmentedDapr, ok := daprAsAny.(augmentConversionForDapr); ok {
		err := augmentedDapr.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Dapr populates the provided destination Dapr from our Dapr
func (dapr *Dapr) AssignProperties_To_Dapr(destination *storage.Dapr) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(dapr.PropertyBag)

	// AppId
	destination.AppId = genruntime.ClonePointerToString(dapr.AppId)

	// AppPort
	destination.AppPort = genruntime.ClonePointerToInt(dapr.AppPort)

	// AppProtocol
	destination.AppProtocol = genruntime.ClonePointerToString(dapr.AppProtocol)

	// EnableApiLogging
	if dapr.EnableApiLogging != nil {
		enableApiLogging := *dapr.EnableApiLogging
		destination.EnableApiLogging = &enableApiLogging
	} else {
		destination.EnableApiLogging = nil
	}

	// Enabled
	if dapr.Enabled != nil {
		enabled := *dapr.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HttpMaxRequestSize
	destination.HttpMaxRequestSize = genruntime.ClonePointerToInt(dapr.HttpMaxRequestSize)

	// HttpReadBufferSize
	destination.HttpReadBufferSize = genruntime.ClonePointerToInt(dapr.HttpReadBufferSize)

	// LogLevel
	destination.LogLevel = genruntime.ClonePointerToString(dapr.LogLevel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDapr interface (if implemented) to customize the conversion
	var daprAsAny any = dapr
	if augmentedDapr, ok := daprAsAny.(augmentConversionForDapr); ok {
		err := augmentedDapr.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Dapr_STATUS
// Container App Dapr configuration.
type Dapr_STATUS struct {
	AppId              *string                `json:"appId,omitempty"`
	AppPort            *int                   `json:"appPort,omitempty"`
	AppProtocol        *string                `json:"appProtocol,omitempty"`
	EnableApiLogging   *bool                  `json:"enableApiLogging,omitempty"`
	Enabled            *bool                  `json:"enabled,omitempty"`
	HttpMaxRequestSize *int                   `json:"httpMaxRequestSize,omitempty"`
	HttpReadBufferSize *int                   `json:"httpReadBufferSize,omitempty"`
	LogLevel           *string                `json:"logLevel,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_Dapr_STATUS populates our Dapr_STATUS from the provided source Dapr_STATUS
func (dapr *Dapr_STATUS) AssignProperties_From_Dapr_STATUS(source *storage.Dapr_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AppId
	dapr.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppPort
	dapr.AppPort = genruntime.ClonePointerToInt(source.AppPort)

	// AppProtocol
	dapr.AppProtocol = genruntime.ClonePointerToString(source.AppProtocol)

	// EnableApiLogging
	if source.EnableApiLogging != nil {
		enableApiLogging := *source.EnableApiLogging
		dapr.EnableApiLogging = &enableApiLogging
	} else {
		dapr.EnableApiLogging = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		dapr.Enabled = &enabled
	} else {
		dapr.Enabled = nil
	}

	// HttpMaxRequestSize
	dapr.HttpMaxRequestSize = genruntime.ClonePointerToInt(source.HttpMaxRequestSize)

	// HttpReadBufferSize
	dapr.HttpReadBufferSize = genruntime.ClonePointerToInt(source.HttpReadBufferSize)

	// LogLevel
	dapr.LogLevel = genruntime.ClonePointerToString(source.LogLevel)

	// Update the property bag
	if len(propertyBag) > 0 {
		dapr.PropertyBag = propertyBag
	} else {
		dapr.PropertyBag = nil
	}

	// Invoke the augmentConversionForDapr_STATUS interface (if implemented) to customize the conversion
	var daprAsAny any = dapr
	if augmentedDapr, ok := daprAsAny.(augmentConversionForDapr_STATUS); ok {
		err := augmentedDapr.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Dapr_STATUS populates the provided destination Dapr_STATUS from our Dapr_STATUS
func (dapr *Dapr_STATUS) AssignProperties_To_Dapr_STATUS(destination *storage.Dapr_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(dapr.PropertyBag)

	// AppId
	destination.AppId = genruntime.ClonePointerToString(dapr.AppId)

	// AppPort
	destination.AppPort = genruntime.ClonePointerToInt(dapr.AppPort)

	// AppProtocol
	destination.AppProtocol = genruntime.ClonePointerToString(dapr.AppProtocol)

	// EnableApiLogging
	if dapr.EnableApiLogging != nil {
		enableApiLogging := *dapr.EnableApiLogging
		destination.EnableApiLogging = &enableApiLogging
	} else {
		destination.EnableApiLogging = nil
	}

	// Enabled
	if dapr.Enabled != nil {
		enabled := *dapr.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HttpMaxRequestSize
	destination.HttpMaxRequestSize = genruntime.ClonePointerToInt(dapr.HttpMaxRequestSize)

	// HttpReadBufferSize
	destination.HttpReadBufferSize = genruntime.ClonePointerToInt(dapr.HttpReadBufferSize)

	// LogLevel
	destination.LogLevel = genruntime.ClonePointerToString(dapr.LogLevel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDapr_STATUS interface (if implemented) to customize the conversion
	var daprAsAny any = dapr
	if augmentedDapr, ok := daprAsAny.(augmentConversionForDapr_STATUS); ok {
		err := augmentedDapr.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Ingress
// Container App Ingress configuration.
type Ingress struct {
	AdditionalPortMappings []IngressPortMapping        `json:"additionalPortMappings,omitempty"`
	AllowInsecure          *bool                       `json:"allowInsecure,omitempty"`
	ClientCertificateMode  *string                     `json:"clientCertificateMode,omitempty"`
	CorsPolicy             *CorsPolicy                 `json:"corsPolicy,omitempty"`
	CustomDomains          []CustomDomain              `json:"customDomains,omitempty"`
	ExposedPort            *int                        `json:"exposedPort,omitempty"`
	External               *bool                       `json:"external,omitempty"`
	IpSecurityRestrictions []IpSecurityRestrictionRule `json:"ipSecurityRestrictions,omitempty"`
	PropertyBag            genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	StickySessions         *Ingress_StickySessions     `json:"stickySessions,omitempty"`
	TargetPort             *int                        `json:"targetPort,omitempty"`
	Traffic                []TrafficWeight             `json:"traffic,omitempty"`
	Transport              *string                     `json:"transport,omitempty"`
}

// AssignProperties_From_Ingress populates our Ingress from the provided source Ingress
func (ingress *Ingress) AssignProperties_From_Ingress(source *storage.Ingress) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalPortMappings
	if source.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]IngressPortMapping, len(source.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range source.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping IngressPortMapping
			err := additionalPortMapping.AssignProperties_From_IngressPortMapping(&additionalPortMappingItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IngressPortMapping() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		ingress.AdditionalPortMappings = additionalPortMappingList
	} else {
		ingress.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if source.AllowInsecure != nil {
		allowInsecure := *source.AllowInsecure
		ingress.AllowInsecure = &allowInsecure
	} else {
		ingress.AllowInsecure = nil
	}

	// ClientCertificateMode
	ingress.ClientCertificateMode = genruntime.ClonePointerToString(source.ClientCertificateMode)

	// CorsPolicy
	if source.CorsPolicy != nil {
		var corsPolicy CorsPolicy
		err := corsPolicy.AssignProperties_From_CorsPolicy(source.CorsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CorsPolicy() to populate field CorsPolicy")
		}
		ingress.CorsPolicy = &corsPolicy
	} else {
		ingress.CorsPolicy = nil
	}

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]CustomDomain, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain CustomDomain
			err := customDomain.AssignProperties_From_CustomDomain(&customDomainItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CustomDomain() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		ingress.CustomDomains = customDomainList
	} else {
		ingress.CustomDomains = nil
	}

	// ExposedPort
	ingress.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		ingress.External = &external
	} else {
		ingress.External = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestrictionRule, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestrictionRule
			err := ipSecurityRestriction.AssignProperties_From_IpSecurityRestrictionRule(&ipSecurityRestrictionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpSecurityRestrictionRule() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		ingress.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		ingress.IpSecurityRestrictions = nil
	}

	// StickySessions
	if source.StickySessions != nil {
		var stickySession Ingress_StickySessions
		err := stickySession.AssignProperties_From_Ingress_StickySessions(source.StickySessions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Ingress_StickySessions() to populate field StickySessions")
		}
		ingress.StickySessions = &stickySession
	} else {
		ingress.StickySessions = nil
	}

	// TargetPort
	ingress.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// Traffic
	if source.Traffic != nil {
		trafficList := make([]TrafficWeight, len(source.Traffic))
		for trafficIndex, trafficItem := range source.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic TrafficWeight
			err := traffic.AssignProperties_From_TrafficWeight(&trafficItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TrafficWeight() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		ingress.Traffic = trafficList
	} else {
		ingress.Traffic = nil
	}

	// Transport
	ingress.Transport = genruntime.ClonePointerToString(source.Transport)

	// Update the property bag
	if len(propertyBag) > 0 {
		ingress.PropertyBag = propertyBag
	} else {
		ingress.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngress interface (if implemented) to customize the conversion
	var ingressAsAny any = ingress
	if augmentedIngress, ok := ingressAsAny.(augmentConversionForIngress); ok {
		err := augmentedIngress.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Ingress populates the provided destination Ingress from our Ingress
func (ingress *Ingress) AssignProperties_To_Ingress(destination *storage.Ingress) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(ingress.PropertyBag)

	// AdditionalPortMappings
	if ingress.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]storage.IngressPortMapping, len(ingress.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range ingress.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping storage.IngressPortMapping
			err := additionalPortMappingItem.AssignProperties_To_IngressPortMapping(&additionalPortMapping)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IngressPortMapping() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		destination.AdditionalPortMappings = additionalPortMappingList
	} else {
		destination.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if ingress.AllowInsecure != nil {
		allowInsecure := *ingress.AllowInsecure
		destination.AllowInsecure = &allowInsecure
	} else {
		destination.AllowInsecure = nil
	}

	// ClientCertificateMode
	destination.ClientCertificateMode = genruntime.ClonePointerToString(ingress.ClientCertificateMode)

	// CorsPolicy
	if ingress.CorsPolicy != nil {
		var corsPolicy storage.CorsPolicy
		err := ingress.CorsPolicy.AssignProperties_To_CorsPolicy(&corsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CorsPolicy() to populate field CorsPolicy")
		}
		destination.CorsPolicy = &corsPolicy
	} else {
		destination.CorsPolicy = nil
	}

	// CustomDomains
	if ingress.CustomDomains != nil {
		customDomainList := make([]storage.CustomDomain, len(ingress.CustomDomains))
		for customDomainIndex, customDomainItem := range ingress.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain storage.CustomDomain
			err := customDomainItem.AssignProperties_To_CustomDomain(&customDomain)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CustomDomain() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// ExposedPort
	destination.ExposedPort = genruntime.ClonePointerToInt(ingress.ExposedPort)

	// External
	if ingress.External != nil {
		external := *ingress.External
		destination.External = &external
	} else {
		destination.External = nil
	}

	// IpSecurityRestrictions
	if ingress.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]storage.IpSecurityRestrictionRule, len(ingress.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range ingress.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction storage.IpSecurityRestrictionRule
			err := ipSecurityRestrictionItem.AssignProperties_To_IpSecurityRestrictionRule(&ipSecurityRestriction)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpSecurityRestrictionRule() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// StickySessions
	if ingress.StickySessions != nil {
		var stickySession storage.Ingress_StickySessions
		err := ingress.StickySessions.AssignProperties_To_Ingress_StickySessions(&stickySession)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Ingress_StickySessions() to populate field StickySessions")
		}
		destination.StickySessions = &stickySession
	} else {
		destination.StickySessions = nil
	}

	// TargetPort
	destination.TargetPort = genruntime.ClonePointerToInt(ingress.TargetPort)

	// Traffic
	if ingress.Traffic != nil {
		trafficList := make([]storage.TrafficWeight, len(ingress.Traffic))
		for trafficIndex, trafficItem := range ingress.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic storage.TrafficWeight
			err := trafficItem.AssignProperties_To_TrafficWeight(&traffic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TrafficWeight() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		destination.Traffic = trafficList
	} else {
		destination.Traffic = nil
	}

	// Transport
	destination.Transport = genruntime.ClonePointerToString(ingress.Transport)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngress interface (if implemented) to customize the conversion
	var ingressAsAny any = ingress
	if augmentedIngress, ok := ingressAsAny.(augmentConversionForIngress); ok {
		err := augmentedIngress.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Ingress_STATUS
// Container App Ingress configuration.
type Ingress_STATUS struct {
	AdditionalPortMappings []IngressPortMapping_STATUS        `json:"additionalPortMappings,omitempty"`
	AllowInsecure          *bool                              `json:"allowInsecure,omitempty"`
	ClientCertificateMode  *string                            `json:"clientCertificateMode,omitempty"`
	CorsPolicy             *CorsPolicy_STATUS                 `json:"corsPolicy,omitempty"`
	CustomDomains          []CustomDomain_STATUS              `json:"customDomains,omitempty"`
	ExposedPort            *int                               `json:"exposedPort,omitempty"`
	External               *bool                              `json:"external,omitempty"`
	Fqdn                   *string                            `json:"fqdn,omitempty"`
	IpSecurityRestrictions []IpSecurityRestrictionRule_STATUS `json:"ipSecurityRestrictions,omitempty"`
	PropertyBag            genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	StickySessions         *Ingress_StickySessions_STATUS     `json:"stickySessions,omitempty"`
	TargetPort             *int                               `json:"targetPort,omitempty"`
	Traffic                []TrafficWeight_STATUS             `json:"traffic,omitempty"`
	Transport              *string                            `json:"transport,omitempty"`
}

// AssignProperties_From_Ingress_STATUS populates our Ingress_STATUS from the provided source Ingress_STATUS
func (ingress *Ingress_STATUS) AssignProperties_From_Ingress_STATUS(source *storage.Ingress_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalPortMappings
	if source.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]IngressPortMapping_STATUS, len(source.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range source.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping IngressPortMapping_STATUS
			err := additionalPortMapping.AssignProperties_From_IngressPortMapping_STATUS(&additionalPortMappingItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IngressPortMapping_STATUS() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		ingress.AdditionalPortMappings = additionalPortMappingList
	} else {
		ingress.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if source.AllowInsecure != nil {
		allowInsecure := *source.AllowInsecure
		ingress.AllowInsecure = &allowInsecure
	} else {
		ingress.AllowInsecure = nil
	}

	// ClientCertificateMode
	ingress.ClientCertificateMode = genruntime.ClonePointerToString(source.ClientCertificateMode)

	// CorsPolicy
	if source.CorsPolicy != nil {
		var corsPolicy CorsPolicy_STATUS
		err := corsPolicy.AssignProperties_From_CorsPolicy_STATUS(source.CorsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CorsPolicy_STATUS() to populate field CorsPolicy")
		}
		ingress.CorsPolicy = &corsPolicy
	} else {
		ingress.CorsPolicy = nil
	}

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]CustomDomain_STATUS, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain CustomDomain_STATUS
			err := customDomain.AssignProperties_From_CustomDomain_STATUS(&customDomainItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		ingress.CustomDomains = customDomainList
	} else {
		ingress.CustomDomains = nil
	}

	// ExposedPort
	ingress.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		ingress.External = &external
	} else {
		ingress.External = nil
	}

	// Fqdn
	ingress.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestrictionRule_STATUS, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestrictionRule_STATUS
			err := ipSecurityRestriction.AssignProperties_From_IpSecurityRestrictionRule_STATUS(&ipSecurityRestrictionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpSecurityRestrictionRule_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		ingress.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		ingress.IpSecurityRestrictions = nil
	}

	// StickySessions
	if source.StickySessions != nil {
		var stickySession Ingress_StickySessions_STATUS
		err := stickySession.AssignProperties_From_Ingress_StickySessions_STATUS(source.StickySessions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Ingress_StickySessions_STATUS() to populate field StickySessions")
		}
		ingress.StickySessions = &stickySession
	} else {
		ingress.StickySessions = nil
	}

	// TargetPort
	ingress.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// Traffic
	if source.Traffic != nil {
		trafficList := make([]TrafficWeight_STATUS, len(source.Traffic))
		for trafficIndex, trafficItem := range source.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic TrafficWeight_STATUS
			err := traffic.AssignProperties_From_TrafficWeight_STATUS(&trafficItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TrafficWeight_STATUS() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		ingress.Traffic = trafficList
	} else {
		ingress.Traffic = nil
	}

	// Transport
	ingress.Transport = genruntime.ClonePointerToString(source.Transport)

	// Update the property bag
	if len(propertyBag) > 0 {
		ingress.PropertyBag = propertyBag
	} else {
		ingress.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngress_STATUS interface (if implemented) to customize the conversion
	var ingressAsAny any = ingress
	if augmentedIngress, ok := ingressAsAny.(augmentConversionForIngress_STATUS); ok {
		err := augmentedIngress.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Ingress_STATUS populates the provided destination Ingress_STATUS from our Ingress_STATUS
func (ingress *Ingress_STATUS) AssignProperties_To_Ingress_STATUS(destination *storage.Ingress_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(ingress.PropertyBag)

	// AdditionalPortMappings
	if ingress.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]storage.IngressPortMapping_STATUS, len(ingress.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range ingress.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping storage.IngressPortMapping_STATUS
			err := additionalPortMappingItem.AssignProperties_To_IngressPortMapping_STATUS(&additionalPortMapping)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IngressPortMapping_STATUS() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		destination.AdditionalPortMappings = additionalPortMappingList
	} else {
		destination.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if ingress.AllowInsecure != nil {
		allowInsecure := *ingress.AllowInsecure
		destination.AllowInsecure = &allowInsecure
	} else {
		destination.AllowInsecure = nil
	}

	// ClientCertificateMode
	destination.ClientCertificateMode = genruntime.ClonePointerToString(ingress.ClientCertificateMode)

	// CorsPolicy
	if ingress.CorsPolicy != nil {
		var corsPolicy storage.CorsPolicy_STATUS
		err := ingress.CorsPolicy.AssignProperties_To_CorsPolicy_STATUS(&corsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CorsPolicy_STATUS() to populate field CorsPolicy")
		}
		destination.CorsPolicy = &corsPolicy
	} else {
		destination.CorsPolicy = nil
	}

	// CustomDomains
	if ingress.CustomDomains != nil {
		customDomainList := make([]storage.CustomDomain_STATUS, len(ingress.CustomDomains))
		for customDomainIndex, customDomainItem := range ingress.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain storage.CustomDomain_STATUS
			err := customDomainItem.AssignProperties_To_CustomDomain_STATUS(&customDomain)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// ExposedPort
	destination.ExposedPort = genruntime.ClonePointerToInt(ingress.ExposedPort)

	// External
	if ingress.External != nil {
		external := *ingress.External
		destination.External = &external
	} else {
		destination.External = nil
	}

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(ingress.Fqdn)

	// IpSecurityRestrictions
	if ingress.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]storage.IpSecurityRestrictionRule_STATUS, len(ingress.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range ingress.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction storage.IpSecurityRestrictionRule_STATUS
			err := ipSecurityRestrictionItem.AssignProperties_To_IpSecurityRestrictionRule_STATUS(&ipSecurityRestriction)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpSecurityRestrictionRule_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// StickySessions
	if ingress.StickySessions != nil {
		var stickySession storage.Ingress_StickySessions_STATUS
		err := ingress.StickySessions.AssignProperties_To_Ingress_StickySessions_STATUS(&stickySession)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Ingress_StickySessions_STATUS() to populate field StickySessions")
		}
		destination.StickySessions = &stickySession
	} else {
		destination.StickySessions = nil
	}

	// TargetPort
	destination.TargetPort = genruntime.ClonePointerToInt(ingress.TargetPort)

	// Traffic
	if ingress.Traffic != nil {
		trafficList := make([]storage.TrafficWeight_STATUS, len(ingress.Traffic))
		for trafficIndex, trafficItem := range ingress.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic storage.TrafficWeight_STATUS
			err := trafficItem.AssignProperties_To_TrafficWeight_STATUS(&traffic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TrafficWeight_STATUS() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		destination.Traffic = trafficList
	} else {
		destination.Traffic = nil
	}

	// Transport
	destination.Transport = genruntime.ClonePointerToString(ingress.Transport)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngress_STATUS interface (if implemented) to customize the conversion
	var ingressAsAny any = ingress
	if augmentedIngress, ok := ingressAsAny.(augmentConversionForIngress_STATUS); ok {
		err := augmentedIngress.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.RegistryCredentials
// Container App Private Registry
type RegistryCredentials struct {
	// IdentityReference: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned
	// identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
	IdentityReference *genruntime.WellknownResourceReference `armReference:"Identity" json:"identityReference,omitempty"`
	PasswordSecretRef *string                                `json:"passwordSecretRef,omitempty"`
	PropertyBag       genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	Server            *string                                `json:"server,omitempty"`
	Username          *string                                `json:"username,omitempty"`
}

// AssignProperties_From_RegistryCredentials populates our RegistryCredentials from the provided source RegistryCredentials
func (credentials *RegistryCredentials) AssignProperties_From_RegistryCredentials(source *storage.RegistryCredentials) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IdentityReference
	if source.IdentityReference != nil {
		identityReference := source.IdentityReference.Copy()
		credentials.IdentityReference = &identityReference
	} else {
		credentials.IdentityReference = nil
	}

	// PasswordSecretRef
	credentials.PasswordSecretRef = genruntime.ClonePointerToString(source.PasswordSecretRef)

	// Server
	credentials.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		credentials.PropertyBag = propertyBag
	} else {
		credentials.PropertyBag = nil
	}

	// Invoke the augmentConversionForRegistryCredentials interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForRegistryCredentials); ok {
		err := augmentedCredentials.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryCredentials populates the provided destination RegistryCredentials from our RegistryCredentials
func (credentials *RegistryCredentials) AssignProperties_To_RegistryCredentials(destination *storage.RegistryCredentials) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(credentials.PropertyBag)

	// IdentityReference
	if credentials.IdentityReference != nil {
		identityReference := credentials.IdentityReference.Copy()
		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// PasswordSecretRef
	destination.PasswordSecretRef = genruntime.ClonePointerToString(credentials.PasswordSecretRef)

	// Server
	destination.Server = genruntime.ClonePointerToString(credentials.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRegistryCredentials interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForRegistryCredentials); ok {
		err := augmentedCredentials.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.RegistryCredentials_STATUS
// Container App Private Registry
type RegistryCredentials_STATUS struct {
	Identity          *string                `json:"identity,omitempty"`
	PasswordSecretRef *string                `json:"passwordSecretRef,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Server            *string                `json:"server,omitempty"`
	Username          *string                `json:"username,omitempty"`
}

// AssignProperties_From_RegistryCredentials_STATUS populates our RegistryCredentials_STATUS from the provided source RegistryCredentials_STATUS
func (credentials *RegistryCredentials_STATUS) AssignProperties_From_RegistryCredentials_STATUS(source *storage.RegistryCredentials_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Identity
	credentials.Identity = genruntime.ClonePointerToString(source.Identity)

	// PasswordSecretRef
	credentials.PasswordSecretRef = genruntime.ClonePointerToString(source.PasswordSecretRef)

	// Server
	credentials.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		credentials.PropertyBag = propertyBag
	} else {
		credentials.PropertyBag = nil
	}

	// Invoke the augmentConversionForRegistryCredentials_STATUS interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForRegistryCredentials_STATUS); ok {
		err := augmentedCredentials.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RegistryCredentials_STATUS populates the provided destination RegistryCredentials_STATUS from our RegistryCredentials_STATUS
func (credentials *RegistryCredentials_STATUS) AssignProperties_To_RegistryCredentials_STATUS(destination *storage.RegistryCredentials_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(credentials.PropertyBag)

	// Identity
	destination.Identity = genruntime.ClonePointerToString(credentials.Identity)

	// PasswordSecretRef
	destination.PasswordSecretRef = genruntime.ClonePointerToString(credentials.PasswordSecretRef)

	// Server
	destination.Server = genruntime.ClonePointerToString(credentials.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRegistryCredentials_STATUS interface (if implemented) to customize the conversion
	var credentialsAsAny any = credentials
	if augmentedCredentials, ok := credentialsAsAny.(augmentConversionForRegistryCredentials_STATUS); ok {
		err := augmentedCredentials.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Scale
// Container App scaling configurations.
type Scale struct {
	MaxReplicas *int                   `json:"maxReplicas,omitempty"`
	MinReplicas *int                   `json:"minReplicas,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []ScaleRule            `json:"rules,omitempty"`
}

// AssignProperties_From_Scale populates our Scale from the provided source Scale
func (scale *Scale) AssignProperties_From_Scale(source *storage.Scale) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CooldownPeriod
	if source.CooldownPeriod != nil {
		propertyBag.Add("CooldownPeriod", *source.CooldownPeriod)
	} else {
		propertyBag.Remove("CooldownPeriod")
	}

	// MaxReplicas
	scale.MaxReplicas = genruntime.ClonePointerToInt(source.MaxReplicas)

	// MinReplicas
	scale.MinReplicas = genruntime.ClonePointerToInt(source.MinReplicas)

	// PollingInterval
	if source.PollingInterval != nil {
		propertyBag.Add("PollingInterval", *source.PollingInterval)
	} else {
		propertyBag.Remove("PollingInterval")
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ScaleRule
			err := rule.AssignProperties_From_ScaleRule(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		scale.PropertyBag = propertyBag
	} else {
		scale.PropertyBag = nil
	}

	// Invoke the augmentConversionForScale interface (if implemented) to customize the conversion
	var scaleAsAny any = scale
	if augmentedScale, ok := scaleAsAny.(augmentConversionForScale); ok {
		err := augmentedScale.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Scale populates the provided destination Scale from our Scale
func (scale *Scale) AssignProperties_To_Scale(destination *storage.Scale) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(scale.PropertyBag)

	// CooldownPeriod
	if propertyBag.Contains("CooldownPeriod") {
		var cooldownPeriod int
		err := propertyBag.Pull("CooldownPeriod", &cooldownPeriod)
		if err != nil {
			return eris.Wrap(err, "pulling 'CooldownPeriod' from propertyBag")
		}

		destination.CooldownPeriod = &cooldownPeriod
	} else {
		destination.CooldownPeriod = nil
	}

	// MaxReplicas
	destination.MaxReplicas = genruntime.ClonePointerToInt(scale.MaxReplicas)

	// MinReplicas
	destination.MinReplicas = genruntime.ClonePointerToInt(scale.MinReplicas)

	// PollingInterval
	if propertyBag.Contains("PollingInterval") {
		var pollingInterval int
		err := propertyBag.Pull("PollingInterval", &pollingInterval)
		if err != nil {
			return eris.Wrap(err, "pulling 'PollingInterval' from propertyBag")
		}

		destination.PollingInterval = &pollingInterval
	} else {
		destination.PollingInterval = nil
	}

	// Rules
	if scale.Rules != nil {
		ruleList := make([]storage.ScaleRule, len(scale.Rules))
		for ruleIndex, ruleItem := range scale.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ScaleRule
			err := ruleItem.AssignProperties_To_ScaleRule(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScale interface (if implemented) to customize the conversion
	var scaleAsAny any = scale
	if augmentedScale, ok := scaleAsAny.(augmentConversionForScale); ok {
		err := augmentedScale.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Scale_STATUS
// Container App scaling configurations.
type Scale_STATUS struct {
	MaxReplicas *int                   `json:"maxReplicas,omitempty"`
	MinReplicas *int                   `json:"minReplicas,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []ScaleRule_STATUS     `json:"rules,omitempty"`
}

// AssignProperties_From_Scale_STATUS populates our Scale_STATUS from the provided source Scale_STATUS
func (scale *Scale_STATUS) AssignProperties_From_Scale_STATUS(source *storage.Scale_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CooldownPeriod
	if source.CooldownPeriod != nil {
		propertyBag.Add("CooldownPeriod", *source.CooldownPeriod)
	} else {
		propertyBag.Remove("CooldownPeriod")
	}

	// MaxReplicas
	scale.MaxReplicas = genruntime.ClonePointerToInt(source.MaxReplicas)

	// MinReplicas
	scale.MinReplicas = genruntime.ClonePointerToInt(source.MinReplicas)

	// PollingInterval
	if source.PollingInterval != nil {
		propertyBag.Add("PollingInterval", *source.PollingInterval)
	} else {
		propertyBag.Remove("PollingInterval")
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ScaleRule_STATUS
			err := rule.AssignProperties_From_ScaleRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		scale.PropertyBag = propertyBag
	} else {
		scale.PropertyBag = nil
	}

	// Invoke the augmentConversionForScale_STATUS interface (if implemented) to customize the conversion
	var scaleAsAny any = scale
	if augmentedScale, ok := scaleAsAny.(augmentConversionForScale_STATUS); ok {
		err := augmentedScale.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Scale_STATUS populates the provided destination Scale_STATUS from our Scale_STATUS
func (scale *Scale_STATUS) AssignProperties_To_Scale_STATUS(destination *storage.Scale_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(scale.PropertyBag)

	// CooldownPeriod
	if propertyBag.Contains("CooldownPeriod") {
		var cooldownPeriod int
		err := propertyBag.Pull("CooldownPeriod", &cooldownPeriod)
		if err != nil {
			return eris.Wrap(err, "pulling 'CooldownPeriod' from propertyBag")
		}

		destination.CooldownPeriod = &cooldownPeriod
	} else {
		destination.CooldownPeriod = nil
	}

	// MaxReplicas
	destination.MaxReplicas = genruntime.ClonePointerToInt(scale.MaxReplicas)

	// MinReplicas
	destination.MinReplicas = genruntime.ClonePointerToInt(scale.MinReplicas)

	// PollingInterval
	if propertyBag.Contains("PollingInterval") {
		var pollingInterval int
		err := propertyBag.Pull("PollingInterval", &pollingInterval)
		if err != nil {
			return eris.Wrap(err, "pulling 'PollingInterval' from propertyBag")
		}

		destination.PollingInterval = &pollingInterval
	} else {
		destination.PollingInterval = nil
	}

	// Rules
	if scale.Rules != nil {
		ruleList := make([]storage.ScaleRule_STATUS, len(scale.Rules))
		for ruleIndex, ruleItem := range scale.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ScaleRule_STATUS
			err := ruleItem.AssignProperties_To_ScaleRule_STATUS(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScale_STATUS interface (if implemented) to customize the conversion
	var scaleAsAny any = scale
	if augmentedScale, ok := scaleAsAny.(augmentConversionForScale_STATUS); ok {
		err := augmentedScale.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Secret
// Secret definition.
type Secret struct {
	// IdentityReference: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a
	// system-assigned identity.
	IdentityReference *genruntime.WellknownResourceReference `armReference:"Identity" json:"identityReference,omitempty"`
	KeyVaultUrl       *string                                `json:"keyVaultUrl,omitempty"`
	Name              *string                                `json:"name,omitempty"`
	PropertyBag       genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	Value             *genruntime.SecretReference            `json:"value,omitempty"`
}

// AssignProperties_From_Secret populates our Secret from the provided source Secret
func (secret *Secret) AssignProperties_From_Secret(source *storage.Secret) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IdentityReference
	if source.IdentityReference != nil {
		identityReference := source.IdentityReference.Copy()
		secret.IdentityReference = &identityReference
	} else {
		secret.IdentityReference = nil
	}

	// KeyVaultUrl
	secret.KeyVaultUrl = genruntime.ClonePointerToString(source.KeyVaultUrl)

	// Name
	secret.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	if source.Value != nil {
		value := source.Value.Copy()
		secret.Value = &value
	} else {
		secret.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		secret.PropertyBag = propertyBag
	} else {
		secret.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecret interface (if implemented) to customize the conversion
	var secretAsAny any = secret
	if augmentedSecret, ok := secretAsAny.(augmentConversionForSecret); ok {
		err := augmentedSecret.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Secret populates the provided destination Secret from our Secret
func (secret *Secret) AssignProperties_To_Secret(destination *storage.Secret) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(secret.PropertyBag)

	// IdentityReference
	if secret.IdentityReference != nil {
		identityReference := secret.IdentityReference.Copy()
		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// KeyVaultUrl
	destination.KeyVaultUrl = genruntime.ClonePointerToString(secret.KeyVaultUrl)

	// Name
	destination.Name = genruntime.ClonePointerToString(secret.Name)

	// Value
	if secret.Value != nil {
		value := secret.Value.Copy()
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecret interface (if implemented) to customize the conversion
	var secretAsAny any = secret
	if augmentedSecret, ok := secretAsAny.(augmentConversionForSecret); ok {
		err := augmentedSecret.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Secret_STATUS
// Secret definition.
type Secret_STATUS struct {
	Identity    *string                `json:"identity,omitempty"`
	KeyVaultUrl *string                `json:"keyVaultUrl,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_Secret_STATUS populates our Secret_STATUS from the provided source Secret_STATUS
func (secret *Secret_STATUS) AssignProperties_From_Secret_STATUS(source *storage.Secret_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Identity
	secret.Identity = genruntime.ClonePointerToString(source.Identity)

	// KeyVaultUrl
	secret.KeyVaultUrl = genruntime.ClonePointerToString(source.KeyVaultUrl)

	// Name
	secret.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		secret.PropertyBag = propertyBag
	} else {
		secret.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecret_STATUS interface (if implemented) to customize the conversion
	var secretAsAny any = secret
	if augmentedSecret, ok := secretAsAny.(augmentConversionForSecret_STATUS); ok {
		err := augmentedSecret.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Secret_STATUS populates the provided destination Secret_STATUS from our Secret_STATUS
func (secret *Secret_STATUS) AssignProperties_To_Secret_STATUS(destination *storage.Secret_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(secret.PropertyBag)

	// Identity
	destination.Identity = genruntime.ClonePointerToString(secret.Identity)

	// KeyVaultUrl
	destination.KeyVaultUrl = genruntime.ClonePointerToString(secret.KeyVaultUrl)

	// Name
	destination.Name = genruntime.ClonePointerToString(secret.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecret_STATUS interface (if implemented) to customize the conversion
	var secretAsAny any = secret
	if augmentedSecret, ok := secretAsAny.(augmentConversionForSecret_STATUS); ok {
		err := augmentedSecret.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Service
// Container App to be a dev service
type Service struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_Service populates our Service from the provided source Service
func (service *Service) AssignProperties_From_Service(source *storage.Service) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	service.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		service.PropertyBag = propertyBag
	} else {
		service.PropertyBag = nil
	}

	// Invoke the augmentConversionForService interface (if implemented) to customize the conversion
	var serviceAsAny any = service
	if augmentedService, ok := serviceAsAny.(augmentConversionForService); ok {
		err := augmentedService.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Service populates the provided destination Service from our Service
func (service *Service) AssignProperties_To_Service(destination *storage.Service) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(service.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(service.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForService interface (if implemented) to customize the conversion
	var serviceAsAny any = service
	if augmentedService, ok := serviceAsAny.(augmentConversionForService); ok {
		err := augmentedService.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Service_STATUS
// Container App to be a dev service
type Service_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_Service_STATUS populates our Service_STATUS from the provided source Service_STATUS
func (service *Service_STATUS) AssignProperties_From_Service_STATUS(source *storage.Service_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	service.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		service.PropertyBag = propertyBag
	} else {
		service.PropertyBag = nil
	}

	// Invoke the augmentConversionForService_STATUS interface (if implemented) to customize the conversion
	var serviceAsAny any = service
	if augmentedService, ok := serviceAsAny.(augmentConversionForService_STATUS); ok {
		err := augmentedService.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Service_STATUS populates the provided destination Service_STATUS from our Service_STATUS
func (service *Service_STATUS) AssignProperties_To_Service_STATUS(destination *storage.Service_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(service.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(service.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForService_STATUS interface (if implemented) to customize the conversion
	var serviceAsAny any = service
	if augmentedService, ok := serviceAsAny.(augmentConversionForService_STATUS); ok {
		err := augmentedService.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ServiceBind
// Configuration to bind a ContainerApp to a dev ContainerApp Service
type ServiceBind struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// ServiceReference: Resource id of the target service
	ServiceReference *genruntime.ResourceReference `armReference:"ServiceId" json:"serviceReference,omitempty"`
}

// AssignProperties_From_ServiceBind populates our ServiceBind from the provided source ServiceBind
func (bind *ServiceBind) AssignProperties_From_ServiceBind(source *storage.ServiceBind) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	bind.Name = genruntime.ClonePointerToString(source.Name)

	// ServiceReference
	if source.ServiceReference != nil {
		serviceReference := source.ServiceReference.Copy()
		bind.ServiceReference = &serviceReference
	} else {
		bind.ServiceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		bind.PropertyBag = propertyBag
	} else {
		bind.PropertyBag = nil
	}

	// Invoke the augmentConversionForServiceBind interface (if implemented) to customize the conversion
	var bindAsAny any = bind
	if augmentedBind, ok := bindAsAny.(augmentConversionForServiceBind); ok {
		err := augmentedBind.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceBind populates the provided destination ServiceBind from our ServiceBind
func (bind *ServiceBind) AssignProperties_To_ServiceBind(destination *storage.ServiceBind) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(bind.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(bind.Name)

	// ServiceReference
	if bind.ServiceReference != nil {
		serviceReference := bind.ServiceReference.Copy()
		destination.ServiceReference = &serviceReference
	} else {
		destination.ServiceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForServiceBind interface (if implemented) to customize the conversion
	var bindAsAny any = bind
	if augmentedBind, ok := bindAsAny.(augmentConversionForServiceBind); ok {
		err := augmentedBind.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ServiceBind_STATUS
// Configuration to bind a ContainerApp to a dev ContainerApp Service
type ServiceBind_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ServiceId   *string                `json:"serviceId,omitempty"`
}

// AssignProperties_From_ServiceBind_STATUS populates our ServiceBind_STATUS from the provided source ServiceBind_STATUS
func (bind *ServiceBind_STATUS) AssignProperties_From_ServiceBind_STATUS(source *storage.ServiceBind_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	bind.Name = genruntime.ClonePointerToString(source.Name)

	// ServiceId
	bind.ServiceId = genruntime.ClonePointerToString(source.ServiceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		bind.PropertyBag = propertyBag
	} else {
		bind.PropertyBag = nil
	}

	// Invoke the augmentConversionForServiceBind_STATUS interface (if implemented) to customize the conversion
	var bindAsAny any = bind
	if augmentedBind, ok := bindAsAny.(augmentConversionForServiceBind_STATUS); ok {
		err := augmentedBind.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceBind_STATUS populates the provided destination ServiceBind_STATUS from our ServiceBind_STATUS
func (bind *ServiceBind_STATUS) AssignProperties_To_ServiceBind_STATUS(destination *storage.ServiceBind_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(bind.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(bind.Name)

	// ServiceId
	destination.ServiceId = genruntime.ClonePointerToString(bind.ServiceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForServiceBind_STATUS interface (if implemented) to customize the conversion
	var bindAsAny any = bind
	if augmentedBind, ok := bindAsAny.(augmentConversionForServiceBind_STATUS); ok {
		err := augmentedBind.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.UserAssignedIdentity_STATUS
// User assigned identity properties
type UserAssignedIdentity_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PrincipalId *string                `json:"principalId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserAssignedIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForUserAssignedIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserAssignedIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForUserAssignedIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.UserAssignedIdentityDetails
// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	PropertyBag genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	Reference   genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	details.Reference = source.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		details.PropertyBag = propertyBag
	} else {
		details.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserAssignedIdentityDetails interface (if implemented) to customize the conversion
	var detailsAsAny any = details
	if augmentedDetails, ok := detailsAsAny.(augmentConversionForUserAssignedIdentityDetails); ok {
		err := augmentedDetails.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(details.PropertyBag)

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserAssignedIdentityDetails interface (if implemented) to customize the conversion
	var detailsAsAny any = details
	if augmentedDetails, ok := detailsAsAny.(augmentConversionForUserAssignedIdentityDetails); ok {
		err := augmentedDetails.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Volume
// Volume definitions for the Container App.
type Volume struct {
	MountOptions *string                `json:"mountOptions,omitempty"`
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Secrets      []SecretVolumeItem     `json:"secrets,omitempty"`
	StorageName  *string                `json:"storageName,omitempty"`
	StorageType  *string                `json:"storageType,omitempty"`
}

// AssignProperties_From_Volume populates our Volume from the provided source Volume
func (volume *Volume) AssignProperties_From_Volume(source *storage.Volume) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MountOptions
	volume.MountOptions = genruntime.ClonePointerToString(source.MountOptions)

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secrets
	if source.Secrets != nil {
		secretList := make([]SecretVolumeItem, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret SecretVolumeItem
			err := secret.AssignProperties_From_SecretVolumeItem(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SecretVolumeItem() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		volume.Secrets = secretList
	} else {
		volume.Secrets = nil
	}

	// StorageName
	volume.StorageName = genruntime.ClonePointerToString(source.StorageName)

	// StorageType
	volume.StorageType = genruntime.ClonePointerToString(source.StorageType)

	// Update the property bag
	if len(propertyBag) > 0 {
		volume.PropertyBag = propertyBag
	} else {
		volume.PropertyBag = nil
	}

	// Invoke the augmentConversionForVolume interface (if implemented) to customize the conversion
	var volumeAsAny any = volume
	if augmentedVolume, ok := volumeAsAny.(augmentConversionForVolume); ok {
		err := augmentedVolume.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Volume populates the provided destination Volume from our Volume
func (volume *Volume) AssignProperties_To_Volume(destination *storage.Volume) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(volume.PropertyBag)

	// MountOptions
	destination.MountOptions = genruntime.ClonePointerToString(volume.MountOptions)

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secrets
	if volume.Secrets != nil {
		secretList := make([]storage.SecretVolumeItem, len(volume.Secrets))
		for secretIndex, secretItem := range volume.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.SecretVolumeItem
			err := secretItem.AssignProperties_To_SecretVolumeItem(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SecretVolumeItem() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// StorageName
	destination.StorageName = genruntime.ClonePointerToString(volume.StorageName)

	// StorageType
	destination.StorageType = genruntime.ClonePointerToString(volume.StorageType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVolume interface (if implemented) to customize the conversion
	var volumeAsAny any = volume
	if augmentedVolume, ok := volumeAsAny.(augmentConversionForVolume); ok {
		err := augmentedVolume.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Volume_STATUS
// Volume definitions for the Container App.
type Volume_STATUS struct {
	MountOptions *string                   `json:"mountOptions,omitempty"`
	Name         *string                   `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
	Secrets      []SecretVolumeItem_STATUS `json:"secrets,omitempty"`
	StorageName  *string                   `json:"storageName,omitempty"`
	StorageType  *string                   `json:"storageType,omitempty"`
}

// AssignProperties_From_Volume_STATUS populates our Volume_STATUS from the provided source Volume_STATUS
func (volume *Volume_STATUS) AssignProperties_From_Volume_STATUS(source *storage.Volume_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MountOptions
	volume.MountOptions = genruntime.ClonePointerToString(source.MountOptions)

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secrets
	if source.Secrets != nil {
		secretList := make([]SecretVolumeItem_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret SecretVolumeItem_STATUS
			err := secret.AssignProperties_From_SecretVolumeItem_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SecretVolumeItem_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		volume.Secrets = secretList
	} else {
		volume.Secrets = nil
	}

	// StorageName
	volume.StorageName = genruntime.ClonePointerToString(source.StorageName)

	// StorageType
	volume.StorageType = genruntime.ClonePointerToString(source.StorageType)

	// Update the property bag
	if len(propertyBag) > 0 {
		volume.PropertyBag = propertyBag
	} else {
		volume.PropertyBag = nil
	}

	// Invoke the augmentConversionForVolume_STATUS interface (if implemented) to customize the conversion
	var volumeAsAny any = volume
	if augmentedVolume, ok := volumeAsAny.(augmentConversionForVolume_STATUS); ok {
		err := augmentedVolume.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Volume_STATUS populates the provided destination Volume_STATUS from our Volume_STATUS
func (volume *Volume_STATUS) AssignProperties_To_Volume_STATUS(destination *storage.Volume_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(volume.PropertyBag)

	// MountOptions
	destination.MountOptions = genruntime.ClonePointerToString(volume.MountOptions)

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secrets
	if volume.Secrets != nil {
		secretList := make([]storage.SecretVolumeItem_STATUS, len(volume.Secrets))
		for secretIndex, secretItem := range volume.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.SecretVolumeItem_STATUS
			err := secretItem.AssignProperties_To_SecretVolumeItem_STATUS(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SecretVolumeItem_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// StorageName
	destination.StorageName = genruntime.ClonePointerToString(volume.StorageName)

	// StorageType
	destination.StorageType = genruntime.ClonePointerToString(volume.StorageType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVolume_STATUS interface (if implemented) to customize the conversion
	var volumeAsAny any = volume
	if augmentedVolume, ok := volumeAsAny.(augmentConversionForVolume_STATUS); ok {
		err := augmentedVolume.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForBaseContainer interface {
	AssignPropertiesFrom(src *storage.BaseContainer) error
	AssignPropertiesTo(dst *storage.BaseContainer) error
}

type augmentConversionForBaseContainer_STATUS interface {
	AssignPropertiesFrom(src *storage.BaseContainer_STATUS) error
	AssignPropertiesTo(dst *storage.BaseContainer_STATUS) error
}

type augmentConversionForContainer interface {
	AssignPropertiesFrom(src *storage.Container) error
	AssignPropertiesTo(dst *storage.Container) error
}

type augmentConversionForContainer_STATUS interface {
	AssignPropertiesFrom(src *storage.Container_STATUS) error
	AssignPropertiesTo(dst *storage.Container_STATUS) error
}

type augmentConversionForContainerAppOperatorConfigMaps interface {
	AssignPropertiesFrom(src *storage.ContainerAppOperatorConfigMaps) error
	AssignPropertiesTo(dst *storage.ContainerAppOperatorConfigMaps) error
}

type augmentConversionForDapr interface {
	AssignPropertiesFrom(src *storage.Dapr) error
	AssignPropertiesTo(dst *storage.Dapr) error
}

type augmentConversionForDapr_STATUS interface {
	AssignPropertiesFrom(src *storage.Dapr_STATUS) error
	AssignPropertiesTo(dst *storage.Dapr_STATUS) error
}

type augmentConversionForIngress interface {
	AssignPropertiesFrom(src *storage.Ingress) error
	AssignPropertiesTo(dst *storage.Ingress) error
}

type augmentConversionForIngress_STATUS interface {
	AssignPropertiesFrom(src *storage.Ingress_STATUS) error
	AssignPropertiesTo(dst *storage.Ingress_STATUS) error
}

type augmentConversionForRegistryCredentials interface {
	AssignPropertiesFrom(src *storage.RegistryCredentials) error
	AssignPropertiesTo(dst *storage.RegistryCredentials) error
}

type augmentConversionForRegistryCredentials_STATUS interface {
	AssignPropertiesFrom(src *storage.RegistryCredentials_STATUS) error
	AssignPropertiesTo(dst *storage.RegistryCredentials_STATUS) error
}

type augmentConversionForScale interface {
	AssignPropertiesFrom(src *storage.Scale) error
	AssignPropertiesTo(dst *storage.Scale) error
}

type augmentConversionForScale_STATUS interface {
	AssignPropertiesFrom(src *storage.Scale_STATUS) error
	AssignPropertiesTo(dst *storage.Scale_STATUS) error
}

type augmentConversionForSecret interface {
	AssignPropertiesFrom(src *storage.Secret) error
	AssignPropertiesTo(dst *storage.Secret) error
}

type augmentConversionForSecret_STATUS interface {
	AssignPropertiesFrom(src *storage.Secret_STATUS) error
	AssignPropertiesTo(dst *storage.Secret_STATUS) error
}

type augmentConversionForService interface {
	AssignPropertiesFrom(src *storage.Service) error
	AssignPropertiesTo(dst *storage.Service) error
}

type augmentConversionForService_STATUS interface {
	AssignPropertiesFrom(src *storage.Service_STATUS) error
	AssignPropertiesTo(dst *storage.Service_STATUS) error
}

type augmentConversionForServiceBind interface {
	AssignPropertiesFrom(src *storage.ServiceBind) error
	AssignPropertiesTo(dst *storage.ServiceBind) error
}

type augmentConversionForServiceBind_STATUS interface {
	AssignPropertiesFrom(src *storage.ServiceBind_STATUS) error
	AssignPropertiesTo(dst *storage.ServiceBind_STATUS) error
}

type augmentConversionForUserAssignedIdentity_STATUS interface {
	AssignPropertiesFrom(src *storage.UserAssignedIdentity_STATUS) error
	AssignPropertiesTo(dst *storage.UserAssignedIdentity_STATUS) error
}

type augmentConversionForUserAssignedIdentityDetails interface {
	AssignPropertiesFrom(src *storage.UserAssignedIdentityDetails) error
	AssignPropertiesTo(dst *storage.UserAssignedIdentityDetails) error
}

type augmentConversionForVolume interface {
	AssignPropertiesFrom(src *storage.Volume) error
	AssignPropertiesTo(dst *storage.Volume) error
}

type augmentConversionForVolume_STATUS interface {
	AssignPropertiesFrom(src *storage.Volume_STATUS) error
	AssignPropertiesTo(dst *storage.Volume_STATUS) error
}

// Storage version of v1api20240301.ContainerAppProbe
// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive
// traffic.
type ContainerAppProbe struct {
	FailureThreshold              *int                         `json:"failureThreshold,omitempty"`
	HttpGet                       *ContainerAppProbe_HttpGet   `json:"httpGet,omitempty"`
	InitialDelaySeconds           *int                         `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds                 *int                         `json:"periodSeconds,omitempty"`
	PropertyBag                   genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	SuccessThreshold              *int                         `json:"successThreshold,omitempty"`
	TcpSocket                     *ContainerAppProbe_TcpSocket `json:"tcpSocket,omitempty"`
	TerminationGracePeriodSeconds *int                         `json:"terminationGracePeriodSeconds,omitempty"`
	TimeoutSeconds                *int                         `json:"timeoutSeconds,omitempty"`
	Type                          *string                      `json:"type,omitempty"`
}

// AssignProperties_From_ContainerAppProbe populates our ContainerAppProbe from the provided source ContainerAppProbe
func (probe *ContainerAppProbe) AssignProperties_From_ContainerAppProbe(source *storage.ContainerAppProbe) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerAppProbe_HttpGet
		err := httpGet.AssignProperties_From_ContainerAppProbe_HttpGet(source.HttpGet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_HttpGet() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TcpSocket
	if source.TcpSocket != nil {
		var tcpSocket ContainerAppProbe_TcpSocket
		err := tcpSocket.AssignProperties_From_ContainerAppProbe_TcpSocket(source.TcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_TcpSocket() to populate field TcpSocket")
		}
		probe.TcpSocket = &tcpSocket
	} else {
		probe.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	probe.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// Type
	probe.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		probe.PropertyBag = propertyBag
	} else {
		probe.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe interface (if implemented) to customize the conversion
	var probeAsAny any = probe
	if augmentedProbe, ok := probeAsAny.(augmentConversionForContainerAppProbe); ok {
		err := augmentedProbe.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe populates the provided destination ContainerAppProbe from our ContainerAppProbe
func (probe *ContainerAppProbe) AssignProperties_To_ContainerAppProbe(destination *storage.ContainerAppProbe) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(probe.PropertyBag)

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet storage.ContainerAppProbe_HttpGet
		err := probe.HttpGet.AssignProperties_To_ContainerAppProbe_HttpGet(&httpGet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_HttpGet() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TcpSocket
	if probe.TcpSocket != nil {
		var tcpSocket storage.ContainerAppProbe_TcpSocket
		err := probe.TcpSocket.AssignProperties_To_ContainerAppProbe_TcpSocket(&tcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_TcpSocket() to populate field TcpSocket")
		}
		destination.TcpSocket = &tcpSocket
	} else {
		destination.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	destination.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(probe.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Type
	destination.Type = genruntime.ClonePointerToString(probe.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe interface (if implemented) to customize the conversion
	var probeAsAny any = probe
	if augmentedProbe, ok := probeAsAny.(augmentConversionForContainerAppProbe); ok {
		err := augmentedProbe.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerAppProbe_STATUS
// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive
// traffic.
type ContainerAppProbe_STATUS struct {
	FailureThreshold              *int                                `json:"failureThreshold,omitempty"`
	HttpGet                       *ContainerAppProbe_HttpGet_STATUS   `json:"httpGet,omitempty"`
	InitialDelaySeconds           *int                                `json:"initialDelaySeconds,omitempty"`
	PeriodSeconds                 *int                                `json:"periodSeconds,omitempty"`
	PropertyBag                   genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
	SuccessThreshold              *int                                `json:"successThreshold,omitempty"`
	TcpSocket                     *ContainerAppProbe_TcpSocket_STATUS `json:"tcpSocket,omitempty"`
	TerminationGracePeriodSeconds *int                                `json:"terminationGracePeriodSeconds,omitempty"`
	TimeoutSeconds                *int                                `json:"timeoutSeconds,omitempty"`
	Type                          *string                             `json:"type,omitempty"`
}

// AssignProperties_From_ContainerAppProbe_STATUS populates our ContainerAppProbe_STATUS from the provided source ContainerAppProbe_STATUS
func (probe *ContainerAppProbe_STATUS) AssignProperties_From_ContainerAppProbe_STATUS(source *storage.ContainerAppProbe_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerAppProbe_HttpGet_STATUS
		err := httpGet.AssignProperties_From_ContainerAppProbe_HttpGet_STATUS(source.HttpGet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_HttpGet_STATUS() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TcpSocket
	if source.TcpSocket != nil {
		var tcpSocket ContainerAppProbe_TcpSocket_STATUS
		err := tcpSocket.AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS(source.TcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS() to populate field TcpSocket")
		}
		probe.TcpSocket = &tcpSocket
	} else {
		probe.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	probe.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// Type
	probe.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		probe.PropertyBag = propertyBag
	} else {
		probe.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_STATUS interface (if implemented) to customize the conversion
	var probeAsAny any = probe
	if augmentedProbe, ok := probeAsAny.(augmentConversionForContainerAppProbe_STATUS); ok {
		err := augmentedProbe.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_STATUS populates the provided destination ContainerAppProbe_STATUS from our ContainerAppProbe_STATUS
func (probe *ContainerAppProbe_STATUS) AssignProperties_To_ContainerAppProbe_STATUS(destination *storage.ContainerAppProbe_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(probe.PropertyBag)

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet storage.ContainerAppProbe_HttpGet_STATUS
		err := probe.HttpGet.AssignProperties_To_ContainerAppProbe_HttpGet_STATUS(&httpGet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_HttpGet_STATUS() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TcpSocket
	if probe.TcpSocket != nil {
		var tcpSocket storage.ContainerAppProbe_TcpSocket_STATUS
		err := probe.TcpSocket.AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS(&tcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS() to populate field TcpSocket")
		}
		destination.TcpSocket = &tcpSocket
	} else {
		destination.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	destination.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(probe.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Type
	destination.Type = genruntime.ClonePointerToString(probe.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_STATUS interface (if implemented) to customize the conversion
	var probeAsAny any = probe
	if augmentedProbe, ok := probeAsAny.(augmentConversionForContainerAppProbe_STATUS); ok {
		err := augmentedProbe.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerResources
// Container App container resource requirements.
type ContainerResources struct {
	Cpu         *float64               `json:"cpu,omitempty"`
	Memory      *string                `json:"memory,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ContainerResources populates our ContainerResources from the provided source ContainerResources
func (resources *ContainerResources) AssignProperties_From_ContainerResources(source *storage.ContainerResources) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		resources.Cpu = &cpu
	} else {
		resources.Cpu = nil
	}

	// Memory
	resources.Memory = genruntime.ClonePointerToString(source.Memory)

	// Update the property bag
	if len(propertyBag) > 0 {
		resources.PropertyBag = propertyBag
	} else {
		resources.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerResources interface (if implemented) to customize the conversion
	var resourcesAsAny any = resources
	if augmentedResources, ok := resourcesAsAny.(augmentConversionForContainerResources); ok {
		err := augmentedResources.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerResources populates the provided destination ContainerResources from our ContainerResources
func (resources *ContainerResources) AssignProperties_To_ContainerResources(destination *storage.ContainerResources) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resources.PropertyBag)

	// Cpu
	if resources.Cpu != nil {
		cpu := *resources.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Memory
	destination.Memory = genruntime.ClonePointerToString(resources.Memory)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerResources interface (if implemented) to customize the conversion
	var resourcesAsAny any = resources
	if augmentedResources, ok := resourcesAsAny.(augmentConversionForContainerResources); ok {
		err := augmentedResources.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerResources_STATUS
// Container App container resource requirements.
type ContainerResources_STATUS struct {
	Cpu              *float64               `json:"cpu,omitempty"`
	EphemeralStorage *string                `json:"ephemeralStorage,omitempty"`
	Memory           *string                `json:"memory,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ContainerResources_STATUS populates our ContainerResources_STATUS from the provided source ContainerResources_STATUS
func (resources *ContainerResources_STATUS) AssignProperties_From_ContainerResources_STATUS(source *storage.ContainerResources_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		resources.Cpu = &cpu
	} else {
		resources.Cpu = nil
	}

	// EphemeralStorage
	resources.EphemeralStorage = genruntime.ClonePointerToString(source.EphemeralStorage)

	// Memory
	resources.Memory = genruntime.ClonePointerToString(source.Memory)

	// Update the property bag
	if len(propertyBag) > 0 {
		resources.PropertyBag = propertyBag
	} else {
		resources.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerResources_STATUS interface (if implemented) to customize the conversion
	var resourcesAsAny any = resources
	if augmentedResources, ok := resourcesAsAny.(augmentConversionForContainerResources_STATUS); ok {
		err := augmentedResources.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerResources_STATUS populates the provided destination ContainerResources_STATUS from our ContainerResources_STATUS
func (resources *ContainerResources_STATUS) AssignProperties_To_ContainerResources_STATUS(destination *storage.ContainerResources_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resources.PropertyBag)

	// Cpu
	if resources.Cpu != nil {
		cpu := *resources.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// EphemeralStorage
	destination.EphemeralStorage = genruntime.ClonePointerToString(resources.EphemeralStorage)

	// Memory
	destination.Memory = genruntime.ClonePointerToString(resources.Memory)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerResources_STATUS interface (if implemented) to customize the conversion
	var resourcesAsAny any = resources
	if augmentedResources, ok := resourcesAsAny.(augmentConversionForContainerResources_STATUS); ok {
		err := augmentedResources.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CorsPolicy
// Cross-Origin-Resource-Sharing policy
type CorsPolicy struct {
	AllowCredentials *bool                  `json:"allowCredentials,omitempty"`
	AllowedHeaders   []string               `json:"allowedHeaders,omitempty"`
	AllowedMethods   []string               `json:"allowedMethods,omitempty"`
	AllowedOrigins   []string               `json:"allowedOrigins,omitempty"`
	ExposeHeaders    []string               `json:"exposeHeaders,omitempty"`
	MaxAge           *int                   `json:"maxAge,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_CorsPolicy populates our CorsPolicy from the provided source CorsPolicy
func (policy *CorsPolicy) AssignProperties_From_CorsPolicy(source *storage.CorsPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowCredentials
	if source.AllowCredentials != nil {
		allowCredential := *source.AllowCredentials
		policy.AllowCredentials = &allowCredential
	} else {
		policy.AllowCredentials = nil
	}

	// AllowedHeaders
	policy.AllowedHeaders = genruntime.CloneSliceOfString(source.AllowedHeaders)

	// AllowedMethods
	policy.AllowedMethods = genruntime.CloneSliceOfString(source.AllowedMethods)

	// AllowedOrigins
	policy.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// ExposeHeaders
	policy.ExposeHeaders = genruntime.CloneSliceOfString(source.ExposeHeaders)

	// MaxAge
	policy.MaxAge = genruntime.ClonePointerToInt(source.MaxAge)

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForCorsPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForCorsPolicy); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CorsPolicy populates the provided destination CorsPolicy from our CorsPolicy
func (policy *CorsPolicy) AssignProperties_To_CorsPolicy(destination *storage.CorsPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// AllowCredentials
	if policy.AllowCredentials != nil {
		allowCredential := *policy.AllowCredentials
		destination.AllowCredentials = &allowCredential
	} else {
		destination.AllowCredentials = nil
	}

	// AllowedHeaders
	destination.AllowedHeaders = genruntime.CloneSliceOfString(policy.AllowedHeaders)

	// AllowedMethods
	destination.AllowedMethods = genruntime.CloneSliceOfString(policy.AllowedMethods)

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(policy.AllowedOrigins)

	// ExposeHeaders
	destination.ExposeHeaders = genruntime.CloneSliceOfString(policy.ExposeHeaders)

	// MaxAge
	destination.MaxAge = genruntime.ClonePointerToInt(policy.MaxAge)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCorsPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForCorsPolicy); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CorsPolicy_STATUS
// Cross-Origin-Resource-Sharing policy
type CorsPolicy_STATUS struct {
	AllowCredentials *bool                  `json:"allowCredentials,omitempty"`
	AllowedHeaders   []string               `json:"allowedHeaders,omitempty"`
	AllowedMethods   []string               `json:"allowedMethods,omitempty"`
	AllowedOrigins   []string               `json:"allowedOrigins,omitempty"`
	ExposeHeaders    []string               `json:"exposeHeaders,omitempty"`
	MaxAge           *int                   `json:"maxAge,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_CorsPolicy_STATUS populates our CorsPolicy_STATUS from the provided source CorsPolicy_STATUS
func (policy *CorsPolicy_STATUS) AssignProperties_From_CorsPolicy_STATUS(source *storage.CorsPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowCredentials
	if source.AllowCredentials != nil {
		allowCredential := *source.AllowCredentials
		policy.AllowCredentials = &allowCredential
	} else {
		policy.AllowCredentials = nil
	}

	// AllowedHeaders
	policy.AllowedHeaders = genruntime.CloneSliceOfString(source.AllowedHeaders)

	// AllowedMethods
	policy.AllowedMethods = genruntime.CloneSliceOfString(source.AllowedMethods)

	// AllowedOrigins
	policy.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// ExposeHeaders
	policy.ExposeHeaders = genruntime.CloneSliceOfString(source.ExposeHeaders)

	// MaxAge
	policy.MaxAge = genruntime.ClonePointerToInt(source.MaxAge)

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForCorsPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForCorsPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CorsPolicy_STATUS populates the provided destination CorsPolicy_STATUS from our CorsPolicy_STATUS
func (policy *CorsPolicy_STATUS) AssignProperties_To_CorsPolicy_STATUS(destination *storage.CorsPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// AllowCredentials
	if policy.AllowCredentials != nil {
		allowCredential := *policy.AllowCredentials
		destination.AllowCredentials = &allowCredential
	} else {
		destination.AllowCredentials = nil
	}

	// AllowedHeaders
	destination.AllowedHeaders = genruntime.CloneSliceOfString(policy.AllowedHeaders)

	// AllowedMethods
	destination.AllowedMethods = genruntime.CloneSliceOfString(policy.AllowedMethods)

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(policy.AllowedOrigins)

	// ExposeHeaders
	destination.ExposeHeaders = genruntime.CloneSliceOfString(policy.ExposeHeaders)

	// MaxAge
	destination.MaxAge = genruntime.ClonePointerToInt(policy.MaxAge)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCorsPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForCorsPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CustomDomain
// Custom Domain of a Container App
type CustomDomain struct {
	BindingType *string `json:"bindingType,omitempty"`

	// CertificateReference: Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
	CertificateReference *genruntime.ResourceReference `armReference:"CertificateId" json:"certificateReference,omitempty"`
	Name                 *string                       `json:"name,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_CustomDomain populates our CustomDomain from the provided source CustomDomain
func (domain *CustomDomain) AssignProperties_From_CustomDomain(source *storage.CustomDomain) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BindingType
	domain.BindingType = genruntime.ClonePointerToString(source.BindingType)

	// CertificateReference
	if source.CertificateReference != nil {
		certificateReference := source.CertificateReference.Copy()
		domain.CertificateReference = &certificateReference
	} else {
		domain.CertificateReference = nil
	}

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		domain.PropertyBag = propertyBag
	} else {
		domain.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomDomain interface (if implemented) to customize the conversion
	var domainAsAny any = domain
	if augmentedDomain, ok := domainAsAny.(augmentConversionForCustomDomain); ok {
		err := augmentedDomain.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CustomDomain populates the provided destination CustomDomain from our CustomDomain
func (domain *CustomDomain) AssignProperties_To_CustomDomain(destination *storage.CustomDomain) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(domain.PropertyBag)

	// BindingType
	destination.BindingType = genruntime.ClonePointerToString(domain.BindingType)

	// CertificateReference
	if domain.CertificateReference != nil {
		certificateReference := domain.CertificateReference.Copy()
		destination.CertificateReference = &certificateReference
	} else {
		destination.CertificateReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(domain.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomDomain interface (if implemented) to customize the conversion
	var domainAsAny any = domain
	if augmentedDomain, ok := domainAsAny.(augmentConversionForCustomDomain); ok {
		err := augmentedDomain.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CustomDomain_STATUS
// Custom Domain of a Container App
type CustomDomain_STATUS struct {
	BindingType   *string                `json:"bindingType,omitempty"`
	CertificateId *string                `json:"certificateId,omitempty"`
	Name          *string                `json:"name,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_CustomDomain_STATUS populates our CustomDomain_STATUS from the provided source CustomDomain_STATUS
func (domain *CustomDomain_STATUS) AssignProperties_From_CustomDomain_STATUS(source *storage.CustomDomain_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BindingType
	domain.BindingType = genruntime.ClonePointerToString(source.BindingType)

	// CertificateId
	domain.CertificateId = genruntime.ClonePointerToString(source.CertificateId)

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		domain.PropertyBag = propertyBag
	} else {
		domain.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomDomain_STATUS interface (if implemented) to customize the conversion
	var domainAsAny any = domain
	if augmentedDomain, ok := domainAsAny.(augmentConversionForCustomDomain_STATUS); ok {
		err := augmentedDomain.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CustomDomain_STATUS populates the provided destination CustomDomain_STATUS from our CustomDomain_STATUS
func (domain *CustomDomain_STATUS) AssignProperties_To_CustomDomain_STATUS(destination *storage.CustomDomain_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(domain.PropertyBag)

	// BindingType
	destination.BindingType = genruntime.ClonePointerToString(domain.BindingType)

	// CertificateId
	destination.CertificateId = genruntime.ClonePointerToString(domain.CertificateId)

	// Name
	destination.Name = genruntime.ClonePointerToString(domain.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomDomain_STATUS interface (if implemented) to customize the conversion
	var domainAsAny any = domain
	if augmentedDomain, ok := domainAsAny.(augmentConversionForCustomDomain_STATUS); ok {
		err := augmentedDomain.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.EnvironmentVar
// Container App container environment variable.
type EnvironmentVar struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretRef   *string                `json:"secretRef,omitempty"`
	Value       *string                `json:"value,omitempty"`
}

// AssignProperties_From_EnvironmentVar populates our EnvironmentVar from the provided source EnvironmentVar
func (environmentVar *EnvironmentVar) AssignProperties_From_EnvironmentVar(source *storage.EnvironmentVar) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	environmentVar.Name = genruntime.ClonePointerToString(source.Name)

	// SecretRef
	environmentVar.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// Value
	environmentVar.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		environmentVar.PropertyBag = propertyBag
	} else {
		environmentVar.PropertyBag = nil
	}

	// Invoke the augmentConversionForEnvironmentVar interface (if implemented) to customize the conversion
	var environmentVarAsAny any = environmentVar
	if augmentedEnvironmentVar, ok := environmentVarAsAny.(augmentConversionForEnvironmentVar); ok {
		err := augmentedEnvironmentVar.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVar populates the provided destination EnvironmentVar from our EnvironmentVar
func (environmentVar *EnvironmentVar) AssignProperties_To_EnvironmentVar(destination *storage.EnvironmentVar) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(environmentVar.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(environmentVar.Name)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(environmentVar.SecretRef)

	// Value
	destination.Value = genruntime.ClonePointerToString(environmentVar.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEnvironmentVar interface (if implemented) to customize the conversion
	var environmentVarAsAny any = environmentVar
	if augmentedEnvironmentVar, ok := environmentVarAsAny.(augmentConversionForEnvironmentVar); ok {
		err := augmentedEnvironmentVar.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.EnvironmentVar_STATUS
// Container App container environment variable.
type EnvironmentVar_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretRef   *string                `json:"secretRef,omitempty"`
	Value       *string                `json:"value,omitempty"`
}

// AssignProperties_From_EnvironmentVar_STATUS populates our EnvironmentVar_STATUS from the provided source EnvironmentVar_STATUS
func (environmentVar *EnvironmentVar_STATUS) AssignProperties_From_EnvironmentVar_STATUS(source *storage.EnvironmentVar_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	environmentVar.Name = genruntime.ClonePointerToString(source.Name)

	// SecretRef
	environmentVar.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// Value
	environmentVar.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		environmentVar.PropertyBag = propertyBag
	} else {
		environmentVar.PropertyBag = nil
	}

	// Invoke the augmentConversionForEnvironmentVar_STATUS interface (if implemented) to customize the conversion
	var environmentVarAsAny any = environmentVar
	if augmentedEnvironmentVar, ok := environmentVarAsAny.(augmentConversionForEnvironmentVar_STATUS); ok {
		err := augmentedEnvironmentVar.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVar_STATUS populates the provided destination EnvironmentVar_STATUS from our EnvironmentVar_STATUS
func (environmentVar *EnvironmentVar_STATUS) AssignProperties_To_EnvironmentVar_STATUS(destination *storage.EnvironmentVar_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(environmentVar.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(environmentVar.Name)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(environmentVar.SecretRef)

	// Value
	destination.Value = genruntime.ClonePointerToString(environmentVar.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEnvironmentVar_STATUS interface (if implemented) to customize the conversion
	var environmentVarAsAny any = environmentVar
	if augmentedEnvironmentVar, ok := environmentVarAsAny.(augmentConversionForEnvironmentVar_STATUS); ok {
		err := augmentedEnvironmentVar.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Ingress_StickySessions
type Ingress_StickySessions struct {
	Affinity    *string                `json:"affinity,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_Ingress_StickySessions populates our Ingress_StickySessions from the provided source Ingress_StickySessions
func (sessions *Ingress_StickySessions) AssignProperties_From_Ingress_StickySessions(source *storage.Ingress_StickySessions) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Affinity
	sessions.Affinity = genruntime.ClonePointerToString(source.Affinity)

	// Update the property bag
	if len(propertyBag) > 0 {
		sessions.PropertyBag = propertyBag
	} else {
		sessions.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngress_StickySessions interface (if implemented) to customize the conversion
	var sessionsAsAny any = sessions
	if augmentedSessions, ok := sessionsAsAny.(augmentConversionForIngress_StickySessions); ok {
		err := augmentedSessions.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Ingress_StickySessions populates the provided destination Ingress_StickySessions from our Ingress_StickySessions
func (sessions *Ingress_StickySessions) AssignProperties_To_Ingress_StickySessions(destination *storage.Ingress_StickySessions) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sessions.PropertyBag)

	// Affinity
	destination.Affinity = genruntime.ClonePointerToString(sessions.Affinity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngress_StickySessions interface (if implemented) to customize the conversion
	var sessionsAsAny any = sessions
	if augmentedSessions, ok := sessionsAsAny.(augmentConversionForIngress_StickySessions); ok {
		err := augmentedSessions.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Ingress_StickySessions_STATUS
type Ingress_StickySessions_STATUS struct {
	Affinity    *string                `json:"affinity,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_Ingress_StickySessions_STATUS populates our Ingress_StickySessions_STATUS from the provided source Ingress_StickySessions_STATUS
func (sessions *Ingress_StickySessions_STATUS) AssignProperties_From_Ingress_StickySessions_STATUS(source *storage.Ingress_StickySessions_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Affinity
	sessions.Affinity = genruntime.ClonePointerToString(source.Affinity)

	// Update the property bag
	if len(propertyBag) > 0 {
		sessions.PropertyBag = propertyBag
	} else {
		sessions.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngress_StickySessions_STATUS interface (if implemented) to customize the conversion
	var sessionsAsAny any = sessions
	if augmentedSessions, ok := sessionsAsAny.(augmentConversionForIngress_StickySessions_STATUS); ok {
		err := augmentedSessions.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Ingress_StickySessions_STATUS populates the provided destination Ingress_StickySessions_STATUS from our Ingress_StickySessions_STATUS
func (sessions *Ingress_StickySessions_STATUS) AssignProperties_To_Ingress_StickySessions_STATUS(destination *storage.Ingress_StickySessions_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sessions.PropertyBag)

	// Affinity
	destination.Affinity = genruntime.ClonePointerToString(sessions.Affinity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngress_StickySessions_STATUS interface (if implemented) to customize the conversion
	var sessionsAsAny any = sessions
	if augmentedSessions, ok := sessionsAsAny.(augmentConversionForIngress_StickySessions_STATUS); ok {
		err := augmentedSessions.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.IngressPortMapping
// Port mappings of container app ingress
type IngressPortMapping struct {
	ExposedPort *int                   `json:"exposedPort,omitempty"`
	External    *bool                  `json:"external,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TargetPort  *int                   `json:"targetPort,omitempty"`
}

// AssignProperties_From_IngressPortMapping populates our IngressPortMapping from the provided source IngressPortMapping
func (mapping *IngressPortMapping) AssignProperties_From_IngressPortMapping(source *storage.IngressPortMapping) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExposedPort
	mapping.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		mapping.External = &external
	} else {
		mapping.External = nil
	}

	// TargetPort
	mapping.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		mapping.PropertyBag = propertyBag
	} else {
		mapping.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngressPortMapping interface (if implemented) to customize the conversion
	var mappingAsAny any = mapping
	if augmentedMapping, ok := mappingAsAny.(augmentConversionForIngressPortMapping); ok {
		err := augmentedMapping.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IngressPortMapping populates the provided destination IngressPortMapping from our IngressPortMapping
func (mapping *IngressPortMapping) AssignProperties_To_IngressPortMapping(destination *storage.IngressPortMapping) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(mapping.PropertyBag)

	// ExposedPort
	destination.ExposedPort = genruntime.ClonePointerToInt(mapping.ExposedPort)

	// External
	if mapping.External != nil {
		external := *mapping.External
		destination.External = &external
	} else {
		destination.External = nil
	}

	// TargetPort
	destination.TargetPort = genruntime.ClonePointerToInt(mapping.TargetPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngressPortMapping interface (if implemented) to customize the conversion
	var mappingAsAny any = mapping
	if augmentedMapping, ok := mappingAsAny.(augmentConversionForIngressPortMapping); ok {
		err := augmentedMapping.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.IngressPortMapping_STATUS
// Port mappings of container app ingress
type IngressPortMapping_STATUS struct {
	ExposedPort *int                   `json:"exposedPort,omitempty"`
	External    *bool                  `json:"external,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TargetPort  *int                   `json:"targetPort,omitempty"`
}

// AssignProperties_From_IngressPortMapping_STATUS populates our IngressPortMapping_STATUS from the provided source IngressPortMapping_STATUS
func (mapping *IngressPortMapping_STATUS) AssignProperties_From_IngressPortMapping_STATUS(source *storage.IngressPortMapping_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExposedPort
	mapping.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		mapping.External = &external
	} else {
		mapping.External = nil
	}

	// TargetPort
	mapping.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		mapping.PropertyBag = propertyBag
	} else {
		mapping.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngressPortMapping_STATUS interface (if implemented) to customize the conversion
	var mappingAsAny any = mapping
	if augmentedMapping, ok := mappingAsAny.(augmentConversionForIngressPortMapping_STATUS); ok {
		err := augmentedMapping.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IngressPortMapping_STATUS populates the provided destination IngressPortMapping_STATUS from our IngressPortMapping_STATUS
func (mapping *IngressPortMapping_STATUS) AssignProperties_To_IngressPortMapping_STATUS(destination *storage.IngressPortMapping_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(mapping.PropertyBag)

	// ExposedPort
	destination.ExposedPort = genruntime.ClonePointerToInt(mapping.ExposedPort)

	// External
	if mapping.External != nil {
		external := *mapping.External
		destination.External = &external
	} else {
		destination.External = nil
	}

	// TargetPort
	destination.TargetPort = genruntime.ClonePointerToInt(mapping.TargetPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIngressPortMapping_STATUS interface (if implemented) to customize the conversion
	var mappingAsAny any = mapping
	if augmentedMapping, ok := mappingAsAny.(augmentConversionForIngressPortMapping_STATUS); ok {
		err := augmentedMapping.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.IpSecurityRestrictionRule
// Rule to restrict incoming IP address.
type IpSecurityRestrictionRule struct {
	Action         *string                `json:"action,omitempty"`
	Description    *string                `json:"description,omitempty"`
	IpAddressRange *string                `json:"ipAddressRange,omitempty"`
	Name           *string                `json:"name,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_IpSecurityRestrictionRule populates our IpSecurityRestrictionRule from the provided source IpSecurityRestrictionRule
func (rule *IpSecurityRestrictionRule) AssignProperties_From_IpSecurityRestrictionRule(source *storage.IpSecurityRestrictionRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Action
	rule.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// IpAddressRange
	rule.IpAddressRange = genruntime.ClonePointerToString(source.IpAddressRange)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForIpSecurityRestrictionRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForIpSecurityRestrictionRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IpSecurityRestrictionRule populates the provided destination IpSecurityRestrictionRule from our IpSecurityRestrictionRule
func (rule *IpSecurityRestrictionRule) AssignProperties_To_IpSecurityRestrictionRule(destination *storage.IpSecurityRestrictionRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Action
	destination.Action = genruntime.ClonePointerToString(rule.Action)

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// IpAddressRange
	destination.IpAddressRange = genruntime.ClonePointerToString(rule.IpAddressRange)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIpSecurityRestrictionRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForIpSecurityRestrictionRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.IpSecurityRestrictionRule_STATUS
// Rule to restrict incoming IP address.
type IpSecurityRestrictionRule_STATUS struct {
	Action         *string                `json:"action,omitempty"`
	Description    *string                `json:"description,omitempty"`
	IpAddressRange *string                `json:"ipAddressRange,omitempty"`
	Name           *string                `json:"name,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_IpSecurityRestrictionRule_STATUS populates our IpSecurityRestrictionRule_STATUS from the provided source IpSecurityRestrictionRule_STATUS
func (rule *IpSecurityRestrictionRule_STATUS) AssignProperties_From_IpSecurityRestrictionRule_STATUS(source *storage.IpSecurityRestrictionRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Action
	rule.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// IpAddressRange
	rule.IpAddressRange = genruntime.ClonePointerToString(source.IpAddressRange)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForIpSecurityRestrictionRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForIpSecurityRestrictionRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IpSecurityRestrictionRule_STATUS populates the provided destination IpSecurityRestrictionRule_STATUS from our IpSecurityRestrictionRule_STATUS
func (rule *IpSecurityRestrictionRule_STATUS) AssignProperties_To_IpSecurityRestrictionRule_STATUS(destination *storage.IpSecurityRestrictionRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Action
	destination.Action = genruntime.ClonePointerToString(rule.Action)

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// IpAddressRange
	destination.IpAddressRange = genruntime.ClonePointerToString(rule.IpAddressRange)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIpSecurityRestrictionRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForIpSecurityRestrictionRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ScaleRule
// Container App container scaling rule.
type ScaleRule struct {
	AzureQueue  *QueueScaleRule        `json:"azureQueue,omitempty"`
	Custom      *CustomScaleRule       `json:"custom,omitempty"`
	Http        *HttpScaleRule         `json:"http,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tcp         *TcpScaleRule          `json:"tcp,omitempty"`
}

// AssignProperties_From_ScaleRule populates our ScaleRule from the provided source ScaleRule
func (rule *ScaleRule) AssignProperties_From_ScaleRule(source *storage.ScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureQueue
	if source.AzureQueue != nil {
		var azureQueue QueueScaleRule
		err := azureQueue.AssignProperties_From_QueueScaleRule(source.AzureQueue)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_QueueScaleRule() to populate field AzureQueue")
		}
		rule.AzureQueue = &azureQueue
	} else {
		rule.AzureQueue = nil
	}

	// Custom
	if source.Custom != nil {
		var custom CustomScaleRule
		err := custom.AssignProperties_From_CustomScaleRule(source.Custom)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomScaleRule() to populate field Custom")
		}
		rule.Custom = &custom
	} else {
		rule.Custom = nil
	}

	// Http
	if source.Http != nil {
		var http HttpScaleRule
		err := http.AssignProperties_From_HttpScaleRule(source.Http)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpScaleRule() to populate field Http")
		}
		rule.Http = &http
	} else {
		rule.Http = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Tcp
	if source.Tcp != nil {
		var tcp TcpScaleRule
		err := tcp.AssignProperties_From_TcpScaleRule(source.Tcp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TcpScaleRule() to populate field Tcp")
		}
		rule.Tcp = &tcp
	} else {
		rule.Tcp = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForScaleRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleRule populates the provided destination ScaleRule from our ScaleRule
func (rule *ScaleRule) AssignProperties_To_ScaleRule(destination *storage.ScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// AzureQueue
	if rule.AzureQueue != nil {
		var azureQueue storage.QueueScaleRule
		err := rule.AzureQueue.AssignProperties_To_QueueScaleRule(&azureQueue)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_QueueScaleRule() to populate field AzureQueue")
		}
		destination.AzureQueue = &azureQueue
	} else {
		destination.AzureQueue = nil
	}

	// Custom
	if rule.Custom != nil {
		var custom storage.CustomScaleRule
		err := rule.Custom.AssignProperties_To_CustomScaleRule(&custom)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomScaleRule() to populate field Custom")
		}
		destination.Custom = &custom
	} else {
		destination.Custom = nil
	}

	// Http
	if rule.Http != nil {
		var http storage.HttpScaleRule
		err := rule.Http.AssignProperties_To_HttpScaleRule(&http)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpScaleRule() to populate field Http")
		}
		destination.Http = &http
	} else {
		destination.Http = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Tcp
	if rule.Tcp != nil {
		var tcp storage.TcpScaleRule
		err := rule.Tcp.AssignProperties_To_TcpScaleRule(&tcp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TcpScaleRule() to populate field Tcp")
		}
		destination.Tcp = &tcp
	} else {
		destination.Tcp = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForScaleRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ScaleRule_STATUS
// Container App container scaling rule.
type ScaleRule_STATUS struct {
	AzureQueue  *QueueScaleRule_STATUS  `json:"azureQueue,omitempty"`
	Custom      *CustomScaleRule_STATUS `json:"custom,omitempty"`
	Http        *HttpScaleRule_STATUS   `json:"http,omitempty"`
	Name        *string                 `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
	Tcp         *TcpScaleRule_STATUS    `json:"tcp,omitempty"`
}

// AssignProperties_From_ScaleRule_STATUS populates our ScaleRule_STATUS from the provided source ScaleRule_STATUS
func (rule *ScaleRule_STATUS) AssignProperties_From_ScaleRule_STATUS(source *storage.ScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureQueue
	if source.AzureQueue != nil {
		var azureQueue QueueScaleRule_STATUS
		err := azureQueue.AssignProperties_From_QueueScaleRule_STATUS(source.AzureQueue)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_QueueScaleRule_STATUS() to populate field AzureQueue")
		}
		rule.AzureQueue = &azureQueue
	} else {
		rule.AzureQueue = nil
	}

	// Custom
	if source.Custom != nil {
		var custom CustomScaleRule_STATUS
		err := custom.AssignProperties_From_CustomScaleRule_STATUS(source.Custom)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomScaleRule_STATUS() to populate field Custom")
		}
		rule.Custom = &custom
	} else {
		rule.Custom = nil
	}

	// Http
	if source.Http != nil {
		var http HttpScaleRule_STATUS
		err := http.AssignProperties_From_HttpScaleRule_STATUS(source.Http)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpScaleRule_STATUS() to populate field Http")
		}
		rule.Http = &http
	} else {
		rule.Http = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Tcp
	if source.Tcp != nil {
		var tcp TcpScaleRule_STATUS
		err := tcp.AssignProperties_From_TcpScaleRule_STATUS(source.Tcp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TcpScaleRule_STATUS() to populate field Tcp")
		}
		rule.Tcp = &tcp
	} else {
		rule.Tcp = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleRule_STATUS populates the provided destination ScaleRule_STATUS from our ScaleRule_STATUS
func (rule *ScaleRule_STATUS) AssignProperties_To_ScaleRule_STATUS(destination *storage.ScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// AzureQueue
	if rule.AzureQueue != nil {
		var azureQueue storage.QueueScaleRule_STATUS
		err := rule.AzureQueue.AssignProperties_To_QueueScaleRule_STATUS(&azureQueue)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_QueueScaleRule_STATUS() to populate field AzureQueue")
		}
		destination.AzureQueue = &azureQueue
	} else {
		destination.AzureQueue = nil
	}

	// Custom
	if rule.Custom != nil {
		var custom storage.CustomScaleRule_STATUS
		err := rule.Custom.AssignProperties_To_CustomScaleRule_STATUS(&custom)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomScaleRule_STATUS() to populate field Custom")
		}
		destination.Custom = &custom
	} else {
		destination.Custom = nil
	}

	// Http
	if rule.Http != nil {
		var http storage.HttpScaleRule_STATUS
		err := rule.Http.AssignProperties_To_HttpScaleRule_STATUS(&http)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpScaleRule_STATUS() to populate field Http")
		}
		destination.Http = &http
	} else {
		destination.Http = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Tcp
	if rule.Tcp != nil {
		var tcp storage.TcpScaleRule_STATUS
		err := rule.Tcp.AssignProperties_To_TcpScaleRule_STATUS(&tcp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TcpScaleRule_STATUS() to populate field Tcp")
		}
		destination.Tcp = &tcp
	} else {
		destination.Tcp = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.SecretVolumeItem
// Secret to be added to volume.
type SecretVolumeItem struct {
	Path        *string                `json:"path,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretRef   *string                `json:"secretRef,omitempty"`
}

// AssignProperties_From_SecretVolumeItem populates our SecretVolumeItem from the provided source SecretVolumeItem
func (item *SecretVolumeItem) AssignProperties_From_SecretVolumeItem(source *storage.SecretVolumeItem) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Path
	item.Path = genruntime.ClonePointerToString(source.Path)

	// SecretRef
	item.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// Update the property bag
	if len(propertyBag) > 0 {
		item.PropertyBag = propertyBag
	} else {
		item.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretVolumeItem interface (if implemented) to customize the conversion
	var itemAsAny any = item
	if augmentedItem, ok := itemAsAny.(augmentConversionForSecretVolumeItem); ok {
		err := augmentedItem.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecretVolumeItem populates the provided destination SecretVolumeItem from our SecretVolumeItem
func (item *SecretVolumeItem) AssignProperties_To_SecretVolumeItem(destination *storage.SecretVolumeItem) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(item.PropertyBag)

	// Path
	destination.Path = genruntime.ClonePointerToString(item.Path)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(item.SecretRef)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretVolumeItem interface (if implemented) to customize the conversion
	var itemAsAny any = item
	if augmentedItem, ok := itemAsAny.(augmentConversionForSecretVolumeItem); ok {
		err := augmentedItem.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.SecretVolumeItem_STATUS
// Secret to be added to volume.
type SecretVolumeItem_STATUS struct {
	Path        *string                `json:"path,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretRef   *string                `json:"secretRef,omitempty"`
}

// AssignProperties_From_SecretVolumeItem_STATUS populates our SecretVolumeItem_STATUS from the provided source SecretVolumeItem_STATUS
func (item *SecretVolumeItem_STATUS) AssignProperties_From_SecretVolumeItem_STATUS(source *storage.SecretVolumeItem_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Path
	item.Path = genruntime.ClonePointerToString(source.Path)

	// SecretRef
	item.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// Update the property bag
	if len(propertyBag) > 0 {
		item.PropertyBag = propertyBag
	} else {
		item.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretVolumeItem_STATUS interface (if implemented) to customize the conversion
	var itemAsAny any = item
	if augmentedItem, ok := itemAsAny.(augmentConversionForSecretVolumeItem_STATUS); ok {
		err := augmentedItem.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecretVolumeItem_STATUS populates the provided destination SecretVolumeItem_STATUS from our SecretVolumeItem_STATUS
func (item *SecretVolumeItem_STATUS) AssignProperties_To_SecretVolumeItem_STATUS(destination *storage.SecretVolumeItem_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(item.PropertyBag)

	// Path
	destination.Path = genruntime.ClonePointerToString(item.Path)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(item.SecretRef)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecretVolumeItem_STATUS interface (if implemented) to customize the conversion
	var itemAsAny any = item
	if augmentedItem, ok := itemAsAny.(augmentConversionForSecretVolumeItem_STATUS); ok {
		err := augmentedItem.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.TrafficWeight
// Traffic weight assigned to a revision
type TrafficWeight struct {
	Label          *string                `json:"label,omitempty"`
	LatestRevision *bool                  `json:"latestRevision,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RevisionName   *string                `json:"revisionName,omitempty"`
	Weight         *int                   `json:"weight,omitempty"`
}

// AssignProperties_From_TrafficWeight populates our TrafficWeight from the provided source TrafficWeight
func (weight *TrafficWeight) AssignProperties_From_TrafficWeight(source *storage.TrafficWeight) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Label
	weight.Label = genruntime.ClonePointerToString(source.Label)

	// LatestRevision
	if source.LatestRevision != nil {
		latestRevision := *source.LatestRevision
		weight.LatestRevision = &latestRevision
	} else {
		weight.LatestRevision = nil
	}

	// RevisionName
	weight.RevisionName = genruntime.ClonePointerToString(source.RevisionName)

	// Weight
	weight.Weight = genruntime.ClonePointerToInt(source.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		weight.PropertyBag = propertyBag
	} else {
		weight.PropertyBag = nil
	}

	// Invoke the augmentConversionForTrafficWeight interface (if implemented) to customize the conversion
	var weightAsAny any = weight
	if augmentedWeight, ok := weightAsAny.(augmentConversionForTrafficWeight); ok {
		err := augmentedWeight.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficWeight populates the provided destination TrafficWeight from our TrafficWeight
func (weight *TrafficWeight) AssignProperties_To_TrafficWeight(destination *storage.TrafficWeight) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(weight.PropertyBag)

	// Label
	destination.Label = genruntime.ClonePointerToString(weight.Label)

	// LatestRevision
	if weight.LatestRevision != nil {
		latestRevision := *weight.LatestRevision
		destination.LatestRevision = &latestRevision
	} else {
		destination.LatestRevision = nil
	}

	// RevisionName
	destination.RevisionName = genruntime.ClonePointerToString(weight.RevisionName)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(weight.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTrafficWeight interface (if implemented) to customize the conversion
	var weightAsAny any = weight
	if augmentedWeight, ok := weightAsAny.(augmentConversionForTrafficWeight); ok {
		err := augmentedWeight.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.TrafficWeight_STATUS
// Traffic weight assigned to a revision
type TrafficWeight_STATUS struct {
	Label          *string                `json:"label,omitempty"`
	LatestRevision *bool                  `json:"latestRevision,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RevisionName   *string                `json:"revisionName,omitempty"`
	Weight         *int                   `json:"weight,omitempty"`
}

// AssignProperties_From_TrafficWeight_STATUS populates our TrafficWeight_STATUS from the provided source TrafficWeight_STATUS
func (weight *TrafficWeight_STATUS) AssignProperties_From_TrafficWeight_STATUS(source *storage.TrafficWeight_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Label
	weight.Label = genruntime.ClonePointerToString(source.Label)

	// LatestRevision
	if source.LatestRevision != nil {
		latestRevision := *source.LatestRevision
		weight.LatestRevision = &latestRevision
	} else {
		weight.LatestRevision = nil
	}

	// RevisionName
	weight.RevisionName = genruntime.ClonePointerToString(source.RevisionName)

	// Weight
	weight.Weight = genruntime.ClonePointerToInt(source.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		weight.PropertyBag = propertyBag
	} else {
		weight.PropertyBag = nil
	}

	// Invoke the augmentConversionForTrafficWeight_STATUS interface (if implemented) to customize the conversion
	var weightAsAny any = weight
	if augmentedWeight, ok := weightAsAny.(augmentConversionForTrafficWeight_STATUS); ok {
		err := augmentedWeight.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficWeight_STATUS populates the provided destination TrafficWeight_STATUS from our TrafficWeight_STATUS
func (weight *TrafficWeight_STATUS) AssignProperties_To_TrafficWeight_STATUS(destination *storage.TrafficWeight_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(weight.PropertyBag)

	// Label
	destination.Label = genruntime.ClonePointerToString(weight.Label)

	// LatestRevision
	if weight.LatestRevision != nil {
		latestRevision := *weight.LatestRevision
		destination.LatestRevision = &latestRevision
	} else {
		destination.LatestRevision = nil
	}

	// RevisionName
	destination.RevisionName = genruntime.ClonePointerToString(weight.RevisionName)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(weight.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTrafficWeight_STATUS interface (if implemented) to customize the conversion
	var weightAsAny any = weight
	if augmentedWeight, ok := weightAsAny.(augmentConversionForTrafficWeight_STATUS); ok {
		err := augmentedWeight.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.VolumeMount
// Volume mount for the Container App.
type VolumeMount struct {
	MountPath   *string                `json:"mountPath,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SubPath     *string                `json:"subPath,omitempty"`
	VolumeName  *string                `json:"volumeName,omitempty"`
}

// AssignProperties_From_VolumeMount populates our VolumeMount from the provided source VolumeMount
func (mount *VolumeMount) AssignProperties_From_VolumeMount(source *storage.VolumeMount) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// SubPath
	mount.SubPath = genruntime.ClonePointerToString(source.SubPath)

	// VolumeName
	mount.VolumeName = genruntime.ClonePointerToString(source.VolumeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		mount.PropertyBag = propertyBag
	} else {
		mount.PropertyBag = nil
	}

	// Invoke the augmentConversionForVolumeMount interface (if implemented) to customize the conversion
	var mountAsAny any = mount
	if augmentedMount, ok := mountAsAny.(augmentConversionForVolumeMount); ok {
		err := augmentedMount.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeMount populates the provided destination VolumeMount from our VolumeMount
func (mount *VolumeMount) AssignProperties_To_VolumeMount(destination *storage.VolumeMount) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(mount.PropertyBag)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// SubPath
	destination.SubPath = genruntime.ClonePointerToString(mount.SubPath)

	// VolumeName
	destination.VolumeName = genruntime.ClonePointerToString(mount.VolumeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVolumeMount interface (if implemented) to customize the conversion
	var mountAsAny any = mount
	if augmentedMount, ok := mountAsAny.(augmentConversionForVolumeMount); ok {
		err := augmentedMount.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.VolumeMount_STATUS
// Volume mount for the Container App.
type VolumeMount_STATUS struct {
	MountPath   *string                `json:"mountPath,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SubPath     *string                `json:"subPath,omitempty"`
	VolumeName  *string                `json:"volumeName,omitempty"`
}

// AssignProperties_From_VolumeMount_STATUS populates our VolumeMount_STATUS from the provided source VolumeMount_STATUS
func (mount *VolumeMount_STATUS) AssignProperties_From_VolumeMount_STATUS(source *storage.VolumeMount_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// SubPath
	mount.SubPath = genruntime.ClonePointerToString(source.SubPath)

	// VolumeName
	mount.VolumeName = genruntime.ClonePointerToString(source.VolumeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		mount.PropertyBag = propertyBag
	} else {
		mount.PropertyBag = nil
	}

	// Invoke the augmentConversionForVolumeMount_STATUS interface (if implemented) to customize the conversion
	var mountAsAny any = mount
	if augmentedMount, ok := mountAsAny.(augmentConversionForVolumeMount_STATUS); ok {
		err := augmentedMount.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeMount_STATUS populates the provided destination VolumeMount_STATUS from our VolumeMount_STATUS
func (mount *VolumeMount_STATUS) AssignProperties_To_VolumeMount_STATUS(destination *storage.VolumeMount_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(mount.PropertyBag)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// SubPath
	destination.SubPath = genruntime.ClonePointerToString(mount.SubPath)

	// VolumeName
	destination.VolumeName = genruntime.ClonePointerToString(mount.VolumeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVolumeMount_STATUS interface (if implemented) to customize the conversion
	var mountAsAny any = mount
	if augmentedMount, ok := mountAsAny.(augmentConversionForVolumeMount_STATUS); ok {
		err := augmentedMount.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForContainerAppProbe interface {
	AssignPropertiesFrom(src *storage.ContainerAppProbe) error
	AssignPropertiesTo(dst *storage.ContainerAppProbe) error
}

type augmentConversionForContainerAppProbe_STATUS interface {
	AssignPropertiesFrom(src *storage.ContainerAppProbe_STATUS) error
	AssignPropertiesTo(dst *storage.ContainerAppProbe_STATUS) error
}

type augmentConversionForContainerResources interface {
	AssignPropertiesFrom(src *storage.ContainerResources) error
	AssignPropertiesTo(dst *storage.ContainerResources) error
}

type augmentConversionForContainerResources_STATUS interface {
	AssignPropertiesFrom(src *storage.ContainerResources_STATUS) error
	AssignPropertiesTo(dst *storage.ContainerResources_STATUS) error
}

type augmentConversionForCorsPolicy interface {
	AssignPropertiesFrom(src *storage.CorsPolicy) error
	AssignPropertiesTo(dst *storage.CorsPolicy) error
}

type augmentConversionForCorsPolicy_STATUS interface {
	AssignPropertiesFrom(src *storage.CorsPolicy_STATUS) error
	AssignPropertiesTo(dst *storage.CorsPolicy_STATUS) error
}

type augmentConversionForCustomDomain interface {
	AssignPropertiesFrom(src *storage.CustomDomain) error
	AssignPropertiesTo(dst *storage.CustomDomain) error
}

type augmentConversionForCustomDomain_STATUS interface {
	AssignPropertiesFrom(src *storage.CustomDomain_STATUS) error
	AssignPropertiesTo(dst *storage.CustomDomain_STATUS) error
}

type augmentConversionForEnvironmentVar interface {
	AssignPropertiesFrom(src *storage.EnvironmentVar) error
	AssignPropertiesTo(dst *storage.EnvironmentVar) error
}

type augmentConversionForEnvironmentVar_STATUS interface {
	AssignPropertiesFrom(src *storage.EnvironmentVar_STATUS) error
	AssignPropertiesTo(dst *storage.EnvironmentVar_STATUS) error
}

type augmentConversionForIngress_StickySessions interface {
	AssignPropertiesFrom(src *storage.Ingress_StickySessions) error
	AssignPropertiesTo(dst *storage.Ingress_StickySessions) error
}

type augmentConversionForIngress_StickySessions_STATUS interface {
	AssignPropertiesFrom(src *storage.Ingress_StickySessions_STATUS) error
	AssignPropertiesTo(dst *storage.Ingress_StickySessions_STATUS) error
}

type augmentConversionForIngressPortMapping interface {
	AssignPropertiesFrom(src *storage.IngressPortMapping) error
	AssignPropertiesTo(dst *storage.IngressPortMapping) error
}

type augmentConversionForIngressPortMapping_STATUS interface {
	AssignPropertiesFrom(src *storage.IngressPortMapping_STATUS) error
	AssignPropertiesTo(dst *storage.IngressPortMapping_STATUS) error
}

type augmentConversionForIpSecurityRestrictionRule interface {
	AssignPropertiesFrom(src *storage.IpSecurityRestrictionRule) error
	AssignPropertiesTo(dst *storage.IpSecurityRestrictionRule) error
}

type augmentConversionForIpSecurityRestrictionRule_STATUS interface {
	AssignPropertiesFrom(src *storage.IpSecurityRestrictionRule_STATUS) error
	AssignPropertiesTo(dst *storage.IpSecurityRestrictionRule_STATUS) error
}

type augmentConversionForScaleRule interface {
	AssignPropertiesFrom(src *storage.ScaleRule) error
	AssignPropertiesTo(dst *storage.ScaleRule) error
}

type augmentConversionForScaleRule_STATUS interface {
	AssignPropertiesFrom(src *storage.ScaleRule_STATUS) error
	AssignPropertiesTo(dst *storage.ScaleRule_STATUS) error
}

type augmentConversionForSecretVolumeItem interface {
	AssignPropertiesFrom(src *storage.SecretVolumeItem) error
	AssignPropertiesTo(dst *storage.SecretVolumeItem) error
}

type augmentConversionForSecretVolumeItem_STATUS interface {
	AssignPropertiesFrom(src *storage.SecretVolumeItem_STATUS) error
	AssignPropertiesTo(dst *storage.SecretVolumeItem_STATUS) error
}

type augmentConversionForTrafficWeight interface {
	AssignPropertiesFrom(src *storage.TrafficWeight) error
	AssignPropertiesTo(dst *storage.TrafficWeight) error
}

type augmentConversionForTrafficWeight_STATUS interface {
	AssignPropertiesFrom(src *storage.TrafficWeight_STATUS) error
	AssignPropertiesTo(dst *storage.TrafficWeight_STATUS) error
}

type augmentConversionForVolumeMount interface {
	AssignPropertiesFrom(src *storage.VolumeMount) error
	AssignPropertiesTo(dst *storage.VolumeMount) error
}

type augmentConversionForVolumeMount_STATUS interface {
	AssignPropertiesFrom(src *storage.VolumeMount_STATUS) error
	AssignPropertiesTo(dst *storage.VolumeMount_STATUS) error
}

// Storage version of v1api20240301.ContainerAppProbe_HttpGet
type ContainerAppProbe_HttpGet struct {
	Host        *string                                 `json:"host,omitempty"`
	HttpHeaders []ContainerAppProbe_HttpGet_HttpHeaders `json:"httpHeaders,omitempty"`
	Path        *string                                 `json:"path,omitempty"`
	Port        *int                                    `json:"port,omitempty"`
	PropertyBag genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
	Scheme      *string                                 `json:"scheme,omitempty"`
}

// AssignProperties_From_ContainerAppProbe_HttpGet populates our ContainerAppProbe_HttpGet from the provided source ContainerAppProbe_HttpGet
func (httpGet *ContainerAppProbe_HttpGet) AssignProperties_From_ContainerAppProbe_HttpGet(source *storage.ContainerAppProbe_HttpGet) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Host
	httpGet.Host = genruntime.ClonePointerToString(source.Host)

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]ContainerAppProbe_HttpGet_HttpHeaders, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader ContainerAppProbe_HttpGet_HttpHeaders
			err := httpHeader.AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders(&httpHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	httpGet.Scheme = genruntime.ClonePointerToString(source.Scheme)

	// Update the property bag
	if len(propertyBag) > 0 {
		httpGet.PropertyBag = propertyBag
	} else {
		httpGet.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_HttpGet interface (if implemented) to customize the conversion
	var httpGetAsAny any = httpGet
	if augmentedHttpGet, ok := httpGetAsAny.(augmentConversionForContainerAppProbe_HttpGet); ok {
		err := augmentedHttpGet.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_HttpGet populates the provided destination ContainerAppProbe_HttpGet from our ContainerAppProbe_HttpGet
func (httpGet *ContainerAppProbe_HttpGet) AssignProperties_To_ContainerAppProbe_HttpGet(destination *storage.ContainerAppProbe_HttpGet) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(httpGet.PropertyBag)

	// Host
	destination.Host = genruntime.ClonePointerToString(httpGet.Host)

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]storage.ContainerAppProbe_HttpGet_HttpHeaders, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader storage.ContainerAppProbe_HttpGet_HttpHeaders
			err := httpHeaderItem.AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders(&httpHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	destination.Scheme = genruntime.ClonePointerToString(httpGet.Scheme)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_HttpGet interface (if implemented) to customize the conversion
	var httpGetAsAny any = httpGet
	if augmentedHttpGet, ok := httpGetAsAny.(augmentConversionForContainerAppProbe_HttpGet); ok {
		err := augmentedHttpGet.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerAppProbe_HttpGet_STATUS
type ContainerAppProbe_HttpGet_STATUS struct {
	Host        *string                                        `json:"host,omitempty"`
	HttpHeaders []ContainerAppProbe_HttpGet_HttpHeaders_STATUS `json:"httpHeaders,omitempty"`
	Path        *string                                        `json:"path,omitempty"`
	Port        *int                                           `json:"port,omitempty"`
	PropertyBag genruntime.PropertyBag                         `json:"$propertyBag,omitempty"`
	Scheme      *string                                        `json:"scheme,omitempty"`
}

// AssignProperties_From_ContainerAppProbe_HttpGet_STATUS populates our ContainerAppProbe_HttpGet_STATUS from the provided source ContainerAppProbe_HttpGet_STATUS
func (httpGet *ContainerAppProbe_HttpGet_STATUS) AssignProperties_From_ContainerAppProbe_HttpGet_STATUS(source *storage.ContainerAppProbe_HttpGet_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Host
	httpGet.Host = genruntime.ClonePointerToString(source.Host)

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]ContainerAppProbe_HttpGet_HttpHeaders_STATUS, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader ContainerAppProbe_HttpGet_HttpHeaders_STATUS
			err := httpHeader.AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(&httpHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	httpGet.Scheme = genruntime.ClonePointerToString(source.Scheme)

	// Update the property bag
	if len(propertyBag) > 0 {
		httpGet.PropertyBag = propertyBag
	} else {
		httpGet.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_HttpGet_STATUS interface (if implemented) to customize the conversion
	var httpGetAsAny any = httpGet
	if augmentedHttpGet, ok := httpGetAsAny.(augmentConversionForContainerAppProbe_HttpGet_STATUS); ok {
		err := augmentedHttpGet.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_HttpGet_STATUS populates the provided destination ContainerAppProbe_HttpGet_STATUS from our ContainerAppProbe_HttpGet_STATUS
func (httpGet *ContainerAppProbe_HttpGet_STATUS) AssignProperties_To_ContainerAppProbe_HttpGet_STATUS(destination *storage.ContainerAppProbe_HttpGet_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(httpGet.PropertyBag)

	// Host
	destination.Host = genruntime.ClonePointerToString(httpGet.Host)

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS
			err := httpHeaderItem.AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(&httpHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	destination.Scheme = genruntime.ClonePointerToString(httpGet.Scheme)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_HttpGet_STATUS interface (if implemented) to customize the conversion
	var httpGetAsAny any = httpGet
	if augmentedHttpGet, ok := httpGetAsAny.(augmentConversionForContainerAppProbe_HttpGet_STATUS); ok {
		err := augmentedHttpGet.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerAppProbe_TcpSocket
type ContainerAppProbe_TcpSocket struct {
	Host        *string                `json:"host,omitempty"`
	Port        *int                   `json:"port,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ContainerAppProbe_TcpSocket populates our ContainerAppProbe_TcpSocket from the provided source ContainerAppProbe_TcpSocket
func (socket *ContainerAppProbe_TcpSocket) AssignProperties_From_ContainerAppProbe_TcpSocket(source *storage.ContainerAppProbe_TcpSocket) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Host
	socket.Host = genruntime.ClonePointerToString(source.Host)

	// Port
	socket.Port = genruntime.ClonePointerToInt(source.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		socket.PropertyBag = propertyBag
	} else {
		socket.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_TcpSocket interface (if implemented) to customize the conversion
	var socketAsAny any = socket
	if augmentedSocket, ok := socketAsAny.(augmentConversionForContainerAppProbe_TcpSocket); ok {
		err := augmentedSocket.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_TcpSocket populates the provided destination ContainerAppProbe_TcpSocket from our ContainerAppProbe_TcpSocket
func (socket *ContainerAppProbe_TcpSocket) AssignProperties_To_ContainerAppProbe_TcpSocket(destination *storage.ContainerAppProbe_TcpSocket) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(socket.PropertyBag)

	// Host
	destination.Host = genruntime.ClonePointerToString(socket.Host)

	// Port
	destination.Port = genruntime.ClonePointerToInt(socket.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_TcpSocket interface (if implemented) to customize the conversion
	var socketAsAny any = socket
	if augmentedSocket, ok := socketAsAny.(augmentConversionForContainerAppProbe_TcpSocket); ok {
		err := augmentedSocket.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerAppProbe_TcpSocket_STATUS
type ContainerAppProbe_TcpSocket_STATUS struct {
	Host        *string                `json:"host,omitempty"`
	Port        *int                   `json:"port,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS populates our ContainerAppProbe_TcpSocket_STATUS from the provided source ContainerAppProbe_TcpSocket_STATUS
func (socket *ContainerAppProbe_TcpSocket_STATUS) AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS(source *storage.ContainerAppProbe_TcpSocket_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Host
	socket.Host = genruntime.ClonePointerToString(source.Host)

	// Port
	socket.Port = genruntime.ClonePointerToInt(source.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		socket.PropertyBag = propertyBag
	} else {
		socket.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_TcpSocket_STATUS interface (if implemented) to customize the conversion
	var socketAsAny any = socket
	if augmentedSocket, ok := socketAsAny.(augmentConversionForContainerAppProbe_TcpSocket_STATUS); ok {
		err := augmentedSocket.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS populates the provided destination ContainerAppProbe_TcpSocket_STATUS from our ContainerAppProbe_TcpSocket_STATUS
func (socket *ContainerAppProbe_TcpSocket_STATUS) AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS(destination *storage.ContainerAppProbe_TcpSocket_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(socket.PropertyBag)

	// Host
	destination.Host = genruntime.ClonePointerToString(socket.Host)

	// Port
	destination.Port = genruntime.ClonePointerToInt(socket.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_TcpSocket_STATUS interface (if implemented) to customize the conversion
	var socketAsAny any = socket
	if augmentedSocket, ok := socketAsAny.(augmentConversionForContainerAppProbe_TcpSocket_STATUS); ok {
		err := augmentedSocket.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CustomScaleRule
// Container App container Custom scaling rule.
type CustomScaleRule struct {
	Auth        []ScaleRuleAuth        `json:"auth,omitempty"`
	Metadata    map[string]string      `json:"metadata,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_CustomScaleRule populates our CustomScaleRule from the provided source CustomScaleRule
func (rule *CustomScaleRule) AssignProperties_From_CustomScaleRule(source *storage.CustomScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// IdentityReference
	if source.IdentityReference != nil {
		propertyBag.Add("IdentityReference", *source.IdentityReference)
	} else {
		propertyBag.Remove("IdentityReference")
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForCustomScaleRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CustomScaleRule populates the provided destination CustomScaleRule from our CustomScaleRule
func (rule *CustomScaleRule) AssignProperties_To_CustomScaleRule(destination *storage.CustomScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// IdentityReference
	if propertyBag.Contains("IdentityReference") {
		var identityReference genruntime.WellknownResourceReference
		err := propertyBag.Pull("IdentityReference", &identityReference)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentityReference' from propertyBag")
		}

		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForCustomScaleRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.CustomScaleRule_STATUS
// Container App container Custom scaling rule.
type CustomScaleRule_STATUS struct {
	Auth        []ScaleRuleAuth_STATUS `json:"auth,omitempty"`
	Metadata    map[string]string      `json:"metadata,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_CustomScaleRule_STATUS populates our CustomScaleRule_STATUS from the provided source CustomScaleRule_STATUS
func (rule *CustomScaleRule_STATUS) AssignProperties_From_CustomScaleRule_STATUS(source *storage.CustomScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Identity
	if source.Identity != nil {
		propertyBag.Add("Identity", *source.Identity)
	} else {
		propertyBag.Remove("Identity")
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForCustomScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CustomScaleRule_STATUS populates the provided destination CustomScaleRule_STATUS from our CustomScaleRule_STATUS
func (rule *CustomScaleRule_STATUS) AssignProperties_To_CustomScaleRule_STATUS(destination *storage.CustomScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Identity
	if propertyBag.Contains("Identity") {
		var identity string
		err := propertyBag.Pull("Identity", &identity)
		if err != nil {
			return eris.Wrap(err, "pulling 'Identity' from propertyBag")
		}

		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCustomScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForCustomScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.HttpScaleRule
// Container App container Http scaling rule.
type HttpScaleRule struct {
	Auth        []ScaleRuleAuth        `json:"auth,omitempty"`
	Metadata    map[string]string      `json:"metadata,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HttpScaleRule populates our HttpScaleRule from the provided source HttpScaleRule
func (rule *HttpScaleRule) AssignProperties_From_HttpScaleRule(source *storage.HttpScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// IdentityReference
	if source.IdentityReference != nil {
		propertyBag.Add("IdentityReference", *source.IdentityReference)
	} else {
		propertyBag.Remove("IdentityReference")
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForHttpScaleRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpScaleRule populates the provided destination HttpScaleRule from our HttpScaleRule
func (rule *HttpScaleRule) AssignProperties_To_HttpScaleRule(destination *storage.HttpScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// IdentityReference
	if propertyBag.Contains("IdentityReference") {
		var identityReference genruntime.WellknownResourceReference
		err := propertyBag.Pull("IdentityReference", &identityReference)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentityReference' from propertyBag")
		}

		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForHttpScaleRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.HttpScaleRule_STATUS
// Container App container Http scaling rule.
type HttpScaleRule_STATUS struct {
	Auth        []ScaleRuleAuth_STATUS `json:"auth,omitempty"`
	Metadata    map[string]string      `json:"metadata,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HttpScaleRule_STATUS populates our HttpScaleRule_STATUS from the provided source HttpScaleRule_STATUS
func (rule *HttpScaleRule_STATUS) AssignProperties_From_HttpScaleRule_STATUS(source *storage.HttpScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Identity
	if source.Identity != nil {
		propertyBag.Add("Identity", *source.Identity)
	} else {
		propertyBag.Remove("Identity")
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForHttpScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpScaleRule_STATUS populates the provided destination HttpScaleRule_STATUS from our HttpScaleRule_STATUS
func (rule *HttpScaleRule_STATUS) AssignProperties_To_HttpScaleRule_STATUS(destination *storage.HttpScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Identity
	if propertyBag.Contains("Identity") {
		var identity string
		err := propertyBag.Pull("Identity", &identity)
		if err != nil {
			return eris.Wrap(err, "pulling 'Identity' from propertyBag")
		}

		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForHttpScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.QueueScaleRule
// Container App container Azure Queue based scaling rule.
type QueueScaleRule struct {
	Auth        []ScaleRuleAuth        `json:"auth,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueueLength *int                   `json:"queueLength,omitempty"`
	QueueName   *string                `json:"queueName,omitempty"`
}

// AssignProperties_From_QueueScaleRule populates our QueueScaleRule from the provided source QueueScaleRule
func (rule *QueueScaleRule) AssignProperties_From_QueueScaleRule(source *storage.QueueScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AccountName
	if source.AccountName != nil {
		propertyBag.Add("AccountName", *source.AccountName)
	} else {
		propertyBag.Remove("AccountName")
	}

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// IdentityReference
	if source.IdentityReference != nil {
		propertyBag.Add("IdentityReference", *source.IdentityReference)
	} else {
		propertyBag.Remove("IdentityReference")
	}

	// QueueLength
	rule.QueueLength = genruntime.ClonePointerToInt(source.QueueLength)

	// QueueName
	rule.QueueName = genruntime.ClonePointerToString(source.QueueName)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueueScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForQueueScaleRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_QueueScaleRule populates the provided destination QueueScaleRule from our QueueScaleRule
func (rule *QueueScaleRule) AssignProperties_To_QueueScaleRule(destination *storage.QueueScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// AccountName
	if propertyBag.Contains("AccountName") {
		var accountName string
		err := propertyBag.Pull("AccountName", &accountName)
		if err != nil {
			return eris.Wrap(err, "pulling 'AccountName' from propertyBag")
		}

		destination.AccountName = &accountName
	} else {
		destination.AccountName = nil
	}

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// IdentityReference
	if propertyBag.Contains("IdentityReference") {
		var identityReference genruntime.WellknownResourceReference
		err := propertyBag.Pull("IdentityReference", &identityReference)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentityReference' from propertyBag")
		}

		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// QueueLength
	destination.QueueLength = genruntime.ClonePointerToInt(rule.QueueLength)

	// QueueName
	destination.QueueName = genruntime.ClonePointerToString(rule.QueueName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueueScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForQueueScaleRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.QueueScaleRule_STATUS
// Container App container Azure Queue based scaling rule.
type QueueScaleRule_STATUS struct {
	Auth        []ScaleRuleAuth_STATUS `json:"auth,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueueLength *int                   `json:"queueLength,omitempty"`
	QueueName   *string                `json:"queueName,omitempty"`
}

// AssignProperties_From_QueueScaleRule_STATUS populates our QueueScaleRule_STATUS from the provided source QueueScaleRule_STATUS
func (rule *QueueScaleRule_STATUS) AssignProperties_From_QueueScaleRule_STATUS(source *storage.QueueScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AccountName
	if source.AccountName != nil {
		propertyBag.Add("AccountName", *source.AccountName)
	} else {
		propertyBag.Remove("AccountName")
	}

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Identity
	if source.Identity != nil {
		propertyBag.Add("Identity", *source.Identity)
	} else {
		propertyBag.Remove("Identity")
	}

	// QueueLength
	rule.QueueLength = genruntime.ClonePointerToInt(source.QueueLength)

	// QueueName
	rule.QueueName = genruntime.ClonePointerToString(source.QueueName)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueueScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForQueueScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_QueueScaleRule_STATUS populates the provided destination QueueScaleRule_STATUS from our QueueScaleRule_STATUS
func (rule *QueueScaleRule_STATUS) AssignProperties_To_QueueScaleRule_STATUS(destination *storage.QueueScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// AccountName
	if propertyBag.Contains("AccountName") {
		var accountName string
		err := propertyBag.Pull("AccountName", &accountName)
		if err != nil {
			return eris.Wrap(err, "pulling 'AccountName' from propertyBag")
		}

		destination.AccountName = &accountName
	} else {
		destination.AccountName = nil
	}

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Identity
	if propertyBag.Contains("Identity") {
		var identity string
		err := propertyBag.Pull("Identity", &identity)
		if err != nil {
			return eris.Wrap(err, "pulling 'Identity' from propertyBag")
		}

		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// QueueLength
	destination.QueueLength = genruntime.ClonePointerToInt(rule.QueueLength)

	// QueueName
	destination.QueueName = genruntime.ClonePointerToString(rule.QueueName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueueScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForQueueScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.TcpScaleRule
// Container App container Tcp scaling rule.
type TcpScaleRule struct {
	Auth        []ScaleRuleAuth        `json:"auth,omitempty"`
	Metadata    map[string]string      `json:"metadata,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_TcpScaleRule populates our TcpScaleRule from the provided source TcpScaleRule
func (rule *TcpScaleRule) AssignProperties_From_TcpScaleRule(source *storage.TcpScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// IdentityReference
	if source.IdentityReference != nil {
		propertyBag.Add("IdentityReference", *source.IdentityReference)
	} else {
		propertyBag.Remove("IdentityReference")
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForTcpScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForTcpScaleRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TcpScaleRule populates the provided destination TcpScaleRule from our TcpScaleRule
func (rule *TcpScaleRule) AssignProperties_To_TcpScaleRule(destination *storage.TcpScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// IdentityReference
	if propertyBag.Contains("IdentityReference") {
		var identityReference genruntime.WellknownResourceReference
		err := propertyBag.Pull("IdentityReference", &identityReference)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentityReference' from propertyBag")
		}

		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTcpScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForTcpScaleRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.TcpScaleRule_STATUS
// Container App container Tcp scaling rule.
type TcpScaleRule_STATUS struct {
	Auth        []ScaleRuleAuth_STATUS `json:"auth,omitempty"`
	Metadata    map[string]string      `json:"metadata,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_TcpScaleRule_STATUS populates our TcpScaleRule_STATUS from the provided source TcpScaleRule_STATUS
func (rule *TcpScaleRule_STATUS) AssignProperties_From_TcpScaleRule_STATUS(source *storage.TcpScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Identity
	if source.Identity != nil {
		propertyBag.Add("Identity", *source.Identity)
	} else {
		propertyBag.Remove("Identity")
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForTcpScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForTcpScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TcpScaleRule_STATUS populates the provided destination TcpScaleRule_STATUS from our TcpScaleRule_STATUS
func (rule *TcpScaleRule_STATUS) AssignProperties_To_TcpScaleRule_STATUS(destination *storage.TcpScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Identity
	if propertyBag.Contains("Identity") {
		var identity string
		err := propertyBag.Pull("Identity", &identity)
		if err != nil {
			return eris.Wrap(err, "pulling 'Identity' from propertyBag")
		}

		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTcpScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForTcpScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForContainerAppProbe_HttpGet interface {
	AssignPropertiesFrom(src *storage.ContainerAppProbe_HttpGet) error
	AssignPropertiesTo(dst *storage.ContainerAppProbe_HttpGet) error
}

type augmentConversionForContainerAppProbe_HttpGet_STATUS interface {
	AssignPropertiesFrom(src *storage.ContainerAppProbe_HttpGet_STATUS) error
	AssignPropertiesTo(dst *storage.ContainerAppProbe_HttpGet_STATUS) error
}

type augmentConversionForContainerAppProbe_TcpSocket interface {
	AssignPropertiesFrom(src *storage.ContainerAppProbe_TcpSocket) error
	AssignPropertiesTo(dst *storage.ContainerAppProbe_TcpSocket) error
}

type augmentConversionForContainerAppProbe_TcpSocket_STATUS interface {
	AssignPropertiesFrom(src *storage.ContainerAppProbe_TcpSocket_STATUS) error
	AssignPropertiesTo(dst *storage.ContainerAppProbe_TcpSocket_STATUS) error
}

type augmentConversionForCustomScaleRule interface {
	AssignPropertiesFrom(src *storage.CustomScaleRule) error
	AssignPropertiesTo(dst *storage.CustomScaleRule) error
}

type augmentConversionForCustomScaleRule_STATUS interface {
	AssignPropertiesFrom(src *storage.CustomScaleRule_STATUS) error
	AssignPropertiesTo(dst *storage.CustomScaleRule_STATUS) error
}

type augmentConversionForHttpScaleRule interface {
	AssignPropertiesFrom(src *storage.HttpScaleRule) error
	AssignPropertiesTo(dst *storage.HttpScaleRule) error
}

type augmentConversionForHttpScaleRule_STATUS interface {
	AssignPropertiesFrom(src *storage.HttpScaleRule_STATUS) error
	AssignPropertiesTo(dst *storage.HttpScaleRule_STATUS) error
}

type augmentConversionForQueueScaleRule interface {
	AssignPropertiesFrom(src *storage.QueueScaleRule) error
	AssignPropertiesTo(dst *storage.QueueScaleRule) error
}

type augmentConversionForQueueScaleRule_STATUS interface {
	AssignPropertiesFrom(src *storage.QueueScaleRule_STATUS) error
	AssignPropertiesTo(dst *storage.QueueScaleRule_STATUS) error
}

type augmentConversionForTcpScaleRule interface {
	AssignPropertiesFrom(src *storage.TcpScaleRule) error
	AssignPropertiesTo(dst *storage.TcpScaleRule) error
}

type augmentConversionForTcpScaleRule_STATUS interface {
	AssignPropertiesFrom(src *storage.TcpScaleRule_STATUS) error
	AssignPropertiesTo(dst *storage.TcpScaleRule_STATUS) error
}

// Storage version of v1api20240301.ContainerAppProbe_HttpGet_HttpHeaders
type ContainerAppProbe_HttpGet_HttpHeaders struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Value       *string                `json:"value,omitempty"`
}

// AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders populates our ContainerAppProbe_HttpGet_HttpHeaders from the provided source ContainerAppProbe_HttpGet_HttpHeaders
func (headers *ContainerAppProbe_HttpGet_HttpHeaders) AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders(source *storage.ContainerAppProbe_HttpGet_HttpHeaders) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		headers.PropertyBag = propertyBag
	} else {
		headers.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_HttpGet_HttpHeaders interface (if implemented) to customize the conversion
	var headersAsAny any = headers
	if augmentedHeaders, ok := headersAsAny.(augmentConversionForContainerAppProbe_HttpGet_HttpHeaders); ok {
		err := augmentedHeaders.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders populates the provided destination ContainerAppProbe_HttpGet_HttpHeaders from our ContainerAppProbe_HttpGet_HttpHeaders
func (headers *ContainerAppProbe_HttpGet_HttpHeaders) AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders(destination *storage.ContainerAppProbe_HttpGet_HttpHeaders) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(headers.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_HttpGet_HttpHeaders interface (if implemented) to customize the conversion
	var headersAsAny any = headers
	if augmentedHeaders, ok := headersAsAny.(augmentConversionForContainerAppProbe_HttpGet_HttpHeaders); ok {
		err := augmentedHeaders.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ContainerAppProbe_HttpGet_HttpHeaders_STATUS
type ContainerAppProbe_HttpGet_HttpHeaders_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Value       *string                `json:"value,omitempty"`
}

// AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS populates our ContainerAppProbe_HttpGet_HttpHeaders_STATUS from the provided source ContainerAppProbe_HttpGet_HttpHeaders_STATUS
func (headers *ContainerAppProbe_HttpGet_HttpHeaders_STATUS) AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(source *storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		headers.PropertyBag = propertyBag
	} else {
		headers.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_HttpGet_HttpHeaders_STATUS interface (if implemented) to customize the conversion
	var headersAsAny any = headers
	if augmentedHeaders, ok := headersAsAny.(augmentConversionForContainerAppProbe_HttpGet_HttpHeaders_STATUS); ok {
		err := augmentedHeaders.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS populates the provided destination ContainerAppProbe_HttpGet_HttpHeaders_STATUS from our ContainerAppProbe_HttpGet_HttpHeaders_STATUS
func (headers *ContainerAppProbe_HttpGet_HttpHeaders_STATUS) AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(destination *storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(headers.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForContainerAppProbe_HttpGet_HttpHeaders_STATUS interface (if implemented) to customize the conversion
	var headersAsAny any = headers
	if augmentedHeaders, ok := headersAsAny.(augmentConversionForContainerAppProbe_HttpGet_HttpHeaders_STATUS); ok {
		err := augmentedHeaders.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ScaleRuleAuth
// Auth Secrets for Scale Rule
type ScaleRuleAuth struct {
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretRef        *string                `json:"secretRef,omitempty"`
	TriggerParameter *string                `json:"triggerParameter,omitempty"`
}

// AssignProperties_From_ScaleRuleAuth populates our ScaleRuleAuth from the provided source ScaleRuleAuth
func (auth *ScaleRuleAuth) AssignProperties_From_ScaleRuleAuth(source *storage.ScaleRuleAuth) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretRef
	auth.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// TriggerParameter
	auth.TriggerParameter = genruntime.ClonePointerToString(source.TriggerParameter)

	// Update the property bag
	if len(propertyBag) > 0 {
		auth.PropertyBag = propertyBag
	} else {
		auth.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleRuleAuth interface (if implemented) to customize the conversion
	var authAsAny any = auth
	if augmentedAuth, ok := authAsAny.(augmentConversionForScaleRuleAuth); ok {
		err := augmentedAuth.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleRuleAuth populates the provided destination ScaleRuleAuth from our ScaleRuleAuth
func (auth *ScaleRuleAuth) AssignProperties_To_ScaleRuleAuth(destination *storage.ScaleRuleAuth) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(auth.PropertyBag)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(auth.SecretRef)

	// TriggerParameter
	destination.TriggerParameter = genruntime.ClonePointerToString(auth.TriggerParameter)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleRuleAuth interface (if implemented) to customize the conversion
	var authAsAny any = auth
	if augmentedAuth, ok := authAsAny.(augmentConversionForScaleRuleAuth); ok {
		err := augmentedAuth.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.ScaleRuleAuth_STATUS
// Auth Secrets for Scale Rule
type ScaleRuleAuth_STATUS struct {
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretRef        *string                `json:"secretRef,omitempty"`
	TriggerParameter *string                `json:"triggerParameter,omitempty"`
}

// AssignProperties_From_ScaleRuleAuth_STATUS populates our ScaleRuleAuth_STATUS from the provided source ScaleRuleAuth_STATUS
func (auth *ScaleRuleAuth_STATUS) AssignProperties_From_ScaleRuleAuth_STATUS(source *storage.ScaleRuleAuth_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretRef
	auth.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// TriggerParameter
	auth.TriggerParameter = genruntime.ClonePointerToString(source.TriggerParameter)

	// Update the property bag
	if len(propertyBag) > 0 {
		auth.PropertyBag = propertyBag
	} else {
		auth.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleRuleAuth_STATUS interface (if implemented) to customize the conversion
	var authAsAny any = auth
	if augmentedAuth, ok := authAsAny.(augmentConversionForScaleRuleAuth_STATUS); ok {
		err := augmentedAuth.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleRuleAuth_STATUS populates the provided destination ScaleRuleAuth_STATUS from our ScaleRuleAuth_STATUS
func (auth *ScaleRuleAuth_STATUS) AssignProperties_To_ScaleRuleAuth_STATUS(destination *storage.ScaleRuleAuth_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(auth.PropertyBag)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(auth.SecretRef)

	// TriggerParameter
	destination.TriggerParameter = genruntime.ClonePointerToString(auth.TriggerParameter)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleRuleAuth_STATUS interface (if implemented) to customize the conversion
	var authAsAny any = auth
	if augmentedAuth, ok := authAsAny.(augmentConversionForScaleRuleAuth_STATUS); ok {
		err := augmentedAuth.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForContainerAppProbe_HttpGet_HttpHeaders interface {
	AssignPropertiesFrom(src *storage.ContainerAppProbe_HttpGet_HttpHeaders) error
	AssignPropertiesTo(dst *storage.ContainerAppProbe_HttpGet_HttpHeaders) error
}

type augmentConversionForContainerAppProbe_HttpGet_HttpHeaders_STATUS interface {
	AssignPropertiesFrom(src *storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS) error
	AssignPropertiesTo(dst *storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS) error
}

type augmentConversionForScaleRuleAuth interface {
	AssignPropertiesFrom(src *storage.ScaleRuleAuth) error
	AssignPropertiesTo(dst *storage.ScaleRuleAuth) error
}

type augmentConversionForScaleRuleAuth_STATUS interface {
	AssignPropertiesFrom(src *storage.ScaleRuleAuth_STATUS) error
	AssignPropertiesTo(dst *storage.ScaleRuleAuth_STATUS) error
}

func init() {
	SchemeBuilder.Register(&ContainerApp{}, &ContainerAppList{})
}
