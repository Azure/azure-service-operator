// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"fmt"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20250101/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,app}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20240301.Job
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/ContainerApps/stable/2024-03-01/Jobs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}
type Job struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Job_Spec   `json:"spec,omitempty"`
	Status            Job_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Job{}

// GetConditions returns the conditions of the resource
func (job *Job) GetConditions() conditions.Conditions {
	return job.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (job *Job) SetConditions(conditions conditions.Conditions) { job.Status.Conditions = conditions }

var _ conversion.Convertible = &Job{}

// ConvertFrom populates our Job from the provided hub Job
func (job *Job) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Job)
	if !ok {
		return fmt.Errorf("expected app/v1api20250101/storage/Job but received %T instead", hub)
	}

	return job.AssignProperties_From_Job(source)
}

// ConvertTo populates the provided hub Job from our Job
func (job *Job) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Job)
	if !ok {
		return fmt.Errorf("expected app/v1api20250101/storage/Job but received %T instead", hub)
	}

	return job.AssignProperties_To_Job(destination)
}

var _ configmaps.Exporter = &Job{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (job *Job) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if job.Spec.OperatorSpec == nil {
		return nil
	}
	return job.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Job{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (job *Job) SecretDestinationExpressions() []*core.DestinationExpression {
	if job.Spec.OperatorSpec == nil {
		return nil
	}
	return job.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &Job{}

// AzureName returns the Azure name of the resource
func (job *Job) AzureName() string {
	return job.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (job Job) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (job *Job) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (job *Job) GetSpec() genruntime.ConvertibleSpec {
	return &job.Spec
}

// GetStatus returns the status of this resource
func (job *Job) GetStatus() genruntime.ConvertibleStatus {
	return &job.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (job *Job) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.App/jobs"
func (job *Job) GetType() string {
	return "Microsoft.App/jobs"
}

// NewEmptyStatus returns a new empty (blank) status
func (job *Job) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Job_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (job *Job) Owner() *genruntime.ResourceReference {
	if job.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(job.Spec)
	return job.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (job *Job) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Job_STATUS); ok {
		job.Status = *st
		return nil
	}

	// Convert status to required version
	var st Job_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	job.Status = st
	return nil
}

// AssignProperties_From_Job populates our Job from the provided source Job
func (job *Job) AssignProperties_From_Job(source *storage.Job) error {

	// ObjectMeta
	job.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Job_Spec
	err := spec.AssignProperties_From_Job_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Job_Spec() to populate field Spec")
	}
	job.Spec = spec

	// Status
	var status Job_STATUS
	err = status.AssignProperties_From_Job_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Job_STATUS() to populate field Status")
	}
	job.Status = status

	// Invoke the augmentConversionForJob interface (if implemented) to customize the conversion
	var jobAsAny any = job
	if augmentedJob, ok := jobAsAny.(augmentConversionForJob); ok {
		err := augmentedJob.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Job populates the provided destination Job from our Job
func (job *Job) AssignProperties_To_Job(destination *storage.Job) error {

	// ObjectMeta
	destination.ObjectMeta = *job.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Job_Spec
	err := job.Spec.AssignProperties_To_Job_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Job_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Job_STATUS
	err = job.Status.AssignProperties_To_Job_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Job_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForJob interface (if implemented) to customize the conversion
	var jobAsAny any = job
	if augmentedJob, ok := jobAsAny.(augmentConversionForJob); ok {
		err := augmentedJob.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (job *Job) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: job.Spec.OriginalVersion,
		Kind:    "Job",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20240301.Job
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/ContainerApps/stable/2024-03-01/Jobs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}
type JobList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Job `json:"items"`
}

type augmentConversionForJob interface {
	AssignPropertiesFrom(src *storage.Job) error
	AssignPropertiesTo(dst *storage.Job) error
}

// Storage version of v1api20240301.Job_Spec
type Job_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName     string            `json:"azureName,omitempty"`
	Configuration *JobConfiguration `json:"configuration,omitempty"`

	// EnvironmentReference: Resource ID of environment.
	EnvironmentReference *genruntime.ResourceReference `armReference:"EnvironmentId" json:"environmentReference,omitempty"`
	Identity             *ManagedServiceIdentity       `json:"identity,omitempty"`
	Location             *string                       `json:"location,omitempty"`
	OperatorSpec         *JobOperatorSpec              `json:"operatorSpec,omitempty"`
	OriginalVersion      string                        `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner               *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	PropertyBag         genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Tags                map[string]string                  `json:"tags,omitempty"`
	Template            *JobTemplate                       `json:"template,omitempty"`
	WorkloadProfileName *string                            `json:"workloadProfileName,omitempty"`
}

var _ genruntime.ConvertibleSpec = &Job_Spec{}

// ConvertSpecFrom populates our Job_Spec from the provided source
func (job *Job_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Job_Spec)
	if ok {
		// Populate our instance from source
		return job.AssignProperties_From_Job_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Job_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = job.AssignProperties_From_Job_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Job_Spec
func (job *Job_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Job_Spec)
	if ok {
		// Populate destination from our instance
		return job.AssignProperties_To_Job_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Job_Spec{}
	err := job.AssignProperties_To_Job_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Job_Spec populates our Job_Spec from the provided source Job_Spec
func (job *Job_Spec) AssignProperties_From_Job_Spec(source *storage.Job_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	job.AzureName = source.AzureName

	// Configuration
	if source.Configuration != nil {
		var configuration JobConfiguration
		err := configuration.AssignProperties_From_JobConfiguration(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration() to populate field Configuration")
		}
		job.Configuration = &configuration
	} else {
		job.Configuration = nil
	}

	// EnvironmentReference
	if source.EnvironmentReference != nil {
		environmentReference := source.EnvironmentReference.Copy()
		job.EnvironmentReference = &environmentReference
	} else {
		job.EnvironmentReference = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		job.Identity = &identity
	} else {
		job.Identity = nil
	}

	// Location
	job.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec JobOperatorSpec
		err := operatorSpec.AssignProperties_From_JobOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobOperatorSpec() to populate field OperatorSpec")
		}
		job.OperatorSpec = &operatorSpec
	} else {
		job.OperatorSpec = nil
	}

	// OriginalVersion
	job.OriginalVersion = source.OriginalVersion

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		job.Owner = &owner
	} else {
		job.Owner = nil
	}

	// Tags
	job.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template JobTemplate
		err := template.AssignProperties_From_JobTemplate(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobTemplate() to populate field Template")
		}
		job.Template = &template
	} else {
		job.Template = nil
	}

	// WorkloadProfileName
	job.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		job.PropertyBag = propertyBag
	} else {
		job.PropertyBag = nil
	}

	// Invoke the augmentConversionForJob_Spec interface (if implemented) to customize the conversion
	var jobAsAny any = job
	if augmentedJob, ok := jobAsAny.(augmentConversionForJob_Spec); ok {
		err := augmentedJob.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Job_Spec populates the provided destination Job_Spec from our Job_Spec
func (job *Job_Spec) AssignProperties_To_Job_Spec(destination *storage.Job_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(job.PropertyBag)

	// AzureName
	destination.AzureName = job.AzureName

	// Configuration
	if job.Configuration != nil {
		var configuration storage.JobConfiguration
		err := job.Configuration.AssignProperties_To_JobConfiguration(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// EnvironmentReference
	if job.EnvironmentReference != nil {
		environmentReference := job.EnvironmentReference.Copy()
		destination.EnvironmentReference = &environmentReference
	} else {
		destination.EnvironmentReference = nil
	}

	// Identity
	if job.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := job.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(job.Location)

	// OperatorSpec
	if job.OperatorSpec != nil {
		var operatorSpec storage.JobOperatorSpec
		err := job.OperatorSpec.AssignProperties_To_JobOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = job.OriginalVersion

	// Owner
	if job.Owner != nil {
		owner := job.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(job.Tags)

	// Template
	if job.Template != nil {
		var template storage.JobTemplate
		err := job.Template.AssignProperties_To_JobTemplate(&template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobTemplate() to populate field Template")
		}
		destination.Template = &template
	} else {
		destination.Template = nil
	}

	// WorkloadProfileName
	destination.WorkloadProfileName = genruntime.ClonePointerToString(job.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJob_Spec interface (if implemented) to customize the conversion
	var jobAsAny any = job
	if augmentedJob, ok := jobAsAny.(augmentConversionForJob_Spec); ok {
		err := augmentedJob.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.Job_STATUS
// Container App Job
type Job_STATUS struct {
	Conditions          []conditions.Condition         `json:"conditions,omitempty"`
	Configuration       *JobConfiguration_STATUS       `json:"configuration,omitempty"`
	EnvironmentId       *string                        `json:"environmentId,omitempty"`
	EventStreamEndpoint *string                        `json:"eventStreamEndpoint,omitempty"`
	Id                  *string                        `json:"id,omitempty"`
	Identity            *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`
	Location            *string                        `json:"location,omitempty"`
	Name                *string                        `json:"name,omitempty"`
	OutboundIpAddresses []string                       `json:"outboundIpAddresses,omitempty"`
	PropertyBag         genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	ProvisioningState   *string                        `json:"provisioningState,omitempty"`
	SystemData          *SystemData_STATUS             `json:"systemData,omitempty"`
	Tags                map[string]string              `json:"tags,omitempty"`
	Template            *JobTemplate_STATUS            `json:"template,omitempty"`
	Type                *string                        `json:"type,omitempty"`
	WorkloadProfileName *string                        `json:"workloadProfileName,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Job_STATUS{}

// ConvertStatusFrom populates our Job_STATUS from the provided source
func (job *Job_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Job_STATUS)
	if ok {
		// Populate our instance from source
		return job.AssignProperties_From_Job_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Job_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = job.AssignProperties_From_Job_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Job_STATUS
func (job *Job_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Job_STATUS)
	if ok {
		// Populate destination from our instance
		return job.AssignProperties_To_Job_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Job_STATUS{}
	err := job.AssignProperties_To_Job_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_Job_STATUS populates our Job_STATUS from the provided source Job_STATUS
func (job *Job_STATUS) AssignProperties_From_Job_STATUS(source *storage.Job_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Conditions
	job.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Configuration
	if source.Configuration != nil {
		var configuration JobConfiguration_STATUS
		err := configuration.AssignProperties_From_JobConfiguration_STATUS(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_STATUS() to populate field Configuration")
		}
		job.Configuration = &configuration
	} else {
		job.Configuration = nil
	}

	// EnvironmentId
	job.EnvironmentId = genruntime.ClonePointerToString(source.EnvironmentId)

	// EventStreamEndpoint
	job.EventStreamEndpoint = genruntime.ClonePointerToString(source.EventStreamEndpoint)

	// Id
	job.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		job.Identity = &identity
	} else {
		job.Identity = nil
	}

	// Location
	job.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	job.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundIpAddresses
	job.OutboundIpAddresses = genruntime.CloneSliceOfString(source.OutboundIpAddresses)

	// ProvisioningState
	job.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		job.SystemData = &systemDatum
	} else {
		job.SystemData = nil
	}

	// Tags
	job.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template JobTemplate_STATUS
		err := template.AssignProperties_From_JobTemplate_STATUS(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobTemplate_STATUS() to populate field Template")
		}
		job.Template = &template
	} else {
		job.Template = nil
	}

	// Type
	job.Type = genruntime.ClonePointerToString(source.Type)

	// WorkloadProfileName
	job.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		job.PropertyBag = propertyBag
	} else {
		job.PropertyBag = nil
	}

	// Invoke the augmentConversionForJob_STATUS interface (if implemented) to customize the conversion
	var jobAsAny any = job
	if augmentedJob, ok := jobAsAny.(augmentConversionForJob_STATUS); ok {
		err := augmentedJob.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Job_STATUS populates the provided destination Job_STATUS from our Job_STATUS
func (job *Job_STATUS) AssignProperties_To_Job_STATUS(destination *storage.Job_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(job.PropertyBag)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(job.Conditions)

	// Configuration
	if job.Configuration != nil {
		var configuration storage.JobConfiguration_STATUS
		err := job.Configuration.AssignProperties_To_JobConfiguration_STATUS(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_STATUS() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// EnvironmentId
	destination.EnvironmentId = genruntime.ClonePointerToString(job.EnvironmentId)

	// EventStreamEndpoint
	destination.EventStreamEndpoint = genruntime.ClonePointerToString(job.EventStreamEndpoint)

	// Id
	destination.Id = genruntime.ClonePointerToString(job.Id)

	// Identity
	if job.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := job.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(job.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(job.Name)

	// OutboundIpAddresses
	destination.OutboundIpAddresses = genruntime.CloneSliceOfString(job.OutboundIpAddresses)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(job.ProvisioningState)

	// SystemData
	if job.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := job.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(job.Tags)

	// Template
	if job.Template != nil {
		var template storage.JobTemplate_STATUS
		err := job.Template.AssignProperties_To_JobTemplate_STATUS(&template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobTemplate_STATUS() to populate field Template")
		}
		destination.Template = &template
	} else {
		destination.Template = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(job.Type)

	// WorkloadProfileName
	destination.WorkloadProfileName = genruntime.ClonePointerToString(job.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJob_STATUS interface (if implemented) to customize the conversion
	var jobAsAny any = job
	if augmentedJob, ok := jobAsAny.(augmentConversionForJob_STATUS); ok {
		err := augmentedJob.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForJob_Spec interface {
	AssignPropertiesFrom(src *storage.Job_Spec) error
	AssignPropertiesTo(dst *storage.Job_Spec) error
}

type augmentConversionForJob_STATUS interface {
	AssignPropertiesFrom(src *storage.Job_STATUS) error
	AssignPropertiesTo(dst *storage.Job_STATUS) error
}

// Storage version of v1api20240301.JobConfiguration
// Non versioned Container Apps Job configuration properties
type JobConfiguration struct {
	EventTriggerConfig    *JobConfiguration_EventTriggerConfig    `json:"eventTriggerConfig,omitempty"`
	ManualTriggerConfig   *JobConfiguration_ManualTriggerConfig   `json:"manualTriggerConfig,omitempty"`
	PropertyBag           genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
	Registries            []RegistryCredentials                   `json:"registries,omitempty"`
	ReplicaRetryLimit     *int                                    `json:"replicaRetryLimit,omitempty"`
	ReplicaTimeout        *int                                    `json:"replicaTimeout,omitempty"`
	ScheduleTriggerConfig *JobConfiguration_ScheduleTriggerConfig `json:"scheduleTriggerConfig,omitempty"`
	Secrets               []Secret                                `json:"secrets,omitempty"`
	TriggerType           *string                                 `json:"triggerType,omitempty"`
}

// AssignProperties_From_JobConfiguration populates our JobConfiguration from the provided source JobConfiguration
func (configuration *JobConfiguration) AssignProperties_From_JobConfiguration(source *storage.JobConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventTriggerConfig
	if source.EventTriggerConfig != nil {
		var eventTriggerConfig JobConfiguration_EventTriggerConfig
		err := eventTriggerConfig.AssignProperties_From_JobConfiguration_EventTriggerConfig(source.EventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_EventTriggerConfig() to populate field EventTriggerConfig")
		}
		configuration.EventTriggerConfig = &eventTriggerConfig
	} else {
		configuration.EventTriggerConfig = nil
	}

	// IdentitySettings
	if len(source.IdentitySettings) > 0 {
		propertyBag.Add("IdentitySettings", source.IdentitySettings)
	} else {
		propertyBag.Remove("IdentitySettings")
	}

	// ManualTriggerConfig
	if source.ManualTriggerConfig != nil {
		var manualTriggerConfig JobConfiguration_ManualTriggerConfig
		err := manualTriggerConfig.AssignProperties_From_JobConfiguration_ManualTriggerConfig(source.ManualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_ManualTriggerConfig() to populate field ManualTriggerConfig")
		}
		configuration.ManualTriggerConfig = &manualTriggerConfig
	} else {
		configuration.ManualTriggerConfig = nil
	}

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials
			err := registry.AssignProperties_From_RegistryCredentials(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegistryCredentials() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// ReplicaRetryLimit
	configuration.ReplicaRetryLimit = genruntime.ClonePointerToInt(source.ReplicaRetryLimit)

	// ReplicaTimeout
	configuration.ReplicaTimeout = genruntime.ClonePointerToInt(source.ReplicaTimeout)

	// ScheduleTriggerConfig
	if source.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig JobConfiguration_ScheduleTriggerConfig
		err := scheduleTriggerConfig.AssignProperties_From_JobConfiguration_ScheduleTriggerConfig(source.ScheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_ScheduleTriggerConfig() to populate field ScheduleTriggerConfig")
		}
		configuration.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		configuration.ScheduleTriggerConfig = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret
			err := secret.AssignProperties_From_Secret(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Secret() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// TriggerType
	configuration.TriggerType = genruntime.ClonePointerToString(source.TriggerType)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForJobConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration populates the provided destination JobConfiguration from our JobConfiguration
func (configuration *JobConfiguration) AssignProperties_To_JobConfiguration(destination *storage.JobConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// EventTriggerConfig
	if configuration.EventTriggerConfig != nil {
		var eventTriggerConfig storage.JobConfiguration_EventTriggerConfig
		err := configuration.EventTriggerConfig.AssignProperties_To_JobConfiguration_EventTriggerConfig(&eventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_EventTriggerConfig() to populate field EventTriggerConfig")
		}
		destination.EventTriggerConfig = &eventTriggerConfig
	} else {
		destination.EventTriggerConfig = nil
	}

	// IdentitySettings
	if propertyBag.Contains("IdentitySettings") {
		var identitySetting []storage.IdentitySettings
		err := propertyBag.Pull("IdentitySettings", &identitySetting)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentitySettings' from propertyBag")
		}

		destination.IdentitySettings = identitySetting
	} else {
		destination.IdentitySettings = nil
	}

	// ManualTriggerConfig
	if configuration.ManualTriggerConfig != nil {
		var manualTriggerConfig storage.JobConfiguration_ManualTriggerConfig
		err := configuration.ManualTriggerConfig.AssignProperties_To_JobConfiguration_ManualTriggerConfig(&manualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_ManualTriggerConfig() to populate field ManualTriggerConfig")
		}
		destination.ManualTriggerConfig = &manualTriggerConfig
	} else {
		destination.ManualTriggerConfig = nil
	}

	// Registries
	if configuration.Registries != nil {
		registryList := make([]storage.RegistryCredentials, len(configuration.Registries))
		for registryIndex, registryItem := range configuration.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry storage.RegistryCredentials
			err := registryItem.AssignProperties_To_RegistryCredentials(&registry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegistryCredentials() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		destination.Registries = registryList
	} else {
		destination.Registries = nil
	}

	// ReplicaRetryLimit
	destination.ReplicaRetryLimit = genruntime.ClonePointerToInt(configuration.ReplicaRetryLimit)

	// ReplicaTimeout
	destination.ReplicaTimeout = genruntime.ClonePointerToInt(configuration.ReplicaTimeout)

	// ScheduleTriggerConfig
	if configuration.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig storage.JobConfiguration_ScheduleTriggerConfig
		err := configuration.ScheduleTriggerConfig.AssignProperties_To_JobConfiguration_ScheduleTriggerConfig(&scheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_ScheduleTriggerConfig() to populate field ScheduleTriggerConfig")
		}
		destination.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		destination.ScheduleTriggerConfig = nil
	}

	// Secrets
	if configuration.Secrets != nil {
		secretList := make([]storage.Secret, len(configuration.Secrets))
		for secretIndex, secretItem := range configuration.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.Secret
			err := secretItem.AssignProperties_To_Secret(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Secret() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// TriggerType
	destination.TriggerType = genruntime.ClonePointerToString(configuration.TriggerType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForJobConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobConfiguration_STATUS
// Non versioned Container Apps Job configuration properties
type JobConfiguration_STATUS struct {
	EventTriggerConfig    *JobConfiguration_EventTriggerConfig_STATUS    `json:"eventTriggerConfig,omitempty"`
	ManualTriggerConfig   *JobConfiguration_ManualTriggerConfig_STATUS   `json:"manualTriggerConfig,omitempty"`
	PropertyBag           genruntime.PropertyBag                         `json:"$propertyBag,omitempty"`
	Registries            []RegistryCredentials_STATUS                   `json:"registries,omitempty"`
	ReplicaRetryLimit     *int                                           `json:"replicaRetryLimit,omitempty"`
	ReplicaTimeout        *int                                           `json:"replicaTimeout,omitempty"`
	ScheduleTriggerConfig *JobConfiguration_ScheduleTriggerConfig_STATUS `json:"scheduleTriggerConfig,omitempty"`
	Secrets               []Secret_STATUS                                `json:"secrets,omitempty"`
	TriggerType           *string                                        `json:"triggerType,omitempty"`
}

// AssignProperties_From_JobConfiguration_STATUS populates our JobConfiguration_STATUS from the provided source JobConfiguration_STATUS
func (configuration *JobConfiguration_STATUS) AssignProperties_From_JobConfiguration_STATUS(source *storage.JobConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventTriggerConfig
	if source.EventTriggerConfig != nil {
		var eventTriggerConfig JobConfiguration_EventTriggerConfig_STATUS
		err := eventTriggerConfig.AssignProperties_From_JobConfiguration_EventTriggerConfig_STATUS(source.EventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_EventTriggerConfig_STATUS() to populate field EventTriggerConfig")
		}
		configuration.EventTriggerConfig = &eventTriggerConfig
	} else {
		configuration.EventTriggerConfig = nil
	}

	// IdentitySettings
	if len(source.IdentitySettings) > 0 {
		propertyBag.Add("IdentitySettings", source.IdentitySettings)
	} else {
		propertyBag.Remove("IdentitySettings")
	}

	// ManualTriggerConfig
	if source.ManualTriggerConfig != nil {
		var manualTriggerConfig JobConfiguration_ManualTriggerConfig_STATUS
		err := manualTriggerConfig.AssignProperties_From_JobConfiguration_ManualTriggerConfig_STATUS(source.ManualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_ManualTriggerConfig_STATUS() to populate field ManualTriggerConfig")
		}
		configuration.ManualTriggerConfig = &manualTriggerConfig
	} else {
		configuration.ManualTriggerConfig = nil
	}

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials_STATUS, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials_STATUS
			err := registry.AssignProperties_From_RegistryCredentials_STATUS(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// ReplicaRetryLimit
	configuration.ReplicaRetryLimit = genruntime.ClonePointerToInt(source.ReplicaRetryLimit)

	// ReplicaTimeout
	configuration.ReplicaTimeout = genruntime.ClonePointerToInt(source.ReplicaTimeout)

	// ScheduleTriggerConfig
	if source.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig JobConfiguration_ScheduleTriggerConfig_STATUS
		err := scheduleTriggerConfig.AssignProperties_From_JobConfiguration_ScheduleTriggerConfig_STATUS(source.ScheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_ScheduleTriggerConfig_STATUS() to populate field ScheduleTriggerConfig")
		}
		configuration.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		configuration.ScheduleTriggerConfig = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret_STATUS
			err := secret.AssignProperties_From_Secret_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// TriggerType
	configuration.TriggerType = genruntime.ClonePointerToString(source.TriggerType)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForJobConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_STATUS populates the provided destination JobConfiguration_STATUS from our JobConfiguration_STATUS
func (configuration *JobConfiguration_STATUS) AssignProperties_To_JobConfiguration_STATUS(destination *storage.JobConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// EventTriggerConfig
	if configuration.EventTriggerConfig != nil {
		var eventTriggerConfig storage.JobConfiguration_EventTriggerConfig_STATUS
		err := configuration.EventTriggerConfig.AssignProperties_To_JobConfiguration_EventTriggerConfig_STATUS(&eventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_EventTriggerConfig_STATUS() to populate field EventTriggerConfig")
		}
		destination.EventTriggerConfig = &eventTriggerConfig
	} else {
		destination.EventTriggerConfig = nil
	}

	// IdentitySettings
	if propertyBag.Contains("IdentitySettings") {
		var identitySetting []storage.IdentitySettings_STATUS
		err := propertyBag.Pull("IdentitySettings", &identitySetting)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentitySettings' from propertyBag")
		}

		destination.IdentitySettings = identitySetting
	} else {
		destination.IdentitySettings = nil
	}

	// ManualTriggerConfig
	if configuration.ManualTriggerConfig != nil {
		var manualTriggerConfig storage.JobConfiguration_ManualTriggerConfig_STATUS
		err := configuration.ManualTriggerConfig.AssignProperties_To_JobConfiguration_ManualTriggerConfig_STATUS(&manualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_ManualTriggerConfig_STATUS() to populate field ManualTriggerConfig")
		}
		destination.ManualTriggerConfig = &manualTriggerConfig
	} else {
		destination.ManualTriggerConfig = nil
	}

	// Registries
	if configuration.Registries != nil {
		registryList := make([]storage.RegistryCredentials_STATUS, len(configuration.Registries))
		for registryIndex, registryItem := range configuration.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry storage.RegistryCredentials_STATUS
			err := registryItem.AssignProperties_To_RegistryCredentials_STATUS(&registry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		destination.Registries = registryList
	} else {
		destination.Registries = nil
	}

	// ReplicaRetryLimit
	destination.ReplicaRetryLimit = genruntime.ClonePointerToInt(configuration.ReplicaRetryLimit)

	// ReplicaTimeout
	destination.ReplicaTimeout = genruntime.ClonePointerToInt(configuration.ReplicaTimeout)

	// ScheduleTriggerConfig
	if configuration.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig storage.JobConfiguration_ScheduleTriggerConfig_STATUS
		err := configuration.ScheduleTriggerConfig.AssignProperties_To_JobConfiguration_ScheduleTriggerConfig_STATUS(&scheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_ScheduleTriggerConfig_STATUS() to populate field ScheduleTriggerConfig")
		}
		destination.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		destination.ScheduleTriggerConfig = nil
	}

	// Secrets
	if configuration.Secrets != nil {
		secretList := make([]storage.Secret_STATUS, len(configuration.Secrets))
		for secretIndex, secretItem := range configuration.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.Secret_STATUS
			err := secretItem.AssignProperties_To_Secret_STATUS(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// TriggerType
	destination.TriggerType = genruntime.ClonePointerToString(configuration.TriggerType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForJobConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type JobOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_JobOperatorSpec populates our JobOperatorSpec from the provided source JobOperatorSpec
func (operator *JobOperatorSpec) AssignProperties_From_JobOperatorSpec(source *storage.JobOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		operator.PropertyBag = propertyBag
	} else {
		operator.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForJobOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobOperatorSpec populates the provided destination JobOperatorSpec from our JobOperatorSpec
func (operator *JobOperatorSpec) AssignProperties_To_JobOperatorSpec(destination *storage.JobOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(operator.PropertyBag)

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForJobOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobTemplate
// Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to
// this section Will result in a new revision being created
type JobTemplate struct {
	Containers     []Container            `json:"containers,omitempty"`
	InitContainers []BaseContainer        `json:"initContainers,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Volumes        []Volume               `json:"volumes,omitempty"`
}

// AssignProperties_From_JobTemplate populates our JobTemplate from the provided source JobTemplate
func (template *JobTemplate) AssignProperties_From_JobTemplate(source *storage.JobTemplate) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Containers
	if source.Containers != nil {
		containerList := make([]Container, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container
			err := container.AssignProperties_From_Container(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer
			err := initContainer.AssignProperties_From_BaseContainer(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BaseContainer() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.AssignProperties_From_Volume(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		template.PropertyBag = propertyBag
	} else {
		template.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobTemplate interface (if implemented) to customize the conversion
	var templateAsAny any = template
	if augmentedTemplate, ok := templateAsAny.(augmentConversionForJobTemplate); ok {
		err := augmentedTemplate.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobTemplate populates the provided destination JobTemplate from our JobTemplate
func (template *JobTemplate) AssignProperties_To_JobTemplate(destination *storage.JobTemplate) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(template.PropertyBag)

	// Containers
	if template.Containers != nil {
		containerList := make([]storage.Container, len(template.Containers))
		for containerIndex, containerItem := range template.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container
			err := containerItem.AssignProperties_To_Container(&container)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// InitContainers
	if template.InitContainers != nil {
		initContainerList := make([]storage.BaseContainer, len(template.InitContainers))
		for initContainerIndex, initContainerItem := range template.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.BaseContainer
			err := initContainerItem.AssignProperties_To_BaseContainer(&initContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BaseContainer() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// Volumes
	if template.Volumes != nil {
		volumeList := make([]storage.Volume, len(template.Volumes))
		for volumeIndex, volumeItem := range template.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume
			err := volumeItem.AssignProperties_To_Volume(&volume)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobTemplate interface (if implemented) to customize the conversion
	var templateAsAny any = template
	if augmentedTemplate, ok := templateAsAny.(augmentConversionForJobTemplate); ok {
		err := augmentedTemplate.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobTemplate_STATUS
// Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to
// this section Will result in a new revision being created
type JobTemplate_STATUS struct {
	Containers     []Container_STATUS     `json:"containers,omitempty"`
	InitContainers []BaseContainer_STATUS `json:"initContainers,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Volumes        []Volume_STATUS        `json:"volumes,omitempty"`
}

// AssignProperties_From_JobTemplate_STATUS populates our JobTemplate_STATUS from the provided source JobTemplate_STATUS
func (template *JobTemplate_STATUS) AssignProperties_From_JobTemplate_STATUS(source *storage.JobTemplate_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Containers
	if source.Containers != nil {
		containerList := make([]Container_STATUS, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container_STATUS
			err := container.AssignProperties_From_Container_STATUS(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer_STATUS, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer_STATUS
			err := initContainer.AssignProperties_From_BaseContainer_STATUS(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume_STATUS, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume_STATUS
			err := volume.AssignProperties_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		template.PropertyBag = propertyBag
	} else {
		template.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobTemplate_STATUS interface (if implemented) to customize the conversion
	var templateAsAny any = template
	if augmentedTemplate, ok := templateAsAny.(augmentConversionForJobTemplate_STATUS); ok {
		err := augmentedTemplate.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobTemplate_STATUS populates the provided destination JobTemplate_STATUS from our JobTemplate_STATUS
func (template *JobTemplate_STATUS) AssignProperties_To_JobTemplate_STATUS(destination *storage.JobTemplate_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(template.PropertyBag)

	// Containers
	if template.Containers != nil {
		containerList := make([]storage.Container_STATUS, len(template.Containers))
		for containerIndex, containerItem := range template.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container_STATUS
			err := containerItem.AssignProperties_To_Container_STATUS(&container)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// InitContainers
	if template.InitContainers != nil {
		initContainerList := make([]storage.BaseContainer_STATUS, len(template.InitContainers))
		for initContainerIndex, initContainerItem := range template.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.BaseContainer_STATUS
			err := initContainerItem.AssignProperties_To_BaseContainer_STATUS(&initContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// Volumes
	if template.Volumes != nil {
		volumeList := make([]storage.Volume_STATUS, len(template.Volumes))
		for volumeIndex, volumeItem := range template.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume_STATUS
			err := volumeItem.AssignProperties_To_Volume_STATUS(&volume)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobTemplate_STATUS interface (if implemented) to customize the conversion
	var templateAsAny any = template
	if augmentedTemplate, ok := templateAsAny.(augmentConversionForJobTemplate_STATUS); ok {
		err := augmentedTemplate.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForJobConfiguration interface {
	AssignPropertiesFrom(src *storage.JobConfiguration) error
	AssignPropertiesTo(dst *storage.JobConfiguration) error
}

type augmentConversionForJobConfiguration_STATUS interface {
	AssignPropertiesFrom(src *storage.JobConfiguration_STATUS) error
	AssignPropertiesTo(dst *storage.JobConfiguration_STATUS) error
}

type augmentConversionForJobOperatorSpec interface {
	AssignPropertiesFrom(src *storage.JobOperatorSpec) error
	AssignPropertiesTo(dst *storage.JobOperatorSpec) error
}

type augmentConversionForJobTemplate interface {
	AssignPropertiesFrom(src *storage.JobTemplate) error
	AssignPropertiesTo(dst *storage.JobTemplate) error
}

type augmentConversionForJobTemplate_STATUS interface {
	AssignPropertiesFrom(src *storage.JobTemplate_STATUS) error
	AssignPropertiesTo(dst *storage.JobTemplate_STATUS) error
}

// Storage version of v1api20240301.JobConfiguration_EventTriggerConfig
type JobConfiguration_EventTriggerConfig struct {
	Parallelism            *int                   `json:"parallelism,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ReplicaCompletionCount *int                   `json:"replicaCompletionCount,omitempty"`
	Scale                  *JobScale              `json:"scale,omitempty"`
}

// AssignProperties_From_JobConfiguration_EventTriggerConfig populates our JobConfiguration_EventTriggerConfig from the provided source JobConfiguration_EventTriggerConfig
func (config *JobConfiguration_EventTriggerConfig) AssignProperties_From_JobConfiguration_EventTriggerConfig(source *storage.JobConfiguration_EventTriggerConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Scale
	if source.Scale != nil {
		var scale JobScale
		err := scale.AssignProperties_From_JobScale(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobScale() to populate field Scale")
		}
		config.Scale = &scale
	} else {
		config.Scale = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_EventTriggerConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_EventTriggerConfig); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_EventTriggerConfig populates the provided destination JobConfiguration_EventTriggerConfig from our JobConfiguration_EventTriggerConfig
func (config *JobConfiguration_EventTriggerConfig) AssignProperties_To_JobConfiguration_EventTriggerConfig(destination *storage.JobConfiguration_EventTriggerConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Scale
	if config.Scale != nil {
		var scale storage.JobScale
		err := config.Scale.AssignProperties_To_JobScale(&scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobScale() to populate field Scale")
		}
		destination.Scale = &scale
	} else {
		destination.Scale = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_EventTriggerConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_EventTriggerConfig); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobConfiguration_EventTriggerConfig_STATUS
type JobConfiguration_EventTriggerConfig_STATUS struct {
	Parallelism            *int                   `json:"parallelism,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ReplicaCompletionCount *int                   `json:"replicaCompletionCount,omitempty"`
	Scale                  *JobScale_STATUS       `json:"scale,omitempty"`
}

// AssignProperties_From_JobConfiguration_EventTriggerConfig_STATUS populates our JobConfiguration_EventTriggerConfig_STATUS from the provided source JobConfiguration_EventTriggerConfig_STATUS
func (config *JobConfiguration_EventTriggerConfig_STATUS) AssignProperties_From_JobConfiguration_EventTriggerConfig_STATUS(source *storage.JobConfiguration_EventTriggerConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Scale
	if source.Scale != nil {
		var scale JobScale_STATUS
		err := scale.AssignProperties_From_JobScale_STATUS(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobScale_STATUS() to populate field Scale")
		}
		config.Scale = &scale
	} else {
		config.Scale = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_EventTriggerConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_EventTriggerConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_EventTriggerConfig_STATUS populates the provided destination JobConfiguration_EventTriggerConfig_STATUS from our JobConfiguration_EventTriggerConfig_STATUS
func (config *JobConfiguration_EventTriggerConfig_STATUS) AssignProperties_To_JobConfiguration_EventTriggerConfig_STATUS(destination *storage.JobConfiguration_EventTriggerConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Scale
	if config.Scale != nil {
		var scale storage.JobScale_STATUS
		err := config.Scale.AssignProperties_To_JobScale_STATUS(&scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobScale_STATUS() to populate field Scale")
		}
		destination.Scale = &scale
	} else {
		destination.Scale = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_EventTriggerConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_EventTriggerConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobConfiguration_ManualTriggerConfig
type JobConfiguration_ManualTriggerConfig struct {
	Parallelism            *int                   `json:"parallelism,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ReplicaCompletionCount *int                   `json:"replicaCompletionCount,omitempty"`
}

// AssignProperties_From_JobConfiguration_ManualTriggerConfig populates our JobConfiguration_ManualTriggerConfig from the provided source JobConfiguration_ManualTriggerConfig
func (config *JobConfiguration_ManualTriggerConfig) AssignProperties_From_JobConfiguration_ManualTriggerConfig(source *storage.JobConfiguration_ManualTriggerConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_ManualTriggerConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_ManualTriggerConfig); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_ManualTriggerConfig populates the provided destination JobConfiguration_ManualTriggerConfig from our JobConfiguration_ManualTriggerConfig
func (config *JobConfiguration_ManualTriggerConfig) AssignProperties_To_JobConfiguration_ManualTriggerConfig(destination *storage.JobConfiguration_ManualTriggerConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_ManualTriggerConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_ManualTriggerConfig); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobConfiguration_ManualTriggerConfig_STATUS
type JobConfiguration_ManualTriggerConfig_STATUS struct {
	Parallelism            *int                   `json:"parallelism,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ReplicaCompletionCount *int                   `json:"replicaCompletionCount,omitempty"`
}

// AssignProperties_From_JobConfiguration_ManualTriggerConfig_STATUS populates our JobConfiguration_ManualTriggerConfig_STATUS from the provided source JobConfiguration_ManualTriggerConfig_STATUS
func (config *JobConfiguration_ManualTriggerConfig_STATUS) AssignProperties_From_JobConfiguration_ManualTriggerConfig_STATUS(source *storage.JobConfiguration_ManualTriggerConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_ManualTriggerConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_ManualTriggerConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_ManualTriggerConfig_STATUS populates the provided destination JobConfiguration_ManualTriggerConfig_STATUS from our JobConfiguration_ManualTriggerConfig_STATUS
func (config *JobConfiguration_ManualTriggerConfig_STATUS) AssignProperties_To_JobConfiguration_ManualTriggerConfig_STATUS(destination *storage.JobConfiguration_ManualTriggerConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_ManualTriggerConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_ManualTriggerConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobConfiguration_ScheduleTriggerConfig
type JobConfiguration_ScheduleTriggerConfig struct {
	CronExpression         *string                `json:"cronExpression,omitempty"`
	Parallelism            *int                   `json:"parallelism,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ReplicaCompletionCount *int                   `json:"replicaCompletionCount,omitempty"`
}

// AssignProperties_From_JobConfiguration_ScheduleTriggerConfig populates our JobConfiguration_ScheduleTriggerConfig from the provided source JobConfiguration_ScheduleTriggerConfig
func (config *JobConfiguration_ScheduleTriggerConfig) AssignProperties_From_JobConfiguration_ScheduleTriggerConfig(source *storage.JobConfiguration_ScheduleTriggerConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CronExpression
	config.CronExpression = genruntime.ClonePointerToString(source.CronExpression)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_ScheduleTriggerConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_ScheduleTriggerConfig); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_ScheduleTriggerConfig populates the provided destination JobConfiguration_ScheduleTriggerConfig from our JobConfiguration_ScheduleTriggerConfig
func (config *JobConfiguration_ScheduleTriggerConfig) AssignProperties_To_JobConfiguration_ScheduleTriggerConfig(destination *storage.JobConfiguration_ScheduleTriggerConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// CronExpression
	destination.CronExpression = genruntime.ClonePointerToString(config.CronExpression)

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_ScheduleTriggerConfig interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_ScheduleTriggerConfig); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobConfiguration_ScheduleTriggerConfig_STATUS
type JobConfiguration_ScheduleTriggerConfig_STATUS struct {
	CronExpression         *string                `json:"cronExpression,omitempty"`
	Parallelism            *int                   `json:"parallelism,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ReplicaCompletionCount *int                   `json:"replicaCompletionCount,omitempty"`
}

// AssignProperties_From_JobConfiguration_ScheduleTriggerConfig_STATUS populates our JobConfiguration_ScheduleTriggerConfig_STATUS from the provided source JobConfiguration_ScheduleTriggerConfig_STATUS
func (config *JobConfiguration_ScheduleTriggerConfig_STATUS) AssignProperties_From_JobConfiguration_ScheduleTriggerConfig_STATUS(source *storage.JobConfiguration_ScheduleTriggerConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CronExpression
	config.CronExpression = genruntime.ClonePointerToString(source.CronExpression)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_ScheduleTriggerConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_ScheduleTriggerConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_ScheduleTriggerConfig_STATUS populates the provided destination JobConfiguration_ScheduleTriggerConfig_STATUS from our JobConfiguration_ScheduleTriggerConfig_STATUS
func (config *JobConfiguration_ScheduleTriggerConfig_STATUS) AssignProperties_To_JobConfiguration_ScheduleTriggerConfig_STATUS(destination *storage.JobConfiguration_ScheduleTriggerConfig_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// CronExpression
	destination.CronExpression = genruntime.ClonePointerToString(config.CronExpression)

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobConfiguration_ScheduleTriggerConfig_STATUS interface (if implemented) to customize the conversion
	var configAsAny any = config
	if augmentedConfig, ok := configAsAny.(augmentConversionForJobConfiguration_ScheduleTriggerConfig_STATUS); ok {
		err := augmentedConfig.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForJobConfiguration_EventTriggerConfig interface {
	AssignPropertiesFrom(src *storage.JobConfiguration_EventTriggerConfig) error
	AssignPropertiesTo(dst *storage.JobConfiguration_EventTriggerConfig) error
}

type augmentConversionForJobConfiguration_EventTriggerConfig_STATUS interface {
	AssignPropertiesFrom(src *storage.JobConfiguration_EventTriggerConfig_STATUS) error
	AssignPropertiesTo(dst *storage.JobConfiguration_EventTriggerConfig_STATUS) error
}

type augmentConversionForJobConfiguration_ManualTriggerConfig interface {
	AssignPropertiesFrom(src *storage.JobConfiguration_ManualTriggerConfig) error
	AssignPropertiesTo(dst *storage.JobConfiguration_ManualTriggerConfig) error
}

type augmentConversionForJobConfiguration_ManualTriggerConfig_STATUS interface {
	AssignPropertiesFrom(src *storage.JobConfiguration_ManualTriggerConfig_STATUS) error
	AssignPropertiesTo(dst *storage.JobConfiguration_ManualTriggerConfig_STATUS) error
}

type augmentConversionForJobConfiguration_ScheduleTriggerConfig interface {
	AssignPropertiesFrom(src *storage.JobConfiguration_ScheduleTriggerConfig) error
	AssignPropertiesTo(dst *storage.JobConfiguration_ScheduleTriggerConfig) error
}

type augmentConversionForJobConfiguration_ScheduleTriggerConfig_STATUS interface {
	AssignPropertiesFrom(src *storage.JobConfiguration_ScheduleTriggerConfig_STATUS) error
	AssignPropertiesTo(dst *storage.JobConfiguration_ScheduleTriggerConfig_STATUS) error
}

// Storage version of v1api20240301.JobScale
// Scaling configurations for event driven jobs.
type JobScale struct {
	MaxExecutions   *int                   `json:"maxExecutions,omitempty"`
	MinExecutions   *int                   `json:"minExecutions,omitempty"`
	PollingInterval *int                   `json:"pollingInterval,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules           []JobScaleRule         `json:"rules,omitempty"`
}

// AssignProperties_From_JobScale populates our JobScale from the provided source JobScale
func (scale *JobScale) AssignProperties_From_JobScale(source *storage.JobScale) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MaxExecutions
	scale.MaxExecutions = genruntime.ClonePointerToInt(source.MaxExecutions)

	// MinExecutions
	scale.MinExecutions = genruntime.ClonePointerToInt(source.MinExecutions)

	// PollingInterval
	scale.PollingInterval = genruntime.ClonePointerToInt(source.PollingInterval)

	// Rules
	if source.Rules != nil {
		ruleList := make([]JobScaleRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule JobScaleRule
			err := rule.AssignProperties_From_JobScaleRule(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_JobScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		scale.PropertyBag = propertyBag
	} else {
		scale.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobScale interface (if implemented) to customize the conversion
	var scaleAsAny any = scale
	if augmentedScale, ok := scaleAsAny.(augmentConversionForJobScale); ok {
		err := augmentedScale.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobScale populates the provided destination JobScale from our JobScale
func (scale *JobScale) AssignProperties_To_JobScale(destination *storage.JobScale) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(scale.PropertyBag)

	// MaxExecutions
	destination.MaxExecutions = genruntime.ClonePointerToInt(scale.MaxExecutions)

	// MinExecutions
	destination.MinExecutions = genruntime.ClonePointerToInt(scale.MinExecutions)

	// PollingInterval
	destination.PollingInterval = genruntime.ClonePointerToInt(scale.PollingInterval)

	// Rules
	if scale.Rules != nil {
		ruleList := make([]storage.JobScaleRule, len(scale.Rules))
		for ruleIndex, ruleItem := range scale.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.JobScaleRule
			err := ruleItem.AssignProperties_To_JobScaleRule(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_JobScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobScale interface (if implemented) to customize the conversion
	var scaleAsAny any = scale
	if augmentedScale, ok := scaleAsAny.(augmentConversionForJobScale); ok {
		err := augmentedScale.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobScale_STATUS
// Scaling configurations for event driven jobs.
type JobScale_STATUS struct {
	MaxExecutions   *int                   `json:"maxExecutions,omitempty"`
	MinExecutions   *int                   `json:"minExecutions,omitempty"`
	PollingInterval *int                   `json:"pollingInterval,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules           []JobScaleRule_STATUS  `json:"rules,omitempty"`
}

// AssignProperties_From_JobScale_STATUS populates our JobScale_STATUS from the provided source JobScale_STATUS
func (scale *JobScale_STATUS) AssignProperties_From_JobScale_STATUS(source *storage.JobScale_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MaxExecutions
	scale.MaxExecutions = genruntime.ClonePointerToInt(source.MaxExecutions)

	// MinExecutions
	scale.MinExecutions = genruntime.ClonePointerToInt(source.MinExecutions)

	// PollingInterval
	scale.PollingInterval = genruntime.ClonePointerToInt(source.PollingInterval)

	// Rules
	if source.Rules != nil {
		ruleList := make([]JobScaleRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule JobScaleRule_STATUS
			err := rule.AssignProperties_From_JobScaleRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_JobScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		scale.PropertyBag = propertyBag
	} else {
		scale.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobScale_STATUS interface (if implemented) to customize the conversion
	var scaleAsAny any = scale
	if augmentedScale, ok := scaleAsAny.(augmentConversionForJobScale_STATUS); ok {
		err := augmentedScale.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobScale_STATUS populates the provided destination JobScale_STATUS from our JobScale_STATUS
func (scale *JobScale_STATUS) AssignProperties_To_JobScale_STATUS(destination *storage.JobScale_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(scale.PropertyBag)

	// MaxExecutions
	destination.MaxExecutions = genruntime.ClonePointerToInt(scale.MaxExecutions)

	// MinExecutions
	destination.MinExecutions = genruntime.ClonePointerToInt(scale.MinExecutions)

	// PollingInterval
	destination.PollingInterval = genruntime.ClonePointerToInt(scale.PollingInterval)

	// Rules
	if scale.Rules != nil {
		ruleList := make([]storage.JobScaleRule_STATUS, len(scale.Rules))
		for ruleIndex, ruleItem := range scale.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.JobScaleRule_STATUS
			err := ruleItem.AssignProperties_To_JobScaleRule_STATUS(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_JobScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobScale_STATUS interface (if implemented) to customize the conversion
	var scaleAsAny any = scale
	if augmentedScale, ok := scaleAsAny.(augmentConversionForJobScale_STATUS); ok {
		err := augmentedScale.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForJobScale interface {
	AssignPropertiesFrom(src *storage.JobScale) error
	AssignPropertiesTo(dst *storage.JobScale) error
}

type augmentConversionForJobScale_STATUS interface {
	AssignPropertiesFrom(src *storage.JobScale_STATUS) error
	AssignPropertiesTo(dst *storage.JobScale_STATUS) error
}

// Storage version of v1api20240301.JobScaleRule
// Scaling rule.
type JobScaleRule struct {
	Auth        []ScaleRuleAuth        `json:"auth,omitempty"`
	Metadata    map[string]v1.JSON     `json:"metadata,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_JobScaleRule populates our JobScaleRule from the provided source JobScaleRule
func (rule *JobScaleRule) AssignProperties_From_JobScaleRule(source *storage.JobScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// IdentityReference
	if source.IdentityReference != nil {
		propertyBag.Add("IdentityReference", *source.IdentityReference)
	} else {
		propertyBag.Remove("IdentityReference")
	}

	// Metadata
	if source.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(source.Metadata))
		for metadatumKey, metadatumValue := range source.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		rule.Metadata = metadatumMap
	} else {
		rule.Metadata = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForJobScaleRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobScaleRule populates the provided destination JobScaleRule from our JobScaleRule
func (rule *JobScaleRule) AssignProperties_To_JobScaleRule(destination *storage.JobScaleRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// IdentityReference
	if propertyBag.Contains("IdentityReference") {
		var identityReference genruntime.WellknownResourceReference
		err := propertyBag.Pull("IdentityReference", &identityReference)
		if err != nil {
			return eris.Wrap(err, "pulling 'IdentityReference' from propertyBag")
		}

		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// Metadata
	if rule.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(rule.Metadata))
		for metadatumKey, metadatumValue := range rule.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		destination.Metadata = metadatumMap
	} else {
		destination.Metadata = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobScaleRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForJobScaleRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240301.JobScaleRule_STATUS
// Scaling rule.
type JobScaleRule_STATUS struct {
	Auth        []ScaleRuleAuth_STATUS `json:"auth,omitempty"`
	Metadata    map[string]v1.JSON     `json:"metadata,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_JobScaleRule_STATUS populates our JobScaleRule_STATUS from the provided source JobScaleRule_STATUS
func (rule *JobScaleRule_STATUS) AssignProperties_From_JobScaleRule_STATUS(source *storage.JobScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Identity
	if source.Identity != nil {
		propertyBag.Add("Identity", *source.Identity)
	} else {
		propertyBag.Remove("Identity")
	}

	// Metadata
	if source.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(source.Metadata))
		for metadatumKey, metadatumValue := range source.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		rule.Metadata = metadatumMap
	} else {
		rule.Metadata = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForJobScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_JobScaleRule_STATUS populates the provided destination JobScaleRule_STATUS from our JobScaleRule_STATUS
func (rule *JobScaleRule_STATUS) AssignProperties_To_JobScaleRule_STATUS(destination *storage.JobScaleRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Identity
	if propertyBag.Contains("Identity") {
		var identity string
		err := propertyBag.Pull("Identity", &identity)
		if err != nil {
			return eris.Wrap(err, "pulling 'Identity' from propertyBag")
		}

		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Metadata
	if rule.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(rule.Metadata))
		for metadatumKey, metadatumValue := range rule.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		destination.Metadata = metadatumMap
	} else {
		destination.Metadata = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForJobScaleRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForJobScaleRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForJobScaleRule interface {
	AssignPropertiesFrom(src *storage.JobScaleRule) error
	AssignPropertiesTo(dst *storage.JobScaleRule) error
}

type augmentConversionForJobScaleRule_STATUS interface {
	AssignPropertiesFrom(src *storage.JobScaleRule_STATUS) error
	AssignPropertiesTo(dst *storage.JobScaleRule_STATUS) error
}

func init() {
	SchemeBuilder.Register(&Job{}, &JobList{})
}
