// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AllowedAudiencesValidation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AllowedAudiencesValidation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAllowedAudiencesValidation, AllowedAudiencesValidationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAllowedAudiencesValidation runs a test to see if a specific instance of AllowedAudiencesValidation round trips to JSON and back losslessly
func RunJSONSerializationTestForAllowedAudiencesValidation(subject AllowedAudiencesValidation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AllowedAudiencesValidation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AllowedAudiencesValidation instances for property testing - lazily instantiated by
// AllowedAudiencesValidationGenerator()
var allowedAudiencesValidationGenerator gopter.Gen

// AllowedAudiencesValidationGenerator returns a generator of AllowedAudiencesValidation instances for property testing.
func AllowedAudiencesValidationGenerator() gopter.Gen {
	if allowedAudiencesValidationGenerator != nil {
		return allowedAudiencesValidationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAllowedAudiencesValidation(generators)
	allowedAudiencesValidationGenerator = gen.Struct(reflect.TypeOf(AllowedAudiencesValidation{}), generators)

	return allowedAudiencesValidationGenerator
}

// AddIndependentPropertyGeneratorsForAllowedAudiencesValidation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAllowedAudiencesValidation(gens map[string]gopter.Gen) {
	gens["AllowedAudiences"] = gen.SliceOf(gen.AlphaString())
}

func Test_AllowedAudiencesValidation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AllowedAudiencesValidation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAllowedAudiencesValidation_STATUS, AllowedAudiencesValidation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAllowedAudiencesValidation_STATUS runs a test to see if a specific instance of AllowedAudiencesValidation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAllowedAudiencesValidation_STATUS(subject AllowedAudiencesValidation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AllowedAudiencesValidation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AllowedAudiencesValidation_STATUS instances for property testing - lazily instantiated by
// AllowedAudiencesValidation_STATUSGenerator()
var allowedAudiencesValidation_STATUSGenerator gopter.Gen

// AllowedAudiencesValidation_STATUSGenerator returns a generator of AllowedAudiencesValidation_STATUS instances for property testing.
func AllowedAudiencesValidation_STATUSGenerator() gopter.Gen {
	if allowedAudiencesValidation_STATUSGenerator != nil {
		return allowedAudiencesValidation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAllowedAudiencesValidation_STATUS(generators)
	allowedAudiencesValidation_STATUSGenerator = gen.Struct(reflect.TypeOf(AllowedAudiencesValidation_STATUS{}), generators)

	return allowedAudiencesValidation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAllowedAudiencesValidation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAllowedAudiencesValidation_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedAudiences"] = gen.SliceOf(gen.AlphaString())
}

func Test_AllowedPrincipals_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AllowedPrincipals via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAllowedPrincipals, AllowedPrincipalsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAllowedPrincipals runs a test to see if a specific instance of AllowedPrincipals round trips to JSON and back losslessly
func RunJSONSerializationTestForAllowedPrincipals(subject AllowedPrincipals) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AllowedPrincipals
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AllowedPrincipals instances for property testing - lazily instantiated by AllowedPrincipalsGenerator()
var allowedPrincipalsGenerator gopter.Gen

// AllowedPrincipalsGenerator returns a generator of AllowedPrincipals instances for property testing.
func AllowedPrincipalsGenerator() gopter.Gen {
	if allowedPrincipalsGenerator != nil {
		return allowedPrincipalsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAllowedPrincipals(generators)
	allowedPrincipalsGenerator = gen.Struct(reflect.TypeOf(AllowedPrincipals{}), generators)

	return allowedPrincipalsGenerator
}

// AddIndependentPropertyGeneratorsForAllowedPrincipals is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAllowedPrincipals(gens map[string]gopter.Gen) {
	gens["Groups"] = gen.SliceOf(gen.AlphaString())
	gens["Identities"] = gen.SliceOf(gen.AlphaString())
}

func Test_AllowedPrincipals_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AllowedPrincipals_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAllowedPrincipals_STATUS, AllowedPrincipals_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAllowedPrincipals_STATUS runs a test to see if a specific instance of AllowedPrincipals_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAllowedPrincipals_STATUS(subject AllowedPrincipals_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AllowedPrincipals_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AllowedPrincipals_STATUS instances for property testing - lazily instantiated by
// AllowedPrincipals_STATUSGenerator()
var allowedPrincipals_STATUSGenerator gopter.Gen

// AllowedPrincipals_STATUSGenerator returns a generator of AllowedPrincipals_STATUS instances for property testing.
func AllowedPrincipals_STATUSGenerator() gopter.Gen {
	if allowedPrincipals_STATUSGenerator != nil {
		return allowedPrincipals_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAllowedPrincipals_STATUS(generators)
	allowedPrincipals_STATUSGenerator = gen.Struct(reflect.TypeOf(AllowedPrincipals_STATUS{}), generators)

	return allowedPrincipals_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAllowedPrincipals_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAllowedPrincipals_STATUS(gens map[string]gopter.Gen) {
	gens["Groups"] = gen.SliceOf(gen.AlphaString())
	gens["Identities"] = gen.SliceOf(gen.AlphaString())
}

func Test_AppRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AppRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAppRegistration, AppRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAppRegistration runs a test to see if a specific instance of AppRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForAppRegistration(subject AppRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AppRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AppRegistration instances for property testing - lazily instantiated by AppRegistrationGenerator()
var appRegistrationGenerator gopter.Gen

// AppRegistrationGenerator returns a generator of AppRegistration instances for property testing.
func AppRegistrationGenerator() gopter.Gen {
	if appRegistrationGenerator != nil {
		return appRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppRegistration(generators)
	appRegistrationGenerator = gen.Struct(reflect.TypeOf(AppRegistration{}), generators)

	return appRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForAppRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAppRegistration(gens map[string]gopter.Gen) {
	gens["AppId"] = gen.PtrOf(gen.AlphaString())
	gens["AppSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AppRegistration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AppRegistration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAppRegistration_STATUS, AppRegistration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAppRegistration_STATUS runs a test to see if a specific instance of AppRegistration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAppRegistration_STATUS(subject AppRegistration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AppRegistration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AppRegistration_STATUS instances for property testing - lazily instantiated by
// AppRegistration_STATUSGenerator()
var appRegistration_STATUSGenerator gopter.Gen

// AppRegistration_STATUSGenerator returns a generator of AppRegistration_STATUS instances for property testing.
func AppRegistration_STATUSGenerator() gopter.Gen {
	if appRegistration_STATUSGenerator != nil {
		return appRegistration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppRegistration_STATUS(generators)
	appRegistration_STATUSGenerator = gen.Struct(reflect.TypeOf(AppRegistration_STATUS{}), generators)

	return appRegistration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAppRegistration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAppRegistration_STATUS(gens map[string]gopter.Gen) {
	gens["AppId"] = gen.PtrOf(gen.AlphaString())
	gens["AppSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Apple_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Apple via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApple, AppleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApple runs a test to see if a specific instance of Apple round trips to JSON and back losslessly
func RunJSONSerializationTestForApple(subject Apple) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Apple
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Apple instances for property testing - lazily instantiated by AppleGenerator()
var appleGenerator gopter.Gen

// AppleGenerator returns a generator of Apple instances for property testing.
// We first initialize appleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AppleGenerator() gopter.Gen {
	if appleGenerator != nil {
		return appleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApple(generators)
	appleGenerator = gen.Struct(reflect.TypeOf(Apple{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApple(generators)
	AddRelatedPropertyGeneratorsForApple(generators)
	appleGenerator = gen.Struct(reflect.TypeOf(Apple{}), generators)

	return appleGenerator
}

// AddIndependentPropertyGeneratorsForApple is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApple(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForApple is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApple(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopesGenerator())
	gens["Registration"] = gen.PtrOf(AppleRegistrationGenerator())
}

func Test_AppleRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AppleRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAppleRegistration, AppleRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAppleRegistration runs a test to see if a specific instance of AppleRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForAppleRegistration(subject AppleRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AppleRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AppleRegistration instances for property testing - lazily instantiated by AppleRegistrationGenerator()
var appleRegistrationGenerator gopter.Gen

// AppleRegistrationGenerator returns a generator of AppleRegistration instances for property testing.
func AppleRegistrationGenerator() gopter.Gen {
	if appleRegistrationGenerator != nil {
		return appleRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppleRegistration(generators)
	appleRegistrationGenerator = gen.Struct(reflect.TypeOf(AppleRegistration{}), generators)

	return appleRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForAppleRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAppleRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AppleRegistration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AppleRegistration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAppleRegistration_STATUS, AppleRegistration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAppleRegistration_STATUS runs a test to see if a specific instance of AppleRegistration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAppleRegistration_STATUS(subject AppleRegistration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AppleRegistration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AppleRegistration_STATUS instances for property testing - lazily instantiated by
// AppleRegistration_STATUSGenerator()
var appleRegistration_STATUSGenerator gopter.Gen

// AppleRegistration_STATUSGenerator returns a generator of AppleRegistration_STATUS instances for property testing.
func AppleRegistration_STATUSGenerator() gopter.Gen {
	if appleRegistration_STATUSGenerator != nil {
		return appleRegistration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppleRegistration_STATUS(generators)
	appleRegistration_STATUSGenerator = gen.Struct(reflect.TypeOf(AppleRegistration_STATUS{}), generators)

	return appleRegistration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAppleRegistration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAppleRegistration_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Apple_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Apple_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApple_STATUS, Apple_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApple_STATUS runs a test to see if a specific instance of Apple_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApple_STATUS(subject Apple_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Apple_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Apple_STATUS instances for property testing - lazily instantiated by Apple_STATUSGenerator()
var apple_STATUSGenerator gopter.Gen

// Apple_STATUSGenerator returns a generator of Apple_STATUS instances for property testing.
// We first initialize apple_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Apple_STATUSGenerator() gopter.Gen {
	if apple_STATUSGenerator != nil {
		return apple_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApple_STATUS(generators)
	apple_STATUSGenerator = gen.Struct(reflect.TypeOf(Apple_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApple_STATUS(generators)
	AddRelatedPropertyGeneratorsForApple_STATUS(generators)
	apple_STATUSGenerator = gen.Struct(reflect.TypeOf(Apple_STATUS{}), generators)

	return apple_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApple_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApple_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForApple_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApple_STATUS(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopes_STATUSGenerator())
	gens["Registration"] = gen.PtrOf(AppleRegistration_STATUSGenerator())
}

func Test_AuthConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthConfig, AuthConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthConfig runs a test to see if a specific instance of AuthConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthConfig(subject AuthConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthConfig instances for property testing - lazily instantiated by AuthConfigGenerator()
var authConfigGenerator gopter.Gen

// AuthConfigGenerator returns a generator of AuthConfig instances for property testing.
func AuthConfigGenerator() gopter.Gen {
	if authConfigGenerator != nil {
		return authConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAuthConfig(generators)
	authConfigGenerator = gen.Struct(reflect.TypeOf(AuthConfig{}), generators)

	return authConfigGenerator
}

// AddRelatedPropertyGeneratorsForAuthConfig is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthConfig(gens map[string]gopter.Gen) {
	gens["Spec"] = AuthConfig_SpecGenerator()
	gens["Status"] = AuthConfig_STATUSGenerator()
}

func Test_AuthConfigOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthConfigOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthConfigOperatorSpec, AuthConfigOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthConfigOperatorSpec runs a test to see if a specific instance of AuthConfigOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthConfigOperatorSpec(subject AuthConfigOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthConfigOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthConfigOperatorSpec instances for property testing - lazily instantiated by
// AuthConfigOperatorSpecGenerator()
var authConfigOperatorSpecGenerator gopter.Gen

// AuthConfigOperatorSpecGenerator returns a generator of AuthConfigOperatorSpec instances for property testing.
func AuthConfigOperatorSpecGenerator() gopter.Gen {
	if authConfigOperatorSpecGenerator != nil {
		return authConfigOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	authConfigOperatorSpecGenerator = gen.Struct(reflect.TypeOf(AuthConfigOperatorSpec{}), generators)

	return authConfigOperatorSpecGenerator
}

func Test_AuthConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthConfig_STATUS, AuthConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthConfig_STATUS runs a test to see if a specific instance of AuthConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthConfig_STATUS(subject AuthConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthConfig_STATUS instances for property testing - lazily instantiated by AuthConfig_STATUSGenerator()
var authConfig_STATUSGenerator gopter.Gen

// AuthConfig_STATUSGenerator returns a generator of AuthConfig_STATUS instances for property testing.
// We first initialize authConfig_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AuthConfig_STATUSGenerator() gopter.Gen {
	if authConfig_STATUSGenerator != nil {
		return authConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthConfig_STATUS(generators)
	authConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(AuthConfig_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthConfig_STATUS(generators)
	AddRelatedPropertyGeneratorsForAuthConfig_STATUS(generators)
	authConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(AuthConfig_STATUS{}), generators)

	return authConfig_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAuthConfig_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAuthConfig_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAuthConfig_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthConfig_STATUS(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.PtrOf(EncryptionSettings_STATUSGenerator())
	gens["GlobalValidation"] = gen.PtrOf(GlobalValidation_STATUSGenerator())
	gens["HttpSettings"] = gen.PtrOf(HttpSettings_STATUSGenerator())
	gens["IdentityProviders"] = gen.PtrOf(IdentityProviders_STATUSGenerator())
	gens["Login"] = gen.PtrOf(Login_STATUSGenerator())
	gens["Platform"] = gen.PtrOf(AuthPlatform_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_AuthConfig_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthConfig_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthConfig_Spec, AuthConfig_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthConfig_Spec runs a test to see if a specific instance of AuthConfig_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthConfig_Spec(subject AuthConfig_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthConfig_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthConfig_Spec instances for property testing - lazily instantiated by AuthConfig_SpecGenerator()
var authConfig_SpecGenerator gopter.Gen

// AuthConfig_SpecGenerator returns a generator of AuthConfig_Spec instances for property testing.
// We first initialize authConfig_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AuthConfig_SpecGenerator() gopter.Gen {
	if authConfig_SpecGenerator != nil {
		return authConfig_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthConfig_Spec(generators)
	authConfig_SpecGenerator = gen.Struct(reflect.TypeOf(AuthConfig_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthConfig_Spec(generators)
	AddRelatedPropertyGeneratorsForAuthConfig_Spec(generators)
	authConfig_SpecGenerator = gen.Struct(reflect.TypeOf(AuthConfig_Spec{}), generators)

	return authConfig_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAuthConfig_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAuthConfig_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["OriginalVersion"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForAuthConfig_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthConfig_Spec(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.PtrOf(EncryptionSettingsGenerator())
	gens["GlobalValidation"] = gen.PtrOf(GlobalValidationGenerator())
	gens["HttpSettings"] = gen.PtrOf(HttpSettingsGenerator())
	gens["IdentityProviders"] = gen.PtrOf(IdentityProvidersGenerator())
	gens["Login"] = gen.PtrOf(LoginGenerator())
	gens["OperatorSpec"] = gen.PtrOf(AuthConfigOperatorSpecGenerator())
	gens["Platform"] = gen.PtrOf(AuthPlatformGenerator())
}

func Test_AuthPlatform_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthPlatform via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthPlatform, AuthPlatformGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthPlatform runs a test to see if a specific instance of AuthPlatform round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthPlatform(subject AuthPlatform) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthPlatform
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthPlatform instances for property testing - lazily instantiated by AuthPlatformGenerator()
var authPlatformGenerator gopter.Gen

// AuthPlatformGenerator returns a generator of AuthPlatform instances for property testing.
func AuthPlatformGenerator() gopter.Gen {
	if authPlatformGenerator != nil {
		return authPlatformGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthPlatform(generators)
	authPlatformGenerator = gen.Struct(reflect.TypeOf(AuthPlatform{}), generators)

	return authPlatformGenerator
}

// AddIndependentPropertyGeneratorsForAuthPlatform is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAuthPlatform(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["RuntimeVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_AuthPlatform_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthPlatform_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthPlatform_STATUS, AuthPlatform_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthPlatform_STATUS runs a test to see if a specific instance of AuthPlatform_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthPlatform_STATUS(subject AuthPlatform_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthPlatform_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthPlatform_STATUS instances for property testing - lazily instantiated by
// AuthPlatform_STATUSGenerator()
var authPlatform_STATUSGenerator gopter.Gen

// AuthPlatform_STATUSGenerator returns a generator of AuthPlatform_STATUS instances for property testing.
func AuthPlatform_STATUSGenerator() gopter.Gen {
	if authPlatform_STATUSGenerator != nil {
		return authPlatform_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthPlatform_STATUS(generators)
	authPlatform_STATUSGenerator = gen.Struct(reflect.TypeOf(AuthPlatform_STATUS{}), generators)

	return authPlatform_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAuthPlatform_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAuthPlatform_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["RuntimeVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureActiveDirectory_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectory via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectory, AzureActiveDirectoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectory runs a test to see if a specific instance of AzureActiveDirectory round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectory(subject AzureActiveDirectory) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectory
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectory instances for property testing - lazily instantiated by
// AzureActiveDirectoryGenerator()
var azureActiveDirectoryGenerator gopter.Gen

// AzureActiveDirectoryGenerator returns a generator of AzureActiveDirectory instances for property testing.
// We first initialize azureActiveDirectoryGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureActiveDirectoryGenerator() gopter.Gen {
	if azureActiveDirectoryGenerator != nil {
		return azureActiveDirectoryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectory(generators)
	azureActiveDirectoryGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectory{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectory(generators)
	AddRelatedPropertyGeneratorsForAzureActiveDirectory(generators)
	azureActiveDirectoryGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectory{}), generators)

	return azureActiveDirectoryGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectory is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectory(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["IsAutoProvisioned"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForAzureActiveDirectory is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureActiveDirectory(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(AzureActiveDirectoryLoginGenerator())
	gens["Registration"] = gen.PtrOf(AzureActiveDirectoryRegistrationGenerator())
	gens["Validation"] = gen.PtrOf(AzureActiveDirectoryValidationGenerator())
}

func Test_AzureActiveDirectoryLogin_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryLogin via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryLogin, AzureActiveDirectoryLoginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryLogin runs a test to see if a specific instance of AzureActiveDirectoryLogin round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryLogin(subject AzureActiveDirectoryLogin) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryLogin
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryLogin instances for property testing - lazily instantiated by
// AzureActiveDirectoryLoginGenerator()
var azureActiveDirectoryLoginGenerator gopter.Gen

// AzureActiveDirectoryLoginGenerator returns a generator of AzureActiveDirectoryLogin instances for property testing.
func AzureActiveDirectoryLoginGenerator() gopter.Gen {
	if azureActiveDirectoryLoginGenerator != nil {
		return azureActiveDirectoryLoginGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin(generators)
	azureActiveDirectoryLoginGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryLogin{}), generators)

	return azureActiveDirectoryLoginGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin(gens map[string]gopter.Gen) {
	gens["DisableWWWAuthenticate"] = gen.PtrOf(gen.Bool())
	gens["LoginParameters"] = gen.SliceOf(gen.AlphaString())
}

func Test_AzureActiveDirectoryLogin_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryLogin_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryLogin_STATUS, AzureActiveDirectoryLogin_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryLogin_STATUS runs a test to see if a specific instance of AzureActiveDirectoryLogin_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryLogin_STATUS(subject AzureActiveDirectoryLogin_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryLogin_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryLogin_STATUS instances for property testing - lazily instantiated by
// AzureActiveDirectoryLogin_STATUSGenerator()
var azureActiveDirectoryLogin_STATUSGenerator gopter.Gen

// AzureActiveDirectoryLogin_STATUSGenerator returns a generator of AzureActiveDirectoryLogin_STATUS instances for property testing.
func AzureActiveDirectoryLogin_STATUSGenerator() gopter.Gen {
	if azureActiveDirectoryLogin_STATUSGenerator != nil {
		return azureActiveDirectoryLogin_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin_STATUS(generators)
	azureActiveDirectoryLogin_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryLogin_STATUS{}), generators)

	return azureActiveDirectoryLogin_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin_STATUS(gens map[string]gopter.Gen) {
	gens["DisableWWWAuthenticate"] = gen.PtrOf(gen.Bool())
	gens["LoginParameters"] = gen.SliceOf(gen.AlphaString())
}

func Test_AzureActiveDirectoryRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryRegistration, AzureActiveDirectoryRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryRegistration runs a test to see if a specific instance of AzureActiveDirectoryRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryRegistration(subject AzureActiveDirectoryRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryRegistration instances for property testing - lazily instantiated by
// AzureActiveDirectoryRegistrationGenerator()
var azureActiveDirectoryRegistrationGenerator gopter.Gen

// AzureActiveDirectoryRegistrationGenerator returns a generator of AzureActiveDirectoryRegistration instances for property testing.
func AzureActiveDirectoryRegistrationGenerator() gopter.Gen {
	if azureActiveDirectoryRegistrationGenerator != nil {
		return azureActiveDirectoryRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration(generators)
	azureActiveDirectoryRegistrationGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryRegistration{}), generators)

	return azureActiveDirectoryRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateIssuer"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateSubjectAlternativeName"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateThumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
	gens["OpenIdIssuer"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureActiveDirectoryRegistration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryRegistration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryRegistration_STATUS, AzureActiveDirectoryRegistration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryRegistration_STATUS runs a test to see if a specific instance of AzureActiveDirectoryRegistration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryRegistration_STATUS(subject AzureActiveDirectoryRegistration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryRegistration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryRegistration_STATUS instances for property testing - lazily instantiated by
// AzureActiveDirectoryRegistration_STATUSGenerator()
var azureActiveDirectoryRegistration_STATUSGenerator gopter.Gen

// AzureActiveDirectoryRegistration_STATUSGenerator returns a generator of AzureActiveDirectoryRegistration_STATUS instances for property testing.
func AzureActiveDirectoryRegistration_STATUSGenerator() gopter.Gen {
	if azureActiveDirectoryRegistration_STATUSGenerator != nil {
		return azureActiveDirectoryRegistration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration_STATUS(generators)
	azureActiveDirectoryRegistration_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryRegistration_STATUS{}), generators)

	return azureActiveDirectoryRegistration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateIssuer"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateSubjectAlternativeName"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateThumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
	gens["OpenIdIssuer"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureActiveDirectoryValidation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryValidation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryValidation, AzureActiveDirectoryValidationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryValidation runs a test to see if a specific instance of AzureActiveDirectoryValidation round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryValidation(subject AzureActiveDirectoryValidation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryValidation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryValidation instances for property testing - lazily instantiated by
// AzureActiveDirectoryValidationGenerator()
var azureActiveDirectoryValidationGenerator gopter.Gen

// AzureActiveDirectoryValidationGenerator returns a generator of AzureActiveDirectoryValidation instances for property testing.
// We first initialize azureActiveDirectoryValidationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureActiveDirectoryValidationGenerator() gopter.Gen {
	if azureActiveDirectoryValidationGenerator != nil {
		return azureActiveDirectoryValidationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation(generators)
	azureActiveDirectoryValidationGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryValidation{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation(generators)
	AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation(generators)
	azureActiveDirectoryValidationGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryValidation{}), generators)

	return azureActiveDirectoryValidationGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation(gens map[string]gopter.Gen) {
	gens["AllowedAudiences"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation(gens map[string]gopter.Gen) {
	gens["DefaultAuthorizationPolicy"] = gen.PtrOf(DefaultAuthorizationPolicyGenerator())
	gens["JwtClaimChecks"] = gen.PtrOf(JwtClaimChecksGenerator())
}

func Test_AzureActiveDirectoryValidation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryValidation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryValidation_STATUS, AzureActiveDirectoryValidation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryValidation_STATUS runs a test to see if a specific instance of AzureActiveDirectoryValidation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryValidation_STATUS(subject AzureActiveDirectoryValidation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryValidation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryValidation_STATUS instances for property testing - lazily instantiated by
// AzureActiveDirectoryValidation_STATUSGenerator()
var azureActiveDirectoryValidation_STATUSGenerator gopter.Gen

// AzureActiveDirectoryValidation_STATUSGenerator returns a generator of AzureActiveDirectoryValidation_STATUS instances for property testing.
// We first initialize azureActiveDirectoryValidation_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureActiveDirectoryValidation_STATUSGenerator() gopter.Gen {
	if azureActiveDirectoryValidation_STATUSGenerator != nil {
		return azureActiveDirectoryValidation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation_STATUS(generators)
	azureActiveDirectoryValidation_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryValidation_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation_STATUS(generators)
	AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation_STATUS(generators)
	azureActiveDirectoryValidation_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryValidation_STATUS{}), generators)

	return azureActiveDirectoryValidation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedAudiences"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultAuthorizationPolicy"] = gen.PtrOf(DefaultAuthorizationPolicy_STATUSGenerator())
	gens["JwtClaimChecks"] = gen.PtrOf(JwtClaimChecks_STATUSGenerator())
}

func Test_AzureActiveDirectory_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectory_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectory_STATUS, AzureActiveDirectory_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectory_STATUS runs a test to see if a specific instance of AzureActiveDirectory_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectory_STATUS(subject AzureActiveDirectory_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectory_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectory_STATUS instances for property testing - lazily instantiated by
// AzureActiveDirectory_STATUSGenerator()
var azureActiveDirectory_STATUSGenerator gopter.Gen

// AzureActiveDirectory_STATUSGenerator returns a generator of AzureActiveDirectory_STATUS instances for property testing.
// We first initialize azureActiveDirectory_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureActiveDirectory_STATUSGenerator() gopter.Gen {
	if azureActiveDirectory_STATUSGenerator != nil {
		return azureActiveDirectory_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectory_STATUS(generators)
	azureActiveDirectory_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectory_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectory_STATUS(generators)
	AddRelatedPropertyGeneratorsForAzureActiveDirectory_STATUS(generators)
	azureActiveDirectory_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectory_STATUS{}), generators)

	return azureActiveDirectory_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectory_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectory_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["IsAutoProvisioned"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForAzureActiveDirectory_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureActiveDirectory_STATUS(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(AzureActiveDirectoryLogin_STATUSGenerator())
	gens["Registration"] = gen.PtrOf(AzureActiveDirectoryRegistration_STATUSGenerator())
	gens["Validation"] = gen.PtrOf(AzureActiveDirectoryValidation_STATUSGenerator())
}

func Test_AzureStaticWebApps_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStaticWebApps via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStaticWebApps, AzureStaticWebAppsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStaticWebApps runs a test to see if a specific instance of AzureStaticWebApps round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStaticWebApps(subject AzureStaticWebApps) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStaticWebApps
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStaticWebApps instances for property testing - lazily instantiated by AzureStaticWebAppsGenerator()
var azureStaticWebAppsGenerator gopter.Gen

// AzureStaticWebAppsGenerator returns a generator of AzureStaticWebApps instances for property testing.
// We first initialize azureStaticWebAppsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureStaticWebAppsGenerator() gopter.Gen {
	if azureStaticWebAppsGenerator != nil {
		return azureStaticWebAppsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebApps(generators)
	azureStaticWebAppsGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebApps{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebApps(generators)
	AddRelatedPropertyGeneratorsForAzureStaticWebApps(generators)
	azureStaticWebAppsGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebApps{}), generators)

	return azureStaticWebAppsGenerator
}

// AddIndependentPropertyGeneratorsForAzureStaticWebApps is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStaticWebApps(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForAzureStaticWebApps is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureStaticWebApps(gens map[string]gopter.Gen) {
	gens["Registration"] = gen.PtrOf(AzureStaticWebAppsRegistrationGenerator())
}

func Test_AzureStaticWebAppsRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStaticWebAppsRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStaticWebAppsRegistration, AzureStaticWebAppsRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStaticWebAppsRegistration runs a test to see if a specific instance of AzureStaticWebAppsRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStaticWebAppsRegistration(subject AzureStaticWebAppsRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStaticWebAppsRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStaticWebAppsRegistration instances for property testing - lazily instantiated by
// AzureStaticWebAppsRegistrationGenerator()
var azureStaticWebAppsRegistrationGenerator gopter.Gen

// AzureStaticWebAppsRegistrationGenerator returns a generator of AzureStaticWebAppsRegistration instances for property testing.
func AzureStaticWebAppsRegistrationGenerator() gopter.Gen {
	if azureStaticWebAppsRegistrationGenerator != nil {
		return azureStaticWebAppsRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration(generators)
	azureStaticWebAppsRegistrationGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebAppsRegistration{}), generators)

	return azureStaticWebAppsRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureStaticWebAppsRegistration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStaticWebAppsRegistration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStaticWebAppsRegistration_STATUS, AzureStaticWebAppsRegistration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStaticWebAppsRegistration_STATUS runs a test to see if a specific instance of AzureStaticWebAppsRegistration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStaticWebAppsRegistration_STATUS(subject AzureStaticWebAppsRegistration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStaticWebAppsRegistration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStaticWebAppsRegistration_STATUS instances for property testing - lazily instantiated by
// AzureStaticWebAppsRegistration_STATUSGenerator()
var azureStaticWebAppsRegistration_STATUSGenerator gopter.Gen

// AzureStaticWebAppsRegistration_STATUSGenerator returns a generator of AzureStaticWebAppsRegistration_STATUS instances for property testing.
func AzureStaticWebAppsRegistration_STATUSGenerator() gopter.Gen {
	if azureStaticWebAppsRegistration_STATUSGenerator != nil {
		return azureStaticWebAppsRegistration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration_STATUS(generators)
	azureStaticWebAppsRegistration_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebAppsRegistration_STATUS{}), generators)

	return azureStaticWebAppsRegistration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureStaticWebApps_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStaticWebApps_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStaticWebApps_STATUS, AzureStaticWebApps_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStaticWebApps_STATUS runs a test to see if a specific instance of AzureStaticWebApps_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStaticWebApps_STATUS(subject AzureStaticWebApps_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStaticWebApps_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStaticWebApps_STATUS instances for property testing - lazily instantiated by
// AzureStaticWebApps_STATUSGenerator()
var azureStaticWebApps_STATUSGenerator gopter.Gen

// AzureStaticWebApps_STATUSGenerator returns a generator of AzureStaticWebApps_STATUS instances for property testing.
// We first initialize azureStaticWebApps_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureStaticWebApps_STATUSGenerator() gopter.Gen {
	if azureStaticWebApps_STATUSGenerator != nil {
		return azureStaticWebApps_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebApps_STATUS(generators)
	azureStaticWebApps_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebApps_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebApps_STATUS(generators)
	AddRelatedPropertyGeneratorsForAzureStaticWebApps_STATUS(generators)
	azureStaticWebApps_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebApps_STATUS{}), generators)

	return azureStaticWebApps_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureStaticWebApps_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStaticWebApps_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForAzureStaticWebApps_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureStaticWebApps_STATUS(gens map[string]gopter.Gen) {
	gens["Registration"] = gen.PtrOf(AzureStaticWebAppsRegistration_STATUSGenerator())
}

func Test_BlobStorageTokenStore_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobStorageTokenStore via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobStorageTokenStore, BlobStorageTokenStoreGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobStorageTokenStore runs a test to see if a specific instance of BlobStorageTokenStore round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobStorageTokenStore(subject BlobStorageTokenStore) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobStorageTokenStore
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobStorageTokenStore instances for property testing - lazily instantiated by
// BlobStorageTokenStoreGenerator()
var blobStorageTokenStoreGenerator gopter.Gen

// BlobStorageTokenStoreGenerator returns a generator of BlobStorageTokenStore instances for property testing.
func BlobStorageTokenStoreGenerator() gopter.Gen {
	if blobStorageTokenStoreGenerator != nil {
		return blobStorageTokenStoreGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobStorageTokenStore(generators)
	blobStorageTokenStoreGenerator = gen.Struct(reflect.TypeOf(BlobStorageTokenStore{}), generators)

	return blobStorageTokenStoreGenerator
}

// AddIndependentPropertyGeneratorsForBlobStorageTokenStore is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobStorageTokenStore(gens map[string]gopter.Gen) {
	gens["SasUrlSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobStorageTokenStore_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobStorageTokenStore_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobStorageTokenStore_STATUS, BlobStorageTokenStore_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobStorageTokenStore_STATUS runs a test to see if a specific instance of BlobStorageTokenStore_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobStorageTokenStore_STATUS(subject BlobStorageTokenStore_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobStorageTokenStore_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobStorageTokenStore_STATUS instances for property testing - lazily instantiated by
// BlobStorageTokenStore_STATUSGenerator()
var blobStorageTokenStore_STATUSGenerator gopter.Gen

// BlobStorageTokenStore_STATUSGenerator returns a generator of BlobStorageTokenStore_STATUS instances for property testing.
func BlobStorageTokenStore_STATUSGenerator() gopter.Gen {
	if blobStorageTokenStore_STATUSGenerator != nil {
		return blobStorageTokenStore_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobStorageTokenStore_STATUS(generators)
	blobStorageTokenStore_STATUSGenerator = gen.Struct(reflect.TypeOf(BlobStorageTokenStore_STATUS{}), generators)

	return blobStorageTokenStore_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBlobStorageTokenStore_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobStorageTokenStore_STATUS(gens map[string]gopter.Gen) {
	gens["SasUrlSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ClientRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientRegistration, ClientRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientRegistration runs a test to see if a specific instance of ClientRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForClientRegistration(subject ClientRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientRegistration instances for property testing - lazily instantiated by ClientRegistrationGenerator()
var clientRegistrationGenerator gopter.Gen

// ClientRegistrationGenerator returns a generator of ClientRegistration instances for property testing.
func ClientRegistrationGenerator() gopter.Gen {
	if clientRegistrationGenerator != nil {
		return clientRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientRegistration(generators)
	clientRegistrationGenerator = gen.Struct(reflect.TypeOf(ClientRegistration{}), generators)

	return clientRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForClientRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ClientRegistration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientRegistration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientRegistration_STATUS, ClientRegistration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientRegistration_STATUS runs a test to see if a specific instance of ClientRegistration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForClientRegistration_STATUS(subject ClientRegistration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientRegistration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientRegistration_STATUS instances for property testing - lazily instantiated by
// ClientRegistration_STATUSGenerator()
var clientRegistration_STATUSGenerator gopter.Gen

// ClientRegistration_STATUSGenerator returns a generator of ClientRegistration_STATUS instances for property testing.
func ClientRegistration_STATUSGenerator() gopter.Gen {
	if clientRegistration_STATUSGenerator != nil {
		return clientRegistration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientRegistration_STATUS(generators)
	clientRegistration_STATUSGenerator = gen.Struct(reflect.TypeOf(ClientRegistration_STATUS{}), generators)

	return clientRegistration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForClientRegistration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientRegistration_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_CookieExpiration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookieExpiration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookieExpiration, CookieExpirationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookieExpiration runs a test to see if a specific instance of CookieExpiration round trips to JSON and back losslessly
func RunJSONSerializationTestForCookieExpiration(subject CookieExpiration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookieExpiration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookieExpiration instances for property testing - lazily instantiated by CookieExpirationGenerator()
var cookieExpirationGenerator gopter.Gen

// CookieExpirationGenerator returns a generator of CookieExpiration instances for property testing.
func CookieExpirationGenerator() gopter.Gen {
	if cookieExpirationGenerator != nil {
		return cookieExpirationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookieExpiration(generators)
	cookieExpirationGenerator = gen.Struct(reflect.TypeOf(CookieExpiration{}), generators)

	return cookieExpirationGenerator
}

// AddIndependentPropertyGeneratorsForCookieExpiration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookieExpiration(gens map[string]gopter.Gen) {
	gens["Convention"] = gen.PtrOf(gen.AlphaString())
	gens["TimeToExpiration"] = gen.PtrOf(gen.AlphaString())
}

func Test_CookieExpiration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookieExpiration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookieExpiration_STATUS, CookieExpiration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookieExpiration_STATUS runs a test to see if a specific instance of CookieExpiration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCookieExpiration_STATUS(subject CookieExpiration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookieExpiration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookieExpiration_STATUS instances for property testing - lazily instantiated by
// CookieExpiration_STATUSGenerator()
var cookieExpiration_STATUSGenerator gopter.Gen

// CookieExpiration_STATUSGenerator returns a generator of CookieExpiration_STATUS instances for property testing.
func CookieExpiration_STATUSGenerator() gopter.Gen {
	if cookieExpiration_STATUSGenerator != nil {
		return cookieExpiration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookieExpiration_STATUS(generators)
	cookieExpiration_STATUSGenerator = gen.Struct(reflect.TypeOf(CookieExpiration_STATUS{}), generators)

	return cookieExpiration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCookieExpiration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookieExpiration_STATUS(gens map[string]gopter.Gen) {
	gens["Convention"] = gen.PtrOf(gen.AlphaString())
	gens["TimeToExpiration"] = gen.PtrOf(gen.AlphaString())
}

func Test_CustomOpenIdConnectProvider_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomOpenIdConnectProvider via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomOpenIdConnectProvider, CustomOpenIdConnectProviderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomOpenIdConnectProvider runs a test to see if a specific instance of CustomOpenIdConnectProvider round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomOpenIdConnectProvider(subject CustomOpenIdConnectProvider) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomOpenIdConnectProvider
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomOpenIdConnectProvider instances for property testing - lazily instantiated by
// CustomOpenIdConnectProviderGenerator()
var customOpenIdConnectProviderGenerator gopter.Gen

// CustomOpenIdConnectProviderGenerator returns a generator of CustomOpenIdConnectProvider instances for property testing.
// We first initialize customOpenIdConnectProviderGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomOpenIdConnectProviderGenerator() gopter.Gen {
	if customOpenIdConnectProviderGenerator != nil {
		return customOpenIdConnectProviderGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider(generators)
	customOpenIdConnectProviderGenerator = gen.Struct(reflect.TypeOf(CustomOpenIdConnectProvider{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider(generators)
	AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider(generators)
	customOpenIdConnectProviderGenerator = gen.Struct(reflect.TypeOf(CustomOpenIdConnectProvider{}), generators)

	return customOpenIdConnectProviderGenerator
}

// AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(OpenIdConnectLoginGenerator())
	gens["Registration"] = gen.PtrOf(OpenIdConnectRegistrationGenerator())
}

func Test_CustomOpenIdConnectProvider_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomOpenIdConnectProvider_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomOpenIdConnectProvider_STATUS, CustomOpenIdConnectProvider_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomOpenIdConnectProvider_STATUS runs a test to see if a specific instance of CustomOpenIdConnectProvider_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomOpenIdConnectProvider_STATUS(subject CustomOpenIdConnectProvider_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomOpenIdConnectProvider_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomOpenIdConnectProvider_STATUS instances for property testing - lazily instantiated by
// CustomOpenIdConnectProvider_STATUSGenerator()
var customOpenIdConnectProvider_STATUSGenerator gopter.Gen

// CustomOpenIdConnectProvider_STATUSGenerator returns a generator of CustomOpenIdConnectProvider_STATUS instances for property testing.
// We first initialize customOpenIdConnectProvider_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomOpenIdConnectProvider_STATUSGenerator() gopter.Gen {
	if customOpenIdConnectProvider_STATUSGenerator != nil {
		return customOpenIdConnectProvider_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider_STATUS(generators)
	customOpenIdConnectProvider_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomOpenIdConnectProvider_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider_STATUS(generators)
	AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider_STATUS(generators)
	customOpenIdConnectProvider_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomOpenIdConnectProvider_STATUS{}), generators)

	return customOpenIdConnectProvider_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider_STATUS(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(OpenIdConnectLogin_STATUSGenerator())
	gens["Registration"] = gen.PtrOf(OpenIdConnectRegistration_STATUSGenerator())
}

func Test_DefaultAuthorizationPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DefaultAuthorizationPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDefaultAuthorizationPolicy, DefaultAuthorizationPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDefaultAuthorizationPolicy runs a test to see if a specific instance of DefaultAuthorizationPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForDefaultAuthorizationPolicy(subject DefaultAuthorizationPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DefaultAuthorizationPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DefaultAuthorizationPolicy instances for property testing - lazily instantiated by
// DefaultAuthorizationPolicyGenerator()
var defaultAuthorizationPolicyGenerator gopter.Gen

// DefaultAuthorizationPolicyGenerator returns a generator of DefaultAuthorizationPolicy instances for property testing.
// We first initialize defaultAuthorizationPolicyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DefaultAuthorizationPolicyGenerator() gopter.Gen {
	if defaultAuthorizationPolicyGenerator != nil {
		return defaultAuthorizationPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy(generators)
	defaultAuthorizationPolicyGenerator = gen.Struct(reflect.TypeOf(DefaultAuthorizationPolicy{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy(generators)
	AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy(generators)
	defaultAuthorizationPolicyGenerator = gen.Struct(reflect.TypeOf(DefaultAuthorizationPolicy{}), generators)

	return defaultAuthorizationPolicyGenerator
}

// AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy(gens map[string]gopter.Gen) {
	gens["AllowedApplications"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy(gens map[string]gopter.Gen) {
	gens["AllowedPrincipals"] = gen.PtrOf(AllowedPrincipalsGenerator())
}

func Test_DefaultAuthorizationPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DefaultAuthorizationPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDefaultAuthorizationPolicy_STATUS, DefaultAuthorizationPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDefaultAuthorizationPolicy_STATUS runs a test to see if a specific instance of DefaultAuthorizationPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDefaultAuthorizationPolicy_STATUS(subject DefaultAuthorizationPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DefaultAuthorizationPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DefaultAuthorizationPolicy_STATUS instances for property testing - lazily instantiated by
// DefaultAuthorizationPolicy_STATUSGenerator()
var defaultAuthorizationPolicy_STATUSGenerator gopter.Gen

// DefaultAuthorizationPolicy_STATUSGenerator returns a generator of DefaultAuthorizationPolicy_STATUS instances for property testing.
// We first initialize defaultAuthorizationPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DefaultAuthorizationPolicy_STATUSGenerator() gopter.Gen {
	if defaultAuthorizationPolicy_STATUSGenerator != nil {
		return defaultAuthorizationPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy_STATUS(generators)
	defaultAuthorizationPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(DefaultAuthorizationPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy_STATUS(generators)
	defaultAuthorizationPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(DefaultAuthorizationPolicy_STATUS{}), generators)

	return defaultAuthorizationPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedApplications"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedPrincipals"] = gen.PtrOf(AllowedPrincipals_STATUSGenerator())
}

func Test_EncryptionSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettings, EncryptionSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettings runs a test to see if a specific instance of EncryptionSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettings(subject EncryptionSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettings instances for property testing - lazily instantiated by EncryptionSettingsGenerator()
var encryptionSettingsGenerator gopter.Gen

// EncryptionSettingsGenerator returns a generator of EncryptionSettings instances for property testing.
func EncryptionSettingsGenerator() gopter.Gen {
	if encryptionSettingsGenerator != nil {
		return encryptionSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettings(generators)
	encryptionSettingsGenerator = gen.Struct(reflect.TypeOf(EncryptionSettings{}), generators)

	return encryptionSettingsGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettings(gens map[string]gopter.Gen) {
	gens["ContainerAppAuthEncryptionSecretName"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerAppAuthSigningSecretName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettings_STATUS, EncryptionSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettings_STATUS runs a test to see if a specific instance of EncryptionSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettings_STATUS(subject EncryptionSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettings_STATUS instances for property testing - lazily instantiated by
// EncryptionSettings_STATUSGenerator()
var encryptionSettings_STATUSGenerator gopter.Gen

// EncryptionSettings_STATUSGenerator returns a generator of EncryptionSettings_STATUS instances for property testing.
func EncryptionSettings_STATUSGenerator() gopter.Gen {
	if encryptionSettings_STATUSGenerator != nil {
		return encryptionSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettings_STATUS(generators)
	encryptionSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionSettings_STATUS{}), generators)

	return encryptionSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettings_STATUS(gens map[string]gopter.Gen) {
	gens["ContainerAppAuthEncryptionSecretName"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerAppAuthSigningSecretName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Facebook_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Facebook via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFacebook, FacebookGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFacebook runs a test to see if a specific instance of Facebook round trips to JSON and back losslessly
func RunJSONSerializationTestForFacebook(subject Facebook) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Facebook
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Facebook instances for property testing - lazily instantiated by FacebookGenerator()
var facebookGenerator gopter.Gen

// FacebookGenerator returns a generator of Facebook instances for property testing.
// We first initialize facebookGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FacebookGenerator() gopter.Gen {
	if facebookGenerator != nil {
		return facebookGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFacebook(generators)
	facebookGenerator = gen.Struct(reflect.TypeOf(Facebook{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFacebook(generators)
	AddRelatedPropertyGeneratorsForFacebook(generators)
	facebookGenerator = gen.Struct(reflect.TypeOf(Facebook{}), generators)

	return facebookGenerator
}

// AddIndependentPropertyGeneratorsForFacebook is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFacebook(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GraphApiVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFacebook is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFacebook(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopesGenerator())
	gens["Registration"] = gen.PtrOf(AppRegistrationGenerator())
}

func Test_Facebook_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Facebook_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFacebook_STATUS, Facebook_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFacebook_STATUS runs a test to see if a specific instance of Facebook_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFacebook_STATUS(subject Facebook_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Facebook_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Facebook_STATUS instances for property testing - lazily instantiated by Facebook_STATUSGenerator()
var facebook_STATUSGenerator gopter.Gen

// Facebook_STATUSGenerator returns a generator of Facebook_STATUS instances for property testing.
// We first initialize facebook_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Facebook_STATUSGenerator() gopter.Gen {
	if facebook_STATUSGenerator != nil {
		return facebook_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFacebook_STATUS(generators)
	facebook_STATUSGenerator = gen.Struct(reflect.TypeOf(Facebook_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFacebook_STATUS(generators)
	AddRelatedPropertyGeneratorsForFacebook_STATUS(generators)
	facebook_STATUSGenerator = gen.Struct(reflect.TypeOf(Facebook_STATUS{}), generators)

	return facebook_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFacebook_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFacebook_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GraphApiVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFacebook_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFacebook_STATUS(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopes_STATUSGenerator())
	gens["Registration"] = gen.PtrOf(AppRegistration_STATUSGenerator())
}

func Test_ForwardProxy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ForwardProxy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForForwardProxy, ForwardProxyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForForwardProxy runs a test to see if a specific instance of ForwardProxy round trips to JSON and back losslessly
func RunJSONSerializationTestForForwardProxy(subject ForwardProxy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ForwardProxy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ForwardProxy instances for property testing - lazily instantiated by ForwardProxyGenerator()
var forwardProxyGenerator gopter.Gen

// ForwardProxyGenerator returns a generator of ForwardProxy instances for property testing.
func ForwardProxyGenerator() gopter.Gen {
	if forwardProxyGenerator != nil {
		return forwardProxyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardProxy(generators)
	forwardProxyGenerator = gen.Struct(reflect.TypeOf(ForwardProxy{}), generators)

	return forwardProxyGenerator
}

// AddIndependentPropertyGeneratorsForForwardProxy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForForwardProxy(gens map[string]gopter.Gen) {
	gens["Convention"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHostHeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomProtoHeaderName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ForwardProxy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ForwardProxy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForForwardProxy_STATUS, ForwardProxy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForForwardProxy_STATUS runs a test to see if a specific instance of ForwardProxy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForForwardProxy_STATUS(subject ForwardProxy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ForwardProxy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ForwardProxy_STATUS instances for property testing - lazily instantiated by
// ForwardProxy_STATUSGenerator()
var forwardProxy_STATUSGenerator gopter.Gen

// ForwardProxy_STATUSGenerator returns a generator of ForwardProxy_STATUS instances for property testing.
func ForwardProxy_STATUSGenerator() gopter.Gen {
	if forwardProxy_STATUSGenerator != nil {
		return forwardProxy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardProxy_STATUS(generators)
	forwardProxy_STATUSGenerator = gen.Struct(reflect.TypeOf(ForwardProxy_STATUS{}), generators)

	return forwardProxy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForForwardProxy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForForwardProxy_STATUS(gens map[string]gopter.Gen) {
	gens["Convention"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHostHeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomProtoHeaderName"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitHub_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitHub via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitHub, GitHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitHub runs a test to see if a specific instance of GitHub round trips to JSON and back losslessly
func RunJSONSerializationTestForGitHub(subject GitHub) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitHub
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitHub instances for property testing - lazily instantiated by GitHubGenerator()
var gitHubGenerator gopter.Gen

// GitHubGenerator returns a generator of GitHub instances for property testing.
// We first initialize gitHubGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func GitHubGenerator() gopter.Gen {
	if gitHubGenerator != nil {
		return gitHubGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitHub(generators)
	gitHubGenerator = gen.Struct(reflect.TypeOf(GitHub{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitHub(generators)
	AddRelatedPropertyGeneratorsForGitHub(generators)
	gitHubGenerator = gen.Struct(reflect.TypeOf(GitHub{}), generators)

	return gitHubGenerator
}

// AddIndependentPropertyGeneratorsForGitHub is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitHub(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForGitHub is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGitHub(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopesGenerator())
	gens["Registration"] = gen.PtrOf(ClientRegistrationGenerator())
}

func Test_GitHub_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitHub_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitHub_STATUS, GitHub_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitHub_STATUS runs a test to see if a specific instance of GitHub_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGitHub_STATUS(subject GitHub_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitHub_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitHub_STATUS instances for property testing - lazily instantiated by GitHub_STATUSGenerator()
var gitHub_STATUSGenerator gopter.Gen

// GitHub_STATUSGenerator returns a generator of GitHub_STATUS instances for property testing.
// We first initialize gitHub_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func GitHub_STATUSGenerator() gopter.Gen {
	if gitHub_STATUSGenerator != nil {
		return gitHub_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitHub_STATUS(generators)
	gitHub_STATUSGenerator = gen.Struct(reflect.TypeOf(GitHub_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitHub_STATUS(generators)
	AddRelatedPropertyGeneratorsForGitHub_STATUS(generators)
	gitHub_STATUSGenerator = gen.Struct(reflect.TypeOf(GitHub_STATUS{}), generators)

	return gitHub_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGitHub_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitHub_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForGitHub_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGitHub_STATUS(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopes_STATUSGenerator())
	gens["Registration"] = gen.PtrOf(ClientRegistration_STATUSGenerator())
}

func Test_GlobalValidation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GlobalValidation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGlobalValidation, GlobalValidationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGlobalValidation runs a test to see if a specific instance of GlobalValidation round trips to JSON and back losslessly
func RunJSONSerializationTestForGlobalValidation(subject GlobalValidation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GlobalValidation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GlobalValidation instances for property testing - lazily instantiated by GlobalValidationGenerator()
var globalValidationGenerator gopter.Gen

// GlobalValidationGenerator returns a generator of GlobalValidation instances for property testing.
func GlobalValidationGenerator() gopter.Gen {
	if globalValidationGenerator != nil {
		return globalValidationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGlobalValidation(generators)
	globalValidationGenerator = gen.Struct(reflect.TypeOf(GlobalValidation{}), generators)

	return globalValidationGenerator
}

// AddIndependentPropertyGeneratorsForGlobalValidation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGlobalValidation(gens map[string]gopter.Gen) {
	gens["ExcludedPaths"] = gen.SliceOf(gen.AlphaString())
	gens["RedirectToProvider"] = gen.PtrOf(gen.AlphaString())
	gens["UnauthenticatedClientAction"] = gen.PtrOf(gen.AlphaString())
}

func Test_GlobalValidation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GlobalValidation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGlobalValidation_STATUS, GlobalValidation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGlobalValidation_STATUS runs a test to see if a specific instance of GlobalValidation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGlobalValidation_STATUS(subject GlobalValidation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GlobalValidation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GlobalValidation_STATUS instances for property testing - lazily instantiated by
// GlobalValidation_STATUSGenerator()
var globalValidation_STATUSGenerator gopter.Gen

// GlobalValidation_STATUSGenerator returns a generator of GlobalValidation_STATUS instances for property testing.
func GlobalValidation_STATUSGenerator() gopter.Gen {
	if globalValidation_STATUSGenerator != nil {
		return globalValidation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGlobalValidation_STATUS(generators)
	globalValidation_STATUSGenerator = gen.Struct(reflect.TypeOf(GlobalValidation_STATUS{}), generators)

	return globalValidation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGlobalValidation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGlobalValidation_STATUS(gens map[string]gopter.Gen) {
	gens["ExcludedPaths"] = gen.SliceOf(gen.AlphaString())
	gens["RedirectToProvider"] = gen.PtrOf(gen.AlphaString())
	gens["UnauthenticatedClientAction"] = gen.PtrOf(gen.AlphaString())
}

func Test_Google_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Google via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGoogle, GoogleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGoogle runs a test to see if a specific instance of Google round trips to JSON and back losslessly
func RunJSONSerializationTestForGoogle(subject Google) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Google
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Google instances for property testing - lazily instantiated by GoogleGenerator()
var googleGenerator gopter.Gen

// GoogleGenerator returns a generator of Google instances for property testing.
// We first initialize googleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func GoogleGenerator() gopter.Gen {
	if googleGenerator != nil {
		return googleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGoogle(generators)
	googleGenerator = gen.Struct(reflect.TypeOf(Google{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGoogle(generators)
	AddRelatedPropertyGeneratorsForGoogle(generators)
	googleGenerator = gen.Struct(reflect.TypeOf(Google{}), generators)

	return googleGenerator
}

// AddIndependentPropertyGeneratorsForGoogle is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGoogle(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForGoogle is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGoogle(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopesGenerator())
	gens["Registration"] = gen.PtrOf(ClientRegistrationGenerator())
	gens["Validation"] = gen.PtrOf(AllowedAudiencesValidationGenerator())
}

func Test_Google_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Google_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGoogle_STATUS, Google_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGoogle_STATUS runs a test to see if a specific instance of Google_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGoogle_STATUS(subject Google_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Google_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Google_STATUS instances for property testing - lazily instantiated by Google_STATUSGenerator()
var google_STATUSGenerator gopter.Gen

// Google_STATUSGenerator returns a generator of Google_STATUS instances for property testing.
// We first initialize google_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Google_STATUSGenerator() gopter.Gen {
	if google_STATUSGenerator != nil {
		return google_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGoogle_STATUS(generators)
	google_STATUSGenerator = gen.Struct(reflect.TypeOf(Google_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGoogle_STATUS(generators)
	AddRelatedPropertyGeneratorsForGoogle_STATUS(generators)
	google_STATUSGenerator = gen.Struct(reflect.TypeOf(Google_STATUS{}), generators)

	return google_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGoogle_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGoogle_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForGoogle_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGoogle_STATUS(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopes_STATUSGenerator())
	gens["Registration"] = gen.PtrOf(ClientRegistration_STATUSGenerator())
	gens["Validation"] = gen.PtrOf(AllowedAudiencesValidation_STATUSGenerator())
}

func Test_HttpSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpSettings, HttpSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpSettings runs a test to see if a specific instance of HttpSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpSettings(subject HttpSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpSettings instances for property testing - lazily instantiated by HttpSettingsGenerator()
var httpSettingsGenerator gopter.Gen

// HttpSettingsGenerator returns a generator of HttpSettings instances for property testing.
// We first initialize httpSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HttpSettingsGenerator() gopter.Gen {
	if httpSettingsGenerator != nil {
		return httpSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettings(generators)
	httpSettingsGenerator = gen.Struct(reflect.TypeOf(HttpSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettings(generators)
	AddRelatedPropertyGeneratorsForHttpSettings(generators)
	httpSettingsGenerator = gen.Struct(reflect.TypeOf(HttpSettings{}), generators)

	return httpSettingsGenerator
}

// AddIndependentPropertyGeneratorsForHttpSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpSettings(gens map[string]gopter.Gen) {
	gens["RequireHttps"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForHttpSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHttpSettings(gens map[string]gopter.Gen) {
	gens["ForwardProxy"] = gen.PtrOf(ForwardProxyGenerator())
	gens["Routes"] = gen.PtrOf(HttpSettingsRoutesGenerator())
}

func Test_HttpSettingsRoutes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpSettingsRoutes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpSettingsRoutes, HttpSettingsRoutesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpSettingsRoutes runs a test to see if a specific instance of HttpSettingsRoutes round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpSettingsRoutes(subject HttpSettingsRoutes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpSettingsRoutes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpSettingsRoutes instances for property testing - lazily instantiated by HttpSettingsRoutesGenerator()
var httpSettingsRoutesGenerator gopter.Gen

// HttpSettingsRoutesGenerator returns a generator of HttpSettingsRoutes instances for property testing.
func HttpSettingsRoutesGenerator() gopter.Gen {
	if httpSettingsRoutesGenerator != nil {
		return httpSettingsRoutesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettingsRoutes(generators)
	httpSettingsRoutesGenerator = gen.Struct(reflect.TypeOf(HttpSettingsRoutes{}), generators)

	return httpSettingsRoutesGenerator
}

// AddIndependentPropertyGeneratorsForHttpSettingsRoutes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpSettingsRoutes(gens map[string]gopter.Gen) {
	gens["ApiPrefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_HttpSettingsRoutes_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpSettingsRoutes_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpSettingsRoutes_STATUS, HttpSettingsRoutes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpSettingsRoutes_STATUS runs a test to see if a specific instance of HttpSettingsRoutes_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpSettingsRoutes_STATUS(subject HttpSettingsRoutes_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpSettingsRoutes_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpSettingsRoutes_STATUS instances for property testing - lazily instantiated by
// HttpSettingsRoutes_STATUSGenerator()
var httpSettingsRoutes_STATUSGenerator gopter.Gen

// HttpSettingsRoutes_STATUSGenerator returns a generator of HttpSettingsRoutes_STATUS instances for property testing.
func HttpSettingsRoutes_STATUSGenerator() gopter.Gen {
	if httpSettingsRoutes_STATUSGenerator != nil {
		return httpSettingsRoutes_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettingsRoutes_STATUS(generators)
	httpSettingsRoutes_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpSettingsRoutes_STATUS{}), generators)

	return httpSettingsRoutes_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpSettingsRoutes_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpSettingsRoutes_STATUS(gens map[string]gopter.Gen) {
	gens["ApiPrefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_HttpSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpSettings_STATUS, HttpSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpSettings_STATUS runs a test to see if a specific instance of HttpSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpSettings_STATUS(subject HttpSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpSettings_STATUS instances for property testing - lazily instantiated by
// HttpSettings_STATUSGenerator()
var httpSettings_STATUSGenerator gopter.Gen

// HttpSettings_STATUSGenerator returns a generator of HttpSettings_STATUS instances for property testing.
// We first initialize httpSettings_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HttpSettings_STATUSGenerator() gopter.Gen {
	if httpSettings_STATUSGenerator != nil {
		return httpSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettings_STATUS(generators)
	httpSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpSettings_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettings_STATUS(generators)
	AddRelatedPropertyGeneratorsForHttpSettings_STATUS(generators)
	httpSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpSettings_STATUS{}), generators)

	return httpSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpSettings_STATUS(gens map[string]gopter.Gen) {
	gens["RequireHttps"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForHttpSettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHttpSettings_STATUS(gens map[string]gopter.Gen) {
	gens["ForwardProxy"] = gen.PtrOf(ForwardProxy_STATUSGenerator())
	gens["Routes"] = gen.PtrOf(HttpSettingsRoutes_STATUSGenerator())
}

func Test_IdentityProviders_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityProviders via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityProviders, IdentityProvidersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityProviders runs a test to see if a specific instance of IdentityProviders round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityProviders(subject IdentityProviders) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityProviders
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityProviders instances for property testing - lazily instantiated by IdentityProvidersGenerator()
var identityProvidersGenerator gopter.Gen

// IdentityProvidersGenerator returns a generator of IdentityProviders instances for property testing.
func IdentityProvidersGenerator() gopter.Gen {
	if identityProvidersGenerator != nil {
		return identityProvidersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForIdentityProviders(generators)
	identityProvidersGenerator = gen.Struct(reflect.TypeOf(IdentityProviders{}), generators)

	return identityProvidersGenerator
}

// AddRelatedPropertyGeneratorsForIdentityProviders is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityProviders(gens map[string]gopter.Gen) {
	gens["Apple"] = gen.PtrOf(AppleGenerator())
	gens["AzureActiveDirectory"] = gen.PtrOf(AzureActiveDirectoryGenerator())
	gens["AzureStaticWebApps"] = gen.PtrOf(AzureStaticWebAppsGenerator())
	gens["CustomOpenIdConnectProviders"] = gen.MapOf(
		gen.AlphaString(),
		CustomOpenIdConnectProviderGenerator())
	gens["Facebook"] = gen.PtrOf(FacebookGenerator())
	gens["GitHub"] = gen.PtrOf(GitHubGenerator())
	gens["Google"] = gen.PtrOf(GoogleGenerator())
	gens["Twitter"] = gen.PtrOf(TwitterGenerator())
}

func Test_IdentityProviders_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityProviders_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityProviders_STATUS, IdentityProviders_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityProviders_STATUS runs a test to see if a specific instance of IdentityProviders_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityProviders_STATUS(subject IdentityProviders_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityProviders_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityProviders_STATUS instances for property testing - lazily instantiated by
// IdentityProviders_STATUSGenerator()
var identityProviders_STATUSGenerator gopter.Gen

// IdentityProviders_STATUSGenerator returns a generator of IdentityProviders_STATUS instances for property testing.
func IdentityProviders_STATUSGenerator() gopter.Gen {
	if identityProviders_STATUSGenerator != nil {
		return identityProviders_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForIdentityProviders_STATUS(generators)
	identityProviders_STATUSGenerator = gen.Struct(reflect.TypeOf(IdentityProviders_STATUS{}), generators)

	return identityProviders_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForIdentityProviders_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityProviders_STATUS(gens map[string]gopter.Gen) {
	gens["Apple"] = gen.PtrOf(Apple_STATUSGenerator())
	gens["AzureActiveDirectory"] = gen.PtrOf(AzureActiveDirectory_STATUSGenerator())
	gens["AzureStaticWebApps"] = gen.PtrOf(AzureStaticWebApps_STATUSGenerator())
	gens["CustomOpenIdConnectProviders"] = gen.MapOf(
		gen.AlphaString(),
		CustomOpenIdConnectProvider_STATUSGenerator())
	gens["Facebook"] = gen.PtrOf(Facebook_STATUSGenerator())
	gens["GitHub"] = gen.PtrOf(GitHub_STATUSGenerator())
	gens["Google"] = gen.PtrOf(Google_STATUSGenerator())
	gens["Twitter"] = gen.PtrOf(Twitter_STATUSGenerator())
}

func Test_JwtClaimChecks_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JwtClaimChecks via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJwtClaimChecks, JwtClaimChecksGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJwtClaimChecks runs a test to see if a specific instance of JwtClaimChecks round trips to JSON and back losslessly
func RunJSONSerializationTestForJwtClaimChecks(subject JwtClaimChecks) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JwtClaimChecks
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JwtClaimChecks instances for property testing - lazily instantiated by JwtClaimChecksGenerator()
var jwtClaimChecksGenerator gopter.Gen

// JwtClaimChecksGenerator returns a generator of JwtClaimChecks instances for property testing.
func JwtClaimChecksGenerator() gopter.Gen {
	if jwtClaimChecksGenerator != nil {
		return jwtClaimChecksGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJwtClaimChecks(generators)
	jwtClaimChecksGenerator = gen.Struct(reflect.TypeOf(JwtClaimChecks{}), generators)

	return jwtClaimChecksGenerator
}

// AddIndependentPropertyGeneratorsForJwtClaimChecks is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJwtClaimChecks(gens map[string]gopter.Gen) {
	gens["AllowedClientApplications"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_JwtClaimChecks_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JwtClaimChecks_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJwtClaimChecks_STATUS, JwtClaimChecks_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJwtClaimChecks_STATUS runs a test to see if a specific instance of JwtClaimChecks_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForJwtClaimChecks_STATUS(subject JwtClaimChecks_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JwtClaimChecks_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JwtClaimChecks_STATUS instances for property testing - lazily instantiated by
// JwtClaimChecks_STATUSGenerator()
var jwtClaimChecks_STATUSGenerator gopter.Gen

// JwtClaimChecks_STATUSGenerator returns a generator of JwtClaimChecks_STATUS instances for property testing.
func JwtClaimChecks_STATUSGenerator() gopter.Gen {
	if jwtClaimChecks_STATUSGenerator != nil {
		return jwtClaimChecks_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJwtClaimChecks_STATUS(generators)
	jwtClaimChecks_STATUSGenerator = gen.Struct(reflect.TypeOf(JwtClaimChecks_STATUS{}), generators)

	return jwtClaimChecks_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForJwtClaimChecks_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJwtClaimChecks_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedClientApplications"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_Login_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Login via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogin, LoginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogin runs a test to see if a specific instance of Login round trips to JSON and back losslessly
func RunJSONSerializationTestForLogin(subject Login) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Login
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Login instances for property testing - lazily instantiated by LoginGenerator()
var loginGenerator gopter.Gen

// LoginGenerator returns a generator of Login instances for property testing.
// We first initialize loginGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoginGenerator() gopter.Gen {
	if loginGenerator != nil {
		return loginGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogin(generators)
	loginGenerator = gen.Struct(reflect.TypeOf(Login{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogin(generators)
	AddRelatedPropertyGeneratorsForLogin(generators)
	loginGenerator = gen.Struct(reflect.TypeOf(Login{}), generators)

	return loginGenerator
}

// AddIndependentPropertyGeneratorsForLogin is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogin(gens map[string]gopter.Gen) {
	gens["AllowedExternalRedirectUrls"] = gen.SliceOf(gen.AlphaString())
	gens["PreserveUrlFragmentsForLogins"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLogin is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogin(gens map[string]gopter.Gen) {
	gens["CookieExpiration"] = gen.PtrOf(CookieExpirationGenerator())
	gens["Nonce"] = gen.PtrOf(NonceGenerator())
	gens["Routes"] = gen.PtrOf(LoginRoutesGenerator())
	gens["TokenStore"] = gen.PtrOf(TokenStoreGenerator())
}

func Test_LoginRoutes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoginRoutes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoginRoutes, LoginRoutesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoginRoutes runs a test to see if a specific instance of LoginRoutes round trips to JSON and back losslessly
func RunJSONSerializationTestForLoginRoutes(subject LoginRoutes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoginRoutes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoginRoutes instances for property testing - lazily instantiated by LoginRoutesGenerator()
var loginRoutesGenerator gopter.Gen

// LoginRoutesGenerator returns a generator of LoginRoutes instances for property testing.
func LoginRoutesGenerator() gopter.Gen {
	if loginRoutesGenerator != nil {
		return loginRoutesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoginRoutes(generators)
	loginRoutesGenerator = gen.Struct(reflect.TypeOf(LoginRoutes{}), generators)

	return loginRoutesGenerator
}

// AddIndependentPropertyGeneratorsForLoginRoutes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoginRoutes(gens map[string]gopter.Gen) {
	gens["LogoutEndpoint"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoginRoutes_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoginRoutes_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoginRoutes_STATUS, LoginRoutes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoginRoutes_STATUS runs a test to see if a specific instance of LoginRoutes_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoginRoutes_STATUS(subject LoginRoutes_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoginRoutes_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoginRoutes_STATUS instances for property testing - lazily instantiated by LoginRoutes_STATUSGenerator()
var loginRoutes_STATUSGenerator gopter.Gen

// LoginRoutes_STATUSGenerator returns a generator of LoginRoutes_STATUS instances for property testing.
func LoginRoutes_STATUSGenerator() gopter.Gen {
	if loginRoutes_STATUSGenerator != nil {
		return loginRoutes_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoginRoutes_STATUS(generators)
	loginRoutes_STATUSGenerator = gen.Struct(reflect.TypeOf(LoginRoutes_STATUS{}), generators)

	return loginRoutes_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLoginRoutes_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoginRoutes_STATUS(gens map[string]gopter.Gen) {
	gens["LogoutEndpoint"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoginScopes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoginScopes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoginScopes, LoginScopesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoginScopes runs a test to see if a specific instance of LoginScopes round trips to JSON and back losslessly
func RunJSONSerializationTestForLoginScopes(subject LoginScopes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoginScopes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoginScopes instances for property testing - lazily instantiated by LoginScopesGenerator()
var loginScopesGenerator gopter.Gen

// LoginScopesGenerator returns a generator of LoginScopes instances for property testing.
func LoginScopesGenerator() gopter.Gen {
	if loginScopesGenerator != nil {
		return loginScopesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoginScopes(generators)
	loginScopesGenerator = gen.Struct(reflect.TypeOf(LoginScopes{}), generators)

	return loginScopesGenerator
}

// AddIndependentPropertyGeneratorsForLoginScopes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoginScopes(gens map[string]gopter.Gen) {
	gens["Scopes"] = gen.SliceOf(gen.AlphaString())
}

func Test_LoginScopes_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoginScopes_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoginScopes_STATUS, LoginScopes_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoginScopes_STATUS runs a test to see if a specific instance of LoginScopes_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoginScopes_STATUS(subject LoginScopes_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoginScopes_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoginScopes_STATUS instances for property testing - lazily instantiated by LoginScopes_STATUSGenerator()
var loginScopes_STATUSGenerator gopter.Gen

// LoginScopes_STATUSGenerator returns a generator of LoginScopes_STATUS instances for property testing.
func LoginScopes_STATUSGenerator() gopter.Gen {
	if loginScopes_STATUSGenerator != nil {
		return loginScopes_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoginScopes_STATUS(generators)
	loginScopes_STATUSGenerator = gen.Struct(reflect.TypeOf(LoginScopes_STATUS{}), generators)

	return loginScopes_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLoginScopes_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoginScopes_STATUS(gens map[string]gopter.Gen) {
	gens["Scopes"] = gen.SliceOf(gen.AlphaString())
}

func Test_Login_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Login_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogin_STATUS, Login_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogin_STATUS runs a test to see if a specific instance of Login_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogin_STATUS(subject Login_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Login_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Login_STATUS instances for property testing - lazily instantiated by Login_STATUSGenerator()
var login_STATUSGenerator gopter.Gen

// Login_STATUSGenerator returns a generator of Login_STATUS instances for property testing.
// We first initialize login_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Login_STATUSGenerator() gopter.Gen {
	if login_STATUSGenerator != nil {
		return login_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogin_STATUS(generators)
	login_STATUSGenerator = gen.Struct(reflect.TypeOf(Login_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogin_STATUS(generators)
	AddRelatedPropertyGeneratorsForLogin_STATUS(generators)
	login_STATUSGenerator = gen.Struct(reflect.TypeOf(Login_STATUS{}), generators)

	return login_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogin_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogin_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedExternalRedirectUrls"] = gen.SliceOf(gen.AlphaString())
	gens["PreserveUrlFragmentsForLogins"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLogin_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogin_STATUS(gens map[string]gopter.Gen) {
	gens["CookieExpiration"] = gen.PtrOf(CookieExpiration_STATUSGenerator())
	gens["Nonce"] = gen.PtrOf(Nonce_STATUSGenerator())
	gens["Routes"] = gen.PtrOf(LoginRoutes_STATUSGenerator())
	gens["TokenStore"] = gen.PtrOf(TokenStore_STATUSGenerator())
}

func Test_Nonce_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Nonce via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNonce, NonceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNonce runs a test to see if a specific instance of Nonce round trips to JSON and back losslessly
func RunJSONSerializationTestForNonce(subject Nonce) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Nonce
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Nonce instances for property testing - lazily instantiated by NonceGenerator()
var nonceGenerator gopter.Gen

// NonceGenerator returns a generator of Nonce instances for property testing.
func NonceGenerator() gopter.Gen {
	if nonceGenerator != nil {
		return nonceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNonce(generators)
	nonceGenerator = gen.Struct(reflect.TypeOf(Nonce{}), generators)

	return nonceGenerator
}

// AddIndependentPropertyGeneratorsForNonce is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNonce(gens map[string]gopter.Gen) {
	gens["NonceExpirationInterval"] = gen.PtrOf(gen.AlphaString())
	gens["ValidateNonce"] = gen.PtrOf(gen.Bool())
}

func Test_Nonce_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Nonce_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNonce_STATUS, Nonce_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNonce_STATUS runs a test to see if a specific instance of Nonce_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNonce_STATUS(subject Nonce_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Nonce_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Nonce_STATUS instances for property testing - lazily instantiated by Nonce_STATUSGenerator()
var nonce_STATUSGenerator gopter.Gen

// Nonce_STATUSGenerator returns a generator of Nonce_STATUS instances for property testing.
func Nonce_STATUSGenerator() gopter.Gen {
	if nonce_STATUSGenerator != nil {
		return nonce_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNonce_STATUS(generators)
	nonce_STATUSGenerator = gen.Struct(reflect.TypeOf(Nonce_STATUS{}), generators)

	return nonce_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNonce_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNonce_STATUS(gens map[string]gopter.Gen) {
	gens["NonceExpirationInterval"] = gen.PtrOf(gen.AlphaString())
	gens["ValidateNonce"] = gen.PtrOf(gen.Bool())
}

func Test_OpenIdConnectClientCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectClientCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectClientCredential, OpenIdConnectClientCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectClientCredential runs a test to see if a specific instance of OpenIdConnectClientCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectClientCredential(subject OpenIdConnectClientCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectClientCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectClientCredential instances for property testing - lazily instantiated by
// OpenIdConnectClientCredentialGenerator()
var openIdConnectClientCredentialGenerator gopter.Gen

// OpenIdConnectClientCredentialGenerator returns a generator of OpenIdConnectClientCredential instances for property testing.
func OpenIdConnectClientCredentialGenerator() gopter.Gen {
	if openIdConnectClientCredentialGenerator != nil {
		return openIdConnectClientCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential(generators)
	openIdConnectClientCredentialGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectClientCredential{}), generators)

	return openIdConnectClientCredentialGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential(gens map[string]gopter.Gen) {
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
	gens["Method"] = gen.PtrOf(gen.AlphaString())
}

func Test_OpenIdConnectClientCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectClientCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectClientCredential_STATUS, OpenIdConnectClientCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectClientCredential_STATUS runs a test to see if a specific instance of OpenIdConnectClientCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectClientCredential_STATUS(subject OpenIdConnectClientCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectClientCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectClientCredential_STATUS instances for property testing - lazily instantiated by
// OpenIdConnectClientCredential_STATUSGenerator()
var openIdConnectClientCredential_STATUSGenerator gopter.Gen

// OpenIdConnectClientCredential_STATUSGenerator returns a generator of OpenIdConnectClientCredential_STATUS instances for property testing.
func OpenIdConnectClientCredential_STATUSGenerator() gopter.Gen {
	if openIdConnectClientCredential_STATUSGenerator != nil {
		return openIdConnectClientCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential_STATUS(generators)
	openIdConnectClientCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectClientCredential_STATUS{}), generators)

	return openIdConnectClientCredential_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential_STATUS(gens map[string]gopter.Gen) {
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
	gens["Method"] = gen.PtrOf(gen.AlphaString())
}

func Test_OpenIdConnectConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectConfig, OpenIdConnectConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectConfig runs a test to see if a specific instance of OpenIdConnectConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectConfig(subject OpenIdConnectConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectConfig instances for property testing - lazily instantiated by
// OpenIdConnectConfigGenerator()
var openIdConnectConfigGenerator gopter.Gen

// OpenIdConnectConfigGenerator returns a generator of OpenIdConnectConfig instances for property testing.
func OpenIdConnectConfigGenerator() gopter.Gen {
	if openIdConnectConfigGenerator != nil {
		return openIdConnectConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectConfig(generators)
	openIdConnectConfigGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectConfig{}), generators)

	return openIdConnectConfigGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectConfig(gens map[string]gopter.Gen) {
	gens["AuthorizationEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["CertificationUri"] = gen.PtrOf(gen.AlphaString())
	gens["Issuer"] = gen.PtrOf(gen.AlphaString())
	gens["TokenEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["WellKnownOpenIdConfiguration"] = gen.PtrOf(gen.AlphaString())
}

func Test_OpenIdConnectConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectConfig_STATUS, OpenIdConnectConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectConfig_STATUS runs a test to see if a specific instance of OpenIdConnectConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectConfig_STATUS(subject OpenIdConnectConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectConfig_STATUS instances for property testing - lazily instantiated by
// OpenIdConnectConfig_STATUSGenerator()
var openIdConnectConfig_STATUSGenerator gopter.Gen

// OpenIdConnectConfig_STATUSGenerator returns a generator of OpenIdConnectConfig_STATUS instances for property testing.
func OpenIdConnectConfig_STATUSGenerator() gopter.Gen {
	if openIdConnectConfig_STATUSGenerator != nil {
		return openIdConnectConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectConfig_STATUS(generators)
	openIdConnectConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectConfig_STATUS{}), generators)

	return openIdConnectConfig_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectConfig_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectConfig_STATUS(gens map[string]gopter.Gen) {
	gens["AuthorizationEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["CertificationUri"] = gen.PtrOf(gen.AlphaString())
	gens["Issuer"] = gen.PtrOf(gen.AlphaString())
	gens["TokenEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["WellKnownOpenIdConfiguration"] = gen.PtrOf(gen.AlphaString())
}

func Test_OpenIdConnectLogin_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectLogin via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectLogin, OpenIdConnectLoginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectLogin runs a test to see if a specific instance of OpenIdConnectLogin round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectLogin(subject OpenIdConnectLogin) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectLogin
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectLogin instances for property testing - lazily instantiated by OpenIdConnectLoginGenerator()
var openIdConnectLoginGenerator gopter.Gen

// OpenIdConnectLoginGenerator returns a generator of OpenIdConnectLogin instances for property testing.
func OpenIdConnectLoginGenerator() gopter.Gen {
	if openIdConnectLoginGenerator != nil {
		return openIdConnectLoginGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectLogin(generators)
	openIdConnectLoginGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectLogin{}), generators)

	return openIdConnectLoginGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectLogin is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectLogin(gens map[string]gopter.Gen) {
	gens["NameClaimType"] = gen.PtrOf(gen.AlphaString())
	gens["Scopes"] = gen.SliceOf(gen.AlphaString())
}

func Test_OpenIdConnectLogin_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectLogin_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectLogin_STATUS, OpenIdConnectLogin_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectLogin_STATUS runs a test to see if a specific instance of OpenIdConnectLogin_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectLogin_STATUS(subject OpenIdConnectLogin_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectLogin_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectLogin_STATUS instances for property testing - lazily instantiated by
// OpenIdConnectLogin_STATUSGenerator()
var openIdConnectLogin_STATUSGenerator gopter.Gen

// OpenIdConnectLogin_STATUSGenerator returns a generator of OpenIdConnectLogin_STATUS instances for property testing.
func OpenIdConnectLogin_STATUSGenerator() gopter.Gen {
	if openIdConnectLogin_STATUSGenerator != nil {
		return openIdConnectLogin_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectLogin_STATUS(generators)
	openIdConnectLogin_STATUSGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectLogin_STATUS{}), generators)

	return openIdConnectLogin_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectLogin_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectLogin_STATUS(gens map[string]gopter.Gen) {
	gens["NameClaimType"] = gen.PtrOf(gen.AlphaString())
	gens["Scopes"] = gen.SliceOf(gen.AlphaString())
}

func Test_OpenIdConnectRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectRegistration, OpenIdConnectRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectRegistration runs a test to see if a specific instance of OpenIdConnectRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectRegistration(subject OpenIdConnectRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectRegistration instances for property testing - lazily instantiated by
// OpenIdConnectRegistrationGenerator()
var openIdConnectRegistrationGenerator gopter.Gen

// OpenIdConnectRegistrationGenerator returns a generator of OpenIdConnectRegistration instances for property testing.
// We first initialize openIdConnectRegistrationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OpenIdConnectRegistrationGenerator() gopter.Gen {
	if openIdConnectRegistrationGenerator != nil {
		return openIdConnectRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectRegistration(generators)
	openIdConnectRegistrationGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectRegistration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectRegistration(generators)
	AddRelatedPropertyGeneratorsForOpenIdConnectRegistration(generators)
	openIdConnectRegistrationGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectRegistration{}), generators)

	return openIdConnectRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOpenIdConnectRegistration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenIdConnectRegistration(gens map[string]gopter.Gen) {
	gens["ClientCredential"] = gen.PtrOf(OpenIdConnectClientCredentialGenerator())
	gens["OpenIdConnectConfiguration"] = gen.PtrOf(OpenIdConnectConfigGenerator())
}

func Test_OpenIdConnectRegistration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectRegistration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectRegistration_STATUS, OpenIdConnectRegistration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectRegistration_STATUS runs a test to see if a specific instance of OpenIdConnectRegistration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectRegistration_STATUS(subject OpenIdConnectRegistration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectRegistration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectRegistration_STATUS instances for property testing - lazily instantiated by
// OpenIdConnectRegistration_STATUSGenerator()
var openIdConnectRegistration_STATUSGenerator gopter.Gen

// OpenIdConnectRegistration_STATUSGenerator returns a generator of OpenIdConnectRegistration_STATUS instances for property testing.
// We first initialize openIdConnectRegistration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OpenIdConnectRegistration_STATUSGenerator() gopter.Gen {
	if openIdConnectRegistration_STATUSGenerator != nil {
		return openIdConnectRegistration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectRegistration_STATUS(generators)
	openIdConnectRegistration_STATUSGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectRegistration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectRegistration_STATUS(generators)
	AddRelatedPropertyGeneratorsForOpenIdConnectRegistration_STATUS(generators)
	openIdConnectRegistration_STATUSGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectRegistration_STATUS{}), generators)

	return openIdConnectRegistration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectRegistration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectRegistration_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOpenIdConnectRegistration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenIdConnectRegistration_STATUS(gens map[string]gopter.Gen) {
	gens["ClientCredential"] = gen.PtrOf(OpenIdConnectClientCredential_STATUSGenerator())
	gens["OpenIdConnectConfiguration"] = gen.PtrOf(OpenIdConnectConfig_STATUSGenerator())
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_TokenStore_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenStore via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenStore, TokenStoreGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenStore runs a test to see if a specific instance of TokenStore round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenStore(subject TokenStore) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenStore
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenStore instances for property testing - lazily instantiated by TokenStoreGenerator()
var tokenStoreGenerator gopter.Gen

// TokenStoreGenerator returns a generator of TokenStore instances for property testing.
// We first initialize tokenStoreGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TokenStoreGenerator() gopter.Gen {
	if tokenStoreGenerator != nil {
		return tokenStoreGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenStore(generators)
	tokenStoreGenerator = gen.Struct(reflect.TypeOf(TokenStore{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenStore(generators)
	AddRelatedPropertyGeneratorsForTokenStore(generators)
	tokenStoreGenerator = gen.Struct(reflect.TypeOf(TokenStore{}), generators)

	return tokenStoreGenerator
}

// AddIndependentPropertyGeneratorsForTokenStore is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenStore(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["TokenRefreshExtensionHours"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForTokenStore is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenStore(gens map[string]gopter.Gen) {
	gens["AzureBlobStorage"] = gen.PtrOf(BlobStorageTokenStoreGenerator())
}

func Test_TokenStore_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenStore_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenStore_STATUS, TokenStore_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenStore_STATUS runs a test to see if a specific instance of TokenStore_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenStore_STATUS(subject TokenStore_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenStore_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenStore_STATUS instances for property testing - lazily instantiated by TokenStore_STATUSGenerator()
var tokenStore_STATUSGenerator gopter.Gen

// TokenStore_STATUSGenerator returns a generator of TokenStore_STATUS instances for property testing.
// We first initialize tokenStore_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TokenStore_STATUSGenerator() gopter.Gen {
	if tokenStore_STATUSGenerator != nil {
		return tokenStore_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenStore_STATUS(generators)
	tokenStore_STATUSGenerator = gen.Struct(reflect.TypeOf(TokenStore_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenStore_STATUS(generators)
	AddRelatedPropertyGeneratorsForTokenStore_STATUS(generators)
	tokenStore_STATUSGenerator = gen.Struct(reflect.TypeOf(TokenStore_STATUS{}), generators)

	return tokenStore_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTokenStore_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenStore_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["TokenRefreshExtensionHours"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForTokenStore_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenStore_STATUS(gens map[string]gopter.Gen) {
	gens["AzureBlobStorage"] = gen.PtrOf(BlobStorageTokenStore_STATUSGenerator())
}

func Test_Twitter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Twitter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTwitter, TwitterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTwitter runs a test to see if a specific instance of Twitter round trips to JSON and back losslessly
func RunJSONSerializationTestForTwitter(subject Twitter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Twitter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Twitter instances for property testing - lazily instantiated by TwitterGenerator()
var twitterGenerator gopter.Gen

// TwitterGenerator returns a generator of Twitter instances for property testing.
// We first initialize twitterGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TwitterGenerator() gopter.Gen {
	if twitterGenerator != nil {
		return twitterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitter(generators)
	twitterGenerator = gen.Struct(reflect.TypeOf(Twitter{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitter(generators)
	AddRelatedPropertyGeneratorsForTwitter(generators)
	twitterGenerator = gen.Struct(reflect.TypeOf(Twitter{}), generators)

	return twitterGenerator
}

// AddIndependentPropertyGeneratorsForTwitter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTwitter(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForTwitter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTwitter(gens map[string]gopter.Gen) {
	gens["Registration"] = gen.PtrOf(TwitterRegistrationGenerator())
}

func Test_TwitterRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TwitterRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTwitterRegistration, TwitterRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTwitterRegistration runs a test to see if a specific instance of TwitterRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForTwitterRegistration(subject TwitterRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TwitterRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TwitterRegistration instances for property testing - lazily instantiated by
// TwitterRegistrationGenerator()
var twitterRegistrationGenerator gopter.Gen

// TwitterRegistrationGenerator returns a generator of TwitterRegistration instances for property testing.
func TwitterRegistrationGenerator() gopter.Gen {
	if twitterRegistrationGenerator != nil {
		return twitterRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitterRegistration(generators)
	twitterRegistrationGenerator = gen.Struct(reflect.TypeOf(TwitterRegistration{}), generators)

	return twitterRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForTwitterRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTwitterRegistration(gens map[string]gopter.Gen) {
	gens["ConsumerKey"] = gen.PtrOf(gen.AlphaString())
	gens["ConsumerSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_TwitterRegistration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TwitterRegistration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTwitterRegistration_STATUS, TwitterRegistration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTwitterRegistration_STATUS runs a test to see if a specific instance of TwitterRegistration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTwitterRegistration_STATUS(subject TwitterRegistration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TwitterRegistration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TwitterRegistration_STATUS instances for property testing - lazily instantiated by
// TwitterRegistration_STATUSGenerator()
var twitterRegistration_STATUSGenerator gopter.Gen

// TwitterRegistration_STATUSGenerator returns a generator of TwitterRegistration_STATUS instances for property testing.
func TwitterRegistration_STATUSGenerator() gopter.Gen {
	if twitterRegistration_STATUSGenerator != nil {
		return twitterRegistration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitterRegistration_STATUS(generators)
	twitterRegistration_STATUSGenerator = gen.Struct(reflect.TypeOf(TwitterRegistration_STATUS{}), generators)

	return twitterRegistration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTwitterRegistration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTwitterRegistration_STATUS(gens map[string]gopter.Gen) {
	gens["ConsumerKey"] = gen.PtrOf(gen.AlphaString())
	gens["ConsumerSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Twitter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Twitter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTwitter_STATUS, Twitter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTwitter_STATUS runs a test to see if a specific instance of Twitter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTwitter_STATUS(subject Twitter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Twitter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Twitter_STATUS instances for property testing - lazily instantiated by Twitter_STATUSGenerator()
var twitter_STATUSGenerator gopter.Gen

// Twitter_STATUSGenerator returns a generator of Twitter_STATUS instances for property testing.
// We first initialize twitter_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Twitter_STATUSGenerator() gopter.Gen {
	if twitter_STATUSGenerator != nil {
		return twitter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitter_STATUS(generators)
	twitter_STATUSGenerator = gen.Struct(reflect.TypeOf(Twitter_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitter_STATUS(generators)
	AddRelatedPropertyGeneratorsForTwitter_STATUS(generators)
	twitter_STATUSGenerator = gen.Struct(reflect.TypeOf(Twitter_STATUS{}), generators)

	return twitter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTwitter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTwitter_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForTwitter_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTwitter_STATUS(gens map[string]gopter.Gen) {
	gens["Registration"] = gen.PtrOf(TwitterRegistration_STATUSGenerator())
}
