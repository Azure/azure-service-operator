// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"context"
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/storage"
	"github.com/Azure/azure-service-operator/v2/internal/genericarmclient"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/go-logr/logr"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,app}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/stable/2024-03-01/ContainerApps.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}
type ContainerApp struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ContainerApp_Spec   `json:"spec,omitempty"`
	Status            ContainerApp_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ContainerApp{}

// GetConditions returns the conditions of the resource
func (containerApp *ContainerApp) GetConditions() conditions.Conditions {
	return containerApp.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (containerApp *ContainerApp) SetConditions(conditions conditions.Conditions) {
	containerApp.Status.Conditions = conditions
}

var _ conversion.Convertible = &ContainerApp{}

// ConvertFrom populates our ContainerApp from the provided hub ContainerApp
func (containerApp *ContainerApp) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.ContainerApp)
	if !ok {
		return fmt.Errorf("expected app/v1api20240301/storage/ContainerApp but received %T instead", hub)
	}

	return containerApp.AssignProperties_From_ContainerApp(source)
}

// ConvertTo populates the provided hub ContainerApp from our ContainerApp
func (containerApp *ContainerApp) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.ContainerApp)
	if !ok {
		return fmt.Errorf("expected app/v1api20240301/storage/ContainerApp but received %T instead", hub)
	}

	return containerApp.AssignProperties_To_ContainerApp(destination)
}

var _ configmaps.Exporter = &ContainerApp{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (containerApp *ContainerApp) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if containerApp.Spec.OperatorSpec == nil {
		return nil
	}
	return containerApp.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ContainerApp{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (containerApp *ContainerApp) SecretDestinationExpressions() []*core.DestinationExpression {
	if containerApp.Spec.OperatorSpec == nil {
		return nil
	}
	return containerApp.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &ContainerApp{}

// InitializeSpec initializes the spec for this resource from the given status
func (containerApp *ContainerApp) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*ContainerApp_STATUS); ok {
		return containerApp.Spec.Initialize_From_ContainerApp_STATUS(s)
	}

	return fmt.Errorf("expected Status of type ContainerApp_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesConfigExporter = &ContainerApp{}

// ExportKubernetesConfigMaps defines a resource which can create ConfigMaps in Kubernetes.
func (containerApp *ContainerApp) ExportKubernetesConfigMaps(_ context.Context, _ genruntime.MetaObject, _ *genericarmclient.GenericClient, _ logr.Logger) ([]client.Object, error) {
	collector := configmaps.NewCollector(containerApp.Namespace)
	if containerApp.Spec.OperatorSpec != nil && containerApp.Spec.OperatorSpec.ConfigMaps != nil {
		if containerApp.Status.EventStreamEndpoint != nil {
			collector.AddValue(containerApp.Spec.OperatorSpec.ConfigMaps.EventStreamEndpoint, *containerApp.Status.EventStreamEndpoint)
		}
	}
	if containerApp.Spec.OperatorSpec != nil && containerApp.Spec.OperatorSpec.ConfigMaps != nil {
		if containerApp.Status.LatestRevisionFqdn != nil {
			collector.AddValue(containerApp.Spec.OperatorSpec.ConfigMaps.Fqdn, *containerApp.Status.LatestRevisionFqdn)
		}
	}
	result, err := collector.Values()
	if err != nil {
		return nil, err
	}
	return configmaps.SliceToClientObjectSlice(result), nil
}

var _ genruntime.KubernetesResource = &ContainerApp{}

// AzureName returns the Azure name of the resource
func (containerApp *ContainerApp) AzureName() string {
	return containerApp.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (containerApp ContainerApp) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (containerApp *ContainerApp) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (containerApp *ContainerApp) GetSpec() genruntime.ConvertibleSpec {
	return &containerApp.Spec
}

// GetStatus returns the status of this resource
func (containerApp *ContainerApp) GetStatus() genruntime.ConvertibleStatus {
	return &containerApp.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (containerApp *ContainerApp) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.App/containerApps"
func (containerApp *ContainerApp) GetType() string {
	return "Microsoft.App/containerApps"
}

// NewEmptyStatus returns a new empty (blank) status
func (containerApp *ContainerApp) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ContainerApp_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (containerApp *ContainerApp) Owner() *genruntime.ResourceReference {
	if containerApp.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(containerApp.Spec)
	return containerApp.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (containerApp *ContainerApp) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ContainerApp_STATUS); ok {
		containerApp.Status = *st
		return nil
	}

	// Convert status to required version
	var st ContainerApp_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	containerApp.Status = st
	return nil
}

// AssignProperties_From_ContainerApp populates our ContainerApp from the provided source ContainerApp
func (containerApp *ContainerApp) AssignProperties_From_ContainerApp(source *storage.ContainerApp) error {

	// ObjectMeta
	containerApp.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ContainerApp_Spec
	err := spec.AssignProperties_From_ContainerApp_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ContainerApp_Spec() to populate field Spec")
	}
	containerApp.Spec = spec

	// Status
	var status ContainerApp_STATUS
	err = status.AssignProperties_From_ContainerApp_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ContainerApp_STATUS() to populate field Status")
	}
	containerApp.Status = status

	// No error
	return nil
}

// AssignProperties_To_ContainerApp populates the provided destination ContainerApp from our ContainerApp
func (containerApp *ContainerApp) AssignProperties_To_ContainerApp(destination *storage.ContainerApp) error {

	// ObjectMeta
	destination.ObjectMeta = *containerApp.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ContainerApp_Spec
	err := containerApp.Spec.AssignProperties_To_ContainerApp_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ContainerApp_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ContainerApp_STATUS
	err = containerApp.Status.AssignProperties_To_ContainerApp_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ContainerApp_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (containerApp *ContainerApp) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: containerApp.Spec.OriginalVersion(),
		Kind:    "ContainerApp",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/stable/2024-03-01/ContainerApps.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}
type ContainerAppList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ContainerApp `json:"items"`
}

type ContainerApp_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Configuration: Non versioned Container App configuration properties.
	Configuration *Configuration `json:"configuration,omitempty"`

	// EnvironmentReference: Resource ID of environment.
	EnvironmentReference *genruntime.ResourceReference `armReference:"EnvironmentId" json:"environmentReference,omitempty"`

	// ExtendedLocation: The complex type of the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// Identity: managed identities for the Container App to interact with other Azure services without maintaining any secrets
	// or credentials in code.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// ManagedByReference: The fully qualified resource ID of the resource that manages this resource. Indicates if this
	// resource is managed by another Azure resource. If this is present, complete mode deployment will not delete the resource
	// if it is removed from the template since it is managed by another resource.
	ManagedByReference *genruntime.ResourceReference `armReference:"ManagedBy" json:"managedByReference,omitempty"`

	// ManagedEnvironmentReference: Deprecated. Resource ID of the Container App's environment.
	ManagedEnvironmentReference *genruntime.ResourceReference `armReference:"ManagedEnvironmentId" json:"managedEnvironmentReference,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ContainerAppOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Template: Container App versioned application definition.
	Template *Template `json:"template,omitempty"`

	// WorkloadProfileName: Workload profile name to pin for container app execution.
	WorkloadProfileName *string `json:"workloadProfileName,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerApp_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containerApp *ContainerApp_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containerApp == nil {
		return nil, nil
	}
	result := &arm.ContainerApp_Spec{}

	// Set property "ExtendedLocation":
	if containerApp.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*containerApp.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*arm.ExtendedLocation)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property "Identity":
	if containerApp.Identity != nil {
		identity_ARM, err := (*containerApp.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if containerApp.Location != nil {
		location := *containerApp.Location
		result.Location = &location
	}

	// Set property "ManagedBy":
	if containerApp.ManagedByReference != nil {
		managedByReferenceARMID, err := resolved.ResolvedReferences.Lookup(*containerApp.ManagedByReference)
		if err != nil {
			return nil, err
		}
		managedByReference := managedByReferenceARMID
		result.ManagedBy = &managedByReference
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if containerApp.Configuration != nil ||
		containerApp.EnvironmentReference != nil ||
		containerApp.ManagedEnvironmentReference != nil ||
		containerApp.Template != nil ||
		containerApp.WorkloadProfileName != nil {
		result.Properties = &arm.ContainerApp_Properties_Spec{}
	}
	if containerApp.Configuration != nil {
		configuration_ARM, err := (*containerApp.Configuration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		configuration := *configuration_ARM.(*arm.Configuration)
		result.Properties.Configuration = &configuration
	}
	if containerApp.EnvironmentReference != nil {
		environmentIdARMID, err := resolved.ResolvedReferences.Lookup(*containerApp.EnvironmentReference)
		if err != nil {
			return nil, err
		}
		environmentId := environmentIdARMID
		result.Properties.EnvironmentId = &environmentId
	}
	if containerApp.ManagedEnvironmentReference != nil {
		managedEnvironmentIdARMID, err := resolved.ResolvedReferences.Lookup(*containerApp.ManagedEnvironmentReference)
		if err != nil {
			return nil, err
		}
		managedEnvironmentId := managedEnvironmentIdARMID
		result.Properties.ManagedEnvironmentId = &managedEnvironmentId
	}
	if containerApp.Template != nil {
		template_ARM, err := (*containerApp.Template).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		template := *template_ARM.(*arm.Template)
		result.Properties.Template = &template
	}
	if containerApp.WorkloadProfileName != nil {
		workloadProfileName := *containerApp.WorkloadProfileName
		result.Properties.WorkloadProfileName = &workloadProfileName
	}

	// Set property "Tags":
	if containerApp.Tags != nil {
		result.Tags = make(map[string]string, len(containerApp.Tags))
		for key, value := range containerApp.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerApp *ContainerApp_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerApp_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerApp *ContainerApp_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerApp_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerApp_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	containerApp.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Configuration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Configuration != nil {
			var configuration1 Configuration
			err := configuration1.PopulateFromARM(owner, *typedInput.Properties.Configuration)
			if err != nil {
				return err
			}
			configuration := configuration1
			containerApp.Configuration = &configuration
		}
	}

	// no assignment for property "EnvironmentReference"

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		containerApp.ExtendedLocation = &extendedLocation
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		containerApp.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		containerApp.Location = &location
	}

	// no assignment for property "ManagedByReference"

	// no assignment for property "ManagedEnvironmentReference"

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	containerApp.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		containerApp.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			containerApp.Tags[key] = value
		}
	}

	// Set property "Template":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Template != nil {
			var template1 Template
			err := template1.PopulateFromARM(owner, *typedInput.Properties.Template)
			if err != nil {
				return err
			}
			template := template1
			containerApp.Template = &template
		}
	}

	// Set property "WorkloadProfileName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkloadProfileName != nil {
			workloadProfileName := *typedInput.Properties.WorkloadProfileName
			containerApp.WorkloadProfileName = &workloadProfileName
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ContainerApp_Spec{}

// ConvertSpecFrom populates our ContainerApp_Spec from the provided source
func (containerApp *ContainerApp_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ContainerApp_Spec)
	if ok {
		// Populate our instance from source
		return containerApp.AssignProperties_From_ContainerApp_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ContainerApp_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = containerApp.AssignProperties_From_ContainerApp_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ContainerApp_Spec
func (containerApp *ContainerApp_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ContainerApp_Spec)
	if ok {
		// Populate destination from our instance
		return containerApp.AssignProperties_To_ContainerApp_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ContainerApp_Spec{}
	err := containerApp.AssignProperties_To_ContainerApp_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ContainerApp_Spec populates our ContainerApp_Spec from the provided source ContainerApp_Spec
func (containerApp *ContainerApp_Spec) AssignProperties_From_ContainerApp_Spec(source *storage.ContainerApp_Spec) error {

	// AzureName
	containerApp.AzureName = source.AzureName

	// Configuration
	if source.Configuration != nil {
		var configuration Configuration
		err := configuration.AssignProperties_From_Configuration(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Configuration() to populate field Configuration")
		}
		containerApp.Configuration = &configuration
	} else {
		containerApp.Configuration = nil
	}

	// EnvironmentReference
	if source.EnvironmentReference != nil {
		environmentReference := source.EnvironmentReference.Copy()
		containerApp.EnvironmentReference = &environmentReference
	} else {
		containerApp.EnvironmentReference = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		containerApp.ExtendedLocation = &extendedLocation
	} else {
		containerApp.ExtendedLocation = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		containerApp.Identity = &identity
	} else {
		containerApp.Identity = nil
	}

	// Location
	containerApp.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedByReference
	if source.ManagedByReference != nil {
		managedByReference := source.ManagedByReference.Copy()
		containerApp.ManagedByReference = &managedByReference
	} else {
		containerApp.ManagedByReference = nil
	}

	// ManagedEnvironmentReference
	if source.ManagedEnvironmentReference != nil {
		managedEnvironmentReference := source.ManagedEnvironmentReference.Copy()
		containerApp.ManagedEnvironmentReference = &managedEnvironmentReference
	} else {
		containerApp.ManagedEnvironmentReference = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ContainerAppOperatorSpec
		err := operatorSpec.AssignProperties_From_ContainerAppOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppOperatorSpec() to populate field OperatorSpec")
		}
		containerApp.OperatorSpec = &operatorSpec
	} else {
		containerApp.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		containerApp.Owner = &owner
	} else {
		containerApp.Owner = nil
	}

	// Tags
	containerApp.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template Template
		err := template.AssignProperties_From_Template(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Template() to populate field Template")
		}
		containerApp.Template = &template
	} else {
		containerApp.Template = nil
	}

	// WorkloadProfileName
	containerApp.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// No error
	return nil
}

// AssignProperties_To_ContainerApp_Spec populates the provided destination ContainerApp_Spec from our ContainerApp_Spec
func (containerApp *ContainerApp_Spec) AssignProperties_To_ContainerApp_Spec(destination *storage.ContainerApp_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = containerApp.AzureName

	// Configuration
	if containerApp.Configuration != nil {
		var configuration storage.Configuration
		err := containerApp.Configuration.AssignProperties_To_Configuration(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Configuration() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// EnvironmentReference
	if containerApp.EnvironmentReference != nil {
		environmentReference := containerApp.EnvironmentReference.Copy()
		destination.EnvironmentReference = &environmentReference
	} else {
		destination.EnvironmentReference = nil
	}

	// ExtendedLocation
	if containerApp.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation
		err := containerApp.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Identity
	if containerApp.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := containerApp.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(containerApp.Location)

	// ManagedByReference
	if containerApp.ManagedByReference != nil {
		managedByReference := containerApp.ManagedByReference.Copy()
		destination.ManagedByReference = &managedByReference
	} else {
		destination.ManagedByReference = nil
	}

	// ManagedEnvironmentReference
	if containerApp.ManagedEnvironmentReference != nil {
		managedEnvironmentReference := containerApp.ManagedEnvironmentReference.Copy()
		destination.ManagedEnvironmentReference = &managedEnvironmentReference
	} else {
		destination.ManagedEnvironmentReference = nil
	}

	// OperatorSpec
	if containerApp.OperatorSpec != nil {
		var operatorSpec storage.ContainerAppOperatorSpec
		err := containerApp.OperatorSpec.AssignProperties_To_ContainerAppOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = containerApp.OriginalVersion()

	// Owner
	if containerApp.Owner != nil {
		owner := containerApp.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(containerApp.Tags)

	// Template
	if containerApp.Template != nil {
		var template storage.Template
		err := containerApp.Template.AssignProperties_To_Template(&template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Template() to populate field Template")
		}
		destination.Template = &template
	} else {
		destination.Template = nil
	}

	// WorkloadProfileName
	destination.WorkloadProfileName = genruntime.ClonePointerToString(containerApp.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerApp_STATUS populates our ContainerApp_Spec from the provided source ContainerApp_STATUS
func (containerApp *ContainerApp_Spec) Initialize_From_ContainerApp_STATUS(source *ContainerApp_STATUS) error {

	// Configuration
	if source.Configuration != nil {
		var configuration Configuration
		err := configuration.Initialize_From_Configuration_STATUS(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Configuration_STATUS() to populate field Configuration")
		}
		containerApp.Configuration = &configuration
	} else {
		containerApp.Configuration = nil
	}

	// EnvironmentReference
	if source.EnvironmentId != nil {
		environmentReference := genruntime.CreateResourceReferenceFromARMID(*source.EnvironmentId)
		containerApp.EnvironmentReference = &environmentReference
	} else {
		containerApp.EnvironmentReference = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.Initialize_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		containerApp.ExtendedLocation = &extendedLocation
	} else {
		containerApp.ExtendedLocation = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		containerApp.Identity = &identity
	} else {
		containerApp.Identity = nil
	}

	// Location
	containerApp.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedEnvironmentReference
	if source.ManagedEnvironmentId != nil {
		managedEnvironmentReference := genruntime.CreateResourceReferenceFromARMID(*source.ManagedEnvironmentId)
		containerApp.ManagedEnvironmentReference = &managedEnvironmentReference
	} else {
		containerApp.ManagedEnvironmentReference = nil
	}

	// Tags
	containerApp.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template Template
		err := template.Initialize_From_Template_STATUS(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Template_STATUS() to populate field Template")
		}
		containerApp.Template = &template
	} else {
		containerApp.Template = nil
	}

	// WorkloadProfileName
	containerApp.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (containerApp *ContainerApp_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (containerApp *ContainerApp_Spec) SetAzureName(azureName string) {
	containerApp.AzureName = azureName
}

// Container App.
type ContainerApp_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Configuration: Non versioned Container App configuration properties.
	Configuration *Configuration_STATUS `json:"configuration,omitempty"`

	// CustomDomainVerificationId: Id used to verify domain name ownership
	CustomDomainVerificationId *string `json:"customDomainVerificationId,omitempty"`

	// EnvironmentId: Resource ID of environment.
	EnvironmentId *string `json:"environmentId,omitempty"`

	// EventStreamEndpoint: The endpoint of the eventstream of the container app.
	EventStreamEndpoint *string `json:"eventStreamEndpoint,omitempty"`

	// ExtendedLocation: The complex type of the extended location.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: managed identities for the Container App to interact with other Azure services without maintaining any secrets
	// or credentials in code.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// LatestReadyRevisionName: Name of the latest ready revision of the Container App.
	LatestReadyRevisionName *string `json:"latestReadyRevisionName,omitempty"`

	// LatestRevisionFqdn: Fully Qualified Domain Name of the latest revision of the Container App.
	LatestRevisionFqdn *string `json:"latestRevisionFqdn,omitempty"`

	// LatestRevisionName: Name of the latest revision of the Container App.
	LatestRevisionName *string `json:"latestRevisionName,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// ManagedBy: The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is
	// managed by another Azure resource. If this is present, complete mode deployment will not delete the resource if it is
	// removed from the template since it is managed by another resource.
	ManagedBy *string `json:"managedBy,omitempty"`

	// ManagedEnvironmentId: Deprecated. Resource ID of the Container App's environment.
	ManagedEnvironmentId *string `json:"managedEnvironmentId,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// OutboundIpAddresses: Outbound IP Addresses for container app.
	OutboundIpAddresses []string `json:"outboundIpAddresses,omitempty"`

	// ProvisioningState: Provisioning state of the Container App.
	ProvisioningState *ContainerApp_Properties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Template: Container App versioned application definition.
	Template *Template_STATUS `json:"template,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// WorkloadProfileName: Workload profile name to pin for container app execution.
	WorkloadProfileName *string `json:"workloadProfileName,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ContainerApp_STATUS{}

// ConvertStatusFrom populates our ContainerApp_STATUS from the provided source
func (containerApp *ContainerApp_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ContainerApp_STATUS)
	if ok {
		// Populate our instance from source
		return containerApp.AssignProperties_From_ContainerApp_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.ContainerApp_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = containerApp.AssignProperties_From_ContainerApp_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ContainerApp_STATUS
func (containerApp *ContainerApp_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ContainerApp_STATUS)
	if ok {
		// Populate destination from our instance
		return containerApp.AssignProperties_To_ContainerApp_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ContainerApp_STATUS{}
	err := containerApp.AssignProperties_To_ContainerApp_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ContainerApp_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerApp *ContainerApp_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerApp_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerApp *ContainerApp_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerApp_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerApp_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Configuration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Configuration != nil {
			var configuration1 Configuration_STATUS
			err := configuration1.PopulateFromARM(owner, *typedInput.Properties.Configuration)
			if err != nil {
				return err
			}
			configuration := configuration1
			containerApp.Configuration = &configuration
		}
	}

	// Set property "CustomDomainVerificationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainVerificationId != nil {
			customDomainVerificationId := *typedInput.Properties.CustomDomainVerificationId
			containerApp.CustomDomainVerificationId = &customDomainVerificationId
		}
	}

	// Set property "EnvironmentId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnvironmentId != nil {
			environmentId := *typedInput.Properties.EnvironmentId
			containerApp.EnvironmentId = &environmentId
		}
	}

	// Set property "EventStreamEndpoint":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EventStreamEndpoint != nil {
			eventStreamEndpoint := *typedInput.Properties.EventStreamEndpoint
			containerApp.EventStreamEndpoint = &eventStreamEndpoint
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		containerApp.ExtendedLocation = &extendedLocation
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		containerApp.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		containerApp.Identity = &identity
	}

	// Set property "LatestReadyRevisionName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LatestReadyRevisionName != nil {
			latestReadyRevisionName := *typedInput.Properties.LatestReadyRevisionName
			containerApp.LatestReadyRevisionName = &latestReadyRevisionName
		}
	}

	// Set property "LatestRevisionFqdn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LatestRevisionFqdn != nil {
			latestRevisionFqdn := *typedInput.Properties.LatestRevisionFqdn
			containerApp.LatestRevisionFqdn = &latestRevisionFqdn
		}
	}

	// Set property "LatestRevisionName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LatestRevisionName != nil {
			latestRevisionName := *typedInput.Properties.LatestRevisionName
			containerApp.LatestRevisionName = &latestRevisionName
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		containerApp.Location = &location
	}

	// Set property "ManagedBy":
	if typedInput.ManagedBy != nil {
		managedBy := *typedInput.ManagedBy
		containerApp.ManagedBy = &managedBy
	}

	// Set property "ManagedEnvironmentId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedEnvironmentId != nil {
			managedEnvironmentId := *typedInput.Properties.ManagedEnvironmentId
			containerApp.ManagedEnvironmentId = &managedEnvironmentId
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		containerApp.Name = &name
	}

	// Set property "OutboundIpAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundIpAddresses {
			containerApp.OutboundIpAddresses = append(containerApp.OutboundIpAddresses, item)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ContainerApp_Properties_ProvisioningState_STATUS(temp)
			containerApp.ProvisioningState = &provisioningState
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		containerApp.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		containerApp.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			containerApp.Tags[key] = value
		}
	}

	// Set property "Template":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Template != nil {
			var template1 Template_STATUS
			err := template1.PopulateFromARM(owner, *typedInput.Properties.Template)
			if err != nil {
				return err
			}
			template := template1
			containerApp.Template = &template
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		containerApp.Type = &typeVar
	}

	// Set property "WorkloadProfileName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkloadProfileName != nil {
			workloadProfileName := *typedInput.Properties.WorkloadProfileName
			containerApp.WorkloadProfileName = &workloadProfileName
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerApp_STATUS populates our ContainerApp_STATUS from the provided source ContainerApp_STATUS
func (containerApp *ContainerApp_STATUS) AssignProperties_From_ContainerApp_STATUS(source *storage.ContainerApp_STATUS) error {

	// Conditions
	containerApp.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Configuration
	if source.Configuration != nil {
		var configuration Configuration_STATUS
		err := configuration.AssignProperties_From_Configuration_STATUS(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Configuration_STATUS() to populate field Configuration")
		}
		containerApp.Configuration = &configuration
	} else {
		containerApp.Configuration = nil
	}

	// CustomDomainVerificationId
	containerApp.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// EnvironmentId
	containerApp.EnvironmentId = genruntime.ClonePointerToString(source.EnvironmentId)

	// EventStreamEndpoint
	containerApp.EventStreamEndpoint = genruntime.ClonePointerToString(source.EventStreamEndpoint)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		containerApp.ExtendedLocation = &extendedLocation
	} else {
		containerApp.ExtendedLocation = nil
	}

	// Id
	containerApp.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		containerApp.Identity = &identity
	} else {
		containerApp.Identity = nil
	}

	// LatestReadyRevisionName
	containerApp.LatestReadyRevisionName = genruntime.ClonePointerToString(source.LatestReadyRevisionName)

	// LatestRevisionFqdn
	containerApp.LatestRevisionFqdn = genruntime.ClonePointerToString(source.LatestRevisionFqdn)

	// LatestRevisionName
	containerApp.LatestRevisionName = genruntime.ClonePointerToString(source.LatestRevisionName)

	// Location
	containerApp.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedBy
	containerApp.ManagedBy = genruntime.ClonePointerToString(source.ManagedBy)

	// ManagedEnvironmentId
	containerApp.ManagedEnvironmentId = genruntime.ClonePointerToString(source.ManagedEnvironmentId)

	// Name
	containerApp.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundIpAddresses
	containerApp.OutboundIpAddresses = genruntime.CloneSliceOfString(source.OutboundIpAddresses)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, containerApp_Properties_ProvisioningState_STATUS_Values)
		containerApp.ProvisioningState = &provisioningStateTemp
	} else {
		containerApp.ProvisioningState = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		containerApp.SystemData = &systemDatum
	} else {
		containerApp.SystemData = nil
	}

	// Tags
	containerApp.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template Template_STATUS
		err := template.AssignProperties_From_Template_STATUS(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Template_STATUS() to populate field Template")
		}
		containerApp.Template = &template
	} else {
		containerApp.Template = nil
	}

	// Type
	containerApp.Type = genruntime.ClonePointerToString(source.Type)

	// WorkloadProfileName
	containerApp.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// No error
	return nil
}

// AssignProperties_To_ContainerApp_STATUS populates the provided destination ContainerApp_STATUS from our ContainerApp_STATUS
func (containerApp *ContainerApp_STATUS) AssignProperties_To_ContainerApp_STATUS(destination *storage.ContainerApp_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(containerApp.Conditions)

	// Configuration
	if containerApp.Configuration != nil {
		var configuration storage.Configuration_STATUS
		err := containerApp.Configuration.AssignProperties_To_Configuration_STATUS(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Configuration_STATUS() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(containerApp.CustomDomainVerificationId)

	// EnvironmentId
	destination.EnvironmentId = genruntime.ClonePointerToString(containerApp.EnvironmentId)

	// EventStreamEndpoint
	destination.EventStreamEndpoint = genruntime.ClonePointerToString(containerApp.EventStreamEndpoint)

	// ExtendedLocation
	if containerApp.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation_STATUS
		err := containerApp.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(containerApp.Id)

	// Identity
	if containerApp.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := containerApp.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LatestReadyRevisionName
	destination.LatestReadyRevisionName = genruntime.ClonePointerToString(containerApp.LatestReadyRevisionName)

	// LatestRevisionFqdn
	destination.LatestRevisionFqdn = genruntime.ClonePointerToString(containerApp.LatestRevisionFqdn)

	// LatestRevisionName
	destination.LatestRevisionName = genruntime.ClonePointerToString(containerApp.LatestRevisionName)

	// Location
	destination.Location = genruntime.ClonePointerToString(containerApp.Location)

	// ManagedBy
	destination.ManagedBy = genruntime.ClonePointerToString(containerApp.ManagedBy)

	// ManagedEnvironmentId
	destination.ManagedEnvironmentId = genruntime.ClonePointerToString(containerApp.ManagedEnvironmentId)

	// Name
	destination.Name = genruntime.ClonePointerToString(containerApp.Name)

	// OutboundIpAddresses
	destination.OutboundIpAddresses = genruntime.CloneSliceOfString(containerApp.OutboundIpAddresses)

	// ProvisioningState
	if containerApp.ProvisioningState != nil {
		provisioningState := string(*containerApp.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// SystemData
	if containerApp.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := containerApp.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(containerApp.Tags)

	// Template
	if containerApp.Template != nil {
		var template storage.Template_STATUS
		err := containerApp.Template.AssignProperties_To_Template_STATUS(&template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Template_STATUS() to populate field Template")
		}
		destination.Template = &template
	} else {
		destination.Template = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(containerApp.Type)

	// WorkloadProfileName
	destination.WorkloadProfileName = genruntime.ClonePointerToString(containerApp.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Non versioned Container App configuration properties that define the mutable settings of a Container app
type Configuration struct {
	// ActiveRevisionsMode: ActiveRevisionsMode controls how active revisions are handled for the Container app:
	// <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time.
	// Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
	ActiveRevisionsMode *Configuration_ActiveRevisionsMode `json:"activeRevisionsMode,omitempty"`

	// Dapr: Dapr configuration for the Container App.
	Dapr *Dapr `json:"dapr,omitempty"`

	// Ingress: Ingress configurations.
	Ingress *Ingress `json:"ingress,omitempty"`

	// MaxInactiveRevisions: Optional. Max inactive revisions a Container App can have.
	MaxInactiveRevisions *int `json:"maxInactiveRevisions,omitempty"`

	// Registries: Collection of private container registry credentials for containers used by the Container app
	Registries []RegistryCredentials `json:"registries,omitempty"`

	// Secrets: Collection of secrets used by a Container app
	Secrets []Secret `json:"secrets,omitempty"`

	// Service: Container App to be a dev Container App Service
	Service *Service `json:"service,omitempty"`
}

var _ genruntime.ARMTransformer = &Configuration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *Configuration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.Configuration{}

	// Set property "ActiveRevisionsMode":
	if configuration.ActiveRevisionsMode != nil {
		var temp string
		temp = string(*configuration.ActiveRevisionsMode)
		activeRevisionsMode := arm.Configuration_ActiveRevisionsMode(temp)
		result.ActiveRevisionsMode = &activeRevisionsMode
	}

	// Set property "Dapr":
	if configuration.Dapr != nil {
		dapr_ARM, err := (*configuration.Dapr).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dapr := *dapr_ARM.(*arm.Dapr)
		result.Dapr = &dapr
	}

	// Set property "Ingress":
	if configuration.Ingress != nil {
		ingress_ARM, err := (*configuration.Ingress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ingress := *ingress_ARM.(*arm.Ingress)
		result.Ingress = &ingress
	}

	// Set property "MaxInactiveRevisions":
	if configuration.MaxInactiveRevisions != nil {
		maxInactiveRevisions := *configuration.MaxInactiveRevisions
		result.MaxInactiveRevisions = &maxInactiveRevisions
	}

	// Set property "Registries":
	for _, item := range configuration.Registries {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Registries = append(result.Registries, *item_ARM.(*arm.RegistryCredentials))
	}

	// Set property "Secrets":
	for _, item := range configuration.Secrets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, *item_ARM.(*arm.Secret))
	}

	// Set property "Service":
	if configuration.Service != nil {
		service_ARM, err := (*configuration.Service).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		service := *service_ARM.(*arm.Service)
		result.Service = &service
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *Configuration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Configuration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *Configuration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Configuration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Configuration, got %T", armInput)
	}

	// Set property "ActiveRevisionsMode":
	if typedInput.ActiveRevisionsMode != nil {
		var temp string
		temp = string(*typedInput.ActiveRevisionsMode)
		activeRevisionsMode := Configuration_ActiveRevisionsMode(temp)
		configuration.ActiveRevisionsMode = &activeRevisionsMode
	}

	// Set property "Dapr":
	if typedInput.Dapr != nil {
		var dapr1 Dapr
		err := dapr1.PopulateFromARM(owner, *typedInput.Dapr)
		if err != nil {
			return err
		}
		dapr := dapr1
		configuration.Dapr = &dapr
	}

	// Set property "Ingress":
	if typedInput.Ingress != nil {
		var ingress1 Ingress
		err := ingress1.PopulateFromARM(owner, *typedInput.Ingress)
		if err != nil {
			return err
		}
		ingress := ingress1
		configuration.Ingress = &ingress
	}

	// Set property "MaxInactiveRevisions":
	if typedInput.MaxInactiveRevisions != nil {
		maxInactiveRevisions := *typedInput.MaxInactiveRevisions
		configuration.MaxInactiveRevisions = &maxInactiveRevisions
	}

	// Set property "Registries":
	for _, item := range typedInput.Registries {
		var item1 RegistryCredentials
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Registries = append(configuration.Registries, item1)
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 Secret
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Secrets = append(configuration.Secrets, item1)
	}

	// Set property "Service":
	if typedInput.Service != nil {
		var service1 Service
		err := service1.PopulateFromARM(owner, *typedInput.Service)
		if err != nil {
			return err
		}
		service := service1
		configuration.Service = &service
	}

	// No error
	return nil
}

// AssignProperties_From_Configuration populates our Configuration from the provided source Configuration
func (configuration *Configuration) AssignProperties_From_Configuration(source *storage.Configuration) error {

	// ActiveRevisionsMode
	if source.ActiveRevisionsMode != nil {
		activeRevisionsMode := *source.ActiveRevisionsMode
		activeRevisionsModeTemp := genruntime.ToEnum(activeRevisionsMode, configuration_ActiveRevisionsMode_Values)
		configuration.ActiveRevisionsMode = &activeRevisionsModeTemp
	} else {
		configuration.ActiveRevisionsMode = nil
	}

	// Dapr
	if source.Dapr != nil {
		var dapr Dapr
		err := dapr.AssignProperties_From_Dapr(source.Dapr)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Dapr() to populate field Dapr")
		}
		configuration.Dapr = &dapr
	} else {
		configuration.Dapr = nil
	}

	// Ingress
	if source.Ingress != nil {
		var ingress Ingress
		err := ingress.AssignProperties_From_Ingress(source.Ingress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Ingress() to populate field Ingress")
		}
		configuration.Ingress = &ingress
	} else {
		configuration.Ingress = nil
	}

	// MaxInactiveRevisions
	configuration.MaxInactiveRevisions = genruntime.ClonePointerToInt(source.MaxInactiveRevisions)

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials
			err := registry.AssignProperties_From_RegistryCredentials(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegistryCredentials() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret
			err := secret.AssignProperties_From_Secret(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Secret() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// Service
	if source.Service != nil {
		var service Service
		err := service.AssignProperties_From_Service(source.Service)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Service() to populate field Service")
		}
		configuration.Service = &service
	} else {
		configuration.Service = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Configuration populates the provided destination Configuration from our Configuration
func (configuration *Configuration) AssignProperties_To_Configuration(destination *storage.Configuration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActiveRevisionsMode
	if configuration.ActiveRevisionsMode != nil {
		activeRevisionsMode := string(*configuration.ActiveRevisionsMode)
		destination.ActiveRevisionsMode = &activeRevisionsMode
	} else {
		destination.ActiveRevisionsMode = nil
	}

	// Dapr
	if configuration.Dapr != nil {
		var dapr storage.Dapr
		err := configuration.Dapr.AssignProperties_To_Dapr(&dapr)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Dapr() to populate field Dapr")
		}
		destination.Dapr = &dapr
	} else {
		destination.Dapr = nil
	}

	// Ingress
	if configuration.Ingress != nil {
		var ingress storage.Ingress
		err := configuration.Ingress.AssignProperties_To_Ingress(&ingress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Ingress() to populate field Ingress")
		}
		destination.Ingress = &ingress
	} else {
		destination.Ingress = nil
	}

	// MaxInactiveRevisions
	destination.MaxInactiveRevisions = genruntime.ClonePointerToInt(configuration.MaxInactiveRevisions)

	// Registries
	if configuration.Registries != nil {
		registryList := make([]storage.RegistryCredentials, len(configuration.Registries))
		for registryIndex, registryItem := range configuration.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry storage.RegistryCredentials
			err := registryItem.AssignProperties_To_RegistryCredentials(&registry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegistryCredentials() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		destination.Registries = registryList
	} else {
		destination.Registries = nil
	}

	// Secrets
	if configuration.Secrets != nil {
		secretList := make([]storage.Secret, len(configuration.Secrets))
		for secretIndex, secretItem := range configuration.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.Secret
			err := secretItem.AssignProperties_To_Secret(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Secret() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// Service
	if configuration.Service != nil {
		var service storage.Service
		err := configuration.Service.AssignProperties_To_Service(&service)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Service() to populate field Service")
		}
		destination.Service = &service
	} else {
		destination.Service = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Configuration_STATUS populates our Configuration from the provided source Configuration_STATUS
func (configuration *Configuration) Initialize_From_Configuration_STATUS(source *Configuration_STATUS) error {

	// ActiveRevisionsMode
	if source.ActiveRevisionsMode != nil {
		activeRevisionsMode := genruntime.ToEnum(string(*source.ActiveRevisionsMode), configuration_ActiveRevisionsMode_Values)
		configuration.ActiveRevisionsMode = &activeRevisionsMode
	} else {
		configuration.ActiveRevisionsMode = nil
	}

	// Dapr
	if source.Dapr != nil {
		var dapr Dapr
		err := dapr.Initialize_From_Dapr_STATUS(source.Dapr)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Dapr_STATUS() to populate field Dapr")
		}
		configuration.Dapr = &dapr
	} else {
		configuration.Dapr = nil
	}

	// Ingress
	if source.Ingress != nil {
		var ingress Ingress
		err := ingress.Initialize_From_Ingress_STATUS(source.Ingress)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Ingress_STATUS() to populate field Ingress")
		}
		configuration.Ingress = &ingress
	} else {
		configuration.Ingress = nil
	}

	// MaxInactiveRevisions
	configuration.MaxInactiveRevisions = genruntime.ClonePointerToInt(source.MaxInactiveRevisions)

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials
			err := registry.Initialize_From_RegistryCredentials_STATUS(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret
			err := secret.Initialize_From_Secret_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// Service
	if source.Service != nil {
		var service Service
		err := service.Initialize_From_Service_STATUS(source.Service)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Service_STATUS() to populate field Service")
		}
		configuration.Service = &service
	} else {
		configuration.Service = nil
	}

	// No error
	return nil
}

// Non versioned Container App configuration properties that define the mutable settings of a Container app
type Configuration_STATUS struct {
	// ActiveRevisionsMode: ActiveRevisionsMode controls how active revisions are handled for the Container app:
	// <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time.
	// Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
	ActiveRevisionsMode *Configuration_ActiveRevisionsMode_STATUS `json:"activeRevisionsMode,omitempty"`

	// Dapr: Dapr configuration for the Container App.
	Dapr *Dapr_STATUS `json:"dapr,omitempty"`

	// Ingress: Ingress configurations.
	Ingress *Ingress_STATUS `json:"ingress,omitempty"`

	// MaxInactiveRevisions: Optional. Max inactive revisions a Container App can have.
	MaxInactiveRevisions *int `json:"maxInactiveRevisions,omitempty"`

	// Registries: Collection of private container registry credentials for containers used by the Container app
	Registries []RegistryCredentials_STATUS `json:"registries,omitempty"`

	// Secrets: Collection of secrets used by a Container app
	Secrets []Secret_STATUS `json:"secrets,omitempty"`

	// Service: Container App to be a dev Container App Service
	Service *Service_STATUS `json:"service,omitempty"`
}

var _ genruntime.FromARMConverter = &Configuration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *Configuration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Configuration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *Configuration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Configuration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Configuration_STATUS, got %T", armInput)
	}

	// Set property "ActiveRevisionsMode":
	if typedInput.ActiveRevisionsMode != nil {
		var temp string
		temp = string(*typedInput.ActiveRevisionsMode)
		activeRevisionsMode := Configuration_ActiveRevisionsMode_STATUS(temp)
		configuration.ActiveRevisionsMode = &activeRevisionsMode
	}

	// Set property "Dapr":
	if typedInput.Dapr != nil {
		var dapr1 Dapr_STATUS
		err := dapr1.PopulateFromARM(owner, *typedInput.Dapr)
		if err != nil {
			return err
		}
		dapr := dapr1
		configuration.Dapr = &dapr
	}

	// Set property "Ingress":
	if typedInput.Ingress != nil {
		var ingress1 Ingress_STATUS
		err := ingress1.PopulateFromARM(owner, *typedInput.Ingress)
		if err != nil {
			return err
		}
		ingress := ingress1
		configuration.Ingress = &ingress
	}

	// Set property "MaxInactiveRevisions":
	if typedInput.MaxInactiveRevisions != nil {
		maxInactiveRevisions := *typedInput.MaxInactiveRevisions
		configuration.MaxInactiveRevisions = &maxInactiveRevisions
	}

	// Set property "Registries":
	for _, item := range typedInput.Registries {
		var item1 RegistryCredentials_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Registries = append(configuration.Registries, item1)
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 Secret_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Secrets = append(configuration.Secrets, item1)
	}

	// Set property "Service":
	if typedInput.Service != nil {
		var service1 Service_STATUS
		err := service1.PopulateFromARM(owner, *typedInput.Service)
		if err != nil {
			return err
		}
		service := service1
		configuration.Service = &service
	}

	// No error
	return nil
}

// AssignProperties_From_Configuration_STATUS populates our Configuration_STATUS from the provided source Configuration_STATUS
func (configuration *Configuration_STATUS) AssignProperties_From_Configuration_STATUS(source *storage.Configuration_STATUS) error {

	// ActiveRevisionsMode
	if source.ActiveRevisionsMode != nil {
		activeRevisionsMode := *source.ActiveRevisionsMode
		activeRevisionsModeTemp := genruntime.ToEnum(activeRevisionsMode, configuration_ActiveRevisionsMode_STATUS_Values)
		configuration.ActiveRevisionsMode = &activeRevisionsModeTemp
	} else {
		configuration.ActiveRevisionsMode = nil
	}

	// Dapr
	if source.Dapr != nil {
		var dapr Dapr_STATUS
		err := dapr.AssignProperties_From_Dapr_STATUS(source.Dapr)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Dapr_STATUS() to populate field Dapr")
		}
		configuration.Dapr = &dapr
	} else {
		configuration.Dapr = nil
	}

	// Ingress
	if source.Ingress != nil {
		var ingress Ingress_STATUS
		err := ingress.AssignProperties_From_Ingress_STATUS(source.Ingress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Ingress_STATUS() to populate field Ingress")
		}
		configuration.Ingress = &ingress
	} else {
		configuration.Ingress = nil
	}

	// MaxInactiveRevisions
	configuration.MaxInactiveRevisions = genruntime.ClonePointerToInt(source.MaxInactiveRevisions)

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials_STATUS, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials_STATUS
			err := registry.AssignProperties_From_RegistryCredentials_STATUS(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret_STATUS
			err := secret.AssignProperties_From_Secret_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// Service
	if source.Service != nil {
		var service Service_STATUS
		err := service.AssignProperties_From_Service_STATUS(source.Service)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Service_STATUS() to populate field Service")
		}
		configuration.Service = &service
	} else {
		configuration.Service = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Configuration_STATUS populates the provided destination Configuration_STATUS from our Configuration_STATUS
func (configuration *Configuration_STATUS) AssignProperties_To_Configuration_STATUS(destination *storage.Configuration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActiveRevisionsMode
	if configuration.ActiveRevisionsMode != nil {
		activeRevisionsMode := string(*configuration.ActiveRevisionsMode)
		destination.ActiveRevisionsMode = &activeRevisionsMode
	} else {
		destination.ActiveRevisionsMode = nil
	}

	// Dapr
	if configuration.Dapr != nil {
		var dapr storage.Dapr_STATUS
		err := configuration.Dapr.AssignProperties_To_Dapr_STATUS(&dapr)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Dapr_STATUS() to populate field Dapr")
		}
		destination.Dapr = &dapr
	} else {
		destination.Dapr = nil
	}

	// Ingress
	if configuration.Ingress != nil {
		var ingress storage.Ingress_STATUS
		err := configuration.Ingress.AssignProperties_To_Ingress_STATUS(&ingress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Ingress_STATUS() to populate field Ingress")
		}
		destination.Ingress = &ingress
	} else {
		destination.Ingress = nil
	}

	// MaxInactiveRevisions
	destination.MaxInactiveRevisions = genruntime.ClonePointerToInt(configuration.MaxInactiveRevisions)

	// Registries
	if configuration.Registries != nil {
		registryList := make([]storage.RegistryCredentials_STATUS, len(configuration.Registries))
		for registryIndex, registryItem := range configuration.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry storage.RegistryCredentials_STATUS
			err := registryItem.AssignProperties_To_RegistryCredentials_STATUS(&registry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		destination.Registries = registryList
	} else {
		destination.Registries = nil
	}

	// Secrets
	if configuration.Secrets != nil {
		secretList := make([]storage.Secret_STATUS, len(configuration.Secrets))
		for secretIndex, secretItem := range configuration.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.Secret_STATUS
			err := secretItem.AssignProperties_To_Secret_STATUS(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// Service
	if configuration.Service != nil {
		var service storage.Service_STATUS
		err := configuration.Service.AssignProperties_To_Service_STATUS(&service)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Service_STATUS() to populate field Service")
		}
		destination.Service = &service
	} else {
		destination.Service = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerApp_Properties_ProvisioningState_STATUS string

const (
	ContainerApp_Properties_ProvisioningState_STATUS_Canceled   = ContainerApp_Properties_ProvisioningState_STATUS("Canceled")
	ContainerApp_Properties_ProvisioningState_STATUS_Deleting   = ContainerApp_Properties_ProvisioningState_STATUS("Deleting")
	ContainerApp_Properties_ProvisioningState_STATUS_Failed     = ContainerApp_Properties_ProvisioningState_STATUS("Failed")
	ContainerApp_Properties_ProvisioningState_STATUS_InProgress = ContainerApp_Properties_ProvisioningState_STATUS("InProgress")
	ContainerApp_Properties_ProvisioningState_STATUS_Succeeded  = ContainerApp_Properties_ProvisioningState_STATUS("Succeeded")
)

// Mapping from string to ContainerApp_Properties_ProvisioningState_STATUS
var containerApp_Properties_ProvisioningState_STATUS_Values = map[string]ContainerApp_Properties_ProvisioningState_STATUS{
	"canceled":   ContainerApp_Properties_ProvisioningState_STATUS_Canceled,
	"deleting":   ContainerApp_Properties_ProvisioningState_STATUS_Deleting,
	"failed":     ContainerApp_Properties_ProvisioningState_STATUS_Failed,
	"inprogress": ContainerApp_Properties_ProvisioningState_STATUS_InProgress,
	"succeeded":  ContainerApp_Properties_ProvisioningState_STATUS_Succeeded,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ContainerAppOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// ConfigMaps: configures where to place operator written ConfigMaps.
	ConfigMaps *ContainerAppOperatorConfigMaps `json:"configMaps,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_ContainerAppOperatorSpec populates our ContainerAppOperatorSpec from the provided source ContainerAppOperatorSpec
func (operator *ContainerAppOperatorSpec) AssignProperties_From_ContainerAppOperatorSpec(source *storage.ContainerAppOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if source.ConfigMaps != nil {
		var configMap ContainerAppOperatorConfigMaps
		err := configMap.AssignProperties_From_ContainerAppOperatorConfigMaps(source.ConfigMaps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppOperatorConfigMaps() to populate field ConfigMaps")
		}
		operator.ConfigMaps = &configMap
	} else {
		operator.ConfigMaps = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppOperatorSpec populates the provided destination ContainerAppOperatorSpec from our ContainerAppOperatorSpec
func (operator *ContainerAppOperatorSpec) AssignProperties_To_ContainerAppOperatorSpec(destination *storage.ContainerAppOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if operator.ConfigMaps != nil {
		var configMap storage.ContainerAppOperatorConfigMaps
		err := operator.ConfigMaps.AssignProperties_To_ContainerAppOperatorConfigMaps(&configMap)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppOperatorConfigMaps() to populate field ConfigMaps")
		}
		destination.ConfigMaps = &configMap
	} else {
		destination.ConfigMaps = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The complex type of the extended location.
type ExtendedLocation struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (location *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if location == nil {
		return nil, nil
	}
	result := &arm.ExtendedLocation{}

	// Set property "Name":
	if location.Name != nil {
		name := *location.Name
		result.Name = &name
	}

	// Set property "Type":
	if location.Type != nil {
		var temp string
		temp = string(*location.Type)
		typeVar := arm.ExtendedLocationType(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExtendedLocation{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExtendedLocation)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExtendedLocation, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExtendedLocationType(temp)
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignProperties_From_ExtendedLocation(source *storage.ExtendedLocation) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, extendedLocationType_Values)
		location.Type = &typeTemp
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignProperties_To_ExtendedLocation(destination *storage.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExtendedLocation_STATUS populates our ExtendedLocation from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation) Initialize_From_ExtendedLocation_STATUS(source *ExtendedLocation_STATUS) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), extendedLocationType_Values)
		location.Type = &typeVar
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// The complex type of the extended location.
type ExtendedLocation_STATUS struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationType_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExtendedLocation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExtendedLocation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExtendedLocation_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExtendedLocationType_STATUS(temp)
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_From_ExtendedLocation_STATUS(source *storage.ExtendedLocation_STATUS) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, extendedLocationType_STATUS_Values)
		location.Type = &typeTemp
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_To_ExtendedLocation_STATUS(destination *storage.ExtendedLocation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// +kubebuilder:validation:Required
	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType   `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedServiceIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedServiceIdentityType(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), managedServiceIdentityType_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: The service principal ID of the system assigned identity. This property will only be provided for a system
	// assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType_STATUS     `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App versioned application definition.
// Defines the desired state of an immutable revision.
// Any changes to this
// section Will result in a new revision being created
type Template struct {
	// Containers: List of container definitions for the Container App.
	Containers []Container `json:"containers,omitempty"`

	// InitContainers: List of specialized containers that run before app containers.
	InitContainers []BaseContainer `json:"initContainers,omitempty"`

	// RevisionSuffix: User friendly suffix that is appended to the revision name
	RevisionSuffix *string `json:"revisionSuffix,omitempty"`

	// Scale: Scaling properties for the Container App.
	Scale *Scale `json:"scale,omitempty"`

	// ServiceBinds: List of container app services bound to the app
	ServiceBinds []ServiceBind `json:"serviceBinds,omitempty"`

	// TerminationGracePeriodSeconds: Optional duration in seconds the Container App Instance needs to terminate gracefully.
	// Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to
	// shut down). If this value is nil, the default grace period will be used instead. Set this value longer than the expected
	// cleanup time for your process. Defaults to 30 seconds.
	TerminationGracePeriodSeconds *int `json:"terminationGracePeriodSeconds,omitempty"`

	// Volumes: List of volume definitions for the Container App.
	Volumes []Volume `json:"volumes,omitempty"`
}

var _ genruntime.ARMTransformer = &Template{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (template *Template) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if template == nil {
		return nil, nil
	}
	result := &arm.Template{}

	// Set property "Containers":
	for _, item := range template.Containers {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Containers = append(result.Containers, *item_ARM.(*arm.Container))
	}

	// Set property "InitContainers":
	for _, item := range template.InitContainers {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.InitContainers = append(result.InitContainers, *item_ARM.(*arm.BaseContainer))
	}

	// Set property "RevisionSuffix":
	if template.RevisionSuffix != nil {
		revisionSuffix := *template.RevisionSuffix
		result.RevisionSuffix = &revisionSuffix
	}

	// Set property "Scale":
	if template.Scale != nil {
		scale_ARM, err := (*template.Scale).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scale := *scale_ARM.(*arm.Scale)
		result.Scale = &scale
	}

	// Set property "ServiceBinds":
	for _, item := range template.ServiceBinds {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ServiceBinds = append(result.ServiceBinds, *item_ARM.(*arm.ServiceBind))
	}

	// Set property "TerminationGracePeriodSeconds":
	if template.TerminationGracePeriodSeconds != nil {
		terminationGracePeriodSeconds := *template.TerminationGracePeriodSeconds
		result.TerminationGracePeriodSeconds = &terminationGracePeriodSeconds
	}

	// Set property "Volumes":
	for _, item := range template.Volumes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Volumes = append(result.Volumes, *item_ARM.(*arm.Volume))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (template *Template) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Template{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (template *Template) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Template)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Template, got %T", armInput)
	}

	// Set property "Containers":
	for _, item := range typedInput.Containers {
		var item1 Container
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.Containers = append(template.Containers, item1)
	}

	// Set property "InitContainers":
	for _, item := range typedInput.InitContainers {
		var item1 BaseContainer
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.InitContainers = append(template.InitContainers, item1)
	}

	// Set property "RevisionSuffix":
	if typedInput.RevisionSuffix != nil {
		revisionSuffix := *typedInput.RevisionSuffix
		template.RevisionSuffix = &revisionSuffix
	}

	// Set property "Scale":
	if typedInput.Scale != nil {
		var scale1 Scale
		err := scale1.PopulateFromARM(owner, *typedInput.Scale)
		if err != nil {
			return err
		}
		scale := scale1
		template.Scale = &scale
	}

	// Set property "ServiceBinds":
	for _, item := range typedInput.ServiceBinds {
		var item1 ServiceBind
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.ServiceBinds = append(template.ServiceBinds, item1)
	}

	// Set property "TerminationGracePeriodSeconds":
	if typedInput.TerminationGracePeriodSeconds != nil {
		terminationGracePeriodSeconds := *typedInput.TerminationGracePeriodSeconds
		template.TerminationGracePeriodSeconds = &terminationGracePeriodSeconds
	}

	// Set property "Volumes":
	for _, item := range typedInput.Volumes {
		var item1 Volume
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.Volumes = append(template.Volumes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Template populates our Template from the provided source Template
func (template *Template) AssignProperties_From_Template(source *storage.Template) error {

	// Containers
	if source.Containers != nil {
		containerList := make([]Container, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container
			err := container.AssignProperties_From_Container(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer
			err := initContainer.AssignProperties_From_BaseContainer(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BaseContainer() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// RevisionSuffix
	template.RevisionSuffix = genruntime.ClonePointerToString(source.RevisionSuffix)

	// Scale
	if source.Scale != nil {
		var scale Scale
		err := scale.AssignProperties_From_Scale(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Scale() to populate field Scale")
		}
		template.Scale = &scale
	} else {
		template.Scale = nil
	}

	// ServiceBinds
	if source.ServiceBinds != nil {
		serviceBindList := make([]ServiceBind, len(source.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range source.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind ServiceBind
			err := serviceBind.AssignProperties_From_ServiceBind(&serviceBindItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ServiceBind() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		template.ServiceBinds = serviceBindList
	} else {
		template.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	template.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.AssignProperties_From_Volume(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Template populates the provided destination Template from our Template
func (template *Template) AssignProperties_To_Template(destination *storage.Template) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Containers
	if template.Containers != nil {
		containerList := make([]storage.Container, len(template.Containers))
		for containerIndex, containerItem := range template.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container
			err := containerItem.AssignProperties_To_Container(&container)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// InitContainers
	if template.InitContainers != nil {
		initContainerList := make([]storage.BaseContainer, len(template.InitContainers))
		for initContainerIndex, initContainerItem := range template.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.BaseContainer
			err := initContainerItem.AssignProperties_To_BaseContainer(&initContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BaseContainer() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// RevisionSuffix
	destination.RevisionSuffix = genruntime.ClonePointerToString(template.RevisionSuffix)

	// Scale
	if template.Scale != nil {
		var scale storage.Scale
		err := template.Scale.AssignProperties_To_Scale(&scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Scale() to populate field Scale")
		}
		destination.Scale = &scale
	} else {
		destination.Scale = nil
	}

	// ServiceBinds
	if template.ServiceBinds != nil {
		serviceBindList := make([]storage.ServiceBind, len(template.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range template.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind storage.ServiceBind
			err := serviceBindItem.AssignProperties_To_ServiceBind(&serviceBind)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ServiceBind() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		destination.ServiceBinds = serviceBindList
	} else {
		destination.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	destination.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(template.TerminationGracePeriodSeconds)

	// Volumes
	if template.Volumes != nil {
		volumeList := make([]storage.Volume, len(template.Volumes))
		for volumeIndex, volumeItem := range template.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume
			err := volumeItem.AssignProperties_To_Volume(&volume)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Template_STATUS populates our Template from the provided source Template_STATUS
func (template *Template) Initialize_From_Template_STATUS(source *Template_STATUS) error {

	// Containers
	if source.Containers != nil {
		containerList := make([]Container, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container
			err := container.Initialize_From_Container_STATUS(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer
			err := initContainer.Initialize_From_BaseContainer_STATUS(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// RevisionSuffix
	template.RevisionSuffix = genruntime.ClonePointerToString(source.RevisionSuffix)

	// Scale
	if source.Scale != nil {
		var scale Scale
		err := scale.Initialize_From_Scale_STATUS(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Scale_STATUS() to populate field Scale")
		}
		template.Scale = &scale
	} else {
		template.Scale = nil
	}

	// ServiceBinds
	if source.ServiceBinds != nil {
		serviceBindList := make([]ServiceBind, len(source.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range source.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind ServiceBind
			err := serviceBind.Initialize_From_ServiceBind_STATUS(&serviceBindItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ServiceBind_STATUS() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		template.ServiceBinds = serviceBindList
	} else {
		template.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	template.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.Initialize_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// No error
	return nil
}

// Container App versioned application definition.
// Defines the desired state of an immutable revision.
// Any changes to this
// section Will result in a new revision being created
type Template_STATUS struct {
	// Containers: List of container definitions for the Container App.
	Containers []Container_STATUS `json:"containers,omitempty"`

	// InitContainers: List of specialized containers that run before app containers.
	InitContainers []BaseContainer_STATUS `json:"initContainers,omitempty"`

	// RevisionSuffix: User friendly suffix that is appended to the revision name
	RevisionSuffix *string `json:"revisionSuffix,omitempty"`

	// Scale: Scaling properties for the Container App.
	Scale *Scale_STATUS `json:"scale,omitempty"`

	// ServiceBinds: List of container app services bound to the app
	ServiceBinds []ServiceBind_STATUS `json:"serviceBinds,omitempty"`

	// TerminationGracePeriodSeconds: Optional duration in seconds the Container App Instance needs to terminate gracefully.
	// Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to
	// shut down). If this value is nil, the default grace period will be used instead. Set this value longer than the expected
	// cleanup time for your process. Defaults to 30 seconds.
	TerminationGracePeriodSeconds *int `json:"terminationGracePeriodSeconds,omitempty"`

	// Volumes: List of volume definitions for the Container App.
	Volumes []Volume_STATUS `json:"volumes,omitempty"`
}

var _ genruntime.FromARMConverter = &Template_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (template *Template_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Template_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (template *Template_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Template_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Template_STATUS, got %T", armInput)
	}

	// Set property "Containers":
	for _, item := range typedInput.Containers {
		var item1 Container_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.Containers = append(template.Containers, item1)
	}

	// Set property "InitContainers":
	for _, item := range typedInput.InitContainers {
		var item1 BaseContainer_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.InitContainers = append(template.InitContainers, item1)
	}

	// Set property "RevisionSuffix":
	if typedInput.RevisionSuffix != nil {
		revisionSuffix := *typedInput.RevisionSuffix
		template.RevisionSuffix = &revisionSuffix
	}

	// Set property "Scale":
	if typedInput.Scale != nil {
		var scale1 Scale_STATUS
		err := scale1.PopulateFromARM(owner, *typedInput.Scale)
		if err != nil {
			return err
		}
		scale := scale1
		template.Scale = &scale
	}

	// Set property "ServiceBinds":
	for _, item := range typedInput.ServiceBinds {
		var item1 ServiceBind_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.ServiceBinds = append(template.ServiceBinds, item1)
	}

	// Set property "TerminationGracePeriodSeconds":
	if typedInput.TerminationGracePeriodSeconds != nil {
		terminationGracePeriodSeconds := *typedInput.TerminationGracePeriodSeconds
		template.TerminationGracePeriodSeconds = &terminationGracePeriodSeconds
	}

	// Set property "Volumes":
	for _, item := range typedInput.Volumes {
		var item1 Volume_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.Volumes = append(template.Volumes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Template_STATUS populates our Template_STATUS from the provided source Template_STATUS
func (template *Template_STATUS) AssignProperties_From_Template_STATUS(source *storage.Template_STATUS) error {

	// Containers
	if source.Containers != nil {
		containerList := make([]Container_STATUS, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container_STATUS
			err := container.AssignProperties_From_Container_STATUS(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer_STATUS, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer_STATUS
			err := initContainer.AssignProperties_From_BaseContainer_STATUS(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// RevisionSuffix
	template.RevisionSuffix = genruntime.ClonePointerToString(source.RevisionSuffix)

	// Scale
	if source.Scale != nil {
		var scale Scale_STATUS
		err := scale.AssignProperties_From_Scale_STATUS(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Scale_STATUS() to populate field Scale")
		}
		template.Scale = &scale
	} else {
		template.Scale = nil
	}

	// ServiceBinds
	if source.ServiceBinds != nil {
		serviceBindList := make([]ServiceBind_STATUS, len(source.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range source.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind ServiceBind_STATUS
			err := serviceBind.AssignProperties_From_ServiceBind_STATUS(&serviceBindItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ServiceBind_STATUS() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		template.ServiceBinds = serviceBindList
	} else {
		template.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	template.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume_STATUS, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume_STATUS
			err := volume.AssignProperties_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Template_STATUS populates the provided destination Template_STATUS from our Template_STATUS
func (template *Template_STATUS) AssignProperties_To_Template_STATUS(destination *storage.Template_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Containers
	if template.Containers != nil {
		containerList := make([]storage.Container_STATUS, len(template.Containers))
		for containerIndex, containerItem := range template.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container_STATUS
			err := containerItem.AssignProperties_To_Container_STATUS(&container)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// InitContainers
	if template.InitContainers != nil {
		initContainerList := make([]storage.BaseContainer_STATUS, len(template.InitContainers))
		for initContainerIndex, initContainerItem := range template.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.BaseContainer_STATUS
			err := initContainerItem.AssignProperties_To_BaseContainer_STATUS(&initContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// RevisionSuffix
	destination.RevisionSuffix = genruntime.ClonePointerToString(template.RevisionSuffix)

	// Scale
	if template.Scale != nil {
		var scale storage.Scale_STATUS
		err := template.Scale.AssignProperties_To_Scale_STATUS(&scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Scale_STATUS() to populate field Scale")
		}
		destination.Scale = &scale
	} else {
		destination.Scale = nil
	}

	// ServiceBinds
	if template.ServiceBinds != nil {
		serviceBindList := make([]storage.ServiceBind_STATUS, len(template.ServiceBinds))
		for serviceBindIndex, serviceBindItem := range template.ServiceBinds {
			// Shadow the loop variable to avoid aliasing
			serviceBindItem := serviceBindItem
			var serviceBind storage.ServiceBind_STATUS
			err := serviceBindItem.AssignProperties_To_ServiceBind_STATUS(&serviceBind)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ServiceBind_STATUS() to populate field ServiceBinds")
			}
			serviceBindList[serviceBindIndex] = serviceBind
		}
		destination.ServiceBinds = serviceBindList
	} else {
		destination.ServiceBinds = nil
	}

	// TerminationGracePeriodSeconds
	destination.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(template.TerminationGracePeriodSeconds)

	// Volumes
	if template.Volumes != nil {
		volumeList := make([]storage.Volume_STATUS, len(template.Volumes))
		for volumeIndex, volumeItem := range template.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume_STATUS
			err := volumeItem.AssignProperties_To_Volume_STATUS(&volume)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App base container definition.
type BaseContainer struct {
	// Args: Container start command arguments.
	Args []string `json:"args,omitempty"`

	// Command: Container start command.
	Command []string `json:"command,omitempty"`

	// Env: Container environment variables.
	Env []EnvironmentVar `json:"env,omitempty"`

	// Image: Container image tag.
	Image *string `json:"image,omitempty"`

	// Name: Custom container name.
	Name *string `json:"name,omitempty"`

	// Resources: Container resource requirements.
	Resources *ContainerResources `json:"resources,omitempty"`

	// VolumeMounts: Container volume mounts.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

var _ genruntime.ARMTransformer = &BaseContainer{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (container *BaseContainer) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if container == nil {
		return nil, nil
	}
	result := &arm.BaseContainer{}

	// Set property "Args":
	for _, item := range container.Args {
		result.Args = append(result.Args, item)
	}

	// Set property "Command":
	for _, item := range container.Command {
		result.Command = append(result.Command, item)
	}

	// Set property "Env":
	for _, item := range container.Env {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Env = append(result.Env, *item_ARM.(*arm.EnvironmentVar))
	}

	// Set property "Image":
	if container.Image != nil {
		image := *container.Image
		result.Image = &image
	}

	// Set property "Name":
	if container.Name != nil {
		name := *container.Name
		result.Name = &name
	}

	// Set property "Resources":
	if container.Resources != nil {
		resources_ARM, err := (*container.Resources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resources := *resources_ARM.(*arm.ContainerResources)
		result.Resources = &resources
	}

	// Set property "VolumeMounts":
	for _, item := range container.VolumeMounts {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VolumeMounts = append(result.VolumeMounts, *item_ARM.(*arm.VolumeMount))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *BaseContainer) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BaseContainer{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *BaseContainer) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BaseContainer)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BaseContainer, got %T", armInput)
	}

	// Set property "Args":
	for _, item := range typedInput.Args {
		container.Args = append(container.Args, item)
	}

	// Set property "Command":
	for _, item := range typedInput.Command {
		container.Command = append(container.Command, item)
	}

	// Set property "Env":
	for _, item := range typedInput.Env {
		var item1 EnvironmentVar
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.Env = append(container.Env, item1)
	}

	// Set property "Image":
	if typedInput.Image != nil {
		image := *typedInput.Image
		container.Image = &image
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property "Resources":
	if typedInput.Resources != nil {
		var resources1 ContainerResources
		err := resources1.PopulateFromARM(owner, *typedInput.Resources)
		if err != nil {
			return err
		}
		resources := resources1
		container.Resources = &resources
	}

	// Set property "VolumeMounts":
	for _, item := range typedInput.VolumeMounts {
		var item1 VolumeMount
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.VolumeMounts = append(container.VolumeMounts, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BaseContainer populates our BaseContainer from the provided source BaseContainer
func (container *BaseContainer) AssignProperties_From_BaseContainer(source *storage.BaseContainer) error {

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar
			err := env.AssignProperties_From_EnvironmentVar(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnvironmentVar() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Resources
	if source.Resources != nil {
		var resource ContainerResources
		err := resource.AssignProperties_From_ContainerResources(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerResources() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignProperties_From_VolumeMount(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BaseContainer populates the provided destination BaseContainer from our BaseContainer
func (container *BaseContainer) AssignProperties_To_BaseContainer(destination *storage.BaseContainer) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Args
	destination.Args = genruntime.CloneSliceOfString(container.Args)

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// Env
	if container.Env != nil {
		envList := make([]storage.EnvironmentVar, len(container.Env))
		for envIndex, envItem := range container.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env storage.EnvironmentVar
			err := envItem.AssignProperties_To_EnvironmentVar(&env)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnvironmentVar() to populate field Env")
			}
			envList[envIndex] = env
		}
		destination.Env = envList
	} else {
		destination.Env = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Resources
	if container.Resources != nil {
		var resource storage.ContainerResources
		err := container.Resources.AssignProperties_To_ContainerResources(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerResources() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount
			err := volumeMountItem.AssignProperties_To_VolumeMount(&volumeMount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BaseContainer_STATUS populates our BaseContainer from the provided source BaseContainer_STATUS
func (container *BaseContainer) Initialize_From_BaseContainer_STATUS(source *BaseContainer_STATUS) error {

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar
			err := env.Initialize_From_EnvironmentVar_STATUS(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Resources
	if source.Resources != nil {
		var resource ContainerResources
		err := resource.Initialize_From_ContainerResources_STATUS(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ContainerResources_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.Initialize_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// Container App base container definition.
type BaseContainer_STATUS struct {
	// Args: Container start command arguments.
	Args []string `json:"args,omitempty"`

	// Command: Container start command.
	Command []string `json:"command,omitempty"`

	// Env: Container environment variables.
	Env []EnvironmentVar_STATUS `json:"env,omitempty"`

	// Image: Container image tag.
	Image *string `json:"image,omitempty"`

	// Name: Custom container name.
	Name *string `json:"name,omitempty"`

	// Resources: Container resource requirements.
	Resources *ContainerResources_STATUS `json:"resources,omitempty"`

	// VolumeMounts: Container volume mounts.
	VolumeMounts []VolumeMount_STATUS `json:"volumeMounts,omitempty"`
}

var _ genruntime.FromARMConverter = &BaseContainer_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *BaseContainer_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BaseContainer_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *BaseContainer_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BaseContainer_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BaseContainer_STATUS, got %T", armInput)
	}

	// Set property "Args":
	for _, item := range typedInput.Args {
		container.Args = append(container.Args, item)
	}

	// Set property "Command":
	for _, item := range typedInput.Command {
		container.Command = append(container.Command, item)
	}

	// Set property "Env":
	for _, item := range typedInput.Env {
		var item1 EnvironmentVar_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.Env = append(container.Env, item1)
	}

	// Set property "Image":
	if typedInput.Image != nil {
		image := *typedInput.Image
		container.Image = &image
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property "Resources":
	if typedInput.Resources != nil {
		var resources1 ContainerResources_STATUS
		err := resources1.PopulateFromARM(owner, *typedInput.Resources)
		if err != nil {
			return err
		}
		resources := resources1
		container.Resources = &resources
	}

	// Set property "VolumeMounts":
	for _, item := range typedInput.VolumeMounts {
		var item1 VolumeMount_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.VolumeMounts = append(container.VolumeMounts, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BaseContainer_STATUS populates our BaseContainer_STATUS from the provided source BaseContainer_STATUS
func (container *BaseContainer_STATUS) AssignProperties_From_BaseContainer_STATUS(source *storage.BaseContainer_STATUS) error {

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar_STATUS, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar_STATUS
			err := env.AssignProperties_From_EnvironmentVar_STATUS(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Resources
	if source.Resources != nil {
		var resource ContainerResources_STATUS
		err := resource.AssignProperties_From_ContainerResources_STATUS(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerResources_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_STATUS, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_STATUS
			err := volumeMount.AssignProperties_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BaseContainer_STATUS populates the provided destination BaseContainer_STATUS from our BaseContainer_STATUS
func (container *BaseContainer_STATUS) AssignProperties_To_BaseContainer_STATUS(destination *storage.BaseContainer_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Args
	destination.Args = genruntime.CloneSliceOfString(container.Args)

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// Env
	if container.Env != nil {
		envList := make([]storage.EnvironmentVar_STATUS, len(container.Env))
		for envIndex, envItem := range container.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env storage.EnvironmentVar_STATUS
			err := envItem.AssignProperties_To_EnvironmentVar_STATUS(&env)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		destination.Env = envList
	} else {
		destination.Env = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Resources
	if container.Resources != nil {
		var resource storage.ContainerResources_STATUS
		err := container.Resources.AssignProperties_To_ContainerResources_STATUS(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerResources_STATUS() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount_STATUS, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount_STATUS
			err := volumeMountItem.AssignProperties_To_VolumeMount_STATUS(&volumeMount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Multiple","Single"}
type Configuration_ActiveRevisionsMode string

const (
	Configuration_ActiveRevisionsMode_Multiple = Configuration_ActiveRevisionsMode("Multiple")
	Configuration_ActiveRevisionsMode_Single   = Configuration_ActiveRevisionsMode("Single")
)

// Mapping from string to Configuration_ActiveRevisionsMode
var configuration_ActiveRevisionsMode_Values = map[string]Configuration_ActiveRevisionsMode{
	"multiple": Configuration_ActiveRevisionsMode_Multiple,
	"single":   Configuration_ActiveRevisionsMode_Single,
}

type Configuration_ActiveRevisionsMode_STATUS string

const (
	Configuration_ActiveRevisionsMode_STATUS_Multiple = Configuration_ActiveRevisionsMode_STATUS("Multiple")
	Configuration_ActiveRevisionsMode_STATUS_Single   = Configuration_ActiveRevisionsMode_STATUS("Single")
)

// Mapping from string to Configuration_ActiveRevisionsMode_STATUS
var configuration_ActiveRevisionsMode_STATUS_Values = map[string]Configuration_ActiveRevisionsMode_STATUS{
	"multiple": Configuration_ActiveRevisionsMode_STATUS_Multiple,
	"single":   Configuration_ActiveRevisionsMode_STATUS_Single,
}

// Container App container definition
type Container struct {
	// Args: Container start command arguments.
	Args []string `json:"args,omitempty"`

	// Command: Container start command.
	Command []string `json:"command,omitempty"`

	// Env: Container environment variables.
	Env []EnvironmentVar `json:"env,omitempty"`

	// Image: Container image tag.
	Image *string `json:"image,omitempty"`

	// Name: Custom container name.
	Name *string `json:"name,omitempty"`

	// Probes: List of probes for the container.
	Probes []ContainerAppProbe `json:"probes,omitempty"`

	// Resources: Container resource requirements.
	Resources *ContainerResources `json:"resources,omitempty"`

	// VolumeMounts: Container volume mounts.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

var _ genruntime.ARMTransformer = &Container{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (container *Container) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if container == nil {
		return nil, nil
	}
	result := &arm.Container{}

	// Set property "Args":
	for _, item := range container.Args {
		result.Args = append(result.Args, item)
	}

	// Set property "Command":
	for _, item := range container.Command {
		result.Command = append(result.Command, item)
	}

	// Set property "Env":
	for _, item := range container.Env {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Env = append(result.Env, *item_ARM.(*arm.EnvironmentVar))
	}

	// Set property "Image":
	if container.Image != nil {
		image := *container.Image
		result.Image = &image
	}

	// Set property "Name":
	if container.Name != nil {
		name := *container.Name
		result.Name = &name
	}

	// Set property "Probes":
	for _, item := range container.Probes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Probes = append(result.Probes, *item_ARM.(*arm.ContainerAppProbe))
	}

	// Set property "Resources":
	if container.Resources != nil {
		resources_ARM, err := (*container.Resources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resources := *resources_ARM.(*arm.ContainerResources)
		result.Resources = &resources
	}

	// Set property "VolumeMounts":
	for _, item := range container.VolumeMounts {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VolumeMounts = append(result.VolumeMounts, *item_ARM.(*arm.VolumeMount))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *Container) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Container{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *Container) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Container)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Container, got %T", armInput)
	}

	// Set property "Args":
	for _, item := range typedInput.Args {
		container.Args = append(container.Args, item)
	}

	// Set property "Command":
	for _, item := range typedInput.Command {
		container.Command = append(container.Command, item)
	}

	// Set property "Env":
	for _, item := range typedInput.Env {
		var item1 EnvironmentVar
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.Env = append(container.Env, item1)
	}

	// Set property "Image":
	if typedInput.Image != nil {
		image := *typedInput.Image
		container.Image = &image
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property "Probes":
	for _, item := range typedInput.Probes {
		var item1 ContainerAppProbe
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.Probes = append(container.Probes, item1)
	}

	// Set property "Resources":
	if typedInput.Resources != nil {
		var resources1 ContainerResources
		err := resources1.PopulateFromARM(owner, *typedInput.Resources)
		if err != nil {
			return err
		}
		resources := resources1
		container.Resources = &resources
	}

	// Set property "VolumeMounts":
	for _, item := range typedInput.VolumeMounts {
		var item1 VolumeMount
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.VolumeMounts = append(container.VolumeMounts, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Container populates our Container from the provided source Container
func (container *Container) AssignProperties_From_Container(source *storage.Container) error {

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar
			err := env.AssignProperties_From_EnvironmentVar(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnvironmentVar() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Probes
	if source.Probes != nil {
		probeList := make([]ContainerAppProbe, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe ContainerAppProbe
			err := probe.AssignProperties_From_ContainerAppProbe(&probeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		container.Probes = probeList
	} else {
		container.Probes = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ContainerResources
		err := resource.AssignProperties_From_ContainerResources(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerResources() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.AssignProperties_From_VolumeMount(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Container populates the provided destination Container from our Container
func (container *Container) AssignProperties_To_Container(destination *storage.Container) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Args
	destination.Args = genruntime.CloneSliceOfString(container.Args)

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// Env
	if container.Env != nil {
		envList := make([]storage.EnvironmentVar, len(container.Env))
		for envIndex, envItem := range container.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env storage.EnvironmentVar
			err := envItem.AssignProperties_To_EnvironmentVar(&env)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnvironmentVar() to populate field Env")
			}
			envList[envIndex] = env
		}
		destination.Env = envList
	} else {
		destination.Env = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Probes
	if container.Probes != nil {
		probeList := make([]storage.ContainerAppProbe, len(container.Probes))
		for probeIndex, probeItem := range container.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe storage.ContainerAppProbe
			err := probeItem.AssignProperties_To_ContainerAppProbe(&probe)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// Resources
	if container.Resources != nil {
		var resource storage.ContainerResources
		err := container.Resources.AssignProperties_To_ContainerResources(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerResources() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount
			err := volumeMountItem.AssignProperties_To_VolumeMount(&volumeMount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VolumeMount() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Container_STATUS populates our Container from the provided source Container_STATUS
func (container *Container) Initialize_From_Container_STATUS(source *Container_STATUS) error {

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar
			err := env.Initialize_From_EnvironmentVar_STATUS(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Probes
	if source.Probes != nil {
		probeList := make([]ContainerAppProbe, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe ContainerAppProbe
			err := probe.Initialize_From_ContainerAppProbe_STATUS(&probeItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ContainerAppProbe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		container.Probes = probeList
	} else {
		container.Probes = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ContainerResources
		err := resource.Initialize_From_ContainerResources_STATUS(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ContainerResources_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount
			err := volumeMount.Initialize_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// Container App container definition
type Container_STATUS struct {
	// Args: Container start command arguments.
	Args []string `json:"args,omitempty"`

	// Command: Container start command.
	Command []string `json:"command,omitempty"`

	// Env: Container environment variables.
	Env []EnvironmentVar_STATUS `json:"env,omitempty"`

	// Image: Container image tag.
	Image *string `json:"image,omitempty"`

	// Name: Custom container name.
	Name *string `json:"name,omitempty"`

	// Probes: List of probes for the container.
	Probes []ContainerAppProbe_STATUS `json:"probes,omitempty"`

	// Resources: Container resource requirements.
	Resources *ContainerResources_STATUS `json:"resources,omitempty"`

	// VolumeMounts: Container volume mounts.
	VolumeMounts []VolumeMount_STATUS `json:"volumeMounts,omitempty"`
}

var _ genruntime.FromARMConverter = &Container_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *Container_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Container_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *Container_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Container_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Container_STATUS, got %T", armInput)
	}

	// Set property "Args":
	for _, item := range typedInput.Args {
		container.Args = append(container.Args, item)
	}

	// Set property "Command":
	for _, item := range typedInput.Command {
		container.Command = append(container.Command, item)
	}

	// Set property "Env":
	for _, item := range typedInput.Env {
		var item1 EnvironmentVar_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.Env = append(container.Env, item1)
	}

	// Set property "Image":
	if typedInput.Image != nil {
		image := *typedInput.Image
		container.Image = &image
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property "Probes":
	for _, item := range typedInput.Probes {
		var item1 ContainerAppProbe_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.Probes = append(container.Probes, item1)
	}

	// Set property "Resources":
	if typedInput.Resources != nil {
		var resources1 ContainerResources_STATUS
		err := resources1.PopulateFromARM(owner, *typedInput.Resources)
		if err != nil {
			return err
		}
		resources := resources1
		container.Resources = &resources
	}

	// Set property "VolumeMounts":
	for _, item := range typedInput.VolumeMounts {
		var item1 VolumeMount_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		container.VolumeMounts = append(container.VolumeMounts, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Container_STATUS populates our Container_STATUS from the provided source Container_STATUS
func (container *Container_STATUS) AssignProperties_From_Container_STATUS(source *storage.Container_STATUS) error {

	// Args
	container.Args = genruntime.CloneSliceOfString(source.Args)

	// Command
	container.Command = genruntime.CloneSliceOfString(source.Command)

	// Env
	if source.Env != nil {
		envList := make([]EnvironmentVar_STATUS, len(source.Env))
		for envIndex, envItem := range source.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env EnvironmentVar_STATUS
			err := env.AssignProperties_From_EnvironmentVar_STATUS(&envItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		container.Env = envList
	} else {
		container.Env = nil
	}

	// Image
	container.Image = genruntime.ClonePointerToString(source.Image)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Probes
	if source.Probes != nil {
		probeList := make([]ContainerAppProbe_STATUS, len(source.Probes))
		for probeIndex, probeItem := range source.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe ContainerAppProbe_STATUS
			err := probe.AssignProperties_From_ContainerAppProbe_STATUS(&probeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		container.Probes = probeList
	} else {
		container.Probes = nil
	}

	// Resources
	if source.Resources != nil {
		var resource ContainerResources_STATUS
		err := resource.AssignProperties_From_ContainerResources_STATUS(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerResources_STATUS() to populate field Resources")
		}
		container.Resources = &resource
	} else {
		container.Resources = nil
	}

	// VolumeMounts
	if source.VolumeMounts != nil {
		volumeMountList := make([]VolumeMount_STATUS, len(source.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range source.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount VolumeMount_STATUS
			err := volumeMount.AssignProperties_From_VolumeMount_STATUS(&volumeMountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		container.VolumeMounts = volumeMountList
	} else {
		container.VolumeMounts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Container_STATUS populates the provided destination Container_STATUS from our Container_STATUS
func (container *Container_STATUS) AssignProperties_To_Container_STATUS(destination *storage.Container_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Args
	destination.Args = genruntime.CloneSliceOfString(container.Args)

	// Command
	destination.Command = genruntime.CloneSliceOfString(container.Command)

	// Env
	if container.Env != nil {
		envList := make([]storage.EnvironmentVar_STATUS, len(container.Env))
		for envIndex, envItem := range container.Env {
			// Shadow the loop variable to avoid aliasing
			envItem := envItem
			var env storage.EnvironmentVar_STATUS
			err := envItem.AssignProperties_To_EnvironmentVar_STATUS(&env)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnvironmentVar_STATUS() to populate field Env")
			}
			envList[envIndex] = env
		}
		destination.Env = envList
	} else {
		destination.Env = nil
	}

	// Image
	destination.Image = genruntime.ClonePointerToString(container.Image)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Probes
	if container.Probes != nil {
		probeList := make([]storage.ContainerAppProbe_STATUS, len(container.Probes))
		for probeIndex, probeItem := range container.Probes {
			// Shadow the loop variable to avoid aliasing
			probeItem := probeItem
			var probe storage.ContainerAppProbe_STATUS
			err := probeItem.AssignProperties_To_ContainerAppProbe_STATUS(&probe)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_STATUS() to populate field Probes")
			}
			probeList[probeIndex] = probe
		}
		destination.Probes = probeList
	} else {
		destination.Probes = nil
	}

	// Resources
	if container.Resources != nil {
		var resource storage.ContainerResources_STATUS
		err := container.Resources.AssignProperties_To_ContainerResources_STATUS(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerResources_STATUS() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// VolumeMounts
	if container.VolumeMounts != nil {
		volumeMountList := make([]storage.VolumeMount_STATUS, len(container.VolumeMounts))
		for volumeMountIndex, volumeMountItem := range container.VolumeMounts {
			// Shadow the loop variable to avoid aliasing
			volumeMountItem := volumeMountItem
			var volumeMount storage.VolumeMount_STATUS
			err := volumeMountItem.AssignProperties_To_VolumeMount_STATUS(&volumeMount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VolumeMount_STATUS() to populate field VolumeMounts")
			}
			volumeMountList[volumeMountIndex] = volumeMount
		}
		destination.VolumeMounts = volumeMountList
	} else {
		destination.VolumeMounts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerAppOperatorConfigMaps struct {
	// EventStreamEndpoint: indicates where the EventStreamEndpoint config map should be placed. If omitted, no config map will
	// be created.
	EventStreamEndpoint *genruntime.ConfigMapDestination `json:"eventStreamEndpoint,omitempty"`

	// Fqdn: indicates where the Fqdn config map should be placed. If omitted, no config map will be created.
	Fqdn *genruntime.ConfigMapDestination `json:"fqdn,omitempty"`
}

// AssignProperties_From_ContainerAppOperatorConfigMaps populates our ContainerAppOperatorConfigMaps from the provided source ContainerAppOperatorConfigMaps
func (maps *ContainerAppOperatorConfigMaps) AssignProperties_From_ContainerAppOperatorConfigMaps(source *storage.ContainerAppOperatorConfigMaps) error {

	// EventStreamEndpoint
	if source.EventStreamEndpoint != nil {
		eventStreamEndpoint := source.EventStreamEndpoint.Copy()
		maps.EventStreamEndpoint = &eventStreamEndpoint
	} else {
		maps.EventStreamEndpoint = nil
	}

	// Fqdn
	if source.Fqdn != nil {
		fqdn := source.Fqdn.Copy()
		maps.Fqdn = &fqdn
	} else {
		maps.Fqdn = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppOperatorConfigMaps populates the provided destination ContainerAppOperatorConfigMaps from our ContainerAppOperatorConfigMaps
func (maps *ContainerAppOperatorConfigMaps) AssignProperties_To_ContainerAppOperatorConfigMaps(destination *storage.ContainerAppOperatorConfigMaps) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventStreamEndpoint
	if maps.EventStreamEndpoint != nil {
		eventStreamEndpoint := maps.EventStreamEndpoint.Copy()
		destination.EventStreamEndpoint = &eventStreamEndpoint
	} else {
		destination.EventStreamEndpoint = nil
	}

	// Fqdn
	if maps.Fqdn != nil {
		fqdn := maps.Fqdn.Copy()
		destination.Fqdn = &fqdn
	} else {
		destination.Fqdn = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App Dapr configuration.
type Dapr struct {
	// AppId: Dapr application identifier
	AppId *string `json:"appId,omitempty"`

	// AppPort: Tells Dapr which port your application is listening on
	AppPort *int `json:"appPort,omitempty"`

	// AppProtocol: Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
	AppProtocol *Dapr_AppProtocol `json:"appProtocol,omitempty"`

	// EnableApiLogging: Enables API logging for the Dapr sidecar
	EnableApiLogging *bool `json:"enableApiLogging,omitempty"`

	// Enabled: Boolean indicating if the Dapr side car is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// HttpMaxRequestSize: Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big
	// files. Default is 4 MB.
	HttpMaxRequestSize *int `json:"httpMaxRequestSize,omitempty"`

	// HttpReadBufferSize: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is
	// 65KB.
	HttpReadBufferSize *int `json:"httpReadBufferSize,omitempty"`

	// LogLevel: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
	LogLevel *Dapr_LogLevel `json:"logLevel,omitempty"`
}

var _ genruntime.ARMTransformer = &Dapr{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (dapr *Dapr) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if dapr == nil {
		return nil, nil
	}
	result := &arm.Dapr{}

	// Set property "AppId":
	if dapr.AppId != nil {
		appId := *dapr.AppId
		result.AppId = &appId
	}

	// Set property "AppPort":
	if dapr.AppPort != nil {
		appPort := *dapr.AppPort
		result.AppPort = &appPort
	}

	// Set property "AppProtocol":
	if dapr.AppProtocol != nil {
		var temp string
		temp = string(*dapr.AppProtocol)
		appProtocol := arm.Dapr_AppProtocol(temp)
		result.AppProtocol = &appProtocol
	}

	// Set property "EnableApiLogging":
	if dapr.EnableApiLogging != nil {
		enableApiLogging := *dapr.EnableApiLogging
		result.EnableApiLogging = &enableApiLogging
	}

	// Set property "Enabled":
	if dapr.Enabled != nil {
		enabled := *dapr.Enabled
		result.Enabled = &enabled
	}

	// Set property "HttpMaxRequestSize":
	if dapr.HttpMaxRequestSize != nil {
		httpMaxRequestSize := *dapr.HttpMaxRequestSize
		result.HttpMaxRequestSize = &httpMaxRequestSize
	}

	// Set property "HttpReadBufferSize":
	if dapr.HttpReadBufferSize != nil {
		httpReadBufferSize := *dapr.HttpReadBufferSize
		result.HttpReadBufferSize = &httpReadBufferSize
	}

	// Set property "LogLevel":
	if dapr.LogLevel != nil {
		var temp string
		temp = string(*dapr.LogLevel)
		logLevel := arm.Dapr_LogLevel(temp)
		result.LogLevel = &logLevel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (dapr *Dapr) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Dapr{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (dapr *Dapr) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Dapr)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Dapr, got %T", armInput)
	}

	// Set property "AppId":
	if typedInput.AppId != nil {
		appId := *typedInput.AppId
		dapr.AppId = &appId
	}

	// Set property "AppPort":
	if typedInput.AppPort != nil {
		appPort := *typedInput.AppPort
		dapr.AppPort = &appPort
	}

	// Set property "AppProtocol":
	if typedInput.AppProtocol != nil {
		var temp string
		temp = string(*typedInput.AppProtocol)
		appProtocol := Dapr_AppProtocol(temp)
		dapr.AppProtocol = &appProtocol
	}

	// Set property "EnableApiLogging":
	if typedInput.EnableApiLogging != nil {
		enableApiLogging := *typedInput.EnableApiLogging
		dapr.EnableApiLogging = &enableApiLogging
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		dapr.Enabled = &enabled
	}

	// Set property "HttpMaxRequestSize":
	if typedInput.HttpMaxRequestSize != nil {
		httpMaxRequestSize := *typedInput.HttpMaxRequestSize
		dapr.HttpMaxRequestSize = &httpMaxRequestSize
	}

	// Set property "HttpReadBufferSize":
	if typedInput.HttpReadBufferSize != nil {
		httpReadBufferSize := *typedInput.HttpReadBufferSize
		dapr.HttpReadBufferSize = &httpReadBufferSize
	}

	// Set property "LogLevel":
	if typedInput.LogLevel != nil {
		var temp string
		temp = string(*typedInput.LogLevel)
		logLevel := Dapr_LogLevel(temp)
		dapr.LogLevel = &logLevel
	}

	// No error
	return nil
}

// AssignProperties_From_Dapr populates our Dapr from the provided source Dapr
func (dapr *Dapr) AssignProperties_From_Dapr(source *storage.Dapr) error {

	// AppId
	dapr.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppPort
	dapr.AppPort = genruntime.ClonePointerToInt(source.AppPort)

	// AppProtocol
	if source.AppProtocol != nil {
		appProtocol := *source.AppProtocol
		appProtocolTemp := genruntime.ToEnum(appProtocol, dapr_AppProtocol_Values)
		dapr.AppProtocol = &appProtocolTemp
	} else {
		dapr.AppProtocol = nil
	}

	// EnableApiLogging
	if source.EnableApiLogging != nil {
		enableApiLogging := *source.EnableApiLogging
		dapr.EnableApiLogging = &enableApiLogging
	} else {
		dapr.EnableApiLogging = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		dapr.Enabled = &enabled
	} else {
		dapr.Enabled = nil
	}

	// HttpMaxRequestSize
	dapr.HttpMaxRequestSize = genruntime.ClonePointerToInt(source.HttpMaxRequestSize)

	// HttpReadBufferSize
	dapr.HttpReadBufferSize = genruntime.ClonePointerToInt(source.HttpReadBufferSize)

	// LogLevel
	if source.LogLevel != nil {
		logLevel := *source.LogLevel
		logLevelTemp := genruntime.ToEnum(logLevel, dapr_LogLevel_Values)
		dapr.LogLevel = &logLevelTemp
	} else {
		dapr.LogLevel = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Dapr populates the provided destination Dapr from our Dapr
func (dapr *Dapr) AssignProperties_To_Dapr(destination *storage.Dapr) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppId
	destination.AppId = genruntime.ClonePointerToString(dapr.AppId)

	// AppPort
	destination.AppPort = genruntime.ClonePointerToInt(dapr.AppPort)

	// AppProtocol
	if dapr.AppProtocol != nil {
		appProtocol := string(*dapr.AppProtocol)
		destination.AppProtocol = &appProtocol
	} else {
		destination.AppProtocol = nil
	}

	// EnableApiLogging
	if dapr.EnableApiLogging != nil {
		enableApiLogging := *dapr.EnableApiLogging
		destination.EnableApiLogging = &enableApiLogging
	} else {
		destination.EnableApiLogging = nil
	}

	// Enabled
	if dapr.Enabled != nil {
		enabled := *dapr.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HttpMaxRequestSize
	destination.HttpMaxRequestSize = genruntime.ClonePointerToInt(dapr.HttpMaxRequestSize)

	// HttpReadBufferSize
	destination.HttpReadBufferSize = genruntime.ClonePointerToInt(dapr.HttpReadBufferSize)

	// LogLevel
	if dapr.LogLevel != nil {
		logLevel := string(*dapr.LogLevel)
		destination.LogLevel = &logLevel
	} else {
		destination.LogLevel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Dapr_STATUS populates our Dapr from the provided source Dapr_STATUS
func (dapr *Dapr) Initialize_From_Dapr_STATUS(source *Dapr_STATUS) error {

	// AppId
	dapr.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppPort
	dapr.AppPort = genruntime.ClonePointerToInt(source.AppPort)

	// AppProtocol
	if source.AppProtocol != nil {
		appProtocol := genruntime.ToEnum(string(*source.AppProtocol), dapr_AppProtocol_Values)
		dapr.AppProtocol = &appProtocol
	} else {
		dapr.AppProtocol = nil
	}

	// EnableApiLogging
	if source.EnableApiLogging != nil {
		enableApiLogging := *source.EnableApiLogging
		dapr.EnableApiLogging = &enableApiLogging
	} else {
		dapr.EnableApiLogging = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		dapr.Enabled = &enabled
	} else {
		dapr.Enabled = nil
	}

	// HttpMaxRequestSize
	dapr.HttpMaxRequestSize = genruntime.ClonePointerToInt(source.HttpMaxRequestSize)

	// HttpReadBufferSize
	dapr.HttpReadBufferSize = genruntime.ClonePointerToInt(source.HttpReadBufferSize)

	// LogLevel
	if source.LogLevel != nil {
		logLevel := genruntime.ToEnum(string(*source.LogLevel), dapr_LogLevel_Values)
		dapr.LogLevel = &logLevel
	} else {
		dapr.LogLevel = nil
	}

	// No error
	return nil
}

// Container App Dapr configuration.
type Dapr_STATUS struct {
	// AppId: Dapr application identifier
	AppId *string `json:"appId,omitempty"`

	// AppPort: Tells Dapr which port your application is listening on
	AppPort *int `json:"appPort,omitempty"`

	// AppProtocol: Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
	AppProtocol *Dapr_AppProtocol_STATUS `json:"appProtocol,omitempty"`

	// EnableApiLogging: Enables API logging for the Dapr sidecar
	EnableApiLogging *bool `json:"enableApiLogging,omitempty"`

	// Enabled: Boolean indicating if the Dapr side car is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// HttpMaxRequestSize: Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big
	// files. Default is 4 MB.
	HttpMaxRequestSize *int `json:"httpMaxRequestSize,omitempty"`

	// HttpReadBufferSize: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is
	// 65KB.
	HttpReadBufferSize *int `json:"httpReadBufferSize,omitempty"`

	// LogLevel: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
	LogLevel *Dapr_LogLevel_STATUS `json:"logLevel,omitempty"`
}

var _ genruntime.FromARMConverter = &Dapr_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (dapr *Dapr_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Dapr_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (dapr *Dapr_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Dapr_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Dapr_STATUS, got %T", armInput)
	}

	// Set property "AppId":
	if typedInput.AppId != nil {
		appId := *typedInput.AppId
		dapr.AppId = &appId
	}

	// Set property "AppPort":
	if typedInput.AppPort != nil {
		appPort := *typedInput.AppPort
		dapr.AppPort = &appPort
	}

	// Set property "AppProtocol":
	if typedInput.AppProtocol != nil {
		var temp string
		temp = string(*typedInput.AppProtocol)
		appProtocol := Dapr_AppProtocol_STATUS(temp)
		dapr.AppProtocol = &appProtocol
	}

	// Set property "EnableApiLogging":
	if typedInput.EnableApiLogging != nil {
		enableApiLogging := *typedInput.EnableApiLogging
		dapr.EnableApiLogging = &enableApiLogging
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		dapr.Enabled = &enabled
	}

	// Set property "HttpMaxRequestSize":
	if typedInput.HttpMaxRequestSize != nil {
		httpMaxRequestSize := *typedInput.HttpMaxRequestSize
		dapr.HttpMaxRequestSize = &httpMaxRequestSize
	}

	// Set property "HttpReadBufferSize":
	if typedInput.HttpReadBufferSize != nil {
		httpReadBufferSize := *typedInput.HttpReadBufferSize
		dapr.HttpReadBufferSize = &httpReadBufferSize
	}

	// Set property "LogLevel":
	if typedInput.LogLevel != nil {
		var temp string
		temp = string(*typedInput.LogLevel)
		logLevel := Dapr_LogLevel_STATUS(temp)
		dapr.LogLevel = &logLevel
	}

	// No error
	return nil
}

// AssignProperties_From_Dapr_STATUS populates our Dapr_STATUS from the provided source Dapr_STATUS
func (dapr *Dapr_STATUS) AssignProperties_From_Dapr_STATUS(source *storage.Dapr_STATUS) error {

	// AppId
	dapr.AppId = genruntime.ClonePointerToString(source.AppId)

	// AppPort
	dapr.AppPort = genruntime.ClonePointerToInt(source.AppPort)

	// AppProtocol
	if source.AppProtocol != nil {
		appProtocol := *source.AppProtocol
		appProtocolTemp := genruntime.ToEnum(appProtocol, dapr_AppProtocol_STATUS_Values)
		dapr.AppProtocol = &appProtocolTemp
	} else {
		dapr.AppProtocol = nil
	}

	// EnableApiLogging
	if source.EnableApiLogging != nil {
		enableApiLogging := *source.EnableApiLogging
		dapr.EnableApiLogging = &enableApiLogging
	} else {
		dapr.EnableApiLogging = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		dapr.Enabled = &enabled
	} else {
		dapr.Enabled = nil
	}

	// HttpMaxRequestSize
	dapr.HttpMaxRequestSize = genruntime.ClonePointerToInt(source.HttpMaxRequestSize)

	// HttpReadBufferSize
	dapr.HttpReadBufferSize = genruntime.ClonePointerToInt(source.HttpReadBufferSize)

	// LogLevel
	if source.LogLevel != nil {
		logLevel := *source.LogLevel
		logLevelTemp := genruntime.ToEnum(logLevel, dapr_LogLevel_STATUS_Values)
		dapr.LogLevel = &logLevelTemp
	} else {
		dapr.LogLevel = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Dapr_STATUS populates the provided destination Dapr_STATUS from our Dapr_STATUS
func (dapr *Dapr_STATUS) AssignProperties_To_Dapr_STATUS(destination *storage.Dapr_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppId
	destination.AppId = genruntime.ClonePointerToString(dapr.AppId)

	// AppPort
	destination.AppPort = genruntime.ClonePointerToInt(dapr.AppPort)

	// AppProtocol
	if dapr.AppProtocol != nil {
		appProtocol := string(*dapr.AppProtocol)
		destination.AppProtocol = &appProtocol
	} else {
		destination.AppProtocol = nil
	}

	// EnableApiLogging
	if dapr.EnableApiLogging != nil {
		enableApiLogging := *dapr.EnableApiLogging
		destination.EnableApiLogging = &enableApiLogging
	} else {
		destination.EnableApiLogging = nil
	}

	// Enabled
	if dapr.Enabled != nil {
		enabled := *dapr.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HttpMaxRequestSize
	destination.HttpMaxRequestSize = genruntime.ClonePointerToInt(dapr.HttpMaxRequestSize)

	// HttpReadBufferSize
	destination.HttpReadBufferSize = genruntime.ClonePointerToInt(dapr.HttpReadBufferSize)

	// LogLevel
	if dapr.LogLevel != nil {
		logLevel := string(*dapr.LogLevel)
		destination.LogLevel = &logLevel
	} else {
		destination.LogLevel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The type of extendedLocation.
// +kubebuilder:validation:Enum={"CustomLocation"}
type ExtendedLocationType string

const ExtendedLocationType_CustomLocation = ExtendedLocationType("CustomLocation")

// Mapping from string to ExtendedLocationType
var extendedLocationType_Values = map[string]ExtendedLocationType{
	"customlocation": ExtendedLocationType_CustomLocation,
}

// The type of extendedLocation.
type ExtendedLocationType_STATUS string

const ExtendedLocationType_STATUS_CustomLocation = ExtendedLocationType_STATUS("CustomLocation")

// Mapping from string to ExtendedLocationType_STATUS
var extendedLocationType_STATUS_Values = map[string]ExtendedLocationType_STATUS{
	"customlocation": ExtendedLocationType_STATUS_CustomLocation,
}

// Container App Ingress configuration.
type Ingress struct {
	// AdditionalPortMappings: Settings to expose additional ports on container app
	AdditionalPortMappings []IngressPortMapping `json:"additionalPortMappings,omitempty"`

	// AllowInsecure: Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically
	// redirected to HTTPS connections
	AllowInsecure *bool `json:"allowInsecure,omitempty"`

	// ClientCertificateMode: Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate
	// on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require
	// indicates server requires a client certificate.
	ClientCertificateMode *Ingress_ClientCertificateMode `json:"clientCertificateMode,omitempty"`

	// CorsPolicy: CORS policy for container app
	CorsPolicy *CorsPolicy `json:"corsPolicy,omitempty"`

	// CustomDomains: custom domain bindings for Container Apps' hostnames.
	CustomDomains []CustomDomain `json:"customDomains,omitempty"`

	// ExposedPort: Exposed Port in containers for TCP traffic from ingress
	ExposedPort *int `json:"exposedPort,omitempty"`

	// External: Bool indicating if app exposes an external http endpoint
	External *bool `json:"external,omitempty"`

	// IpSecurityRestrictions: Rules to restrict incoming IP address.
	IpSecurityRestrictions []IpSecurityRestrictionRule `json:"ipSecurityRestrictions,omitempty"`

	// StickySessions: Sticky Sessions for Single Revision Mode
	StickySessions *Ingress_StickySessions `json:"stickySessions,omitempty"`

	// TargetPort: Target Port in containers for traffic from ingress
	TargetPort *int `json:"targetPort,omitempty"`

	// Traffic: Traffic weights for app's revisions
	Traffic []TrafficWeight `json:"traffic,omitempty"`

	// Transport: Ingress transport protocol
	Transport *Ingress_Transport `json:"transport,omitempty"`
}

var _ genruntime.ARMTransformer = &Ingress{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ingress *Ingress) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ingress == nil {
		return nil, nil
	}
	result := &arm.Ingress{}

	// Set property "AdditionalPortMappings":
	for _, item := range ingress.AdditionalPortMappings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AdditionalPortMappings = append(result.AdditionalPortMappings, *item_ARM.(*arm.IngressPortMapping))
	}

	// Set property "AllowInsecure":
	if ingress.AllowInsecure != nil {
		allowInsecure := *ingress.AllowInsecure
		result.AllowInsecure = &allowInsecure
	}

	// Set property "ClientCertificateMode":
	if ingress.ClientCertificateMode != nil {
		var temp string
		temp = string(*ingress.ClientCertificateMode)
		clientCertificateMode := arm.Ingress_ClientCertificateMode(temp)
		result.ClientCertificateMode = &clientCertificateMode
	}

	// Set property "CorsPolicy":
	if ingress.CorsPolicy != nil {
		corsPolicy_ARM, err := (*ingress.CorsPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		corsPolicy := *corsPolicy_ARM.(*arm.CorsPolicy)
		result.CorsPolicy = &corsPolicy
	}

	// Set property "CustomDomains":
	for _, item := range ingress.CustomDomains {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.CustomDomains = append(result.CustomDomains, *item_ARM.(*arm.CustomDomain))
	}

	// Set property "ExposedPort":
	if ingress.ExposedPort != nil {
		exposedPort := *ingress.ExposedPort
		result.ExposedPort = &exposedPort
	}

	// Set property "External":
	if ingress.External != nil {
		external := *ingress.External
		result.External = &external
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range ingress.IpSecurityRestrictions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpSecurityRestrictions = append(result.IpSecurityRestrictions, *item_ARM.(*arm.IpSecurityRestrictionRule))
	}

	// Set property "StickySessions":
	if ingress.StickySessions != nil {
		stickySessions_ARM, err := (*ingress.StickySessions).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		stickySessions := *stickySessions_ARM.(*arm.Ingress_StickySessions)
		result.StickySessions = &stickySessions
	}

	// Set property "TargetPort":
	if ingress.TargetPort != nil {
		targetPort := *ingress.TargetPort
		result.TargetPort = &targetPort
	}

	// Set property "Traffic":
	for _, item := range ingress.Traffic {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Traffic = append(result.Traffic, *item_ARM.(*arm.TrafficWeight))
	}

	// Set property "Transport":
	if ingress.Transport != nil {
		var temp string
		temp = string(*ingress.Transport)
		transport := arm.Ingress_Transport(temp)
		result.Transport = &transport
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ingress *Ingress) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Ingress{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ingress *Ingress) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Ingress)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Ingress, got %T", armInput)
	}

	// Set property "AdditionalPortMappings":
	for _, item := range typedInput.AdditionalPortMappings {
		var item1 IngressPortMapping
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ingress.AdditionalPortMappings = append(ingress.AdditionalPortMappings, item1)
	}

	// Set property "AllowInsecure":
	if typedInput.AllowInsecure != nil {
		allowInsecure := *typedInput.AllowInsecure
		ingress.AllowInsecure = &allowInsecure
	}

	// Set property "ClientCertificateMode":
	if typedInput.ClientCertificateMode != nil {
		var temp string
		temp = string(*typedInput.ClientCertificateMode)
		clientCertificateMode := Ingress_ClientCertificateMode(temp)
		ingress.ClientCertificateMode = &clientCertificateMode
	}

	// Set property "CorsPolicy":
	if typedInput.CorsPolicy != nil {
		var corsPolicy1 CorsPolicy
		err := corsPolicy1.PopulateFromARM(owner, *typedInput.CorsPolicy)
		if err != nil {
			return err
		}
		corsPolicy := corsPolicy1
		ingress.CorsPolicy = &corsPolicy
	}

	// Set property "CustomDomains":
	for _, item := range typedInput.CustomDomains {
		var item1 CustomDomain
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ingress.CustomDomains = append(ingress.CustomDomains, item1)
	}

	// Set property "ExposedPort":
	if typedInput.ExposedPort != nil {
		exposedPort := *typedInput.ExposedPort
		ingress.ExposedPort = &exposedPort
	}

	// Set property "External":
	if typedInput.External != nil {
		external := *typedInput.External
		ingress.External = &external
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range typedInput.IpSecurityRestrictions {
		var item1 IpSecurityRestrictionRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ingress.IpSecurityRestrictions = append(ingress.IpSecurityRestrictions, item1)
	}

	// Set property "StickySessions":
	if typedInput.StickySessions != nil {
		var stickySessions1 Ingress_StickySessions
		err := stickySessions1.PopulateFromARM(owner, *typedInput.StickySessions)
		if err != nil {
			return err
		}
		stickySessions := stickySessions1
		ingress.StickySessions = &stickySessions
	}

	// Set property "TargetPort":
	if typedInput.TargetPort != nil {
		targetPort := *typedInput.TargetPort
		ingress.TargetPort = &targetPort
	}

	// Set property "Traffic":
	for _, item := range typedInput.Traffic {
		var item1 TrafficWeight
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ingress.Traffic = append(ingress.Traffic, item1)
	}

	// Set property "Transport":
	if typedInput.Transport != nil {
		var temp string
		temp = string(*typedInput.Transport)
		transport := Ingress_Transport(temp)
		ingress.Transport = &transport
	}

	// No error
	return nil
}

// AssignProperties_From_Ingress populates our Ingress from the provided source Ingress
func (ingress *Ingress) AssignProperties_From_Ingress(source *storage.Ingress) error {

	// AdditionalPortMappings
	if source.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]IngressPortMapping, len(source.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range source.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping IngressPortMapping
			err := additionalPortMapping.AssignProperties_From_IngressPortMapping(&additionalPortMappingItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IngressPortMapping() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		ingress.AdditionalPortMappings = additionalPortMappingList
	} else {
		ingress.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if source.AllowInsecure != nil {
		allowInsecure := *source.AllowInsecure
		ingress.AllowInsecure = &allowInsecure
	} else {
		ingress.AllowInsecure = nil
	}

	// ClientCertificateMode
	if source.ClientCertificateMode != nil {
		clientCertificateMode := *source.ClientCertificateMode
		clientCertificateModeTemp := genruntime.ToEnum(clientCertificateMode, ingress_ClientCertificateMode_Values)
		ingress.ClientCertificateMode = &clientCertificateModeTemp
	} else {
		ingress.ClientCertificateMode = nil
	}

	// CorsPolicy
	if source.CorsPolicy != nil {
		var corsPolicy CorsPolicy
		err := corsPolicy.AssignProperties_From_CorsPolicy(source.CorsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CorsPolicy() to populate field CorsPolicy")
		}
		ingress.CorsPolicy = &corsPolicy
	} else {
		ingress.CorsPolicy = nil
	}

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]CustomDomain, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain CustomDomain
			err := customDomain.AssignProperties_From_CustomDomain(&customDomainItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CustomDomain() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		ingress.CustomDomains = customDomainList
	} else {
		ingress.CustomDomains = nil
	}

	// ExposedPort
	ingress.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		ingress.External = &external
	} else {
		ingress.External = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestrictionRule, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestrictionRule
			err := ipSecurityRestriction.AssignProperties_From_IpSecurityRestrictionRule(&ipSecurityRestrictionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpSecurityRestrictionRule() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		ingress.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		ingress.IpSecurityRestrictions = nil
	}

	// StickySessions
	if source.StickySessions != nil {
		var stickySession Ingress_StickySessions
		err := stickySession.AssignProperties_From_Ingress_StickySessions(source.StickySessions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Ingress_StickySessions() to populate field StickySessions")
		}
		ingress.StickySessions = &stickySession
	} else {
		ingress.StickySessions = nil
	}

	// TargetPort
	ingress.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// Traffic
	if source.Traffic != nil {
		trafficList := make([]TrafficWeight, len(source.Traffic))
		for trafficIndex, trafficItem := range source.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic TrafficWeight
			err := traffic.AssignProperties_From_TrafficWeight(&trafficItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TrafficWeight() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		ingress.Traffic = trafficList
	} else {
		ingress.Traffic = nil
	}

	// Transport
	if source.Transport != nil {
		transport := *source.Transport
		transportTemp := genruntime.ToEnum(transport, ingress_Transport_Values)
		ingress.Transport = &transportTemp
	} else {
		ingress.Transport = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Ingress populates the provided destination Ingress from our Ingress
func (ingress *Ingress) AssignProperties_To_Ingress(destination *storage.Ingress) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalPortMappings
	if ingress.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]storage.IngressPortMapping, len(ingress.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range ingress.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping storage.IngressPortMapping
			err := additionalPortMappingItem.AssignProperties_To_IngressPortMapping(&additionalPortMapping)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IngressPortMapping() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		destination.AdditionalPortMappings = additionalPortMappingList
	} else {
		destination.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if ingress.AllowInsecure != nil {
		allowInsecure := *ingress.AllowInsecure
		destination.AllowInsecure = &allowInsecure
	} else {
		destination.AllowInsecure = nil
	}

	// ClientCertificateMode
	if ingress.ClientCertificateMode != nil {
		clientCertificateMode := string(*ingress.ClientCertificateMode)
		destination.ClientCertificateMode = &clientCertificateMode
	} else {
		destination.ClientCertificateMode = nil
	}

	// CorsPolicy
	if ingress.CorsPolicy != nil {
		var corsPolicy storage.CorsPolicy
		err := ingress.CorsPolicy.AssignProperties_To_CorsPolicy(&corsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CorsPolicy() to populate field CorsPolicy")
		}
		destination.CorsPolicy = &corsPolicy
	} else {
		destination.CorsPolicy = nil
	}

	// CustomDomains
	if ingress.CustomDomains != nil {
		customDomainList := make([]storage.CustomDomain, len(ingress.CustomDomains))
		for customDomainIndex, customDomainItem := range ingress.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain storage.CustomDomain
			err := customDomainItem.AssignProperties_To_CustomDomain(&customDomain)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CustomDomain() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// ExposedPort
	destination.ExposedPort = genruntime.ClonePointerToInt(ingress.ExposedPort)

	// External
	if ingress.External != nil {
		external := *ingress.External
		destination.External = &external
	} else {
		destination.External = nil
	}

	// IpSecurityRestrictions
	if ingress.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]storage.IpSecurityRestrictionRule, len(ingress.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range ingress.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction storage.IpSecurityRestrictionRule
			err := ipSecurityRestrictionItem.AssignProperties_To_IpSecurityRestrictionRule(&ipSecurityRestriction)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpSecurityRestrictionRule() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// StickySessions
	if ingress.StickySessions != nil {
		var stickySession storage.Ingress_StickySessions
		err := ingress.StickySessions.AssignProperties_To_Ingress_StickySessions(&stickySession)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Ingress_StickySessions() to populate field StickySessions")
		}
		destination.StickySessions = &stickySession
	} else {
		destination.StickySessions = nil
	}

	// TargetPort
	destination.TargetPort = genruntime.ClonePointerToInt(ingress.TargetPort)

	// Traffic
	if ingress.Traffic != nil {
		trafficList := make([]storage.TrafficWeight, len(ingress.Traffic))
		for trafficIndex, trafficItem := range ingress.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic storage.TrafficWeight
			err := trafficItem.AssignProperties_To_TrafficWeight(&traffic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TrafficWeight() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		destination.Traffic = trafficList
	} else {
		destination.Traffic = nil
	}

	// Transport
	if ingress.Transport != nil {
		transport := string(*ingress.Transport)
		destination.Transport = &transport
	} else {
		destination.Transport = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Ingress_STATUS populates our Ingress from the provided source Ingress_STATUS
func (ingress *Ingress) Initialize_From_Ingress_STATUS(source *Ingress_STATUS) error {

	// AdditionalPortMappings
	if source.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]IngressPortMapping, len(source.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range source.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping IngressPortMapping
			err := additionalPortMapping.Initialize_From_IngressPortMapping_STATUS(&additionalPortMappingItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_IngressPortMapping_STATUS() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		ingress.AdditionalPortMappings = additionalPortMappingList
	} else {
		ingress.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if source.AllowInsecure != nil {
		allowInsecure := *source.AllowInsecure
		ingress.AllowInsecure = &allowInsecure
	} else {
		ingress.AllowInsecure = nil
	}

	// ClientCertificateMode
	if source.ClientCertificateMode != nil {
		clientCertificateMode := genruntime.ToEnum(string(*source.ClientCertificateMode), ingress_ClientCertificateMode_Values)
		ingress.ClientCertificateMode = &clientCertificateMode
	} else {
		ingress.ClientCertificateMode = nil
	}

	// CorsPolicy
	if source.CorsPolicy != nil {
		var corsPolicy CorsPolicy
		err := corsPolicy.Initialize_From_CorsPolicy_STATUS(source.CorsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_CorsPolicy_STATUS() to populate field CorsPolicy")
		}
		ingress.CorsPolicy = &corsPolicy
	} else {
		ingress.CorsPolicy = nil
	}

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]CustomDomain, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain CustomDomain
			err := customDomain.Initialize_From_CustomDomain_STATUS(&customDomainItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_CustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		ingress.CustomDomains = customDomainList
	} else {
		ingress.CustomDomains = nil
	}

	// ExposedPort
	ingress.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		ingress.External = &external
	} else {
		ingress.External = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestrictionRule, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestrictionRule
			err := ipSecurityRestriction.Initialize_From_IpSecurityRestrictionRule_STATUS(&ipSecurityRestrictionItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_IpSecurityRestrictionRule_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		ingress.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		ingress.IpSecurityRestrictions = nil
	}

	// StickySessions
	if source.StickySessions != nil {
		var stickySession Ingress_StickySessions
		err := stickySession.Initialize_From_Ingress_StickySessions_STATUS(source.StickySessions)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Ingress_StickySessions_STATUS() to populate field StickySessions")
		}
		ingress.StickySessions = &stickySession
	} else {
		ingress.StickySessions = nil
	}

	// TargetPort
	ingress.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// Traffic
	if source.Traffic != nil {
		trafficList := make([]TrafficWeight, len(source.Traffic))
		for trafficIndex, trafficItem := range source.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic TrafficWeight
			err := traffic.Initialize_From_TrafficWeight_STATUS(&trafficItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_TrafficWeight_STATUS() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		ingress.Traffic = trafficList
	} else {
		ingress.Traffic = nil
	}

	// Transport
	if source.Transport != nil {
		transport := genruntime.ToEnum(string(*source.Transport), ingress_Transport_Values)
		ingress.Transport = &transport
	} else {
		ingress.Transport = nil
	}

	// No error
	return nil
}

// Container App Ingress configuration.
type Ingress_STATUS struct {
	// AdditionalPortMappings: Settings to expose additional ports on container app
	AdditionalPortMappings []IngressPortMapping_STATUS `json:"additionalPortMappings,omitempty"`

	// AllowInsecure: Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically
	// redirected to HTTPS connections
	AllowInsecure *bool `json:"allowInsecure,omitempty"`

	// ClientCertificateMode: Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate
	// on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require
	// indicates server requires a client certificate.
	ClientCertificateMode *Ingress_ClientCertificateMode_STATUS `json:"clientCertificateMode,omitempty"`

	// CorsPolicy: CORS policy for container app
	CorsPolicy *CorsPolicy_STATUS `json:"corsPolicy,omitempty"`

	// CustomDomains: custom domain bindings for Container Apps' hostnames.
	CustomDomains []CustomDomain_STATUS `json:"customDomains,omitempty"`

	// ExposedPort: Exposed Port in containers for TCP traffic from ingress
	ExposedPort *int `json:"exposedPort,omitempty"`

	// External: Bool indicating if app exposes an external http endpoint
	External *bool `json:"external,omitempty"`

	// Fqdn: Hostname.
	Fqdn *string `json:"fqdn,omitempty"`

	// IpSecurityRestrictions: Rules to restrict incoming IP address.
	IpSecurityRestrictions []IpSecurityRestrictionRule_STATUS `json:"ipSecurityRestrictions,omitempty"`

	// StickySessions: Sticky Sessions for Single Revision Mode
	StickySessions *Ingress_StickySessions_STATUS `json:"stickySessions,omitempty"`

	// TargetPort: Target Port in containers for traffic from ingress
	TargetPort *int `json:"targetPort,omitempty"`

	// Traffic: Traffic weights for app's revisions
	Traffic []TrafficWeight_STATUS `json:"traffic,omitempty"`

	// Transport: Ingress transport protocol
	Transport *Ingress_Transport_STATUS `json:"transport,omitempty"`
}

var _ genruntime.FromARMConverter = &Ingress_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ingress *Ingress_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Ingress_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ingress *Ingress_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Ingress_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Ingress_STATUS, got %T", armInput)
	}

	// Set property "AdditionalPortMappings":
	for _, item := range typedInput.AdditionalPortMappings {
		var item1 IngressPortMapping_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ingress.AdditionalPortMappings = append(ingress.AdditionalPortMappings, item1)
	}

	// Set property "AllowInsecure":
	if typedInput.AllowInsecure != nil {
		allowInsecure := *typedInput.AllowInsecure
		ingress.AllowInsecure = &allowInsecure
	}

	// Set property "ClientCertificateMode":
	if typedInput.ClientCertificateMode != nil {
		var temp string
		temp = string(*typedInput.ClientCertificateMode)
		clientCertificateMode := Ingress_ClientCertificateMode_STATUS(temp)
		ingress.ClientCertificateMode = &clientCertificateMode
	}

	// Set property "CorsPolicy":
	if typedInput.CorsPolicy != nil {
		var corsPolicy1 CorsPolicy_STATUS
		err := corsPolicy1.PopulateFromARM(owner, *typedInput.CorsPolicy)
		if err != nil {
			return err
		}
		corsPolicy := corsPolicy1
		ingress.CorsPolicy = &corsPolicy
	}

	// Set property "CustomDomains":
	for _, item := range typedInput.CustomDomains {
		var item1 CustomDomain_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ingress.CustomDomains = append(ingress.CustomDomains, item1)
	}

	// Set property "ExposedPort":
	if typedInput.ExposedPort != nil {
		exposedPort := *typedInput.ExposedPort
		ingress.ExposedPort = &exposedPort
	}

	// Set property "External":
	if typedInput.External != nil {
		external := *typedInput.External
		ingress.External = &external
	}

	// Set property "Fqdn":
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		ingress.Fqdn = &fqdn
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range typedInput.IpSecurityRestrictions {
		var item1 IpSecurityRestrictionRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ingress.IpSecurityRestrictions = append(ingress.IpSecurityRestrictions, item1)
	}

	// Set property "StickySessions":
	if typedInput.StickySessions != nil {
		var stickySessions1 Ingress_StickySessions_STATUS
		err := stickySessions1.PopulateFromARM(owner, *typedInput.StickySessions)
		if err != nil {
			return err
		}
		stickySessions := stickySessions1
		ingress.StickySessions = &stickySessions
	}

	// Set property "TargetPort":
	if typedInput.TargetPort != nil {
		targetPort := *typedInput.TargetPort
		ingress.TargetPort = &targetPort
	}

	// Set property "Traffic":
	for _, item := range typedInput.Traffic {
		var item1 TrafficWeight_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ingress.Traffic = append(ingress.Traffic, item1)
	}

	// Set property "Transport":
	if typedInput.Transport != nil {
		var temp string
		temp = string(*typedInput.Transport)
		transport := Ingress_Transport_STATUS(temp)
		ingress.Transport = &transport
	}

	// No error
	return nil
}

// AssignProperties_From_Ingress_STATUS populates our Ingress_STATUS from the provided source Ingress_STATUS
func (ingress *Ingress_STATUS) AssignProperties_From_Ingress_STATUS(source *storage.Ingress_STATUS) error {

	// AdditionalPortMappings
	if source.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]IngressPortMapping_STATUS, len(source.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range source.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping IngressPortMapping_STATUS
			err := additionalPortMapping.AssignProperties_From_IngressPortMapping_STATUS(&additionalPortMappingItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IngressPortMapping_STATUS() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		ingress.AdditionalPortMappings = additionalPortMappingList
	} else {
		ingress.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if source.AllowInsecure != nil {
		allowInsecure := *source.AllowInsecure
		ingress.AllowInsecure = &allowInsecure
	} else {
		ingress.AllowInsecure = nil
	}

	// ClientCertificateMode
	if source.ClientCertificateMode != nil {
		clientCertificateMode := *source.ClientCertificateMode
		clientCertificateModeTemp := genruntime.ToEnum(clientCertificateMode, ingress_ClientCertificateMode_STATUS_Values)
		ingress.ClientCertificateMode = &clientCertificateModeTemp
	} else {
		ingress.ClientCertificateMode = nil
	}

	// CorsPolicy
	if source.CorsPolicy != nil {
		var corsPolicy CorsPolicy_STATUS
		err := corsPolicy.AssignProperties_From_CorsPolicy_STATUS(source.CorsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CorsPolicy_STATUS() to populate field CorsPolicy")
		}
		ingress.CorsPolicy = &corsPolicy
	} else {
		ingress.CorsPolicy = nil
	}

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]CustomDomain_STATUS, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain CustomDomain_STATUS
			err := customDomain.AssignProperties_From_CustomDomain_STATUS(&customDomainItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		ingress.CustomDomains = customDomainList
	} else {
		ingress.CustomDomains = nil
	}

	// ExposedPort
	ingress.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		ingress.External = &external
	} else {
		ingress.External = nil
	}

	// Fqdn
	ingress.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestrictionRule_STATUS, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestrictionRule_STATUS
			err := ipSecurityRestriction.AssignProperties_From_IpSecurityRestrictionRule_STATUS(&ipSecurityRestrictionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpSecurityRestrictionRule_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		ingress.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		ingress.IpSecurityRestrictions = nil
	}

	// StickySessions
	if source.StickySessions != nil {
		var stickySession Ingress_StickySessions_STATUS
		err := stickySession.AssignProperties_From_Ingress_StickySessions_STATUS(source.StickySessions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Ingress_StickySessions_STATUS() to populate field StickySessions")
		}
		ingress.StickySessions = &stickySession
	} else {
		ingress.StickySessions = nil
	}

	// TargetPort
	ingress.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// Traffic
	if source.Traffic != nil {
		trafficList := make([]TrafficWeight_STATUS, len(source.Traffic))
		for trafficIndex, trafficItem := range source.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic TrafficWeight_STATUS
			err := traffic.AssignProperties_From_TrafficWeight_STATUS(&trafficItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TrafficWeight_STATUS() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		ingress.Traffic = trafficList
	} else {
		ingress.Traffic = nil
	}

	// Transport
	if source.Transport != nil {
		transport := *source.Transport
		transportTemp := genruntime.ToEnum(transport, ingress_Transport_STATUS_Values)
		ingress.Transport = &transportTemp
	} else {
		ingress.Transport = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Ingress_STATUS populates the provided destination Ingress_STATUS from our Ingress_STATUS
func (ingress *Ingress_STATUS) AssignProperties_To_Ingress_STATUS(destination *storage.Ingress_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalPortMappings
	if ingress.AdditionalPortMappings != nil {
		additionalPortMappingList := make([]storage.IngressPortMapping_STATUS, len(ingress.AdditionalPortMappings))
		for additionalPortMappingIndex, additionalPortMappingItem := range ingress.AdditionalPortMappings {
			// Shadow the loop variable to avoid aliasing
			additionalPortMappingItem := additionalPortMappingItem
			var additionalPortMapping storage.IngressPortMapping_STATUS
			err := additionalPortMappingItem.AssignProperties_To_IngressPortMapping_STATUS(&additionalPortMapping)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IngressPortMapping_STATUS() to populate field AdditionalPortMappings")
			}
			additionalPortMappingList[additionalPortMappingIndex] = additionalPortMapping
		}
		destination.AdditionalPortMappings = additionalPortMappingList
	} else {
		destination.AdditionalPortMappings = nil
	}

	// AllowInsecure
	if ingress.AllowInsecure != nil {
		allowInsecure := *ingress.AllowInsecure
		destination.AllowInsecure = &allowInsecure
	} else {
		destination.AllowInsecure = nil
	}

	// ClientCertificateMode
	if ingress.ClientCertificateMode != nil {
		clientCertificateMode := string(*ingress.ClientCertificateMode)
		destination.ClientCertificateMode = &clientCertificateMode
	} else {
		destination.ClientCertificateMode = nil
	}

	// CorsPolicy
	if ingress.CorsPolicy != nil {
		var corsPolicy storage.CorsPolicy_STATUS
		err := ingress.CorsPolicy.AssignProperties_To_CorsPolicy_STATUS(&corsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CorsPolicy_STATUS() to populate field CorsPolicy")
		}
		destination.CorsPolicy = &corsPolicy
	} else {
		destination.CorsPolicy = nil
	}

	// CustomDomains
	if ingress.CustomDomains != nil {
		customDomainList := make([]storage.CustomDomain_STATUS, len(ingress.CustomDomains))
		for customDomainIndex, customDomainItem := range ingress.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain storage.CustomDomain_STATUS
			err := customDomainItem.AssignProperties_To_CustomDomain_STATUS(&customDomain)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// ExposedPort
	destination.ExposedPort = genruntime.ClonePointerToInt(ingress.ExposedPort)

	// External
	if ingress.External != nil {
		external := *ingress.External
		destination.External = &external
	} else {
		destination.External = nil
	}

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(ingress.Fqdn)

	// IpSecurityRestrictions
	if ingress.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]storage.IpSecurityRestrictionRule_STATUS, len(ingress.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range ingress.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction storage.IpSecurityRestrictionRule_STATUS
			err := ipSecurityRestrictionItem.AssignProperties_To_IpSecurityRestrictionRule_STATUS(&ipSecurityRestriction)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpSecurityRestrictionRule_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// StickySessions
	if ingress.StickySessions != nil {
		var stickySession storage.Ingress_StickySessions_STATUS
		err := ingress.StickySessions.AssignProperties_To_Ingress_StickySessions_STATUS(&stickySession)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Ingress_StickySessions_STATUS() to populate field StickySessions")
		}
		destination.StickySessions = &stickySession
	} else {
		destination.StickySessions = nil
	}

	// TargetPort
	destination.TargetPort = genruntime.ClonePointerToInt(ingress.TargetPort)

	// Traffic
	if ingress.Traffic != nil {
		trafficList := make([]storage.TrafficWeight_STATUS, len(ingress.Traffic))
		for trafficIndex, trafficItem := range ingress.Traffic {
			// Shadow the loop variable to avoid aliasing
			trafficItem := trafficItem
			var traffic storage.TrafficWeight_STATUS
			err := trafficItem.AssignProperties_To_TrafficWeight_STATUS(&traffic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TrafficWeight_STATUS() to populate field Traffic")
			}
			trafficList[trafficIndex] = traffic
		}
		destination.Traffic = trafficList
	} else {
		destination.Traffic = nil
	}

	// Transport
	if ingress.Transport != nil {
		transport := string(*ingress.Transport)
		destination.Transport = &transport
	} else {
		destination.Transport = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned,UserAssigned","UserAssigned"}
type ManagedServiceIdentityType string

const (
	ManagedServiceIdentityType_None                       = ManagedServiceIdentityType("None")
	ManagedServiceIdentityType_SystemAssigned             = ManagedServiceIdentityType("SystemAssigned")
	ManagedServiceIdentityType_SystemAssignedUserAssigned = ManagedServiceIdentityType("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_UserAssigned               = ManagedServiceIdentityType("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType
var managedServiceIdentityType_Values = map[string]ManagedServiceIdentityType{
	"none":                        ManagedServiceIdentityType_None,
	"systemassigned":              ManagedServiceIdentityType_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_UserAssigned,
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
type ManagedServiceIdentityType_STATUS string

const (
	ManagedServiceIdentityType_STATUS_None                       = ManagedServiceIdentityType_STATUS("None")
	ManagedServiceIdentityType_STATUS_SystemAssigned             = ManagedServiceIdentityType_STATUS("SystemAssigned")
	ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentityType_STATUS("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_STATUS_UserAssigned               = ManagedServiceIdentityType_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType_STATUS
var managedServiceIdentityType_STATUS_Values = map[string]ManagedServiceIdentityType_STATUS{
	"none":                        ManagedServiceIdentityType_STATUS_None,
	"systemassigned":              ManagedServiceIdentityType_STATUS_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_STATUS_UserAssigned,
}

// Container App Private Registry
type RegistryCredentials struct {
	// IdentityReference: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned
	// identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
	IdentityReference *genruntime.ResourceReference `armReference:"Identity" json:"identityReference,omitempty"`

	// PasswordSecretRef: The name of the Secret that contains the registry login password
	PasswordSecretRef *string `json:"passwordSecretRef,omitempty"`

	// Server: Container Registry Server
	Server *string `json:"server,omitempty"`

	// Username: Container Registry Username
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &RegistryCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *RegistryCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.RegistryCredentials{}

	// Set property "Identity":
	if credentials.IdentityReference != nil {
		identityReferenceARMID, err := resolved.ResolvedReferences.Lookup(*credentials.IdentityReference)
		if err != nil {
			return nil, err
		}
		identityReference := identityReferenceARMID
		result.Identity = &identityReference
	}

	// Set property "PasswordSecretRef":
	if credentials.PasswordSecretRef != nil {
		passwordSecretRef := *credentials.PasswordSecretRef
		result.PasswordSecretRef = &passwordSecretRef
	}

	// Set property "Server":
	if credentials.Server != nil {
		server := *credentials.Server
		result.Server = &server
	}

	// Set property "Username":
	if credentials.Username != nil {
		username := *credentials.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *RegistryCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *RegistryCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryCredentials, got %T", armInput)
	}

	// no assignment for property "IdentityReference"

	// Set property "PasswordSecretRef":
	if typedInput.PasswordSecretRef != nil {
		passwordSecretRef := *typedInput.PasswordSecretRef
		credentials.PasswordSecretRef = &passwordSecretRef
	}

	// Set property "Server":
	if typedInput.Server != nil {
		server := *typedInput.Server
		credentials.Server = &server
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryCredentials populates our RegistryCredentials from the provided source RegistryCredentials
func (credentials *RegistryCredentials) AssignProperties_From_RegistryCredentials(source *storage.RegistryCredentials) error {

	// IdentityReference
	if source.IdentityReference != nil {
		identityReference := source.IdentityReference.Copy()
		credentials.IdentityReference = &identityReference
	} else {
		credentials.IdentityReference = nil
	}

	// PasswordSecretRef
	credentials.PasswordSecretRef = genruntime.ClonePointerToString(source.PasswordSecretRef)

	// Server
	credentials.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_RegistryCredentials populates the provided destination RegistryCredentials from our RegistryCredentials
func (credentials *RegistryCredentials) AssignProperties_To_RegistryCredentials(destination *storage.RegistryCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityReference
	if credentials.IdentityReference != nil {
		identityReference := credentials.IdentityReference.Copy()
		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// PasswordSecretRef
	destination.PasswordSecretRef = genruntime.ClonePointerToString(credentials.PasswordSecretRef)

	// Server
	destination.Server = genruntime.ClonePointerToString(credentials.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RegistryCredentials_STATUS populates our RegistryCredentials from the provided source RegistryCredentials_STATUS
func (credentials *RegistryCredentials) Initialize_From_RegistryCredentials_STATUS(source *RegistryCredentials_STATUS) error {

	// PasswordSecretRef
	credentials.PasswordSecretRef = genruntime.ClonePointerToString(source.PasswordSecretRef)

	// Server
	credentials.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// Container App Private Registry
type RegistryCredentials_STATUS struct {
	// Identity: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the
	// full user-assigned identity Resource ID. For system-assigned identities, use 'system'
	Identity *string `json:"identity,omitempty"`

	// PasswordSecretRef: The name of the Secret that contains the registry login password
	PasswordSecretRef *string `json:"passwordSecretRef,omitempty"`

	// Server: Container Registry Server
	Server *string `json:"server,omitempty"`

	// Username: Container Registry Username
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &RegistryCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *RegistryCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RegistryCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *RegistryCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RegistryCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RegistryCredentials_STATUS, got %T", armInput)
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		identity := *typedInput.Identity
		credentials.Identity = &identity
	}

	// Set property "PasswordSecretRef":
	if typedInput.PasswordSecretRef != nil {
		passwordSecretRef := *typedInput.PasswordSecretRef
		credentials.PasswordSecretRef = &passwordSecretRef
	}

	// Set property "Server":
	if typedInput.Server != nil {
		server := *typedInput.Server
		credentials.Server = &server
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_RegistryCredentials_STATUS populates our RegistryCredentials_STATUS from the provided source RegistryCredentials_STATUS
func (credentials *RegistryCredentials_STATUS) AssignProperties_From_RegistryCredentials_STATUS(source *storage.RegistryCredentials_STATUS) error {

	// Identity
	credentials.Identity = genruntime.ClonePointerToString(source.Identity)

	// PasswordSecretRef
	credentials.PasswordSecretRef = genruntime.ClonePointerToString(source.PasswordSecretRef)

	// Server
	credentials.Server = genruntime.ClonePointerToString(source.Server)

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_RegistryCredentials_STATUS populates the provided destination RegistryCredentials_STATUS from our RegistryCredentials_STATUS
func (credentials *RegistryCredentials_STATUS) AssignProperties_To_RegistryCredentials_STATUS(destination *storage.RegistryCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	destination.Identity = genruntime.ClonePointerToString(credentials.Identity)

	// PasswordSecretRef
	destination.PasswordSecretRef = genruntime.ClonePointerToString(credentials.PasswordSecretRef)

	// Server
	destination.Server = genruntime.ClonePointerToString(credentials.Server)

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App scaling configurations.
type Scale struct {
	// MaxReplicas: Optional. Maximum number of container replicas. Defaults to 10 if not set.
	MaxReplicas *int `json:"maxReplicas,omitempty"`

	// MinReplicas: Optional. Minimum number of container replicas.
	MinReplicas *int `json:"minReplicas,omitempty"`

	// Rules: Scaling rules.
	Rules []ScaleRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &Scale{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scale *Scale) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scale == nil {
		return nil, nil
	}
	result := &arm.Scale{}

	// Set property "MaxReplicas":
	if scale.MaxReplicas != nil {
		maxReplicas := *scale.MaxReplicas
		result.MaxReplicas = &maxReplicas
	}

	// Set property "MinReplicas":
	if scale.MinReplicas != nil {
		minReplicas := *scale.MinReplicas
		result.MinReplicas = &minReplicas
	}

	// Set property "Rules":
	for _, item := range scale.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.ScaleRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scale *Scale) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Scale{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scale *Scale) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Scale)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Scale, got %T", armInput)
	}

	// Set property "MaxReplicas":
	if typedInput.MaxReplicas != nil {
		maxReplicas := *typedInput.MaxReplicas
		scale.MaxReplicas = &maxReplicas
	}

	// Set property "MinReplicas":
	if typedInput.MinReplicas != nil {
		minReplicas := *typedInput.MinReplicas
		scale.MinReplicas = &minReplicas
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ScaleRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		scale.Rules = append(scale.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Scale populates our Scale from the provided source Scale
func (scale *Scale) AssignProperties_From_Scale(source *storage.Scale) error {

	// MaxReplicas
	scale.MaxReplicas = genruntime.ClonePointerToInt(source.MaxReplicas)

	// MinReplicas
	scale.MinReplicas = genruntime.ClonePointerToInt(source.MinReplicas)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ScaleRule
			err := rule.AssignProperties_From_ScaleRule(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Scale populates the provided destination Scale from our Scale
func (scale *Scale) AssignProperties_To_Scale(destination *storage.Scale) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxReplicas
	destination.MaxReplicas = genruntime.ClonePointerToInt(scale.MaxReplicas)

	// MinReplicas
	destination.MinReplicas = genruntime.ClonePointerToInt(scale.MinReplicas)

	// Rules
	if scale.Rules != nil {
		ruleList := make([]storage.ScaleRule, len(scale.Rules))
		for ruleIndex, ruleItem := range scale.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ScaleRule
			err := ruleItem.AssignProperties_To_ScaleRule(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Scale_STATUS populates our Scale from the provided source Scale_STATUS
func (scale *Scale) Initialize_From_Scale_STATUS(source *Scale_STATUS) error {

	// MaxReplicas
	scale.MaxReplicas = genruntime.ClonePointerToInt(source.MaxReplicas)

	// MinReplicas
	scale.MinReplicas = genruntime.ClonePointerToInt(source.MinReplicas)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ScaleRule
			err := rule.Initialize_From_ScaleRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// No error
	return nil
}

// Container App scaling configurations.
type Scale_STATUS struct {
	// MaxReplicas: Optional. Maximum number of container replicas. Defaults to 10 if not set.
	MaxReplicas *int `json:"maxReplicas,omitempty"`

	// MinReplicas: Optional. Minimum number of container replicas.
	MinReplicas *int `json:"minReplicas,omitempty"`

	// Rules: Scaling rules.
	Rules []ScaleRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &Scale_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scale *Scale_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Scale_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scale *Scale_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Scale_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Scale_STATUS, got %T", armInput)
	}

	// Set property "MaxReplicas":
	if typedInput.MaxReplicas != nil {
		maxReplicas := *typedInput.MaxReplicas
		scale.MaxReplicas = &maxReplicas
	}

	// Set property "MinReplicas":
	if typedInput.MinReplicas != nil {
		minReplicas := *typedInput.MinReplicas
		scale.MinReplicas = &minReplicas
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ScaleRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		scale.Rules = append(scale.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Scale_STATUS populates our Scale_STATUS from the provided source Scale_STATUS
func (scale *Scale_STATUS) AssignProperties_From_Scale_STATUS(source *storage.Scale_STATUS) error {

	// MaxReplicas
	scale.MaxReplicas = genruntime.ClonePointerToInt(source.MaxReplicas)

	// MinReplicas
	scale.MinReplicas = genruntime.ClonePointerToInt(source.MinReplicas)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ScaleRule_STATUS
			err := rule.AssignProperties_From_ScaleRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Scale_STATUS populates the provided destination Scale_STATUS from our Scale_STATUS
func (scale *Scale_STATUS) AssignProperties_To_Scale_STATUS(destination *storage.Scale_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxReplicas
	destination.MaxReplicas = genruntime.ClonePointerToInt(scale.MaxReplicas)

	// MinReplicas
	destination.MinReplicas = genruntime.ClonePointerToInt(scale.MinReplicas)

	// Rules
	if scale.Rules != nil {
		ruleList := make([]storage.ScaleRule_STATUS, len(scale.Rules))
		for ruleIndex, ruleItem := range scale.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ScaleRule_STATUS
			err := ruleItem.AssignProperties_To_ScaleRule_STATUS(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Secret definition.
type Secret struct {
	// IdentityReference: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a
	// system-assigned identity.
	IdentityReference *genruntime.ResourceReference `armReference:"Identity" json:"identityReference,omitempty"`

	// KeyVaultUrl: Azure Key Vault URL pointing to the secret referenced by the container app.
	KeyVaultUrl *string `json:"keyVaultUrl,omitempty"`

	// Name: Secret Name.
	Name *string `json:"name,omitempty"`

	// Value: Secret Value.
	Value *genruntime.SecretReference `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &Secret{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (secret *Secret) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if secret == nil {
		return nil, nil
	}
	result := &arm.Secret{}

	// Set property "Identity":
	if secret.IdentityReference != nil {
		identityReferenceARMID, err := resolved.ResolvedReferences.Lookup(*secret.IdentityReference)
		if err != nil {
			return nil, err
		}
		identityReference := identityReferenceARMID
		result.Identity = &identityReference
	}

	// Set property "KeyVaultUrl":
	if secret.KeyVaultUrl != nil {
		keyVaultUrl := *secret.KeyVaultUrl
		result.KeyVaultUrl = &keyVaultUrl
	}

	// Set property "Name":
	if secret.Name != nil {
		name := *secret.Name
		result.Name = &name
	}

	// Set property "Value":
	if secret.Value != nil {
		valueSecret, err := resolved.ResolvedSecrets.Lookup(*secret.Value)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property Value")
		}
		value := valueSecret
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (secret *Secret) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Secret{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (secret *Secret) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Secret)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Secret, got %T", armInput)
	}

	// no assignment for property "IdentityReference"

	// Set property "KeyVaultUrl":
	if typedInput.KeyVaultUrl != nil {
		keyVaultUrl := *typedInput.KeyVaultUrl
		secret.KeyVaultUrl = &keyVaultUrl
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		secret.Name = &name
	}

	// no assignment for property "Value"

	// No error
	return nil
}

// AssignProperties_From_Secret populates our Secret from the provided source Secret
func (secret *Secret) AssignProperties_From_Secret(source *storage.Secret) error {

	// IdentityReference
	if source.IdentityReference != nil {
		identityReference := source.IdentityReference.Copy()
		secret.IdentityReference = &identityReference
	} else {
		secret.IdentityReference = nil
	}

	// KeyVaultUrl
	secret.KeyVaultUrl = genruntime.ClonePointerToString(source.KeyVaultUrl)

	// Name
	secret.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	if source.Value != nil {
		value := source.Value.Copy()
		secret.Value = &value
	} else {
		secret.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Secret populates the provided destination Secret from our Secret
func (secret *Secret) AssignProperties_To_Secret(destination *storage.Secret) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityReference
	if secret.IdentityReference != nil {
		identityReference := secret.IdentityReference.Copy()
		destination.IdentityReference = &identityReference
	} else {
		destination.IdentityReference = nil
	}

	// KeyVaultUrl
	destination.KeyVaultUrl = genruntime.ClonePointerToString(secret.KeyVaultUrl)

	// Name
	destination.Name = genruntime.ClonePointerToString(secret.Name)

	// Value
	if secret.Value != nil {
		value := secret.Value.Copy()
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Secret_STATUS populates our Secret from the provided source Secret_STATUS
func (secret *Secret) Initialize_From_Secret_STATUS(source *Secret_STATUS) error {

	// KeyVaultUrl
	secret.KeyVaultUrl = genruntime.ClonePointerToString(source.KeyVaultUrl)

	// Name
	secret.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// Secret definition.
type Secret_STATUS struct {
	// Identity: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned
	// identity.
	Identity *string `json:"identity,omitempty"`

	// KeyVaultUrl: Azure Key Vault URL pointing to the secret referenced by the container app.
	KeyVaultUrl *string `json:"keyVaultUrl,omitempty"`

	// Name: Secret Name.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &Secret_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (secret *Secret_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Secret_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (secret *Secret_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Secret_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Secret_STATUS, got %T", armInput)
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		identity := *typedInput.Identity
		secret.Identity = &identity
	}

	// Set property "KeyVaultUrl":
	if typedInput.KeyVaultUrl != nil {
		keyVaultUrl := *typedInput.KeyVaultUrl
		secret.KeyVaultUrl = &keyVaultUrl
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		secret.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Secret_STATUS populates our Secret_STATUS from the provided source Secret_STATUS
func (secret *Secret_STATUS) AssignProperties_From_Secret_STATUS(source *storage.Secret_STATUS) error {

	// Identity
	secret.Identity = genruntime.ClonePointerToString(source.Identity)

	// KeyVaultUrl
	secret.KeyVaultUrl = genruntime.ClonePointerToString(source.KeyVaultUrl)

	// Name
	secret.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_Secret_STATUS populates the provided destination Secret_STATUS from our Secret_STATUS
func (secret *Secret_STATUS) AssignProperties_To_Secret_STATUS(destination *storage.Secret_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	destination.Identity = genruntime.ClonePointerToString(secret.Identity)

	// KeyVaultUrl
	destination.KeyVaultUrl = genruntime.ClonePointerToString(secret.KeyVaultUrl)

	// Name
	destination.Name = genruntime.ClonePointerToString(secret.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App to be a dev service
type Service struct {
	// +kubebuilder:validation:Required
	// Type: Dev ContainerApp service type
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Service{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (service *Service) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if service == nil {
		return nil, nil
	}
	result := &arm.Service{}

	// Set property "Type":
	if service.Type != nil {
		typeVar := *service.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *Service) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Service{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *Service) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Service)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Service, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		service.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Service populates our Service from the provided source Service
func (service *Service) AssignProperties_From_Service(source *storage.Service) error {

	// Type
	service.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Service populates the provided destination Service from our Service
func (service *Service) AssignProperties_To_Service(destination *storage.Service) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	destination.Type = genruntime.ClonePointerToString(service.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Service_STATUS populates our Service from the provided source Service_STATUS
func (service *Service) Initialize_From_Service_STATUS(source *Service_STATUS) error {

	// Type
	service.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// Container App to be a dev service
type Service_STATUS struct {
	// Type: Dev ContainerApp service type
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Service_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *Service_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Service_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *Service_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Service_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Service_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		service.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Service_STATUS populates our Service_STATUS from the provided source Service_STATUS
func (service *Service_STATUS) AssignProperties_From_Service_STATUS(source *storage.Service_STATUS) error {

	// Type
	service.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Service_STATUS populates the provided destination Service_STATUS from our Service_STATUS
func (service *Service_STATUS) AssignProperties_To_Service_STATUS(destination *storage.Service_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	destination.Type = genruntime.ClonePointerToString(service.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration to bind a ContainerApp to a dev ContainerApp Service
type ServiceBind struct {
	// Name: Name of the service bind
	Name *string `json:"name,omitempty"`

	// ServiceReference: Resource id of the target service
	ServiceReference *genruntime.ResourceReference `armReference:"ServiceId" json:"serviceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ServiceBind{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (bind *ServiceBind) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if bind == nil {
		return nil, nil
	}
	result := &arm.ServiceBind{}

	// Set property "Name":
	if bind.Name != nil {
		name := *bind.Name
		result.Name = &name
	}

	// Set property "ServiceId":
	if bind.ServiceReference != nil {
		serviceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*bind.ServiceReference)
		if err != nil {
			return nil, err
		}
		serviceReference := serviceReferenceARMID
		result.ServiceId = &serviceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (bind *ServiceBind) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceBind{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (bind *ServiceBind) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceBind)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceBind, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		bind.Name = &name
	}

	// no assignment for property "ServiceReference"

	// No error
	return nil
}

// AssignProperties_From_ServiceBind populates our ServiceBind from the provided source ServiceBind
func (bind *ServiceBind) AssignProperties_From_ServiceBind(source *storage.ServiceBind) error {

	// Name
	bind.Name = genruntime.ClonePointerToString(source.Name)

	// ServiceReference
	if source.ServiceReference != nil {
		serviceReference := source.ServiceReference.Copy()
		bind.ServiceReference = &serviceReference
	} else {
		bind.ServiceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceBind populates the provided destination ServiceBind from our ServiceBind
func (bind *ServiceBind) AssignProperties_To_ServiceBind(destination *storage.ServiceBind) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(bind.Name)

	// ServiceReference
	if bind.ServiceReference != nil {
		serviceReference := bind.ServiceReference.Copy()
		destination.ServiceReference = &serviceReference
	} else {
		destination.ServiceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServiceBind_STATUS populates our ServiceBind from the provided source ServiceBind_STATUS
func (bind *ServiceBind) Initialize_From_ServiceBind_STATUS(source *ServiceBind_STATUS) error {

	// Name
	bind.Name = genruntime.ClonePointerToString(source.Name)

	// ServiceReference
	if source.ServiceId != nil {
		serviceReference := genruntime.CreateResourceReferenceFromARMID(*source.ServiceId)
		bind.ServiceReference = &serviceReference
	} else {
		bind.ServiceReference = nil
	}

	// No error
	return nil
}

// Configuration to bind a ContainerApp to a dev ContainerApp Service
type ServiceBind_STATUS struct {
	// Name: Name of the service bind
	Name *string `json:"name,omitempty"`

	// ServiceId: Resource id of the target service
	ServiceId *string `json:"serviceId,omitempty"`
}

var _ genruntime.FromARMConverter = &ServiceBind_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (bind *ServiceBind_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceBind_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (bind *ServiceBind_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceBind_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceBind_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		bind.Name = &name
	}

	// Set property "ServiceId":
	if typedInput.ServiceId != nil {
		serviceId := *typedInput.ServiceId
		bind.ServiceId = &serviceId
	}

	// No error
	return nil
}

// AssignProperties_From_ServiceBind_STATUS populates our ServiceBind_STATUS from the provided source ServiceBind_STATUS
func (bind *ServiceBind_STATUS) AssignProperties_From_ServiceBind_STATUS(source *storage.ServiceBind_STATUS) error {

	// Name
	bind.Name = genruntime.ClonePointerToString(source.Name)

	// ServiceId
	bind.ServiceId = genruntime.ClonePointerToString(source.ServiceId)

	// No error
	return nil
}

// AssignProperties_To_ServiceBind_STATUS populates the provided destination ServiceBind_STATUS from our ServiceBind_STATUS
func (bind *ServiceBind_STATUS) AssignProperties_To_ServiceBind_STATUS(destination *storage.ServiceBind_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(bind.Name)

	// ServiceId
	destination.ServiceId = genruntime.ClonePointerToString(bind.ServiceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// User assigned identity properties
type UserAssignedIdentity_STATUS struct {
	// ClientId: The client ID of the assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal ID of the assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Volume definitions for the Container App.
type Volume struct {
	// MountOptions: Mount options used while mounting the AzureFile. Must be a comma-separated string.
	MountOptions *string `json:"mountOptions,omitempty"`

	// Name: Volume name.
	Name *string `json:"name,omitempty"`

	// Secrets: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to
	// volume.
	Secrets []SecretVolumeItem `json:"secrets,omitempty"`

	// StorageName: Name of storage resource. No need to provide for EmptyDir and Secret.
	StorageName *string `json:"storageName,omitempty"`

	// StorageType: Storage type for the volume. If not provided, use EmptyDir.
	StorageType *Volume_StorageType `json:"storageType,omitempty"`
}

var _ genruntime.ARMTransformer = &Volume{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (volume *Volume) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if volume == nil {
		return nil, nil
	}
	result := &arm.Volume{}

	// Set property "MountOptions":
	if volume.MountOptions != nil {
		mountOptions := *volume.MountOptions
		result.MountOptions = &mountOptions
	}

	// Set property "Name":
	if volume.Name != nil {
		name := *volume.Name
		result.Name = &name
	}

	// Set property "Secrets":
	for _, item := range volume.Secrets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, *item_ARM.(*arm.SecretVolumeItem))
	}

	// Set property "StorageName":
	if volume.StorageName != nil {
		storageName := *volume.StorageName
		result.StorageName = &storageName
	}

	// Set property "StorageType":
	if volume.StorageType != nil {
		var temp string
		temp = string(*volume.StorageType)
		storageType := arm.Volume_StorageType(temp)
		result.StorageType = &storageType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *Volume) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Volume{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *Volume) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Volume)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Volume, got %T", armInput)
	}

	// Set property "MountOptions":
	if typedInput.MountOptions != nil {
		mountOptions := *typedInput.MountOptions
		volume.MountOptions = &mountOptions
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		volume.Name = &name
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 SecretVolumeItem
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		volume.Secrets = append(volume.Secrets, item1)
	}

	// Set property "StorageName":
	if typedInput.StorageName != nil {
		storageName := *typedInput.StorageName
		volume.StorageName = &storageName
	}

	// Set property "StorageType":
	if typedInput.StorageType != nil {
		var temp string
		temp = string(*typedInput.StorageType)
		storageType := Volume_StorageType(temp)
		volume.StorageType = &storageType
	}

	// No error
	return nil
}

// AssignProperties_From_Volume populates our Volume from the provided source Volume
func (volume *Volume) AssignProperties_From_Volume(source *storage.Volume) error {

	// MountOptions
	volume.MountOptions = genruntime.ClonePointerToString(source.MountOptions)

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secrets
	if source.Secrets != nil {
		secretList := make([]SecretVolumeItem, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret SecretVolumeItem
			err := secret.AssignProperties_From_SecretVolumeItem(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SecretVolumeItem() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		volume.Secrets = secretList
	} else {
		volume.Secrets = nil
	}

	// StorageName
	volume.StorageName = genruntime.ClonePointerToString(source.StorageName)

	// StorageType
	if source.StorageType != nil {
		storageType := *source.StorageType
		storageTypeTemp := genruntime.ToEnum(storageType, volume_StorageType_Values)
		volume.StorageType = &storageTypeTemp
	} else {
		volume.StorageType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Volume populates the provided destination Volume from our Volume
func (volume *Volume) AssignProperties_To_Volume(destination *storage.Volume) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountOptions
	destination.MountOptions = genruntime.ClonePointerToString(volume.MountOptions)

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secrets
	if volume.Secrets != nil {
		secretList := make([]storage.SecretVolumeItem, len(volume.Secrets))
		for secretIndex, secretItem := range volume.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.SecretVolumeItem
			err := secretItem.AssignProperties_To_SecretVolumeItem(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SecretVolumeItem() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// StorageName
	destination.StorageName = genruntime.ClonePointerToString(volume.StorageName)

	// StorageType
	if volume.StorageType != nil {
		storageType := string(*volume.StorageType)
		destination.StorageType = &storageType
	} else {
		destination.StorageType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Volume_STATUS populates our Volume from the provided source Volume_STATUS
func (volume *Volume) Initialize_From_Volume_STATUS(source *Volume_STATUS) error {

	// MountOptions
	volume.MountOptions = genruntime.ClonePointerToString(source.MountOptions)

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secrets
	if source.Secrets != nil {
		secretList := make([]SecretVolumeItem, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret SecretVolumeItem
			err := secret.Initialize_From_SecretVolumeItem_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_SecretVolumeItem_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		volume.Secrets = secretList
	} else {
		volume.Secrets = nil
	}

	// StorageName
	volume.StorageName = genruntime.ClonePointerToString(source.StorageName)

	// StorageType
	if source.StorageType != nil {
		storageType := genruntime.ToEnum(string(*source.StorageType), volume_StorageType_Values)
		volume.StorageType = &storageType
	} else {
		volume.StorageType = nil
	}

	// No error
	return nil
}

// Volume definitions for the Container App.
type Volume_STATUS struct {
	// MountOptions: Mount options used while mounting the AzureFile. Must be a comma-separated string.
	MountOptions *string `json:"mountOptions,omitempty"`

	// Name: Volume name.
	Name *string `json:"name,omitempty"`

	// Secrets: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to
	// volume.
	Secrets []SecretVolumeItem_STATUS `json:"secrets,omitempty"`

	// StorageName: Name of storage resource. No need to provide for EmptyDir and Secret.
	StorageName *string `json:"storageName,omitempty"`

	// StorageType: Storage type for the volume. If not provided, use EmptyDir.
	StorageType *Volume_StorageType_STATUS `json:"storageType,omitempty"`
}

var _ genruntime.FromARMConverter = &Volume_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (volume *Volume_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Volume_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (volume *Volume_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Volume_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Volume_STATUS, got %T", armInput)
	}

	// Set property "MountOptions":
	if typedInput.MountOptions != nil {
		mountOptions := *typedInput.MountOptions
		volume.MountOptions = &mountOptions
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		volume.Name = &name
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 SecretVolumeItem_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		volume.Secrets = append(volume.Secrets, item1)
	}

	// Set property "StorageName":
	if typedInput.StorageName != nil {
		storageName := *typedInput.StorageName
		volume.StorageName = &storageName
	}

	// Set property "StorageType":
	if typedInput.StorageType != nil {
		var temp string
		temp = string(*typedInput.StorageType)
		storageType := Volume_StorageType_STATUS(temp)
		volume.StorageType = &storageType
	}

	// No error
	return nil
}

// AssignProperties_From_Volume_STATUS populates our Volume_STATUS from the provided source Volume_STATUS
func (volume *Volume_STATUS) AssignProperties_From_Volume_STATUS(source *storage.Volume_STATUS) error {

	// MountOptions
	volume.MountOptions = genruntime.ClonePointerToString(source.MountOptions)

	// Name
	volume.Name = genruntime.ClonePointerToString(source.Name)

	// Secrets
	if source.Secrets != nil {
		secretList := make([]SecretVolumeItem_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret SecretVolumeItem_STATUS
			err := secret.AssignProperties_From_SecretVolumeItem_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SecretVolumeItem_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		volume.Secrets = secretList
	} else {
		volume.Secrets = nil
	}

	// StorageName
	volume.StorageName = genruntime.ClonePointerToString(source.StorageName)

	// StorageType
	if source.StorageType != nil {
		storageType := *source.StorageType
		storageTypeTemp := genruntime.ToEnum(storageType, volume_StorageType_STATUS_Values)
		volume.StorageType = &storageTypeTemp
	} else {
		volume.StorageType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Volume_STATUS populates the provided destination Volume_STATUS from our Volume_STATUS
func (volume *Volume_STATUS) AssignProperties_To_Volume_STATUS(destination *storage.Volume_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountOptions
	destination.MountOptions = genruntime.ClonePointerToString(volume.MountOptions)

	// Name
	destination.Name = genruntime.ClonePointerToString(volume.Name)

	// Secrets
	if volume.Secrets != nil {
		secretList := make([]storage.SecretVolumeItem_STATUS, len(volume.Secrets))
		for secretIndex, secretItem := range volume.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.SecretVolumeItem_STATUS
			err := secretItem.AssignProperties_To_SecretVolumeItem_STATUS(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SecretVolumeItem_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// StorageName
	destination.StorageName = genruntime.ClonePointerToString(volume.StorageName)

	// StorageType
	if volume.StorageType != nil {
		storageType := string(*volume.StorageType)
		destination.StorageType = &storageType
	} else {
		destination.StorageType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive
// traffic.
type ContainerAppProbe struct {
	// FailureThreshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to
	// 3. Minimum value is 1. Maximum value is 10.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: HTTPGet specifies the http request to perform.
	HttpGet *ContainerAppProbe_HttpGet `json:"httpGet,omitempty"`

	// InitialDelaySeconds: Number of seconds after the container has started before liveness probes are initiated. Minimum
	// value is 1. Maximum value is 60.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is
	// 240.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults
	// to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TcpSocket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
	TcpSocket *ContainerAppProbe_TcpSocket `json:"tcpSocket,omitempty"`

	// TerminationGracePeriodSeconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
	// The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the
	// time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for
	// your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value
	// overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop
	// immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling
	// ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
	TerminationGracePeriodSeconds *int `json:"terminationGracePeriodSeconds,omitempty"`

	// TimeoutSeconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum
	// value is 240.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`

	// Type: The type of probe.
	Type *ContainerAppProbe_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerAppProbe{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (probe *ContainerAppProbe) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if probe == nil {
		return nil, nil
	}
	result := &arm.ContainerAppProbe{}

	// Set property "FailureThreshold":
	if probe.FailureThreshold != nil {
		failureThreshold := *probe.FailureThreshold
		result.FailureThreshold = &failureThreshold
	}

	// Set property "HttpGet":
	if probe.HttpGet != nil {
		httpGet_ARM, err := (*probe.HttpGet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpGet := *httpGet_ARM.(*arm.ContainerAppProbe_HttpGet)
		result.HttpGet = &httpGet
	}

	// Set property "InitialDelaySeconds":
	if probe.InitialDelaySeconds != nil {
		initialDelaySeconds := *probe.InitialDelaySeconds
		result.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property "PeriodSeconds":
	if probe.PeriodSeconds != nil {
		periodSeconds := *probe.PeriodSeconds
		result.PeriodSeconds = &periodSeconds
	}

	// Set property "SuccessThreshold":
	if probe.SuccessThreshold != nil {
		successThreshold := *probe.SuccessThreshold
		result.SuccessThreshold = &successThreshold
	}

	// Set property "TcpSocket":
	if probe.TcpSocket != nil {
		tcpSocket_ARM, err := (*probe.TcpSocket).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tcpSocket := *tcpSocket_ARM.(*arm.ContainerAppProbe_TcpSocket)
		result.TcpSocket = &tcpSocket
	}

	// Set property "TerminationGracePeriodSeconds":
	if probe.TerminationGracePeriodSeconds != nil {
		terminationGracePeriodSeconds := *probe.TerminationGracePeriodSeconds
		result.TerminationGracePeriodSeconds = &terminationGracePeriodSeconds
	}

	// Set property "TimeoutSeconds":
	if probe.TimeoutSeconds != nil {
		timeoutSeconds := *probe.TimeoutSeconds
		result.TimeoutSeconds = &timeoutSeconds
	}

	// Set property "Type":
	if probe.Type != nil {
		var temp string
		temp = string(*probe.Type)
		typeVar := arm.ContainerAppProbe_Type(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ContainerAppProbe) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerAppProbe{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ContainerAppProbe) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerAppProbe)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerAppProbe, got %T", armInput)
	}

	// Set property "FailureThreshold":
	if typedInput.FailureThreshold != nil {
		failureThreshold := *typedInput.FailureThreshold
		probe.FailureThreshold = &failureThreshold
	}

	// Set property "HttpGet":
	if typedInput.HttpGet != nil {
		var httpGet1 ContainerAppProbe_HttpGet
		err := httpGet1.PopulateFromARM(owner, *typedInput.HttpGet)
		if err != nil {
			return err
		}
		httpGet := httpGet1
		probe.HttpGet = &httpGet
	}

	// Set property "InitialDelaySeconds":
	if typedInput.InitialDelaySeconds != nil {
		initialDelaySeconds := *typedInput.InitialDelaySeconds
		probe.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property "PeriodSeconds":
	if typedInput.PeriodSeconds != nil {
		periodSeconds := *typedInput.PeriodSeconds
		probe.PeriodSeconds = &periodSeconds
	}

	// Set property "SuccessThreshold":
	if typedInput.SuccessThreshold != nil {
		successThreshold := *typedInput.SuccessThreshold
		probe.SuccessThreshold = &successThreshold
	}

	// Set property "TcpSocket":
	if typedInput.TcpSocket != nil {
		var tcpSocket1 ContainerAppProbe_TcpSocket
		err := tcpSocket1.PopulateFromARM(owner, *typedInput.TcpSocket)
		if err != nil {
			return err
		}
		tcpSocket := tcpSocket1
		probe.TcpSocket = &tcpSocket
	}

	// Set property "TerminationGracePeriodSeconds":
	if typedInput.TerminationGracePeriodSeconds != nil {
		terminationGracePeriodSeconds := *typedInput.TerminationGracePeriodSeconds
		probe.TerminationGracePeriodSeconds = &terminationGracePeriodSeconds
	}

	// Set property "TimeoutSeconds":
	if typedInput.TimeoutSeconds != nil {
		timeoutSeconds := *typedInput.TimeoutSeconds
		probe.TimeoutSeconds = &timeoutSeconds
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ContainerAppProbe_Type(temp)
		probe.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerAppProbe populates our ContainerAppProbe from the provided source ContainerAppProbe
func (probe *ContainerAppProbe) AssignProperties_From_ContainerAppProbe(source *storage.ContainerAppProbe) error {

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerAppProbe_HttpGet
		err := httpGet.AssignProperties_From_ContainerAppProbe_HttpGet(source.HttpGet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_HttpGet() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TcpSocket
	if source.TcpSocket != nil {
		var tcpSocket ContainerAppProbe_TcpSocket
		err := tcpSocket.AssignProperties_From_ContainerAppProbe_TcpSocket(source.TcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_TcpSocket() to populate field TcpSocket")
		}
		probe.TcpSocket = &tcpSocket
	} else {
		probe.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	probe.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, containerAppProbe_Type_Values)
		probe.Type = &typeTemp
	} else {
		probe.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe populates the provided destination ContainerAppProbe from our ContainerAppProbe
func (probe *ContainerAppProbe) AssignProperties_To_ContainerAppProbe(destination *storage.ContainerAppProbe) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet storage.ContainerAppProbe_HttpGet
		err := probe.HttpGet.AssignProperties_To_ContainerAppProbe_HttpGet(&httpGet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_HttpGet() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TcpSocket
	if probe.TcpSocket != nil {
		var tcpSocket storage.ContainerAppProbe_TcpSocket
		err := probe.TcpSocket.AssignProperties_To_ContainerAppProbe_TcpSocket(&tcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_TcpSocket() to populate field TcpSocket")
		}
		destination.TcpSocket = &tcpSocket
	} else {
		destination.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	destination.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(probe.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Type
	if probe.Type != nil {
		typeVar := string(*probe.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerAppProbe_STATUS populates our ContainerAppProbe from the provided source ContainerAppProbe_STATUS
func (probe *ContainerAppProbe) Initialize_From_ContainerAppProbe_STATUS(source *ContainerAppProbe_STATUS) error {

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerAppProbe_HttpGet
		err := httpGet.Initialize_From_ContainerAppProbe_HttpGet_STATUS(source.HttpGet)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ContainerAppProbe_HttpGet_STATUS() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TcpSocket
	if source.TcpSocket != nil {
		var tcpSocket ContainerAppProbe_TcpSocket
		err := tcpSocket.Initialize_From_ContainerAppProbe_TcpSocket_STATUS(source.TcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ContainerAppProbe_TcpSocket_STATUS() to populate field TcpSocket")
		}
		probe.TcpSocket = &tcpSocket
	} else {
		probe.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	probe.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), containerAppProbe_Type_Values)
		probe.Type = &typeVar
	} else {
		probe.Type = nil
	}

	// No error
	return nil
}

// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive
// traffic.
type ContainerAppProbe_STATUS struct {
	// FailureThreshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to
	// 3. Minimum value is 1. Maximum value is 10.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: HTTPGet specifies the http request to perform.
	HttpGet *ContainerAppProbe_HttpGet_STATUS `json:"httpGet,omitempty"`

	// InitialDelaySeconds: Number of seconds after the container has started before liveness probes are initiated. Minimum
	// value is 1. Maximum value is 60.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is
	// 240.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults
	// to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TcpSocket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
	TcpSocket *ContainerAppProbe_TcpSocket_STATUS `json:"tcpSocket,omitempty"`

	// TerminationGracePeriodSeconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
	// The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the
	// time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for
	// your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value
	// overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop
	// immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling
	// ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
	TerminationGracePeriodSeconds *int `json:"terminationGracePeriodSeconds,omitempty"`

	// TimeoutSeconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum
	// value is 240.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`

	// Type: The type of probe.
	Type *ContainerAppProbe_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerAppProbe_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probe *ContainerAppProbe_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerAppProbe_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probe *ContainerAppProbe_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerAppProbe_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerAppProbe_STATUS, got %T", armInput)
	}

	// Set property "FailureThreshold":
	if typedInput.FailureThreshold != nil {
		failureThreshold := *typedInput.FailureThreshold
		probe.FailureThreshold = &failureThreshold
	}

	// Set property "HttpGet":
	if typedInput.HttpGet != nil {
		var httpGet1 ContainerAppProbe_HttpGet_STATUS
		err := httpGet1.PopulateFromARM(owner, *typedInput.HttpGet)
		if err != nil {
			return err
		}
		httpGet := httpGet1
		probe.HttpGet = &httpGet
	}

	// Set property "InitialDelaySeconds":
	if typedInput.InitialDelaySeconds != nil {
		initialDelaySeconds := *typedInput.InitialDelaySeconds
		probe.InitialDelaySeconds = &initialDelaySeconds
	}

	// Set property "PeriodSeconds":
	if typedInput.PeriodSeconds != nil {
		periodSeconds := *typedInput.PeriodSeconds
		probe.PeriodSeconds = &periodSeconds
	}

	// Set property "SuccessThreshold":
	if typedInput.SuccessThreshold != nil {
		successThreshold := *typedInput.SuccessThreshold
		probe.SuccessThreshold = &successThreshold
	}

	// Set property "TcpSocket":
	if typedInput.TcpSocket != nil {
		var tcpSocket1 ContainerAppProbe_TcpSocket_STATUS
		err := tcpSocket1.PopulateFromARM(owner, *typedInput.TcpSocket)
		if err != nil {
			return err
		}
		tcpSocket := tcpSocket1
		probe.TcpSocket = &tcpSocket
	}

	// Set property "TerminationGracePeriodSeconds":
	if typedInput.TerminationGracePeriodSeconds != nil {
		terminationGracePeriodSeconds := *typedInput.TerminationGracePeriodSeconds
		probe.TerminationGracePeriodSeconds = &terminationGracePeriodSeconds
	}

	// Set property "TimeoutSeconds":
	if typedInput.TimeoutSeconds != nil {
		timeoutSeconds := *typedInput.TimeoutSeconds
		probe.TimeoutSeconds = &timeoutSeconds
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ContainerAppProbe_Type_STATUS(temp)
		probe.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerAppProbe_STATUS populates our ContainerAppProbe_STATUS from the provided source ContainerAppProbe_STATUS
func (probe *ContainerAppProbe_STATUS) AssignProperties_From_ContainerAppProbe_STATUS(source *storage.ContainerAppProbe_STATUS) error {

	// FailureThreshold
	probe.FailureThreshold = genruntime.ClonePointerToInt(source.FailureThreshold)

	// HttpGet
	if source.HttpGet != nil {
		var httpGet ContainerAppProbe_HttpGet_STATUS
		err := httpGet.AssignProperties_From_ContainerAppProbe_HttpGet_STATUS(source.HttpGet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_HttpGet_STATUS() to populate field HttpGet")
		}
		probe.HttpGet = &httpGet
	} else {
		probe.HttpGet = nil
	}

	// InitialDelaySeconds
	probe.InitialDelaySeconds = genruntime.ClonePointerToInt(source.InitialDelaySeconds)

	// PeriodSeconds
	probe.PeriodSeconds = genruntime.ClonePointerToInt(source.PeriodSeconds)

	// SuccessThreshold
	probe.SuccessThreshold = genruntime.ClonePointerToInt(source.SuccessThreshold)

	// TcpSocket
	if source.TcpSocket != nil {
		var tcpSocket ContainerAppProbe_TcpSocket_STATUS
		err := tcpSocket.AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS(source.TcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS() to populate field TcpSocket")
		}
		probe.TcpSocket = &tcpSocket
	} else {
		probe.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	probe.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(source.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	probe.TimeoutSeconds = genruntime.ClonePointerToInt(source.TimeoutSeconds)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, containerAppProbe_Type_STATUS_Values)
		probe.Type = &typeTemp
	} else {
		probe.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_STATUS populates the provided destination ContainerAppProbe_STATUS from our ContainerAppProbe_STATUS
func (probe *ContainerAppProbe_STATUS) AssignProperties_To_ContainerAppProbe_STATUS(destination *storage.ContainerAppProbe_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FailureThreshold
	destination.FailureThreshold = genruntime.ClonePointerToInt(probe.FailureThreshold)

	// HttpGet
	if probe.HttpGet != nil {
		var httpGet storage.ContainerAppProbe_HttpGet_STATUS
		err := probe.HttpGet.AssignProperties_To_ContainerAppProbe_HttpGet_STATUS(&httpGet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_HttpGet_STATUS() to populate field HttpGet")
		}
		destination.HttpGet = &httpGet
	} else {
		destination.HttpGet = nil
	}

	// InitialDelaySeconds
	destination.InitialDelaySeconds = genruntime.ClonePointerToInt(probe.InitialDelaySeconds)

	// PeriodSeconds
	destination.PeriodSeconds = genruntime.ClonePointerToInt(probe.PeriodSeconds)

	// SuccessThreshold
	destination.SuccessThreshold = genruntime.ClonePointerToInt(probe.SuccessThreshold)

	// TcpSocket
	if probe.TcpSocket != nil {
		var tcpSocket storage.ContainerAppProbe_TcpSocket_STATUS
		err := probe.TcpSocket.AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS(&tcpSocket)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS() to populate field TcpSocket")
		}
		destination.TcpSocket = &tcpSocket
	} else {
		destination.TcpSocket = nil
	}

	// TerminationGracePeriodSeconds
	destination.TerminationGracePeriodSeconds = genruntime.ClonePointerToInt(probe.TerminationGracePeriodSeconds)

	// TimeoutSeconds
	destination.TimeoutSeconds = genruntime.ClonePointerToInt(probe.TimeoutSeconds)

	// Type
	if probe.Type != nil {
		typeVar := string(*probe.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App container resource requirements.
type ContainerResources struct {
	// Cpu: Required CPU in cores, e.g. 0.5
	Cpu *float64 `json:"cpu,omitempty"`

	// Memory: Required memory, e.g. "250Mb"
	Memory *string `json:"memory,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerResources{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resources *ContainerResources) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resources == nil {
		return nil, nil
	}
	result := &arm.ContainerResources{}

	// Set property "Cpu":
	if resources.Cpu != nil {
		cpu := *resources.Cpu
		result.Cpu = &cpu
	}

	// Set property "Memory":
	if resources.Memory != nil {
		memory := *resources.Memory
		result.Memory = &memory
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resources *ContainerResources) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerResources{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resources *ContainerResources) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerResources)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerResources, got %T", armInput)
	}

	// Set property "Cpu":
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		resources.Cpu = &cpu
	}

	// Set property "Memory":
	if typedInput.Memory != nil {
		memory := *typedInput.Memory
		resources.Memory = &memory
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerResources populates our ContainerResources from the provided source ContainerResources
func (resources *ContainerResources) AssignProperties_From_ContainerResources(source *storage.ContainerResources) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		resources.Cpu = &cpu
	} else {
		resources.Cpu = nil
	}

	// Memory
	resources.Memory = genruntime.ClonePointerToString(source.Memory)

	// No error
	return nil
}

// AssignProperties_To_ContainerResources populates the provided destination ContainerResources from our ContainerResources
func (resources *ContainerResources) AssignProperties_To_ContainerResources(destination *storage.ContainerResources) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if resources.Cpu != nil {
		cpu := *resources.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// Memory
	destination.Memory = genruntime.ClonePointerToString(resources.Memory)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerResources_STATUS populates our ContainerResources from the provided source ContainerResources_STATUS
func (resources *ContainerResources) Initialize_From_ContainerResources_STATUS(source *ContainerResources_STATUS) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		resources.Cpu = &cpu
	} else {
		resources.Cpu = nil
	}

	// Memory
	resources.Memory = genruntime.ClonePointerToString(source.Memory)

	// No error
	return nil
}

// Container App container resource requirements.
type ContainerResources_STATUS struct {
	// Cpu: Required CPU in cores, e.g. 0.5
	Cpu *float64 `json:"cpu,omitempty"`

	// EphemeralStorage: Ephemeral Storage, e.g. "1Gi"
	EphemeralStorage *string `json:"ephemeralStorage,omitempty"`

	// Memory: Required memory, e.g. "250Mb"
	Memory *string `json:"memory,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerResources_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resources *ContainerResources_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerResources_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resources *ContainerResources_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerResources_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerResources_STATUS, got %T", armInput)
	}

	// Set property "Cpu":
	if typedInput.Cpu != nil {
		cpu := *typedInput.Cpu
		resources.Cpu = &cpu
	}

	// Set property "EphemeralStorage":
	if typedInput.EphemeralStorage != nil {
		ephemeralStorage := *typedInput.EphemeralStorage
		resources.EphemeralStorage = &ephemeralStorage
	}

	// Set property "Memory":
	if typedInput.Memory != nil {
		memory := *typedInput.Memory
		resources.Memory = &memory
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerResources_STATUS populates our ContainerResources_STATUS from the provided source ContainerResources_STATUS
func (resources *ContainerResources_STATUS) AssignProperties_From_ContainerResources_STATUS(source *storage.ContainerResources_STATUS) error {

	// Cpu
	if source.Cpu != nil {
		cpu := *source.Cpu
		resources.Cpu = &cpu
	} else {
		resources.Cpu = nil
	}

	// EphemeralStorage
	resources.EphemeralStorage = genruntime.ClonePointerToString(source.EphemeralStorage)

	// Memory
	resources.Memory = genruntime.ClonePointerToString(source.Memory)

	// No error
	return nil
}

// AssignProperties_To_ContainerResources_STATUS populates the provided destination ContainerResources_STATUS from our ContainerResources_STATUS
func (resources *ContainerResources_STATUS) AssignProperties_To_ContainerResources_STATUS(destination *storage.ContainerResources_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cpu
	if resources.Cpu != nil {
		cpu := *resources.Cpu
		destination.Cpu = &cpu
	} else {
		destination.Cpu = nil
	}

	// EphemeralStorage
	destination.EphemeralStorage = genruntime.ClonePointerToString(resources.EphemeralStorage)

	// Memory
	destination.Memory = genruntime.ClonePointerToString(resources.Memory)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Cross-Origin-Resource-Sharing policy
type CorsPolicy struct {
	// AllowCredentials: Specifies whether the resource allows credentials
	AllowCredentials *bool `json:"allowCredentials,omitempty"`

	// AllowedHeaders: Specifies the content for the access-control-allow-headers header
	AllowedHeaders []string `json:"allowedHeaders,omitempty"`

	// AllowedMethods: Specifies the content for the access-control-allow-methods header
	AllowedMethods []string `json:"allowedMethods,omitempty"`

	// +kubebuilder:validation:Required
	// AllowedOrigins: Specifies the content for the access-control-allow-origins header
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// ExposeHeaders: Specifies the content for the access-control-expose-headers header
	ExposeHeaders []string `json:"exposeHeaders,omitempty"`

	// MaxAge: Specifies the content for the access-control-max-age header
	MaxAge *int `json:"maxAge,omitempty"`
}

var _ genruntime.ARMTransformer = &CorsPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *CorsPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.CorsPolicy{}

	// Set property "AllowCredentials":
	if policy.AllowCredentials != nil {
		allowCredentials := *policy.AllowCredentials
		result.AllowCredentials = &allowCredentials
	}

	// Set property "AllowedHeaders":
	for _, item := range policy.AllowedHeaders {
		result.AllowedHeaders = append(result.AllowedHeaders, item)
	}

	// Set property "AllowedMethods":
	for _, item := range policy.AllowedMethods {
		result.AllowedMethods = append(result.AllowedMethods, item)
	}

	// Set property "AllowedOrigins":
	for _, item := range policy.AllowedOrigins {
		result.AllowedOrigins = append(result.AllowedOrigins, item)
	}

	// Set property "ExposeHeaders":
	for _, item := range policy.ExposeHeaders {
		result.ExposeHeaders = append(result.ExposeHeaders, item)
	}

	// Set property "MaxAge":
	if policy.MaxAge != nil {
		maxAge := *policy.MaxAge
		result.MaxAge = &maxAge
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *CorsPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CorsPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *CorsPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CorsPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CorsPolicy, got %T", armInput)
	}

	// Set property "AllowCredentials":
	if typedInput.AllowCredentials != nil {
		allowCredentials := *typedInput.AllowCredentials
		policy.AllowCredentials = &allowCredentials
	}

	// Set property "AllowedHeaders":
	for _, item := range typedInput.AllowedHeaders {
		policy.AllowedHeaders = append(policy.AllowedHeaders, item)
	}

	// Set property "AllowedMethods":
	for _, item := range typedInput.AllowedMethods {
		policy.AllowedMethods = append(policy.AllowedMethods, item)
	}

	// Set property "AllowedOrigins":
	for _, item := range typedInput.AllowedOrigins {
		policy.AllowedOrigins = append(policy.AllowedOrigins, item)
	}

	// Set property "ExposeHeaders":
	for _, item := range typedInput.ExposeHeaders {
		policy.ExposeHeaders = append(policy.ExposeHeaders, item)
	}

	// Set property "MaxAge":
	if typedInput.MaxAge != nil {
		maxAge := *typedInput.MaxAge
		policy.MaxAge = &maxAge
	}

	// No error
	return nil
}

// AssignProperties_From_CorsPolicy populates our CorsPolicy from the provided source CorsPolicy
func (policy *CorsPolicy) AssignProperties_From_CorsPolicy(source *storage.CorsPolicy) error {

	// AllowCredentials
	if source.AllowCredentials != nil {
		allowCredential := *source.AllowCredentials
		policy.AllowCredentials = &allowCredential
	} else {
		policy.AllowCredentials = nil
	}

	// AllowedHeaders
	policy.AllowedHeaders = genruntime.CloneSliceOfString(source.AllowedHeaders)

	// AllowedMethods
	policy.AllowedMethods = genruntime.CloneSliceOfString(source.AllowedMethods)

	// AllowedOrigins
	policy.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// ExposeHeaders
	policy.ExposeHeaders = genruntime.CloneSliceOfString(source.ExposeHeaders)

	// MaxAge
	policy.MaxAge = genruntime.ClonePointerToInt(source.MaxAge)

	// No error
	return nil
}

// AssignProperties_To_CorsPolicy populates the provided destination CorsPolicy from our CorsPolicy
func (policy *CorsPolicy) AssignProperties_To_CorsPolicy(destination *storage.CorsPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowCredentials
	if policy.AllowCredentials != nil {
		allowCredential := *policy.AllowCredentials
		destination.AllowCredentials = &allowCredential
	} else {
		destination.AllowCredentials = nil
	}

	// AllowedHeaders
	destination.AllowedHeaders = genruntime.CloneSliceOfString(policy.AllowedHeaders)

	// AllowedMethods
	destination.AllowedMethods = genruntime.CloneSliceOfString(policy.AllowedMethods)

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(policy.AllowedOrigins)

	// ExposeHeaders
	destination.ExposeHeaders = genruntime.CloneSliceOfString(policy.ExposeHeaders)

	// MaxAge
	destination.MaxAge = genruntime.ClonePointerToInt(policy.MaxAge)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CorsPolicy_STATUS populates our CorsPolicy from the provided source CorsPolicy_STATUS
func (policy *CorsPolicy) Initialize_From_CorsPolicy_STATUS(source *CorsPolicy_STATUS) error {

	// AllowCredentials
	if source.AllowCredentials != nil {
		allowCredential := *source.AllowCredentials
		policy.AllowCredentials = &allowCredential
	} else {
		policy.AllowCredentials = nil
	}

	// AllowedHeaders
	policy.AllowedHeaders = genruntime.CloneSliceOfString(source.AllowedHeaders)

	// AllowedMethods
	policy.AllowedMethods = genruntime.CloneSliceOfString(source.AllowedMethods)

	// AllowedOrigins
	policy.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// ExposeHeaders
	policy.ExposeHeaders = genruntime.CloneSliceOfString(source.ExposeHeaders)

	// MaxAge
	policy.MaxAge = genruntime.ClonePointerToInt(source.MaxAge)

	// No error
	return nil
}

// Cross-Origin-Resource-Sharing policy
type CorsPolicy_STATUS struct {
	// AllowCredentials: Specifies whether the resource allows credentials
	AllowCredentials *bool `json:"allowCredentials,omitempty"`

	// AllowedHeaders: Specifies the content for the access-control-allow-headers header
	AllowedHeaders []string `json:"allowedHeaders,omitempty"`

	// AllowedMethods: Specifies the content for the access-control-allow-methods header
	AllowedMethods []string `json:"allowedMethods,omitempty"`

	// AllowedOrigins: Specifies the content for the access-control-allow-origins header
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// ExposeHeaders: Specifies the content for the access-control-expose-headers header
	ExposeHeaders []string `json:"exposeHeaders,omitempty"`

	// MaxAge: Specifies the content for the access-control-max-age header
	MaxAge *int `json:"maxAge,omitempty"`
}

var _ genruntime.FromARMConverter = &CorsPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *CorsPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CorsPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *CorsPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CorsPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CorsPolicy_STATUS, got %T", armInput)
	}

	// Set property "AllowCredentials":
	if typedInput.AllowCredentials != nil {
		allowCredentials := *typedInput.AllowCredentials
		policy.AllowCredentials = &allowCredentials
	}

	// Set property "AllowedHeaders":
	for _, item := range typedInput.AllowedHeaders {
		policy.AllowedHeaders = append(policy.AllowedHeaders, item)
	}

	// Set property "AllowedMethods":
	for _, item := range typedInput.AllowedMethods {
		policy.AllowedMethods = append(policy.AllowedMethods, item)
	}

	// Set property "AllowedOrigins":
	for _, item := range typedInput.AllowedOrigins {
		policy.AllowedOrigins = append(policy.AllowedOrigins, item)
	}

	// Set property "ExposeHeaders":
	for _, item := range typedInput.ExposeHeaders {
		policy.ExposeHeaders = append(policy.ExposeHeaders, item)
	}

	// Set property "MaxAge":
	if typedInput.MaxAge != nil {
		maxAge := *typedInput.MaxAge
		policy.MaxAge = &maxAge
	}

	// No error
	return nil
}

// AssignProperties_From_CorsPolicy_STATUS populates our CorsPolicy_STATUS from the provided source CorsPolicy_STATUS
func (policy *CorsPolicy_STATUS) AssignProperties_From_CorsPolicy_STATUS(source *storage.CorsPolicy_STATUS) error {

	// AllowCredentials
	if source.AllowCredentials != nil {
		allowCredential := *source.AllowCredentials
		policy.AllowCredentials = &allowCredential
	} else {
		policy.AllowCredentials = nil
	}

	// AllowedHeaders
	policy.AllowedHeaders = genruntime.CloneSliceOfString(source.AllowedHeaders)

	// AllowedMethods
	policy.AllowedMethods = genruntime.CloneSliceOfString(source.AllowedMethods)

	// AllowedOrigins
	policy.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// ExposeHeaders
	policy.ExposeHeaders = genruntime.CloneSliceOfString(source.ExposeHeaders)

	// MaxAge
	policy.MaxAge = genruntime.ClonePointerToInt(source.MaxAge)

	// No error
	return nil
}

// AssignProperties_To_CorsPolicy_STATUS populates the provided destination CorsPolicy_STATUS from our CorsPolicy_STATUS
func (policy *CorsPolicy_STATUS) AssignProperties_To_CorsPolicy_STATUS(destination *storage.CorsPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowCredentials
	if policy.AllowCredentials != nil {
		allowCredential := *policy.AllowCredentials
		destination.AllowCredentials = &allowCredential
	} else {
		destination.AllowCredentials = nil
	}

	// AllowedHeaders
	destination.AllowedHeaders = genruntime.CloneSliceOfString(policy.AllowedHeaders)

	// AllowedMethods
	destination.AllowedMethods = genruntime.CloneSliceOfString(policy.AllowedMethods)

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(policy.AllowedOrigins)

	// ExposeHeaders
	destination.ExposeHeaders = genruntime.CloneSliceOfString(policy.ExposeHeaders)

	// MaxAge
	destination.MaxAge = genruntime.ClonePointerToInt(policy.MaxAge)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Custom Domain of a Container App
type CustomDomain struct {
	// BindingType: Custom Domain binding type.
	BindingType *CustomDomain_BindingType `json:"bindingType,omitempty"`

	// CertificateReference: Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
	CertificateReference *genruntime.ResourceReference `armReference:"CertificateId" json:"certificateReference,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Hostname.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomDomain{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (domain *CustomDomain) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if domain == nil {
		return nil, nil
	}
	result := &arm.CustomDomain{}

	// Set property "BindingType":
	if domain.BindingType != nil {
		var temp string
		temp = string(*domain.BindingType)
		bindingType := arm.CustomDomain_BindingType(temp)
		result.BindingType = &bindingType
	}

	// Set property "CertificateId":
	if domain.CertificateReference != nil {
		certificateReferenceARMID, err := resolved.ResolvedReferences.Lookup(*domain.CertificateReference)
		if err != nil {
			return nil, err
		}
		certificateReference := certificateReferenceARMID
		result.CertificateId = &certificateReference
	}

	// Set property "Name":
	if domain.Name != nil {
		name := *domain.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (domain *CustomDomain) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomDomain{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (domain *CustomDomain) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomDomain)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomDomain, got %T", armInput)
	}

	// Set property "BindingType":
	if typedInput.BindingType != nil {
		var temp string
		temp = string(*typedInput.BindingType)
		bindingType := CustomDomain_BindingType(temp)
		domain.BindingType = &bindingType
	}

	// no assignment for property "CertificateReference"

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		domain.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_CustomDomain populates our CustomDomain from the provided source CustomDomain
func (domain *CustomDomain) AssignProperties_From_CustomDomain(source *storage.CustomDomain) error {

	// BindingType
	if source.BindingType != nil {
		bindingType := *source.BindingType
		bindingTypeTemp := genruntime.ToEnum(bindingType, customDomain_BindingType_Values)
		domain.BindingType = &bindingTypeTemp
	} else {
		domain.BindingType = nil
	}

	// CertificateReference
	if source.CertificateReference != nil {
		certificateReference := source.CertificateReference.Copy()
		domain.CertificateReference = &certificateReference
	} else {
		domain.CertificateReference = nil
	}

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_CustomDomain populates the provided destination CustomDomain from our CustomDomain
func (domain *CustomDomain) AssignProperties_To_CustomDomain(destination *storage.CustomDomain) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingType
	if domain.BindingType != nil {
		bindingType := string(*domain.BindingType)
		destination.BindingType = &bindingType
	} else {
		destination.BindingType = nil
	}

	// CertificateReference
	if domain.CertificateReference != nil {
		certificateReference := domain.CertificateReference.Copy()
		destination.CertificateReference = &certificateReference
	} else {
		destination.CertificateReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(domain.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomDomain_STATUS populates our CustomDomain from the provided source CustomDomain_STATUS
func (domain *CustomDomain) Initialize_From_CustomDomain_STATUS(source *CustomDomain_STATUS) error {

	// BindingType
	if source.BindingType != nil {
		bindingType := genruntime.ToEnum(string(*source.BindingType), customDomain_BindingType_Values)
		domain.BindingType = &bindingType
	} else {
		domain.BindingType = nil
	}

	// CertificateReference
	if source.CertificateId != nil {
		certificateReference := genruntime.CreateResourceReferenceFromARMID(*source.CertificateId)
		domain.CertificateReference = &certificateReference
	} else {
		domain.CertificateReference = nil
	}

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// Custom Domain of a Container App
type CustomDomain_STATUS struct {
	// BindingType: Custom Domain binding type.
	BindingType *CustomDomain_BindingType_STATUS `json:"bindingType,omitempty"`

	// CertificateId: Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
	CertificateId *string `json:"certificateId,omitempty"`

	// Name: Hostname.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomDomain_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (domain *CustomDomain_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomDomain_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (domain *CustomDomain_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomDomain_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomDomain_STATUS, got %T", armInput)
	}

	// Set property "BindingType":
	if typedInput.BindingType != nil {
		var temp string
		temp = string(*typedInput.BindingType)
		bindingType := CustomDomain_BindingType_STATUS(temp)
		domain.BindingType = &bindingType
	}

	// Set property "CertificateId":
	if typedInput.CertificateId != nil {
		certificateId := *typedInput.CertificateId
		domain.CertificateId = &certificateId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		domain.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_CustomDomain_STATUS populates our CustomDomain_STATUS from the provided source CustomDomain_STATUS
func (domain *CustomDomain_STATUS) AssignProperties_From_CustomDomain_STATUS(source *storage.CustomDomain_STATUS) error {

	// BindingType
	if source.BindingType != nil {
		bindingType := *source.BindingType
		bindingTypeTemp := genruntime.ToEnum(bindingType, customDomain_BindingType_STATUS_Values)
		domain.BindingType = &bindingTypeTemp
	} else {
		domain.BindingType = nil
	}

	// CertificateId
	domain.CertificateId = genruntime.ClonePointerToString(source.CertificateId)

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_CustomDomain_STATUS populates the provided destination CustomDomain_STATUS from our CustomDomain_STATUS
func (domain *CustomDomain_STATUS) AssignProperties_To_CustomDomain_STATUS(destination *storage.CustomDomain_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingType
	if domain.BindingType != nil {
		bindingType := string(*domain.BindingType)
		destination.BindingType = &bindingType
	} else {
		destination.BindingType = nil
	}

	// CertificateId
	destination.CertificateId = genruntime.ClonePointerToString(domain.CertificateId)

	// Name
	destination.Name = genruntime.ClonePointerToString(domain.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"grpc","http"}
type Dapr_AppProtocol string

const (
	Dapr_AppProtocol_Grpc = Dapr_AppProtocol("grpc")
	Dapr_AppProtocol_Http = Dapr_AppProtocol("http")
)

// Mapping from string to Dapr_AppProtocol
var dapr_AppProtocol_Values = map[string]Dapr_AppProtocol{
	"grpc": Dapr_AppProtocol_Grpc,
	"http": Dapr_AppProtocol_Http,
}

type Dapr_AppProtocol_STATUS string

const (
	Dapr_AppProtocol_STATUS_Grpc = Dapr_AppProtocol_STATUS("grpc")
	Dapr_AppProtocol_STATUS_Http = Dapr_AppProtocol_STATUS("http")
)

// Mapping from string to Dapr_AppProtocol_STATUS
var dapr_AppProtocol_STATUS_Values = map[string]Dapr_AppProtocol_STATUS{
	"grpc": Dapr_AppProtocol_STATUS_Grpc,
	"http": Dapr_AppProtocol_STATUS_Http,
}

// +kubebuilder:validation:Enum={"debug","error","info","warn"}
type Dapr_LogLevel string

const (
	Dapr_LogLevel_Debug = Dapr_LogLevel("debug")
	Dapr_LogLevel_Error = Dapr_LogLevel("error")
	Dapr_LogLevel_Info  = Dapr_LogLevel("info")
	Dapr_LogLevel_Warn  = Dapr_LogLevel("warn")
)

// Mapping from string to Dapr_LogLevel
var dapr_LogLevel_Values = map[string]Dapr_LogLevel{
	"debug": Dapr_LogLevel_Debug,
	"error": Dapr_LogLevel_Error,
	"info":  Dapr_LogLevel_Info,
	"warn":  Dapr_LogLevel_Warn,
}

type Dapr_LogLevel_STATUS string

const (
	Dapr_LogLevel_STATUS_Debug = Dapr_LogLevel_STATUS("debug")
	Dapr_LogLevel_STATUS_Error = Dapr_LogLevel_STATUS("error")
	Dapr_LogLevel_STATUS_Info  = Dapr_LogLevel_STATUS("info")
	Dapr_LogLevel_STATUS_Warn  = Dapr_LogLevel_STATUS("warn")
)

// Mapping from string to Dapr_LogLevel_STATUS
var dapr_LogLevel_STATUS_Values = map[string]Dapr_LogLevel_STATUS{
	"debug": Dapr_LogLevel_STATUS_Debug,
	"error": Dapr_LogLevel_STATUS_Error,
	"info":  Dapr_LogLevel_STATUS_Info,
	"warn":  Dapr_LogLevel_STATUS_Warn,
}

// Container App container environment variable.
type EnvironmentVar struct {
	// Name: Environment variable name.
	Name *string `json:"name,omitempty"`

	// SecretRef: Name of the Container App secret from which to pull the environment variable value.
	SecretRef *string `json:"secretRef,omitempty"`

	// Value: Non-secret environment variable value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EnvironmentVar{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (environmentVar *EnvironmentVar) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if environmentVar == nil {
		return nil, nil
	}
	result := &arm.EnvironmentVar{}

	// Set property "Name":
	if environmentVar.Name != nil {
		name := *environmentVar.Name
		result.Name = &name
	}

	// Set property "SecretRef":
	if environmentVar.SecretRef != nil {
		secretRef := *environmentVar.SecretRef
		result.SecretRef = &secretRef
	}

	// Set property "Value":
	if environmentVar.Value != nil {
		value := *environmentVar.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (environmentVar *EnvironmentVar) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnvironmentVar{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (environmentVar *EnvironmentVar) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnvironmentVar)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnvironmentVar, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		environmentVar.Name = &name
	}

	// Set property "SecretRef":
	if typedInput.SecretRef != nil {
		secretRef := *typedInput.SecretRef
		environmentVar.SecretRef = &secretRef
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		environmentVar.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnvironmentVar populates our EnvironmentVar from the provided source EnvironmentVar
func (environmentVar *EnvironmentVar) AssignProperties_From_EnvironmentVar(source *storage.EnvironmentVar) error {

	// Name
	environmentVar.Name = genruntime.ClonePointerToString(source.Name)

	// SecretRef
	environmentVar.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// Value
	environmentVar.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVar populates the provided destination EnvironmentVar from our EnvironmentVar
func (environmentVar *EnvironmentVar) AssignProperties_To_EnvironmentVar(destination *storage.EnvironmentVar) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(environmentVar.Name)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(environmentVar.SecretRef)

	// Value
	destination.Value = genruntime.ClonePointerToString(environmentVar.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EnvironmentVar_STATUS populates our EnvironmentVar from the provided source EnvironmentVar_STATUS
func (environmentVar *EnvironmentVar) Initialize_From_EnvironmentVar_STATUS(source *EnvironmentVar_STATUS) error {

	// Name
	environmentVar.Name = genruntime.ClonePointerToString(source.Name)

	// SecretRef
	environmentVar.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// Value
	environmentVar.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Container App container environment variable.
type EnvironmentVar_STATUS struct {
	// Name: Environment variable name.
	Name *string `json:"name,omitempty"`

	// SecretRef: Name of the Container App secret from which to pull the environment variable value.
	SecretRef *string `json:"secretRef,omitempty"`

	// Value: Non-secret environment variable value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EnvironmentVar_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (environmentVar *EnvironmentVar_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnvironmentVar_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (environmentVar *EnvironmentVar_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnvironmentVar_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnvironmentVar_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		environmentVar.Name = &name
	}

	// Set property "SecretRef":
	if typedInput.SecretRef != nil {
		secretRef := *typedInput.SecretRef
		environmentVar.SecretRef = &secretRef
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		environmentVar.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnvironmentVar_STATUS populates our EnvironmentVar_STATUS from the provided source EnvironmentVar_STATUS
func (environmentVar *EnvironmentVar_STATUS) AssignProperties_From_EnvironmentVar_STATUS(source *storage.EnvironmentVar_STATUS) error {

	// Name
	environmentVar.Name = genruntime.ClonePointerToString(source.Name)

	// SecretRef
	environmentVar.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// Value
	environmentVar.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVar_STATUS populates the provided destination EnvironmentVar_STATUS from our EnvironmentVar_STATUS
func (environmentVar *EnvironmentVar_STATUS) AssignProperties_To_EnvironmentVar_STATUS(destination *storage.EnvironmentVar_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(environmentVar.Name)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(environmentVar.SecretRef)

	// Value
	destination.Value = genruntime.ClonePointerToString(environmentVar.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"accept","ignore","require"}
type Ingress_ClientCertificateMode string

const (
	Ingress_ClientCertificateMode_Accept  = Ingress_ClientCertificateMode("accept")
	Ingress_ClientCertificateMode_Ignore  = Ingress_ClientCertificateMode("ignore")
	Ingress_ClientCertificateMode_Require = Ingress_ClientCertificateMode("require")
)

// Mapping from string to Ingress_ClientCertificateMode
var ingress_ClientCertificateMode_Values = map[string]Ingress_ClientCertificateMode{
	"accept":  Ingress_ClientCertificateMode_Accept,
	"ignore":  Ingress_ClientCertificateMode_Ignore,
	"require": Ingress_ClientCertificateMode_Require,
}

type Ingress_ClientCertificateMode_STATUS string

const (
	Ingress_ClientCertificateMode_STATUS_Accept  = Ingress_ClientCertificateMode_STATUS("accept")
	Ingress_ClientCertificateMode_STATUS_Ignore  = Ingress_ClientCertificateMode_STATUS("ignore")
	Ingress_ClientCertificateMode_STATUS_Require = Ingress_ClientCertificateMode_STATUS("require")
)

// Mapping from string to Ingress_ClientCertificateMode_STATUS
var ingress_ClientCertificateMode_STATUS_Values = map[string]Ingress_ClientCertificateMode_STATUS{
	"accept":  Ingress_ClientCertificateMode_STATUS_Accept,
	"ignore":  Ingress_ClientCertificateMode_STATUS_Ignore,
	"require": Ingress_ClientCertificateMode_STATUS_Require,
}

type Ingress_StickySessions struct {
	// Affinity: Sticky Session Affinity
	Affinity *Ingress_StickySessions_Affinity `json:"affinity,omitempty"`
}

var _ genruntime.ARMTransformer = &Ingress_StickySessions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sessions *Ingress_StickySessions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sessions == nil {
		return nil, nil
	}
	result := &arm.Ingress_StickySessions{}

	// Set property "Affinity":
	if sessions.Affinity != nil {
		var temp string
		temp = string(*sessions.Affinity)
		affinity := arm.Ingress_StickySessions_Affinity(temp)
		result.Affinity = &affinity
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sessions *Ingress_StickySessions) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Ingress_StickySessions{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sessions *Ingress_StickySessions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Ingress_StickySessions)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Ingress_StickySessions, got %T", armInput)
	}

	// Set property "Affinity":
	if typedInput.Affinity != nil {
		var temp string
		temp = string(*typedInput.Affinity)
		affinity := Ingress_StickySessions_Affinity(temp)
		sessions.Affinity = &affinity
	}

	// No error
	return nil
}

// AssignProperties_From_Ingress_StickySessions populates our Ingress_StickySessions from the provided source Ingress_StickySessions
func (sessions *Ingress_StickySessions) AssignProperties_From_Ingress_StickySessions(source *storage.Ingress_StickySessions) error {

	// Affinity
	if source.Affinity != nil {
		affinity := *source.Affinity
		affinityTemp := genruntime.ToEnum(affinity, ingress_StickySessions_Affinity_Values)
		sessions.Affinity = &affinityTemp
	} else {
		sessions.Affinity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Ingress_StickySessions populates the provided destination Ingress_StickySessions from our Ingress_StickySessions
func (sessions *Ingress_StickySessions) AssignProperties_To_Ingress_StickySessions(destination *storage.Ingress_StickySessions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Affinity
	if sessions.Affinity != nil {
		affinity := string(*sessions.Affinity)
		destination.Affinity = &affinity
	} else {
		destination.Affinity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Ingress_StickySessions_STATUS populates our Ingress_StickySessions from the provided source Ingress_StickySessions_STATUS
func (sessions *Ingress_StickySessions) Initialize_From_Ingress_StickySessions_STATUS(source *Ingress_StickySessions_STATUS) error {

	// Affinity
	if source.Affinity != nil {
		affinity := genruntime.ToEnum(string(*source.Affinity), ingress_StickySessions_Affinity_Values)
		sessions.Affinity = &affinity
	} else {
		sessions.Affinity = nil
	}

	// No error
	return nil
}

type Ingress_StickySessions_STATUS struct {
	// Affinity: Sticky Session Affinity
	Affinity *Ingress_StickySessions_Affinity_STATUS `json:"affinity,omitempty"`
}

var _ genruntime.FromARMConverter = &Ingress_StickySessions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sessions *Ingress_StickySessions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Ingress_StickySessions_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sessions *Ingress_StickySessions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Ingress_StickySessions_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Ingress_StickySessions_STATUS, got %T", armInput)
	}

	// Set property "Affinity":
	if typedInput.Affinity != nil {
		var temp string
		temp = string(*typedInput.Affinity)
		affinity := Ingress_StickySessions_Affinity_STATUS(temp)
		sessions.Affinity = &affinity
	}

	// No error
	return nil
}

// AssignProperties_From_Ingress_StickySessions_STATUS populates our Ingress_StickySessions_STATUS from the provided source Ingress_StickySessions_STATUS
func (sessions *Ingress_StickySessions_STATUS) AssignProperties_From_Ingress_StickySessions_STATUS(source *storage.Ingress_StickySessions_STATUS) error {

	// Affinity
	if source.Affinity != nil {
		affinity := *source.Affinity
		affinityTemp := genruntime.ToEnum(affinity, ingress_StickySessions_Affinity_STATUS_Values)
		sessions.Affinity = &affinityTemp
	} else {
		sessions.Affinity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Ingress_StickySessions_STATUS populates the provided destination Ingress_StickySessions_STATUS from our Ingress_StickySessions_STATUS
func (sessions *Ingress_StickySessions_STATUS) AssignProperties_To_Ingress_StickySessions_STATUS(destination *storage.Ingress_StickySessions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Affinity
	if sessions.Affinity != nil {
		affinity := string(*sessions.Affinity)
		destination.Affinity = &affinity
	} else {
		destination.Affinity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"auto","http","http2","tcp"}
type Ingress_Transport string

const (
	Ingress_Transport_Auto  = Ingress_Transport("auto")
	Ingress_Transport_Http  = Ingress_Transport("http")
	Ingress_Transport_Http2 = Ingress_Transport("http2")
	Ingress_Transport_Tcp   = Ingress_Transport("tcp")
)

// Mapping from string to Ingress_Transport
var ingress_Transport_Values = map[string]Ingress_Transport{
	"auto":  Ingress_Transport_Auto,
	"http":  Ingress_Transport_Http,
	"http2": Ingress_Transport_Http2,
	"tcp":   Ingress_Transport_Tcp,
}

type Ingress_Transport_STATUS string

const (
	Ingress_Transport_STATUS_Auto  = Ingress_Transport_STATUS("auto")
	Ingress_Transport_STATUS_Http  = Ingress_Transport_STATUS("http")
	Ingress_Transport_STATUS_Http2 = Ingress_Transport_STATUS("http2")
	Ingress_Transport_STATUS_Tcp   = Ingress_Transport_STATUS("tcp")
)

// Mapping from string to Ingress_Transport_STATUS
var ingress_Transport_STATUS_Values = map[string]Ingress_Transport_STATUS{
	"auto":  Ingress_Transport_STATUS_Auto,
	"http":  Ingress_Transport_STATUS_Http,
	"http2": Ingress_Transport_STATUS_Http2,
	"tcp":   Ingress_Transport_STATUS_Tcp,
}

// Port mappings of container app ingress
type IngressPortMapping struct {
	// ExposedPort: Specifies the exposed port for the target port. If not specified, it defaults to target port
	ExposedPort *int `json:"exposedPort,omitempty"`

	// +kubebuilder:validation:Required
	// External: Specifies whether the app port is accessible outside of the environment
	External *bool `json:"external,omitempty"`

	// +kubebuilder:validation:Required
	// TargetPort: Specifies the port user's container listens on
	TargetPort *int `json:"targetPort,omitempty"`
}

var _ genruntime.ARMTransformer = &IngressPortMapping{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mapping *IngressPortMapping) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mapping == nil {
		return nil, nil
	}
	result := &arm.IngressPortMapping{}

	// Set property "ExposedPort":
	if mapping.ExposedPort != nil {
		exposedPort := *mapping.ExposedPort
		result.ExposedPort = &exposedPort
	}

	// Set property "External":
	if mapping.External != nil {
		external := *mapping.External
		result.External = &external
	}

	// Set property "TargetPort":
	if mapping.TargetPort != nil {
		targetPort := *mapping.TargetPort
		result.TargetPort = &targetPort
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mapping *IngressPortMapping) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IngressPortMapping{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mapping *IngressPortMapping) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IngressPortMapping)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IngressPortMapping, got %T", armInput)
	}

	// Set property "ExposedPort":
	if typedInput.ExposedPort != nil {
		exposedPort := *typedInput.ExposedPort
		mapping.ExposedPort = &exposedPort
	}

	// Set property "External":
	if typedInput.External != nil {
		external := *typedInput.External
		mapping.External = &external
	}

	// Set property "TargetPort":
	if typedInput.TargetPort != nil {
		targetPort := *typedInput.TargetPort
		mapping.TargetPort = &targetPort
	}

	// No error
	return nil
}

// AssignProperties_From_IngressPortMapping populates our IngressPortMapping from the provided source IngressPortMapping
func (mapping *IngressPortMapping) AssignProperties_From_IngressPortMapping(source *storage.IngressPortMapping) error {

	// ExposedPort
	mapping.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		mapping.External = &external
	} else {
		mapping.External = nil
	}

	// TargetPort
	mapping.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// No error
	return nil
}

// AssignProperties_To_IngressPortMapping populates the provided destination IngressPortMapping from our IngressPortMapping
func (mapping *IngressPortMapping) AssignProperties_To_IngressPortMapping(destination *storage.IngressPortMapping) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExposedPort
	destination.ExposedPort = genruntime.ClonePointerToInt(mapping.ExposedPort)

	// External
	if mapping.External != nil {
		external := *mapping.External
		destination.External = &external
	} else {
		destination.External = nil
	}

	// TargetPort
	destination.TargetPort = genruntime.ClonePointerToInt(mapping.TargetPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IngressPortMapping_STATUS populates our IngressPortMapping from the provided source IngressPortMapping_STATUS
func (mapping *IngressPortMapping) Initialize_From_IngressPortMapping_STATUS(source *IngressPortMapping_STATUS) error {

	// ExposedPort
	mapping.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		mapping.External = &external
	} else {
		mapping.External = nil
	}

	// TargetPort
	mapping.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// No error
	return nil
}

// Port mappings of container app ingress
type IngressPortMapping_STATUS struct {
	// ExposedPort: Specifies the exposed port for the target port. If not specified, it defaults to target port
	ExposedPort *int `json:"exposedPort,omitempty"`

	// External: Specifies whether the app port is accessible outside of the environment
	External *bool `json:"external,omitempty"`

	// TargetPort: Specifies the port user's container listens on
	TargetPort *int `json:"targetPort,omitempty"`
}

var _ genruntime.FromARMConverter = &IngressPortMapping_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mapping *IngressPortMapping_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IngressPortMapping_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mapping *IngressPortMapping_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IngressPortMapping_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IngressPortMapping_STATUS, got %T", armInput)
	}

	// Set property "ExposedPort":
	if typedInput.ExposedPort != nil {
		exposedPort := *typedInput.ExposedPort
		mapping.ExposedPort = &exposedPort
	}

	// Set property "External":
	if typedInput.External != nil {
		external := *typedInput.External
		mapping.External = &external
	}

	// Set property "TargetPort":
	if typedInput.TargetPort != nil {
		targetPort := *typedInput.TargetPort
		mapping.TargetPort = &targetPort
	}

	// No error
	return nil
}

// AssignProperties_From_IngressPortMapping_STATUS populates our IngressPortMapping_STATUS from the provided source IngressPortMapping_STATUS
func (mapping *IngressPortMapping_STATUS) AssignProperties_From_IngressPortMapping_STATUS(source *storage.IngressPortMapping_STATUS) error {

	// ExposedPort
	mapping.ExposedPort = genruntime.ClonePointerToInt(source.ExposedPort)

	// External
	if source.External != nil {
		external := *source.External
		mapping.External = &external
	} else {
		mapping.External = nil
	}

	// TargetPort
	mapping.TargetPort = genruntime.ClonePointerToInt(source.TargetPort)

	// No error
	return nil
}

// AssignProperties_To_IngressPortMapping_STATUS populates the provided destination IngressPortMapping_STATUS from our IngressPortMapping_STATUS
func (mapping *IngressPortMapping_STATUS) AssignProperties_To_IngressPortMapping_STATUS(destination *storage.IngressPortMapping_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExposedPort
	destination.ExposedPort = genruntime.ClonePointerToInt(mapping.ExposedPort)

	// External
	if mapping.External != nil {
		external := *mapping.External
		destination.External = &external
	} else {
		destination.External = nil
	}

	// TargetPort
	destination.TargetPort = genruntime.ClonePointerToInt(mapping.TargetPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Rule to restrict incoming IP address.
type IpSecurityRestrictionRule struct {
	// +kubebuilder:validation:Required
	// Action: Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
	Action *IpSecurityRestrictionRule_Action `json:"action,omitempty"`

	// Description: Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
	Description *string `json:"description,omitempty"`

	// +kubebuilder:validation:Required
	// IpAddressRange: CIDR notation to match incoming IP address
	IpAddressRange *string `json:"ipAddressRange,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Name for the IP restriction rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &IpSecurityRestrictionRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *IpSecurityRestrictionRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.IpSecurityRestrictionRule{}

	// Set property "Action":
	if rule.Action != nil {
		var temp string
		temp = string(*rule.Action)
		action := arm.IpSecurityRestrictionRule_Action(temp)
		result.Action = &action
	}

	// Set property "Description":
	if rule.Description != nil {
		description := *rule.Description
		result.Description = &description
	}

	// Set property "IpAddressRange":
	if rule.IpAddressRange != nil {
		ipAddressRange := *rule.IpAddressRange
		result.IpAddressRange = &ipAddressRange
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpSecurityRestrictionRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpSecurityRestrictionRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpSecurityRestrictionRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpSecurityRestrictionRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpSecurityRestrictionRule, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := IpSecurityRestrictionRule_Action(temp)
		rule.Action = &action
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		rule.Description = &description
	}

	// Set property "IpAddressRange":
	if typedInput.IpAddressRange != nil {
		ipAddressRange := *typedInput.IpAddressRange
		rule.IpAddressRange = &ipAddressRange
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_IpSecurityRestrictionRule populates our IpSecurityRestrictionRule from the provided source IpSecurityRestrictionRule
func (rule *IpSecurityRestrictionRule) AssignProperties_From_IpSecurityRestrictionRule(source *storage.IpSecurityRestrictionRule) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, ipSecurityRestrictionRule_Action_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// IpAddressRange
	rule.IpAddressRange = genruntime.ClonePointerToString(source.IpAddressRange)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_IpSecurityRestrictionRule populates the provided destination IpSecurityRestrictionRule from our IpSecurityRestrictionRule
func (rule *IpSecurityRestrictionRule) AssignProperties_To_IpSecurityRestrictionRule(destination *storage.IpSecurityRestrictionRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// IpAddressRange
	destination.IpAddressRange = genruntime.ClonePointerToString(rule.IpAddressRange)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IpSecurityRestrictionRule_STATUS populates our IpSecurityRestrictionRule from the provided source IpSecurityRestrictionRule_STATUS
func (rule *IpSecurityRestrictionRule) Initialize_From_IpSecurityRestrictionRule_STATUS(source *IpSecurityRestrictionRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), ipSecurityRestrictionRule_Action_Values)
		rule.Action = &action
	} else {
		rule.Action = nil
	}

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// IpAddressRange
	rule.IpAddressRange = genruntime.ClonePointerToString(source.IpAddressRange)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// Rule to restrict incoming IP address.
type IpSecurityRestrictionRule_STATUS struct {
	// Action: Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
	Action *IpSecurityRestrictionRule_Action_STATUS `json:"action,omitempty"`

	// Description: Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
	Description *string `json:"description,omitempty"`

	// IpAddressRange: CIDR notation to match incoming IP address
	IpAddressRange *string `json:"ipAddressRange,omitempty"`

	// Name: Name for the IP restriction rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &IpSecurityRestrictionRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpSecurityRestrictionRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpSecurityRestrictionRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpSecurityRestrictionRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpSecurityRestrictionRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpSecurityRestrictionRule_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := IpSecurityRestrictionRule_Action_STATUS(temp)
		rule.Action = &action
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		rule.Description = &description
	}

	// Set property "IpAddressRange":
	if typedInput.IpAddressRange != nil {
		ipAddressRange := *typedInput.IpAddressRange
		rule.IpAddressRange = &ipAddressRange
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_IpSecurityRestrictionRule_STATUS populates our IpSecurityRestrictionRule_STATUS from the provided source IpSecurityRestrictionRule_STATUS
func (rule *IpSecurityRestrictionRule_STATUS) AssignProperties_From_IpSecurityRestrictionRule_STATUS(source *storage.IpSecurityRestrictionRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, ipSecurityRestrictionRule_Action_STATUS_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// IpAddressRange
	rule.IpAddressRange = genruntime.ClonePointerToString(source.IpAddressRange)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_IpSecurityRestrictionRule_STATUS populates the provided destination IpSecurityRestrictionRule_STATUS from our IpSecurityRestrictionRule_STATUS
func (rule *IpSecurityRestrictionRule_STATUS) AssignProperties_To_IpSecurityRestrictionRule_STATUS(destination *storage.IpSecurityRestrictionRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// IpAddressRange
	destination.IpAddressRange = genruntime.ClonePointerToString(rule.IpAddressRange)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App container scaling rule.
type ScaleRule struct {
	// AzureQueue: Azure Queue based scaling.
	AzureQueue *QueueScaleRule `json:"azureQueue,omitempty"`

	// Custom: Custom scale rule.
	Custom *CustomScaleRule `json:"custom,omitempty"`

	// Http: HTTP requests based scaling.
	Http *HttpScaleRule `json:"http,omitempty"`

	// Name: Scale Rule Name
	Name *string `json:"name,omitempty"`

	// Tcp: Tcp requests based scaling.
	Tcp *TcpScaleRule `json:"tcp,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *ScaleRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.ScaleRule{}

	// Set property "AzureQueue":
	if rule.AzureQueue != nil {
		azureQueue_ARM, err := (*rule.AzureQueue).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureQueue := *azureQueue_ARM.(*arm.QueueScaleRule)
		result.AzureQueue = &azureQueue
	}

	// Set property "Custom":
	if rule.Custom != nil {
		custom_ARM, err := (*rule.Custom).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		custom := *custom_ARM.(*arm.CustomScaleRule)
		result.Custom = &custom
	}

	// Set property "Http":
	if rule.Http != nil {
		http_ARM, err := (*rule.Http).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		http := *http_ARM.(*arm.HttpScaleRule)
		result.Http = &http
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Tcp":
	if rule.Tcp != nil {
		tcp_ARM, err := (*rule.Tcp).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tcp := *tcp_ARM.(*arm.TcpScaleRule)
		result.Tcp = &tcp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ScaleRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ScaleRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleRule, got %T", armInput)
	}

	// Set property "AzureQueue":
	if typedInput.AzureQueue != nil {
		var azureQueue1 QueueScaleRule
		err := azureQueue1.PopulateFromARM(owner, *typedInput.AzureQueue)
		if err != nil {
			return err
		}
		azureQueue := azureQueue1
		rule.AzureQueue = &azureQueue
	}

	// Set property "Custom":
	if typedInput.Custom != nil {
		var custom1 CustomScaleRule
		err := custom1.PopulateFromARM(owner, *typedInput.Custom)
		if err != nil {
			return err
		}
		custom := custom1
		rule.Custom = &custom
	}

	// Set property "Http":
	if typedInput.Http != nil {
		var http1 HttpScaleRule
		err := http1.PopulateFromARM(owner, *typedInput.Http)
		if err != nil {
			return err
		}
		http := http1
		rule.Http = &http
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Tcp":
	if typedInput.Tcp != nil {
		var tcp1 TcpScaleRule
		err := tcp1.PopulateFromARM(owner, *typedInput.Tcp)
		if err != nil {
			return err
		}
		tcp := tcp1
		rule.Tcp = &tcp
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleRule populates our ScaleRule from the provided source ScaleRule
func (rule *ScaleRule) AssignProperties_From_ScaleRule(source *storage.ScaleRule) error {

	// AzureQueue
	if source.AzureQueue != nil {
		var azureQueue QueueScaleRule
		err := azureQueue.AssignProperties_From_QueueScaleRule(source.AzureQueue)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_QueueScaleRule() to populate field AzureQueue")
		}
		rule.AzureQueue = &azureQueue
	} else {
		rule.AzureQueue = nil
	}

	// Custom
	if source.Custom != nil {
		var custom CustomScaleRule
		err := custom.AssignProperties_From_CustomScaleRule(source.Custom)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomScaleRule() to populate field Custom")
		}
		rule.Custom = &custom
	} else {
		rule.Custom = nil
	}

	// Http
	if source.Http != nil {
		var http HttpScaleRule
		err := http.AssignProperties_From_HttpScaleRule(source.Http)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpScaleRule() to populate field Http")
		}
		rule.Http = &http
	} else {
		rule.Http = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Tcp
	if source.Tcp != nil {
		var tcp TcpScaleRule
		err := tcp.AssignProperties_From_TcpScaleRule(source.Tcp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TcpScaleRule() to populate field Tcp")
		}
		rule.Tcp = &tcp
	} else {
		rule.Tcp = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleRule populates the provided destination ScaleRule from our ScaleRule
func (rule *ScaleRule) AssignProperties_To_ScaleRule(destination *storage.ScaleRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureQueue
	if rule.AzureQueue != nil {
		var azureQueue storage.QueueScaleRule
		err := rule.AzureQueue.AssignProperties_To_QueueScaleRule(&azureQueue)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_QueueScaleRule() to populate field AzureQueue")
		}
		destination.AzureQueue = &azureQueue
	} else {
		destination.AzureQueue = nil
	}

	// Custom
	if rule.Custom != nil {
		var custom storage.CustomScaleRule
		err := rule.Custom.AssignProperties_To_CustomScaleRule(&custom)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomScaleRule() to populate field Custom")
		}
		destination.Custom = &custom
	} else {
		destination.Custom = nil
	}

	// Http
	if rule.Http != nil {
		var http storage.HttpScaleRule
		err := rule.Http.AssignProperties_To_HttpScaleRule(&http)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpScaleRule() to populate field Http")
		}
		destination.Http = &http
	} else {
		destination.Http = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Tcp
	if rule.Tcp != nil {
		var tcp storage.TcpScaleRule
		err := rule.Tcp.AssignProperties_To_TcpScaleRule(&tcp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TcpScaleRule() to populate field Tcp")
		}
		destination.Tcp = &tcp
	} else {
		destination.Tcp = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScaleRule_STATUS populates our ScaleRule from the provided source ScaleRule_STATUS
func (rule *ScaleRule) Initialize_From_ScaleRule_STATUS(source *ScaleRule_STATUS) error {

	// AzureQueue
	if source.AzureQueue != nil {
		var azureQueue QueueScaleRule
		err := azureQueue.Initialize_From_QueueScaleRule_STATUS(source.AzureQueue)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_QueueScaleRule_STATUS() to populate field AzureQueue")
		}
		rule.AzureQueue = &azureQueue
	} else {
		rule.AzureQueue = nil
	}

	// Custom
	if source.Custom != nil {
		var custom CustomScaleRule
		err := custom.Initialize_From_CustomScaleRule_STATUS(source.Custom)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_CustomScaleRule_STATUS() to populate field Custom")
		}
		rule.Custom = &custom
	} else {
		rule.Custom = nil
	}

	// Http
	if source.Http != nil {
		var http HttpScaleRule
		err := http.Initialize_From_HttpScaleRule_STATUS(source.Http)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_HttpScaleRule_STATUS() to populate field Http")
		}
		rule.Http = &http
	} else {
		rule.Http = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Tcp
	if source.Tcp != nil {
		var tcp TcpScaleRule
		err := tcp.Initialize_From_TcpScaleRule_STATUS(source.Tcp)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_TcpScaleRule_STATUS() to populate field Tcp")
		}
		rule.Tcp = &tcp
	} else {
		rule.Tcp = nil
	}

	// No error
	return nil
}

// Container App container scaling rule.
type ScaleRule_STATUS struct {
	// AzureQueue: Azure Queue based scaling.
	AzureQueue *QueueScaleRule_STATUS `json:"azureQueue,omitempty"`

	// Custom: Custom scale rule.
	Custom *CustomScaleRule_STATUS `json:"custom,omitempty"`

	// Http: HTTP requests based scaling.
	Http *HttpScaleRule_STATUS `json:"http,omitempty"`

	// Name: Scale Rule Name
	Name *string `json:"name,omitempty"`

	// Tcp: Tcp requests based scaling.
	Tcp *TcpScaleRule_STATUS `json:"tcp,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ScaleRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ScaleRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleRule_STATUS, got %T", armInput)
	}

	// Set property "AzureQueue":
	if typedInput.AzureQueue != nil {
		var azureQueue1 QueueScaleRule_STATUS
		err := azureQueue1.PopulateFromARM(owner, *typedInput.AzureQueue)
		if err != nil {
			return err
		}
		azureQueue := azureQueue1
		rule.AzureQueue = &azureQueue
	}

	// Set property "Custom":
	if typedInput.Custom != nil {
		var custom1 CustomScaleRule_STATUS
		err := custom1.PopulateFromARM(owner, *typedInput.Custom)
		if err != nil {
			return err
		}
		custom := custom1
		rule.Custom = &custom
	}

	// Set property "Http":
	if typedInput.Http != nil {
		var http1 HttpScaleRule_STATUS
		err := http1.PopulateFromARM(owner, *typedInput.Http)
		if err != nil {
			return err
		}
		http := http1
		rule.Http = &http
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Tcp":
	if typedInput.Tcp != nil {
		var tcp1 TcpScaleRule_STATUS
		err := tcp1.PopulateFromARM(owner, *typedInput.Tcp)
		if err != nil {
			return err
		}
		tcp := tcp1
		rule.Tcp = &tcp
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleRule_STATUS populates our ScaleRule_STATUS from the provided source ScaleRule_STATUS
func (rule *ScaleRule_STATUS) AssignProperties_From_ScaleRule_STATUS(source *storage.ScaleRule_STATUS) error {

	// AzureQueue
	if source.AzureQueue != nil {
		var azureQueue QueueScaleRule_STATUS
		err := azureQueue.AssignProperties_From_QueueScaleRule_STATUS(source.AzureQueue)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_QueueScaleRule_STATUS() to populate field AzureQueue")
		}
		rule.AzureQueue = &azureQueue
	} else {
		rule.AzureQueue = nil
	}

	// Custom
	if source.Custom != nil {
		var custom CustomScaleRule_STATUS
		err := custom.AssignProperties_From_CustomScaleRule_STATUS(source.Custom)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomScaleRule_STATUS() to populate field Custom")
		}
		rule.Custom = &custom
	} else {
		rule.Custom = nil
	}

	// Http
	if source.Http != nil {
		var http HttpScaleRule_STATUS
		err := http.AssignProperties_From_HttpScaleRule_STATUS(source.Http)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HttpScaleRule_STATUS() to populate field Http")
		}
		rule.Http = &http
	} else {
		rule.Http = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Tcp
	if source.Tcp != nil {
		var tcp TcpScaleRule_STATUS
		err := tcp.AssignProperties_From_TcpScaleRule_STATUS(source.Tcp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TcpScaleRule_STATUS() to populate field Tcp")
		}
		rule.Tcp = &tcp
	} else {
		rule.Tcp = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleRule_STATUS populates the provided destination ScaleRule_STATUS from our ScaleRule_STATUS
func (rule *ScaleRule_STATUS) AssignProperties_To_ScaleRule_STATUS(destination *storage.ScaleRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureQueue
	if rule.AzureQueue != nil {
		var azureQueue storage.QueueScaleRule_STATUS
		err := rule.AzureQueue.AssignProperties_To_QueueScaleRule_STATUS(&azureQueue)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_QueueScaleRule_STATUS() to populate field AzureQueue")
		}
		destination.AzureQueue = &azureQueue
	} else {
		destination.AzureQueue = nil
	}

	// Custom
	if rule.Custom != nil {
		var custom storage.CustomScaleRule_STATUS
		err := rule.Custom.AssignProperties_To_CustomScaleRule_STATUS(&custom)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomScaleRule_STATUS() to populate field Custom")
		}
		destination.Custom = &custom
	} else {
		destination.Custom = nil
	}

	// Http
	if rule.Http != nil {
		var http storage.HttpScaleRule_STATUS
		err := rule.Http.AssignProperties_To_HttpScaleRule_STATUS(&http)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HttpScaleRule_STATUS() to populate field Http")
		}
		destination.Http = &http
	} else {
		destination.Http = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Tcp
	if rule.Tcp != nil {
		var tcp storage.TcpScaleRule_STATUS
		err := rule.Tcp.AssignProperties_To_TcpScaleRule_STATUS(&tcp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TcpScaleRule_STATUS() to populate field Tcp")
		}
		destination.Tcp = &tcp
	} else {
		destination.Tcp = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Secret to be added to volume.
type SecretVolumeItem struct {
	// Path: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
	Path *string `json:"path,omitempty"`

	// SecretRef: Name of the Container App secret from which to pull the secret value.
	SecretRef *string `json:"secretRef,omitempty"`
}

var _ genruntime.ARMTransformer = &SecretVolumeItem{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (item *SecretVolumeItem) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if item == nil {
		return nil, nil
	}
	result := &arm.SecretVolumeItem{}

	// Set property "Path":
	if item.Path != nil {
		path := *item.Path
		result.Path = &path
	}

	// Set property "SecretRef":
	if item.SecretRef != nil {
		secretRef := *item.SecretRef
		result.SecretRef = &secretRef
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *SecretVolumeItem) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecretVolumeItem{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *SecretVolumeItem) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecretVolumeItem)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecretVolumeItem, got %T", armInput)
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		item.Path = &path
	}

	// Set property "SecretRef":
	if typedInput.SecretRef != nil {
		secretRef := *typedInput.SecretRef
		item.SecretRef = &secretRef
	}

	// No error
	return nil
}

// AssignProperties_From_SecretVolumeItem populates our SecretVolumeItem from the provided source SecretVolumeItem
func (item *SecretVolumeItem) AssignProperties_From_SecretVolumeItem(source *storage.SecretVolumeItem) error {

	// Path
	item.Path = genruntime.ClonePointerToString(source.Path)

	// SecretRef
	item.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// No error
	return nil
}

// AssignProperties_To_SecretVolumeItem populates the provided destination SecretVolumeItem from our SecretVolumeItem
func (item *SecretVolumeItem) AssignProperties_To_SecretVolumeItem(destination *storage.SecretVolumeItem) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Path
	destination.Path = genruntime.ClonePointerToString(item.Path)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(item.SecretRef)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SecretVolumeItem_STATUS populates our SecretVolumeItem from the provided source SecretVolumeItem_STATUS
func (item *SecretVolumeItem) Initialize_From_SecretVolumeItem_STATUS(source *SecretVolumeItem_STATUS) error {

	// Path
	item.Path = genruntime.ClonePointerToString(source.Path)

	// SecretRef
	item.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// No error
	return nil
}

// Secret to be added to volume.
type SecretVolumeItem_STATUS struct {
	// Path: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
	Path *string `json:"path,omitempty"`

	// SecretRef: Name of the Container App secret from which to pull the secret value.
	SecretRef *string `json:"secretRef,omitempty"`
}

var _ genruntime.FromARMConverter = &SecretVolumeItem_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *SecretVolumeItem_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecretVolumeItem_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *SecretVolumeItem_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecretVolumeItem_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecretVolumeItem_STATUS, got %T", armInput)
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		item.Path = &path
	}

	// Set property "SecretRef":
	if typedInput.SecretRef != nil {
		secretRef := *typedInput.SecretRef
		item.SecretRef = &secretRef
	}

	// No error
	return nil
}

// AssignProperties_From_SecretVolumeItem_STATUS populates our SecretVolumeItem_STATUS from the provided source SecretVolumeItem_STATUS
func (item *SecretVolumeItem_STATUS) AssignProperties_From_SecretVolumeItem_STATUS(source *storage.SecretVolumeItem_STATUS) error {

	// Path
	item.Path = genruntime.ClonePointerToString(source.Path)

	// SecretRef
	item.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// No error
	return nil
}

// AssignProperties_To_SecretVolumeItem_STATUS populates the provided destination SecretVolumeItem_STATUS from our SecretVolumeItem_STATUS
func (item *SecretVolumeItem_STATUS) AssignProperties_To_SecretVolumeItem_STATUS(destination *storage.SecretVolumeItem_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Path
	destination.Path = genruntime.ClonePointerToString(item.Path)

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(item.SecretRef)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Traffic weight assigned to a revision
type TrafficWeight struct {
	// Label: Associates a traffic label with a revision
	Label *string `json:"label,omitempty"`

	// LatestRevision: Indicates that the traffic weight belongs to a latest stable revision
	LatestRevision *bool `json:"latestRevision,omitempty"`

	// RevisionName: Name of a revision
	RevisionName *string `json:"revisionName,omitempty"`

	// Weight: Traffic weight assigned to a revision
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ARMTransformer = &TrafficWeight{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (weight *TrafficWeight) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if weight == nil {
		return nil, nil
	}
	result := &arm.TrafficWeight{}

	// Set property "Label":
	if weight.Label != nil {
		label := *weight.Label
		result.Label = &label
	}

	// Set property "LatestRevision":
	if weight.LatestRevision != nil {
		latestRevision := *weight.LatestRevision
		result.LatestRevision = &latestRevision
	}

	// Set property "RevisionName":
	if weight.RevisionName != nil {
		revisionName := *weight.RevisionName
		result.RevisionName = &revisionName
	}

	// Set property "Weight":
	if weight.Weight != nil {
		weight1 := *weight.Weight
		result.Weight = &weight1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (weight *TrafficWeight) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficWeight{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (weight *TrafficWeight) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficWeight)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficWeight, got %T", armInput)
	}

	// Set property "Label":
	if typedInput.Label != nil {
		label := *typedInput.Label
		weight.Label = &label
	}

	// Set property "LatestRevision":
	if typedInput.LatestRevision != nil {
		latestRevision := *typedInput.LatestRevision
		weight.LatestRevision = &latestRevision
	}

	// Set property "RevisionName":
	if typedInput.RevisionName != nil {
		revisionName := *typedInput.RevisionName
		weight.RevisionName = &revisionName
	}

	// Set property "Weight":
	if typedInput.Weight != nil {
		weight1 := *typedInput.Weight
		weight.Weight = &weight1
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficWeight populates our TrafficWeight from the provided source TrafficWeight
func (weight *TrafficWeight) AssignProperties_From_TrafficWeight(source *storage.TrafficWeight) error {

	// Label
	weight.Label = genruntime.ClonePointerToString(source.Label)

	// LatestRevision
	if source.LatestRevision != nil {
		latestRevision := *source.LatestRevision
		weight.LatestRevision = &latestRevision
	} else {
		weight.LatestRevision = nil
	}

	// RevisionName
	weight.RevisionName = genruntime.ClonePointerToString(source.RevisionName)

	// Weight
	weight.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_TrafficWeight populates the provided destination TrafficWeight from our TrafficWeight
func (weight *TrafficWeight) AssignProperties_To_TrafficWeight(destination *storage.TrafficWeight) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Label
	destination.Label = genruntime.ClonePointerToString(weight.Label)

	// LatestRevision
	if weight.LatestRevision != nil {
		latestRevision := *weight.LatestRevision
		destination.LatestRevision = &latestRevision
	} else {
		destination.LatestRevision = nil
	}

	// RevisionName
	destination.RevisionName = genruntime.ClonePointerToString(weight.RevisionName)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(weight.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrafficWeight_STATUS populates our TrafficWeight from the provided source TrafficWeight_STATUS
func (weight *TrafficWeight) Initialize_From_TrafficWeight_STATUS(source *TrafficWeight_STATUS) error {

	// Label
	weight.Label = genruntime.ClonePointerToString(source.Label)

	// LatestRevision
	if source.LatestRevision != nil {
		latestRevision := *source.LatestRevision
		weight.LatestRevision = &latestRevision
	} else {
		weight.LatestRevision = nil
	}

	// RevisionName
	weight.RevisionName = genruntime.ClonePointerToString(source.RevisionName)

	// Weight
	weight.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// Traffic weight assigned to a revision
type TrafficWeight_STATUS struct {
	// Label: Associates a traffic label with a revision
	Label *string `json:"label,omitempty"`

	// LatestRevision: Indicates that the traffic weight belongs to a latest stable revision
	LatestRevision *bool `json:"latestRevision,omitempty"`

	// RevisionName: Name of a revision
	RevisionName *string `json:"revisionName,omitempty"`

	// Weight: Traffic weight assigned to a revision
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.FromARMConverter = &TrafficWeight_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (weight *TrafficWeight_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficWeight_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (weight *TrafficWeight_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficWeight_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficWeight_STATUS, got %T", armInput)
	}

	// Set property "Label":
	if typedInput.Label != nil {
		label := *typedInput.Label
		weight.Label = &label
	}

	// Set property "LatestRevision":
	if typedInput.LatestRevision != nil {
		latestRevision := *typedInput.LatestRevision
		weight.LatestRevision = &latestRevision
	}

	// Set property "RevisionName":
	if typedInput.RevisionName != nil {
		revisionName := *typedInput.RevisionName
		weight.RevisionName = &revisionName
	}

	// Set property "Weight":
	if typedInput.Weight != nil {
		weight1 := *typedInput.Weight
		weight.Weight = &weight1
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficWeight_STATUS populates our TrafficWeight_STATUS from the provided source TrafficWeight_STATUS
func (weight *TrafficWeight_STATUS) AssignProperties_From_TrafficWeight_STATUS(source *storage.TrafficWeight_STATUS) error {

	// Label
	weight.Label = genruntime.ClonePointerToString(source.Label)

	// LatestRevision
	if source.LatestRevision != nil {
		latestRevision := *source.LatestRevision
		weight.LatestRevision = &latestRevision
	} else {
		weight.LatestRevision = nil
	}

	// RevisionName
	weight.RevisionName = genruntime.ClonePointerToString(source.RevisionName)

	// Weight
	weight.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_TrafficWeight_STATUS populates the provided destination TrafficWeight_STATUS from our TrafficWeight_STATUS
func (weight *TrafficWeight_STATUS) AssignProperties_To_TrafficWeight_STATUS(destination *storage.TrafficWeight_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Label
	destination.Label = genruntime.ClonePointerToString(weight.Label)

	// LatestRevision
	if weight.LatestRevision != nil {
		latestRevision := *weight.LatestRevision
		destination.LatestRevision = &latestRevision
	} else {
		destination.LatestRevision = nil
	}

	// RevisionName
	destination.RevisionName = genruntime.ClonePointerToString(weight.RevisionName)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(weight.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AzureFile","EmptyDir","Secret"}
type Volume_StorageType string

const (
	Volume_StorageType_AzureFile = Volume_StorageType("AzureFile")
	Volume_StorageType_EmptyDir  = Volume_StorageType("EmptyDir")
	Volume_StorageType_Secret    = Volume_StorageType("Secret")
)

// Mapping from string to Volume_StorageType
var volume_StorageType_Values = map[string]Volume_StorageType{
	"azurefile": Volume_StorageType_AzureFile,
	"emptydir":  Volume_StorageType_EmptyDir,
	"secret":    Volume_StorageType_Secret,
}

type Volume_StorageType_STATUS string

const (
	Volume_StorageType_STATUS_AzureFile = Volume_StorageType_STATUS("AzureFile")
	Volume_StorageType_STATUS_EmptyDir  = Volume_StorageType_STATUS("EmptyDir")
	Volume_StorageType_STATUS_Secret    = Volume_StorageType_STATUS("Secret")
)

// Mapping from string to Volume_StorageType_STATUS
var volume_StorageType_STATUS_Values = map[string]Volume_StorageType_STATUS{
	"azurefile": Volume_StorageType_STATUS_AzureFile,
	"emptydir":  Volume_StorageType_STATUS_EmptyDir,
	"secret":    Volume_StorageType_STATUS_Secret,
}

// Volume mount for the Container App.
type VolumeMount struct {
	// MountPath: Path within the container at which the volume should be mounted.Must not contain ':'.
	MountPath *string `json:"mountPath,omitempty"`

	// SubPath: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
	SubPath *string `json:"subPath,omitempty"`

	// VolumeName: This must match the Name of a Volume.
	VolumeName *string `json:"volumeName,omitempty"`
}

var _ genruntime.ARMTransformer = &VolumeMount{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mount *VolumeMount) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mount == nil {
		return nil, nil
	}
	result := &arm.VolumeMount{}

	// Set property "MountPath":
	if mount.MountPath != nil {
		mountPath := *mount.MountPath
		result.MountPath = &mountPath
	}

	// Set property "SubPath":
	if mount.SubPath != nil {
		subPath := *mount.SubPath
		result.SubPath = &subPath
	}

	// Set property "VolumeName":
	if mount.VolumeName != nil {
		volumeName := *mount.VolumeName
		result.VolumeName = &volumeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *VolumeMount) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VolumeMount{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *VolumeMount) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VolumeMount)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VolumeMount, got %T", armInput)
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property "SubPath":
	if typedInput.SubPath != nil {
		subPath := *typedInput.SubPath
		mount.SubPath = &subPath
	}

	// Set property "VolumeName":
	if typedInput.VolumeName != nil {
		volumeName := *typedInput.VolumeName
		mount.VolumeName = &volumeName
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeMount populates our VolumeMount from the provided source VolumeMount
func (mount *VolumeMount) AssignProperties_From_VolumeMount(source *storage.VolumeMount) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// SubPath
	mount.SubPath = genruntime.ClonePointerToString(source.SubPath)

	// VolumeName
	mount.VolumeName = genruntime.ClonePointerToString(source.VolumeName)

	// No error
	return nil
}

// AssignProperties_To_VolumeMount populates the provided destination VolumeMount from our VolumeMount
func (mount *VolumeMount) AssignProperties_To_VolumeMount(destination *storage.VolumeMount) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// SubPath
	destination.SubPath = genruntime.ClonePointerToString(mount.SubPath)

	// VolumeName
	destination.VolumeName = genruntime.ClonePointerToString(mount.VolumeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VolumeMount_STATUS populates our VolumeMount from the provided source VolumeMount_STATUS
func (mount *VolumeMount) Initialize_From_VolumeMount_STATUS(source *VolumeMount_STATUS) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// SubPath
	mount.SubPath = genruntime.ClonePointerToString(source.SubPath)

	// VolumeName
	mount.VolumeName = genruntime.ClonePointerToString(source.VolumeName)

	// No error
	return nil
}

// Volume mount for the Container App.
type VolumeMount_STATUS struct {
	// MountPath: Path within the container at which the volume should be mounted.Must not contain ':'.
	MountPath *string `json:"mountPath,omitempty"`

	// SubPath: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
	SubPath *string `json:"subPath,omitempty"`

	// VolumeName: This must match the Name of a Volume.
	VolumeName *string `json:"volumeName,omitempty"`
}

var _ genruntime.FromARMConverter = &VolumeMount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *VolumeMount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VolumeMount_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *VolumeMount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VolumeMount_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VolumeMount_STATUS, got %T", armInput)
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property "SubPath":
	if typedInput.SubPath != nil {
		subPath := *typedInput.SubPath
		mount.SubPath = &subPath
	}

	// Set property "VolumeName":
	if typedInput.VolumeName != nil {
		volumeName := *typedInput.VolumeName
		mount.VolumeName = &volumeName
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeMount_STATUS populates our VolumeMount_STATUS from the provided source VolumeMount_STATUS
func (mount *VolumeMount_STATUS) AssignProperties_From_VolumeMount_STATUS(source *storage.VolumeMount_STATUS) error {

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// SubPath
	mount.SubPath = genruntime.ClonePointerToString(source.SubPath)

	// VolumeName
	mount.VolumeName = genruntime.ClonePointerToString(source.VolumeName)

	// No error
	return nil
}

// AssignProperties_To_VolumeMount_STATUS populates the provided destination VolumeMount_STATUS from our VolumeMount_STATUS
func (mount *VolumeMount_STATUS) AssignProperties_To_VolumeMount_STATUS(destination *storage.VolumeMount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// SubPath
	destination.SubPath = genruntime.ClonePointerToString(mount.SubPath)

	// VolumeName
	destination.VolumeName = genruntime.ClonePointerToString(mount.VolumeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerAppProbe_HttpGet struct {
	// Host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
	Host *string `json:"host,omitempty"`

	// HttpHeaders: Custom headers to set in the request. HTTP allows repeated headers.
	HttpHeaders []ContainerAppProbe_HttpGet_HttpHeaders `json:"httpHeaders,omitempty"`

	// Path: Path to access on the HTTP server.
	Path *string `json:"path,omitempty"`

	// +kubebuilder:validation:Required
	// Port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an
	// IANA_SVC_NAME.
	Port *int `json:"port,omitempty"`

	// Scheme: Scheme to use for connecting to the host. Defaults to HTTP.
	Scheme *ContainerAppProbe_HttpGet_Scheme `json:"scheme,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerAppProbe_HttpGet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (httpGet *ContainerAppProbe_HttpGet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if httpGet == nil {
		return nil, nil
	}
	result := &arm.ContainerAppProbe_HttpGet{}

	// Set property "Host":
	if httpGet.Host != nil {
		host := *httpGet.Host
		result.Host = &host
	}

	// Set property "HttpHeaders":
	for _, item := range httpGet.HttpHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HttpHeaders = append(result.HttpHeaders, *item_ARM.(*arm.ContainerAppProbe_HttpGet_HttpHeaders))
	}

	// Set property "Path":
	if httpGet.Path != nil {
		path := *httpGet.Path
		result.Path = &path
	}

	// Set property "Port":
	if httpGet.Port != nil {
		port := *httpGet.Port
		result.Port = &port
	}

	// Set property "Scheme":
	if httpGet.Scheme != nil {
		var temp string
		temp = string(*httpGet.Scheme)
		scheme := arm.ContainerAppProbe_HttpGet_Scheme(temp)
		result.Scheme = &scheme
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (httpGet *ContainerAppProbe_HttpGet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerAppProbe_HttpGet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (httpGet *ContainerAppProbe_HttpGet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerAppProbe_HttpGet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerAppProbe_HttpGet, got %T", armInput)
	}

	// Set property "Host":
	if typedInput.Host != nil {
		host := *typedInput.Host
		httpGet.Host = &host
	}

	// Set property "HttpHeaders":
	for _, item := range typedInput.HttpHeaders {
		var item1 ContainerAppProbe_HttpGet_HttpHeaders
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		httpGet.HttpHeaders = append(httpGet.HttpHeaders, item1)
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		httpGet.Path = &path
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		httpGet.Port = &port
	}

	// Set property "Scheme":
	if typedInput.Scheme != nil {
		var temp string
		temp = string(*typedInput.Scheme)
		scheme := ContainerAppProbe_HttpGet_Scheme(temp)
		httpGet.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerAppProbe_HttpGet populates our ContainerAppProbe_HttpGet from the provided source ContainerAppProbe_HttpGet
func (httpGet *ContainerAppProbe_HttpGet) AssignProperties_From_ContainerAppProbe_HttpGet(source *storage.ContainerAppProbe_HttpGet) error {

	// Host
	httpGet.Host = genruntime.ClonePointerToString(source.Host)

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]ContainerAppProbe_HttpGet_HttpHeaders, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader ContainerAppProbe_HttpGet_HttpHeaders
			err := httpHeader.AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders(&httpHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := *source.Scheme
		schemeTemp := genruntime.ToEnum(scheme, containerAppProbe_HttpGet_Scheme_Values)
		httpGet.Scheme = &schemeTemp
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_HttpGet populates the provided destination ContainerAppProbe_HttpGet from our ContainerAppProbe_HttpGet
func (httpGet *ContainerAppProbe_HttpGet) AssignProperties_To_ContainerAppProbe_HttpGet(destination *storage.ContainerAppProbe_HttpGet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Host
	destination.Host = genruntime.ClonePointerToString(httpGet.Host)

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]storage.ContainerAppProbe_HttpGet_HttpHeaders, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader storage.ContainerAppProbe_HttpGet_HttpHeaders
			err := httpHeaderItem.AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders(&httpHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	if httpGet.Scheme != nil {
		scheme := string(*httpGet.Scheme)
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerAppProbe_HttpGet_STATUS populates our ContainerAppProbe_HttpGet from the provided source ContainerAppProbe_HttpGet_STATUS
func (httpGet *ContainerAppProbe_HttpGet) Initialize_From_ContainerAppProbe_HttpGet_STATUS(source *ContainerAppProbe_HttpGet_STATUS) error {

	// Host
	httpGet.Host = genruntime.ClonePointerToString(source.Host)

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]ContainerAppProbe_HttpGet_HttpHeaders, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader ContainerAppProbe_HttpGet_HttpHeaders
			err := httpHeader.Initialize_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(&httpHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := genruntime.ToEnum(string(*source.Scheme), containerAppProbe_HttpGet_Scheme_Values)
		httpGet.Scheme = &scheme
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

type ContainerAppProbe_HttpGet_STATUS struct {
	// Host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
	Host *string `json:"host,omitempty"`

	// HttpHeaders: Custom headers to set in the request. HTTP allows repeated headers.
	HttpHeaders []ContainerAppProbe_HttpGet_HttpHeaders_STATUS `json:"httpHeaders,omitempty"`

	// Path: Path to access on the HTTP server.
	Path *string `json:"path,omitempty"`

	// Port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an
	// IANA_SVC_NAME.
	Port *int `json:"port,omitempty"`

	// Scheme: Scheme to use for connecting to the host. Defaults to HTTP.
	Scheme *ContainerAppProbe_HttpGet_Scheme_STATUS `json:"scheme,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerAppProbe_HttpGet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (httpGet *ContainerAppProbe_HttpGet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerAppProbe_HttpGet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (httpGet *ContainerAppProbe_HttpGet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerAppProbe_HttpGet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerAppProbe_HttpGet_STATUS, got %T", armInput)
	}

	// Set property "Host":
	if typedInput.Host != nil {
		host := *typedInput.Host
		httpGet.Host = &host
	}

	// Set property "HttpHeaders":
	for _, item := range typedInput.HttpHeaders {
		var item1 ContainerAppProbe_HttpGet_HttpHeaders_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		httpGet.HttpHeaders = append(httpGet.HttpHeaders, item1)
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		httpGet.Path = &path
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		httpGet.Port = &port
	}

	// Set property "Scheme":
	if typedInput.Scheme != nil {
		var temp string
		temp = string(*typedInput.Scheme)
		scheme := ContainerAppProbe_HttpGet_Scheme_STATUS(temp)
		httpGet.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerAppProbe_HttpGet_STATUS populates our ContainerAppProbe_HttpGet_STATUS from the provided source ContainerAppProbe_HttpGet_STATUS
func (httpGet *ContainerAppProbe_HttpGet_STATUS) AssignProperties_From_ContainerAppProbe_HttpGet_STATUS(source *storage.ContainerAppProbe_HttpGet_STATUS) error {

	// Host
	httpGet.Host = genruntime.ClonePointerToString(source.Host)

	// HttpHeaders
	if source.HttpHeaders != nil {
		httpHeaderList := make([]ContainerAppProbe_HttpGet_HttpHeaders_STATUS, len(source.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range source.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader ContainerAppProbe_HttpGet_HttpHeaders_STATUS
			err := httpHeader.AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(&httpHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		httpGet.HttpHeaders = httpHeaderList
	} else {
		httpGet.HttpHeaders = nil
	}

	// Path
	httpGet.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	httpGet.Port = genruntime.ClonePointerToInt(source.Port)

	// Scheme
	if source.Scheme != nil {
		scheme := *source.Scheme
		schemeTemp := genruntime.ToEnum(scheme, containerAppProbe_HttpGet_Scheme_STATUS_Values)
		httpGet.Scheme = &schemeTemp
	} else {
		httpGet.Scheme = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_HttpGet_STATUS populates the provided destination ContainerAppProbe_HttpGet_STATUS from our ContainerAppProbe_HttpGet_STATUS
func (httpGet *ContainerAppProbe_HttpGet_STATUS) AssignProperties_To_ContainerAppProbe_HttpGet_STATUS(destination *storage.ContainerAppProbe_HttpGet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Host
	destination.Host = genruntime.ClonePointerToString(httpGet.Host)

	// HttpHeaders
	if httpGet.HttpHeaders != nil {
		httpHeaderList := make([]storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS, len(httpGet.HttpHeaders))
		for httpHeaderIndex, httpHeaderItem := range httpGet.HttpHeaders {
			// Shadow the loop variable to avoid aliasing
			httpHeaderItem := httpHeaderItem
			var httpHeader storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS
			err := httpHeaderItem.AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(&httpHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS() to populate field HttpHeaders")
			}
			httpHeaderList[httpHeaderIndex] = httpHeader
		}
		destination.HttpHeaders = httpHeaderList
	} else {
		destination.HttpHeaders = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(httpGet.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(httpGet.Port)

	// Scheme
	if httpGet.Scheme != nil {
		scheme := string(*httpGet.Scheme)
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerAppProbe_TcpSocket struct {
	// Host: Optional: Host name to connect to, defaults to the pod IP.
	Host *string `json:"host,omitempty"`

	// +kubebuilder:validation:Required
	// Port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an
	// IANA_SVC_NAME.
	Port *int `json:"port,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerAppProbe_TcpSocket{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (socket *ContainerAppProbe_TcpSocket) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if socket == nil {
		return nil, nil
	}
	result := &arm.ContainerAppProbe_TcpSocket{}

	// Set property "Host":
	if socket.Host != nil {
		host := *socket.Host
		result.Host = &host
	}

	// Set property "Port":
	if socket.Port != nil {
		port := *socket.Port
		result.Port = &port
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (socket *ContainerAppProbe_TcpSocket) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerAppProbe_TcpSocket{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (socket *ContainerAppProbe_TcpSocket) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerAppProbe_TcpSocket)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerAppProbe_TcpSocket, got %T", armInput)
	}

	// Set property "Host":
	if typedInput.Host != nil {
		host := *typedInput.Host
		socket.Host = &host
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		socket.Port = &port
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerAppProbe_TcpSocket populates our ContainerAppProbe_TcpSocket from the provided source ContainerAppProbe_TcpSocket
func (socket *ContainerAppProbe_TcpSocket) AssignProperties_From_ContainerAppProbe_TcpSocket(source *storage.ContainerAppProbe_TcpSocket) error {

	// Host
	socket.Host = genruntime.ClonePointerToString(source.Host)

	// Port
	socket.Port = genruntime.ClonePointerToInt(source.Port)

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_TcpSocket populates the provided destination ContainerAppProbe_TcpSocket from our ContainerAppProbe_TcpSocket
func (socket *ContainerAppProbe_TcpSocket) AssignProperties_To_ContainerAppProbe_TcpSocket(destination *storage.ContainerAppProbe_TcpSocket) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Host
	destination.Host = genruntime.ClonePointerToString(socket.Host)

	// Port
	destination.Port = genruntime.ClonePointerToInt(socket.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerAppProbe_TcpSocket_STATUS populates our ContainerAppProbe_TcpSocket from the provided source ContainerAppProbe_TcpSocket_STATUS
func (socket *ContainerAppProbe_TcpSocket) Initialize_From_ContainerAppProbe_TcpSocket_STATUS(source *ContainerAppProbe_TcpSocket_STATUS) error {

	// Host
	socket.Host = genruntime.ClonePointerToString(source.Host)

	// Port
	socket.Port = genruntime.ClonePointerToInt(source.Port)

	// No error
	return nil
}

type ContainerAppProbe_TcpSocket_STATUS struct {
	// Host: Optional: Host name to connect to, defaults to the pod IP.
	Host *string `json:"host,omitempty"`

	// Port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an
	// IANA_SVC_NAME.
	Port *int `json:"port,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerAppProbe_TcpSocket_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (socket *ContainerAppProbe_TcpSocket_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerAppProbe_TcpSocket_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (socket *ContainerAppProbe_TcpSocket_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerAppProbe_TcpSocket_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerAppProbe_TcpSocket_STATUS, got %T", armInput)
	}

	// Set property "Host":
	if typedInput.Host != nil {
		host := *typedInput.Host
		socket.Host = &host
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		socket.Port = &port
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS populates our ContainerAppProbe_TcpSocket_STATUS from the provided source ContainerAppProbe_TcpSocket_STATUS
func (socket *ContainerAppProbe_TcpSocket_STATUS) AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS(source *storage.ContainerAppProbe_TcpSocket_STATUS) error {

	// Host
	socket.Host = genruntime.ClonePointerToString(source.Host)

	// Port
	socket.Port = genruntime.ClonePointerToInt(source.Port)

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS populates the provided destination ContainerAppProbe_TcpSocket_STATUS from our ContainerAppProbe_TcpSocket_STATUS
func (socket *ContainerAppProbe_TcpSocket_STATUS) AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS(destination *storage.ContainerAppProbe_TcpSocket_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Host
	destination.Host = genruntime.ClonePointerToString(socket.Host)

	// Port
	destination.Port = genruntime.ClonePointerToInt(socket.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Liveness","Readiness","Startup"}
type ContainerAppProbe_Type string

const (
	ContainerAppProbe_Type_Liveness  = ContainerAppProbe_Type("Liveness")
	ContainerAppProbe_Type_Readiness = ContainerAppProbe_Type("Readiness")
	ContainerAppProbe_Type_Startup   = ContainerAppProbe_Type("Startup")
)

// Mapping from string to ContainerAppProbe_Type
var containerAppProbe_Type_Values = map[string]ContainerAppProbe_Type{
	"liveness":  ContainerAppProbe_Type_Liveness,
	"readiness": ContainerAppProbe_Type_Readiness,
	"startup":   ContainerAppProbe_Type_Startup,
}

type ContainerAppProbe_Type_STATUS string

const (
	ContainerAppProbe_Type_STATUS_Liveness  = ContainerAppProbe_Type_STATUS("Liveness")
	ContainerAppProbe_Type_STATUS_Readiness = ContainerAppProbe_Type_STATUS("Readiness")
	ContainerAppProbe_Type_STATUS_Startup   = ContainerAppProbe_Type_STATUS("Startup")
)

// Mapping from string to ContainerAppProbe_Type_STATUS
var containerAppProbe_Type_STATUS_Values = map[string]ContainerAppProbe_Type_STATUS{
	"liveness":  ContainerAppProbe_Type_STATUS_Liveness,
	"readiness": ContainerAppProbe_Type_STATUS_Readiness,
	"startup":   ContainerAppProbe_Type_STATUS_Startup,
}

// +kubebuilder:validation:Enum={"Disabled","SniEnabled"}
type CustomDomain_BindingType string

const (
	CustomDomain_BindingType_Disabled   = CustomDomain_BindingType("Disabled")
	CustomDomain_BindingType_SniEnabled = CustomDomain_BindingType("SniEnabled")
)

// Mapping from string to CustomDomain_BindingType
var customDomain_BindingType_Values = map[string]CustomDomain_BindingType{
	"disabled":   CustomDomain_BindingType_Disabled,
	"snienabled": CustomDomain_BindingType_SniEnabled,
}

type CustomDomain_BindingType_STATUS string

const (
	CustomDomain_BindingType_STATUS_Disabled   = CustomDomain_BindingType_STATUS("Disabled")
	CustomDomain_BindingType_STATUS_SniEnabled = CustomDomain_BindingType_STATUS("SniEnabled")
)

// Mapping from string to CustomDomain_BindingType_STATUS
var customDomain_BindingType_STATUS_Values = map[string]CustomDomain_BindingType_STATUS{
	"disabled":   CustomDomain_BindingType_STATUS_Disabled,
	"snienabled": CustomDomain_BindingType_STATUS_SniEnabled,
}

// Container App container Custom scaling rule.
type CustomScaleRule struct {
	// Auth: Authentication secrets for the custom scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe custom scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`

	// Type: Type of the custom scale rule
	// eg: azure-servicebus, redis etc.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomScaleRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *CustomScaleRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.CustomScaleRule{}

	// Set property "Auth":
	for _, item := range rule.Auth {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Auth = append(result.Auth, *item_ARM.(*arm.ScaleRuleAuth))
	}

	// Set property "Metadata":
	if rule.Metadata != nil {
		result.Metadata = make(map[string]string, len(rule.Metadata))
		for key, value := range rule.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "Type":
	if rule.Type != nil {
		typeVar := *rule.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *CustomScaleRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomScaleRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *CustomScaleRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomScaleRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomScaleRule, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		rule.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			rule.Metadata[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_CustomScaleRule populates our CustomScaleRule from the provided source CustomScaleRule
func (rule *CustomScaleRule) AssignProperties_From_CustomScaleRule(source *storage.CustomScaleRule) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_CustomScaleRule populates the provided destination CustomScaleRule from our CustomScaleRule
func (rule *CustomScaleRule) AssignProperties_To_CustomScaleRule(destination *storage.CustomScaleRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomScaleRule_STATUS populates our CustomScaleRule from the provided source CustomScaleRule_STATUS
func (rule *CustomScaleRule) Initialize_From_CustomScaleRule_STATUS(source *CustomScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.Initialize_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// Container App container Custom scaling rule.
type CustomScaleRule_STATUS struct {
	// Auth: Authentication secrets for the custom scale rule.
	Auth []ScaleRuleAuth_STATUS `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe custom scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`

	// Type: Type of the custom scale rule
	// eg: azure-servicebus, redis etc.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomScaleRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *CustomScaleRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomScaleRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *CustomScaleRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomScaleRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomScaleRule_STATUS, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		rule.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			rule.Metadata[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_CustomScaleRule_STATUS populates our CustomScaleRule_STATUS from the provided source CustomScaleRule_STATUS
func (rule *CustomScaleRule_STATUS) AssignProperties_From_CustomScaleRule_STATUS(source *storage.CustomScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_CustomScaleRule_STATUS populates the provided destination CustomScaleRule_STATUS from our CustomScaleRule_STATUS
func (rule *CustomScaleRule_STATUS) AssignProperties_To_CustomScaleRule_STATUS(destination *storage.CustomScaleRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App container Http scaling rule.
type HttpScaleRule struct {
	// Auth: Authentication secrets for the custom scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe http scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpScaleRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *HttpScaleRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.HttpScaleRule{}

	// Set property "Auth":
	for _, item := range rule.Auth {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Auth = append(result.Auth, *item_ARM.(*arm.ScaleRuleAuth))
	}

	// Set property "Metadata":
	if rule.Metadata != nil {
		result.Metadata = make(map[string]string, len(rule.Metadata))
		for key, value := range rule.Metadata {
			result.Metadata[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *HttpScaleRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpScaleRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *HttpScaleRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpScaleRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpScaleRule, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		rule.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			rule.Metadata[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_HttpScaleRule populates our HttpScaleRule from the provided source HttpScaleRule
func (rule *HttpScaleRule) AssignProperties_From_HttpScaleRule(source *storage.HttpScaleRule) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// No error
	return nil
}

// AssignProperties_To_HttpScaleRule populates the provided destination HttpScaleRule from our HttpScaleRule
func (rule *HttpScaleRule) AssignProperties_To_HttpScaleRule(destination *storage.HttpScaleRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HttpScaleRule_STATUS populates our HttpScaleRule from the provided source HttpScaleRule_STATUS
func (rule *HttpScaleRule) Initialize_From_HttpScaleRule_STATUS(source *HttpScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.Initialize_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// No error
	return nil
}

// Container App container Http scaling rule.
type HttpScaleRule_STATUS struct {
	// Auth: Authentication secrets for the custom scale rule.
	Auth []ScaleRuleAuth_STATUS `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe http scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpScaleRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *HttpScaleRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpScaleRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *HttpScaleRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpScaleRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpScaleRule_STATUS, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		rule.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			rule.Metadata[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_HttpScaleRule_STATUS populates our HttpScaleRule_STATUS from the provided source HttpScaleRule_STATUS
func (rule *HttpScaleRule_STATUS) AssignProperties_From_HttpScaleRule_STATUS(source *storage.HttpScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// No error
	return nil
}

// AssignProperties_To_HttpScaleRule_STATUS populates the provided destination HttpScaleRule_STATUS from our HttpScaleRule_STATUS
func (rule *HttpScaleRule_STATUS) AssignProperties_To_HttpScaleRule_STATUS(destination *storage.HttpScaleRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"none","sticky"}
type Ingress_StickySessions_Affinity string

const (
	Ingress_StickySessions_Affinity_None   = Ingress_StickySessions_Affinity("none")
	Ingress_StickySessions_Affinity_Sticky = Ingress_StickySessions_Affinity("sticky")
)

// Mapping from string to Ingress_StickySessions_Affinity
var ingress_StickySessions_Affinity_Values = map[string]Ingress_StickySessions_Affinity{
	"none":   Ingress_StickySessions_Affinity_None,
	"sticky": Ingress_StickySessions_Affinity_Sticky,
}

type Ingress_StickySessions_Affinity_STATUS string

const (
	Ingress_StickySessions_Affinity_STATUS_None   = Ingress_StickySessions_Affinity_STATUS("none")
	Ingress_StickySessions_Affinity_STATUS_Sticky = Ingress_StickySessions_Affinity_STATUS("sticky")
)

// Mapping from string to Ingress_StickySessions_Affinity_STATUS
var ingress_StickySessions_Affinity_STATUS_Values = map[string]Ingress_StickySessions_Affinity_STATUS{
	"none":   Ingress_StickySessions_Affinity_STATUS_None,
	"sticky": Ingress_StickySessions_Affinity_STATUS_Sticky,
}

// +kubebuilder:validation:Enum={"Allow","Deny"}
type IpSecurityRestrictionRule_Action string

const (
	IpSecurityRestrictionRule_Action_Allow = IpSecurityRestrictionRule_Action("Allow")
	IpSecurityRestrictionRule_Action_Deny  = IpSecurityRestrictionRule_Action("Deny")
)

// Mapping from string to IpSecurityRestrictionRule_Action
var ipSecurityRestrictionRule_Action_Values = map[string]IpSecurityRestrictionRule_Action{
	"allow": IpSecurityRestrictionRule_Action_Allow,
	"deny":  IpSecurityRestrictionRule_Action_Deny,
}

type IpSecurityRestrictionRule_Action_STATUS string

const (
	IpSecurityRestrictionRule_Action_STATUS_Allow = IpSecurityRestrictionRule_Action_STATUS("Allow")
	IpSecurityRestrictionRule_Action_STATUS_Deny  = IpSecurityRestrictionRule_Action_STATUS("Deny")
)

// Mapping from string to IpSecurityRestrictionRule_Action_STATUS
var ipSecurityRestrictionRule_Action_STATUS_Values = map[string]IpSecurityRestrictionRule_Action_STATUS{
	"allow": IpSecurityRestrictionRule_Action_STATUS_Allow,
	"deny":  IpSecurityRestrictionRule_Action_STATUS_Deny,
}

// Container App container Azure Queue based scaling rule.
type QueueScaleRule struct {
	// Auth: Authentication secrets for the queue scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// QueueLength: Queue length.
	QueueLength *int `json:"queueLength,omitempty"`

	// QueueName: Queue name.
	QueueName *string `json:"queueName,omitempty"`
}

var _ genruntime.ARMTransformer = &QueueScaleRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *QueueScaleRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.QueueScaleRule{}

	// Set property "Auth":
	for _, item := range rule.Auth {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Auth = append(result.Auth, *item_ARM.(*arm.ScaleRuleAuth))
	}

	// Set property "QueueLength":
	if rule.QueueLength != nil {
		queueLength := *rule.QueueLength
		result.QueueLength = &queueLength
	}

	// Set property "QueueName":
	if rule.QueueName != nil {
		queueName := *rule.QueueName
		result.QueueName = &queueName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *QueueScaleRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.QueueScaleRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *QueueScaleRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.QueueScaleRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.QueueScaleRule, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "QueueLength":
	if typedInput.QueueLength != nil {
		queueLength := *typedInput.QueueLength
		rule.QueueLength = &queueLength
	}

	// Set property "QueueName":
	if typedInput.QueueName != nil {
		queueName := *typedInput.QueueName
		rule.QueueName = &queueName
	}

	// No error
	return nil
}

// AssignProperties_From_QueueScaleRule populates our QueueScaleRule from the provided source QueueScaleRule
func (rule *QueueScaleRule) AssignProperties_From_QueueScaleRule(source *storage.QueueScaleRule) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// QueueLength
	rule.QueueLength = genruntime.ClonePointerToInt(source.QueueLength)

	// QueueName
	rule.QueueName = genruntime.ClonePointerToString(source.QueueName)

	// No error
	return nil
}

// AssignProperties_To_QueueScaleRule populates the provided destination QueueScaleRule from our QueueScaleRule
func (rule *QueueScaleRule) AssignProperties_To_QueueScaleRule(destination *storage.QueueScaleRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// QueueLength
	destination.QueueLength = genruntime.ClonePointerToInt(rule.QueueLength)

	// QueueName
	destination.QueueName = genruntime.ClonePointerToString(rule.QueueName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_QueueScaleRule_STATUS populates our QueueScaleRule from the provided source QueueScaleRule_STATUS
func (rule *QueueScaleRule) Initialize_From_QueueScaleRule_STATUS(source *QueueScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.Initialize_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// QueueLength
	rule.QueueLength = genruntime.ClonePointerToInt(source.QueueLength)

	// QueueName
	rule.QueueName = genruntime.ClonePointerToString(source.QueueName)

	// No error
	return nil
}

// Container App container Azure Queue based scaling rule.
type QueueScaleRule_STATUS struct {
	// Auth: Authentication secrets for the queue scale rule.
	Auth []ScaleRuleAuth_STATUS `json:"auth,omitempty"`

	// QueueLength: Queue length.
	QueueLength *int `json:"queueLength,omitempty"`

	// QueueName: Queue name.
	QueueName *string `json:"queueName,omitempty"`
}

var _ genruntime.FromARMConverter = &QueueScaleRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *QueueScaleRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.QueueScaleRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *QueueScaleRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.QueueScaleRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.QueueScaleRule_STATUS, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "QueueLength":
	if typedInput.QueueLength != nil {
		queueLength := *typedInput.QueueLength
		rule.QueueLength = &queueLength
	}

	// Set property "QueueName":
	if typedInput.QueueName != nil {
		queueName := *typedInput.QueueName
		rule.QueueName = &queueName
	}

	// No error
	return nil
}

// AssignProperties_From_QueueScaleRule_STATUS populates our QueueScaleRule_STATUS from the provided source QueueScaleRule_STATUS
func (rule *QueueScaleRule_STATUS) AssignProperties_From_QueueScaleRule_STATUS(source *storage.QueueScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// QueueLength
	rule.QueueLength = genruntime.ClonePointerToInt(source.QueueLength)

	// QueueName
	rule.QueueName = genruntime.ClonePointerToString(source.QueueName)

	// No error
	return nil
}

// AssignProperties_To_QueueScaleRule_STATUS populates the provided destination QueueScaleRule_STATUS from our QueueScaleRule_STATUS
func (rule *QueueScaleRule_STATUS) AssignProperties_To_QueueScaleRule_STATUS(destination *storage.QueueScaleRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// QueueLength
	destination.QueueLength = genruntime.ClonePointerToInt(rule.QueueLength)

	// QueueName
	destination.QueueName = genruntime.ClonePointerToString(rule.QueueName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container App container Tcp scaling rule.
type TcpScaleRule struct {
	// Auth: Authentication secrets for the tcp scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe tcp scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`
}

var _ genruntime.ARMTransformer = &TcpScaleRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *TcpScaleRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.TcpScaleRule{}

	// Set property "Auth":
	for _, item := range rule.Auth {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Auth = append(result.Auth, *item_ARM.(*arm.ScaleRuleAuth))
	}

	// Set property "Metadata":
	if rule.Metadata != nil {
		result.Metadata = make(map[string]string, len(rule.Metadata))
		for key, value := range rule.Metadata {
			result.Metadata[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *TcpScaleRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TcpScaleRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *TcpScaleRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TcpScaleRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TcpScaleRule, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		rule.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			rule.Metadata[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_TcpScaleRule populates our TcpScaleRule from the provided source TcpScaleRule
func (rule *TcpScaleRule) AssignProperties_From_TcpScaleRule(source *storage.TcpScaleRule) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// No error
	return nil
}

// AssignProperties_To_TcpScaleRule populates the provided destination TcpScaleRule from our TcpScaleRule
func (rule *TcpScaleRule) AssignProperties_To_TcpScaleRule(destination *storage.TcpScaleRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TcpScaleRule_STATUS populates our TcpScaleRule from the provided source TcpScaleRule_STATUS
func (rule *TcpScaleRule) Initialize_From_TcpScaleRule_STATUS(source *TcpScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.Initialize_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// No error
	return nil
}

// Container App container Tcp scaling rule.
type TcpScaleRule_STATUS struct {
	// Auth: Authentication secrets for the tcp scale rule.
	Auth []ScaleRuleAuth_STATUS `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe tcp scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`
}

var _ genruntime.FromARMConverter = &TcpScaleRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *TcpScaleRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TcpScaleRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *TcpScaleRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TcpScaleRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TcpScaleRule_STATUS, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		rule.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			rule.Metadata[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_TcpScaleRule_STATUS populates our TcpScaleRule_STATUS from the provided source TcpScaleRule_STATUS
func (rule *TcpScaleRule_STATUS) AssignProperties_From_TcpScaleRule_STATUS(source *storage.TcpScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	rule.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// No error
	return nil
}

// AssignProperties_To_TcpScaleRule_STATUS populates the provided destination TcpScaleRule_STATUS from our TcpScaleRule_STATUS
func (rule *TcpScaleRule_STATUS) AssignProperties_To_TcpScaleRule_STATUS(destination *storage.TcpScaleRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(rule.Metadata)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerAppProbe_HttpGet_HttpHeaders struct {
	// +kubebuilder:validation:Required
	// Name: The header field name
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Value: The header field value
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerAppProbe_HttpGet_HttpHeaders{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (headers *ContainerAppProbe_HttpGet_HttpHeaders) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if headers == nil {
		return nil, nil
	}
	result := &arm.ContainerAppProbe_HttpGet_HttpHeaders{}

	// Set property "Name":
	if headers.Name != nil {
		name := *headers.Name
		result.Name = &name
	}

	// Set property "Value":
	if headers.Value != nil {
		value := *headers.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (headers *ContainerAppProbe_HttpGet_HttpHeaders) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerAppProbe_HttpGet_HttpHeaders{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (headers *ContainerAppProbe_HttpGet_HttpHeaders) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerAppProbe_HttpGet_HttpHeaders)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerAppProbe_HttpGet_HttpHeaders, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		headers.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		headers.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders populates our ContainerAppProbe_HttpGet_HttpHeaders from the provided source ContainerAppProbe_HttpGet_HttpHeaders
func (headers *ContainerAppProbe_HttpGet_HttpHeaders) AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders(source *storage.ContainerAppProbe_HttpGet_HttpHeaders) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders populates the provided destination ContainerAppProbe_HttpGet_HttpHeaders from our ContainerAppProbe_HttpGet_HttpHeaders
func (headers *ContainerAppProbe_HttpGet_HttpHeaders) AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders(destination *storage.ContainerAppProbe_HttpGet_HttpHeaders) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS populates our ContainerAppProbe_HttpGet_HttpHeaders from the provided source ContainerAppProbe_HttpGet_HttpHeaders_STATUS
func (headers *ContainerAppProbe_HttpGet_HttpHeaders) Initialize_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(source *ContainerAppProbe_HttpGet_HttpHeaders_STATUS) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

type ContainerAppProbe_HttpGet_HttpHeaders_STATUS struct {
	// Name: The header field name
	Name *string `json:"name,omitempty"`

	// Value: The header field value
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerAppProbe_HttpGet_HttpHeaders_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (headers *ContainerAppProbe_HttpGet_HttpHeaders_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerAppProbe_HttpGet_HttpHeaders_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (headers *ContainerAppProbe_HttpGet_HttpHeaders_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerAppProbe_HttpGet_HttpHeaders_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerAppProbe_HttpGet_HttpHeaders_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		headers.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		headers.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS populates our ContainerAppProbe_HttpGet_HttpHeaders_STATUS from the provided source ContainerAppProbe_HttpGet_HttpHeaders_STATUS
func (headers *ContainerAppProbe_HttpGet_HttpHeaders_STATUS) AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(source *storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS populates the provided destination ContainerAppProbe_HttpGet_HttpHeaders_STATUS from our ContainerAppProbe_HttpGet_HttpHeaders_STATUS
func (headers *ContainerAppProbe_HttpGet_HttpHeaders_STATUS) AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(destination *storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"HTTP","HTTPS"}
type ContainerAppProbe_HttpGet_Scheme string

const (
	ContainerAppProbe_HttpGet_Scheme_HTTP  = ContainerAppProbe_HttpGet_Scheme("HTTP")
	ContainerAppProbe_HttpGet_Scheme_HTTPS = ContainerAppProbe_HttpGet_Scheme("HTTPS")
)

// Mapping from string to ContainerAppProbe_HttpGet_Scheme
var containerAppProbe_HttpGet_Scheme_Values = map[string]ContainerAppProbe_HttpGet_Scheme{
	"http":  ContainerAppProbe_HttpGet_Scheme_HTTP,
	"https": ContainerAppProbe_HttpGet_Scheme_HTTPS,
}

type ContainerAppProbe_HttpGet_Scheme_STATUS string

const (
	ContainerAppProbe_HttpGet_Scheme_STATUS_HTTP  = ContainerAppProbe_HttpGet_Scheme_STATUS("HTTP")
	ContainerAppProbe_HttpGet_Scheme_STATUS_HTTPS = ContainerAppProbe_HttpGet_Scheme_STATUS("HTTPS")
)

// Mapping from string to ContainerAppProbe_HttpGet_Scheme_STATUS
var containerAppProbe_HttpGet_Scheme_STATUS_Values = map[string]ContainerAppProbe_HttpGet_Scheme_STATUS{
	"http":  ContainerAppProbe_HttpGet_Scheme_STATUS_HTTP,
	"https": ContainerAppProbe_HttpGet_Scheme_STATUS_HTTPS,
}

// Auth Secrets for Scale Rule
type ScaleRuleAuth struct {
	// SecretRef: Name of the secret from which to pull the auth params.
	SecretRef *string `json:"secretRef,omitempty"`

	// TriggerParameter: Trigger Parameter that uses the secret
	TriggerParameter *string `json:"triggerParameter,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleRuleAuth{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (auth *ScaleRuleAuth) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if auth == nil {
		return nil, nil
	}
	result := &arm.ScaleRuleAuth{}

	// Set property "SecretRef":
	if auth.SecretRef != nil {
		secretRef := *auth.SecretRef
		result.SecretRef = &secretRef
	}

	// Set property "TriggerParameter":
	if auth.TriggerParameter != nil {
		triggerParameter := *auth.TriggerParameter
		result.TriggerParameter = &triggerParameter
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (auth *ScaleRuleAuth) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleRuleAuth{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (auth *ScaleRuleAuth) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleRuleAuth)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleRuleAuth, got %T", armInput)
	}

	// Set property "SecretRef":
	if typedInput.SecretRef != nil {
		secretRef := *typedInput.SecretRef
		auth.SecretRef = &secretRef
	}

	// Set property "TriggerParameter":
	if typedInput.TriggerParameter != nil {
		triggerParameter := *typedInput.TriggerParameter
		auth.TriggerParameter = &triggerParameter
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleRuleAuth populates our ScaleRuleAuth from the provided source ScaleRuleAuth
func (auth *ScaleRuleAuth) AssignProperties_From_ScaleRuleAuth(source *storage.ScaleRuleAuth) error {

	// SecretRef
	auth.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// TriggerParameter
	auth.TriggerParameter = genruntime.ClonePointerToString(source.TriggerParameter)

	// No error
	return nil
}

// AssignProperties_To_ScaleRuleAuth populates the provided destination ScaleRuleAuth from our ScaleRuleAuth
func (auth *ScaleRuleAuth) AssignProperties_To_ScaleRuleAuth(destination *storage.ScaleRuleAuth) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(auth.SecretRef)

	// TriggerParameter
	destination.TriggerParameter = genruntime.ClonePointerToString(auth.TriggerParameter)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScaleRuleAuth_STATUS populates our ScaleRuleAuth from the provided source ScaleRuleAuth_STATUS
func (auth *ScaleRuleAuth) Initialize_From_ScaleRuleAuth_STATUS(source *ScaleRuleAuth_STATUS) error {

	// SecretRef
	auth.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// TriggerParameter
	auth.TriggerParameter = genruntime.ClonePointerToString(source.TriggerParameter)

	// No error
	return nil
}

// Auth Secrets for Scale Rule
type ScaleRuleAuth_STATUS struct {
	// SecretRef: Name of the secret from which to pull the auth params.
	SecretRef *string `json:"secretRef,omitempty"`

	// TriggerParameter: Trigger Parameter that uses the secret
	TriggerParameter *string `json:"triggerParameter,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleRuleAuth_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (auth *ScaleRuleAuth_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleRuleAuth_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (auth *ScaleRuleAuth_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleRuleAuth_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleRuleAuth_STATUS, got %T", armInput)
	}

	// Set property "SecretRef":
	if typedInput.SecretRef != nil {
		secretRef := *typedInput.SecretRef
		auth.SecretRef = &secretRef
	}

	// Set property "TriggerParameter":
	if typedInput.TriggerParameter != nil {
		triggerParameter := *typedInput.TriggerParameter
		auth.TriggerParameter = &triggerParameter
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleRuleAuth_STATUS populates our ScaleRuleAuth_STATUS from the provided source ScaleRuleAuth_STATUS
func (auth *ScaleRuleAuth_STATUS) AssignProperties_From_ScaleRuleAuth_STATUS(source *storage.ScaleRuleAuth_STATUS) error {

	// SecretRef
	auth.SecretRef = genruntime.ClonePointerToString(source.SecretRef)

	// TriggerParameter
	auth.TriggerParameter = genruntime.ClonePointerToString(source.TriggerParameter)

	// No error
	return nil
}

// AssignProperties_To_ScaleRuleAuth_STATUS populates the provided destination ScaleRuleAuth_STATUS from our ScaleRuleAuth_STATUS
func (auth *ScaleRuleAuth_STATUS) AssignProperties_To_ScaleRuleAuth_STATUS(destination *storage.ScaleRuleAuth_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretRef
	destination.SecretRef = genruntime.ClonePointerToString(auth.SecretRef)

	// TriggerParameter
	destination.TriggerParameter = genruntime.ClonePointerToString(auth.TriggerParameter)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ContainerApp{}, &ContainerAppList{})
}
