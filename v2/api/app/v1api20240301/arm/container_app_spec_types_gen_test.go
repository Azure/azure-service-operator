// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BaseContainer_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaseContainer via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaseContainer, BaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaseContainer runs a test to see if a specific instance of BaseContainer round trips to JSON and back losslessly
func RunJSONSerializationTestForBaseContainer(subject BaseContainer) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaseContainer
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaseContainer instances for property testing - lazily instantiated by BaseContainerGenerator()
var baseContainerGenerator gopter.Gen

// BaseContainerGenerator returns a generator of BaseContainer instances for property testing.
// We first initialize baseContainerGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BaseContainerGenerator() gopter.Gen {
	if baseContainerGenerator != nil {
		return baseContainerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBaseContainer(generators)
	baseContainerGenerator = gen.Struct(reflect.TypeOf(BaseContainer{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBaseContainer(generators)
	AddRelatedPropertyGeneratorsForBaseContainer(generators)
	baseContainerGenerator = gen.Struct(reflect.TypeOf(BaseContainer{}), generators)

	return baseContainerGenerator
}

// AddIndependentPropertyGeneratorsForBaseContainer is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBaseContainer(gens map[string]gopter.Gen) {
	gens["Args"] = gen.SliceOf(gen.AlphaString())
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBaseContainer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaseContainer(gens map[string]gopter.Gen) {
	gens["Env"] = gen.SliceOf(EnvironmentVarGenerator())
	gens["Resources"] = gen.PtrOf(ContainerResourcesGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_Configuration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Configuration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConfiguration, ConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConfiguration runs a test to see if a specific instance of Configuration round trips to JSON and back losslessly
func RunJSONSerializationTestForConfiguration(subject Configuration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Configuration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Configuration instances for property testing - lazily instantiated by ConfigurationGenerator()
var configurationGenerator gopter.Gen

// ConfigurationGenerator returns a generator of Configuration instances for property testing.
// We first initialize configurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ConfigurationGenerator() gopter.Gen {
	if configurationGenerator != nil {
		return configurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConfiguration(generators)
	configurationGenerator = gen.Struct(reflect.TypeOf(Configuration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConfiguration(generators)
	AddRelatedPropertyGeneratorsForConfiguration(generators)
	configurationGenerator = gen.Struct(reflect.TypeOf(Configuration{}), generators)

	return configurationGenerator
}

// AddIndependentPropertyGeneratorsForConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConfiguration(gens map[string]gopter.Gen) {
	gens["ActiveRevisionsMode"] = gen.PtrOf(gen.OneConstOf(Configuration_ActiveRevisionsMode_Multiple, Configuration_ActiveRevisionsMode_Single))
	gens["MaxInactiveRevisions"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForConfiguration(gens map[string]gopter.Gen) {
	gens["Dapr"] = gen.PtrOf(DaprGenerator())
	gens["Ingress"] = gen.PtrOf(IngressGenerator())
	gens["Registries"] = gen.SliceOf(RegistryCredentialsGenerator())
	gens["Secrets"] = gen.SliceOf(SecretGenerator())
	gens["Service"] = gen.PtrOf(ServiceGenerator())
}

func Test_Container_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainer, ContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainer runs a test to see if a specific instance of Container round trips to JSON and back losslessly
func RunJSONSerializationTestForContainer(subject Container) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container instances for property testing - lazily instantiated by ContainerGenerator()
var containerGenerator gopter.Gen

// ContainerGenerator returns a generator of Container instances for property testing.
// We first initialize containerGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGenerator() gopter.Gen {
	if containerGenerator != nil {
		return containerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer(generators)
	containerGenerator = gen.Struct(reflect.TypeOf(Container{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer(generators)
	AddRelatedPropertyGeneratorsForContainer(generators)
	containerGenerator = gen.Struct(reflect.TypeOf(Container{}), generators)

	return containerGenerator
}

// AddIndependentPropertyGeneratorsForContainer is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainer(gens map[string]gopter.Gen) {
	gens["Args"] = gen.SliceOf(gen.AlphaString())
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainer(gens map[string]gopter.Gen) {
	gens["Env"] = gen.SliceOf(EnvironmentVarGenerator())
	gens["Probes"] = gen.SliceOf(ContainerAppProbeGenerator())
	gens["Resources"] = gen.PtrOf(ContainerResourcesGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_ContainerAppProbe_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe, ContainerAppProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe runs a test to see if a specific instance of ContainerAppProbe round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe(subject ContainerAppProbe) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe instances for property testing - lazily instantiated by ContainerAppProbeGenerator()
var containerAppProbeGenerator gopter.Gen

// ContainerAppProbeGenerator returns a generator of ContainerAppProbe instances for property testing.
// We first initialize containerAppProbeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerAppProbeGenerator() gopter.Gen {
	if containerAppProbeGenerator != nil {
		return containerAppProbeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe(generators)
	containerAppProbeGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe(generators)
	AddRelatedPropertyGeneratorsForContainerAppProbe(generators)
	containerAppProbeGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe{}), generators)

	return containerAppProbeGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TerminationGracePeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ContainerAppProbe_Type_Liveness, ContainerAppProbe_Type_Readiness, ContainerAppProbe_Type_Startup))
}

// AddRelatedPropertyGeneratorsForContainerAppProbe is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerAppProbe(gens map[string]gopter.Gen) {
	gens["HttpGet"] = gen.PtrOf(ContainerAppProbe_HttpGetGenerator())
	gens["TcpSocket"] = gen.PtrOf(ContainerAppProbe_TcpSocketGenerator())
}

func Test_ContainerAppProbe_HttpGet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_HttpGet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_HttpGet, ContainerAppProbe_HttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_HttpGet runs a test to see if a specific instance of ContainerAppProbe_HttpGet round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_HttpGet(subject ContainerAppProbe_HttpGet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_HttpGet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_HttpGet instances for property testing - lazily instantiated by
// ContainerAppProbe_HttpGetGenerator()
var containerAppProbe_HttpGetGenerator gopter.Gen

// ContainerAppProbe_HttpGetGenerator returns a generator of ContainerAppProbe_HttpGet instances for property testing.
// We first initialize containerAppProbe_HttpGetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerAppProbe_HttpGetGenerator() gopter.Gen {
	if containerAppProbe_HttpGetGenerator != nil {
		return containerAppProbe_HttpGetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet(generators)
	containerAppProbe_HttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet(generators)
	AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet(generators)
	containerAppProbe_HttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet{}), generators)

	return containerAppProbe_HttpGetGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet(gens map[string]gopter.Gen) {
	gens["Host"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerAppProbe_HttpGet_Scheme_HTTP, ContainerAppProbe_HttpGet_Scheme_HTTPS))
}

// AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(ContainerAppProbe_HttpGet_HttpHeadersGenerator())
}

func Test_ContainerAppProbe_HttpGet_HttpHeaders_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_HttpGet_HttpHeaders via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders, ContainerAppProbe_HttpGet_HttpHeadersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders runs a test to see if a specific instance of ContainerAppProbe_HttpGet_HttpHeaders round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders(subject ContainerAppProbe_HttpGet_HttpHeaders) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_HttpGet_HttpHeaders
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_HttpGet_HttpHeaders instances for property testing - lazily instantiated by
// ContainerAppProbe_HttpGet_HttpHeadersGenerator()
var containerAppProbe_HttpGet_HttpHeadersGenerator gopter.Gen

// ContainerAppProbe_HttpGet_HttpHeadersGenerator returns a generator of ContainerAppProbe_HttpGet_HttpHeaders instances for property testing.
func ContainerAppProbe_HttpGet_HttpHeadersGenerator() gopter.Gen {
	if containerAppProbe_HttpGet_HttpHeadersGenerator != nil {
		return containerAppProbe_HttpGet_HttpHeadersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders(generators)
	containerAppProbe_HttpGet_HttpHeadersGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet_HttpHeaders{}), generators)

	return containerAppProbe_HttpGet_HttpHeadersGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerAppProbe_TcpSocket_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_TcpSocket via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_TcpSocket, ContainerAppProbe_TcpSocketGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_TcpSocket runs a test to see if a specific instance of ContainerAppProbe_TcpSocket round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_TcpSocket(subject ContainerAppProbe_TcpSocket) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_TcpSocket
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_TcpSocket instances for property testing - lazily instantiated by
// ContainerAppProbe_TcpSocketGenerator()
var containerAppProbe_TcpSocketGenerator gopter.Gen

// ContainerAppProbe_TcpSocketGenerator returns a generator of ContainerAppProbe_TcpSocket instances for property testing.
func ContainerAppProbe_TcpSocketGenerator() gopter.Gen {
	if containerAppProbe_TcpSocketGenerator != nil {
		return containerAppProbe_TcpSocketGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket(generators)
	containerAppProbe_TcpSocketGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_TcpSocket{}), generators)

	return containerAppProbe_TcpSocketGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket(gens map[string]gopter.Gen) {
	gens["Host"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
}

func Test_ContainerApp_Properties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerApp_Properties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerApp_Properties_Spec, ContainerApp_Properties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerApp_Properties_Spec runs a test to see if a specific instance of ContainerApp_Properties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerApp_Properties_Spec(subject ContainerApp_Properties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerApp_Properties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerApp_Properties_Spec instances for property testing - lazily instantiated by
// ContainerApp_Properties_SpecGenerator()
var containerApp_Properties_SpecGenerator gopter.Gen

// ContainerApp_Properties_SpecGenerator returns a generator of ContainerApp_Properties_Spec instances for property testing.
// We first initialize containerApp_Properties_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerApp_Properties_SpecGenerator() gopter.Gen {
	if containerApp_Properties_SpecGenerator != nil {
		return containerApp_Properties_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerApp_Properties_Spec(generators)
	containerApp_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerApp_Properties_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerApp_Properties_Spec(generators)
	AddRelatedPropertyGeneratorsForContainerApp_Properties_Spec(generators)
	containerApp_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerApp_Properties_Spec{}), generators)

	return containerApp_Properties_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerApp_Properties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerApp_Properties_Spec(gens map[string]gopter.Gen) {
	gens["EnvironmentId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedEnvironmentId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkloadProfileName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerApp_Properties_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerApp_Properties_Spec(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(ConfigurationGenerator())
	gens["Template"] = gen.PtrOf(TemplateGenerator())
}

func Test_ContainerApp_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerApp_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerApp_Spec, ContainerApp_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerApp_Spec runs a test to see if a specific instance of ContainerApp_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerApp_Spec(subject ContainerApp_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerApp_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerApp_Spec instances for property testing - lazily instantiated by ContainerApp_SpecGenerator()
var containerApp_SpecGenerator gopter.Gen

// ContainerApp_SpecGenerator returns a generator of ContainerApp_Spec instances for property testing.
// We first initialize containerApp_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerApp_SpecGenerator() gopter.Gen {
	if containerApp_SpecGenerator != nil {
		return containerApp_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerApp_Spec(generators)
	containerApp_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerApp_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerApp_Spec(generators)
	AddRelatedPropertyGeneratorsForContainerApp_Spec(generators)
	containerApp_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerApp_Spec{}), generators)

	return containerApp_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerApp_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerApp_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerApp_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerApp_Spec(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["Properties"] = gen.PtrOf(ContainerApp_Properties_SpecGenerator())
}

func Test_ContainerResources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerResources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerResources, ContainerResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerResources runs a test to see if a specific instance of ContainerResources round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerResources(subject ContainerResources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerResources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerResources instances for property testing - lazily instantiated by ContainerResourcesGenerator()
var containerResourcesGenerator gopter.Gen

// ContainerResourcesGenerator returns a generator of ContainerResources instances for property testing.
func ContainerResourcesGenerator() gopter.Gen {
	if containerResourcesGenerator != nil {
		return containerResourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerResources(generators)
	containerResourcesGenerator = gen.Struct(reflect.TypeOf(ContainerResources{}), generators)

	return containerResourcesGenerator
}

// AddIndependentPropertyGeneratorsForContainerResources is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerResources(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["Memory"] = gen.PtrOf(gen.AlphaString())
}

func Test_CorsPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy, CorsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy runs a test to see if a specific instance of CorsPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy(subject CorsPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy instances for property testing - lazily instantiated by CorsPolicyGenerator()
var corsPolicyGenerator gopter.Gen

// CorsPolicyGenerator returns a generator of CorsPolicy instances for property testing.
func CorsPolicyGenerator() gopter.Gen {
	if corsPolicyGenerator != nil {
		return corsPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy(generators)
	corsPolicyGenerator = gen.Struct(reflect.TypeOf(CorsPolicy{}), generators)

	return corsPolicyGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy(gens map[string]gopter.Gen) {
	gens["AllowCredentials"] = gen.PtrOf(gen.Bool())
	gens["AllowedHeaders"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["ExposeHeaders"] = gen.SliceOf(gen.AlphaString())
	gens["MaxAge"] = gen.PtrOf(gen.Int())
}

func Test_CustomDomain_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain, CustomDomainGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain runs a test to see if a specific instance of CustomDomain round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain(subject CustomDomain) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain instances for property testing - lazily instantiated by CustomDomainGenerator()
var customDomainGenerator gopter.Gen

// CustomDomainGenerator returns a generator of CustomDomain instances for property testing.
func CustomDomainGenerator() gopter.Gen {
	if customDomainGenerator != nil {
		return customDomainGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain(generators)
	customDomainGenerator = gen.Struct(reflect.TypeOf(CustomDomain{}), generators)

	return customDomainGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain(gens map[string]gopter.Gen) {
	gens["BindingType"] = gen.PtrOf(gen.OneConstOf(CustomDomain_BindingType_Disabled, CustomDomain_BindingType_SniEnabled))
	gens["CertificateId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_CustomScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomScaleRule, CustomScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomScaleRule runs a test to see if a specific instance of CustomScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomScaleRule(subject CustomScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomScaleRule instances for property testing - lazily instantiated by CustomScaleRuleGenerator()
var customScaleRuleGenerator gopter.Gen

// CustomScaleRuleGenerator returns a generator of CustomScaleRule instances for property testing.
// We first initialize customScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomScaleRuleGenerator() gopter.Gen {
	if customScaleRuleGenerator != nil {
		return customScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomScaleRule(generators)
	customScaleRuleGenerator = gen.Struct(reflect.TypeOf(CustomScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomScaleRule(generators)
	AddRelatedPropertyGeneratorsForCustomScaleRule(generators)
	customScaleRuleGenerator = gen.Struct(reflect.TypeOf(CustomScaleRule{}), generators)

	return customScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForCustomScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomScaleRule(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCustomScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_Dapr_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Dapr via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDapr, DaprGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDapr runs a test to see if a specific instance of Dapr round trips to JSON and back losslessly
func RunJSONSerializationTestForDapr(subject Dapr) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Dapr
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Dapr instances for property testing - lazily instantiated by DaprGenerator()
var daprGenerator gopter.Gen

// DaprGenerator returns a generator of Dapr instances for property testing.
func DaprGenerator() gopter.Gen {
	if daprGenerator != nil {
		return daprGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDapr(generators)
	daprGenerator = gen.Struct(reflect.TypeOf(Dapr{}), generators)

	return daprGenerator
}

// AddIndependentPropertyGeneratorsForDapr is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDapr(gens map[string]gopter.Gen) {
	gens["AppId"] = gen.PtrOf(gen.AlphaString())
	gens["AppPort"] = gen.PtrOf(gen.Int())
	gens["AppProtocol"] = gen.PtrOf(gen.OneConstOf(Dapr_AppProtocol_Grpc, Dapr_AppProtocol_Http))
	gens["EnableApiLogging"] = gen.PtrOf(gen.Bool())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HttpMaxRequestSize"] = gen.PtrOf(gen.Int())
	gens["HttpReadBufferSize"] = gen.PtrOf(gen.Int())
	gens["LogLevel"] = gen.PtrOf(gen.OneConstOf(
		Dapr_LogLevel_Debug,
		Dapr_LogLevel_Error,
		Dapr_LogLevel_Info,
		Dapr_LogLevel_Warn))
}

func Test_EnvironmentVar_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVar via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVar, EnvironmentVarGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVar runs a test to see if a specific instance of EnvironmentVar round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVar(subject EnvironmentVar) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVar
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVar instances for property testing - lazily instantiated by EnvironmentVarGenerator()
var environmentVarGenerator gopter.Gen

// EnvironmentVarGenerator returns a generator of EnvironmentVar instances for property testing.
func EnvironmentVarGenerator() gopter.Gen {
	if environmentVarGenerator != nil {
		return environmentVarGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVar(generators)
	environmentVarGenerator = gen.Struct(reflect.TypeOf(EnvironmentVar{}), generators)

	return environmentVarGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVar is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVar(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation, ExtendedLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation runs a test to see if a specific instance of ExtendedLocation round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation(subject ExtendedLocation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation instances for property testing - lazily instantiated by ExtendedLocationGenerator()
var extendedLocationGenerator gopter.Gen

// ExtendedLocationGenerator returns a generator of ExtendedLocation instances for property testing.
func ExtendedLocationGenerator() gopter.Gen {
	if extendedLocationGenerator != nil {
		return extendedLocationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation(generators)
	extendedLocationGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation{}), generators)

	return extendedLocationGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_CustomLocation))
}

func Test_HttpScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpScaleRule, HttpScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpScaleRule runs a test to see if a specific instance of HttpScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpScaleRule(subject HttpScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpScaleRule instances for property testing - lazily instantiated by HttpScaleRuleGenerator()
var httpScaleRuleGenerator gopter.Gen

// HttpScaleRuleGenerator returns a generator of HttpScaleRule instances for property testing.
// We first initialize httpScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HttpScaleRuleGenerator() gopter.Gen {
	if httpScaleRuleGenerator != nil {
		return httpScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpScaleRule(generators)
	httpScaleRuleGenerator = gen.Struct(reflect.TypeOf(HttpScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpScaleRule(generators)
	AddRelatedPropertyGeneratorsForHttpScaleRule(generators)
	httpScaleRuleGenerator = gen.Struct(reflect.TypeOf(HttpScaleRule{}), generators)

	return httpScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForHttpScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpScaleRule(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHttpScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHttpScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_Ingress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Ingress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngress, IngressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngress runs a test to see if a specific instance of Ingress round trips to JSON and back losslessly
func RunJSONSerializationTestForIngress(subject Ingress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Ingress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Ingress instances for property testing - lazily instantiated by IngressGenerator()
var ingressGenerator gopter.Gen

// IngressGenerator returns a generator of Ingress instances for property testing.
// We first initialize ingressGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IngressGenerator() gopter.Gen {
	if ingressGenerator != nil {
		return ingressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress(generators)
	ingressGenerator = gen.Struct(reflect.TypeOf(Ingress{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress(generators)
	AddRelatedPropertyGeneratorsForIngress(generators)
	ingressGenerator = gen.Struct(reflect.TypeOf(Ingress{}), generators)

	return ingressGenerator
}

// AddIndependentPropertyGeneratorsForIngress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngress(gens map[string]gopter.Gen) {
	gens["AllowInsecure"] = gen.PtrOf(gen.Bool())
	gens["ClientCertificateMode"] = gen.PtrOf(gen.OneConstOf(Ingress_ClientCertificateMode_Accept, Ingress_ClientCertificateMode_Ignore, Ingress_ClientCertificateMode_Require))
	gens["ExposedPort"] = gen.PtrOf(gen.Int())
	gens["External"] = gen.PtrOf(gen.Bool())
	gens["TargetPort"] = gen.PtrOf(gen.Int())
	gens["Transport"] = gen.PtrOf(gen.OneConstOf(
		Ingress_Transport_Auto,
		Ingress_Transport_Http,
		Ingress_Transport_Http2,
		Ingress_Transport_Tcp))
}

// AddRelatedPropertyGeneratorsForIngress is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIngress(gens map[string]gopter.Gen) {
	gens["AdditionalPortMappings"] = gen.SliceOf(IngressPortMappingGenerator())
	gens["CorsPolicy"] = gen.PtrOf(CorsPolicyGenerator())
	gens["CustomDomains"] = gen.SliceOf(CustomDomainGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionRuleGenerator())
	gens["StickySessions"] = gen.PtrOf(Ingress_StickySessionsGenerator())
	gens["Traffic"] = gen.SliceOf(TrafficWeightGenerator())
}

func Test_IngressPortMapping_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IngressPortMapping via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngressPortMapping, IngressPortMappingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngressPortMapping runs a test to see if a specific instance of IngressPortMapping round trips to JSON and back losslessly
func RunJSONSerializationTestForIngressPortMapping(subject IngressPortMapping) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IngressPortMapping
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IngressPortMapping instances for property testing - lazily instantiated by IngressPortMappingGenerator()
var ingressPortMappingGenerator gopter.Gen

// IngressPortMappingGenerator returns a generator of IngressPortMapping instances for property testing.
func IngressPortMappingGenerator() gopter.Gen {
	if ingressPortMappingGenerator != nil {
		return ingressPortMappingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngressPortMapping(generators)
	ingressPortMappingGenerator = gen.Struct(reflect.TypeOf(IngressPortMapping{}), generators)

	return ingressPortMappingGenerator
}

// AddIndependentPropertyGeneratorsForIngressPortMapping is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngressPortMapping(gens map[string]gopter.Gen) {
	gens["ExposedPort"] = gen.PtrOf(gen.Int())
	gens["External"] = gen.PtrOf(gen.Bool())
	gens["TargetPort"] = gen.PtrOf(gen.Int())
}

func Test_Ingress_StickySessions_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Ingress_StickySessions via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngress_StickySessions, Ingress_StickySessionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngress_StickySessions runs a test to see if a specific instance of Ingress_StickySessions round trips to JSON and back losslessly
func RunJSONSerializationTestForIngress_StickySessions(subject Ingress_StickySessions) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Ingress_StickySessions
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Ingress_StickySessions instances for property testing - lazily instantiated by
// Ingress_StickySessionsGenerator()
var ingress_StickySessionsGenerator gopter.Gen

// Ingress_StickySessionsGenerator returns a generator of Ingress_StickySessions instances for property testing.
func Ingress_StickySessionsGenerator() gopter.Gen {
	if ingress_StickySessionsGenerator != nil {
		return ingress_StickySessionsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress_StickySessions(generators)
	ingress_StickySessionsGenerator = gen.Struct(reflect.TypeOf(Ingress_StickySessions{}), generators)

	return ingress_StickySessionsGenerator
}

// AddIndependentPropertyGeneratorsForIngress_StickySessions is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngress_StickySessions(gens map[string]gopter.Gen) {
	gens["Affinity"] = gen.PtrOf(gen.OneConstOf(Ingress_StickySessions_Affinity_None, Ingress_StickySessions_Affinity_Sticky))
}

func Test_IpSecurityRestrictionRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestrictionRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestrictionRule, IpSecurityRestrictionRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestrictionRule runs a test to see if a specific instance of IpSecurityRestrictionRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestrictionRule(subject IpSecurityRestrictionRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestrictionRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestrictionRule instances for property testing - lazily instantiated by
// IpSecurityRestrictionRuleGenerator()
var ipSecurityRestrictionRuleGenerator gopter.Gen

// IpSecurityRestrictionRuleGenerator returns a generator of IpSecurityRestrictionRule instances for property testing.
func IpSecurityRestrictionRuleGenerator() gopter.Gen {
	if ipSecurityRestrictionRuleGenerator != nil {
		return ipSecurityRestrictionRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule(generators)
	ipSecurityRestrictionRuleGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestrictionRule{}), generators)

	return ipSecurityRestrictionRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestrictionRule_Action_Allow, IpSecurityRestrictionRule_Action_Deny))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddressRange"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_None,
		ManagedServiceIdentityType_SystemAssigned,
		ManagedServiceIdentityType_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_QueueScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueueScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueueScaleRule, QueueScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueueScaleRule runs a test to see if a specific instance of QueueScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForQueueScaleRule(subject QueueScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueueScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueueScaleRule instances for property testing - lazily instantiated by QueueScaleRuleGenerator()
var queueScaleRuleGenerator gopter.Gen

// QueueScaleRuleGenerator returns a generator of QueueScaleRule instances for property testing.
// We first initialize queueScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func QueueScaleRuleGenerator() gopter.Gen {
	if queueScaleRuleGenerator != nil {
		return queueScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueueScaleRule(generators)
	queueScaleRuleGenerator = gen.Struct(reflect.TypeOf(QueueScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueueScaleRule(generators)
	AddRelatedPropertyGeneratorsForQueueScaleRule(generators)
	queueScaleRuleGenerator = gen.Struct(reflect.TypeOf(QueueScaleRule{}), generators)

	return queueScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForQueueScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueueScaleRule(gens map[string]gopter.Gen) {
	gens["QueueLength"] = gen.PtrOf(gen.Int())
	gens["QueueName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForQueueScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForQueueScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_RegistryCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryCredentials, RegistryCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryCredentials runs a test to see if a specific instance of RegistryCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryCredentials(subject RegistryCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryCredentials instances for property testing - lazily instantiated by
// RegistryCredentialsGenerator()
var registryCredentialsGenerator gopter.Gen

// RegistryCredentialsGenerator returns a generator of RegistryCredentials instances for property testing.
func RegistryCredentialsGenerator() gopter.Gen {
	if registryCredentialsGenerator != nil {
		return registryCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryCredentials(generators)
	registryCredentialsGenerator = gen.Struct(reflect.TypeOf(RegistryCredentials{}), generators)

	return registryCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForRegistryCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryCredentials(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["PasswordSecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_Scale_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Scale via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScale, ScaleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScale runs a test to see if a specific instance of Scale round trips to JSON and back losslessly
func RunJSONSerializationTestForScale(subject Scale) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Scale
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Scale instances for property testing - lazily instantiated by ScaleGenerator()
var scaleGenerator gopter.Gen

// ScaleGenerator returns a generator of Scale instances for property testing.
// We first initialize scaleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScaleGenerator() gopter.Gen {
	if scaleGenerator != nil {
		return scaleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScale(generators)
	scaleGenerator = gen.Struct(reflect.TypeOf(Scale{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScale(generators)
	AddRelatedPropertyGeneratorsForScale(generators)
	scaleGenerator = gen.Struct(reflect.TypeOf(Scale{}), generators)

	return scaleGenerator
}

// AddIndependentPropertyGeneratorsForScale is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScale(gens map[string]gopter.Gen) {
	gens["MaxReplicas"] = gen.PtrOf(gen.Int())
	gens["MinReplicas"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForScale is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScale(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ScaleRuleGenerator())
}

func Test_ScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule, ScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule runs a test to see if a specific instance of ScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule(subject ScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule instances for property testing - lazily instantiated by ScaleRuleGenerator()
var scaleRuleGenerator gopter.Gen

// ScaleRuleGenerator returns a generator of ScaleRule instances for property testing.
// We first initialize scaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScaleRuleGenerator() gopter.Gen {
	if scaleRuleGenerator != nil {
		return scaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRule(generators)
	scaleRuleGenerator = gen.Struct(reflect.TypeOf(ScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRule(generators)
	AddRelatedPropertyGeneratorsForScaleRule(generators)
	scaleRuleGenerator = gen.Struct(reflect.TypeOf(ScaleRule{}), generators)

	return scaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRule(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule(gens map[string]gopter.Gen) {
	gens["AzureQueue"] = gen.PtrOf(QueueScaleRuleGenerator())
	gens["Custom"] = gen.PtrOf(CustomScaleRuleGenerator())
	gens["Http"] = gen.PtrOf(HttpScaleRuleGenerator())
	gens["Tcp"] = gen.PtrOf(TcpScaleRuleGenerator())
}

func Test_ScaleRuleAuth_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleAuth via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleAuth, ScaleRuleAuthGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleAuth runs a test to see if a specific instance of ScaleRuleAuth round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleAuth(subject ScaleRuleAuth) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleAuth
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleAuth instances for property testing - lazily instantiated by ScaleRuleAuthGenerator()
var scaleRuleAuthGenerator gopter.Gen

// ScaleRuleAuthGenerator returns a generator of ScaleRuleAuth instances for property testing.
func ScaleRuleAuthGenerator() gopter.Gen {
	if scaleRuleAuthGenerator != nil {
		return scaleRuleAuthGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleAuth(generators)
	scaleRuleAuthGenerator = gen.Struct(reflect.TypeOf(ScaleRuleAuth{}), generators)

	return scaleRuleAuthGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleAuth is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleAuth(gens map[string]gopter.Gen) {
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["TriggerParameter"] = gen.PtrOf(gen.AlphaString())
}

func Test_Secret_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Secret via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecret, SecretGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecret runs a test to see if a specific instance of Secret round trips to JSON and back losslessly
func RunJSONSerializationTestForSecret(subject Secret) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Secret
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Secret instances for property testing - lazily instantiated by SecretGenerator()
var secretGenerator gopter.Gen

// SecretGenerator returns a generator of Secret instances for property testing.
func SecretGenerator() gopter.Gen {
	if secretGenerator != nil {
		return secretGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecret(generators)
	secretGenerator = gen.Struct(reflect.TypeOf(Secret{}), generators)

	return secretGenerator
}

// AddIndependentPropertyGeneratorsForSecret is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecret(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecretVolumeItem_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretVolumeItem via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretVolumeItem, SecretVolumeItemGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretVolumeItem runs a test to see if a specific instance of SecretVolumeItem round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretVolumeItem(subject SecretVolumeItem) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretVolumeItem
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretVolumeItem instances for property testing - lazily instantiated by SecretVolumeItemGenerator()
var secretVolumeItemGenerator gopter.Gen

// SecretVolumeItemGenerator returns a generator of SecretVolumeItem instances for property testing.
func SecretVolumeItemGenerator() gopter.Gen {
	if secretVolumeItemGenerator != nil {
		return secretVolumeItemGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretVolumeItem(generators)
	secretVolumeItemGenerator = gen.Struct(reflect.TypeOf(SecretVolumeItem{}), generators)

	return secretVolumeItemGenerator
}

// AddIndependentPropertyGeneratorsForSecretVolumeItem is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretVolumeItem(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
}

func Test_Service_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService, ServiceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService runs a test to see if a specific instance of Service round trips to JSON and back losslessly
func RunJSONSerializationTestForService(subject Service) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service instances for property testing - lazily instantiated by ServiceGenerator()
var serviceGenerator gopter.Gen

// ServiceGenerator returns a generator of Service instances for property testing.
func ServiceGenerator() gopter.Gen {
	if serviceGenerator != nil {
		return serviceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService(generators)
	serviceGenerator = gen.Struct(reflect.TypeOf(Service{}), generators)

	return serviceGenerator
}

// AddIndependentPropertyGeneratorsForService is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBind_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBind via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBind, ServiceBindGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBind runs a test to see if a specific instance of ServiceBind round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBind(subject ServiceBind) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBind
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBind instances for property testing - lazily instantiated by ServiceBindGenerator()
var serviceBindGenerator gopter.Gen

// ServiceBindGenerator returns a generator of ServiceBind instances for property testing.
func ServiceBindGenerator() gopter.Gen {
	if serviceBindGenerator != nil {
		return serviceBindGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBind(generators)
	serviceBindGenerator = gen.Struct(reflect.TypeOf(ServiceBind{}), generators)

	return serviceBindGenerator
}

// AddIndependentPropertyGeneratorsForServiceBind is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBind(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_TcpScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TcpScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTcpScaleRule, TcpScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTcpScaleRule runs a test to see if a specific instance of TcpScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForTcpScaleRule(subject TcpScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TcpScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TcpScaleRule instances for property testing - lazily instantiated by TcpScaleRuleGenerator()
var tcpScaleRuleGenerator gopter.Gen

// TcpScaleRuleGenerator returns a generator of TcpScaleRule instances for property testing.
// We first initialize tcpScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TcpScaleRuleGenerator() gopter.Gen {
	if tcpScaleRuleGenerator != nil {
		return tcpScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTcpScaleRule(generators)
	tcpScaleRuleGenerator = gen.Struct(reflect.TypeOf(TcpScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTcpScaleRule(generators)
	AddRelatedPropertyGeneratorsForTcpScaleRule(generators)
	tcpScaleRuleGenerator = gen.Struct(reflect.TypeOf(TcpScaleRule{}), generators)

	return tcpScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForTcpScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTcpScaleRule(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForTcpScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTcpScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_Template_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Template via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTemplate, TemplateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTemplate runs a test to see if a specific instance of Template round trips to JSON and back losslessly
func RunJSONSerializationTestForTemplate(subject Template) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Template
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Template instances for property testing - lazily instantiated by TemplateGenerator()
var templateGenerator gopter.Gen

// TemplateGenerator returns a generator of Template instances for property testing.
// We first initialize templateGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TemplateGenerator() gopter.Gen {
	if templateGenerator != nil {
		return templateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTemplate(generators)
	templateGenerator = gen.Struct(reflect.TypeOf(Template{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTemplate(generators)
	AddRelatedPropertyGeneratorsForTemplate(generators)
	templateGenerator = gen.Struct(reflect.TypeOf(Template{}), generators)

	return templateGenerator
}

// AddIndependentPropertyGeneratorsForTemplate is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTemplate(gens map[string]gopter.Gen) {
	gens["RevisionSuffix"] = gen.PtrOf(gen.AlphaString())
	gens["TerminationGracePeriodSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForTemplate is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTemplate(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGenerator())
	gens["InitContainers"] = gen.SliceOf(BaseContainerGenerator())
	gens["Scale"] = gen.PtrOf(ScaleGenerator())
	gens["ServiceBinds"] = gen.SliceOf(ServiceBindGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeGenerator())
}

func Test_TrafficWeight_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TrafficWeight via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrafficWeight, TrafficWeightGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrafficWeight runs a test to see if a specific instance of TrafficWeight round trips to JSON and back losslessly
func RunJSONSerializationTestForTrafficWeight(subject TrafficWeight) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TrafficWeight
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TrafficWeight instances for property testing - lazily instantiated by TrafficWeightGenerator()
var trafficWeightGenerator gopter.Gen

// TrafficWeightGenerator returns a generator of TrafficWeight instances for property testing.
func TrafficWeightGenerator() gopter.Gen {
	if trafficWeightGenerator != nil {
		return trafficWeightGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrafficWeight(generators)
	trafficWeightGenerator = gen.Struct(reflect.TypeOf(TrafficWeight{}), generators)

	return trafficWeightGenerator
}

// AddIndependentPropertyGeneratorsForTrafficWeight is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrafficWeight(gens map[string]gopter.Gen) {
	gens["Label"] = gen.PtrOf(gen.AlphaString())
	gens["LatestRevision"] = gen.PtrOf(gen.Bool())
	gens["RevisionName"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_Volume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume runs a test to see if a specific instance of Volume round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume(subject Volume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume instances for property testing - lazily instantiated by VolumeGenerator()
var volumeGenerator gopter.Gen

// VolumeGenerator returns a generator of Volume instances for property testing.
// We first initialize volumeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeGenerator() gopter.Gen {
	if volumeGenerator != nil {
		return volumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	AddRelatedPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	return volumeGenerator
}

// AddIndependentPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["MountOptions"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageType"] = gen.PtrOf(gen.OneConstOf(Volume_StorageType_AzureFile, Volume_StorageType_EmptyDir, Volume_StorageType_Secret))
}

// AddRelatedPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.SliceOf(SecretVolumeItemGenerator())
}

func Test_VolumeMount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount runs a test to see if a specific instance of VolumeMount round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount(subject VolumeMount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount instances for property testing - lazily instantiated by VolumeMountGenerator()
var volumeMountGenerator gopter.Gen

// VolumeMountGenerator returns a generator of VolumeMount instances for property testing.
func VolumeMountGenerator() gopter.Gen {
	if volumeMountGenerator != nil {
		return volumeMountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount(generators)
	volumeMountGenerator = gen.Struct(reflect.TypeOf(VolumeMount{}), generators)

	return volumeMountGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["SubPath"] = gen.PtrOf(gen.AlphaString())
	gens["VolumeName"] = gen.PtrOf(gen.AlphaString())
}
