// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AllowedAudiencesValidation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AllowedAudiencesValidation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAllowedAudiencesValidation, AllowedAudiencesValidationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAllowedAudiencesValidation runs a test to see if a specific instance of AllowedAudiencesValidation round trips to JSON and back losslessly
func RunJSONSerializationTestForAllowedAudiencesValidation(subject AllowedAudiencesValidation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AllowedAudiencesValidation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AllowedAudiencesValidation instances for property testing - lazily instantiated by
// AllowedAudiencesValidationGenerator()
var allowedAudiencesValidationGenerator gopter.Gen

// AllowedAudiencesValidationGenerator returns a generator of AllowedAudiencesValidation instances for property testing.
func AllowedAudiencesValidationGenerator() gopter.Gen {
	if allowedAudiencesValidationGenerator != nil {
		return allowedAudiencesValidationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAllowedAudiencesValidation(generators)
	allowedAudiencesValidationGenerator = gen.Struct(reflect.TypeOf(AllowedAudiencesValidation{}), generators)

	return allowedAudiencesValidationGenerator
}

// AddIndependentPropertyGeneratorsForAllowedAudiencesValidation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAllowedAudiencesValidation(gens map[string]gopter.Gen) {
	gens["AllowedAudiences"] = gen.SliceOf(gen.AlphaString())
}

func Test_AllowedPrincipals_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AllowedPrincipals via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAllowedPrincipals, AllowedPrincipalsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAllowedPrincipals runs a test to see if a specific instance of AllowedPrincipals round trips to JSON and back losslessly
func RunJSONSerializationTestForAllowedPrincipals(subject AllowedPrincipals) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AllowedPrincipals
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AllowedPrincipals instances for property testing - lazily instantiated by AllowedPrincipalsGenerator()
var allowedPrincipalsGenerator gopter.Gen

// AllowedPrincipalsGenerator returns a generator of AllowedPrincipals instances for property testing.
func AllowedPrincipalsGenerator() gopter.Gen {
	if allowedPrincipalsGenerator != nil {
		return allowedPrincipalsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAllowedPrincipals(generators)
	allowedPrincipalsGenerator = gen.Struct(reflect.TypeOf(AllowedPrincipals{}), generators)

	return allowedPrincipalsGenerator
}

// AddIndependentPropertyGeneratorsForAllowedPrincipals is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAllowedPrincipals(gens map[string]gopter.Gen) {
	gens["Groups"] = gen.SliceOf(gen.AlphaString())
	gens["Identities"] = gen.SliceOf(gen.AlphaString())
}

func Test_AppRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AppRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAppRegistration, AppRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAppRegistration runs a test to see if a specific instance of AppRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForAppRegistration(subject AppRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AppRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AppRegistration instances for property testing - lazily instantiated by AppRegistrationGenerator()
var appRegistrationGenerator gopter.Gen

// AppRegistrationGenerator returns a generator of AppRegistration instances for property testing.
func AppRegistrationGenerator() gopter.Gen {
	if appRegistrationGenerator != nil {
		return appRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppRegistration(generators)
	appRegistrationGenerator = gen.Struct(reflect.TypeOf(AppRegistration{}), generators)

	return appRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForAppRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAppRegistration(gens map[string]gopter.Gen) {
	gens["AppId"] = gen.PtrOf(gen.AlphaString())
	gens["AppSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Apple_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Apple via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApple, AppleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApple runs a test to see if a specific instance of Apple round trips to JSON and back losslessly
func RunJSONSerializationTestForApple(subject Apple) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Apple
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Apple instances for property testing - lazily instantiated by AppleGenerator()
var appleGenerator gopter.Gen

// AppleGenerator returns a generator of Apple instances for property testing.
// We first initialize appleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AppleGenerator() gopter.Gen {
	if appleGenerator != nil {
		return appleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApple(generators)
	appleGenerator = gen.Struct(reflect.TypeOf(Apple{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApple(generators)
	AddRelatedPropertyGeneratorsForApple(generators)
	appleGenerator = gen.Struct(reflect.TypeOf(Apple{}), generators)

	return appleGenerator
}

// AddIndependentPropertyGeneratorsForApple is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApple(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForApple is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApple(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopesGenerator())
	gens["Registration"] = gen.PtrOf(AppleRegistrationGenerator())
}

func Test_AppleRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AppleRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAppleRegistration, AppleRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAppleRegistration runs a test to see if a specific instance of AppleRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForAppleRegistration(subject AppleRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AppleRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AppleRegistration instances for property testing - lazily instantiated by AppleRegistrationGenerator()
var appleRegistrationGenerator gopter.Gen

// AppleRegistrationGenerator returns a generator of AppleRegistration instances for property testing.
func AppleRegistrationGenerator() gopter.Gen {
	if appleRegistrationGenerator != nil {
		return appleRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAppleRegistration(generators)
	appleRegistrationGenerator = gen.Struct(reflect.TypeOf(AppleRegistration{}), generators)

	return appleRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForAppleRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAppleRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AuthConfig_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthConfig_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthConfig_Spec, AuthConfig_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthConfig_Spec runs a test to see if a specific instance of AuthConfig_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthConfig_Spec(subject AuthConfig_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthConfig_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthConfig_Spec instances for property testing - lazily instantiated by AuthConfig_SpecGenerator()
var authConfig_SpecGenerator gopter.Gen

// AuthConfig_SpecGenerator returns a generator of AuthConfig_Spec instances for property testing.
// We first initialize authConfig_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AuthConfig_SpecGenerator() gopter.Gen {
	if authConfig_SpecGenerator != nil {
		return authConfig_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthConfig_Spec(generators)
	authConfig_SpecGenerator = gen.Struct(reflect.TypeOf(AuthConfig_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthConfig_Spec(generators)
	AddRelatedPropertyGeneratorsForAuthConfig_Spec(generators)
	authConfig_SpecGenerator = gen.Struct(reflect.TypeOf(AuthConfig_Spec{}), generators)

	return authConfig_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAuthConfig_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAuthConfig_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForAuthConfig_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAuthConfig_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ContainerApps_AuthConfig_Properties_SpecGenerator())
}

func Test_AuthPlatform_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AuthPlatform via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAuthPlatform, AuthPlatformGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAuthPlatform runs a test to see if a specific instance of AuthPlatform round trips to JSON and back losslessly
func RunJSONSerializationTestForAuthPlatform(subject AuthPlatform) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AuthPlatform
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AuthPlatform instances for property testing - lazily instantiated by AuthPlatformGenerator()
var authPlatformGenerator gopter.Gen

// AuthPlatformGenerator returns a generator of AuthPlatform instances for property testing.
func AuthPlatformGenerator() gopter.Gen {
	if authPlatformGenerator != nil {
		return authPlatformGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAuthPlatform(generators)
	authPlatformGenerator = gen.Struct(reflect.TypeOf(AuthPlatform{}), generators)

	return authPlatformGenerator
}

// AddIndependentPropertyGeneratorsForAuthPlatform is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAuthPlatform(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["RuntimeVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureActiveDirectory_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectory via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectory, AzureActiveDirectoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectory runs a test to see if a specific instance of AzureActiveDirectory round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectory(subject AzureActiveDirectory) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectory
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectory instances for property testing - lazily instantiated by
// AzureActiveDirectoryGenerator()
var azureActiveDirectoryGenerator gopter.Gen

// AzureActiveDirectoryGenerator returns a generator of AzureActiveDirectory instances for property testing.
// We first initialize azureActiveDirectoryGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureActiveDirectoryGenerator() gopter.Gen {
	if azureActiveDirectoryGenerator != nil {
		return azureActiveDirectoryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectory(generators)
	azureActiveDirectoryGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectory{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectory(generators)
	AddRelatedPropertyGeneratorsForAzureActiveDirectory(generators)
	azureActiveDirectoryGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectory{}), generators)

	return azureActiveDirectoryGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectory is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectory(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["IsAutoProvisioned"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForAzureActiveDirectory is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureActiveDirectory(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(AzureActiveDirectoryLoginGenerator())
	gens["Registration"] = gen.PtrOf(AzureActiveDirectoryRegistrationGenerator())
	gens["Validation"] = gen.PtrOf(AzureActiveDirectoryValidationGenerator())
}

func Test_AzureActiveDirectoryLogin_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryLogin via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryLogin, AzureActiveDirectoryLoginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryLogin runs a test to see if a specific instance of AzureActiveDirectoryLogin round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryLogin(subject AzureActiveDirectoryLogin) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryLogin
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryLogin instances for property testing - lazily instantiated by
// AzureActiveDirectoryLoginGenerator()
var azureActiveDirectoryLoginGenerator gopter.Gen

// AzureActiveDirectoryLoginGenerator returns a generator of AzureActiveDirectoryLogin instances for property testing.
func AzureActiveDirectoryLoginGenerator() gopter.Gen {
	if azureActiveDirectoryLoginGenerator != nil {
		return azureActiveDirectoryLoginGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin(generators)
	azureActiveDirectoryLoginGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryLogin{}), generators)

	return azureActiveDirectoryLoginGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryLogin(gens map[string]gopter.Gen) {
	gens["DisableWWWAuthenticate"] = gen.PtrOf(gen.Bool())
	gens["LoginParameters"] = gen.SliceOf(gen.AlphaString())
}

func Test_AzureActiveDirectoryRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryRegistration, AzureActiveDirectoryRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryRegistration runs a test to see if a specific instance of AzureActiveDirectoryRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryRegistration(subject AzureActiveDirectoryRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryRegistration instances for property testing - lazily instantiated by
// AzureActiveDirectoryRegistrationGenerator()
var azureActiveDirectoryRegistrationGenerator gopter.Gen

// AzureActiveDirectoryRegistrationGenerator returns a generator of AzureActiveDirectoryRegistration instances for property testing.
func AzureActiveDirectoryRegistrationGenerator() gopter.Gen {
	if azureActiveDirectoryRegistrationGenerator != nil {
		return azureActiveDirectoryRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration(generators)
	azureActiveDirectoryRegistrationGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryRegistration{}), generators)

	return azureActiveDirectoryRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateIssuer"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateSubjectAlternativeName"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretCertificateThumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
	gens["OpenIdIssuer"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureActiveDirectoryValidation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureActiveDirectoryValidation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureActiveDirectoryValidation, AzureActiveDirectoryValidationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureActiveDirectoryValidation runs a test to see if a specific instance of AzureActiveDirectoryValidation round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureActiveDirectoryValidation(subject AzureActiveDirectoryValidation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureActiveDirectoryValidation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureActiveDirectoryValidation instances for property testing - lazily instantiated by
// AzureActiveDirectoryValidationGenerator()
var azureActiveDirectoryValidationGenerator gopter.Gen

// AzureActiveDirectoryValidationGenerator returns a generator of AzureActiveDirectoryValidation instances for property testing.
// We first initialize azureActiveDirectoryValidationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureActiveDirectoryValidationGenerator() gopter.Gen {
	if azureActiveDirectoryValidationGenerator != nil {
		return azureActiveDirectoryValidationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation(generators)
	azureActiveDirectoryValidationGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryValidation{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation(generators)
	AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation(generators)
	azureActiveDirectoryValidationGenerator = gen.Struct(reflect.TypeOf(AzureActiveDirectoryValidation{}), generators)

	return azureActiveDirectoryValidationGenerator
}

// AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureActiveDirectoryValidation(gens map[string]gopter.Gen) {
	gens["AllowedAudiences"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureActiveDirectoryValidation(gens map[string]gopter.Gen) {
	gens["DefaultAuthorizationPolicy"] = gen.PtrOf(DefaultAuthorizationPolicyGenerator())
	gens["JwtClaimChecks"] = gen.PtrOf(JwtClaimChecksGenerator())
}

func Test_AzureStaticWebApps_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStaticWebApps via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStaticWebApps, AzureStaticWebAppsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStaticWebApps runs a test to see if a specific instance of AzureStaticWebApps round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStaticWebApps(subject AzureStaticWebApps) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStaticWebApps
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStaticWebApps instances for property testing - lazily instantiated by AzureStaticWebAppsGenerator()
var azureStaticWebAppsGenerator gopter.Gen

// AzureStaticWebAppsGenerator returns a generator of AzureStaticWebApps instances for property testing.
// We first initialize azureStaticWebAppsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureStaticWebAppsGenerator() gopter.Gen {
	if azureStaticWebAppsGenerator != nil {
		return azureStaticWebAppsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebApps(generators)
	azureStaticWebAppsGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebApps{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebApps(generators)
	AddRelatedPropertyGeneratorsForAzureStaticWebApps(generators)
	azureStaticWebAppsGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebApps{}), generators)

	return azureStaticWebAppsGenerator
}

// AddIndependentPropertyGeneratorsForAzureStaticWebApps is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStaticWebApps(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForAzureStaticWebApps is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureStaticWebApps(gens map[string]gopter.Gen) {
	gens["Registration"] = gen.PtrOf(AzureStaticWebAppsRegistrationGenerator())
}

func Test_AzureStaticWebAppsRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStaticWebAppsRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStaticWebAppsRegistration, AzureStaticWebAppsRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStaticWebAppsRegistration runs a test to see if a specific instance of AzureStaticWebAppsRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStaticWebAppsRegistration(subject AzureStaticWebAppsRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStaticWebAppsRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStaticWebAppsRegistration instances for property testing - lazily instantiated by
// AzureStaticWebAppsRegistrationGenerator()
var azureStaticWebAppsRegistrationGenerator gopter.Gen

// AzureStaticWebAppsRegistrationGenerator returns a generator of AzureStaticWebAppsRegistration instances for property testing.
func AzureStaticWebAppsRegistrationGenerator() gopter.Gen {
	if azureStaticWebAppsRegistrationGenerator != nil {
		return azureStaticWebAppsRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration(generators)
	azureStaticWebAppsRegistrationGenerator = gen.Struct(reflect.TypeOf(AzureStaticWebAppsRegistration{}), generators)

	return azureStaticWebAppsRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStaticWebAppsRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BlobStorageTokenStore_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BlobStorageTokenStore via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBlobStorageTokenStore, BlobStorageTokenStoreGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBlobStorageTokenStore runs a test to see if a specific instance of BlobStorageTokenStore round trips to JSON and back losslessly
func RunJSONSerializationTestForBlobStorageTokenStore(subject BlobStorageTokenStore) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BlobStorageTokenStore
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BlobStorageTokenStore instances for property testing - lazily instantiated by
// BlobStorageTokenStoreGenerator()
var blobStorageTokenStoreGenerator gopter.Gen

// BlobStorageTokenStoreGenerator returns a generator of BlobStorageTokenStore instances for property testing.
func BlobStorageTokenStoreGenerator() gopter.Gen {
	if blobStorageTokenStoreGenerator != nil {
		return blobStorageTokenStoreGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBlobStorageTokenStore(generators)
	blobStorageTokenStoreGenerator = gen.Struct(reflect.TypeOf(BlobStorageTokenStore{}), generators)

	return blobStorageTokenStoreGenerator
}

// AddIndependentPropertyGeneratorsForBlobStorageTokenStore is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBlobStorageTokenStore(gens map[string]gopter.Gen) {
	gens["SasUrlSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ClientRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientRegistration, ClientRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientRegistration runs a test to see if a specific instance of ClientRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForClientRegistration(subject ClientRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientRegistration instances for property testing - lazily instantiated by ClientRegistrationGenerator()
var clientRegistrationGenerator gopter.Gen

// ClientRegistrationGenerator returns a generator of ClientRegistration instances for property testing.
func ClientRegistrationGenerator() gopter.Gen {
	if clientRegistrationGenerator != nil {
		return clientRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientRegistration(generators)
	clientRegistrationGenerator = gen.Struct(reflect.TypeOf(ClientRegistration{}), generators)

	return clientRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForClientRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerApps_AuthConfig_Properties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerApps_AuthConfig_Properties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerApps_AuthConfig_Properties_Spec, ContainerApps_AuthConfig_Properties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerApps_AuthConfig_Properties_Spec runs a test to see if a specific instance of ContainerApps_AuthConfig_Properties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerApps_AuthConfig_Properties_Spec(subject ContainerApps_AuthConfig_Properties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerApps_AuthConfig_Properties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerApps_AuthConfig_Properties_Spec instances for property testing - lazily instantiated by
// ContainerApps_AuthConfig_Properties_SpecGenerator()
var containerApps_AuthConfig_Properties_SpecGenerator gopter.Gen

// ContainerApps_AuthConfig_Properties_SpecGenerator returns a generator of ContainerApps_AuthConfig_Properties_Spec instances for property testing.
func ContainerApps_AuthConfig_Properties_SpecGenerator() gopter.Gen {
	if containerApps_AuthConfig_Properties_SpecGenerator != nil {
		return containerApps_AuthConfig_Properties_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerApps_AuthConfig_Properties_Spec(generators)
	containerApps_AuthConfig_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerApps_AuthConfig_Properties_Spec{}), generators)

	return containerApps_AuthConfig_Properties_SpecGenerator
}

// AddRelatedPropertyGeneratorsForContainerApps_AuthConfig_Properties_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerApps_AuthConfig_Properties_Spec(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.PtrOf(EncryptionSettingsGenerator())
	gens["GlobalValidation"] = gen.PtrOf(GlobalValidationGenerator())
	gens["HttpSettings"] = gen.PtrOf(HttpSettingsGenerator())
	gens["IdentityProviders"] = gen.PtrOf(IdentityProvidersGenerator())
	gens["Login"] = gen.PtrOf(LoginGenerator())
	gens["Platform"] = gen.PtrOf(AuthPlatformGenerator())
}

func Test_CookieExpiration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookieExpiration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookieExpiration, CookieExpirationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookieExpiration runs a test to see if a specific instance of CookieExpiration round trips to JSON and back losslessly
func RunJSONSerializationTestForCookieExpiration(subject CookieExpiration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookieExpiration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookieExpiration instances for property testing - lazily instantiated by CookieExpirationGenerator()
var cookieExpirationGenerator gopter.Gen

// CookieExpirationGenerator returns a generator of CookieExpiration instances for property testing.
func CookieExpirationGenerator() gopter.Gen {
	if cookieExpirationGenerator != nil {
		return cookieExpirationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookieExpiration(generators)
	cookieExpirationGenerator = gen.Struct(reflect.TypeOf(CookieExpiration{}), generators)

	return cookieExpirationGenerator
}

// AddIndependentPropertyGeneratorsForCookieExpiration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookieExpiration(gens map[string]gopter.Gen) {
	gens["Convention"] = gen.PtrOf(gen.OneConstOf(CookieExpiration_Convention_FixedTime, CookieExpiration_Convention_IdentityProviderDerived))
	gens["TimeToExpiration"] = gen.PtrOf(gen.AlphaString())
}

func Test_CustomOpenIdConnectProvider_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomOpenIdConnectProvider via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomOpenIdConnectProvider, CustomOpenIdConnectProviderGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomOpenIdConnectProvider runs a test to see if a specific instance of CustomOpenIdConnectProvider round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomOpenIdConnectProvider(subject CustomOpenIdConnectProvider) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomOpenIdConnectProvider
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomOpenIdConnectProvider instances for property testing - lazily instantiated by
// CustomOpenIdConnectProviderGenerator()
var customOpenIdConnectProviderGenerator gopter.Gen

// CustomOpenIdConnectProviderGenerator returns a generator of CustomOpenIdConnectProvider instances for property testing.
// We first initialize customOpenIdConnectProviderGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomOpenIdConnectProviderGenerator() gopter.Gen {
	if customOpenIdConnectProviderGenerator != nil {
		return customOpenIdConnectProviderGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider(generators)
	customOpenIdConnectProviderGenerator = gen.Struct(reflect.TypeOf(CustomOpenIdConnectProvider{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider(generators)
	AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider(generators)
	customOpenIdConnectProviderGenerator = gen.Struct(reflect.TypeOf(CustomOpenIdConnectProvider{}), generators)

	return customOpenIdConnectProviderGenerator
}

// AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomOpenIdConnectProvider(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomOpenIdConnectProvider(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(OpenIdConnectLoginGenerator())
	gens["Registration"] = gen.PtrOf(OpenIdConnectRegistrationGenerator())
}

func Test_DefaultAuthorizationPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DefaultAuthorizationPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDefaultAuthorizationPolicy, DefaultAuthorizationPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDefaultAuthorizationPolicy runs a test to see if a specific instance of DefaultAuthorizationPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForDefaultAuthorizationPolicy(subject DefaultAuthorizationPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DefaultAuthorizationPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DefaultAuthorizationPolicy instances for property testing - lazily instantiated by
// DefaultAuthorizationPolicyGenerator()
var defaultAuthorizationPolicyGenerator gopter.Gen

// DefaultAuthorizationPolicyGenerator returns a generator of DefaultAuthorizationPolicy instances for property testing.
// We first initialize defaultAuthorizationPolicyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DefaultAuthorizationPolicyGenerator() gopter.Gen {
	if defaultAuthorizationPolicyGenerator != nil {
		return defaultAuthorizationPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy(generators)
	defaultAuthorizationPolicyGenerator = gen.Struct(reflect.TypeOf(DefaultAuthorizationPolicy{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy(generators)
	AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy(generators)
	defaultAuthorizationPolicyGenerator = gen.Struct(reflect.TypeOf(DefaultAuthorizationPolicy{}), generators)

	return defaultAuthorizationPolicyGenerator
}

// AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDefaultAuthorizationPolicy(gens map[string]gopter.Gen) {
	gens["AllowedApplications"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDefaultAuthorizationPolicy(gens map[string]gopter.Gen) {
	gens["AllowedPrincipals"] = gen.PtrOf(AllowedPrincipalsGenerator())
}

func Test_EncryptionSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionSettings, EncryptionSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionSettings runs a test to see if a specific instance of EncryptionSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionSettings(subject EncryptionSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionSettings instances for property testing - lazily instantiated by EncryptionSettingsGenerator()
var encryptionSettingsGenerator gopter.Gen

// EncryptionSettingsGenerator returns a generator of EncryptionSettings instances for property testing.
func EncryptionSettingsGenerator() gopter.Gen {
	if encryptionSettingsGenerator != nil {
		return encryptionSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionSettings(generators)
	encryptionSettingsGenerator = gen.Struct(reflect.TypeOf(EncryptionSettings{}), generators)

	return encryptionSettingsGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionSettings(gens map[string]gopter.Gen) {
	gens["ContainerAppAuthEncryptionSecretName"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerAppAuthSigningSecretName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Facebook_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Facebook via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFacebook, FacebookGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFacebook runs a test to see if a specific instance of Facebook round trips to JSON and back losslessly
func RunJSONSerializationTestForFacebook(subject Facebook) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Facebook
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Facebook instances for property testing - lazily instantiated by FacebookGenerator()
var facebookGenerator gopter.Gen

// FacebookGenerator returns a generator of Facebook instances for property testing.
// We first initialize facebookGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FacebookGenerator() gopter.Gen {
	if facebookGenerator != nil {
		return facebookGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFacebook(generators)
	facebookGenerator = gen.Struct(reflect.TypeOf(Facebook{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFacebook(generators)
	AddRelatedPropertyGeneratorsForFacebook(generators)
	facebookGenerator = gen.Struct(reflect.TypeOf(Facebook{}), generators)

	return facebookGenerator
}

// AddIndependentPropertyGeneratorsForFacebook is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFacebook(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GraphApiVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFacebook is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFacebook(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopesGenerator())
	gens["Registration"] = gen.PtrOf(AppRegistrationGenerator())
}

func Test_ForwardProxy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ForwardProxy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForForwardProxy, ForwardProxyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForForwardProxy runs a test to see if a specific instance of ForwardProxy round trips to JSON and back losslessly
func RunJSONSerializationTestForForwardProxy(subject ForwardProxy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ForwardProxy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ForwardProxy instances for property testing - lazily instantiated by ForwardProxyGenerator()
var forwardProxyGenerator gopter.Gen

// ForwardProxyGenerator returns a generator of ForwardProxy instances for property testing.
func ForwardProxyGenerator() gopter.Gen {
	if forwardProxyGenerator != nil {
		return forwardProxyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForForwardProxy(generators)
	forwardProxyGenerator = gen.Struct(reflect.TypeOf(ForwardProxy{}), generators)

	return forwardProxyGenerator
}

// AddIndependentPropertyGeneratorsForForwardProxy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForForwardProxy(gens map[string]gopter.Gen) {
	gens["Convention"] = gen.PtrOf(gen.OneConstOf(ForwardProxy_Convention_Custom, ForwardProxy_Convention_NoProxy, ForwardProxy_Convention_Standard))
	gens["CustomHostHeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomProtoHeaderName"] = gen.PtrOf(gen.AlphaString())
}

func Test_GitHub_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitHub via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitHub, GitHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitHub runs a test to see if a specific instance of GitHub round trips to JSON and back losslessly
func RunJSONSerializationTestForGitHub(subject GitHub) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitHub
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitHub instances for property testing - lazily instantiated by GitHubGenerator()
var gitHubGenerator gopter.Gen

// GitHubGenerator returns a generator of GitHub instances for property testing.
// We first initialize gitHubGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func GitHubGenerator() gopter.Gen {
	if gitHubGenerator != nil {
		return gitHubGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitHub(generators)
	gitHubGenerator = gen.Struct(reflect.TypeOf(GitHub{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitHub(generators)
	AddRelatedPropertyGeneratorsForGitHub(generators)
	gitHubGenerator = gen.Struct(reflect.TypeOf(GitHub{}), generators)

	return gitHubGenerator
}

// AddIndependentPropertyGeneratorsForGitHub is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitHub(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForGitHub is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGitHub(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopesGenerator())
	gens["Registration"] = gen.PtrOf(ClientRegistrationGenerator())
}

func Test_GlobalValidation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GlobalValidation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGlobalValidation, GlobalValidationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGlobalValidation runs a test to see if a specific instance of GlobalValidation round trips to JSON and back losslessly
func RunJSONSerializationTestForGlobalValidation(subject GlobalValidation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GlobalValidation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GlobalValidation instances for property testing - lazily instantiated by GlobalValidationGenerator()
var globalValidationGenerator gopter.Gen

// GlobalValidationGenerator returns a generator of GlobalValidation instances for property testing.
func GlobalValidationGenerator() gopter.Gen {
	if globalValidationGenerator != nil {
		return globalValidationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGlobalValidation(generators)
	globalValidationGenerator = gen.Struct(reflect.TypeOf(GlobalValidation{}), generators)

	return globalValidationGenerator
}

// AddIndependentPropertyGeneratorsForGlobalValidation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGlobalValidation(gens map[string]gopter.Gen) {
	gens["ExcludedPaths"] = gen.SliceOf(gen.AlphaString())
	gens["RedirectToProvider"] = gen.PtrOf(gen.AlphaString())
	gens["UnauthenticatedClientAction"] = gen.PtrOf(gen.OneConstOf(
		GlobalValidation_UnauthenticatedClientAction_AllowAnonymous,
		GlobalValidation_UnauthenticatedClientAction_RedirectToLoginPage,
		GlobalValidation_UnauthenticatedClientAction_Return401,
		GlobalValidation_UnauthenticatedClientAction_Return403))
}

func Test_Google_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Google via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGoogle, GoogleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGoogle runs a test to see if a specific instance of Google round trips to JSON and back losslessly
func RunJSONSerializationTestForGoogle(subject Google) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Google
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Google instances for property testing - lazily instantiated by GoogleGenerator()
var googleGenerator gopter.Gen

// GoogleGenerator returns a generator of Google instances for property testing.
// We first initialize googleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func GoogleGenerator() gopter.Gen {
	if googleGenerator != nil {
		return googleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGoogle(generators)
	googleGenerator = gen.Struct(reflect.TypeOf(Google{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGoogle(generators)
	AddRelatedPropertyGeneratorsForGoogle(generators)
	googleGenerator = gen.Struct(reflect.TypeOf(Google{}), generators)

	return googleGenerator
}

// AddIndependentPropertyGeneratorsForGoogle is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGoogle(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForGoogle is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGoogle(gens map[string]gopter.Gen) {
	gens["Login"] = gen.PtrOf(LoginScopesGenerator())
	gens["Registration"] = gen.PtrOf(ClientRegistrationGenerator())
	gens["Validation"] = gen.PtrOf(AllowedAudiencesValidationGenerator())
}

func Test_HttpSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpSettings, HttpSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpSettings runs a test to see if a specific instance of HttpSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpSettings(subject HttpSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpSettings instances for property testing - lazily instantiated by HttpSettingsGenerator()
var httpSettingsGenerator gopter.Gen

// HttpSettingsGenerator returns a generator of HttpSettings instances for property testing.
// We first initialize httpSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HttpSettingsGenerator() gopter.Gen {
	if httpSettingsGenerator != nil {
		return httpSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettings(generators)
	httpSettingsGenerator = gen.Struct(reflect.TypeOf(HttpSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettings(generators)
	AddRelatedPropertyGeneratorsForHttpSettings(generators)
	httpSettingsGenerator = gen.Struct(reflect.TypeOf(HttpSettings{}), generators)

	return httpSettingsGenerator
}

// AddIndependentPropertyGeneratorsForHttpSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpSettings(gens map[string]gopter.Gen) {
	gens["RequireHttps"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForHttpSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHttpSettings(gens map[string]gopter.Gen) {
	gens["ForwardProxy"] = gen.PtrOf(ForwardProxyGenerator())
	gens["Routes"] = gen.PtrOf(HttpSettingsRoutesGenerator())
}

func Test_HttpSettingsRoutes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpSettingsRoutes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpSettingsRoutes, HttpSettingsRoutesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpSettingsRoutes runs a test to see if a specific instance of HttpSettingsRoutes round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpSettingsRoutes(subject HttpSettingsRoutes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpSettingsRoutes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpSettingsRoutes instances for property testing - lazily instantiated by HttpSettingsRoutesGenerator()
var httpSettingsRoutesGenerator gopter.Gen

// HttpSettingsRoutesGenerator returns a generator of HttpSettingsRoutes instances for property testing.
func HttpSettingsRoutesGenerator() gopter.Gen {
	if httpSettingsRoutesGenerator != nil {
		return httpSettingsRoutesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpSettingsRoutes(generators)
	httpSettingsRoutesGenerator = gen.Struct(reflect.TypeOf(HttpSettingsRoutes{}), generators)

	return httpSettingsRoutesGenerator
}

// AddIndependentPropertyGeneratorsForHttpSettingsRoutes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpSettingsRoutes(gens map[string]gopter.Gen) {
	gens["ApiPrefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_IdentityProviders_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityProviders via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityProviders, IdentityProvidersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityProviders runs a test to see if a specific instance of IdentityProviders round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityProviders(subject IdentityProviders) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityProviders
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityProviders instances for property testing - lazily instantiated by IdentityProvidersGenerator()
var identityProvidersGenerator gopter.Gen

// IdentityProvidersGenerator returns a generator of IdentityProviders instances for property testing.
func IdentityProvidersGenerator() gopter.Gen {
	if identityProvidersGenerator != nil {
		return identityProvidersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForIdentityProviders(generators)
	identityProvidersGenerator = gen.Struct(reflect.TypeOf(IdentityProviders{}), generators)

	return identityProvidersGenerator
}

// AddRelatedPropertyGeneratorsForIdentityProviders is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityProviders(gens map[string]gopter.Gen) {
	gens["Apple"] = gen.PtrOf(AppleGenerator())
	gens["AzureActiveDirectory"] = gen.PtrOf(AzureActiveDirectoryGenerator())
	gens["AzureStaticWebApps"] = gen.PtrOf(AzureStaticWebAppsGenerator())
	gens["CustomOpenIdConnectProviders"] = gen.MapOf(
		gen.AlphaString(),
		CustomOpenIdConnectProviderGenerator())
	gens["Facebook"] = gen.PtrOf(FacebookGenerator())
	gens["GitHub"] = gen.PtrOf(GitHubGenerator())
	gens["Google"] = gen.PtrOf(GoogleGenerator())
	gens["Twitter"] = gen.PtrOf(TwitterGenerator())
}

func Test_JwtClaimChecks_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JwtClaimChecks via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJwtClaimChecks, JwtClaimChecksGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJwtClaimChecks runs a test to see if a specific instance of JwtClaimChecks round trips to JSON and back losslessly
func RunJSONSerializationTestForJwtClaimChecks(subject JwtClaimChecks) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JwtClaimChecks
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JwtClaimChecks instances for property testing - lazily instantiated by JwtClaimChecksGenerator()
var jwtClaimChecksGenerator gopter.Gen

// JwtClaimChecksGenerator returns a generator of JwtClaimChecks instances for property testing.
func JwtClaimChecksGenerator() gopter.Gen {
	if jwtClaimChecksGenerator != nil {
		return jwtClaimChecksGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJwtClaimChecks(generators)
	jwtClaimChecksGenerator = gen.Struct(reflect.TypeOf(JwtClaimChecks{}), generators)

	return jwtClaimChecksGenerator
}

// AddIndependentPropertyGeneratorsForJwtClaimChecks is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJwtClaimChecks(gens map[string]gopter.Gen) {
	gens["AllowedClientApplications"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_Login_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Login via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogin, LoginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogin runs a test to see if a specific instance of Login round trips to JSON and back losslessly
func RunJSONSerializationTestForLogin(subject Login) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Login
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Login instances for property testing - lazily instantiated by LoginGenerator()
var loginGenerator gopter.Gen

// LoginGenerator returns a generator of Login instances for property testing.
// We first initialize loginGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LoginGenerator() gopter.Gen {
	if loginGenerator != nil {
		return loginGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogin(generators)
	loginGenerator = gen.Struct(reflect.TypeOf(Login{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogin(generators)
	AddRelatedPropertyGeneratorsForLogin(generators)
	loginGenerator = gen.Struct(reflect.TypeOf(Login{}), generators)

	return loginGenerator
}

// AddIndependentPropertyGeneratorsForLogin is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogin(gens map[string]gopter.Gen) {
	gens["AllowedExternalRedirectUrls"] = gen.SliceOf(gen.AlphaString())
	gens["PreserveUrlFragmentsForLogins"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLogin is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogin(gens map[string]gopter.Gen) {
	gens["CookieExpiration"] = gen.PtrOf(CookieExpirationGenerator())
	gens["Nonce"] = gen.PtrOf(NonceGenerator())
	gens["Routes"] = gen.PtrOf(LoginRoutesGenerator())
	gens["TokenStore"] = gen.PtrOf(TokenStoreGenerator())
}

func Test_LoginRoutes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoginRoutes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoginRoutes, LoginRoutesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoginRoutes runs a test to see if a specific instance of LoginRoutes round trips to JSON and back losslessly
func RunJSONSerializationTestForLoginRoutes(subject LoginRoutes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoginRoutes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoginRoutes instances for property testing - lazily instantiated by LoginRoutesGenerator()
var loginRoutesGenerator gopter.Gen

// LoginRoutesGenerator returns a generator of LoginRoutes instances for property testing.
func LoginRoutesGenerator() gopter.Gen {
	if loginRoutesGenerator != nil {
		return loginRoutesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoginRoutes(generators)
	loginRoutesGenerator = gen.Struct(reflect.TypeOf(LoginRoutes{}), generators)

	return loginRoutesGenerator
}

// AddIndependentPropertyGeneratorsForLoginRoutes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoginRoutes(gens map[string]gopter.Gen) {
	gens["LogoutEndpoint"] = gen.PtrOf(gen.AlphaString())
}

func Test_LoginScopes_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoginScopes via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoginScopes, LoginScopesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoginScopes runs a test to see if a specific instance of LoginScopes round trips to JSON and back losslessly
func RunJSONSerializationTestForLoginScopes(subject LoginScopes) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoginScopes
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoginScopes instances for property testing - lazily instantiated by LoginScopesGenerator()
var loginScopesGenerator gopter.Gen

// LoginScopesGenerator returns a generator of LoginScopes instances for property testing.
func LoginScopesGenerator() gopter.Gen {
	if loginScopesGenerator != nil {
		return loginScopesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLoginScopes(generators)
	loginScopesGenerator = gen.Struct(reflect.TypeOf(LoginScopes{}), generators)

	return loginScopesGenerator
}

// AddIndependentPropertyGeneratorsForLoginScopes is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLoginScopes(gens map[string]gopter.Gen) {
	gens["Scopes"] = gen.SliceOf(gen.AlphaString())
}

func Test_Nonce_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Nonce via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNonce, NonceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNonce runs a test to see if a specific instance of Nonce round trips to JSON and back losslessly
func RunJSONSerializationTestForNonce(subject Nonce) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Nonce
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Nonce instances for property testing - lazily instantiated by NonceGenerator()
var nonceGenerator gopter.Gen

// NonceGenerator returns a generator of Nonce instances for property testing.
func NonceGenerator() gopter.Gen {
	if nonceGenerator != nil {
		return nonceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNonce(generators)
	nonceGenerator = gen.Struct(reflect.TypeOf(Nonce{}), generators)

	return nonceGenerator
}

// AddIndependentPropertyGeneratorsForNonce is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNonce(gens map[string]gopter.Gen) {
	gens["NonceExpirationInterval"] = gen.PtrOf(gen.AlphaString())
	gens["ValidateNonce"] = gen.PtrOf(gen.Bool())
}

func Test_OpenIdConnectClientCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectClientCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectClientCredential, OpenIdConnectClientCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectClientCredential runs a test to see if a specific instance of OpenIdConnectClientCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectClientCredential(subject OpenIdConnectClientCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectClientCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectClientCredential instances for property testing - lazily instantiated by
// OpenIdConnectClientCredentialGenerator()
var openIdConnectClientCredentialGenerator gopter.Gen

// OpenIdConnectClientCredentialGenerator returns a generator of OpenIdConnectClientCredential instances for property testing.
func OpenIdConnectClientCredentialGenerator() gopter.Gen {
	if openIdConnectClientCredentialGenerator != nil {
		return openIdConnectClientCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential(generators)
	openIdConnectClientCredentialGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectClientCredential{}), generators)

	return openIdConnectClientCredentialGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectClientCredential(gens map[string]gopter.Gen) {
	gens["ClientSecretSettingName"] = gen.PtrOf(gen.AlphaString())
	gens["Method"] = gen.PtrOf(gen.OneConstOf(OpenIdConnectClientCredential_Method_ClientSecretPost))
}

func Test_OpenIdConnectConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectConfig, OpenIdConnectConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectConfig runs a test to see if a specific instance of OpenIdConnectConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectConfig(subject OpenIdConnectConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectConfig instances for property testing - lazily instantiated by
// OpenIdConnectConfigGenerator()
var openIdConnectConfigGenerator gopter.Gen

// OpenIdConnectConfigGenerator returns a generator of OpenIdConnectConfig instances for property testing.
func OpenIdConnectConfigGenerator() gopter.Gen {
	if openIdConnectConfigGenerator != nil {
		return openIdConnectConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectConfig(generators)
	openIdConnectConfigGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectConfig{}), generators)

	return openIdConnectConfigGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectConfig(gens map[string]gopter.Gen) {
	gens["AuthorizationEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["CertificationUri"] = gen.PtrOf(gen.AlphaString())
	gens["Issuer"] = gen.PtrOf(gen.AlphaString())
	gens["TokenEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["WellKnownOpenIdConfiguration"] = gen.PtrOf(gen.AlphaString())
}

func Test_OpenIdConnectLogin_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectLogin via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectLogin, OpenIdConnectLoginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectLogin runs a test to see if a specific instance of OpenIdConnectLogin round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectLogin(subject OpenIdConnectLogin) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectLogin
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectLogin instances for property testing - lazily instantiated by OpenIdConnectLoginGenerator()
var openIdConnectLoginGenerator gopter.Gen

// OpenIdConnectLoginGenerator returns a generator of OpenIdConnectLogin instances for property testing.
func OpenIdConnectLoginGenerator() gopter.Gen {
	if openIdConnectLoginGenerator != nil {
		return openIdConnectLoginGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectLogin(generators)
	openIdConnectLoginGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectLogin{}), generators)

	return openIdConnectLoginGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectLogin is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectLogin(gens map[string]gopter.Gen) {
	gens["NameClaimType"] = gen.PtrOf(gen.AlphaString())
	gens["Scopes"] = gen.SliceOf(gen.AlphaString())
}

func Test_OpenIdConnectRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenIdConnectRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenIdConnectRegistration, OpenIdConnectRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenIdConnectRegistration runs a test to see if a specific instance of OpenIdConnectRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenIdConnectRegistration(subject OpenIdConnectRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenIdConnectRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenIdConnectRegistration instances for property testing - lazily instantiated by
// OpenIdConnectRegistrationGenerator()
var openIdConnectRegistrationGenerator gopter.Gen

// OpenIdConnectRegistrationGenerator returns a generator of OpenIdConnectRegistration instances for property testing.
// We first initialize openIdConnectRegistrationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OpenIdConnectRegistrationGenerator() gopter.Gen {
	if openIdConnectRegistrationGenerator != nil {
		return openIdConnectRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectRegistration(generators)
	openIdConnectRegistrationGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectRegistration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenIdConnectRegistration(generators)
	AddRelatedPropertyGeneratorsForOpenIdConnectRegistration(generators)
	openIdConnectRegistrationGenerator = gen.Struct(reflect.TypeOf(OpenIdConnectRegistration{}), generators)

	return openIdConnectRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForOpenIdConnectRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenIdConnectRegistration(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOpenIdConnectRegistration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenIdConnectRegistration(gens map[string]gopter.Gen) {
	gens["ClientCredential"] = gen.PtrOf(OpenIdConnectClientCredentialGenerator())
	gens["OpenIdConnectConfiguration"] = gen.PtrOf(OpenIdConnectConfigGenerator())
}

func Test_TokenStore_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenStore via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenStore, TokenStoreGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenStore runs a test to see if a specific instance of TokenStore round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenStore(subject TokenStore) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenStore
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenStore instances for property testing - lazily instantiated by TokenStoreGenerator()
var tokenStoreGenerator gopter.Gen

// TokenStoreGenerator returns a generator of TokenStore instances for property testing.
// We first initialize tokenStoreGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TokenStoreGenerator() gopter.Gen {
	if tokenStoreGenerator != nil {
		return tokenStoreGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenStore(generators)
	tokenStoreGenerator = gen.Struct(reflect.TypeOf(TokenStore{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenStore(generators)
	AddRelatedPropertyGeneratorsForTokenStore(generators)
	tokenStoreGenerator = gen.Struct(reflect.TypeOf(TokenStore{}), generators)

	return tokenStoreGenerator
}

// AddIndependentPropertyGeneratorsForTokenStore is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenStore(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["TokenRefreshExtensionHours"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForTokenStore is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenStore(gens map[string]gopter.Gen) {
	gens["AzureBlobStorage"] = gen.PtrOf(BlobStorageTokenStoreGenerator())
}

func Test_Twitter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Twitter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTwitter, TwitterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTwitter runs a test to see if a specific instance of Twitter round trips to JSON and back losslessly
func RunJSONSerializationTestForTwitter(subject Twitter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Twitter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Twitter instances for property testing - lazily instantiated by TwitterGenerator()
var twitterGenerator gopter.Gen

// TwitterGenerator returns a generator of Twitter instances for property testing.
// We first initialize twitterGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TwitterGenerator() gopter.Gen {
	if twitterGenerator != nil {
		return twitterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitter(generators)
	twitterGenerator = gen.Struct(reflect.TypeOf(Twitter{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitter(generators)
	AddRelatedPropertyGeneratorsForTwitter(generators)
	twitterGenerator = gen.Struct(reflect.TypeOf(Twitter{}), generators)

	return twitterGenerator
}

// AddIndependentPropertyGeneratorsForTwitter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTwitter(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForTwitter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTwitter(gens map[string]gopter.Gen) {
	gens["Registration"] = gen.PtrOf(TwitterRegistrationGenerator())
}

func Test_TwitterRegistration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TwitterRegistration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTwitterRegistration, TwitterRegistrationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTwitterRegistration runs a test to see if a specific instance of TwitterRegistration round trips to JSON and back losslessly
func RunJSONSerializationTestForTwitterRegistration(subject TwitterRegistration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TwitterRegistration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TwitterRegistration instances for property testing - lazily instantiated by
// TwitterRegistrationGenerator()
var twitterRegistrationGenerator gopter.Gen

// TwitterRegistrationGenerator returns a generator of TwitterRegistration instances for property testing.
func TwitterRegistrationGenerator() gopter.Gen {
	if twitterRegistrationGenerator != nil {
		return twitterRegistrationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTwitterRegistration(generators)
	twitterRegistrationGenerator = gen.Struct(reflect.TypeOf(TwitterRegistration{}), generators)

	return twitterRegistrationGenerator
}

// AddIndependentPropertyGeneratorsForTwitterRegistration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTwitterRegistration(gens map[string]gopter.Gen) {
	gens["ConsumerKey"] = gen.PtrOf(gen.AlphaString())
	gens["ConsumerSecretSettingName"] = gen.PtrOf(gen.AlphaString())
}
