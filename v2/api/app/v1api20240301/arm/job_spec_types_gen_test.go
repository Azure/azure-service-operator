// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_JobConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JobConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJobConfiguration, JobConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJobConfiguration runs a test to see if a specific instance of JobConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForJobConfiguration(subject JobConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JobConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JobConfiguration instances for property testing - lazily instantiated by JobConfigurationGenerator()
var jobConfigurationGenerator gopter.Gen

// JobConfigurationGenerator returns a generator of JobConfiguration instances for property testing.
// We first initialize jobConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func JobConfigurationGenerator() gopter.Gen {
	if jobConfigurationGenerator != nil {
		return jobConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobConfiguration(generators)
	jobConfigurationGenerator = gen.Struct(reflect.TypeOf(JobConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobConfiguration(generators)
	AddRelatedPropertyGeneratorsForJobConfiguration(generators)
	jobConfigurationGenerator = gen.Struct(reflect.TypeOf(JobConfiguration{}), generators)

	return jobConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForJobConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJobConfiguration(gens map[string]gopter.Gen) {
	gens["ReplicaRetryLimit"] = gen.PtrOf(gen.Int())
	gens["ReplicaTimeout"] = gen.PtrOf(gen.Int())
	gens["TriggerType"] = gen.PtrOf(gen.OneConstOf(JobConfiguration_TriggerType_Event, JobConfiguration_TriggerType_Manual, JobConfiguration_TriggerType_Schedule))
}

// AddRelatedPropertyGeneratorsForJobConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForJobConfiguration(gens map[string]gopter.Gen) {
	gens["EventTriggerConfig"] = gen.PtrOf(JobConfiguration_EventTriggerConfigGenerator())
	gens["ManualTriggerConfig"] = gen.PtrOf(JobConfiguration_ManualTriggerConfigGenerator())
	gens["Registries"] = gen.SliceOf(RegistryCredentialsGenerator())
	gens["ScheduleTriggerConfig"] = gen.PtrOf(JobConfiguration_ScheduleTriggerConfigGenerator())
	gens["Secrets"] = gen.SliceOf(SecretGenerator())
}

func Test_JobConfiguration_EventTriggerConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JobConfiguration_EventTriggerConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJobConfiguration_EventTriggerConfig, JobConfiguration_EventTriggerConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJobConfiguration_EventTriggerConfig runs a test to see if a specific instance of JobConfiguration_EventTriggerConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForJobConfiguration_EventTriggerConfig(subject JobConfiguration_EventTriggerConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JobConfiguration_EventTriggerConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JobConfiguration_EventTriggerConfig instances for property testing - lazily instantiated by
// JobConfiguration_EventTriggerConfigGenerator()
var jobConfiguration_EventTriggerConfigGenerator gopter.Gen

// JobConfiguration_EventTriggerConfigGenerator returns a generator of JobConfiguration_EventTriggerConfig instances for property testing.
// We first initialize jobConfiguration_EventTriggerConfigGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func JobConfiguration_EventTriggerConfigGenerator() gopter.Gen {
	if jobConfiguration_EventTriggerConfigGenerator != nil {
		return jobConfiguration_EventTriggerConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobConfiguration_EventTriggerConfig(generators)
	jobConfiguration_EventTriggerConfigGenerator = gen.Struct(reflect.TypeOf(JobConfiguration_EventTriggerConfig{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobConfiguration_EventTriggerConfig(generators)
	AddRelatedPropertyGeneratorsForJobConfiguration_EventTriggerConfig(generators)
	jobConfiguration_EventTriggerConfigGenerator = gen.Struct(reflect.TypeOf(JobConfiguration_EventTriggerConfig{}), generators)

	return jobConfiguration_EventTriggerConfigGenerator
}

// AddIndependentPropertyGeneratorsForJobConfiguration_EventTriggerConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJobConfiguration_EventTriggerConfig(gens map[string]gopter.Gen) {
	gens["Parallelism"] = gen.PtrOf(gen.Int())
	gens["ReplicaCompletionCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForJobConfiguration_EventTriggerConfig is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForJobConfiguration_EventTriggerConfig(gens map[string]gopter.Gen) {
	gens["Scale"] = gen.PtrOf(JobScaleGenerator())
}

func Test_JobConfiguration_ManualTriggerConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JobConfiguration_ManualTriggerConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJobConfiguration_ManualTriggerConfig, JobConfiguration_ManualTriggerConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJobConfiguration_ManualTriggerConfig runs a test to see if a specific instance of JobConfiguration_ManualTriggerConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForJobConfiguration_ManualTriggerConfig(subject JobConfiguration_ManualTriggerConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JobConfiguration_ManualTriggerConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JobConfiguration_ManualTriggerConfig instances for property testing - lazily instantiated by
// JobConfiguration_ManualTriggerConfigGenerator()
var jobConfiguration_ManualTriggerConfigGenerator gopter.Gen

// JobConfiguration_ManualTriggerConfigGenerator returns a generator of JobConfiguration_ManualTriggerConfig instances for property testing.
func JobConfiguration_ManualTriggerConfigGenerator() gopter.Gen {
	if jobConfiguration_ManualTriggerConfigGenerator != nil {
		return jobConfiguration_ManualTriggerConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobConfiguration_ManualTriggerConfig(generators)
	jobConfiguration_ManualTriggerConfigGenerator = gen.Struct(reflect.TypeOf(JobConfiguration_ManualTriggerConfig{}), generators)

	return jobConfiguration_ManualTriggerConfigGenerator
}

// AddIndependentPropertyGeneratorsForJobConfiguration_ManualTriggerConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJobConfiguration_ManualTriggerConfig(gens map[string]gopter.Gen) {
	gens["Parallelism"] = gen.PtrOf(gen.Int())
	gens["ReplicaCompletionCount"] = gen.PtrOf(gen.Int())
}

func Test_JobConfiguration_ScheduleTriggerConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JobConfiguration_ScheduleTriggerConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJobConfiguration_ScheduleTriggerConfig, JobConfiguration_ScheduleTriggerConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJobConfiguration_ScheduleTriggerConfig runs a test to see if a specific instance of JobConfiguration_ScheduleTriggerConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForJobConfiguration_ScheduleTriggerConfig(subject JobConfiguration_ScheduleTriggerConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JobConfiguration_ScheduleTriggerConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JobConfiguration_ScheduleTriggerConfig instances for property testing - lazily instantiated by
// JobConfiguration_ScheduleTriggerConfigGenerator()
var jobConfiguration_ScheduleTriggerConfigGenerator gopter.Gen

// JobConfiguration_ScheduleTriggerConfigGenerator returns a generator of JobConfiguration_ScheduleTriggerConfig instances for property testing.
func JobConfiguration_ScheduleTriggerConfigGenerator() gopter.Gen {
	if jobConfiguration_ScheduleTriggerConfigGenerator != nil {
		return jobConfiguration_ScheduleTriggerConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobConfiguration_ScheduleTriggerConfig(generators)
	jobConfiguration_ScheduleTriggerConfigGenerator = gen.Struct(reflect.TypeOf(JobConfiguration_ScheduleTriggerConfig{}), generators)

	return jobConfiguration_ScheduleTriggerConfigGenerator
}

// AddIndependentPropertyGeneratorsForJobConfiguration_ScheduleTriggerConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJobConfiguration_ScheduleTriggerConfig(gens map[string]gopter.Gen) {
	gens["CronExpression"] = gen.PtrOf(gen.AlphaString())
	gens["Parallelism"] = gen.PtrOf(gen.Int())
	gens["ReplicaCompletionCount"] = gen.PtrOf(gen.Int())
}

func Test_JobScale_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JobScale via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJobScale, JobScaleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJobScale runs a test to see if a specific instance of JobScale round trips to JSON and back losslessly
func RunJSONSerializationTestForJobScale(subject JobScale) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JobScale
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JobScale instances for property testing - lazily instantiated by JobScaleGenerator()
var jobScaleGenerator gopter.Gen

// JobScaleGenerator returns a generator of JobScale instances for property testing.
// We first initialize jobScaleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func JobScaleGenerator() gopter.Gen {
	if jobScaleGenerator != nil {
		return jobScaleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobScale(generators)
	jobScaleGenerator = gen.Struct(reflect.TypeOf(JobScale{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobScale(generators)
	AddRelatedPropertyGeneratorsForJobScale(generators)
	jobScaleGenerator = gen.Struct(reflect.TypeOf(JobScale{}), generators)

	return jobScaleGenerator
}

// AddIndependentPropertyGeneratorsForJobScale is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJobScale(gens map[string]gopter.Gen) {
	gens["MaxExecutions"] = gen.PtrOf(gen.Int())
	gens["MinExecutions"] = gen.PtrOf(gen.Int())
	gens["PollingInterval"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForJobScale is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForJobScale(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(JobScaleRuleGenerator())
}

func Test_JobScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JobScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJobScaleRule, JobScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJobScaleRule runs a test to see if a specific instance of JobScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForJobScaleRule(subject JobScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JobScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JobScaleRule instances for property testing - lazily instantiated by JobScaleRuleGenerator()
var jobScaleRuleGenerator gopter.Gen

// JobScaleRuleGenerator returns a generator of JobScaleRule instances for property testing.
// We first initialize jobScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func JobScaleRuleGenerator() gopter.Gen {
	if jobScaleRuleGenerator != nil {
		return jobScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobScaleRule(generators)
	jobScaleRuleGenerator = gen.Struct(reflect.TypeOf(JobScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJobScaleRule(generators)
	AddRelatedPropertyGeneratorsForJobScaleRule(generators)
	jobScaleRuleGenerator = gen.Struct(reflect.TypeOf(JobScaleRule{}), generators)

	return jobScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForJobScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJobScaleRule(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForJobScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForJobScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_JobTemplate_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of JobTemplate via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJobTemplate, JobTemplateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJobTemplate runs a test to see if a specific instance of JobTemplate round trips to JSON and back losslessly
func RunJSONSerializationTestForJobTemplate(subject JobTemplate) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual JobTemplate
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of JobTemplate instances for property testing - lazily instantiated by JobTemplateGenerator()
var jobTemplateGenerator gopter.Gen

// JobTemplateGenerator returns a generator of JobTemplate instances for property testing.
func JobTemplateGenerator() gopter.Gen {
	if jobTemplateGenerator != nil {
		return jobTemplateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForJobTemplate(generators)
	jobTemplateGenerator = gen.Struct(reflect.TypeOf(JobTemplate{}), generators)

	return jobTemplateGenerator
}

// AddRelatedPropertyGeneratorsForJobTemplate is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForJobTemplate(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGenerator())
	gens["InitContainers"] = gen.SliceOf(BaseContainerGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeGenerator())
}

func Test_Job_Properties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Job_Properties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJob_Properties_Spec, Job_Properties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJob_Properties_Spec runs a test to see if a specific instance of Job_Properties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForJob_Properties_Spec(subject Job_Properties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Job_Properties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Job_Properties_Spec instances for property testing - lazily instantiated by
// Job_Properties_SpecGenerator()
var job_Properties_SpecGenerator gopter.Gen

// Job_Properties_SpecGenerator returns a generator of Job_Properties_Spec instances for property testing.
// We first initialize job_Properties_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Job_Properties_SpecGenerator() gopter.Gen {
	if job_Properties_SpecGenerator != nil {
		return job_Properties_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJob_Properties_Spec(generators)
	job_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(Job_Properties_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJob_Properties_Spec(generators)
	AddRelatedPropertyGeneratorsForJob_Properties_Spec(generators)
	job_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(Job_Properties_Spec{}), generators)

	return job_Properties_SpecGenerator
}

// AddIndependentPropertyGeneratorsForJob_Properties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJob_Properties_Spec(gens map[string]gopter.Gen) {
	gens["EnvironmentId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkloadProfileName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForJob_Properties_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForJob_Properties_Spec(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(JobConfigurationGenerator())
	gens["Template"] = gen.PtrOf(JobTemplateGenerator())
}

func Test_Job_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Job_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForJob_Spec, Job_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForJob_Spec runs a test to see if a specific instance of Job_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForJob_Spec(subject Job_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Job_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Job_Spec instances for property testing - lazily instantiated by Job_SpecGenerator()
var job_SpecGenerator gopter.Gen

// Job_SpecGenerator returns a generator of Job_Spec instances for property testing.
// We first initialize job_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Job_SpecGenerator() gopter.Gen {
	if job_SpecGenerator != nil {
		return job_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJob_Spec(generators)
	job_SpecGenerator = gen.Struct(reflect.TypeOf(Job_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForJob_Spec(generators)
	AddRelatedPropertyGeneratorsForJob_Spec(generators)
	job_SpecGenerator = gen.Struct(reflect.TypeOf(Job_Spec{}), generators)

	return job_SpecGenerator
}

// AddIndependentPropertyGeneratorsForJob_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForJob_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForJob_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForJob_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["Properties"] = gen.PtrOf(Job_Properties_SpecGenerator())
}
