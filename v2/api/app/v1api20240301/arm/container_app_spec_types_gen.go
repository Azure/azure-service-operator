// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import "github.com/Azure/azure-service-operator/v2/pkg/genruntime"

type ContainerApp_Spec struct {
	// ExtendedLocation: The complex type of the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// Identity: managed identities for the Container App to interact with other Azure services without maintaining any secrets
	// or credentials in code.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Location: The geo-location where the resource lives
	Location  *string `json:"location,omitempty"`
	ManagedBy *string `json:"managedBy,omitempty"`
	Name      string  `json:"name,omitempty"`

	// Properties: ContainerApp resource specific properties
	Properties *ContainerApp_Properties_Spec `json:"properties,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMResourceSpec = &ContainerApp_Spec{}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (containerApp ContainerApp_Spec) GetAPIVersion() string {
	return "2024-03-01"
}

// GetName returns the Name of the resource
func (containerApp *ContainerApp_Spec) GetName() string {
	return containerApp.Name
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.App/containerApps"
func (containerApp *ContainerApp_Spec) GetType() string {
	return "Microsoft.App/containerApps"
}

type ContainerApp_Properties_Spec struct {
	// Configuration: Non versioned Container App configuration properties.
	Configuration        *Configuration `json:"configuration,omitempty"`
	EnvironmentId        *string        `json:"environmentId,omitempty"`
	ManagedEnvironmentId *string        `json:"managedEnvironmentId,omitempty"`

	// Template: Container App versioned application definition.
	Template *Template `json:"template,omitempty"`

	// WorkloadProfileName: Workload profile name to pin for container app execution.
	WorkloadProfileName *string `json:"workloadProfileName,omitempty"`
}

// The complex type of the extended location.
type ExtendedLocation struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationType `json:"type,omitempty"`
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType            `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

// Non versioned Container App configuration properties that define the mutable settings of a Container app
type Configuration struct {
	// ActiveRevisionsMode: ActiveRevisionsMode controls how active revisions are handled for the Container app:
	// <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time.
	// Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
	ActiveRevisionsMode *Configuration_ActiveRevisionsMode `json:"activeRevisionsMode,omitempty"`

	// Dapr: Dapr configuration for the Container App.
	Dapr *Dapr `json:"dapr,omitempty"`

	// Ingress: Ingress configurations.
	Ingress *Ingress `json:"ingress,omitempty"`

	// MaxInactiveRevisions: Optional. Max inactive revisions a Container App can have.
	MaxInactiveRevisions *int `json:"maxInactiveRevisions,omitempty"`

	// Registries: Collection of private container registry credentials for containers used by the Container app
	Registries []RegistryCredentials `json:"registries,omitempty"`

	// Secrets: Collection of secrets used by a Container app
	Secrets []Secret `json:"secrets,omitempty"`

	// Service: Container App to be a dev Container App Service
	Service *Service `json:"service,omitempty"`
}

// The type of extendedLocation.
// +kubebuilder:validation:Enum={"CustomLocation"}
type ExtendedLocationType string

const ExtendedLocationType_CustomLocation = ExtendedLocationType("CustomLocation")

// Mapping from string to ExtendedLocationType
var extendedLocationType_Values = map[string]ExtendedLocationType{
	"customlocation": ExtendedLocationType_CustomLocation,
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned,UserAssigned","UserAssigned"}
type ManagedServiceIdentityType string

const (
	ManagedServiceIdentityType_None                       = ManagedServiceIdentityType("None")
	ManagedServiceIdentityType_SystemAssigned             = ManagedServiceIdentityType("SystemAssigned")
	ManagedServiceIdentityType_SystemAssignedUserAssigned = ManagedServiceIdentityType("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_UserAssigned               = ManagedServiceIdentityType("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType
var managedServiceIdentityType_Values = map[string]ManagedServiceIdentityType{
	"none":                        ManagedServiceIdentityType_None,
	"systemassigned":              ManagedServiceIdentityType_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_UserAssigned,
}

// Container App versioned application definition.
// Defines the desired state of an immutable revision.
// Any changes to this
// section Will result in a new revision being created
type Template struct {
	// Containers: List of container definitions for the Container App.
	Containers []Container `json:"containers,omitempty"`

	// InitContainers: List of specialized containers that run before app containers.
	InitContainers []BaseContainer `json:"initContainers,omitempty"`

	// RevisionSuffix: User friendly suffix that is appended to the revision name
	RevisionSuffix *string `json:"revisionSuffix,omitempty"`

	// Scale: Scaling properties for the Container App.
	Scale *Scale `json:"scale,omitempty"`

	// ServiceBinds: List of container app services bound to the app
	ServiceBinds []ServiceBind `json:"serviceBinds,omitempty"`

	// TerminationGracePeriodSeconds: Optional duration in seconds the Container App Instance needs to terminate gracefully.
	// Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to
	// shut down). If this value is nil, the default grace period will be used instead. Set this value longer than the expected
	// cleanup time for your process. Defaults to 30 seconds.
	TerminationGracePeriodSeconds *int `json:"terminationGracePeriodSeconds,omitempty"`

	// Volumes: List of volume definitions for the Container App.
	Volumes []Volume `json:"volumes,omitempty"`
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
}

// Container App base container definition.
type BaseContainer struct {
	// Args: Container start command arguments.
	Args []string `json:"args,omitempty"`

	// Command: Container start command.
	Command []string `json:"command,omitempty"`

	// Env: Container environment variables.
	Env []EnvironmentVar `json:"env,omitempty"`

	// Image: Container image tag.
	Image *string `json:"image,omitempty"`

	// Name: Custom container name.
	Name *string `json:"name,omitempty"`

	// Resources: Container resource requirements.
	Resources *ContainerResources `json:"resources,omitempty"`

	// VolumeMounts: Container volume mounts.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

// +kubebuilder:validation:Enum={"Multiple","Single"}
type Configuration_ActiveRevisionsMode string

const (
	Configuration_ActiveRevisionsMode_Multiple = Configuration_ActiveRevisionsMode("Multiple")
	Configuration_ActiveRevisionsMode_Single   = Configuration_ActiveRevisionsMode("Single")
)

// Mapping from string to Configuration_ActiveRevisionsMode
var configuration_ActiveRevisionsMode_Values = map[string]Configuration_ActiveRevisionsMode{
	"multiple": Configuration_ActiveRevisionsMode_Multiple,
	"single":   Configuration_ActiveRevisionsMode_Single,
}

// Container App container definition
type Container struct {
	// Args: Container start command arguments.
	Args []string `json:"args,omitempty"`

	// Command: Container start command.
	Command []string `json:"command,omitempty"`

	// Env: Container environment variables.
	Env []EnvironmentVar `json:"env,omitempty"`

	// Image: Container image tag.
	Image *string `json:"image,omitempty"`

	// Name: Custom container name.
	Name *string `json:"name,omitempty"`

	// Probes: List of probes for the container.
	Probes []ContainerAppProbe `json:"probes,omitempty"`

	// Resources: Container resource requirements.
	Resources *ContainerResources `json:"resources,omitempty"`

	// VolumeMounts: Container volume mounts.
	VolumeMounts []VolumeMount `json:"volumeMounts,omitempty"`
}

// Container App Dapr configuration.
type Dapr struct {
	// AppId: Dapr application identifier
	AppId *string `json:"appId,omitempty"`

	// AppPort: Tells Dapr which port your application is listening on
	AppPort *int `json:"appPort,omitempty"`

	// AppProtocol: Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
	AppProtocol *Dapr_AppProtocol `json:"appProtocol,omitempty"`

	// EnableApiLogging: Enables API logging for the Dapr sidecar
	EnableApiLogging *bool `json:"enableApiLogging,omitempty"`

	// Enabled: Boolean indicating if the Dapr side car is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// HttpMaxRequestSize: Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big
	// files. Default is 4 MB.
	HttpMaxRequestSize *int `json:"httpMaxRequestSize,omitempty"`

	// HttpReadBufferSize: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is
	// 65KB.
	HttpReadBufferSize *int `json:"httpReadBufferSize,omitempty"`

	// LogLevel: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
	LogLevel *Dapr_LogLevel `json:"logLevel,omitempty"`
}

// Container App Ingress configuration.
type Ingress struct {
	// AdditionalPortMappings: Settings to expose additional ports on container app
	AdditionalPortMappings []IngressPortMapping `json:"additionalPortMappings,omitempty"`

	// AllowInsecure: Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically
	// redirected to HTTPS connections
	AllowInsecure *bool `json:"allowInsecure,omitempty"`

	// ClientCertificateMode: Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate
	// on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require
	// indicates server requires a client certificate.
	ClientCertificateMode *Ingress_ClientCertificateMode `json:"clientCertificateMode,omitempty"`

	// CorsPolicy: CORS policy for container app
	CorsPolicy *CorsPolicy `json:"corsPolicy,omitempty"`

	// CustomDomains: custom domain bindings for Container Apps' hostnames.
	CustomDomains []CustomDomain `json:"customDomains,omitempty"`

	// ExposedPort: Exposed Port in containers for TCP traffic from ingress
	ExposedPort *int `json:"exposedPort,omitempty"`

	// External: Bool indicating if app exposes an external http endpoint
	External *bool `json:"external,omitempty"`

	// IpSecurityRestrictions: Rules to restrict incoming IP address.
	IpSecurityRestrictions []IpSecurityRestrictionRule `json:"ipSecurityRestrictions,omitempty"`

	// StickySessions: Sticky Sessions for Single Revision Mode
	StickySessions *Ingress_StickySessions `json:"stickySessions,omitempty"`

	// TargetPort: Target Port in containers for traffic from ingress
	TargetPort *int `json:"targetPort,omitempty"`

	// Traffic: Traffic weights for app's revisions
	Traffic []TrafficWeight `json:"traffic,omitempty"`

	// Transport: Ingress transport protocol
	Transport *Ingress_Transport `json:"transport,omitempty"`
}

// Container App Private Registry
type RegistryCredentials struct {
	Identity *string `json:"identity,omitempty"`

	// PasswordSecretRef: The name of the Secret that contains the registry login password
	PasswordSecretRef *string `json:"passwordSecretRef,omitempty"`

	// Server: Container Registry Server
	Server *string `json:"server,omitempty"`

	// Username: Container Registry Username
	Username *string `json:"username,omitempty"`
}

// Container App scaling configurations.
type Scale struct {
	// MaxReplicas: Optional. Maximum number of container replicas. Defaults to 10 if not set.
	MaxReplicas *int `json:"maxReplicas,omitempty"`

	// MinReplicas: Optional. Minimum number of container replicas.
	MinReplicas *int `json:"minReplicas,omitempty"`

	// Rules: Scaling rules.
	Rules []ScaleRule `json:"rules,omitempty"`
}

// Secret definition.
type Secret struct {
	Identity *string `json:"identity,omitempty"`

	// KeyVaultUrl: Azure Key Vault URL pointing to the secret referenced by the container app.
	KeyVaultUrl *string `json:"keyVaultUrl,omitempty"`

	// Name: Secret Name.
	Name *string `json:"name,omitempty"`

	// Value: Secret Value.
	Value *string `json:"value,omitempty"`
}

// Container App to be a dev service
type Service struct {
	// Type: Dev ContainerApp service type
	Type *string `json:"type,omitempty"`
}

// Configuration to bind a ContainerApp to a dev ContainerApp Service
type ServiceBind struct {
	// Name: Name of the service bind
	Name      *string `json:"name,omitempty"`
	ServiceId *string `json:"serviceId,omitempty"`
}

// Volume definitions for the Container App.
type Volume struct {
	// MountOptions: Mount options used while mounting the AzureFile. Must be a comma-separated string.
	MountOptions *string `json:"mountOptions,omitempty"`

	// Name: Volume name.
	Name *string `json:"name,omitempty"`

	// Secrets: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to
	// volume.
	Secrets []SecretVolumeItem `json:"secrets,omitempty"`

	// StorageName: Name of storage resource. No need to provide for EmptyDir and Secret.
	StorageName *string `json:"storageName,omitempty"`

	// StorageType: Storage type for the volume. If not provided, use EmptyDir.
	StorageType *Volume_StorageType `json:"storageType,omitempty"`
}

// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive
// traffic.
type ContainerAppProbe struct {
	// FailureThreshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to
	// 3. Minimum value is 1. Maximum value is 10.
	FailureThreshold *int `json:"failureThreshold,omitempty"`

	// HttpGet: HTTPGet specifies the http request to perform.
	HttpGet *ContainerAppProbe_HttpGet `json:"httpGet,omitempty"`

	// InitialDelaySeconds: Number of seconds after the container has started before liveness probes are initiated. Minimum
	// value is 1. Maximum value is 60.
	InitialDelaySeconds *int `json:"initialDelaySeconds,omitempty"`

	// PeriodSeconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is
	// 240.
	PeriodSeconds *int `json:"periodSeconds,omitempty"`

	// SuccessThreshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults
	// to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
	SuccessThreshold *int `json:"successThreshold,omitempty"`

	// TcpSocket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
	TcpSocket *ContainerAppProbe_TcpSocket `json:"tcpSocket,omitempty"`

	// TerminationGracePeriodSeconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
	// The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the
	// time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for
	// your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value
	// overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop
	// immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling
	// ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
	TerminationGracePeriodSeconds *int `json:"terminationGracePeriodSeconds,omitempty"`

	// TimeoutSeconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum
	// value is 240.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`

	// Type: The type of probe.
	Type *ContainerAppProbe_Type `json:"type,omitempty"`
}

// Container App container resource requirements.
type ContainerResources struct {
	// Cpu: Required CPU in cores, e.g. 0.5
	Cpu *float64 `json:"cpu,omitempty"`

	// Memory: Required memory, e.g. "250Mb"
	Memory *string `json:"memory,omitempty"`
}

// Cross-Origin-Resource-Sharing policy
type CorsPolicy struct {
	// AllowCredentials: Specifies whether the resource allows credentials
	AllowCredentials *bool `json:"allowCredentials,omitempty"`

	// AllowedHeaders: Specifies the content for the access-control-allow-headers header
	AllowedHeaders []string `json:"allowedHeaders,omitempty"`

	// AllowedMethods: Specifies the content for the access-control-allow-methods header
	AllowedMethods []string `json:"allowedMethods,omitempty"`

	// AllowedOrigins: Specifies the content for the access-control-allow-origins header
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// ExposeHeaders: Specifies the content for the access-control-expose-headers header
	ExposeHeaders []string `json:"exposeHeaders,omitempty"`

	// MaxAge: Specifies the content for the access-control-max-age header
	MaxAge *int `json:"maxAge,omitempty"`
}

// Custom Domain of a Container App
type CustomDomain struct {
	// BindingType: Custom Domain binding type.
	BindingType   *CustomDomain_BindingType `json:"bindingType,omitempty"`
	CertificateId *string                   `json:"certificateId,omitempty"`

	// Name: Hostname.
	Name *string `json:"name,omitempty"`
}

// +kubebuilder:validation:Enum={"grpc","http"}
type Dapr_AppProtocol string

const (
	Dapr_AppProtocol_Grpc = Dapr_AppProtocol("grpc")
	Dapr_AppProtocol_Http = Dapr_AppProtocol("http")
)

// Mapping from string to Dapr_AppProtocol
var dapr_AppProtocol_Values = map[string]Dapr_AppProtocol{
	"grpc": Dapr_AppProtocol_Grpc,
	"http": Dapr_AppProtocol_Http,
}

// +kubebuilder:validation:Enum={"debug","error","info","warn"}
type Dapr_LogLevel string

const (
	Dapr_LogLevel_Debug = Dapr_LogLevel("debug")
	Dapr_LogLevel_Error = Dapr_LogLevel("error")
	Dapr_LogLevel_Info  = Dapr_LogLevel("info")
	Dapr_LogLevel_Warn  = Dapr_LogLevel("warn")
)

// Mapping from string to Dapr_LogLevel
var dapr_LogLevel_Values = map[string]Dapr_LogLevel{
	"debug": Dapr_LogLevel_Debug,
	"error": Dapr_LogLevel_Error,
	"info":  Dapr_LogLevel_Info,
	"warn":  Dapr_LogLevel_Warn,
}

// Container App container environment variable.
type EnvironmentVar struct {
	// Name: Environment variable name.
	Name *string `json:"name,omitempty"`

	// SecretRef: Name of the Container App secret from which to pull the environment variable value.
	SecretRef *string `json:"secretRef,omitempty"`

	// Value: Non-secret environment variable value.
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:validation:Enum={"accept","ignore","require"}
type Ingress_ClientCertificateMode string

const (
	Ingress_ClientCertificateMode_Accept  = Ingress_ClientCertificateMode("accept")
	Ingress_ClientCertificateMode_Ignore  = Ingress_ClientCertificateMode("ignore")
	Ingress_ClientCertificateMode_Require = Ingress_ClientCertificateMode("require")
)

// Mapping from string to Ingress_ClientCertificateMode
var ingress_ClientCertificateMode_Values = map[string]Ingress_ClientCertificateMode{
	"accept":  Ingress_ClientCertificateMode_Accept,
	"ignore":  Ingress_ClientCertificateMode_Ignore,
	"require": Ingress_ClientCertificateMode_Require,
}

type Ingress_StickySessions struct {
	// Affinity: Sticky Session Affinity
	Affinity *Ingress_StickySessions_Affinity `json:"affinity,omitempty"`
}

// +kubebuilder:validation:Enum={"auto","http","http2","tcp"}
type Ingress_Transport string

const (
	Ingress_Transport_Auto  = Ingress_Transport("auto")
	Ingress_Transport_Http  = Ingress_Transport("http")
	Ingress_Transport_Http2 = Ingress_Transport("http2")
	Ingress_Transport_Tcp   = Ingress_Transport("tcp")
)

// Mapping from string to Ingress_Transport
var ingress_Transport_Values = map[string]Ingress_Transport{
	"auto":  Ingress_Transport_Auto,
	"http":  Ingress_Transport_Http,
	"http2": Ingress_Transport_Http2,
	"tcp":   Ingress_Transport_Tcp,
}

// Port mappings of container app ingress
type IngressPortMapping struct {
	// ExposedPort: Specifies the exposed port for the target port. If not specified, it defaults to target port
	ExposedPort *int `json:"exposedPort,omitempty"`

	// External: Specifies whether the app port is accessible outside of the environment
	External *bool `json:"external,omitempty"`

	// TargetPort: Specifies the port user's container listens on
	TargetPort *int `json:"targetPort,omitempty"`
}

// Rule to restrict incoming IP address.
type IpSecurityRestrictionRule struct {
	// Action: Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
	Action *IpSecurityRestrictionRule_Action `json:"action,omitempty"`

	// Description: Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
	Description *string `json:"description,omitempty"`

	// IpAddressRange: CIDR notation to match incoming IP address
	IpAddressRange *string `json:"ipAddressRange,omitempty"`

	// Name: Name for the IP restriction rule.
	Name *string `json:"name,omitempty"`
}

// Container App container scaling rule.
type ScaleRule struct {
	// AzureQueue: Azure Queue based scaling.
	AzureQueue *QueueScaleRule `json:"azureQueue,omitempty"`

	// Custom: Custom scale rule.
	Custom *CustomScaleRule `json:"custom,omitempty"`

	// Http: HTTP requests based scaling.
	Http *HttpScaleRule `json:"http,omitempty"`

	// Name: Scale Rule Name
	Name *string `json:"name,omitempty"`

	// Tcp: Tcp requests based scaling.
	Tcp *TcpScaleRule `json:"tcp,omitempty"`
}

// Secret to be added to volume.
type SecretVolumeItem struct {
	// Path: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
	Path *string `json:"path,omitempty"`

	// SecretRef: Name of the Container App secret from which to pull the secret value.
	SecretRef *string `json:"secretRef,omitempty"`
}

// Traffic weight assigned to a revision
type TrafficWeight struct {
	// Label: Associates a traffic label with a revision
	Label *string `json:"label,omitempty"`

	// LatestRevision: Indicates that the traffic weight belongs to a latest stable revision
	LatestRevision *bool `json:"latestRevision,omitempty"`

	// RevisionName: Name of a revision
	RevisionName *string `json:"revisionName,omitempty"`

	// Weight: Traffic weight assigned to a revision
	Weight *int `json:"weight,omitempty"`
}

// +kubebuilder:validation:Enum={"AzureFile","EmptyDir","Secret"}
type Volume_StorageType string

const (
	Volume_StorageType_AzureFile = Volume_StorageType("AzureFile")
	Volume_StorageType_EmptyDir  = Volume_StorageType("EmptyDir")
	Volume_StorageType_Secret    = Volume_StorageType("Secret")
)

// Mapping from string to Volume_StorageType
var volume_StorageType_Values = map[string]Volume_StorageType{
	"azurefile": Volume_StorageType_AzureFile,
	"emptydir":  Volume_StorageType_EmptyDir,
	"secret":    Volume_StorageType_Secret,
}

// Volume mount for the Container App.
type VolumeMount struct {
	// MountPath: Path within the container at which the volume should be mounted.Must not contain ':'.
	MountPath *string `json:"mountPath,omitempty"`

	// SubPath: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
	SubPath *string `json:"subPath,omitempty"`

	// VolumeName: This must match the Name of a Volume.
	VolumeName *string `json:"volumeName,omitempty"`
}

type ContainerAppProbe_HttpGet struct {
	// Host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
	Host *string `json:"host,omitempty"`

	// HttpHeaders: Custom headers to set in the request. HTTP allows repeated headers.
	HttpHeaders []ContainerAppProbe_HttpGet_HttpHeaders `json:"httpHeaders,omitempty"`

	// Path: Path to access on the HTTP server.
	Path *string `json:"path,omitempty"`

	// Port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an
	// IANA_SVC_NAME.
	Port *int `json:"port,omitempty"`

	// Scheme: Scheme to use for connecting to the host. Defaults to HTTP.
	Scheme *ContainerAppProbe_HttpGet_Scheme `json:"scheme,omitempty"`
}

type ContainerAppProbe_TcpSocket struct {
	// Host: Optional: Host name to connect to, defaults to the pod IP.
	Host *string `json:"host,omitempty"`

	// Port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an
	// IANA_SVC_NAME.
	Port *int `json:"port,omitempty"`
}

// +kubebuilder:validation:Enum={"Liveness","Readiness","Startup"}
type ContainerAppProbe_Type string

const (
	ContainerAppProbe_Type_Liveness  = ContainerAppProbe_Type("Liveness")
	ContainerAppProbe_Type_Readiness = ContainerAppProbe_Type("Readiness")
	ContainerAppProbe_Type_Startup   = ContainerAppProbe_Type("Startup")
)

// Mapping from string to ContainerAppProbe_Type
var containerAppProbe_Type_Values = map[string]ContainerAppProbe_Type{
	"liveness":  ContainerAppProbe_Type_Liveness,
	"readiness": ContainerAppProbe_Type_Readiness,
	"startup":   ContainerAppProbe_Type_Startup,
}

// +kubebuilder:validation:Enum={"Disabled","SniEnabled"}
type CustomDomain_BindingType string

const (
	CustomDomain_BindingType_Disabled   = CustomDomain_BindingType("Disabled")
	CustomDomain_BindingType_SniEnabled = CustomDomain_BindingType("SniEnabled")
)

// Mapping from string to CustomDomain_BindingType
var customDomain_BindingType_Values = map[string]CustomDomain_BindingType{
	"disabled":   CustomDomain_BindingType_Disabled,
	"snienabled": CustomDomain_BindingType_SniEnabled,
}

// Container App container Custom scaling rule.
type CustomScaleRule struct {
	// Auth: Authentication secrets for the custom scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe custom scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`

	// Type: Type of the custom scale rule
	// eg: azure-servicebus, redis etc.
	Type *string `json:"type,omitempty"`
}

// Container App container Http scaling rule.
type HttpScaleRule struct {
	// Auth: Authentication secrets for the custom scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe http scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`
}

// +kubebuilder:validation:Enum={"none","sticky"}
type Ingress_StickySessions_Affinity string

const (
	Ingress_StickySessions_Affinity_None   = Ingress_StickySessions_Affinity("none")
	Ingress_StickySessions_Affinity_Sticky = Ingress_StickySessions_Affinity("sticky")
)

// Mapping from string to Ingress_StickySessions_Affinity
var ingress_StickySessions_Affinity_Values = map[string]Ingress_StickySessions_Affinity{
	"none":   Ingress_StickySessions_Affinity_None,
	"sticky": Ingress_StickySessions_Affinity_Sticky,
}

// +kubebuilder:validation:Enum={"Allow","Deny"}
type IpSecurityRestrictionRule_Action string

const (
	IpSecurityRestrictionRule_Action_Allow = IpSecurityRestrictionRule_Action("Allow")
	IpSecurityRestrictionRule_Action_Deny  = IpSecurityRestrictionRule_Action("Deny")
)

// Mapping from string to IpSecurityRestrictionRule_Action
var ipSecurityRestrictionRule_Action_Values = map[string]IpSecurityRestrictionRule_Action{
	"allow": IpSecurityRestrictionRule_Action_Allow,
	"deny":  IpSecurityRestrictionRule_Action_Deny,
}

// Container App container Azure Queue based scaling rule.
type QueueScaleRule struct {
	// Auth: Authentication secrets for the queue scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// QueueLength: Queue length.
	QueueLength *int `json:"queueLength,omitempty"`

	// QueueName: Queue name.
	QueueName *string `json:"queueName,omitempty"`
}

// Container App container Tcp scaling rule.
type TcpScaleRule struct {
	// Auth: Authentication secrets for the tcp scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe tcp scale rule.
	Metadata map[string]string `json:"metadata,omitempty"`
}

type ContainerAppProbe_HttpGet_HttpHeaders struct {
	// Name: The header field name
	Name *string `json:"name,omitempty"`

	// Value: The header field value
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:validation:Enum={"HTTP","HTTPS"}
type ContainerAppProbe_HttpGet_Scheme string

const (
	ContainerAppProbe_HttpGet_Scheme_HTTP  = ContainerAppProbe_HttpGet_Scheme("HTTP")
	ContainerAppProbe_HttpGet_Scheme_HTTPS = ContainerAppProbe_HttpGet_Scheme("HTTPS")
)

// Mapping from string to ContainerAppProbe_HttpGet_Scheme
var containerAppProbe_HttpGet_Scheme_Values = map[string]ContainerAppProbe_HttpGet_Scheme{
	"http":  ContainerAppProbe_HttpGet_Scheme_HTTP,
	"https": ContainerAppProbe_HttpGet_Scheme_HTTPS,
}

// Auth Secrets for Scale Rule
type ScaleRuleAuth struct {
	// SecretRef: Name of the secret from which to pull the auth params.
	SecretRef *string `json:"secretRef,omitempty"`

	// TriggerParameter: Trigger Parameter that uses the secret
	TriggerParameter *string `json:"triggerParameter,omitempty"`
}
