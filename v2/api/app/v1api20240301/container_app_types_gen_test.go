// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BaseContainer_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BaseContainer to BaseContainer via AssignProperties_To_BaseContainer & AssignProperties_From_BaseContainer returns original",
		prop.ForAll(RunPropertyAssignmentTestForBaseContainer, BaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBaseContainer tests if a specific instance of BaseContainer can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBaseContainer(subject BaseContainer) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BaseContainer
	err := copied.AssignProperties_To_BaseContainer(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BaseContainer
	err = actual.AssignProperties_From_BaseContainer(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BaseContainer_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaseContainer via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaseContainer, BaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaseContainer runs a test to see if a specific instance of BaseContainer round trips to JSON and back losslessly
func RunJSONSerializationTestForBaseContainer(subject BaseContainer) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaseContainer
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaseContainer instances for property testing - lazily instantiated by BaseContainerGenerator()
var baseContainerGenerator gopter.Gen

// BaseContainerGenerator returns a generator of BaseContainer instances for property testing.
// We first initialize baseContainerGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BaseContainerGenerator() gopter.Gen {
	if baseContainerGenerator != nil {
		return baseContainerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBaseContainer(generators)
	baseContainerGenerator = gen.Struct(reflect.TypeOf(BaseContainer{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBaseContainer(generators)
	AddRelatedPropertyGeneratorsForBaseContainer(generators)
	baseContainerGenerator = gen.Struct(reflect.TypeOf(BaseContainer{}), generators)

	return baseContainerGenerator
}

// AddIndependentPropertyGeneratorsForBaseContainer is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBaseContainer(gens map[string]gopter.Gen) {
	gens["Args"] = gen.SliceOf(gen.AlphaString())
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBaseContainer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaseContainer(gens map[string]gopter.Gen) {
	gens["Env"] = gen.SliceOf(EnvironmentVarGenerator())
	gens["Resources"] = gen.PtrOf(ContainerResourcesGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_BaseContainer_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BaseContainer_STATUS to BaseContainer_STATUS via AssignProperties_To_BaseContainer_STATUS & AssignProperties_From_BaseContainer_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBaseContainer_STATUS, BaseContainer_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBaseContainer_STATUS tests if a specific instance of BaseContainer_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBaseContainer_STATUS(subject BaseContainer_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BaseContainer_STATUS
	err := copied.AssignProperties_To_BaseContainer_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BaseContainer_STATUS
	err = actual.AssignProperties_From_BaseContainer_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BaseContainer_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaseContainer_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaseContainer_STATUS, BaseContainer_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaseContainer_STATUS runs a test to see if a specific instance of BaseContainer_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBaseContainer_STATUS(subject BaseContainer_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaseContainer_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaseContainer_STATUS instances for property testing - lazily instantiated by
// BaseContainer_STATUSGenerator()
var baseContainer_STATUSGenerator gopter.Gen

// BaseContainer_STATUSGenerator returns a generator of BaseContainer_STATUS instances for property testing.
// We first initialize baseContainer_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BaseContainer_STATUSGenerator() gopter.Gen {
	if baseContainer_STATUSGenerator != nil {
		return baseContainer_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBaseContainer_STATUS(generators)
	baseContainer_STATUSGenerator = gen.Struct(reflect.TypeOf(BaseContainer_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBaseContainer_STATUS(generators)
	AddRelatedPropertyGeneratorsForBaseContainer_STATUS(generators)
	baseContainer_STATUSGenerator = gen.Struct(reflect.TypeOf(BaseContainer_STATUS{}), generators)

	return baseContainer_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBaseContainer_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBaseContainer_STATUS(gens map[string]gopter.Gen) {
	gens["Args"] = gen.SliceOf(gen.AlphaString())
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBaseContainer_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaseContainer_STATUS(gens map[string]gopter.Gen) {
	gens["Env"] = gen.SliceOf(EnvironmentVar_STATUSGenerator())
	gens["Resources"] = gen.PtrOf(ContainerResources_STATUSGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMount_STATUSGenerator())
}

func Test_Configuration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Configuration to Configuration via AssignProperties_To_Configuration & AssignProperties_From_Configuration returns original",
		prop.ForAll(RunPropertyAssignmentTestForConfiguration, ConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConfiguration tests if a specific instance of Configuration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForConfiguration(subject Configuration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Configuration
	err := copied.AssignProperties_To_Configuration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Configuration
	err = actual.AssignProperties_From_Configuration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Configuration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Configuration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConfiguration, ConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConfiguration runs a test to see if a specific instance of Configuration round trips to JSON and back losslessly
func RunJSONSerializationTestForConfiguration(subject Configuration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Configuration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Configuration instances for property testing - lazily instantiated by ConfigurationGenerator()
var configurationGenerator gopter.Gen

// ConfigurationGenerator returns a generator of Configuration instances for property testing.
// We first initialize configurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ConfigurationGenerator() gopter.Gen {
	if configurationGenerator != nil {
		return configurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConfiguration(generators)
	configurationGenerator = gen.Struct(reflect.TypeOf(Configuration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConfiguration(generators)
	AddRelatedPropertyGeneratorsForConfiguration(generators)
	configurationGenerator = gen.Struct(reflect.TypeOf(Configuration{}), generators)

	return configurationGenerator
}

// AddIndependentPropertyGeneratorsForConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConfiguration(gens map[string]gopter.Gen) {
	gens["ActiveRevisionsMode"] = gen.PtrOf(gen.OneConstOf(Configuration_ActiveRevisionsMode_Multiple, Configuration_ActiveRevisionsMode_Single))
	gens["MaxInactiveRevisions"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForConfiguration(gens map[string]gopter.Gen) {
	gens["Dapr"] = gen.PtrOf(DaprGenerator())
	gens["Ingress"] = gen.PtrOf(IngressGenerator())
	gens["Registries"] = gen.SliceOf(RegistryCredentialsGenerator())
	gens["Secrets"] = gen.SliceOf(SecretGenerator())
	gens["Service"] = gen.PtrOf(ServiceGenerator())
}

func Test_Configuration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Configuration_STATUS to Configuration_STATUS via AssignProperties_To_Configuration_STATUS & AssignProperties_From_Configuration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForConfiguration_STATUS, Configuration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConfiguration_STATUS tests if a specific instance of Configuration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForConfiguration_STATUS(subject Configuration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Configuration_STATUS
	err := copied.AssignProperties_To_Configuration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Configuration_STATUS
	err = actual.AssignProperties_From_Configuration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Configuration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Configuration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConfiguration_STATUS, Configuration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConfiguration_STATUS runs a test to see if a specific instance of Configuration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForConfiguration_STATUS(subject Configuration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Configuration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Configuration_STATUS instances for property testing - lazily instantiated by
// Configuration_STATUSGenerator()
var configuration_STATUSGenerator gopter.Gen

// Configuration_STATUSGenerator returns a generator of Configuration_STATUS instances for property testing.
// We first initialize configuration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Configuration_STATUSGenerator() gopter.Gen {
	if configuration_STATUSGenerator != nil {
		return configuration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConfiguration_STATUS(generators)
	configuration_STATUSGenerator = gen.Struct(reflect.TypeOf(Configuration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForConfiguration_STATUS(generators)
	configuration_STATUSGenerator = gen.Struct(reflect.TypeOf(Configuration_STATUS{}), generators)

	return configuration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["ActiveRevisionsMode"] = gen.PtrOf(gen.OneConstOf(Configuration_ActiveRevisionsMode_STATUS_Multiple, Configuration_ActiveRevisionsMode_STATUS_Single))
	gens["MaxInactiveRevisions"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Dapr"] = gen.PtrOf(Dapr_STATUSGenerator())
	gens["Ingress"] = gen.PtrOf(Ingress_STATUSGenerator())
	gens["Registries"] = gen.SliceOf(RegistryCredentials_STATUSGenerator())
	gens["Secrets"] = gen.SliceOf(Secret_STATUSGenerator())
	gens["Service"] = gen.PtrOf(Service_STATUSGenerator())
}

func Test_Container_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Container to Container via AssignProperties_To_Container & AssignProperties_From_Container returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainer, ContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainer tests if a specific instance of Container can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainer(subject Container) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Container
	err := copied.AssignProperties_To_Container(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Container
	err = actual.AssignProperties_From_Container(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Container_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainer, ContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainer runs a test to see if a specific instance of Container round trips to JSON and back losslessly
func RunJSONSerializationTestForContainer(subject Container) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container instances for property testing - lazily instantiated by ContainerGenerator()
var containerGenerator gopter.Gen

// ContainerGenerator returns a generator of Container instances for property testing.
// We first initialize containerGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerGenerator() gopter.Gen {
	if containerGenerator != nil {
		return containerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer(generators)
	containerGenerator = gen.Struct(reflect.TypeOf(Container{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer(generators)
	AddRelatedPropertyGeneratorsForContainer(generators)
	containerGenerator = gen.Struct(reflect.TypeOf(Container{}), generators)

	return containerGenerator
}

// AddIndependentPropertyGeneratorsForContainer is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainer(gens map[string]gopter.Gen) {
	gens["Args"] = gen.SliceOf(gen.AlphaString())
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainer(gens map[string]gopter.Gen) {
	gens["Env"] = gen.SliceOf(EnvironmentVarGenerator())
	gens["Probes"] = gen.SliceOf(ContainerAppProbeGenerator())
	gens["Resources"] = gen.PtrOf(ContainerResourcesGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMountGenerator())
}

func Test_ContainerApp_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerApp to hub returns original",
		prop.ForAll(RunResourceConversionTestForContainerApp, ContainerAppGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForContainerApp tests if a specific instance of ContainerApp round trips to the hub storage version and back losslessly
func RunResourceConversionTestForContainerApp(subject ContainerApp) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.ContainerApp
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ContainerApp
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerApp_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerApp to ContainerApp via AssignProperties_To_ContainerApp & AssignProperties_From_ContainerApp returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerApp, ContainerAppGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerApp tests if a specific instance of ContainerApp can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerApp(subject ContainerApp) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerApp
	err := copied.AssignProperties_To_ContainerApp(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerApp
	err = actual.AssignProperties_From_ContainerApp(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerApp_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerApp via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerApp, ContainerAppGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerApp runs a test to see if a specific instance of ContainerApp round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerApp(subject ContainerApp) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerApp
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerApp instances for property testing - lazily instantiated by ContainerAppGenerator()
var containerAppGenerator gopter.Gen

// ContainerAppGenerator returns a generator of ContainerApp instances for property testing.
func ContainerAppGenerator() gopter.Gen {
	if containerAppGenerator != nil {
		return containerAppGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerApp(generators)
	containerAppGenerator = gen.Struct(reflect.TypeOf(ContainerApp{}), generators)

	return containerAppGenerator
}

// AddRelatedPropertyGeneratorsForContainerApp is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerApp(gens map[string]gopter.Gen) {
	gens["Spec"] = ContainerApp_SpecGenerator()
	gens["Status"] = ContainerApp_STATUSGenerator()
}

func Test_ContainerAppOperatorConfigMaps_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppOperatorConfigMaps to ContainerAppOperatorConfigMaps via AssignProperties_To_ContainerAppOperatorConfigMaps & AssignProperties_From_ContainerAppOperatorConfigMaps returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppOperatorConfigMaps, ContainerAppOperatorConfigMapsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppOperatorConfigMaps tests if a specific instance of ContainerAppOperatorConfigMaps can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppOperatorConfigMaps(subject ContainerAppOperatorConfigMaps) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppOperatorConfigMaps
	err := copied.AssignProperties_To_ContainerAppOperatorConfigMaps(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppOperatorConfigMaps
	err = actual.AssignProperties_From_ContainerAppOperatorConfigMaps(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppOperatorConfigMaps_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppOperatorConfigMaps via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppOperatorConfigMaps, ContainerAppOperatorConfigMapsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppOperatorConfigMaps runs a test to see if a specific instance of ContainerAppOperatorConfigMaps round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppOperatorConfigMaps(subject ContainerAppOperatorConfigMaps) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppOperatorConfigMaps
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppOperatorConfigMaps instances for property testing - lazily instantiated by
// ContainerAppOperatorConfigMapsGenerator()
var containerAppOperatorConfigMapsGenerator gopter.Gen

// ContainerAppOperatorConfigMapsGenerator returns a generator of ContainerAppOperatorConfigMaps instances for property testing.
func ContainerAppOperatorConfigMapsGenerator() gopter.Gen {
	if containerAppOperatorConfigMapsGenerator != nil {
		return containerAppOperatorConfigMapsGenerator
	}

	generators := make(map[string]gopter.Gen)
	containerAppOperatorConfigMapsGenerator = gen.Struct(reflect.TypeOf(ContainerAppOperatorConfigMaps{}), generators)

	return containerAppOperatorConfigMapsGenerator
}

func Test_ContainerAppOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppOperatorSpec to ContainerAppOperatorSpec via AssignProperties_To_ContainerAppOperatorSpec & AssignProperties_From_ContainerAppOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppOperatorSpec, ContainerAppOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppOperatorSpec tests if a specific instance of ContainerAppOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppOperatorSpec(subject ContainerAppOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppOperatorSpec
	err := copied.AssignProperties_To_ContainerAppOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppOperatorSpec
	err = actual.AssignProperties_From_ContainerAppOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppOperatorSpec, ContainerAppOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppOperatorSpec runs a test to see if a specific instance of ContainerAppOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppOperatorSpec(subject ContainerAppOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppOperatorSpec instances for property testing - lazily instantiated by
// ContainerAppOperatorSpecGenerator()
var containerAppOperatorSpecGenerator gopter.Gen

// ContainerAppOperatorSpecGenerator returns a generator of ContainerAppOperatorSpec instances for property testing.
func ContainerAppOperatorSpecGenerator() gopter.Gen {
	if containerAppOperatorSpecGenerator != nil {
		return containerAppOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerAppOperatorSpec(generators)
	containerAppOperatorSpecGenerator = gen.Struct(reflect.TypeOf(ContainerAppOperatorSpec{}), generators)

	return containerAppOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForContainerAppOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerAppOperatorSpec(gens map[string]gopter.Gen) {
	gens["ConfigMaps"] = gen.PtrOf(ContainerAppOperatorConfigMapsGenerator())
}

func Test_ContainerAppProbe_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppProbe to ContainerAppProbe via AssignProperties_To_ContainerAppProbe & AssignProperties_From_ContainerAppProbe returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppProbe, ContainerAppProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppProbe tests if a specific instance of ContainerAppProbe can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppProbe(subject ContainerAppProbe) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppProbe
	err := copied.AssignProperties_To_ContainerAppProbe(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppProbe
	err = actual.AssignProperties_From_ContainerAppProbe(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppProbe_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe, ContainerAppProbeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe runs a test to see if a specific instance of ContainerAppProbe round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe(subject ContainerAppProbe) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe instances for property testing - lazily instantiated by ContainerAppProbeGenerator()
var containerAppProbeGenerator gopter.Gen

// ContainerAppProbeGenerator returns a generator of ContainerAppProbe instances for property testing.
// We first initialize containerAppProbeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerAppProbeGenerator() gopter.Gen {
	if containerAppProbeGenerator != nil {
		return containerAppProbeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe(generators)
	containerAppProbeGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe(generators)
	AddRelatedPropertyGeneratorsForContainerAppProbe(generators)
	containerAppProbeGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe{}), generators)

	return containerAppProbeGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TerminationGracePeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ContainerAppProbe_Type_Liveness, ContainerAppProbe_Type_Readiness, ContainerAppProbe_Type_Startup))
}

// AddRelatedPropertyGeneratorsForContainerAppProbe is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerAppProbe(gens map[string]gopter.Gen) {
	gens["HttpGet"] = gen.PtrOf(ContainerAppProbe_HttpGetGenerator())
	gens["TcpSocket"] = gen.PtrOf(ContainerAppProbe_TcpSocketGenerator())
}

func Test_ContainerAppProbe_HttpGet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppProbe_HttpGet to ContainerAppProbe_HttpGet via AssignProperties_To_ContainerAppProbe_HttpGet & AssignProperties_From_ContainerAppProbe_HttpGet returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppProbe_HttpGet, ContainerAppProbe_HttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppProbe_HttpGet tests if a specific instance of ContainerAppProbe_HttpGet can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppProbe_HttpGet(subject ContainerAppProbe_HttpGet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppProbe_HttpGet
	err := copied.AssignProperties_To_ContainerAppProbe_HttpGet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppProbe_HttpGet
	err = actual.AssignProperties_From_ContainerAppProbe_HttpGet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppProbe_HttpGet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_HttpGet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_HttpGet, ContainerAppProbe_HttpGetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_HttpGet runs a test to see if a specific instance of ContainerAppProbe_HttpGet round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_HttpGet(subject ContainerAppProbe_HttpGet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_HttpGet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_HttpGet instances for property testing - lazily instantiated by
// ContainerAppProbe_HttpGetGenerator()
var containerAppProbe_HttpGetGenerator gopter.Gen

// ContainerAppProbe_HttpGetGenerator returns a generator of ContainerAppProbe_HttpGet instances for property testing.
// We first initialize containerAppProbe_HttpGetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerAppProbe_HttpGetGenerator() gopter.Gen {
	if containerAppProbe_HttpGetGenerator != nil {
		return containerAppProbe_HttpGetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet(generators)
	containerAppProbe_HttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet(generators)
	AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet(generators)
	containerAppProbe_HttpGetGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet{}), generators)

	return containerAppProbe_HttpGetGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet(gens map[string]gopter.Gen) {
	gens["Host"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerAppProbe_HttpGet_Scheme_HTTP, ContainerAppProbe_HttpGet_Scheme_HTTPS))
}

// AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(ContainerAppProbe_HttpGet_HttpHeadersGenerator())
}

func Test_ContainerAppProbe_HttpGet_HttpHeaders_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppProbe_HttpGet_HttpHeaders to ContainerAppProbe_HttpGet_HttpHeaders via AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders & AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppProbe_HttpGet_HttpHeaders, ContainerAppProbe_HttpGet_HttpHeadersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppProbe_HttpGet_HttpHeaders tests if a specific instance of ContainerAppProbe_HttpGet_HttpHeaders can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppProbe_HttpGet_HttpHeaders(subject ContainerAppProbe_HttpGet_HttpHeaders) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppProbe_HttpGet_HttpHeaders
	err := copied.AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppProbe_HttpGet_HttpHeaders
	err = actual.AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppProbe_HttpGet_HttpHeaders_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_HttpGet_HttpHeaders via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders, ContainerAppProbe_HttpGet_HttpHeadersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders runs a test to see if a specific instance of ContainerAppProbe_HttpGet_HttpHeaders round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders(subject ContainerAppProbe_HttpGet_HttpHeaders) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_HttpGet_HttpHeaders
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_HttpGet_HttpHeaders instances for property testing - lazily instantiated by
// ContainerAppProbe_HttpGet_HttpHeadersGenerator()
var containerAppProbe_HttpGet_HttpHeadersGenerator gopter.Gen

// ContainerAppProbe_HttpGet_HttpHeadersGenerator returns a generator of ContainerAppProbe_HttpGet_HttpHeaders instances for property testing.
func ContainerAppProbe_HttpGet_HttpHeadersGenerator() gopter.Gen {
	if containerAppProbe_HttpGet_HttpHeadersGenerator != nil {
		return containerAppProbe_HttpGet_HttpHeadersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders(generators)
	containerAppProbe_HttpGet_HttpHeadersGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet_HttpHeaders{}), generators)

	return containerAppProbe_HttpGet_HttpHeadersGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerAppProbe_HttpGet_HttpHeaders_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppProbe_HttpGet_HttpHeaders_STATUS to ContainerAppProbe_HttpGet_HttpHeaders_STATUS via AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS & AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppProbe_HttpGet_HttpHeaders_STATUS, ContainerAppProbe_HttpGet_HttpHeaders_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppProbe_HttpGet_HttpHeaders_STATUS tests if a specific instance of ContainerAppProbe_HttpGet_HttpHeaders_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppProbe_HttpGet_HttpHeaders_STATUS(subject ContainerAppProbe_HttpGet_HttpHeaders_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppProbe_HttpGet_HttpHeaders_STATUS
	err := copied.AssignProperties_To_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppProbe_HttpGet_HttpHeaders_STATUS
	err = actual.AssignProperties_From_ContainerAppProbe_HttpGet_HttpHeaders_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppProbe_HttpGet_HttpHeaders_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_HttpGet_HttpHeaders_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders_STATUS, ContainerAppProbe_HttpGet_HttpHeaders_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders_STATUS runs a test to see if a specific instance of ContainerAppProbe_HttpGet_HttpHeaders_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_HttpGet_HttpHeaders_STATUS(subject ContainerAppProbe_HttpGet_HttpHeaders_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_HttpGet_HttpHeaders_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_HttpGet_HttpHeaders_STATUS instances for property testing - lazily instantiated by
// ContainerAppProbe_HttpGet_HttpHeaders_STATUSGenerator()
var containerAppProbe_HttpGet_HttpHeaders_STATUSGenerator gopter.Gen

// ContainerAppProbe_HttpGet_HttpHeaders_STATUSGenerator returns a generator of ContainerAppProbe_HttpGet_HttpHeaders_STATUS instances for property testing.
func ContainerAppProbe_HttpGet_HttpHeaders_STATUSGenerator() gopter.Gen {
	if containerAppProbe_HttpGet_HttpHeaders_STATUSGenerator != nil {
		return containerAppProbe_HttpGet_HttpHeaders_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders_STATUS(generators)
	containerAppProbe_HttpGet_HttpHeaders_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet_HttpHeaders_STATUS{}), generators)

	return containerAppProbe_HttpGet_HttpHeaders_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_HttpHeaders_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerAppProbe_HttpGet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppProbe_HttpGet_STATUS to ContainerAppProbe_HttpGet_STATUS via AssignProperties_To_ContainerAppProbe_HttpGet_STATUS & AssignProperties_From_ContainerAppProbe_HttpGet_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppProbe_HttpGet_STATUS, ContainerAppProbe_HttpGet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppProbe_HttpGet_STATUS tests if a specific instance of ContainerAppProbe_HttpGet_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppProbe_HttpGet_STATUS(subject ContainerAppProbe_HttpGet_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppProbe_HttpGet_STATUS
	err := copied.AssignProperties_To_ContainerAppProbe_HttpGet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppProbe_HttpGet_STATUS
	err = actual.AssignProperties_From_ContainerAppProbe_HttpGet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppProbe_HttpGet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_HttpGet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_HttpGet_STATUS, ContainerAppProbe_HttpGet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_HttpGet_STATUS runs a test to see if a specific instance of ContainerAppProbe_HttpGet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_HttpGet_STATUS(subject ContainerAppProbe_HttpGet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_HttpGet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_HttpGet_STATUS instances for property testing - lazily instantiated by
// ContainerAppProbe_HttpGet_STATUSGenerator()
var containerAppProbe_HttpGet_STATUSGenerator gopter.Gen

// ContainerAppProbe_HttpGet_STATUSGenerator returns a generator of ContainerAppProbe_HttpGet_STATUS instances for property testing.
// We first initialize containerAppProbe_HttpGet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerAppProbe_HttpGet_STATUSGenerator() gopter.Gen {
	if containerAppProbe_HttpGet_STATUSGenerator != nil {
		return containerAppProbe_HttpGet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_STATUS(generators)
	containerAppProbe_HttpGet_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet_STATUS(generators)
	containerAppProbe_HttpGet_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_HttpGet_STATUS{}), generators)

	return containerAppProbe_HttpGet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_HttpGet_STATUS(gens map[string]gopter.Gen) {
	gens["Host"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["Scheme"] = gen.PtrOf(gen.OneConstOf(ContainerAppProbe_HttpGet_Scheme_STATUS_HTTP, ContainerAppProbe_HttpGet_Scheme_STATUS_HTTPS))
}

// AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerAppProbe_HttpGet_STATUS(gens map[string]gopter.Gen) {
	gens["HttpHeaders"] = gen.SliceOf(ContainerAppProbe_HttpGet_HttpHeaders_STATUSGenerator())
}

func Test_ContainerAppProbe_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppProbe_STATUS to ContainerAppProbe_STATUS via AssignProperties_To_ContainerAppProbe_STATUS & AssignProperties_From_ContainerAppProbe_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppProbe_STATUS, ContainerAppProbe_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppProbe_STATUS tests if a specific instance of ContainerAppProbe_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppProbe_STATUS(subject ContainerAppProbe_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppProbe_STATUS
	err := copied.AssignProperties_To_ContainerAppProbe_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppProbe_STATUS
	err = actual.AssignProperties_From_ContainerAppProbe_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppProbe_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_STATUS, ContainerAppProbe_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_STATUS runs a test to see if a specific instance of ContainerAppProbe_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_STATUS(subject ContainerAppProbe_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_STATUS instances for property testing - lazily instantiated by
// ContainerAppProbe_STATUSGenerator()
var containerAppProbe_STATUSGenerator gopter.Gen

// ContainerAppProbe_STATUSGenerator returns a generator of ContainerAppProbe_STATUS instances for property testing.
// We first initialize containerAppProbe_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerAppProbe_STATUSGenerator() gopter.Gen {
	if containerAppProbe_STATUSGenerator != nil {
		return containerAppProbe_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_STATUS(generators)
	containerAppProbe_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerAppProbe_STATUS(generators)
	containerAppProbe_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_STATUS{}), generators)

	return containerAppProbe_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_STATUS(gens map[string]gopter.Gen) {
	gens["FailureThreshold"] = gen.PtrOf(gen.Int())
	gens["InitialDelaySeconds"] = gen.PtrOf(gen.Int())
	gens["PeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["SuccessThreshold"] = gen.PtrOf(gen.Int())
	gens["TerminationGracePeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutSeconds"] = gen.PtrOf(gen.Int())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ContainerAppProbe_Type_STATUS_Liveness, ContainerAppProbe_Type_STATUS_Readiness, ContainerAppProbe_Type_STATUS_Startup))
}

// AddRelatedPropertyGeneratorsForContainerAppProbe_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerAppProbe_STATUS(gens map[string]gopter.Gen) {
	gens["HttpGet"] = gen.PtrOf(ContainerAppProbe_HttpGet_STATUSGenerator())
	gens["TcpSocket"] = gen.PtrOf(ContainerAppProbe_TcpSocket_STATUSGenerator())
}

func Test_ContainerAppProbe_TcpSocket_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppProbe_TcpSocket to ContainerAppProbe_TcpSocket via AssignProperties_To_ContainerAppProbe_TcpSocket & AssignProperties_From_ContainerAppProbe_TcpSocket returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppProbe_TcpSocket, ContainerAppProbe_TcpSocketGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppProbe_TcpSocket tests if a specific instance of ContainerAppProbe_TcpSocket can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppProbe_TcpSocket(subject ContainerAppProbe_TcpSocket) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppProbe_TcpSocket
	err := copied.AssignProperties_To_ContainerAppProbe_TcpSocket(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppProbe_TcpSocket
	err = actual.AssignProperties_From_ContainerAppProbe_TcpSocket(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppProbe_TcpSocket_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_TcpSocket via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_TcpSocket, ContainerAppProbe_TcpSocketGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_TcpSocket runs a test to see if a specific instance of ContainerAppProbe_TcpSocket round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_TcpSocket(subject ContainerAppProbe_TcpSocket) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_TcpSocket
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_TcpSocket instances for property testing - lazily instantiated by
// ContainerAppProbe_TcpSocketGenerator()
var containerAppProbe_TcpSocketGenerator gopter.Gen

// ContainerAppProbe_TcpSocketGenerator returns a generator of ContainerAppProbe_TcpSocket instances for property testing.
func ContainerAppProbe_TcpSocketGenerator() gopter.Gen {
	if containerAppProbe_TcpSocketGenerator != nil {
		return containerAppProbe_TcpSocketGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket(generators)
	containerAppProbe_TcpSocketGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_TcpSocket{}), generators)

	return containerAppProbe_TcpSocketGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket(gens map[string]gopter.Gen) {
	gens["Host"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
}

func Test_ContainerAppProbe_TcpSocket_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerAppProbe_TcpSocket_STATUS to ContainerAppProbe_TcpSocket_STATUS via AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS & AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerAppProbe_TcpSocket_STATUS, ContainerAppProbe_TcpSocket_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerAppProbe_TcpSocket_STATUS tests if a specific instance of ContainerAppProbe_TcpSocket_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerAppProbe_TcpSocket_STATUS(subject ContainerAppProbe_TcpSocket_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerAppProbe_TcpSocket_STATUS
	err := copied.AssignProperties_To_ContainerAppProbe_TcpSocket_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerAppProbe_TcpSocket_STATUS
	err = actual.AssignProperties_From_ContainerAppProbe_TcpSocket_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerAppProbe_TcpSocket_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerAppProbe_TcpSocket_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerAppProbe_TcpSocket_STATUS, ContainerAppProbe_TcpSocket_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerAppProbe_TcpSocket_STATUS runs a test to see if a specific instance of ContainerAppProbe_TcpSocket_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerAppProbe_TcpSocket_STATUS(subject ContainerAppProbe_TcpSocket_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerAppProbe_TcpSocket_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerAppProbe_TcpSocket_STATUS instances for property testing - lazily instantiated by
// ContainerAppProbe_TcpSocket_STATUSGenerator()
var containerAppProbe_TcpSocket_STATUSGenerator gopter.Gen

// ContainerAppProbe_TcpSocket_STATUSGenerator returns a generator of ContainerAppProbe_TcpSocket_STATUS instances for property testing.
func ContainerAppProbe_TcpSocket_STATUSGenerator() gopter.Gen {
	if containerAppProbe_TcpSocket_STATUSGenerator != nil {
		return containerAppProbe_TcpSocket_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket_STATUS(generators)
	containerAppProbe_TcpSocket_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerAppProbe_TcpSocket_STATUS{}), generators)

	return containerAppProbe_TcpSocket_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerAppProbe_TcpSocket_STATUS(gens map[string]gopter.Gen) {
	gens["Host"] = gen.PtrOf(gen.AlphaString())
	gens["Port"] = gen.PtrOf(gen.Int())
}

func Test_ContainerApp_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerApp_STATUS to ContainerApp_STATUS via AssignProperties_To_ContainerApp_STATUS & AssignProperties_From_ContainerApp_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerApp_STATUS, ContainerApp_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerApp_STATUS tests if a specific instance of ContainerApp_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerApp_STATUS(subject ContainerApp_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerApp_STATUS
	err := copied.AssignProperties_To_ContainerApp_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerApp_STATUS
	err = actual.AssignProperties_From_ContainerApp_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerApp_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerApp_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerApp_STATUS, ContainerApp_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerApp_STATUS runs a test to see if a specific instance of ContainerApp_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerApp_STATUS(subject ContainerApp_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerApp_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerApp_STATUS instances for property testing - lazily instantiated by
// ContainerApp_STATUSGenerator()
var containerApp_STATUSGenerator gopter.Gen

// ContainerApp_STATUSGenerator returns a generator of ContainerApp_STATUS instances for property testing.
// We first initialize containerApp_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerApp_STATUSGenerator() gopter.Gen {
	if containerApp_STATUSGenerator != nil {
		return containerApp_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerApp_STATUS(generators)
	containerApp_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerApp_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerApp_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainerApp_STATUS(generators)
	containerApp_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerApp_STATUS{}), generators)

	return containerApp_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerApp_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerApp_STATUS(gens map[string]gopter.Gen) {
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["EnvironmentId"] = gen.PtrOf(gen.AlphaString())
	gens["EventStreamEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LatestReadyRevisionName"] = gen.PtrOf(gen.AlphaString())
	gens["LatestRevisionFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["LatestRevisionName"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedEnvironmentId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OutboundIpAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ContainerApp_Properties_ProvisioningState_STATUS_Canceled,
		ContainerApp_Properties_ProvisioningState_STATUS_Deleting,
		ContainerApp_Properties_ProvisioningState_STATUS_Failed,
		ContainerApp_Properties_ProvisioningState_STATUS_InProgress,
		ContainerApp_Properties_ProvisioningState_STATUS_Succeeded))
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["WorkloadProfileName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerApp_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerApp_STATUS(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(Configuration_STATUSGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
	gens["Template"] = gen.PtrOf(Template_STATUSGenerator())
}

func Test_ContainerApp_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerApp_Spec to ContainerApp_Spec via AssignProperties_To_ContainerApp_Spec & AssignProperties_From_ContainerApp_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerApp_Spec, ContainerApp_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerApp_Spec tests if a specific instance of ContainerApp_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerApp_Spec(subject ContainerApp_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerApp_Spec
	err := copied.AssignProperties_To_ContainerApp_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerApp_Spec
	err = actual.AssignProperties_From_ContainerApp_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerApp_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerApp_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerApp_Spec, ContainerApp_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerApp_Spec runs a test to see if a specific instance of ContainerApp_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerApp_Spec(subject ContainerApp_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerApp_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerApp_Spec instances for property testing - lazily instantiated by ContainerApp_SpecGenerator()
var containerApp_SpecGenerator gopter.Gen

// ContainerApp_SpecGenerator returns a generator of ContainerApp_Spec instances for property testing.
// We first initialize containerApp_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerApp_SpecGenerator() gopter.Gen {
	if containerApp_SpecGenerator != nil {
		return containerApp_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerApp_Spec(generators)
	containerApp_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerApp_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerApp_Spec(generators)
	AddRelatedPropertyGeneratorsForContainerApp_Spec(generators)
	containerApp_SpecGenerator = gen.Struct(reflect.TypeOf(ContainerApp_Spec{}), generators)

	return containerApp_SpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerApp_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerApp_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["WorkloadProfileName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerApp_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerApp_Spec(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(ConfigurationGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(ContainerAppOperatorSpecGenerator())
	gens["Template"] = gen.PtrOf(TemplateGenerator())
}

func Test_ContainerResources_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerResources to ContainerResources via AssignProperties_To_ContainerResources & AssignProperties_From_ContainerResources returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerResources, ContainerResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerResources tests if a specific instance of ContainerResources can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerResources(subject ContainerResources) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerResources
	err := copied.AssignProperties_To_ContainerResources(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerResources
	err = actual.AssignProperties_From_ContainerResources(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerResources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerResources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerResources, ContainerResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerResources runs a test to see if a specific instance of ContainerResources round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerResources(subject ContainerResources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerResources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerResources instances for property testing - lazily instantiated by ContainerResourcesGenerator()
var containerResourcesGenerator gopter.Gen

// ContainerResourcesGenerator returns a generator of ContainerResources instances for property testing.
func ContainerResourcesGenerator() gopter.Gen {
	if containerResourcesGenerator != nil {
		return containerResourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerResources(generators)
	containerResourcesGenerator = gen.Struct(reflect.TypeOf(ContainerResources{}), generators)

	return containerResourcesGenerator
}

// AddIndependentPropertyGeneratorsForContainerResources is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerResources(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["Memory"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerResources_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerResources_STATUS to ContainerResources_STATUS via AssignProperties_To_ContainerResources_STATUS & AssignProperties_From_ContainerResources_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerResources_STATUS, ContainerResources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerResources_STATUS tests if a specific instance of ContainerResources_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainerResources_STATUS(subject ContainerResources_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ContainerResources_STATUS
	err := copied.AssignProperties_To_ContainerResources_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerResources_STATUS
	err = actual.AssignProperties_From_ContainerResources_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerResources_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerResources_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerResources_STATUS, ContainerResources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerResources_STATUS runs a test to see if a specific instance of ContainerResources_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerResources_STATUS(subject ContainerResources_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerResources_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerResources_STATUS instances for property testing - lazily instantiated by
// ContainerResources_STATUSGenerator()
var containerResources_STATUSGenerator gopter.Gen

// ContainerResources_STATUSGenerator returns a generator of ContainerResources_STATUS instances for property testing.
func ContainerResources_STATUSGenerator() gopter.Gen {
	if containerResources_STATUSGenerator != nil {
		return containerResources_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerResources_STATUS(generators)
	containerResources_STATUSGenerator = gen.Struct(reflect.TypeOf(ContainerResources_STATUS{}), generators)

	return containerResources_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainerResources_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerResources_STATUS(gens map[string]gopter.Gen) {
	gens["Cpu"] = gen.PtrOf(gen.Float64())
	gens["EphemeralStorage"] = gen.PtrOf(gen.AlphaString())
	gens["Memory"] = gen.PtrOf(gen.AlphaString())
}

func Test_Container_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Container_STATUS to Container_STATUS via AssignProperties_To_Container_STATUS & AssignProperties_From_Container_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainer_STATUS, Container_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainer_STATUS tests if a specific instance of Container_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForContainer_STATUS(subject Container_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Container_STATUS
	err := copied.AssignProperties_To_Container_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Container_STATUS
	err = actual.AssignProperties_From_Container_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Container_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Container_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainer_STATUS, Container_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainer_STATUS runs a test to see if a specific instance of Container_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForContainer_STATUS(subject Container_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Container_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Container_STATUS instances for property testing - lazily instantiated by Container_STATUSGenerator()
var container_STATUSGenerator gopter.Gen

// Container_STATUSGenerator returns a generator of Container_STATUS instances for property testing.
// We first initialize container_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Container_STATUSGenerator() gopter.Gen {
	if container_STATUSGenerator != nil {
		return container_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer_STATUS(generators)
	container_STATUSGenerator = gen.Struct(reflect.TypeOf(Container_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainer_STATUS(generators)
	AddRelatedPropertyGeneratorsForContainer_STATUS(generators)
	container_STATUSGenerator = gen.Struct(reflect.TypeOf(Container_STATUS{}), generators)

	return container_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForContainer_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainer_STATUS(gens map[string]gopter.Gen) {
	gens["Args"] = gen.SliceOf(gen.AlphaString())
	gens["Command"] = gen.SliceOf(gen.AlphaString())
	gens["Image"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainer_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainer_STATUS(gens map[string]gopter.Gen) {
	gens["Env"] = gen.SliceOf(EnvironmentVar_STATUSGenerator())
	gens["Probes"] = gen.SliceOf(ContainerAppProbe_STATUSGenerator())
	gens["Resources"] = gen.PtrOf(ContainerResources_STATUSGenerator())
	gens["VolumeMounts"] = gen.SliceOf(VolumeMount_STATUSGenerator())
}

func Test_CorsPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsPolicy to CorsPolicy via AssignProperties_To_CorsPolicy & AssignProperties_From_CorsPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsPolicy, CorsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsPolicy tests if a specific instance of CorsPolicy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCorsPolicy(subject CorsPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CorsPolicy
	err := copied.AssignProperties_To_CorsPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsPolicy
	err = actual.AssignProperties_From_CorsPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy, CorsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy runs a test to see if a specific instance of CorsPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy(subject CorsPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy instances for property testing - lazily instantiated by CorsPolicyGenerator()
var corsPolicyGenerator gopter.Gen

// CorsPolicyGenerator returns a generator of CorsPolicy instances for property testing.
func CorsPolicyGenerator() gopter.Gen {
	if corsPolicyGenerator != nil {
		return corsPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy(generators)
	corsPolicyGenerator = gen.Struct(reflect.TypeOf(CorsPolicy{}), generators)

	return corsPolicyGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy(gens map[string]gopter.Gen) {
	gens["AllowCredentials"] = gen.PtrOf(gen.Bool())
	gens["AllowedHeaders"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["ExposeHeaders"] = gen.SliceOf(gen.AlphaString())
	gens["MaxAge"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsPolicy_STATUS to CorsPolicy_STATUS via AssignProperties_To_CorsPolicy_STATUS & AssignProperties_From_CorsPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsPolicy_STATUS, CorsPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsPolicy_STATUS tests if a specific instance of CorsPolicy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCorsPolicy_STATUS(subject CorsPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CorsPolicy_STATUS
	err := copied.AssignProperties_To_CorsPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsPolicy_STATUS
	err = actual.AssignProperties_From_CorsPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_STATUS, CorsPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_STATUS runs a test to see if a specific instance of CorsPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_STATUS(subject CorsPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_STATUS instances for property testing - lazily instantiated by CorsPolicy_STATUSGenerator()
var corsPolicy_STATUSGenerator gopter.Gen

// CorsPolicy_STATUSGenerator returns a generator of CorsPolicy_STATUS instances for property testing.
func CorsPolicy_STATUSGenerator() gopter.Gen {
	if corsPolicy_STATUSGenerator != nil {
		return corsPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_STATUS(generators)
	corsPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_STATUS{}), generators)

	return corsPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["AllowCredentials"] = gen.PtrOf(gen.Bool())
	gens["AllowedHeaders"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.SliceOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["ExposeHeaders"] = gen.SliceOf(gen.AlphaString())
	gens["MaxAge"] = gen.PtrOf(gen.Int())
}

func Test_CustomDomain_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomain to CustomDomain via AssignProperties_To_CustomDomain & AssignProperties_From_CustomDomain returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomain, CustomDomainGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomain tests if a specific instance of CustomDomain can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomDomain(subject CustomDomain) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomDomain
	err := copied.AssignProperties_To_CustomDomain(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomain
	err = actual.AssignProperties_From_CustomDomain(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomain_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain, CustomDomainGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain runs a test to see if a specific instance of CustomDomain round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain(subject CustomDomain) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain instances for property testing - lazily instantiated by CustomDomainGenerator()
var customDomainGenerator gopter.Gen

// CustomDomainGenerator returns a generator of CustomDomain instances for property testing.
func CustomDomainGenerator() gopter.Gen {
	if customDomainGenerator != nil {
		return customDomainGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain(generators)
	customDomainGenerator = gen.Struct(reflect.TypeOf(CustomDomain{}), generators)

	return customDomainGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain(gens map[string]gopter.Gen) {
	gens["BindingType"] = gen.PtrOf(gen.OneConstOf(CustomDomain_BindingType_Disabled, CustomDomain_BindingType_SniEnabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_CustomDomain_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomain_STATUS to CustomDomain_STATUS via AssignProperties_To_CustomDomain_STATUS & AssignProperties_From_CustomDomain_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomain_STATUS, CustomDomain_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomain_STATUS tests if a specific instance of CustomDomain_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomDomain_STATUS(subject CustomDomain_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomDomain_STATUS
	err := copied.AssignProperties_To_CustomDomain_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomain_STATUS
	err = actual.AssignProperties_From_CustomDomain_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomain_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain_STATUS, CustomDomain_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain_STATUS runs a test to see if a specific instance of CustomDomain_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain_STATUS(subject CustomDomain_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_STATUS instances for property testing - lazily instantiated by
// CustomDomain_STATUSGenerator()
var customDomain_STATUSGenerator gopter.Gen

// CustomDomain_STATUSGenerator returns a generator of CustomDomain_STATUS instances for property testing.
func CustomDomain_STATUSGenerator() gopter.Gen {
	if customDomain_STATUSGenerator != nil {
		return customDomain_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_STATUS(generators)
	customDomain_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUS{}), generators)

	return customDomain_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain_STATUS(gens map[string]gopter.Gen) {
	gens["BindingType"] = gen.PtrOf(gen.OneConstOf(CustomDomain_BindingType_STATUS_Disabled, CustomDomain_BindingType_STATUS_SniEnabled))
	gens["CertificateId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_CustomScaleRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomScaleRule to CustomScaleRule via AssignProperties_To_CustomScaleRule & AssignProperties_From_CustomScaleRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomScaleRule, CustomScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomScaleRule tests if a specific instance of CustomScaleRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomScaleRule(subject CustomScaleRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomScaleRule
	err := copied.AssignProperties_To_CustomScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomScaleRule
	err = actual.AssignProperties_From_CustomScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomScaleRule, CustomScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomScaleRule runs a test to see if a specific instance of CustomScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomScaleRule(subject CustomScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomScaleRule instances for property testing - lazily instantiated by CustomScaleRuleGenerator()
var customScaleRuleGenerator gopter.Gen

// CustomScaleRuleGenerator returns a generator of CustomScaleRule instances for property testing.
// We first initialize customScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomScaleRuleGenerator() gopter.Gen {
	if customScaleRuleGenerator != nil {
		return customScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomScaleRule(generators)
	customScaleRuleGenerator = gen.Struct(reflect.TypeOf(CustomScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomScaleRule(generators)
	AddRelatedPropertyGeneratorsForCustomScaleRule(generators)
	customScaleRuleGenerator = gen.Struct(reflect.TypeOf(CustomScaleRule{}), generators)

	return customScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForCustomScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomScaleRule(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCustomScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_CustomScaleRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomScaleRule_STATUS to CustomScaleRule_STATUS via AssignProperties_To_CustomScaleRule_STATUS & AssignProperties_From_CustomScaleRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomScaleRule_STATUS, CustomScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomScaleRule_STATUS tests if a specific instance of CustomScaleRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomScaleRule_STATUS(subject CustomScaleRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomScaleRule_STATUS
	err := copied.AssignProperties_To_CustomScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomScaleRule_STATUS
	err = actual.AssignProperties_From_CustomScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomScaleRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomScaleRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomScaleRule_STATUS, CustomScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomScaleRule_STATUS runs a test to see if a specific instance of CustomScaleRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomScaleRule_STATUS(subject CustomScaleRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomScaleRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomScaleRule_STATUS instances for property testing - lazily instantiated by
// CustomScaleRule_STATUSGenerator()
var customScaleRule_STATUSGenerator gopter.Gen

// CustomScaleRule_STATUSGenerator returns a generator of CustomScaleRule_STATUS instances for property testing.
// We first initialize customScaleRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomScaleRule_STATUSGenerator() gopter.Gen {
	if customScaleRule_STATUSGenerator != nil {
		return customScaleRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomScaleRule_STATUS(generators)
	customScaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomScaleRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomScaleRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForCustomScaleRule_STATUS(generators)
	customScaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomScaleRule_STATUS{}), generators)

	return customScaleRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomScaleRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCustomScaleRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuth_STATUSGenerator())
}

func Test_Dapr_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Dapr to Dapr via AssignProperties_To_Dapr & AssignProperties_From_Dapr returns original",
		prop.ForAll(RunPropertyAssignmentTestForDapr, DaprGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDapr tests if a specific instance of Dapr can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDapr(subject Dapr) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Dapr
	err := copied.AssignProperties_To_Dapr(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Dapr
	err = actual.AssignProperties_From_Dapr(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Dapr_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Dapr via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDapr, DaprGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDapr runs a test to see if a specific instance of Dapr round trips to JSON and back losslessly
func RunJSONSerializationTestForDapr(subject Dapr) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Dapr
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Dapr instances for property testing - lazily instantiated by DaprGenerator()
var daprGenerator gopter.Gen

// DaprGenerator returns a generator of Dapr instances for property testing.
func DaprGenerator() gopter.Gen {
	if daprGenerator != nil {
		return daprGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDapr(generators)
	daprGenerator = gen.Struct(reflect.TypeOf(Dapr{}), generators)

	return daprGenerator
}

// AddIndependentPropertyGeneratorsForDapr is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDapr(gens map[string]gopter.Gen) {
	gens["AppId"] = gen.PtrOf(gen.AlphaString())
	gens["AppPort"] = gen.PtrOf(gen.Int())
	gens["AppProtocol"] = gen.PtrOf(gen.OneConstOf(Dapr_AppProtocol_Grpc, Dapr_AppProtocol_Http))
	gens["EnableApiLogging"] = gen.PtrOf(gen.Bool())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HttpMaxRequestSize"] = gen.PtrOf(gen.Int())
	gens["HttpReadBufferSize"] = gen.PtrOf(gen.Int())
	gens["LogLevel"] = gen.PtrOf(gen.OneConstOf(
		Dapr_LogLevel_Debug,
		Dapr_LogLevel_Error,
		Dapr_LogLevel_Info,
		Dapr_LogLevel_Warn))
}

func Test_Dapr_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Dapr_STATUS to Dapr_STATUS via AssignProperties_To_Dapr_STATUS & AssignProperties_From_Dapr_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDapr_STATUS, Dapr_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDapr_STATUS tests if a specific instance of Dapr_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDapr_STATUS(subject Dapr_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Dapr_STATUS
	err := copied.AssignProperties_To_Dapr_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Dapr_STATUS
	err = actual.AssignProperties_From_Dapr_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Dapr_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Dapr_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDapr_STATUS, Dapr_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDapr_STATUS runs a test to see if a specific instance of Dapr_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDapr_STATUS(subject Dapr_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Dapr_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Dapr_STATUS instances for property testing - lazily instantiated by Dapr_STATUSGenerator()
var dapr_STATUSGenerator gopter.Gen

// Dapr_STATUSGenerator returns a generator of Dapr_STATUS instances for property testing.
func Dapr_STATUSGenerator() gopter.Gen {
	if dapr_STATUSGenerator != nil {
		return dapr_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDapr_STATUS(generators)
	dapr_STATUSGenerator = gen.Struct(reflect.TypeOf(Dapr_STATUS{}), generators)

	return dapr_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDapr_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDapr_STATUS(gens map[string]gopter.Gen) {
	gens["AppId"] = gen.PtrOf(gen.AlphaString())
	gens["AppPort"] = gen.PtrOf(gen.Int())
	gens["AppProtocol"] = gen.PtrOf(gen.OneConstOf(Dapr_AppProtocol_STATUS_Grpc, Dapr_AppProtocol_STATUS_Http))
	gens["EnableApiLogging"] = gen.PtrOf(gen.Bool())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HttpMaxRequestSize"] = gen.PtrOf(gen.Int())
	gens["HttpReadBufferSize"] = gen.PtrOf(gen.Int())
	gens["LogLevel"] = gen.PtrOf(gen.OneConstOf(
		Dapr_LogLevel_STATUS_Debug,
		Dapr_LogLevel_STATUS_Error,
		Dapr_LogLevel_STATUS_Info,
		Dapr_LogLevel_STATUS_Warn))
}

func Test_EnvironmentVar_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnvironmentVar to EnvironmentVar via AssignProperties_To_EnvironmentVar & AssignProperties_From_EnvironmentVar returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnvironmentVar, EnvironmentVarGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnvironmentVar tests if a specific instance of EnvironmentVar can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEnvironmentVar(subject EnvironmentVar) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EnvironmentVar
	err := copied.AssignProperties_To_EnvironmentVar(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnvironmentVar
	err = actual.AssignProperties_From_EnvironmentVar(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnvironmentVar_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVar via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVar, EnvironmentVarGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVar runs a test to see if a specific instance of EnvironmentVar round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVar(subject EnvironmentVar) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVar
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVar instances for property testing - lazily instantiated by EnvironmentVarGenerator()
var environmentVarGenerator gopter.Gen

// EnvironmentVarGenerator returns a generator of EnvironmentVar instances for property testing.
func EnvironmentVarGenerator() gopter.Gen {
	if environmentVarGenerator != nil {
		return environmentVarGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVar(generators)
	environmentVarGenerator = gen.Struct(reflect.TypeOf(EnvironmentVar{}), generators)

	return environmentVarGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVar is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVar(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnvironmentVar_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnvironmentVar_STATUS to EnvironmentVar_STATUS via AssignProperties_To_EnvironmentVar_STATUS & AssignProperties_From_EnvironmentVar_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnvironmentVar_STATUS, EnvironmentVar_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnvironmentVar_STATUS tests if a specific instance of EnvironmentVar_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEnvironmentVar_STATUS(subject EnvironmentVar_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EnvironmentVar_STATUS
	err := copied.AssignProperties_To_EnvironmentVar_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnvironmentVar_STATUS
	err = actual.AssignProperties_From_EnvironmentVar_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnvironmentVar_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnvironmentVar_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnvironmentVar_STATUS, EnvironmentVar_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnvironmentVar_STATUS runs a test to see if a specific instance of EnvironmentVar_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEnvironmentVar_STATUS(subject EnvironmentVar_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnvironmentVar_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnvironmentVar_STATUS instances for property testing - lazily instantiated by
// EnvironmentVar_STATUSGenerator()
var environmentVar_STATUSGenerator gopter.Gen

// EnvironmentVar_STATUSGenerator returns a generator of EnvironmentVar_STATUS instances for property testing.
func EnvironmentVar_STATUSGenerator() gopter.Gen {
	if environmentVar_STATUSGenerator != nil {
		return environmentVar_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnvironmentVar_STATUS(generators)
	environmentVar_STATUSGenerator = gen.Struct(reflect.TypeOf(EnvironmentVar_STATUS{}), generators)

	return environmentVar_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEnvironmentVar_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnvironmentVar_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtendedLocation_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation to ExtendedLocation via AssignProperties_To_ExtendedLocation & AssignProperties_From_ExtendedLocation returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation, ExtendedLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation tests if a specific instance of ExtendedLocation can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation(subject ExtendedLocation) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExtendedLocation
	err := copied.AssignProperties_To_ExtendedLocation(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation
	err = actual.AssignProperties_From_ExtendedLocation(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation, ExtendedLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation runs a test to see if a specific instance of ExtendedLocation round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation(subject ExtendedLocation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation instances for property testing - lazily instantiated by ExtendedLocationGenerator()
var extendedLocationGenerator gopter.Gen

// ExtendedLocationGenerator returns a generator of ExtendedLocation instances for property testing.
func ExtendedLocationGenerator() gopter.Gen {
	if extendedLocationGenerator != nil {
		return extendedLocationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation(generators)
	extendedLocationGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation{}), generators)

	return extendedLocationGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_CustomLocation))
}

func Test_ExtendedLocation_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtendedLocation_STATUS to ExtendedLocation_STATUS via AssignProperties_To_ExtendedLocation_STATUS & AssignProperties_From_ExtendedLocation_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtendedLocation_STATUS, ExtendedLocation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtendedLocation_STATUS tests if a specific instance of ExtendedLocation_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtendedLocation_STATUS(subject ExtendedLocation_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExtendedLocation_STATUS
	err := copied.AssignProperties_To_ExtendedLocation_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtendedLocation_STATUS
	err = actual.AssignProperties_From_ExtendedLocation_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtendedLocation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocation_STATUS, ExtendedLocation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocation_STATUS runs a test to see if a specific instance of ExtendedLocation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocation_STATUS(subject ExtendedLocation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocation_STATUS instances for property testing - lazily instantiated by
// ExtendedLocation_STATUSGenerator()
var extendedLocation_STATUSGenerator gopter.Gen

// ExtendedLocation_STATUSGenerator returns a generator of ExtendedLocation_STATUS instances for property testing.
func ExtendedLocation_STATUSGenerator() gopter.Gen {
	if extendedLocation_STATUSGenerator != nil {
		return extendedLocation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocation_STATUS(generators)
	extendedLocation_STATUSGenerator = gen.Struct(reflect.TypeOf(ExtendedLocation_STATUS{}), generators)

	return extendedLocation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocation_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocationType_STATUS_CustomLocation))
}

func Test_HttpScaleRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpScaleRule to HttpScaleRule via AssignProperties_To_HttpScaleRule & AssignProperties_From_HttpScaleRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpScaleRule, HttpScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpScaleRule tests if a specific instance of HttpScaleRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHttpScaleRule(subject HttpScaleRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HttpScaleRule
	err := copied.AssignProperties_To_HttpScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpScaleRule
	err = actual.AssignProperties_From_HttpScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpScaleRule, HttpScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpScaleRule runs a test to see if a specific instance of HttpScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpScaleRule(subject HttpScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpScaleRule instances for property testing - lazily instantiated by HttpScaleRuleGenerator()
var httpScaleRuleGenerator gopter.Gen

// HttpScaleRuleGenerator returns a generator of HttpScaleRule instances for property testing.
// We first initialize httpScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HttpScaleRuleGenerator() gopter.Gen {
	if httpScaleRuleGenerator != nil {
		return httpScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpScaleRule(generators)
	httpScaleRuleGenerator = gen.Struct(reflect.TypeOf(HttpScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpScaleRule(generators)
	AddRelatedPropertyGeneratorsForHttpScaleRule(generators)
	httpScaleRuleGenerator = gen.Struct(reflect.TypeOf(HttpScaleRule{}), generators)

	return httpScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForHttpScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpScaleRule(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHttpScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHttpScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_HttpScaleRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpScaleRule_STATUS to HttpScaleRule_STATUS via AssignProperties_To_HttpScaleRule_STATUS & AssignProperties_From_HttpScaleRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpScaleRule_STATUS, HttpScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpScaleRule_STATUS tests if a specific instance of HttpScaleRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHttpScaleRule_STATUS(subject HttpScaleRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HttpScaleRule_STATUS
	err := copied.AssignProperties_To_HttpScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpScaleRule_STATUS
	err = actual.AssignProperties_From_HttpScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpScaleRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpScaleRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpScaleRule_STATUS, HttpScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpScaleRule_STATUS runs a test to see if a specific instance of HttpScaleRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpScaleRule_STATUS(subject HttpScaleRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpScaleRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpScaleRule_STATUS instances for property testing - lazily instantiated by
// HttpScaleRule_STATUSGenerator()
var httpScaleRule_STATUSGenerator gopter.Gen

// HttpScaleRule_STATUSGenerator returns a generator of HttpScaleRule_STATUS instances for property testing.
// We first initialize httpScaleRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HttpScaleRule_STATUSGenerator() gopter.Gen {
	if httpScaleRule_STATUSGenerator != nil {
		return httpScaleRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpScaleRule_STATUS(generators)
	httpScaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpScaleRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpScaleRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForHttpScaleRule_STATUS(generators)
	httpScaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpScaleRule_STATUS{}), generators)

	return httpScaleRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpScaleRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHttpScaleRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHttpScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuth_STATUSGenerator())
}

func Test_Ingress_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Ingress to Ingress via AssignProperties_To_Ingress & AssignProperties_From_Ingress returns original",
		prop.ForAll(RunPropertyAssignmentTestForIngress, IngressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIngress tests if a specific instance of Ingress can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIngress(subject Ingress) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Ingress
	err := copied.AssignProperties_To_Ingress(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Ingress
	err = actual.AssignProperties_From_Ingress(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Ingress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Ingress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngress, IngressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngress runs a test to see if a specific instance of Ingress round trips to JSON and back losslessly
func RunJSONSerializationTestForIngress(subject Ingress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Ingress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Ingress instances for property testing - lazily instantiated by IngressGenerator()
var ingressGenerator gopter.Gen

// IngressGenerator returns a generator of Ingress instances for property testing.
// We first initialize ingressGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IngressGenerator() gopter.Gen {
	if ingressGenerator != nil {
		return ingressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress(generators)
	ingressGenerator = gen.Struct(reflect.TypeOf(Ingress{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress(generators)
	AddRelatedPropertyGeneratorsForIngress(generators)
	ingressGenerator = gen.Struct(reflect.TypeOf(Ingress{}), generators)

	return ingressGenerator
}

// AddIndependentPropertyGeneratorsForIngress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngress(gens map[string]gopter.Gen) {
	gens["AllowInsecure"] = gen.PtrOf(gen.Bool())
	gens["ClientCertificateMode"] = gen.PtrOf(gen.OneConstOf(Ingress_ClientCertificateMode_Accept, Ingress_ClientCertificateMode_Ignore, Ingress_ClientCertificateMode_Require))
	gens["ExposedPort"] = gen.PtrOf(gen.Int())
	gens["External"] = gen.PtrOf(gen.Bool())
	gens["TargetPort"] = gen.PtrOf(gen.Int())
	gens["Transport"] = gen.PtrOf(gen.OneConstOf(
		Ingress_Transport_Auto,
		Ingress_Transport_Http,
		Ingress_Transport_Http2,
		Ingress_Transport_Tcp))
}

// AddRelatedPropertyGeneratorsForIngress is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIngress(gens map[string]gopter.Gen) {
	gens["AdditionalPortMappings"] = gen.SliceOf(IngressPortMappingGenerator())
	gens["CorsPolicy"] = gen.PtrOf(CorsPolicyGenerator())
	gens["CustomDomains"] = gen.SliceOf(CustomDomainGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionRuleGenerator())
	gens["StickySessions"] = gen.PtrOf(Ingress_StickySessionsGenerator())
	gens["Traffic"] = gen.SliceOf(TrafficWeightGenerator())
}

func Test_IngressPortMapping_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IngressPortMapping to IngressPortMapping via AssignProperties_To_IngressPortMapping & AssignProperties_From_IngressPortMapping returns original",
		prop.ForAll(RunPropertyAssignmentTestForIngressPortMapping, IngressPortMappingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIngressPortMapping tests if a specific instance of IngressPortMapping can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIngressPortMapping(subject IngressPortMapping) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IngressPortMapping
	err := copied.AssignProperties_To_IngressPortMapping(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IngressPortMapping
	err = actual.AssignProperties_From_IngressPortMapping(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IngressPortMapping_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IngressPortMapping via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngressPortMapping, IngressPortMappingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngressPortMapping runs a test to see if a specific instance of IngressPortMapping round trips to JSON and back losslessly
func RunJSONSerializationTestForIngressPortMapping(subject IngressPortMapping) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IngressPortMapping
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IngressPortMapping instances for property testing - lazily instantiated by IngressPortMappingGenerator()
var ingressPortMappingGenerator gopter.Gen

// IngressPortMappingGenerator returns a generator of IngressPortMapping instances for property testing.
func IngressPortMappingGenerator() gopter.Gen {
	if ingressPortMappingGenerator != nil {
		return ingressPortMappingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngressPortMapping(generators)
	ingressPortMappingGenerator = gen.Struct(reflect.TypeOf(IngressPortMapping{}), generators)

	return ingressPortMappingGenerator
}

// AddIndependentPropertyGeneratorsForIngressPortMapping is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngressPortMapping(gens map[string]gopter.Gen) {
	gens["ExposedPort"] = gen.PtrOf(gen.Int())
	gens["External"] = gen.PtrOf(gen.Bool())
	gens["TargetPort"] = gen.PtrOf(gen.Int())
}

func Test_IngressPortMapping_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IngressPortMapping_STATUS to IngressPortMapping_STATUS via AssignProperties_To_IngressPortMapping_STATUS & AssignProperties_From_IngressPortMapping_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIngressPortMapping_STATUS, IngressPortMapping_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIngressPortMapping_STATUS tests if a specific instance of IngressPortMapping_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIngressPortMapping_STATUS(subject IngressPortMapping_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IngressPortMapping_STATUS
	err := copied.AssignProperties_To_IngressPortMapping_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IngressPortMapping_STATUS
	err = actual.AssignProperties_From_IngressPortMapping_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IngressPortMapping_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IngressPortMapping_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngressPortMapping_STATUS, IngressPortMapping_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngressPortMapping_STATUS runs a test to see if a specific instance of IngressPortMapping_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIngressPortMapping_STATUS(subject IngressPortMapping_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IngressPortMapping_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IngressPortMapping_STATUS instances for property testing - lazily instantiated by
// IngressPortMapping_STATUSGenerator()
var ingressPortMapping_STATUSGenerator gopter.Gen

// IngressPortMapping_STATUSGenerator returns a generator of IngressPortMapping_STATUS instances for property testing.
func IngressPortMapping_STATUSGenerator() gopter.Gen {
	if ingressPortMapping_STATUSGenerator != nil {
		return ingressPortMapping_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngressPortMapping_STATUS(generators)
	ingressPortMapping_STATUSGenerator = gen.Struct(reflect.TypeOf(IngressPortMapping_STATUS{}), generators)

	return ingressPortMapping_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIngressPortMapping_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngressPortMapping_STATUS(gens map[string]gopter.Gen) {
	gens["ExposedPort"] = gen.PtrOf(gen.Int())
	gens["External"] = gen.PtrOf(gen.Bool())
	gens["TargetPort"] = gen.PtrOf(gen.Int())
}

func Test_Ingress_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Ingress_STATUS to Ingress_STATUS via AssignProperties_To_Ingress_STATUS & AssignProperties_From_Ingress_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIngress_STATUS, Ingress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIngress_STATUS tests if a specific instance of Ingress_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIngress_STATUS(subject Ingress_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Ingress_STATUS
	err := copied.AssignProperties_To_Ingress_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Ingress_STATUS
	err = actual.AssignProperties_From_Ingress_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Ingress_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Ingress_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngress_STATUS, Ingress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngress_STATUS runs a test to see if a specific instance of Ingress_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIngress_STATUS(subject Ingress_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Ingress_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Ingress_STATUS instances for property testing - lazily instantiated by Ingress_STATUSGenerator()
var ingress_STATUSGenerator gopter.Gen

// Ingress_STATUSGenerator returns a generator of Ingress_STATUS instances for property testing.
// We first initialize ingress_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Ingress_STATUSGenerator() gopter.Gen {
	if ingress_STATUSGenerator != nil {
		return ingress_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress_STATUS(generators)
	ingress_STATUSGenerator = gen.Struct(reflect.TypeOf(Ingress_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress_STATUS(generators)
	AddRelatedPropertyGeneratorsForIngress_STATUS(generators)
	ingress_STATUSGenerator = gen.Struct(reflect.TypeOf(Ingress_STATUS{}), generators)

	return ingress_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIngress_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngress_STATUS(gens map[string]gopter.Gen) {
	gens["AllowInsecure"] = gen.PtrOf(gen.Bool())
	gens["ClientCertificateMode"] = gen.PtrOf(gen.OneConstOf(Ingress_ClientCertificateMode_STATUS_Accept, Ingress_ClientCertificateMode_STATUS_Ignore, Ingress_ClientCertificateMode_STATUS_Require))
	gens["ExposedPort"] = gen.PtrOf(gen.Int())
	gens["External"] = gen.PtrOf(gen.Bool())
	gens["Fqdn"] = gen.PtrOf(gen.AlphaString())
	gens["TargetPort"] = gen.PtrOf(gen.Int())
	gens["Transport"] = gen.PtrOf(gen.OneConstOf(
		Ingress_Transport_STATUS_Auto,
		Ingress_Transport_STATUS_Http,
		Ingress_Transport_STATUS_Http2,
		Ingress_Transport_STATUS_Tcp))
}

// AddRelatedPropertyGeneratorsForIngress_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIngress_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalPortMappings"] = gen.SliceOf(IngressPortMapping_STATUSGenerator())
	gens["CorsPolicy"] = gen.PtrOf(CorsPolicy_STATUSGenerator())
	gens["CustomDomains"] = gen.SliceOf(CustomDomain_STATUSGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionRule_STATUSGenerator())
	gens["StickySessions"] = gen.PtrOf(Ingress_StickySessions_STATUSGenerator())
	gens["Traffic"] = gen.SliceOf(TrafficWeight_STATUSGenerator())
}

func Test_Ingress_StickySessions_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Ingress_StickySessions to Ingress_StickySessions via AssignProperties_To_Ingress_StickySessions & AssignProperties_From_Ingress_StickySessions returns original",
		prop.ForAll(RunPropertyAssignmentTestForIngress_StickySessions, Ingress_StickySessionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIngress_StickySessions tests if a specific instance of Ingress_StickySessions can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIngress_StickySessions(subject Ingress_StickySessions) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Ingress_StickySessions
	err := copied.AssignProperties_To_Ingress_StickySessions(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Ingress_StickySessions
	err = actual.AssignProperties_From_Ingress_StickySessions(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Ingress_StickySessions_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Ingress_StickySessions via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngress_StickySessions, Ingress_StickySessionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngress_StickySessions runs a test to see if a specific instance of Ingress_StickySessions round trips to JSON and back losslessly
func RunJSONSerializationTestForIngress_StickySessions(subject Ingress_StickySessions) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Ingress_StickySessions
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Ingress_StickySessions instances for property testing - lazily instantiated by
// Ingress_StickySessionsGenerator()
var ingress_StickySessionsGenerator gopter.Gen

// Ingress_StickySessionsGenerator returns a generator of Ingress_StickySessions instances for property testing.
func Ingress_StickySessionsGenerator() gopter.Gen {
	if ingress_StickySessionsGenerator != nil {
		return ingress_StickySessionsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress_StickySessions(generators)
	ingress_StickySessionsGenerator = gen.Struct(reflect.TypeOf(Ingress_StickySessions{}), generators)

	return ingress_StickySessionsGenerator
}

// AddIndependentPropertyGeneratorsForIngress_StickySessions is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngress_StickySessions(gens map[string]gopter.Gen) {
	gens["Affinity"] = gen.PtrOf(gen.OneConstOf(Ingress_StickySessions_Affinity_None, Ingress_StickySessions_Affinity_Sticky))
}

func Test_Ingress_StickySessions_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Ingress_StickySessions_STATUS to Ingress_StickySessions_STATUS via AssignProperties_To_Ingress_StickySessions_STATUS & AssignProperties_From_Ingress_StickySessions_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIngress_StickySessions_STATUS, Ingress_StickySessions_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIngress_StickySessions_STATUS tests if a specific instance of Ingress_StickySessions_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIngress_StickySessions_STATUS(subject Ingress_StickySessions_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Ingress_StickySessions_STATUS
	err := copied.AssignProperties_To_Ingress_StickySessions_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Ingress_StickySessions_STATUS
	err = actual.AssignProperties_From_Ingress_StickySessions_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Ingress_StickySessions_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Ingress_StickySessions_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngress_StickySessions_STATUS, Ingress_StickySessions_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngress_StickySessions_STATUS runs a test to see if a specific instance of Ingress_StickySessions_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIngress_StickySessions_STATUS(subject Ingress_StickySessions_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Ingress_StickySessions_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Ingress_StickySessions_STATUS instances for property testing - lazily instantiated by
// Ingress_StickySessions_STATUSGenerator()
var ingress_StickySessions_STATUSGenerator gopter.Gen

// Ingress_StickySessions_STATUSGenerator returns a generator of Ingress_StickySessions_STATUS instances for property testing.
func Ingress_StickySessions_STATUSGenerator() gopter.Gen {
	if ingress_StickySessions_STATUSGenerator != nil {
		return ingress_StickySessions_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngress_StickySessions_STATUS(generators)
	ingress_StickySessions_STATUSGenerator = gen.Struct(reflect.TypeOf(Ingress_StickySessions_STATUS{}), generators)

	return ingress_StickySessions_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIngress_StickySessions_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngress_StickySessions_STATUS(gens map[string]gopter.Gen) {
	gens["Affinity"] = gen.PtrOf(gen.OneConstOf(Ingress_StickySessions_Affinity_STATUS_None, Ingress_StickySessions_Affinity_STATUS_Sticky))
}

func Test_IpSecurityRestrictionRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpSecurityRestrictionRule to IpSecurityRestrictionRule via AssignProperties_To_IpSecurityRestrictionRule & AssignProperties_From_IpSecurityRestrictionRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpSecurityRestrictionRule, IpSecurityRestrictionRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpSecurityRestrictionRule tests if a specific instance of IpSecurityRestrictionRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIpSecurityRestrictionRule(subject IpSecurityRestrictionRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IpSecurityRestrictionRule
	err := copied.AssignProperties_To_IpSecurityRestrictionRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpSecurityRestrictionRule
	err = actual.AssignProperties_From_IpSecurityRestrictionRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpSecurityRestrictionRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestrictionRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestrictionRule, IpSecurityRestrictionRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestrictionRule runs a test to see if a specific instance of IpSecurityRestrictionRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestrictionRule(subject IpSecurityRestrictionRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestrictionRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestrictionRule instances for property testing - lazily instantiated by
// IpSecurityRestrictionRuleGenerator()
var ipSecurityRestrictionRuleGenerator gopter.Gen

// IpSecurityRestrictionRuleGenerator returns a generator of IpSecurityRestrictionRule instances for property testing.
func IpSecurityRestrictionRuleGenerator() gopter.Gen {
	if ipSecurityRestrictionRuleGenerator != nil {
		return ipSecurityRestrictionRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule(generators)
	ipSecurityRestrictionRuleGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestrictionRule{}), generators)

	return ipSecurityRestrictionRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestrictionRule_Action_Allow, IpSecurityRestrictionRule_Action_Deny))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddressRange"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpSecurityRestrictionRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpSecurityRestrictionRule_STATUS to IpSecurityRestrictionRule_STATUS via AssignProperties_To_IpSecurityRestrictionRule_STATUS & AssignProperties_From_IpSecurityRestrictionRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpSecurityRestrictionRule_STATUS, IpSecurityRestrictionRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpSecurityRestrictionRule_STATUS tests if a specific instance of IpSecurityRestrictionRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIpSecurityRestrictionRule_STATUS(subject IpSecurityRestrictionRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IpSecurityRestrictionRule_STATUS
	err := copied.AssignProperties_To_IpSecurityRestrictionRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpSecurityRestrictionRule_STATUS
	err = actual.AssignProperties_From_IpSecurityRestrictionRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpSecurityRestrictionRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestrictionRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestrictionRule_STATUS, IpSecurityRestrictionRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestrictionRule_STATUS runs a test to see if a specific instance of IpSecurityRestrictionRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestrictionRule_STATUS(subject IpSecurityRestrictionRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestrictionRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestrictionRule_STATUS instances for property testing - lazily instantiated by
// IpSecurityRestrictionRule_STATUSGenerator()
var ipSecurityRestrictionRule_STATUSGenerator gopter.Gen

// IpSecurityRestrictionRule_STATUSGenerator returns a generator of IpSecurityRestrictionRule_STATUS instances for property testing.
func IpSecurityRestrictionRule_STATUSGenerator() gopter.Gen {
	if ipSecurityRestrictionRule_STATUSGenerator != nil {
		return ipSecurityRestrictionRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule_STATUS(generators)
	ipSecurityRestrictionRule_STATUSGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestrictionRule_STATUS{}), generators)

	return ipSecurityRestrictionRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestrictionRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestrictionRule_Action_STATUS_Allow, IpSecurityRestrictionRule_Action_STATUS_Deny))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["IpAddressRange"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity to ManagedServiceIdentity via AssignProperties_To_ManagedServiceIdentity & AssignProperties_From_ManagedServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity tests if a specific instance of ManagedServiceIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity
	err := copied.AssignProperties_To_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity
	err = actual.AssignProperties_From_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_None,
		ManagedServiceIdentityType_SystemAssigned,
		ManagedServiceIdentityType_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_STATUS to ManagedServiceIdentity_STATUS via AssignProperties_To_ManagedServiceIdentity_STATUS & AssignProperties_From_ManagedServiceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_STATUS tests if a specific instance of ManagedServiceIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity_STATUS
	err := copied.AssignProperties_To_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_STATUS
	err = actual.AssignProperties_From_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_STATUS_None,
		ManagedServiceIdentityType_STATUS_SystemAssigned,
		ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentity_STATUSGenerator())
}

func Test_QueueScaleRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from QueueScaleRule to QueueScaleRule via AssignProperties_To_QueueScaleRule & AssignProperties_From_QueueScaleRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForQueueScaleRule, QueueScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForQueueScaleRule tests if a specific instance of QueueScaleRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForQueueScaleRule(subject QueueScaleRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.QueueScaleRule
	err := copied.AssignProperties_To_QueueScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual QueueScaleRule
	err = actual.AssignProperties_From_QueueScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_QueueScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueueScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueueScaleRule, QueueScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueueScaleRule runs a test to see if a specific instance of QueueScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForQueueScaleRule(subject QueueScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueueScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueueScaleRule instances for property testing - lazily instantiated by QueueScaleRuleGenerator()
var queueScaleRuleGenerator gopter.Gen

// QueueScaleRuleGenerator returns a generator of QueueScaleRule instances for property testing.
// We first initialize queueScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func QueueScaleRuleGenerator() gopter.Gen {
	if queueScaleRuleGenerator != nil {
		return queueScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueueScaleRule(generators)
	queueScaleRuleGenerator = gen.Struct(reflect.TypeOf(QueueScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueueScaleRule(generators)
	AddRelatedPropertyGeneratorsForQueueScaleRule(generators)
	queueScaleRuleGenerator = gen.Struct(reflect.TypeOf(QueueScaleRule{}), generators)

	return queueScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForQueueScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueueScaleRule(gens map[string]gopter.Gen) {
	gens["QueueLength"] = gen.PtrOf(gen.Int())
	gens["QueueName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForQueueScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForQueueScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_QueueScaleRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from QueueScaleRule_STATUS to QueueScaleRule_STATUS via AssignProperties_To_QueueScaleRule_STATUS & AssignProperties_From_QueueScaleRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForQueueScaleRule_STATUS, QueueScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForQueueScaleRule_STATUS tests if a specific instance of QueueScaleRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForQueueScaleRule_STATUS(subject QueueScaleRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.QueueScaleRule_STATUS
	err := copied.AssignProperties_To_QueueScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual QueueScaleRule_STATUS
	err = actual.AssignProperties_From_QueueScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_QueueScaleRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueueScaleRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueueScaleRule_STATUS, QueueScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueueScaleRule_STATUS runs a test to see if a specific instance of QueueScaleRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForQueueScaleRule_STATUS(subject QueueScaleRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueueScaleRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueueScaleRule_STATUS instances for property testing - lazily instantiated by
// QueueScaleRule_STATUSGenerator()
var queueScaleRule_STATUSGenerator gopter.Gen

// QueueScaleRule_STATUSGenerator returns a generator of QueueScaleRule_STATUS instances for property testing.
// We first initialize queueScaleRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func QueueScaleRule_STATUSGenerator() gopter.Gen {
	if queueScaleRule_STATUSGenerator != nil {
		return queueScaleRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueueScaleRule_STATUS(generators)
	queueScaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(QueueScaleRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueueScaleRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForQueueScaleRule_STATUS(generators)
	queueScaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(QueueScaleRule_STATUS{}), generators)

	return queueScaleRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForQueueScaleRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueueScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["QueueLength"] = gen.PtrOf(gen.Int())
	gens["QueueName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForQueueScaleRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForQueueScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuth_STATUSGenerator())
}

func Test_RegistryCredentials_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RegistryCredentials to RegistryCredentials via AssignProperties_To_RegistryCredentials & AssignProperties_From_RegistryCredentials returns original",
		prop.ForAll(RunPropertyAssignmentTestForRegistryCredentials, RegistryCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRegistryCredentials tests if a specific instance of RegistryCredentials can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRegistryCredentials(subject RegistryCredentials) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RegistryCredentials
	err := copied.AssignProperties_To_RegistryCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RegistryCredentials
	err = actual.AssignProperties_From_RegistryCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RegistryCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryCredentials, RegistryCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryCredentials runs a test to see if a specific instance of RegistryCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryCredentials(subject RegistryCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryCredentials instances for property testing - lazily instantiated by
// RegistryCredentialsGenerator()
var registryCredentialsGenerator gopter.Gen

// RegistryCredentialsGenerator returns a generator of RegistryCredentials instances for property testing.
func RegistryCredentialsGenerator() gopter.Gen {
	if registryCredentialsGenerator != nil {
		return registryCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryCredentials(generators)
	registryCredentialsGenerator = gen.Struct(reflect.TypeOf(RegistryCredentials{}), generators)

	return registryCredentialsGenerator
}

// AddIndependentPropertyGeneratorsForRegistryCredentials is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryCredentials(gens map[string]gopter.Gen) {
	gens["PasswordSecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_RegistryCredentials_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RegistryCredentials_STATUS to RegistryCredentials_STATUS via AssignProperties_To_RegistryCredentials_STATUS & AssignProperties_From_RegistryCredentials_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRegistryCredentials_STATUS, RegistryCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRegistryCredentials_STATUS tests if a specific instance of RegistryCredentials_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRegistryCredentials_STATUS(subject RegistryCredentials_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RegistryCredentials_STATUS
	err := copied.AssignProperties_To_RegistryCredentials_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RegistryCredentials_STATUS
	err = actual.AssignProperties_From_RegistryCredentials_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RegistryCredentials_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryCredentials_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryCredentials_STATUS, RegistryCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryCredentials_STATUS runs a test to see if a specific instance of RegistryCredentials_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryCredentials_STATUS(subject RegistryCredentials_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryCredentials_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryCredentials_STATUS instances for property testing - lazily instantiated by
// RegistryCredentials_STATUSGenerator()
var registryCredentials_STATUSGenerator gopter.Gen

// RegistryCredentials_STATUSGenerator returns a generator of RegistryCredentials_STATUS instances for property testing.
func RegistryCredentials_STATUSGenerator() gopter.Gen {
	if registryCredentials_STATUSGenerator != nil {
		return registryCredentials_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryCredentials_STATUS(generators)
	registryCredentials_STATUSGenerator = gen.Struct(reflect.TypeOf(RegistryCredentials_STATUS{}), generators)

	return registryCredentials_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRegistryCredentials_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["PasswordSecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["Server"] = gen.PtrOf(gen.AlphaString())
	gens["Username"] = gen.PtrOf(gen.AlphaString())
}

func Test_Scale_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Scale to Scale via AssignProperties_To_Scale & AssignProperties_From_Scale returns original",
		prop.ForAll(RunPropertyAssignmentTestForScale, ScaleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScale tests if a specific instance of Scale can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScale(subject Scale) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Scale
	err := copied.AssignProperties_To_Scale(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Scale
	err = actual.AssignProperties_From_Scale(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Scale_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Scale via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScale, ScaleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScale runs a test to see if a specific instance of Scale round trips to JSON and back losslessly
func RunJSONSerializationTestForScale(subject Scale) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Scale
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Scale instances for property testing - lazily instantiated by ScaleGenerator()
var scaleGenerator gopter.Gen

// ScaleGenerator returns a generator of Scale instances for property testing.
// We first initialize scaleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScaleGenerator() gopter.Gen {
	if scaleGenerator != nil {
		return scaleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScale(generators)
	scaleGenerator = gen.Struct(reflect.TypeOf(Scale{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScale(generators)
	AddRelatedPropertyGeneratorsForScale(generators)
	scaleGenerator = gen.Struct(reflect.TypeOf(Scale{}), generators)

	return scaleGenerator
}

// AddIndependentPropertyGeneratorsForScale is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScale(gens map[string]gopter.Gen) {
	gens["MaxReplicas"] = gen.PtrOf(gen.Int())
	gens["MinReplicas"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForScale is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScale(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ScaleRuleGenerator())
}

func Test_ScaleRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleRule to ScaleRule via AssignProperties_To_ScaleRule & AssignProperties_From_ScaleRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleRule, ScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleRule tests if a specific instance of ScaleRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleRule(subject ScaleRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleRule
	err := copied.AssignProperties_To_ScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleRule
	err = actual.AssignProperties_From_ScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule, ScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule runs a test to see if a specific instance of ScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule(subject ScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule instances for property testing - lazily instantiated by ScaleRuleGenerator()
var scaleRuleGenerator gopter.Gen

// ScaleRuleGenerator returns a generator of ScaleRule instances for property testing.
// We first initialize scaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScaleRuleGenerator() gopter.Gen {
	if scaleRuleGenerator != nil {
		return scaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRule(generators)
	scaleRuleGenerator = gen.Struct(reflect.TypeOf(ScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRule(generators)
	AddRelatedPropertyGeneratorsForScaleRule(generators)
	scaleRuleGenerator = gen.Struct(reflect.TypeOf(ScaleRule{}), generators)

	return scaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRule(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule(gens map[string]gopter.Gen) {
	gens["AzureQueue"] = gen.PtrOf(QueueScaleRuleGenerator())
	gens["Custom"] = gen.PtrOf(CustomScaleRuleGenerator())
	gens["Http"] = gen.PtrOf(HttpScaleRuleGenerator())
	gens["Tcp"] = gen.PtrOf(TcpScaleRuleGenerator())
}

func Test_ScaleRuleAuth_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleRuleAuth to ScaleRuleAuth via AssignProperties_To_ScaleRuleAuth & AssignProperties_From_ScaleRuleAuth returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleRuleAuth, ScaleRuleAuthGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleRuleAuth tests if a specific instance of ScaleRuleAuth can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleRuleAuth(subject ScaleRuleAuth) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleRuleAuth
	err := copied.AssignProperties_To_ScaleRuleAuth(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleRuleAuth
	err = actual.AssignProperties_From_ScaleRuleAuth(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleRuleAuth_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleAuth via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleAuth, ScaleRuleAuthGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleAuth runs a test to see if a specific instance of ScaleRuleAuth round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleAuth(subject ScaleRuleAuth) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleAuth
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleAuth instances for property testing - lazily instantiated by ScaleRuleAuthGenerator()
var scaleRuleAuthGenerator gopter.Gen

// ScaleRuleAuthGenerator returns a generator of ScaleRuleAuth instances for property testing.
func ScaleRuleAuthGenerator() gopter.Gen {
	if scaleRuleAuthGenerator != nil {
		return scaleRuleAuthGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleAuth(generators)
	scaleRuleAuthGenerator = gen.Struct(reflect.TypeOf(ScaleRuleAuth{}), generators)

	return scaleRuleAuthGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleAuth is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleAuth(gens map[string]gopter.Gen) {
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["TriggerParameter"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleRuleAuth_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleRuleAuth_STATUS to ScaleRuleAuth_STATUS via AssignProperties_To_ScaleRuleAuth_STATUS & AssignProperties_From_ScaleRuleAuth_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleRuleAuth_STATUS, ScaleRuleAuth_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleRuleAuth_STATUS tests if a specific instance of ScaleRuleAuth_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleRuleAuth_STATUS(subject ScaleRuleAuth_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleRuleAuth_STATUS
	err := copied.AssignProperties_To_ScaleRuleAuth_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleRuleAuth_STATUS
	err = actual.AssignProperties_From_ScaleRuleAuth_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleRuleAuth_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleAuth_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleAuth_STATUS, ScaleRuleAuth_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleAuth_STATUS runs a test to see if a specific instance of ScaleRuleAuth_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleAuth_STATUS(subject ScaleRuleAuth_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleAuth_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleAuth_STATUS instances for property testing - lazily instantiated by
// ScaleRuleAuth_STATUSGenerator()
var scaleRuleAuth_STATUSGenerator gopter.Gen

// ScaleRuleAuth_STATUSGenerator returns a generator of ScaleRuleAuth_STATUS instances for property testing.
func ScaleRuleAuth_STATUSGenerator() gopter.Gen {
	if scaleRuleAuth_STATUSGenerator != nil {
		return scaleRuleAuth_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleAuth_STATUS(generators)
	scaleRuleAuth_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRuleAuth_STATUS{}), generators)

	return scaleRuleAuth_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleAuth_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleAuth_STATUS(gens map[string]gopter.Gen) {
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
	gens["TriggerParameter"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleRule_STATUS to ScaleRule_STATUS via AssignProperties_To_ScaleRule_STATUS & AssignProperties_From_ScaleRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleRule_STATUS, ScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleRule_STATUS tests if a specific instance of ScaleRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleRule_STATUS(subject ScaleRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleRule_STATUS
	err := copied.AssignProperties_To_ScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleRule_STATUS
	err = actual.AssignProperties_From_ScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule_STATUS, ScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule_STATUS runs a test to see if a specific instance of ScaleRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule_STATUS(subject ScaleRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule_STATUS instances for property testing - lazily instantiated by ScaleRule_STATUSGenerator()
var scaleRule_STATUSGenerator gopter.Gen

// ScaleRule_STATUSGenerator returns a generator of ScaleRule_STATUS instances for property testing.
// We first initialize scaleRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ScaleRule_STATUSGenerator() gopter.Gen {
	if scaleRule_STATUSGenerator != nil {
		return scaleRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRule_STATUS(generators)
	scaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForScaleRule_STATUS(generators)
	scaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRule_STATUS{}), generators)

	return scaleRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForScaleRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["AzureQueue"] = gen.PtrOf(QueueScaleRule_STATUSGenerator())
	gens["Custom"] = gen.PtrOf(CustomScaleRule_STATUSGenerator())
	gens["Http"] = gen.PtrOf(HttpScaleRule_STATUSGenerator())
	gens["Tcp"] = gen.PtrOf(TcpScaleRule_STATUSGenerator())
}

func Test_Scale_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Scale_STATUS to Scale_STATUS via AssignProperties_To_Scale_STATUS & AssignProperties_From_Scale_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScale_STATUS, Scale_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScale_STATUS tests if a specific instance of Scale_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScale_STATUS(subject Scale_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Scale_STATUS
	err := copied.AssignProperties_To_Scale_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Scale_STATUS
	err = actual.AssignProperties_From_Scale_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Scale_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Scale_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScale_STATUS, Scale_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScale_STATUS runs a test to see if a specific instance of Scale_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScale_STATUS(subject Scale_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Scale_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Scale_STATUS instances for property testing - lazily instantiated by Scale_STATUSGenerator()
var scale_STATUSGenerator gopter.Gen

// Scale_STATUSGenerator returns a generator of Scale_STATUS instances for property testing.
// We first initialize scale_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Scale_STATUSGenerator() gopter.Gen {
	if scale_STATUSGenerator != nil {
		return scale_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScale_STATUS(generators)
	scale_STATUSGenerator = gen.Struct(reflect.TypeOf(Scale_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScale_STATUS(generators)
	AddRelatedPropertyGeneratorsForScale_STATUS(generators)
	scale_STATUSGenerator = gen.Struct(reflect.TypeOf(Scale_STATUS{}), generators)

	return scale_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScale_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScale_STATUS(gens map[string]gopter.Gen) {
	gens["MaxReplicas"] = gen.PtrOf(gen.Int())
	gens["MinReplicas"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForScale_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScale_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ScaleRule_STATUSGenerator())
}

func Test_Secret_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Secret to Secret via AssignProperties_To_Secret & AssignProperties_From_Secret returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecret, SecretGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecret tests if a specific instance of Secret can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSecret(subject Secret) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Secret
	err := copied.AssignProperties_To_Secret(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Secret
	err = actual.AssignProperties_From_Secret(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Secret_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Secret via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecret, SecretGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecret runs a test to see if a specific instance of Secret round trips to JSON and back losslessly
func RunJSONSerializationTestForSecret(subject Secret) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Secret
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Secret instances for property testing - lazily instantiated by SecretGenerator()
var secretGenerator gopter.Gen

// SecretGenerator returns a generator of Secret instances for property testing.
func SecretGenerator() gopter.Gen {
	if secretGenerator != nil {
		return secretGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecret(generators)
	secretGenerator = gen.Struct(reflect.TypeOf(Secret{}), generators)

	return secretGenerator
}

// AddIndependentPropertyGeneratorsForSecret is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecret(gens map[string]gopter.Gen) {
	gens["KeyVaultUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecretVolumeItem_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecretVolumeItem to SecretVolumeItem via AssignProperties_To_SecretVolumeItem & AssignProperties_From_SecretVolumeItem returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecretVolumeItem, SecretVolumeItemGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecretVolumeItem tests if a specific instance of SecretVolumeItem can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSecretVolumeItem(subject SecretVolumeItem) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SecretVolumeItem
	err := copied.AssignProperties_To_SecretVolumeItem(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecretVolumeItem
	err = actual.AssignProperties_From_SecretVolumeItem(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecretVolumeItem_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretVolumeItem via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretVolumeItem, SecretVolumeItemGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretVolumeItem runs a test to see if a specific instance of SecretVolumeItem round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretVolumeItem(subject SecretVolumeItem) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretVolumeItem
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretVolumeItem instances for property testing - lazily instantiated by SecretVolumeItemGenerator()
var secretVolumeItemGenerator gopter.Gen

// SecretVolumeItemGenerator returns a generator of SecretVolumeItem instances for property testing.
func SecretVolumeItemGenerator() gopter.Gen {
	if secretVolumeItemGenerator != nil {
		return secretVolumeItemGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretVolumeItem(generators)
	secretVolumeItemGenerator = gen.Struct(reflect.TypeOf(SecretVolumeItem{}), generators)

	return secretVolumeItemGenerator
}

// AddIndependentPropertyGeneratorsForSecretVolumeItem is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretVolumeItem(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecretVolumeItem_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecretVolumeItem_STATUS to SecretVolumeItem_STATUS via AssignProperties_To_SecretVolumeItem_STATUS & AssignProperties_From_SecretVolumeItem_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecretVolumeItem_STATUS, SecretVolumeItem_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecretVolumeItem_STATUS tests if a specific instance of SecretVolumeItem_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSecretVolumeItem_STATUS(subject SecretVolumeItem_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SecretVolumeItem_STATUS
	err := copied.AssignProperties_To_SecretVolumeItem_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecretVolumeItem_STATUS
	err = actual.AssignProperties_From_SecretVolumeItem_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecretVolumeItem_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretVolumeItem_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretVolumeItem_STATUS, SecretVolumeItem_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretVolumeItem_STATUS runs a test to see if a specific instance of SecretVolumeItem_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretVolumeItem_STATUS(subject SecretVolumeItem_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretVolumeItem_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretVolumeItem_STATUS instances for property testing - lazily instantiated by
// SecretVolumeItem_STATUSGenerator()
var secretVolumeItem_STATUSGenerator gopter.Gen

// SecretVolumeItem_STATUSGenerator returns a generator of SecretVolumeItem_STATUS instances for property testing.
func SecretVolumeItem_STATUSGenerator() gopter.Gen {
	if secretVolumeItem_STATUSGenerator != nil {
		return secretVolumeItem_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecretVolumeItem_STATUS(generators)
	secretVolumeItem_STATUSGenerator = gen.Struct(reflect.TypeOf(SecretVolumeItem_STATUS{}), generators)

	return secretVolumeItem_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSecretVolumeItem_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecretVolumeItem_STATUS(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["SecretRef"] = gen.PtrOf(gen.AlphaString())
}

func Test_Secret_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Secret_STATUS to Secret_STATUS via AssignProperties_To_Secret_STATUS & AssignProperties_From_Secret_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecret_STATUS, Secret_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecret_STATUS tests if a specific instance of Secret_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSecret_STATUS(subject Secret_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Secret_STATUS
	err := copied.AssignProperties_To_Secret_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Secret_STATUS
	err = actual.AssignProperties_From_Secret_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Secret_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Secret_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecret_STATUS, Secret_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecret_STATUS runs a test to see if a specific instance of Secret_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecret_STATUS(subject Secret_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Secret_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Secret_STATUS instances for property testing - lazily instantiated by Secret_STATUSGenerator()
var secret_STATUSGenerator gopter.Gen

// Secret_STATUSGenerator returns a generator of Secret_STATUS instances for property testing.
func Secret_STATUSGenerator() gopter.Gen {
	if secret_STATUSGenerator != nil {
		return secret_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecret_STATUS(generators)
	secret_STATUSGenerator = gen.Struct(reflect.TypeOf(Secret_STATUS{}), generators)

	return secret_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSecret_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecret_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_Service_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Service to Service via AssignProperties_To_Service & AssignProperties_From_Service returns original",
		prop.ForAll(RunPropertyAssignmentTestForService, ServiceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForService tests if a specific instance of Service can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForService(subject Service) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Service
	err := copied.AssignProperties_To_Service(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Service
	err = actual.AssignProperties_From_Service(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Service_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService, ServiceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService runs a test to see if a specific instance of Service round trips to JSON and back losslessly
func RunJSONSerializationTestForService(subject Service) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service instances for property testing - lazily instantiated by ServiceGenerator()
var serviceGenerator gopter.Gen

// ServiceGenerator returns a generator of Service instances for property testing.
func ServiceGenerator() gopter.Gen {
	if serviceGenerator != nil {
		return serviceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService(generators)
	serviceGenerator = gen.Struct(reflect.TypeOf(Service{}), generators)

	return serviceGenerator
}

// AddIndependentPropertyGeneratorsForService is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBind_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceBind to ServiceBind via AssignProperties_To_ServiceBind & AssignProperties_From_ServiceBind returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceBind, ServiceBindGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceBind tests if a specific instance of ServiceBind can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceBind(subject ServiceBind) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServiceBind
	err := copied.AssignProperties_To_ServiceBind(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceBind
	err = actual.AssignProperties_From_ServiceBind(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceBind_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBind via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBind, ServiceBindGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBind runs a test to see if a specific instance of ServiceBind round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBind(subject ServiceBind) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBind
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBind instances for property testing - lazily instantiated by ServiceBindGenerator()
var serviceBindGenerator gopter.Gen

// ServiceBindGenerator returns a generator of ServiceBind instances for property testing.
func ServiceBindGenerator() gopter.Gen {
	if serviceBindGenerator != nil {
		return serviceBindGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBind(generators)
	serviceBindGenerator = gen.Struct(reflect.TypeOf(ServiceBind{}), generators)

	return serviceBindGenerator
}

// AddIndependentPropertyGeneratorsForServiceBind is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBind(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBind_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceBind_STATUS to ServiceBind_STATUS via AssignProperties_To_ServiceBind_STATUS & AssignProperties_From_ServiceBind_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceBind_STATUS, ServiceBind_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceBind_STATUS tests if a specific instance of ServiceBind_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceBind_STATUS(subject ServiceBind_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServiceBind_STATUS
	err := copied.AssignProperties_To_ServiceBind_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceBind_STATUS
	err = actual.AssignProperties_From_ServiceBind_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceBind_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBind_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBind_STATUS, ServiceBind_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBind_STATUS runs a test to see if a specific instance of ServiceBind_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBind_STATUS(subject ServiceBind_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBind_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBind_STATUS instances for property testing - lazily instantiated by ServiceBind_STATUSGenerator()
var serviceBind_STATUSGenerator gopter.Gen

// ServiceBind_STATUSGenerator returns a generator of ServiceBind_STATUS instances for property testing.
func ServiceBind_STATUSGenerator() gopter.Gen {
	if serviceBind_STATUSGenerator != nil {
		return serviceBind_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBind_STATUS(generators)
	serviceBind_STATUSGenerator = gen.Struct(reflect.TypeOf(ServiceBind_STATUS{}), generators)

	return serviceBind_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServiceBind_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBind_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Service_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Service_STATUS to Service_STATUS via AssignProperties_To_Service_STATUS & AssignProperties_From_Service_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForService_STATUS, Service_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForService_STATUS tests if a specific instance of Service_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForService_STATUS(subject Service_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Service_STATUS
	err := copied.AssignProperties_To_Service_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Service_STATUS
	err = actual.AssignProperties_From_Service_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Service_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService_STATUS, Service_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService_STATUS runs a test to see if a specific instance of Service_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForService_STATUS(subject Service_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service_STATUS instances for property testing - lazily instantiated by Service_STATUSGenerator()
var service_STATUSGenerator gopter.Gen

// Service_STATUSGenerator returns a generator of Service_STATUS instances for property testing.
func Service_STATUSGenerator() gopter.Gen {
	if service_STATUSGenerator != nil {
		return service_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_STATUS(generators)
	service_STATUSGenerator = gen.Struct(reflect.TypeOf(Service_STATUS{}), generators)

	return service_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForService_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_TcpScaleRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TcpScaleRule to TcpScaleRule via AssignProperties_To_TcpScaleRule & AssignProperties_From_TcpScaleRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForTcpScaleRule, TcpScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTcpScaleRule tests if a specific instance of TcpScaleRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTcpScaleRule(subject TcpScaleRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TcpScaleRule
	err := copied.AssignProperties_To_TcpScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TcpScaleRule
	err = actual.AssignProperties_From_TcpScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TcpScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TcpScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTcpScaleRule, TcpScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTcpScaleRule runs a test to see if a specific instance of TcpScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForTcpScaleRule(subject TcpScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TcpScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TcpScaleRule instances for property testing - lazily instantiated by TcpScaleRuleGenerator()
var tcpScaleRuleGenerator gopter.Gen

// TcpScaleRuleGenerator returns a generator of TcpScaleRule instances for property testing.
// We first initialize tcpScaleRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TcpScaleRuleGenerator() gopter.Gen {
	if tcpScaleRuleGenerator != nil {
		return tcpScaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTcpScaleRule(generators)
	tcpScaleRuleGenerator = gen.Struct(reflect.TypeOf(TcpScaleRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTcpScaleRule(generators)
	AddRelatedPropertyGeneratorsForTcpScaleRule(generators)
	tcpScaleRuleGenerator = gen.Struct(reflect.TypeOf(TcpScaleRule{}), generators)

	return tcpScaleRuleGenerator
}

// AddIndependentPropertyGeneratorsForTcpScaleRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTcpScaleRule(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForTcpScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTcpScaleRule(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuthGenerator())
}

func Test_TcpScaleRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TcpScaleRule_STATUS to TcpScaleRule_STATUS via AssignProperties_To_TcpScaleRule_STATUS & AssignProperties_From_TcpScaleRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTcpScaleRule_STATUS, TcpScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTcpScaleRule_STATUS tests if a specific instance of TcpScaleRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTcpScaleRule_STATUS(subject TcpScaleRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TcpScaleRule_STATUS
	err := copied.AssignProperties_To_TcpScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TcpScaleRule_STATUS
	err = actual.AssignProperties_From_TcpScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TcpScaleRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TcpScaleRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTcpScaleRule_STATUS, TcpScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTcpScaleRule_STATUS runs a test to see if a specific instance of TcpScaleRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTcpScaleRule_STATUS(subject TcpScaleRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TcpScaleRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TcpScaleRule_STATUS instances for property testing - lazily instantiated by
// TcpScaleRule_STATUSGenerator()
var tcpScaleRule_STATUSGenerator gopter.Gen

// TcpScaleRule_STATUSGenerator returns a generator of TcpScaleRule_STATUS instances for property testing.
// We first initialize tcpScaleRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TcpScaleRule_STATUSGenerator() gopter.Gen {
	if tcpScaleRule_STATUSGenerator != nil {
		return tcpScaleRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTcpScaleRule_STATUS(generators)
	tcpScaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(TcpScaleRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTcpScaleRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForTcpScaleRule_STATUS(generators)
	tcpScaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(TcpScaleRule_STATUS{}), generators)

	return tcpScaleRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTcpScaleRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTcpScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["Metadata"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForTcpScaleRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTcpScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.SliceOf(ScaleRuleAuth_STATUSGenerator())
}

func Test_Template_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Template to Template via AssignProperties_To_Template & AssignProperties_From_Template returns original",
		prop.ForAll(RunPropertyAssignmentTestForTemplate, TemplateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTemplate tests if a specific instance of Template can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTemplate(subject Template) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Template
	err := copied.AssignProperties_To_Template(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Template
	err = actual.AssignProperties_From_Template(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Template_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Template via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTemplate, TemplateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTemplate runs a test to see if a specific instance of Template round trips to JSON and back losslessly
func RunJSONSerializationTestForTemplate(subject Template) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Template
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Template instances for property testing - lazily instantiated by TemplateGenerator()
var templateGenerator gopter.Gen

// TemplateGenerator returns a generator of Template instances for property testing.
// We first initialize templateGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TemplateGenerator() gopter.Gen {
	if templateGenerator != nil {
		return templateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTemplate(generators)
	templateGenerator = gen.Struct(reflect.TypeOf(Template{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTemplate(generators)
	AddRelatedPropertyGeneratorsForTemplate(generators)
	templateGenerator = gen.Struct(reflect.TypeOf(Template{}), generators)

	return templateGenerator
}

// AddIndependentPropertyGeneratorsForTemplate is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTemplate(gens map[string]gopter.Gen) {
	gens["RevisionSuffix"] = gen.PtrOf(gen.AlphaString())
	gens["TerminationGracePeriodSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForTemplate is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTemplate(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(ContainerGenerator())
	gens["InitContainers"] = gen.SliceOf(BaseContainerGenerator())
	gens["Scale"] = gen.PtrOf(ScaleGenerator())
	gens["ServiceBinds"] = gen.SliceOf(ServiceBindGenerator())
	gens["Volumes"] = gen.SliceOf(VolumeGenerator())
}

func Test_Template_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Template_STATUS to Template_STATUS via AssignProperties_To_Template_STATUS & AssignProperties_From_Template_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTemplate_STATUS, Template_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTemplate_STATUS tests if a specific instance of Template_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTemplate_STATUS(subject Template_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Template_STATUS
	err := copied.AssignProperties_To_Template_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Template_STATUS
	err = actual.AssignProperties_From_Template_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Template_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Template_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTemplate_STATUS, Template_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTemplate_STATUS runs a test to see if a specific instance of Template_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTemplate_STATUS(subject Template_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Template_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Template_STATUS instances for property testing - lazily instantiated by Template_STATUSGenerator()
var template_STATUSGenerator gopter.Gen

// Template_STATUSGenerator returns a generator of Template_STATUS instances for property testing.
// We first initialize template_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Template_STATUSGenerator() gopter.Gen {
	if template_STATUSGenerator != nil {
		return template_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTemplate_STATUS(generators)
	template_STATUSGenerator = gen.Struct(reflect.TypeOf(Template_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTemplate_STATUS(generators)
	AddRelatedPropertyGeneratorsForTemplate_STATUS(generators)
	template_STATUSGenerator = gen.Struct(reflect.TypeOf(Template_STATUS{}), generators)

	return template_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTemplate_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTemplate_STATUS(gens map[string]gopter.Gen) {
	gens["RevisionSuffix"] = gen.PtrOf(gen.AlphaString())
	gens["TerminationGracePeriodSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForTemplate_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTemplate_STATUS(gens map[string]gopter.Gen) {
	gens["Containers"] = gen.SliceOf(Container_STATUSGenerator())
	gens["InitContainers"] = gen.SliceOf(BaseContainer_STATUSGenerator())
	gens["Scale"] = gen.PtrOf(Scale_STATUSGenerator())
	gens["ServiceBinds"] = gen.SliceOf(ServiceBind_STATUSGenerator())
	gens["Volumes"] = gen.SliceOf(Volume_STATUSGenerator())
}

func Test_TrafficWeight_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TrafficWeight to TrafficWeight via AssignProperties_To_TrafficWeight & AssignProperties_From_TrafficWeight returns original",
		prop.ForAll(RunPropertyAssignmentTestForTrafficWeight, TrafficWeightGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTrafficWeight tests if a specific instance of TrafficWeight can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTrafficWeight(subject TrafficWeight) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TrafficWeight
	err := copied.AssignProperties_To_TrafficWeight(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TrafficWeight
	err = actual.AssignProperties_From_TrafficWeight(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TrafficWeight_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TrafficWeight via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrafficWeight, TrafficWeightGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrafficWeight runs a test to see if a specific instance of TrafficWeight round trips to JSON and back losslessly
func RunJSONSerializationTestForTrafficWeight(subject TrafficWeight) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TrafficWeight
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TrafficWeight instances for property testing - lazily instantiated by TrafficWeightGenerator()
var trafficWeightGenerator gopter.Gen

// TrafficWeightGenerator returns a generator of TrafficWeight instances for property testing.
func TrafficWeightGenerator() gopter.Gen {
	if trafficWeightGenerator != nil {
		return trafficWeightGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrafficWeight(generators)
	trafficWeightGenerator = gen.Struct(reflect.TypeOf(TrafficWeight{}), generators)

	return trafficWeightGenerator
}

// AddIndependentPropertyGeneratorsForTrafficWeight is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrafficWeight(gens map[string]gopter.Gen) {
	gens["Label"] = gen.PtrOf(gen.AlphaString())
	gens["LatestRevision"] = gen.PtrOf(gen.Bool())
	gens["RevisionName"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_TrafficWeight_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TrafficWeight_STATUS to TrafficWeight_STATUS via AssignProperties_To_TrafficWeight_STATUS & AssignProperties_From_TrafficWeight_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTrafficWeight_STATUS, TrafficWeight_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTrafficWeight_STATUS tests if a specific instance of TrafficWeight_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTrafficWeight_STATUS(subject TrafficWeight_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TrafficWeight_STATUS
	err := copied.AssignProperties_To_TrafficWeight_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TrafficWeight_STATUS
	err = actual.AssignProperties_From_TrafficWeight_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TrafficWeight_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TrafficWeight_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrafficWeight_STATUS, TrafficWeight_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrafficWeight_STATUS runs a test to see if a specific instance of TrafficWeight_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTrafficWeight_STATUS(subject TrafficWeight_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TrafficWeight_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TrafficWeight_STATUS instances for property testing - lazily instantiated by
// TrafficWeight_STATUSGenerator()
var trafficWeight_STATUSGenerator gopter.Gen

// TrafficWeight_STATUSGenerator returns a generator of TrafficWeight_STATUS instances for property testing.
func TrafficWeight_STATUSGenerator() gopter.Gen {
	if trafficWeight_STATUSGenerator != nil {
		return trafficWeight_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrafficWeight_STATUS(generators)
	trafficWeight_STATUSGenerator = gen.Struct(reflect.TypeOf(TrafficWeight_STATUS{}), generators)

	return trafficWeight_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTrafficWeight_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrafficWeight_STATUS(gens map[string]gopter.Gen) {
	gens["Label"] = gen.PtrOf(gen.AlphaString())
	gens["LatestRevision"] = gen.PtrOf(gen.Bool())
	gens["RevisionName"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserAssignedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentity_STATUS to UserAssignedIdentity_STATUS via AssignProperties_To_UserAssignedIdentity_STATUS & AssignProperties_From_UserAssignedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentity_STATUS tests if a specific instance of UserAssignedIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentity_STATUS
	err := copied.AssignProperties_To_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentity_STATUS
	err = actual.AssignProperties_From_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSGenerator()
var userAssignedIdentity_STATUSGenerator gopter.Gen

// UserAssignedIdentity_STATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSGenerator != nil {
		return userAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(generators)
	userAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_Volume_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Volume to Volume via AssignProperties_To_Volume & AssignProperties_From_Volume returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolume tests if a specific instance of Volume can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVolume(subject Volume) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Volume
	err := copied.AssignProperties_To_Volume(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Volume
	err = actual.AssignProperties_From_Volume(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Volume_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume, VolumeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume runs a test to see if a specific instance of Volume round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume(subject Volume) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume instances for property testing - lazily instantiated by VolumeGenerator()
var volumeGenerator gopter.Gen

// VolumeGenerator returns a generator of Volume instances for property testing.
// We first initialize volumeGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VolumeGenerator() gopter.Gen {
	if volumeGenerator != nil {
		return volumeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume(generators)
	AddRelatedPropertyGeneratorsForVolume(generators)
	volumeGenerator = gen.Struct(reflect.TypeOf(Volume{}), generators)

	return volumeGenerator
}

// AddIndependentPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["MountOptions"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageType"] = gen.PtrOf(gen.OneConstOf(Volume_StorageType_AzureFile, Volume_StorageType_EmptyDir, Volume_StorageType_Secret))
}

// AddRelatedPropertyGeneratorsForVolume is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.SliceOf(SecretVolumeItemGenerator())
}

func Test_VolumeMount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VolumeMount to VolumeMount via AssignProperties_To_VolumeMount & AssignProperties_From_VolumeMount returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolumeMount tests if a specific instance of VolumeMount can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVolumeMount(subject VolumeMount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VolumeMount
	err := copied.AssignProperties_To_VolumeMount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VolumeMount
	err = actual.AssignProperties_From_VolumeMount(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VolumeMount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount, VolumeMountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount runs a test to see if a specific instance of VolumeMount round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount(subject VolumeMount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount instances for property testing - lazily instantiated by VolumeMountGenerator()
var volumeMountGenerator gopter.Gen

// VolumeMountGenerator returns a generator of VolumeMount instances for property testing.
func VolumeMountGenerator() gopter.Gen {
	if volumeMountGenerator != nil {
		return volumeMountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount(generators)
	volumeMountGenerator = gen.Struct(reflect.TypeOf(VolumeMount{}), generators)

	return volumeMountGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["SubPath"] = gen.PtrOf(gen.AlphaString())
	gens["VolumeName"] = gen.PtrOf(gen.AlphaString())
}

func Test_VolumeMount_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VolumeMount_STATUS to VolumeMount_STATUS via AssignProperties_To_VolumeMount_STATUS & AssignProperties_From_VolumeMount_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolumeMount_STATUS, VolumeMount_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolumeMount_STATUS tests if a specific instance of VolumeMount_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVolumeMount_STATUS(subject VolumeMount_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VolumeMount_STATUS
	err := copied.AssignProperties_To_VolumeMount_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VolumeMount_STATUS
	err = actual.AssignProperties_From_VolumeMount_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VolumeMount_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VolumeMount_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolumeMount_STATUS, VolumeMount_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolumeMount_STATUS runs a test to see if a specific instance of VolumeMount_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVolumeMount_STATUS(subject VolumeMount_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VolumeMount_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VolumeMount_STATUS instances for property testing - lazily instantiated by VolumeMount_STATUSGenerator()
var volumeMount_STATUSGenerator gopter.Gen

// VolumeMount_STATUSGenerator returns a generator of VolumeMount_STATUS instances for property testing.
func VolumeMount_STATUSGenerator() gopter.Gen {
	if volumeMount_STATUSGenerator != nil {
		return volumeMount_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolumeMount_STATUS(generators)
	volumeMount_STATUSGenerator = gen.Struct(reflect.TypeOf(VolumeMount_STATUS{}), generators)

	return volumeMount_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVolumeMount_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolumeMount_STATUS(gens map[string]gopter.Gen) {
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["SubPath"] = gen.PtrOf(gen.AlphaString())
	gens["VolumeName"] = gen.PtrOf(gen.AlphaString())
}

func Test_Volume_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Volume_STATUS to Volume_STATUS via AssignProperties_To_Volume_STATUS & AssignProperties_From_Volume_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVolume_STATUS, Volume_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVolume_STATUS tests if a specific instance of Volume_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVolume_STATUS(subject Volume_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Volume_STATUS
	err := copied.AssignProperties_To_Volume_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Volume_STATUS
	err = actual.AssignProperties_From_Volume_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Volume_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Volume_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVolume_STATUS, Volume_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVolume_STATUS runs a test to see if a specific instance of Volume_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVolume_STATUS(subject Volume_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Volume_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Volume_STATUS instances for property testing - lazily instantiated by Volume_STATUSGenerator()
var volume_STATUSGenerator gopter.Gen

// Volume_STATUSGenerator returns a generator of Volume_STATUS instances for property testing.
// We first initialize volume_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Volume_STATUSGenerator() gopter.Gen {
	if volume_STATUSGenerator != nil {
		return volume_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume_STATUS(generators)
	volume_STATUSGenerator = gen.Struct(reflect.TypeOf(Volume_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVolume_STATUS(generators)
	AddRelatedPropertyGeneratorsForVolume_STATUS(generators)
	volume_STATUSGenerator = gen.Struct(reflect.TypeOf(Volume_STATUS{}), generators)

	return volume_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVolume_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVolume_STATUS(gens map[string]gopter.Gen) {
	gens["MountOptions"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageType"] = gen.PtrOf(gen.OneConstOf(Volume_StorageType_STATUS_AzureFile, Volume_StorageType_STATUS_EmptyDir, Volume_StorageType_STATUS_Secret))
}

// AddRelatedPropertyGeneratorsForVolume_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVolume_STATUS(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.SliceOf(SecretVolumeItem_STATUSGenerator())
}
