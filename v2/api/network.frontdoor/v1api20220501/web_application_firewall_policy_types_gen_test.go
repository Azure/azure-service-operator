// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220501

import (
	"encoding/json"
	v20220501s "github.com/Azure/azure-service-operator/v2/api/network.frontdoor/v1api20220501/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_WebApplicationFirewallPolicy_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallPolicy to hub returns original",
		prop.ForAll(RunResourceConversionTestForWebApplicationFirewallPolicy, WebApplicationFirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForWebApplicationFirewallPolicy tests if a specific instance of WebApplicationFirewallPolicy round trips to the hub storage version and back losslessly
func RunResourceConversionTestForWebApplicationFirewallPolicy(subject WebApplicationFirewallPolicy) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20220501s.WebApplicationFirewallPolicy
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual WebApplicationFirewallPolicy
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallPolicy to WebApplicationFirewallPolicy via AssignProperties_To_WebApplicationFirewallPolicy & AssignProperties_From_WebApplicationFirewallPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallPolicy, WebApplicationFirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallPolicy tests if a specific instance of WebApplicationFirewallPolicy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallPolicy(subject WebApplicationFirewallPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.WebApplicationFirewallPolicy
	err := copied.AssignProperties_To_WebApplicationFirewallPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallPolicy
	err = actual.AssignProperties_From_WebApplicationFirewallPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallPolicy, WebApplicationFirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallPolicy runs a test to see if a specific instance of WebApplicationFirewallPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallPolicy(subject WebApplicationFirewallPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallPolicy instances for property testing - lazily instantiated by
// WebApplicationFirewallPolicyGenerator()
var webApplicationFirewallPolicyGenerator gopter.Gen

// WebApplicationFirewallPolicyGenerator returns a generator of WebApplicationFirewallPolicy instances for property testing.
func WebApplicationFirewallPolicyGenerator() gopter.Gen {
	if webApplicationFirewallPolicyGenerator != nil {
		return webApplicationFirewallPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy(generators)
	webApplicationFirewallPolicyGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicy{}), generators)

	return webApplicationFirewallPolicyGenerator
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy(gens map[string]gopter.Gen) {
	gens["Spec"] = FrontDoorWebApplicationFirewallPolicy_SpecGenerator()
	gens["Status"] = FrontDoorWebApplicationFirewallPolicy_STATUSGenerator()
}

func Test_FrontDoorWebApplicationFirewallPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontDoorWebApplicationFirewallPolicy_Spec to FrontDoorWebApplicationFirewallPolicy_Spec via AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_Spec & AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontDoorWebApplicationFirewallPolicy_Spec, FrontDoorWebApplicationFirewallPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontDoorWebApplicationFirewallPolicy_Spec tests if a specific instance of FrontDoorWebApplicationFirewallPolicy_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontDoorWebApplicationFirewallPolicy_Spec(subject FrontDoorWebApplicationFirewallPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.FrontDoorWebApplicationFirewallPolicy_Spec
	err := copied.AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontDoorWebApplicationFirewallPolicy_Spec
	err = actual.AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontDoorWebApplicationFirewallPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoorWebApplicationFirewallPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_Spec, FrontDoorWebApplicationFirewallPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_Spec runs a test to see if a specific instance of FrontDoorWebApplicationFirewallPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_Spec(subject FrontDoorWebApplicationFirewallPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoorWebApplicationFirewallPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoorWebApplicationFirewallPolicy_Spec instances for property testing - lazily instantiated by
// FrontDoorWebApplicationFirewallPolicy_SpecGenerator()
var frontDoorWebApplicationFirewallPolicy_SpecGenerator gopter.Gen

// FrontDoorWebApplicationFirewallPolicy_SpecGenerator returns a generator of FrontDoorWebApplicationFirewallPolicy_Spec instances for property testing.
// We first initialize frontDoorWebApplicationFirewallPolicy_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoorWebApplicationFirewallPolicy_SpecGenerator() gopter.Gen {
	if frontDoorWebApplicationFirewallPolicy_SpecGenerator != nil {
		return frontDoorWebApplicationFirewallPolicy_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec(generators)
	frontDoorWebApplicationFirewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoorWebApplicationFirewallPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec(generators)
	frontDoorWebApplicationFirewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(FrontDoorWebApplicationFirewallPolicy_Spec{}), generators)

	return frontDoorWebApplicationFirewallPolicy_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["CustomRules"] = gen.PtrOf(CustomRuleListGenerator())
	gens["ManagedRules"] = gen.PtrOf(ManagedRuleSetListGenerator())
	gens["PolicySettings"] = gen.PtrOf(PolicySettingsGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_FrontDoorWebApplicationFirewallPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontDoorWebApplicationFirewallPolicy_STATUS to FrontDoorWebApplicationFirewallPolicy_STATUS via AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_STATUS & AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontDoorWebApplicationFirewallPolicy_STATUS, FrontDoorWebApplicationFirewallPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontDoorWebApplicationFirewallPolicy_STATUS tests if a specific instance of FrontDoorWebApplicationFirewallPolicy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontDoorWebApplicationFirewallPolicy_STATUS(subject FrontDoorWebApplicationFirewallPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.FrontDoorWebApplicationFirewallPolicy_STATUS
	err := copied.AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontDoorWebApplicationFirewallPolicy_STATUS
	err = actual.AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontDoorWebApplicationFirewallPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoorWebApplicationFirewallPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_STATUS, FrontDoorWebApplicationFirewallPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_STATUS runs a test to see if a specific instance of FrontDoorWebApplicationFirewallPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_STATUS(subject FrontDoorWebApplicationFirewallPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoorWebApplicationFirewallPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoorWebApplicationFirewallPolicy_STATUS instances for property testing - lazily instantiated by
// FrontDoorWebApplicationFirewallPolicy_STATUSGenerator()
var frontDoorWebApplicationFirewallPolicy_STATUSGenerator gopter.Gen

// FrontDoorWebApplicationFirewallPolicy_STATUSGenerator returns a generator of FrontDoorWebApplicationFirewallPolicy_STATUS instances for property testing.
// We first initialize frontDoorWebApplicationFirewallPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoorWebApplicationFirewallPolicy_STATUSGenerator() gopter.Gen {
	if frontDoorWebApplicationFirewallPolicy_STATUSGenerator != nil {
		return frontDoorWebApplicationFirewallPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_STATUS(generators)
	frontDoorWebApplicationFirewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoorWebApplicationFirewallPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_STATUS(generators)
	frontDoorWebApplicationFirewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontDoorWebApplicationFirewallPolicy_STATUS{}), generators)

	return frontDoorWebApplicationFirewallPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(
		WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Creating,
		WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Deleting,
		WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Disabled,
		WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Disabling,
		WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Enabled,
		WebApplicationFirewallPolicyProperties_ResourceState_STATUS_Enabling))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["CustomRules"] = gen.PtrOf(CustomRuleList_STATUSGenerator())
	gens["FrontendEndpointLinks"] = gen.SliceOf(FrontendEndpointLink_STATUSGenerator())
	gens["ManagedRules"] = gen.PtrOf(ManagedRuleSetList_STATUSGenerator())
	gens["PolicySettings"] = gen.PtrOf(PolicySettings_STATUSGenerator())
	gens["RoutingRuleLinks"] = gen.SliceOf(RoutingRuleLink_STATUSGenerator())
	gens["SecurityPolicyLinks"] = gen.SliceOf(SecurityPolicyLink_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
}

func Test_CustomRuleList_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomRuleList to CustomRuleList via AssignProperties_To_CustomRuleList & AssignProperties_From_CustomRuleList returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomRuleList, CustomRuleListGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomRuleList tests if a specific instance of CustomRuleList can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomRuleList(subject CustomRuleList) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.CustomRuleList
	err := copied.AssignProperties_To_CustomRuleList(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomRuleList
	err = actual.AssignProperties_From_CustomRuleList(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomRuleList_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomRuleList via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomRuleList, CustomRuleListGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomRuleList runs a test to see if a specific instance of CustomRuleList round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomRuleList(subject CustomRuleList) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomRuleList
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomRuleList instances for property testing - lazily instantiated by CustomRuleListGenerator()
var customRuleListGenerator gopter.Gen

// CustomRuleListGenerator returns a generator of CustomRuleList instances for property testing.
func CustomRuleListGenerator() gopter.Gen {
	if customRuleListGenerator != nil {
		return customRuleListGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCustomRuleList(generators)
	customRuleListGenerator = gen.Struct(reflect.TypeOf(CustomRuleList{}), generators)

	return customRuleListGenerator
}

// AddRelatedPropertyGeneratorsForCustomRuleList is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomRuleList(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(CustomRuleGenerator())
}

func Test_CustomRuleList_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomRuleList_STATUS to CustomRuleList_STATUS via AssignProperties_To_CustomRuleList_STATUS & AssignProperties_From_CustomRuleList_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomRuleList_STATUS, CustomRuleList_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomRuleList_STATUS tests if a specific instance of CustomRuleList_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomRuleList_STATUS(subject CustomRuleList_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.CustomRuleList_STATUS
	err := copied.AssignProperties_To_CustomRuleList_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomRuleList_STATUS
	err = actual.AssignProperties_From_CustomRuleList_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomRuleList_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomRuleList_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomRuleList_STATUS, CustomRuleList_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomRuleList_STATUS runs a test to see if a specific instance of CustomRuleList_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomRuleList_STATUS(subject CustomRuleList_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomRuleList_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomRuleList_STATUS instances for property testing - lazily instantiated by
// CustomRuleList_STATUSGenerator()
var customRuleList_STATUSGenerator gopter.Gen

// CustomRuleList_STATUSGenerator returns a generator of CustomRuleList_STATUS instances for property testing.
func CustomRuleList_STATUSGenerator() gopter.Gen {
	if customRuleList_STATUSGenerator != nil {
		return customRuleList_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCustomRuleList_STATUS(generators)
	customRuleList_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomRuleList_STATUS{}), generators)

	return customRuleList_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForCustomRuleList_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomRuleList_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(CustomRule_STATUSGenerator())
}

func Test_FrontendEndpointLink_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FrontendEndpointLink_STATUS to FrontendEndpointLink_STATUS via AssignProperties_To_FrontendEndpointLink_STATUS & AssignProperties_From_FrontendEndpointLink_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFrontendEndpointLink_STATUS, FrontendEndpointLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFrontendEndpointLink_STATUS tests if a specific instance of FrontendEndpointLink_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFrontendEndpointLink_STATUS(subject FrontendEndpointLink_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.FrontendEndpointLink_STATUS
	err := copied.AssignProperties_To_FrontendEndpointLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FrontendEndpointLink_STATUS
	err = actual.AssignProperties_From_FrontendEndpointLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FrontendEndpointLink_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontendEndpointLink_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontendEndpointLink_STATUS, FrontendEndpointLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontendEndpointLink_STATUS runs a test to see if a specific instance of FrontendEndpointLink_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontendEndpointLink_STATUS(subject FrontendEndpointLink_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontendEndpointLink_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontendEndpointLink_STATUS instances for property testing - lazily instantiated by
// FrontendEndpointLink_STATUSGenerator()
var frontendEndpointLink_STATUSGenerator gopter.Gen

// FrontendEndpointLink_STATUSGenerator returns a generator of FrontendEndpointLink_STATUS instances for property testing.
func FrontendEndpointLink_STATUSGenerator() gopter.Gen {
	if frontendEndpointLink_STATUSGenerator != nil {
		return frontendEndpointLink_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontendEndpointLink_STATUS(generators)
	frontendEndpointLink_STATUSGenerator = gen.Struct(reflect.TypeOf(FrontendEndpointLink_STATUS{}), generators)

	return frontendEndpointLink_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFrontendEndpointLink_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontendEndpointLink_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedRuleSetList_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleSetList to ManagedRuleSetList via AssignProperties_To_ManagedRuleSetList & AssignProperties_From_ManagedRuleSetList returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleSetList, ManagedRuleSetListGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleSetList tests if a specific instance of ManagedRuleSetList can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleSetList(subject ManagedRuleSetList) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleSetList
	err := copied.AssignProperties_To_ManagedRuleSetList(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleSetList
	err = actual.AssignProperties_From_ManagedRuleSetList(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleSetList_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSetList via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSetList, ManagedRuleSetListGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSetList runs a test to see if a specific instance of ManagedRuleSetList round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSetList(subject ManagedRuleSetList) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSetList
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSetList instances for property testing - lazily instantiated by ManagedRuleSetListGenerator()
var managedRuleSetListGenerator gopter.Gen

// ManagedRuleSetListGenerator returns a generator of ManagedRuleSetList instances for property testing.
func ManagedRuleSetListGenerator() gopter.Gen {
	if managedRuleSetListGenerator != nil {
		return managedRuleSetListGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedRuleSetList(generators)
	managedRuleSetListGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSetList{}), generators)

	return managedRuleSetListGenerator
}

// AddRelatedPropertyGeneratorsForManagedRuleSetList is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSetList(gens map[string]gopter.Gen) {
	gens["ManagedRuleSets"] = gen.SliceOf(ManagedRuleSetGenerator())
}

func Test_ManagedRuleSetList_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleSetList_STATUS to ManagedRuleSetList_STATUS via AssignProperties_To_ManagedRuleSetList_STATUS & AssignProperties_From_ManagedRuleSetList_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleSetList_STATUS, ManagedRuleSetList_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleSetList_STATUS tests if a specific instance of ManagedRuleSetList_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleSetList_STATUS(subject ManagedRuleSetList_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleSetList_STATUS
	err := copied.AssignProperties_To_ManagedRuleSetList_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleSetList_STATUS
	err = actual.AssignProperties_From_ManagedRuleSetList_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleSetList_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSetList_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSetList_STATUS, ManagedRuleSetList_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSetList_STATUS runs a test to see if a specific instance of ManagedRuleSetList_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSetList_STATUS(subject ManagedRuleSetList_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSetList_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSetList_STATUS instances for property testing - lazily instantiated by
// ManagedRuleSetList_STATUSGenerator()
var managedRuleSetList_STATUSGenerator gopter.Gen

// ManagedRuleSetList_STATUSGenerator returns a generator of ManagedRuleSetList_STATUS instances for property testing.
func ManagedRuleSetList_STATUSGenerator() gopter.Gen {
	if managedRuleSetList_STATUSGenerator != nil {
		return managedRuleSetList_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedRuleSetList_STATUS(generators)
	managedRuleSetList_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSetList_STATUS{}), generators)

	return managedRuleSetList_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagedRuleSetList_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSetList_STATUS(gens map[string]gopter.Gen) {
	gens["ManagedRuleSets"] = gen.SliceOf(ManagedRuleSet_STATUSGenerator())
}

func Test_PolicySettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicySettings to PolicySettings via AssignProperties_To_PolicySettings & AssignProperties_From_PolicySettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicySettings, PolicySettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicySettings tests if a specific instance of PolicySettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPolicySettings(subject PolicySettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.PolicySettings
	err := copied.AssignProperties_To_PolicySettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicySettings
	err = actual.AssignProperties_From_PolicySettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicySettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings, PolicySettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings runs a test to see if a specific instance of PolicySettings round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings(subject PolicySettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings instances for property testing - lazily instantiated by PolicySettingsGenerator()
var policySettingsGenerator gopter.Gen

// PolicySettingsGenerator returns a generator of PolicySettings instances for property testing.
func PolicySettingsGenerator() gopter.Gen {
	if policySettingsGenerator != nil {
		return policySettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings(generators)
	policySettingsGenerator = gen.Struct(reflect.TypeOf(PolicySettings{}), generators)

	return policySettingsGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings(gens map[string]gopter.Gen) {
	gens["CustomBlockResponseBody"] = gen.PtrOf(gen.AlphaString())
	gens["CustomBlockResponseStatusCode"] = gen.PtrOf(gen.Int())
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(PolicySettings_EnabledState_Disabled, PolicySettings_EnabledState_Enabled))
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(PolicySettings_Mode_Detection, PolicySettings_Mode_Prevention))
	gens["RedirectUrl"] = gen.PtrOf(gen.AlphaString())
	gens["RequestBodyCheck"] = gen.PtrOf(gen.OneConstOf(PolicySettings_RequestBodyCheck_Disabled, PolicySettings_RequestBodyCheck_Enabled))
}

func Test_PolicySettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicySettings_STATUS to PolicySettings_STATUS via AssignProperties_To_PolicySettings_STATUS & AssignProperties_From_PolicySettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicySettings_STATUS, PolicySettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicySettings_STATUS tests if a specific instance of PolicySettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPolicySettings_STATUS(subject PolicySettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.PolicySettings_STATUS
	err := copied.AssignProperties_To_PolicySettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicySettings_STATUS
	err = actual.AssignProperties_From_PolicySettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicySettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings_STATUS, PolicySettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings_STATUS runs a test to see if a specific instance of PolicySettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings_STATUS(subject PolicySettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings_STATUS instances for property testing - lazily instantiated by
// PolicySettings_STATUSGenerator()
var policySettings_STATUSGenerator gopter.Gen

// PolicySettings_STATUSGenerator returns a generator of PolicySettings_STATUS instances for property testing.
func PolicySettings_STATUSGenerator() gopter.Gen {
	if policySettings_STATUSGenerator != nil {
		return policySettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_STATUS(generators)
	policySettings_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicySettings_STATUS{}), generators)

	return policySettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings_STATUS(gens map[string]gopter.Gen) {
	gens["CustomBlockResponseBody"] = gen.PtrOf(gen.AlphaString())
	gens["CustomBlockResponseStatusCode"] = gen.PtrOf(gen.Int())
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(PolicySettings_EnabledState_STATUS_Disabled, PolicySettings_EnabledState_STATUS_Enabled))
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(PolicySettings_Mode_STATUS_Detection, PolicySettings_Mode_STATUS_Prevention))
	gens["RedirectUrl"] = gen.PtrOf(gen.AlphaString())
	gens["RequestBodyCheck"] = gen.PtrOf(gen.OneConstOf(PolicySettings_RequestBodyCheck_STATUS_Disabled, PolicySettings_RequestBodyCheck_STATUS_Enabled))
}

func Test_RoutingRuleLink_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingRuleLink_STATUS to RoutingRuleLink_STATUS via AssignProperties_To_RoutingRuleLink_STATUS & AssignProperties_From_RoutingRuleLink_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingRuleLink_STATUS, RoutingRuleLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingRuleLink_STATUS tests if a specific instance of RoutingRuleLink_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingRuleLink_STATUS(subject RoutingRuleLink_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.RoutingRuleLink_STATUS
	err := copied.AssignProperties_To_RoutingRuleLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingRuleLink_STATUS
	err = actual.AssignProperties_From_RoutingRuleLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingRuleLink_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingRuleLink_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingRuleLink_STATUS, RoutingRuleLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingRuleLink_STATUS runs a test to see if a specific instance of RoutingRuleLink_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingRuleLink_STATUS(subject RoutingRuleLink_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingRuleLink_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingRuleLink_STATUS instances for property testing - lazily instantiated by
// RoutingRuleLink_STATUSGenerator()
var routingRuleLink_STATUSGenerator gopter.Gen

// RoutingRuleLink_STATUSGenerator returns a generator of RoutingRuleLink_STATUS instances for property testing.
func RoutingRuleLink_STATUSGenerator() gopter.Gen {
	if routingRuleLink_STATUSGenerator != nil {
		return routingRuleLink_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingRuleLink_STATUS(generators)
	routingRuleLink_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingRuleLink_STATUS{}), generators)

	return routingRuleLink_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingRuleLink_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingRuleLink_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_SecurityPolicyLink_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SecurityPolicyLink_STATUS to SecurityPolicyLink_STATUS via AssignProperties_To_SecurityPolicyLink_STATUS & AssignProperties_From_SecurityPolicyLink_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSecurityPolicyLink_STATUS, SecurityPolicyLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSecurityPolicyLink_STATUS tests if a specific instance of SecurityPolicyLink_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSecurityPolicyLink_STATUS(subject SecurityPolicyLink_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.SecurityPolicyLink_STATUS
	err := copied.AssignProperties_To_SecurityPolicyLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SecurityPolicyLink_STATUS
	err = actual.AssignProperties_From_SecurityPolicyLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SecurityPolicyLink_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityPolicyLink_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityPolicyLink_STATUS, SecurityPolicyLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityPolicyLink_STATUS runs a test to see if a specific instance of SecurityPolicyLink_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityPolicyLink_STATUS(subject SecurityPolicyLink_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityPolicyLink_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityPolicyLink_STATUS instances for property testing - lazily instantiated by
// SecurityPolicyLink_STATUSGenerator()
var securityPolicyLink_STATUSGenerator gopter.Gen

// SecurityPolicyLink_STATUSGenerator returns a generator of SecurityPolicyLink_STATUS instances for property testing.
func SecurityPolicyLink_STATUSGenerator() gopter.Gen {
	if securityPolicyLink_STATUSGenerator != nil {
		return securityPolicyLink_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityPolicyLink_STATUS(generators)
	securityPolicyLink_STATUSGenerator = gen.Struct(reflect.TypeOf(SecurityPolicyLink_STATUS{}), generators)

	return securityPolicyLink_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSecurityPolicyLink_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityPolicyLink_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignProperties_To_Sku & AssignProperties_From_Sku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.Sku
	err := copied.AssignProperties_To_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignProperties_From_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(Sku_Name_Classic_AzureFrontDoor, Sku_Name_Premium_AzureFrontDoor, Sku_Name_Standard_AzureFrontDoor))
}

func Test_Sku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_STATUS to Sku_STATUS via AssignProperties_To_Sku_STATUS & AssignProperties_From_Sku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_STATUS tests if a specific instance of Sku_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSku_STATUS(subject Sku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.Sku_STATUS
	err := copied.AssignProperties_To_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_STATUS
	err = actual.AssignProperties_From_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(Sku_Name_STATUS_Classic_AzureFrontDoor, Sku_Name_STATUS_Premium_AzureFrontDoor, Sku_Name_STATUS_Standard_AzureFrontDoor))
}

func Test_CustomRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomRule to CustomRule via AssignProperties_To_CustomRule & AssignProperties_From_CustomRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomRule, CustomRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomRule tests if a specific instance of CustomRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomRule(subject CustomRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.CustomRule
	err := copied.AssignProperties_To_CustomRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomRule
	err = actual.AssignProperties_From_CustomRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomRule, CustomRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomRule runs a test to see if a specific instance of CustomRule round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomRule(subject CustomRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomRule instances for property testing - lazily instantiated by CustomRuleGenerator()
var customRuleGenerator gopter.Gen

// CustomRuleGenerator returns a generator of CustomRule instances for property testing.
// We first initialize customRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomRuleGenerator() gopter.Gen {
	if customRuleGenerator != nil {
		return customRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomRule(generators)
	customRuleGenerator = gen.Struct(reflect.TypeOf(CustomRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomRule(generators)
	AddRelatedPropertyGeneratorsForCustomRule(generators)
	customRuleGenerator = gen.Struct(reflect.TypeOf(CustomRule{}), generators)

	return customRuleGenerator
}

// AddIndependentPropertyGeneratorsForCustomRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_Allow,
		ActionType_AnomalyScoring,
		ActionType_Block,
		ActionType_Log,
		ActionType_Redirect))
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(CustomRule_EnabledState_Disabled, CustomRule_EnabledState_Enabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RateLimitDurationInMinutes"] = gen.PtrOf(gen.Int())
	gens["RateLimitThreshold"] = gen.PtrOf(gen.Int())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(CustomRule_RuleType_MatchRule, CustomRule_RuleType_RateLimitRule))
}

// AddRelatedPropertyGeneratorsForCustomRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomRule(gens map[string]gopter.Gen) {
	gens["MatchConditions"] = gen.SliceOf(MatchConditionGenerator())
}

func Test_CustomRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomRule_STATUS to CustomRule_STATUS via AssignProperties_To_CustomRule_STATUS & AssignProperties_From_CustomRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomRule_STATUS, CustomRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomRule_STATUS tests if a specific instance of CustomRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomRule_STATUS(subject CustomRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.CustomRule_STATUS
	err := copied.AssignProperties_To_CustomRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomRule_STATUS
	err = actual.AssignProperties_From_CustomRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomRule_STATUS, CustomRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomRule_STATUS runs a test to see if a specific instance of CustomRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomRule_STATUS(subject CustomRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomRule_STATUS instances for property testing - lazily instantiated by CustomRule_STATUSGenerator()
var customRule_STATUSGenerator gopter.Gen

// CustomRule_STATUSGenerator returns a generator of CustomRule_STATUS instances for property testing.
// We first initialize customRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomRule_STATUSGenerator() gopter.Gen {
	if customRule_STATUSGenerator != nil {
		return customRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomRule_STATUS(generators)
	customRule_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForCustomRule_STATUS(generators)
	customRule_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomRule_STATUS{}), generators)

	return customRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_STATUS_Allow,
		ActionType_STATUS_AnomalyScoring,
		ActionType_STATUS_Block,
		ActionType_STATUS_Log,
		ActionType_STATUS_Redirect))
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(CustomRule_EnabledState_STATUS_Disabled, CustomRule_EnabledState_STATUS_Enabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RateLimitDurationInMinutes"] = gen.PtrOf(gen.Int())
	gens["RateLimitThreshold"] = gen.PtrOf(gen.Int())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(CustomRule_RuleType_STATUS_MatchRule, CustomRule_RuleType_STATUS_RateLimitRule))
}

// AddRelatedPropertyGeneratorsForCustomRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomRule_STATUS(gens map[string]gopter.Gen) {
	gens["MatchConditions"] = gen.SliceOf(MatchCondition_STATUSGenerator())
}

func Test_ManagedRuleSet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleSet to ManagedRuleSet via AssignProperties_To_ManagedRuleSet & AssignProperties_From_ManagedRuleSet returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleSet, ManagedRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleSet tests if a specific instance of ManagedRuleSet can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleSet(subject ManagedRuleSet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleSet
	err := copied.AssignProperties_To_ManagedRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleSet
	err = actual.AssignProperties_From_ManagedRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSet, ManagedRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSet runs a test to see if a specific instance of ManagedRuleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSet(subject ManagedRuleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSet instances for property testing - lazily instantiated by ManagedRuleSetGenerator()
var managedRuleSetGenerator gopter.Gen

// ManagedRuleSetGenerator returns a generator of ManagedRuleSet instances for property testing.
// We first initialize managedRuleSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleSetGenerator() gopter.Gen {
	if managedRuleSetGenerator != nil {
		return managedRuleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet(generators)
	managedRuleSetGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet(generators)
	AddRelatedPropertyGeneratorsForManagedRuleSet(generators)
	managedRuleSetGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet{}), generators)

	return managedRuleSetGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleSet(gens map[string]gopter.Gen) {
	gens["RuleSetAction"] = gen.PtrOf(gen.OneConstOf(ManagedRuleSetActionType_Block, ManagedRuleSetActionType_Log, ManagedRuleSetActionType_Redirect))
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSet(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusionGenerator())
	gens["RuleGroupOverrides"] = gen.SliceOf(ManagedRuleGroupOverrideGenerator())
}

func Test_ManagedRuleSet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleSet_STATUS to ManagedRuleSet_STATUS via AssignProperties_To_ManagedRuleSet_STATUS & AssignProperties_From_ManagedRuleSet_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleSet_STATUS, ManagedRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleSet_STATUS tests if a specific instance of ManagedRuleSet_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleSet_STATUS(subject ManagedRuleSet_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleSet_STATUS
	err := copied.AssignProperties_To_ManagedRuleSet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleSet_STATUS
	err = actual.AssignProperties_From_ManagedRuleSet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleSet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSet_STATUS, ManagedRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSet_STATUS runs a test to see if a specific instance of ManagedRuleSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSet_STATUS(subject ManagedRuleSet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSet_STATUS instances for property testing - lazily instantiated by
// ManagedRuleSet_STATUSGenerator()
var managedRuleSet_STATUSGenerator gopter.Gen

// ManagedRuleSet_STATUSGenerator returns a generator of ManagedRuleSet_STATUS instances for property testing.
// We first initialize managedRuleSet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleSet_STATUSGenerator() gopter.Gen {
	if managedRuleSet_STATUSGenerator != nil {
		return managedRuleSet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet_STATUS(generators)
	managedRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedRuleSet_STATUS(generators)
	managedRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet_STATUS{}), generators)

	return managedRuleSet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleSet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["RuleSetAction"] = gen.PtrOf(gen.OneConstOf(ManagedRuleSetActionType_STATUS_Block, ManagedRuleSetActionType_STATUS_Log, ManagedRuleSetActionType_STATUS_Redirect))
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleSet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusion_STATUSGenerator())
	gens["RuleGroupOverrides"] = gen.SliceOf(ManagedRuleGroupOverride_STATUSGenerator())
}

func Test_ManagedRuleExclusion_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleExclusion to ManagedRuleExclusion via AssignProperties_To_ManagedRuleExclusion & AssignProperties_From_ManagedRuleExclusion returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleExclusion, ManagedRuleExclusionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleExclusion tests if a specific instance of ManagedRuleExclusion can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleExclusion(subject ManagedRuleExclusion) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleExclusion
	err := copied.AssignProperties_To_ManagedRuleExclusion(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleExclusion
	err = actual.AssignProperties_From_ManagedRuleExclusion(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleExclusion_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleExclusion via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleExclusion, ManagedRuleExclusionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleExclusion runs a test to see if a specific instance of ManagedRuleExclusion round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleExclusion(subject ManagedRuleExclusion) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleExclusion
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleExclusion instances for property testing - lazily instantiated by
// ManagedRuleExclusionGenerator()
var managedRuleExclusionGenerator gopter.Gen

// ManagedRuleExclusionGenerator returns a generator of ManagedRuleExclusion instances for property testing.
func ManagedRuleExclusionGenerator() gopter.Gen {
	if managedRuleExclusionGenerator != nil {
		return managedRuleExclusionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleExclusion(generators)
	managedRuleExclusionGenerator = gen.Struct(reflect.TypeOf(ManagedRuleExclusion{}), generators)

	return managedRuleExclusionGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleExclusion is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleExclusion(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		ManagedRuleExclusion_MatchVariable_QueryStringArgNames,
		ManagedRuleExclusion_MatchVariable_RequestBodyJsonArgNames,
		ManagedRuleExclusion_MatchVariable_RequestBodyPostArgNames,
		ManagedRuleExclusion_MatchVariable_RequestCookieNames,
		ManagedRuleExclusion_MatchVariable_RequestHeaderNames))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(
		ManagedRuleExclusion_SelectorMatchOperator_Contains,
		ManagedRuleExclusion_SelectorMatchOperator_EndsWith,
		ManagedRuleExclusion_SelectorMatchOperator_Equals,
		ManagedRuleExclusion_SelectorMatchOperator_EqualsAny,
		ManagedRuleExclusion_SelectorMatchOperator_StartsWith))
}

func Test_ManagedRuleExclusion_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleExclusion_STATUS to ManagedRuleExclusion_STATUS via AssignProperties_To_ManagedRuleExclusion_STATUS & AssignProperties_From_ManagedRuleExclusion_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleExclusion_STATUS, ManagedRuleExclusion_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleExclusion_STATUS tests if a specific instance of ManagedRuleExclusion_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleExclusion_STATUS(subject ManagedRuleExclusion_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleExclusion_STATUS
	err := copied.AssignProperties_To_ManagedRuleExclusion_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleExclusion_STATUS
	err = actual.AssignProperties_From_ManagedRuleExclusion_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleExclusion_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleExclusion_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleExclusion_STATUS, ManagedRuleExclusion_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleExclusion_STATUS runs a test to see if a specific instance of ManagedRuleExclusion_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleExclusion_STATUS(subject ManagedRuleExclusion_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleExclusion_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleExclusion_STATUS instances for property testing - lazily instantiated by
// ManagedRuleExclusion_STATUSGenerator()
var managedRuleExclusion_STATUSGenerator gopter.Gen

// ManagedRuleExclusion_STATUSGenerator returns a generator of ManagedRuleExclusion_STATUS instances for property testing.
func ManagedRuleExclusion_STATUSGenerator() gopter.Gen {
	if managedRuleExclusion_STATUSGenerator != nil {
		return managedRuleExclusion_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleExclusion_STATUS(generators)
	managedRuleExclusion_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleExclusion_STATUS{}), generators)

	return managedRuleExclusion_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleExclusion_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleExclusion_STATUS(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		ManagedRuleExclusion_MatchVariable_STATUS_QueryStringArgNames,
		ManagedRuleExclusion_MatchVariable_STATUS_RequestBodyJsonArgNames,
		ManagedRuleExclusion_MatchVariable_STATUS_RequestBodyPostArgNames,
		ManagedRuleExclusion_MatchVariable_STATUS_RequestCookieNames,
		ManagedRuleExclusion_MatchVariable_STATUS_RequestHeaderNames))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(
		ManagedRuleExclusion_SelectorMatchOperator_STATUS_Contains,
		ManagedRuleExclusion_SelectorMatchOperator_STATUS_EndsWith,
		ManagedRuleExclusion_SelectorMatchOperator_STATUS_Equals,
		ManagedRuleExclusion_SelectorMatchOperator_STATUS_EqualsAny,
		ManagedRuleExclusion_SelectorMatchOperator_STATUS_StartsWith))
}

func Test_ManagedRuleGroupOverride_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleGroupOverride to ManagedRuleGroupOverride via AssignProperties_To_ManagedRuleGroupOverride & AssignProperties_From_ManagedRuleGroupOverride returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleGroupOverride, ManagedRuleGroupOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleGroupOverride tests if a specific instance of ManagedRuleGroupOverride can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleGroupOverride(subject ManagedRuleGroupOverride) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleGroupOverride
	err := copied.AssignProperties_To_ManagedRuleGroupOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleGroupOverride
	err = actual.AssignProperties_From_ManagedRuleGroupOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleGroupOverride_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleGroupOverride via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleGroupOverride, ManagedRuleGroupOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleGroupOverride runs a test to see if a specific instance of ManagedRuleGroupOverride round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleGroupOverride(subject ManagedRuleGroupOverride) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleGroupOverride
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleGroupOverride instances for property testing - lazily instantiated by
// ManagedRuleGroupOverrideGenerator()
var managedRuleGroupOverrideGenerator gopter.Gen

// ManagedRuleGroupOverrideGenerator returns a generator of ManagedRuleGroupOverride instances for property testing.
// We first initialize managedRuleGroupOverrideGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleGroupOverrideGenerator() gopter.Gen {
	if managedRuleGroupOverrideGenerator != nil {
		return managedRuleGroupOverrideGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride(generators)
	managedRuleGroupOverrideGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride(generators)
	AddRelatedPropertyGeneratorsForManagedRuleGroupOverride(generators)
	managedRuleGroupOverrideGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride{}), generators)

	return managedRuleGroupOverrideGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleGroupOverride is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleGroupOverride(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleGroupOverride is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleGroupOverride(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusionGenerator())
	gens["Rules"] = gen.SliceOf(ManagedRuleOverrideGenerator())
}

func Test_ManagedRuleGroupOverride_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleGroupOverride_STATUS to ManagedRuleGroupOverride_STATUS via AssignProperties_To_ManagedRuleGroupOverride_STATUS & AssignProperties_From_ManagedRuleGroupOverride_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleGroupOverride_STATUS, ManagedRuleGroupOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleGroupOverride_STATUS tests if a specific instance of ManagedRuleGroupOverride_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleGroupOverride_STATUS(subject ManagedRuleGroupOverride_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleGroupOverride_STATUS
	err := copied.AssignProperties_To_ManagedRuleGroupOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleGroupOverride_STATUS
	err = actual.AssignProperties_From_ManagedRuleGroupOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleGroupOverride_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleGroupOverride_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleGroupOverride_STATUS, ManagedRuleGroupOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleGroupOverride_STATUS runs a test to see if a specific instance of ManagedRuleGroupOverride_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleGroupOverride_STATUS(subject ManagedRuleGroupOverride_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleGroupOverride_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleGroupOverride_STATUS instances for property testing - lazily instantiated by
// ManagedRuleGroupOverride_STATUSGenerator()
var managedRuleGroupOverride_STATUSGenerator gopter.Gen

// ManagedRuleGroupOverride_STATUSGenerator returns a generator of ManagedRuleGroupOverride_STATUS instances for property testing.
// We first initialize managedRuleGroupOverride_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleGroupOverride_STATUSGenerator() gopter.Gen {
	if managedRuleGroupOverride_STATUSGenerator != nil {
		return managedRuleGroupOverride_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_STATUS(generators)
	managedRuleGroupOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_STATUS(generators)
	managedRuleGroupOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride_STATUS{}), generators)

	return managedRuleGroupOverride_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_STATUS(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_STATUS(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusion_STATUSGenerator())
	gens["Rules"] = gen.SliceOf(ManagedRuleOverride_STATUSGenerator())
}

func Test_MatchCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MatchCondition to MatchCondition via AssignProperties_To_MatchCondition & AssignProperties_From_MatchCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForMatchCondition, MatchConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMatchCondition tests if a specific instance of MatchCondition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMatchCondition(subject MatchCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.MatchCondition
	err := copied.AssignProperties_To_MatchCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MatchCondition
	err = actual.AssignProperties_From_MatchCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MatchCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchCondition, MatchConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchCondition runs a test to see if a specific instance of MatchCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchCondition(subject MatchCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchCondition instances for property testing - lazily instantiated by MatchConditionGenerator()
var matchConditionGenerator gopter.Gen

// MatchConditionGenerator returns a generator of MatchCondition instances for property testing.
func MatchConditionGenerator() gopter.Gen {
	if matchConditionGenerator != nil {
		return matchConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition(generators)
	matchConditionGenerator = gen.Struct(reflect.TypeOf(MatchCondition{}), generators)

	return matchConditionGenerator
}

// AddIndependentPropertyGeneratorsForMatchCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchCondition(gens map[string]gopter.Gen) {
	gens["MatchValue"] = gen.SliceOf(gen.AlphaString())
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_MatchVariable_Cookies,
		MatchCondition_MatchVariable_PostArgs,
		MatchCondition_MatchVariable_QueryString,
		MatchCondition_MatchVariable_RemoteAddr,
		MatchCondition_MatchVariable_RequestBody,
		MatchCondition_MatchVariable_RequestHeader,
		MatchCondition_MatchVariable_RequestMethod,
		MatchCondition_MatchVariable_RequestUri,
		MatchCondition_MatchVariable_SocketAddr))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_Operator_Any,
		MatchCondition_Operator_BeginsWith,
		MatchCondition_Operator_Contains,
		MatchCondition_Operator_EndsWith,
		MatchCondition_Operator_Equal,
		MatchCondition_Operator_GeoMatch,
		MatchCondition_Operator_GreaterThan,
		MatchCondition_Operator_GreaterThanOrEqual,
		MatchCondition_Operator_IPMatch,
		MatchCondition_Operator_LessThan,
		MatchCondition_Operator_LessThanOrEqual,
		MatchCondition_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		TransformType_Lowercase,
		TransformType_RemoveNulls,
		TransformType_Trim,
		TransformType_Uppercase,
		TransformType_UrlDecode,
		TransformType_UrlEncode))
}

func Test_MatchCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MatchCondition_STATUS to MatchCondition_STATUS via AssignProperties_To_MatchCondition_STATUS & AssignProperties_From_MatchCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMatchCondition_STATUS, MatchCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMatchCondition_STATUS tests if a specific instance of MatchCondition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMatchCondition_STATUS(subject MatchCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.MatchCondition_STATUS
	err := copied.AssignProperties_To_MatchCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MatchCondition_STATUS
	err = actual.AssignProperties_From_MatchCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MatchCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchCondition_STATUS, MatchCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchCondition_STATUS runs a test to see if a specific instance of MatchCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchCondition_STATUS(subject MatchCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchCondition_STATUS instances for property testing - lazily instantiated by
// MatchCondition_STATUSGenerator()
var matchCondition_STATUSGenerator gopter.Gen

// MatchCondition_STATUSGenerator returns a generator of MatchCondition_STATUS instances for property testing.
func MatchCondition_STATUSGenerator() gopter.Gen {
	if matchCondition_STATUSGenerator != nil {
		return matchCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition_STATUS(generators)
	matchCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(MatchCondition_STATUS{}), generators)

	return matchCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMatchCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchCondition_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValue"] = gen.SliceOf(gen.AlphaString())
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_MatchVariable_STATUS_Cookies,
		MatchCondition_MatchVariable_STATUS_PostArgs,
		MatchCondition_MatchVariable_STATUS_QueryString,
		MatchCondition_MatchVariable_STATUS_RemoteAddr,
		MatchCondition_MatchVariable_STATUS_RequestBody,
		MatchCondition_MatchVariable_STATUS_RequestHeader,
		MatchCondition_MatchVariable_STATUS_RequestMethod,
		MatchCondition_MatchVariable_STATUS_RequestUri,
		MatchCondition_MatchVariable_STATUS_SocketAddr))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_Operator_STATUS_Any,
		MatchCondition_Operator_STATUS_BeginsWith,
		MatchCondition_Operator_STATUS_Contains,
		MatchCondition_Operator_STATUS_EndsWith,
		MatchCondition_Operator_STATUS_Equal,
		MatchCondition_Operator_STATUS_GeoMatch,
		MatchCondition_Operator_STATUS_GreaterThan,
		MatchCondition_Operator_STATUS_GreaterThanOrEqual,
		MatchCondition_Operator_STATUS_IPMatch,
		MatchCondition_Operator_STATUS_LessThan,
		MatchCondition_Operator_STATUS_LessThanOrEqual,
		MatchCondition_Operator_STATUS_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		TransformType_STATUS_Lowercase,
		TransformType_STATUS_RemoveNulls,
		TransformType_STATUS_Trim,
		TransformType_STATUS_Uppercase,
		TransformType_STATUS_UrlDecode,
		TransformType_STATUS_UrlEncode))
}

func Test_ManagedRuleOverride_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleOverride to ManagedRuleOverride via AssignProperties_To_ManagedRuleOverride & AssignProperties_From_ManagedRuleOverride returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleOverride, ManagedRuleOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleOverride tests if a specific instance of ManagedRuleOverride can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleOverride(subject ManagedRuleOverride) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleOverride
	err := copied.AssignProperties_To_ManagedRuleOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleOverride
	err = actual.AssignProperties_From_ManagedRuleOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleOverride_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleOverride via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleOverride, ManagedRuleOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleOverride runs a test to see if a specific instance of ManagedRuleOverride round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleOverride(subject ManagedRuleOverride) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleOverride
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleOverride instances for property testing - lazily instantiated by
// ManagedRuleOverrideGenerator()
var managedRuleOverrideGenerator gopter.Gen

// ManagedRuleOverrideGenerator returns a generator of ManagedRuleOverride instances for property testing.
// We first initialize managedRuleOverrideGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleOverrideGenerator() gopter.Gen {
	if managedRuleOverrideGenerator != nil {
		return managedRuleOverrideGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride(generators)
	managedRuleOverrideGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride(generators)
	AddRelatedPropertyGeneratorsForManagedRuleOverride(generators)
	managedRuleOverrideGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride{}), generators)

	return managedRuleOverrideGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleOverride is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleOverride(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_Allow,
		ActionType_AnomalyScoring,
		ActionType_Block,
		ActionType_Log,
		ActionType_Redirect))
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(ManagedRuleEnabledState_Disabled, ManagedRuleEnabledState_Enabled))
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleOverride is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleOverride(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusionGenerator())
}

func Test_ManagedRuleOverride_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleOverride_STATUS to ManagedRuleOverride_STATUS via AssignProperties_To_ManagedRuleOverride_STATUS & AssignProperties_From_ManagedRuleOverride_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleOverride_STATUS, ManagedRuleOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleOverride_STATUS tests if a specific instance of ManagedRuleOverride_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleOverride_STATUS(subject ManagedRuleOverride_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220501s.ManagedRuleOverride_STATUS
	err := copied.AssignProperties_To_ManagedRuleOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleOverride_STATUS
	err = actual.AssignProperties_From_ManagedRuleOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleOverride_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleOverride_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleOverride_STATUS, ManagedRuleOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleOverride_STATUS runs a test to see if a specific instance of ManagedRuleOverride_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleOverride_STATUS(subject ManagedRuleOverride_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleOverride_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleOverride_STATUS instances for property testing - lazily instantiated by
// ManagedRuleOverride_STATUSGenerator()
var managedRuleOverride_STATUSGenerator gopter.Gen

// ManagedRuleOverride_STATUSGenerator returns a generator of ManagedRuleOverride_STATUS instances for property testing.
// We first initialize managedRuleOverride_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleOverride_STATUSGenerator() gopter.Gen {
	if managedRuleOverride_STATUSGenerator != nil {
		return managedRuleOverride_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride_STATUS(generators)
	managedRuleOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedRuleOverride_STATUS(generators)
	managedRuleOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride_STATUS{}), generators)

	return managedRuleOverride_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleOverride_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleOverride_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_STATUS_Allow,
		ActionType_STATUS_AnomalyScoring,
		ActionType_STATUS_Block,
		ActionType_STATUS_Log,
		ActionType_STATUS_Redirect))
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(ManagedRuleEnabledState_STATUS_Disabled, ManagedRuleEnabledState_STATUS_Enabled))
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleOverride_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleOverride_STATUS(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusion_STATUSGenerator())
}
