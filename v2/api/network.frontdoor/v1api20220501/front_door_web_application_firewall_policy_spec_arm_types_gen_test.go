// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220501

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_FrontDoorWebApplicationFirewallPolicy_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FrontDoorWebApplicationFirewallPolicy_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_Spec_ARM, FrontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_Spec_ARM runs a test to see if a specific instance of FrontDoorWebApplicationFirewallPolicy_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFrontDoorWebApplicationFirewallPolicy_Spec_ARM(subject FrontDoorWebApplicationFirewallPolicy_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FrontDoorWebApplicationFirewallPolicy_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FrontDoorWebApplicationFirewallPolicy_Spec_ARM instances for property testing - lazily instantiated by
// FrontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator()
var frontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator gopter.Gen

// FrontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator returns a generator of FrontDoorWebApplicationFirewallPolicy_Spec_ARM instances for property testing.
// We first initialize frontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FrontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator() gopter.Gen {
	if frontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator != nil {
		return frontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec_ARM(generators)
	frontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(FrontDoorWebApplicationFirewallPolicy_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec_ARM(generators)
	frontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(FrontDoorWebApplicationFirewallPolicy_Spec_ARM{}), generators)

	return frontDoorWebApplicationFirewallPolicy_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFrontDoorWebApplicationFirewallPolicy_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WebApplicationFirewallPolicyProperties_ARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_ARMGenerator())
}

func Test_Sku_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_ARM, Sku_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_ARM runs a test to see if a specific instance of Sku_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_ARM(subject Sku_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_ARM instances for property testing - lazily instantiated by Sku_ARMGenerator()
var sku_ARMGenerator gopter.Gen

// Sku_ARMGenerator returns a generator of Sku_ARM instances for property testing.
func Sku_ARMGenerator() gopter.Gen {
	if sku_ARMGenerator != nil {
		return sku_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_ARM(generators)
	sku_ARMGenerator = gen.Struct(reflect.TypeOf(Sku_ARM{}), generators)

	return sku_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSku_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(Sku_Name_Classic_AzureFrontDoor, Sku_Name_Premium_AzureFrontDoor, Sku_Name_Standard_AzureFrontDoor))
}

func Test_WebApplicationFirewallPolicyProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallPolicyProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallPolicyProperties_ARM, WebApplicationFirewallPolicyProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallPolicyProperties_ARM runs a test to see if a specific instance of WebApplicationFirewallPolicyProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallPolicyProperties_ARM(subject WebApplicationFirewallPolicyProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallPolicyProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallPolicyProperties_ARM instances for property testing - lazily instantiated by
// WebApplicationFirewallPolicyProperties_ARMGenerator()
var webApplicationFirewallPolicyProperties_ARMGenerator gopter.Gen

// WebApplicationFirewallPolicyProperties_ARMGenerator returns a generator of WebApplicationFirewallPolicyProperties_ARM instances for property testing.
func WebApplicationFirewallPolicyProperties_ARMGenerator() gopter.Gen {
	if webApplicationFirewallPolicyProperties_ARMGenerator != nil {
		return webApplicationFirewallPolicyProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicyProperties_ARM(generators)
	webApplicationFirewallPolicyProperties_ARMGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicyProperties_ARM{}), generators)

	return webApplicationFirewallPolicyProperties_ARMGenerator
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicyProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicyProperties_ARM(gens map[string]gopter.Gen) {
	gens["CustomRules"] = gen.PtrOf(CustomRuleList_ARMGenerator())
	gens["ManagedRules"] = gen.PtrOf(ManagedRuleSetList_ARMGenerator())
	gens["PolicySettings"] = gen.PtrOf(PolicySettings_ARMGenerator())
}

func Test_CustomRuleList_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomRuleList_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomRuleList_ARM, CustomRuleList_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomRuleList_ARM runs a test to see if a specific instance of CustomRuleList_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomRuleList_ARM(subject CustomRuleList_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomRuleList_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomRuleList_ARM instances for property testing - lazily instantiated by CustomRuleList_ARMGenerator()
var customRuleList_ARMGenerator gopter.Gen

// CustomRuleList_ARMGenerator returns a generator of CustomRuleList_ARM instances for property testing.
func CustomRuleList_ARMGenerator() gopter.Gen {
	if customRuleList_ARMGenerator != nil {
		return customRuleList_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCustomRuleList_ARM(generators)
	customRuleList_ARMGenerator = gen.Struct(reflect.TypeOf(CustomRuleList_ARM{}), generators)

	return customRuleList_ARMGenerator
}

// AddRelatedPropertyGeneratorsForCustomRuleList_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomRuleList_ARM(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(CustomRule_ARMGenerator())
}

func Test_ManagedRuleSetList_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSetList_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSetList_ARM, ManagedRuleSetList_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSetList_ARM runs a test to see if a specific instance of ManagedRuleSetList_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSetList_ARM(subject ManagedRuleSetList_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSetList_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSetList_ARM instances for property testing - lazily instantiated by
// ManagedRuleSetList_ARMGenerator()
var managedRuleSetList_ARMGenerator gopter.Gen

// ManagedRuleSetList_ARMGenerator returns a generator of ManagedRuleSetList_ARM instances for property testing.
func ManagedRuleSetList_ARMGenerator() gopter.Gen {
	if managedRuleSetList_ARMGenerator != nil {
		return managedRuleSetList_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedRuleSetList_ARM(generators)
	managedRuleSetList_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSetList_ARM{}), generators)

	return managedRuleSetList_ARMGenerator
}

// AddRelatedPropertyGeneratorsForManagedRuleSetList_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSetList_ARM(gens map[string]gopter.Gen) {
	gens["ManagedRuleSets"] = gen.SliceOf(ManagedRuleSet_ARMGenerator())
}

func Test_PolicySettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings_ARM, PolicySettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings_ARM runs a test to see if a specific instance of PolicySettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings_ARM(subject PolicySettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings_ARM instances for property testing - lazily instantiated by PolicySettings_ARMGenerator()
var policySettings_ARMGenerator gopter.Gen

// PolicySettings_ARMGenerator returns a generator of PolicySettings_ARM instances for property testing.
func PolicySettings_ARMGenerator() gopter.Gen {
	if policySettings_ARMGenerator != nil {
		return policySettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_ARM(generators)
	policySettings_ARMGenerator = gen.Struct(reflect.TypeOf(PolicySettings_ARM{}), generators)

	return policySettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings_ARM(gens map[string]gopter.Gen) {
	gens["CustomBlockResponseBody"] = gen.PtrOf(gen.AlphaString())
	gens["CustomBlockResponseStatusCode"] = gen.PtrOf(gen.Int())
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(PolicySettings_EnabledState_Disabled, PolicySettings_EnabledState_Enabled))
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(PolicySettings_Mode_Detection, PolicySettings_Mode_Prevention))
	gens["RedirectUrl"] = gen.PtrOf(gen.AlphaString())
	gens["RequestBodyCheck"] = gen.PtrOf(gen.OneConstOf(PolicySettings_RequestBodyCheck_Disabled, PolicySettings_RequestBodyCheck_Enabled))
}

func Test_CustomRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomRule_ARM, CustomRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomRule_ARM runs a test to see if a specific instance of CustomRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomRule_ARM(subject CustomRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomRule_ARM instances for property testing - lazily instantiated by CustomRule_ARMGenerator()
var customRule_ARMGenerator gopter.Gen

// CustomRule_ARMGenerator returns a generator of CustomRule_ARM instances for property testing.
// We first initialize customRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomRule_ARMGenerator() gopter.Gen {
	if customRule_ARMGenerator != nil {
		return customRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomRule_ARM(generators)
	customRule_ARMGenerator = gen.Struct(reflect.TypeOf(CustomRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomRule_ARM(generators)
	AddRelatedPropertyGeneratorsForCustomRule_ARM(generators)
	customRule_ARMGenerator = gen.Struct(reflect.TypeOf(CustomRule_ARM{}), generators)

	return customRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCustomRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomRule_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_Allow,
		ActionType_AnomalyScoring,
		ActionType_Block,
		ActionType_Log,
		ActionType_Redirect))
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(CustomRule_EnabledState_Disabled, CustomRule_EnabledState_Enabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RateLimitDurationInMinutes"] = gen.PtrOf(gen.Int())
	gens["RateLimitThreshold"] = gen.PtrOf(gen.Int())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(CustomRule_RuleType_MatchRule, CustomRule_RuleType_RateLimitRule))
}

// AddRelatedPropertyGeneratorsForCustomRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomRule_ARM(gens map[string]gopter.Gen) {
	gens["MatchConditions"] = gen.SliceOf(MatchCondition_ARMGenerator())
}

func Test_ManagedRuleSet_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSet_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSet_ARM, ManagedRuleSet_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSet_ARM runs a test to see if a specific instance of ManagedRuleSet_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSet_ARM(subject ManagedRuleSet_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSet_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSet_ARM instances for property testing - lazily instantiated by ManagedRuleSet_ARMGenerator()
var managedRuleSet_ARMGenerator gopter.Gen

// ManagedRuleSet_ARMGenerator returns a generator of ManagedRuleSet_ARM instances for property testing.
// We first initialize managedRuleSet_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleSet_ARMGenerator() gopter.Gen {
	if managedRuleSet_ARMGenerator != nil {
		return managedRuleSet_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet_ARM(generators)
	managedRuleSet_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedRuleSet_ARM(generators)
	managedRuleSet_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet_ARM{}), generators)

	return managedRuleSet_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleSet_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleSet_ARM(gens map[string]gopter.Gen) {
	gens["RuleSetAction"] = gen.PtrOf(gen.OneConstOf(ManagedRuleSetActionType_Block, ManagedRuleSetActionType_Log, ManagedRuleSetActionType_Redirect))
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleSet_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSet_ARM(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusion_ARMGenerator())
	gens["RuleGroupOverrides"] = gen.SliceOf(ManagedRuleGroupOverride_ARMGenerator())
}

func Test_ManagedRuleExclusion_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleExclusion_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleExclusion_ARM, ManagedRuleExclusion_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleExclusion_ARM runs a test to see if a specific instance of ManagedRuleExclusion_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleExclusion_ARM(subject ManagedRuleExclusion_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleExclusion_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleExclusion_ARM instances for property testing - lazily instantiated by
// ManagedRuleExclusion_ARMGenerator()
var managedRuleExclusion_ARMGenerator gopter.Gen

// ManagedRuleExclusion_ARMGenerator returns a generator of ManagedRuleExclusion_ARM instances for property testing.
func ManagedRuleExclusion_ARMGenerator() gopter.Gen {
	if managedRuleExclusion_ARMGenerator != nil {
		return managedRuleExclusion_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleExclusion_ARM(generators)
	managedRuleExclusion_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleExclusion_ARM{}), generators)

	return managedRuleExclusion_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleExclusion_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleExclusion_ARM(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		ManagedRuleExclusion_MatchVariable_QueryStringArgNames,
		ManagedRuleExclusion_MatchVariable_RequestBodyJsonArgNames,
		ManagedRuleExclusion_MatchVariable_RequestBodyPostArgNames,
		ManagedRuleExclusion_MatchVariable_RequestCookieNames,
		ManagedRuleExclusion_MatchVariable_RequestHeaderNames))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(
		ManagedRuleExclusion_SelectorMatchOperator_Contains,
		ManagedRuleExclusion_SelectorMatchOperator_EndsWith,
		ManagedRuleExclusion_SelectorMatchOperator_Equals,
		ManagedRuleExclusion_SelectorMatchOperator_EqualsAny,
		ManagedRuleExclusion_SelectorMatchOperator_StartsWith))
}

func Test_ManagedRuleGroupOverride_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleGroupOverride_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleGroupOverride_ARM, ManagedRuleGroupOverride_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleGroupOverride_ARM runs a test to see if a specific instance of ManagedRuleGroupOverride_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleGroupOverride_ARM(subject ManagedRuleGroupOverride_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleGroupOverride_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleGroupOverride_ARM instances for property testing - lazily instantiated by
// ManagedRuleGroupOverride_ARMGenerator()
var managedRuleGroupOverride_ARMGenerator gopter.Gen

// ManagedRuleGroupOverride_ARMGenerator returns a generator of ManagedRuleGroupOverride_ARM instances for property testing.
// We first initialize managedRuleGroupOverride_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleGroupOverride_ARMGenerator() gopter.Gen {
	if managedRuleGroupOverride_ARMGenerator != nil {
		return managedRuleGroupOverride_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_ARM(generators)
	managedRuleGroupOverride_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_ARM(generators)
	managedRuleGroupOverride_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride_ARM{}), generators)

	return managedRuleGroupOverride_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_ARM(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_ARM(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusion_ARMGenerator())
	gens["Rules"] = gen.SliceOf(ManagedRuleOverride_ARMGenerator())
}

func Test_MatchCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchCondition_ARM, MatchCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchCondition_ARM runs a test to see if a specific instance of MatchCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchCondition_ARM(subject MatchCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchCondition_ARM instances for property testing - lazily instantiated by MatchCondition_ARMGenerator()
var matchCondition_ARMGenerator gopter.Gen

// MatchCondition_ARMGenerator returns a generator of MatchCondition_ARM instances for property testing.
func MatchCondition_ARMGenerator() gopter.Gen {
	if matchCondition_ARMGenerator != nil {
		return matchCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition_ARM(generators)
	matchCondition_ARMGenerator = gen.Struct(reflect.TypeOf(MatchCondition_ARM{}), generators)

	return matchCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForMatchCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchCondition_ARM(gens map[string]gopter.Gen) {
	gens["MatchValue"] = gen.SliceOf(gen.AlphaString())
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_MatchVariable_Cookies,
		MatchCondition_MatchVariable_PostArgs,
		MatchCondition_MatchVariable_QueryString,
		MatchCondition_MatchVariable_RemoteAddr,
		MatchCondition_MatchVariable_RequestBody,
		MatchCondition_MatchVariable_RequestHeader,
		MatchCondition_MatchVariable_RequestMethod,
		MatchCondition_MatchVariable_RequestUri,
		MatchCondition_MatchVariable_SocketAddr))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_Operator_Any,
		MatchCondition_Operator_BeginsWith,
		MatchCondition_Operator_Contains,
		MatchCondition_Operator_EndsWith,
		MatchCondition_Operator_Equal,
		MatchCondition_Operator_GeoMatch,
		MatchCondition_Operator_GreaterThan,
		MatchCondition_Operator_GreaterThanOrEqual,
		MatchCondition_Operator_IPMatch,
		MatchCondition_Operator_LessThan,
		MatchCondition_Operator_LessThanOrEqual,
		MatchCondition_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		TransformType_Lowercase,
		TransformType_RemoveNulls,
		TransformType_Trim,
		TransformType_Uppercase,
		TransformType_UrlDecode,
		TransformType_UrlEncode))
}

func Test_ManagedRuleOverride_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleOverride_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleOverride_ARM, ManagedRuleOverride_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleOverride_ARM runs a test to see if a specific instance of ManagedRuleOverride_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleOverride_ARM(subject ManagedRuleOverride_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleOverride_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleOverride_ARM instances for property testing - lazily instantiated by
// ManagedRuleOverride_ARMGenerator()
var managedRuleOverride_ARMGenerator gopter.Gen

// ManagedRuleOverride_ARMGenerator returns a generator of ManagedRuleOverride_ARM instances for property testing.
// We first initialize managedRuleOverride_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleOverride_ARMGenerator() gopter.Gen {
	if managedRuleOverride_ARMGenerator != nil {
		return managedRuleOverride_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride_ARM(generators)
	managedRuleOverride_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedRuleOverride_ARM(generators)
	managedRuleOverride_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride_ARM{}), generators)

	return managedRuleOverride_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleOverride_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleOverride_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_Allow,
		ActionType_AnomalyScoring,
		ActionType_Block,
		ActionType_Log,
		ActionType_Redirect))
	gens["EnabledState"] = gen.PtrOf(gen.OneConstOf(ManagedRuleEnabledState_Disabled, ManagedRuleEnabledState_Enabled))
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleOverride_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleOverride_ARM(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(ManagedRuleExclusion_ARMGenerator())
}
