// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220501

import (
	"fmt"
	v20220501s "github.com/Azure/azure-service-operator/v2/api/network.frontdoor/v1api20220501/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /frontdoor/resource-manager/Microsoft.Network/stable/2022-05-01/webapplicationfirewall.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}
type WebApplicationFirewallPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FrontDoorWebApplicationFirewallPolicy_Spec   `json:"spec,omitempty"`
	Status            FrontDoorWebApplicationFirewallPolicy_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &WebApplicationFirewallPolicy{}

// GetConditions returns the conditions of the resource
func (policy *WebApplicationFirewallPolicy) GetConditions() conditions.Conditions {
	return policy.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (policy *WebApplicationFirewallPolicy) SetConditions(conditions conditions.Conditions) {
	policy.Status.Conditions = conditions
}

var _ conversion.Convertible = &WebApplicationFirewallPolicy{}

// ConvertFrom populates our WebApplicationFirewallPolicy from the provided hub WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20220501s.WebApplicationFirewallPolicy)
	if !ok {
		return fmt.Errorf("expected network.frontdoor/v1api20220501/storage/WebApplicationFirewallPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_From_WebApplicationFirewallPolicy(source)
}

// ConvertTo populates the provided hub WebApplicationFirewallPolicy from our WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20220501s.WebApplicationFirewallPolicy)
	if !ok {
		return fmt.Errorf("expected network.frontdoor/v1api20220501/storage/WebApplicationFirewallPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_To_WebApplicationFirewallPolicy(destination)
}

// +kubebuilder:webhook:path=/mutate-network-frontdoor-azure-com-v1api20220501-webapplicationfirewallpolicy,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.frontdoor.azure.com,resources=webapplicationfirewallpolicies,verbs=create;update,versions=v1api20220501,name=default.v1api20220501.webapplicationfirewallpolicies.network.frontdoor.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &WebApplicationFirewallPolicy{}

// Default applies defaults to the WebApplicationFirewallPolicy resource
func (policy *WebApplicationFirewallPolicy) Default() {
	policy.defaultImpl()
	var temp any = policy
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (policy *WebApplicationFirewallPolicy) defaultAzureName() {
	if policy.Spec.AzureName == "" {
		policy.Spec.AzureName = policy.Name
	}
}

// defaultImpl applies the code generated defaults to the WebApplicationFirewallPolicy resource
func (policy *WebApplicationFirewallPolicy) defaultImpl() { policy.defaultAzureName() }

var _ genruntime.ImportableResource = &WebApplicationFirewallPolicy{}

// InitializeSpec initializes the spec for this resource from the given status
func (policy *WebApplicationFirewallPolicy) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*FrontDoorWebApplicationFirewallPolicy_STATUS); ok {
		return policy.Spec.Initialize_From_FrontDoorWebApplicationFirewallPolicy_STATUS(s)
	}

	return fmt.Errorf("expected Status of type FrontDoorWebApplicationFirewallPolicy_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &WebApplicationFirewallPolicy{}

// AzureName returns the Azure name of the resource
func (policy *WebApplicationFirewallPolicy) AzureName() string {
	return policy.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-05-01"
func (policy WebApplicationFirewallPolicy) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (policy *WebApplicationFirewallPolicy) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (policy *WebApplicationFirewallPolicy) GetSpec() genruntime.ConvertibleSpec {
	return &policy.Spec
}

// GetStatus returns the status of this resource
func (policy *WebApplicationFirewallPolicy) GetStatus() genruntime.ConvertibleStatus {
	return &policy.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (policy *WebApplicationFirewallPolicy) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/FrontDoorWebApplicationFirewallPolicies"
func (policy *WebApplicationFirewallPolicy) GetType() string {
	return "Microsoft.Network/FrontDoorWebApplicationFirewallPolicies"
}

// NewEmptyStatus returns a new empty (blank) status
func (policy *WebApplicationFirewallPolicy) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &FrontDoorWebApplicationFirewallPolicy_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (policy *WebApplicationFirewallPolicy) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(policy.Spec)
	return policy.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (policy *WebApplicationFirewallPolicy) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*FrontDoorWebApplicationFirewallPolicy_STATUS); ok {
		policy.Status = *st
		return nil
	}

	// Convert status to required version
	var st FrontDoorWebApplicationFirewallPolicy_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	policy.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-frontdoor-azure-com-v1api20220501-webapplicationfirewallpolicy,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.frontdoor.azure.com,resources=webapplicationfirewallpolicies,verbs=create;update,versions=v1api20220501,name=validate.v1api20220501.webapplicationfirewallpolicies.network.frontdoor.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &WebApplicationFirewallPolicy{}

// ValidateCreate validates the creation of the resource
func (policy *WebApplicationFirewallPolicy) ValidateCreate() (admission.Warnings, error) {
	validations := policy.createValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (policy *WebApplicationFirewallPolicy) ValidateDelete() (admission.Warnings, error) {
	validations := policy.deleteValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (policy *WebApplicationFirewallPolicy) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := policy.updateValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (policy *WebApplicationFirewallPolicy) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){policy.validateResourceReferences, policy.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (policy *WebApplicationFirewallPolicy) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (policy *WebApplicationFirewallPolicy) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateResourceReferences()
		},
		policy.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (policy *WebApplicationFirewallPolicy) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(policy)
}

// validateResourceReferences validates all resource references
func (policy *WebApplicationFirewallPolicy) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&policy.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (policy *WebApplicationFirewallPolicy) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*WebApplicationFirewallPolicy)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, policy)
}

// AssignProperties_From_WebApplicationFirewallPolicy populates our WebApplicationFirewallPolicy from the provided source WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) AssignProperties_From_WebApplicationFirewallPolicy(source *v20220501s.WebApplicationFirewallPolicy) error {

	// ObjectMeta
	policy.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec FrontDoorWebApplicationFirewallPolicy_Spec
	err := spec.AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_Spec() to populate field Spec")
	}
	policy.Spec = spec

	// Status
	var status FrontDoorWebApplicationFirewallPolicy_STATUS
	err = status.AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_STATUS() to populate field Status")
	}
	policy.Status = status

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicy populates the provided destination WebApplicationFirewallPolicy from our WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) AssignProperties_To_WebApplicationFirewallPolicy(destination *v20220501s.WebApplicationFirewallPolicy) error {

	// ObjectMeta
	destination.ObjectMeta = *policy.ObjectMeta.DeepCopy()

	// Spec
	var spec v20220501s.FrontDoorWebApplicationFirewallPolicy_Spec
	err := policy.Spec.AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20220501s.FrontDoorWebApplicationFirewallPolicy_STATUS
	err = policy.Status.AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (policy *WebApplicationFirewallPolicy) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: policy.Spec.OriginalVersion(),
		Kind:    "WebApplicationFirewallPolicy",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /frontdoor/resource-manager/Microsoft.Network/stable/2022-05-01/webapplicationfirewall.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}
type WebApplicationFirewallPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WebApplicationFirewallPolicy `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-05-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-05-01")

type FrontDoorWebApplicationFirewallPolicy_Spec struct {
	// +kubebuilder:validation:MaxLength=128
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CustomRules: Describes custom rules inside the policy.
	CustomRules *CustomRuleList `json:"customRules,omitempty"`

	// Etag: Gets a unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedRules: Describes managed rules inside the policy.
	ManagedRules *ManagedRuleSetList `json:"managedRules,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PolicySettings: Describes settings for the policy.
	PolicySettings *PolicySettings `json:"policySettings,omitempty"`

	// Sku: The pricing tier of web application firewall policy. Defaults to Classic_AzureFrontDoor if not specified.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &FrontDoorWebApplicationFirewallPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &FrontDoorWebApplicationFirewallPolicy_Spec_ARM{}

	// Set property "Etag":
	if policy.Etag != nil {
		etag := *policy.Etag
		result.Etag = &etag
	}

	// Set property "Location":
	if policy.Location != nil {
		location := *policy.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if policy.CustomRules != nil ||
		policy.ManagedRules != nil ||
		policy.PolicySettings != nil {
		result.Properties = &WebApplicationFirewallPolicyProperties_ARM{}
	}
	if policy.CustomRules != nil {
		customRules_ARM, err := (*policy.CustomRules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customRules := *customRules_ARM.(*CustomRuleList_ARM)
		result.Properties.CustomRules = &customRules
	}
	if policy.ManagedRules != nil {
		managedRules_ARM, err := (*policy.ManagedRules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedRules := *managedRules_ARM.(*ManagedRuleSetList_ARM)
		result.Properties.ManagedRules = &managedRules
	}
	if policy.PolicySettings != nil {
		policySettings_ARM, err := (*policy.PolicySettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		policySettings := *policySettings_ARM.(*PolicySettings_ARM)
		result.Properties.PolicySettings = &policySettings
	}

	// Set property "Sku":
	if policy.Sku != nil {
		sku_ARM, err := (*policy.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*Sku_ARM)
		result.Sku = &sku
	}

	// Set property "Tags":
	if policy.Tags != nil {
		result.Tags = make(map[string]string, len(policy.Tags))
		for key, value := range policy.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontDoorWebApplicationFirewallPolicy_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontDoorWebApplicationFirewallPolicy_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontDoorWebApplicationFirewallPolicy_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	policy.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CustomRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomRules != nil {
			var customRules1 CustomRuleList
			err := customRules1.PopulateFromARM(owner, *typedInput.Properties.CustomRules)
			if err != nil {
				return err
			}
			customRules := customRules1
			policy.CustomRules = &customRules
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		policy.Etag = &etag
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		policy.Location = &location
	}

	// Set property "ManagedRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedRules != nil {
			var managedRules1 ManagedRuleSetList
			err := managedRules1.PopulateFromARM(owner, *typedInput.Properties.ManagedRules)
			if err != nil {
				return err
			}
			managedRules := managedRules1
			policy.ManagedRules = &managedRules
		}
	}

	// Set property "Owner":
	policy.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PolicySettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PolicySettings != nil {
			var policySettings1 PolicySettings
			err := policySettings1.PopulateFromARM(owner, *typedInput.Properties.PolicySettings)
			if err != nil {
				return err
			}
			policySettings := policySettings1
			policy.PolicySettings = &policySettings
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		policy.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		policy.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			policy.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &FrontDoorWebApplicationFirewallPolicy_Spec{}

// ConvertSpecFrom populates our FrontDoorWebApplicationFirewallPolicy_Spec from the provided source
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20220501s.FrontDoorWebApplicationFirewallPolicy_Spec)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20220501s.FrontDoorWebApplicationFirewallPolicy_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our FrontDoorWebApplicationFirewallPolicy_Spec
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20220501s.FrontDoorWebApplicationFirewallPolicy_Spec)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20220501s.FrontDoorWebApplicationFirewallPolicy_Spec{}
	err := policy.AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_Spec populates our FrontDoorWebApplicationFirewallPolicy_Spec from the provided source FrontDoorWebApplicationFirewallPolicy_Spec
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_Spec(source *v20220501s.FrontDoorWebApplicationFirewallPolicy_Spec) error {

	// AzureName
	policy.AzureName = source.AzureName

	// CustomRules
	if source.CustomRules != nil {
		var customRule CustomRuleList
		err := customRule.AssignProperties_From_CustomRuleList(source.CustomRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomRuleList() to populate field CustomRules")
		}
		policy.CustomRules = &customRule
	} else {
		policy.CustomRules = nil
	}

	// Etag
	policy.Etag = genruntime.ClonePointerToString(source.Etag)

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRuleSetList
		err := managedRule.AssignProperties_From_ManagedRuleSetList(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSetList() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		policy.Owner = &owner
	} else {
		policy.Owner = nil
	}

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings
		err := policySetting.AssignProperties_From_PolicySettings(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicySettings() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_Spec populates the provided destination FrontDoorWebApplicationFirewallPolicy_Spec from our FrontDoorWebApplicationFirewallPolicy_Spec
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_Spec(destination *v20220501s.FrontDoorWebApplicationFirewallPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = policy.AzureName

	// CustomRules
	if policy.CustomRules != nil {
		var customRule v20220501s.CustomRuleList
		err := policy.CustomRules.AssignProperties_To_CustomRuleList(&customRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomRuleList() to populate field CustomRules")
		}
		destination.CustomRules = &customRule
	} else {
		destination.CustomRules = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(policy.Etag)

	// Location
	destination.Location = genruntime.ClonePointerToString(policy.Location)

	// ManagedRules
	if policy.ManagedRules != nil {
		var managedRule v20220501s.ManagedRuleSetList
		err := policy.ManagedRules.AssignProperties_To_ManagedRuleSetList(&managedRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSetList() to populate field ManagedRules")
		}
		destination.ManagedRules = &managedRule
	} else {
		destination.ManagedRules = nil
	}

	// OriginalVersion
	destination.OriginalVersion = policy.OriginalVersion()

	// Owner
	if policy.Owner != nil {
		owner := policy.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PolicySettings
	if policy.PolicySettings != nil {
		var policySetting v20220501s.PolicySettings
		err := policy.PolicySettings.AssignProperties_To_PolicySettings(&policySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicySettings() to populate field PolicySettings")
		}
		destination.PolicySettings = &policySetting
	} else {
		destination.PolicySettings = nil
	}

	// Sku
	if policy.Sku != nil {
		var sku v20220501s.Sku
		err := policy.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(policy.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FrontDoorWebApplicationFirewallPolicy_STATUS populates our FrontDoorWebApplicationFirewallPolicy_Spec from the provided source FrontDoorWebApplicationFirewallPolicy_STATUS
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) Initialize_From_FrontDoorWebApplicationFirewallPolicy_STATUS(source *FrontDoorWebApplicationFirewallPolicy_STATUS) error {

	// CustomRules
	if source.CustomRules != nil {
		var customRule CustomRuleList
		err := customRule.Initialize_From_CustomRuleList_STATUS(source.CustomRules)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CustomRuleList_STATUS() to populate field CustomRules")
		}
		policy.CustomRules = &customRule
	} else {
		policy.CustomRules = nil
	}

	// Etag
	policy.Etag = genruntime.ClonePointerToString(source.Etag)

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRuleSetList
		err := managedRule.Initialize_From_ManagedRuleSetList_STATUS(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedRuleSetList_STATUS() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings
		err := policySetting.Initialize_From_PolicySettings_STATUS(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PolicySettings_STATUS() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (policy *FrontDoorWebApplicationFirewallPolicy_Spec) SetAzureName(azureName string) {
	policy.AzureName = azureName
}

type FrontDoorWebApplicationFirewallPolicy_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomRules: Describes custom rules inside the policy.
	CustomRules *CustomRuleList_STATUS `json:"customRules,omitempty"`

	// Etag: Gets a unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FrontendEndpointLinks: Describes Frontend Endpoints associated with this Web Application Firewall policy.
	FrontendEndpointLinks []FrontendEndpointLink_STATUS `json:"frontendEndpointLinks,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedRules: Describes managed rules inside the policy.
	ManagedRules *ManagedRuleSetList_STATUS `json:"managedRules,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// PolicySettings: Describes settings for the policy.
	PolicySettings *PolicySettings_STATUS `json:"policySettings,omitempty"`

	// ProvisioningState: Provisioning state of the policy.
	ProvisioningState *string                                                      `json:"provisioningState,omitempty"`
	ResourceState     *WebApplicationFirewallPolicyProperties_ResourceState_STATUS `json:"resourceState,omitempty"`

	// RoutingRuleLinks: Describes Routing Rules associated with this Web Application Firewall policy.
	RoutingRuleLinks []RoutingRuleLink_STATUS `json:"routingRuleLinks,omitempty"`

	// SecurityPolicyLinks: Describes Security Policy associated with this Web Application Firewall policy.
	SecurityPolicyLinks []SecurityPolicyLink_STATUS `json:"securityPolicyLinks,omitempty"`

	// Sku: The pricing tier of web application firewall policy. Defaults to Classic_AzureFrontDoor if not specified.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &FrontDoorWebApplicationFirewallPolicy_STATUS{}

// ConvertStatusFrom populates our FrontDoorWebApplicationFirewallPolicy_STATUS from the provided source
func (policy *FrontDoorWebApplicationFirewallPolicy_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20220501s.FrontDoorWebApplicationFirewallPolicy_STATUS)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20220501s.FrontDoorWebApplicationFirewallPolicy_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our FrontDoorWebApplicationFirewallPolicy_STATUS
func (policy *FrontDoorWebApplicationFirewallPolicy_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20220501s.FrontDoorWebApplicationFirewallPolicy_STATUS)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20220501s.FrontDoorWebApplicationFirewallPolicy_STATUS{}
	err := policy.AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &FrontDoorWebApplicationFirewallPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *FrontDoorWebApplicationFirewallPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontDoorWebApplicationFirewallPolicy_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *FrontDoorWebApplicationFirewallPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontDoorWebApplicationFirewallPolicy_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontDoorWebApplicationFirewallPolicy_STATUS_ARM, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "CustomRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomRules != nil {
			var customRules1 CustomRuleList_STATUS
			err := customRules1.PopulateFromARM(owner, *typedInput.Properties.CustomRules)
			if err != nil {
				return err
			}
			customRules := customRules1
			policy.CustomRules = &customRules
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		policy.Etag = &etag
	}

	// Set property "FrontendEndpointLinks":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendEndpointLinks {
			var item1 FrontendEndpointLink_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.FrontendEndpointLinks = append(policy.FrontendEndpointLinks, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		policy.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		policy.Location = &location
	}

	// Set property "ManagedRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedRules != nil {
			var managedRules1 ManagedRuleSetList_STATUS
			err := managedRules1.PopulateFromARM(owner, *typedInput.Properties.ManagedRules)
			if err != nil {
				return err
			}
			managedRules := managedRules1
			policy.ManagedRules = &managedRules
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		policy.Name = &name
	}

	// Set property "PolicySettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PolicySettings != nil {
			var policySettings1 PolicySettings_STATUS
			err := policySettings1.PopulateFromARM(owner, *typedInput.Properties.PolicySettings)
			if err != nil {
				return err
			}
			policySettings := policySettings1
			policy.PolicySettings = &policySettings
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			policy.ProvisioningState = &provisioningState
		}
	}

	// Set property "ResourceState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			resourceState := *typedInput.Properties.ResourceState
			policy.ResourceState = &resourceState
		}
	}

	// Set property "RoutingRuleLinks":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RoutingRuleLinks {
			var item1 RoutingRuleLink_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.RoutingRuleLinks = append(policy.RoutingRuleLinks, item1)
		}
	}

	// Set property "SecurityPolicyLinks":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SecurityPolicyLinks {
			var item1 SecurityPolicyLink_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.SecurityPolicyLinks = append(policy.SecurityPolicyLinks, item1)
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		policy.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		policy.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			policy.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		policy.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_STATUS populates our FrontDoorWebApplicationFirewallPolicy_STATUS from the provided source FrontDoorWebApplicationFirewallPolicy_STATUS
func (policy *FrontDoorWebApplicationFirewallPolicy_STATUS) AssignProperties_From_FrontDoorWebApplicationFirewallPolicy_STATUS(source *v20220501s.FrontDoorWebApplicationFirewallPolicy_STATUS) error {

	// Conditions
	policy.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomRules
	if source.CustomRules != nil {
		var customRule CustomRuleList_STATUS
		err := customRule.AssignProperties_From_CustomRuleList_STATUS(source.CustomRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomRuleList_STATUS() to populate field CustomRules")
		}
		policy.CustomRules = &customRule
	} else {
		policy.CustomRules = nil
	}

	// Etag
	policy.Etag = genruntime.ClonePointerToString(source.Etag)

	// FrontendEndpointLinks
	if source.FrontendEndpointLinks != nil {
		frontendEndpointLinkList := make([]FrontendEndpointLink_STATUS, len(source.FrontendEndpointLinks))
		for frontendEndpointLinkIndex, frontendEndpointLinkItem := range source.FrontendEndpointLinks {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointLinkItem := frontendEndpointLinkItem
			var frontendEndpointLink FrontendEndpointLink_STATUS
			err := frontendEndpointLink.AssignProperties_From_FrontendEndpointLink_STATUS(&frontendEndpointLinkItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_FrontendEndpointLink_STATUS() to populate field FrontendEndpointLinks")
			}
			frontendEndpointLinkList[frontendEndpointLinkIndex] = frontendEndpointLink
		}
		policy.FrontendEndpointLinks = frontendEndpointLinkList
	} else {
		policy.FrontendEndpointLinks = nil
	}

	// Id
	policy.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRuleSetList_STATUS
		err := managedRule.AssignProperties_From_ManagedRuleSetList_STATUS(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSetList_STATUS() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// Name
	policy.Name = genruntime.ClonePointerToString(source.Name)

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings_STATUS
		err := policySetting.AssignProperties_From_PolicySettings_STATUS(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicySettings_STATUS() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// ProvisioningState
	policy.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ResourceState
	if source.ResourceState != nil {
		resourceState := *source.ResourceState
		resourceStateTemp := genruntime.ToEnum(resourceState, webApplicationFirewallPolicyProperties_ResourceState_STATUS_Values)
		policy.ResourceState = &resourceStateTemp
	} else {
		policy.ResourceState = nil
	}

	// RoutingRuleLinks
	if source.RoutingRuleLinks != nil {
		routingRuleLinkList := make([]RoutingRuleLink_STATUS, len(source.RoutingRuleLinks))
		for routingRuleLinkIndex, routingRuleLinkItem := range source.RoutingRuleLinks {
			// Shadow the loop variable to avoid aliasing
			routingRuleLinkItem := routingRuleLinkItem
			var routingRuleLink RoutingRuleLink_STATUS
			err := routingRuleLink.AssignProperties_From_RoutingRuleLink_STATUS(&routingRuleLinkItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RoutingRuleLink_STATUS() to populate field RoutingRuleLinks")
			}
			routingRuleLinkList[routingRuleLinkIndex] = routingRuleLink
		}
		policy.RoutingRuleLinks = routingRuleLinkList
	} else {
		policy.RoutingRuleLinks = nil
	}

	// SecurityPolicyLinks
	if source.SecurityPolicyLinks != nil {
		securityPolicyLinkList := make([]SecurityPolicyLink_STATUS, len(source.SecurityPolicyLinks))
		for securityPolicyLinkIndex, securityPolicyLinkItem := range source.SecurityPolicyLinks {
			// Shadow the loop variable to avoid aliasing
			securityPolicyLinkItem := securityPolicyLinkItem
			var securityPolicyLink SecurityPolicyLink_STATUS
			err := securityPolicyLink.AssignProperties_From_SecurityPolicyLink_STATUS(&securityPolicyLinkItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SecurityPolicyLink_STATUS() to populate field SecurityPolicyLinks")
			}
			securityPolicyLinkList[securityPolicyLinkIndex] = securityPolicyLink
		}
		policy.SecurityPolicyLinks = securityPolicyLinkList
	} else {
		policy.SecurityPolicyLinks = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	policy.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_STATUS populates the provided destination FrontDoorWebApplicationFirewallPolicy_STATUS from our FrontDoorWebApplicationFirewallPolicy_STATUS
func (policy *FrontDoorWebApplicationFirewallPolicy_STATUS) AssignProperties_To_FrontDoorWebApplicationFirewallPolicy_STATUS(destination *v20220501s.FrontDoorWebApplicationFirewallPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(policy.Conditions)

	// CustomRules
	if policy.CustomRules != nil {
		var customRule v20220501s.CustomRuleList_STATUS
		err := policy.CustomRules.AssignProperties_To_CustomRuleList_STATUS(&customRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomRuleList_STATUS() to populate field CustomRules")
		}
		destination.CustomRules = &customRule
	} else {
		destination.CustomRules = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(policy.Etag)

	// FrontendEndpointLinks
	if policy.FrontendEndpointLinks != nil {
		frontendEndpointLinkList := make([]v20220501s.FrontendEndpointLink_STATUS, len(policy.FrontendEndpointLinks))
		for frontendEndpointLinkIndex, frontendEndpointLinkItem := range policy.FrontendEndpointLinks {
			// Shadow the loop variable to avoid aliasing
			frontendEndpointLinkItem := frontendEndpointLinkItem
			var frontendEndpointLink v20220501s.FrontendEndpointLink_STATUS
			err := frontendEndpointLinkItem.AssignProperties_To_FrontendEndpointLink_STATUS(&frontendEndpointLink)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_FrontendEndpointLink_STATUS() to populate field FrontendEndpointLinks")
			}
			frontendEndpointLinkList[frontendEndpointLinkIndex] = frontendEndpointLink
		}
		destination.FrontendEndpointLinks = frontendEndpointLinkList
	} else {
		destination.FrontendEndpointLinks = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(policy.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(policy.Location)

	// ManagedRules
	if policy.ManagedRules != nil {
		var managedRule v20220501s.ManagedRuleSetList_STATUS
		err := policy.ManagedRules.AssignProperties_To_ManagedRuleSetList_STATUS(&managedRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSetList_STATUS() to populate field ManagedRules")
		}
		destination.ManagedRules = &managedRule
	} else {
		destination.ManagedRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(policy.Name)

	// PolicySettings
	if policy.PolicySettings != nil {
		var policySetting v20220501s.PolicySettings_STATUS
		err := policy.PolicySettings.AssignProperties_To_PolicySettings_STATUS(&policySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicySettings_STATUS() to populate field PolicySettings")
		}
		destination.PolicySettings = &policySetting
	} else {
		destination.PolicySettings = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(policy.ProvisioningState)

	// ResourceState
	if policy.ResourceState != nil {
		resourceState := string(*policy.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// RoutingRuleLinks
	if policy.RoutingRuleLinks != nil {
		routingRuleLinkList := make([]v20220501s.RoutingRuleLink_STATUS, len(policy.RoutingRuleLinks))
		for routingRuleLinkIndex, routingRuleLinkItem := range policy.RoutingRuleLinks {
			// Shadow the loop variable to avoid aliasing
			routingRuleLinkItem := routingRuleLinkItem
			var routingRuleLink v20220501s.RoutingRuleLink_STATUS
			err := routingRuleLinkItem.AssignProperties_To_RoutingRuleLink_STATUS(&routingRuleLink)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RoutingRuleLink_STATUS() to populate field RoutingRuleLinks")
			}
			routingRuleLinkList[routingRuleLinkIndex] = routingRuleLink
		}
		destination.RoutingRuleLinks = routingRuleLinkList
	} else {
		destination.RoutingRuleLinks = nil
	}

	// SecurityPolicyLinks
	if policy.SecurityPolicyLinks != nil {
		securityPolicyLinkList := make([]v20220501s.SecurityPolicyLink_STATUS, len(policy.SecurityPolicyLinks))
		for securityPolicyLinkIndex, securityPolicyLinkItem := range policy.SecurityPolicyLinks {
			// Shadow the loop variable to avoid aliasing
			securityPolicyLinkItem := securityPolicyLinkItem
			var securityPolicyLink v20220501s.SecurityPolicyLink_STATUS
			err := securityPolicyLinkItem.AssignProperties_To_SecurityPolicyLink_STATUS(&securityPolicyLink)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SecurityPolicyLink_STATUS() to populate field SecurityPolicyLinks")
			}
			securityPolicyLinkList[securityPolicyLinkIndex] = securityPolicyLink
		}
		destination.SecurityPolicyLinks = securityPolicyLinkList
	} else {
		destination.SecurityPolicyLinks = nil
	}

	// Sku
	if policy.Sku != nil {
		var sku v20220501s.Sku_STATUS
		err := policy.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(policy.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(policy.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines contents of custom rules
type CustomRuleList struct {
	// Rules: List of rules
	Rules []CustomRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomRuleList{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (list *CustomRuleList) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if list == nil {
		return nil, nil
	}
	result := &CustomRuleList_ARM{}

	// Set property "Rules":
	for _, item := range list.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*CustomRule_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *CustomRuleList) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomRuleList_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *CustomRuleList) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomRuleList_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomRuleList_ARM, got %T", armInput)
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 CustomRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.Rules = append(list.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CustomRuleList populates our CustomRuleList from the provided source CustomRuleList
func (list *CustomRuleList) AssignProperties_From_CustomRuleList(source *v20220501s.CustomRuleList) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]CustomRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CustomRule
			err := rule.AssignProperties_From_CustomRule(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_CustomRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		list.Rules = ruleList
	} else {
		list.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomRuleList populates the provided destination CustomRuleList from our CustomRuleList
func (list *CustomRuleList) AssignProperties_To_CustomRuleList(destination *v20220501s.CustomRuleList) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if list.Rules != nil {
		ruleList := make([]v20220501s.CustomRule, len(list.Rules))
		for ruleIndex, ruleItem := range list.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20220501s.CustomRule
			err := ruleItem.AssignProperties_To_CustomRule(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_CustomRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomRuleList_STATUS populates our CustomRuleList from the provided source CustomRuleList_STATUS
func (list *CustomRuleList) Initialize_From_CustomRuleList_STATUS(source *CustomRuleList_STATUS) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]CustomRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CustomRule
			err := rule.Initialize_From_CustomRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_CustomRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		list.Rules = ruleList
	} else {
		list.Rules = nil
	}

	// No error
	return nil
}

// Defines contents of custom rules
type CustomRuleList_STATUS struct {
	// Rules: List of rules
	Rules []CustomRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomRuleList_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *CustomRuleList_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomRuleList_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *CustomRuleList_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomRuleList_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomRuleList_STATUS_ARM, got %T", armInput)
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 CustomRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.Rules = append(list.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CustomRuleList_STATUS populates our CustomRuleList_STATUS from the provided source CustomRuleList_STATUS
func (list *CustomRuleList_STATUS) AssignProperties_From_CustomRuleList_STATUS(source *v20220501s.CustomRuleList_STATUS) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]CustomRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CustomRule_STATUS
			err := rule.AssignProperties_From_CustomRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_CustomRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		list.Rules = ruleList
	} else {
		list.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomRuleList_STATUS populates the provided destination CustomRuleList_STATUS from our CustomRuleList_STATUS
func (list *CustomRuleList_STATUS) AssignProperties_To_CustomRuleList_STATUS(destination *v20220501s.CustomRuleList_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if list.Rules != nil {
		ruleList := make([]v20220501s.CustomRule_STATUS, len(list.Rules))
		for ruleIndex, ruleItem := range list.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20220501s.CustomRule_STATUS
			err := ruleItem.AssignProperties_To_CustomRule_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_CustomRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the Resource ID for a Frontend Endpoint.
type FrontendEndpointLink_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &FrontendEndpointLink_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *FrontendEndpointLink_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendEndpointLink_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *FrontendEndpointLink_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendEndpointLink_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendEndpointLink_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_FrontendEndpointLink_STATUS populates our FrontendEndpointLink_STATUS from the provided source FrontendEndpointLink_STATUS
func (link *FrontendEndpointLink_STATUS) AssignProperties_From_FrontendEndpointLink_STATUS(source *v20220501s.FrontendEndpointLink_STATUS) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_FrontendEndpointLink_STATUS populates the provided destination FrontendEndpointLink_STATUS from our FrontendEndpointLink_STATUS
func (link *FrontendEndpointLink_STATUS) AssignProperties_To_FrontendEndpointLink_STATUS(destination *v20220501s.FrontendEndpointLink_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the list of managed rule sets for the policy.
type ManagedRuleSetList struct {
	// ManagedRuleSets: List of rule sets.
	ManagedRuleSets []ManagedRuleSet `json:"managedRuleSets,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleSetList{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (list *ManagedRuleSetList) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if list == nil {
		return nil, nil
	}
	result := &ManagedRuleSetList_ARM{}

	// Set property "ManagedRuleSets":
	for _, item := range list.ManagedRuleSets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ManagedRuleSets = append(result.ManagedRuleSets, *item_ARM.(*ManagedRuleSet_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *ManagedRuleSetList) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleSetList_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *ManagedRuleSetList) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleSetList_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleSetList_ARM, got %T", armInput)
	}

	// Set property "ManagedRuleSets":
	for _, item := range typedInput.ManagedRuleSets {
		var item1 ManagedRuleSet
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.ManagedRuleSets = append(list.ManagedRuleSets, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSetList populates our ManagedRuleSetList from the provided source ManagedRuleSetList
func (list *ManagedRuleSetList) AssignProperties_From_ManagedRuleSetList(source *v20220501s.ManagedRuleSetList) error {

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet
			err := managedRuleSet.AssignProperties_From_ManagedRuleSet(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSet() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		list.ManagedRuleSets = managedRuleSetList
	} else {
		list.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSetList populates the provided destination ManagedRuleSetList from our ManagedRuleSetList
func (list *ManagedRuleSetList) AssignProperties_To_ManagedRuleSetList(destination *v20220501s.ManagedRuleSetList) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ManagedRuleSets
	if list.ManagedRuleSets != nil {
		managedRuleSetList := make([]v20220501s.ManagedRuleSet, len(list.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range list.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet v20220501s.ManagedRuleSet
			err := managedRuleSetItem.AssignProperties_To_ManagedRuleSet(&managedRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSet() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		destination.ManagedRuleSets = managedRuleSetList
	} else {
		destination.ManagedRuleSets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleSetList_STATUS populates our ManagedRuleSetList from the provided source ManagedRuleSetList_STATUS
func (list *ManagedRuleSetList) Initialize_From_ManagedRuleSetList_STATUS(source *ManagedRuleSetList_STATUS) error {

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet
			err := managedRuleSet.Initialize_From_ManagedRuleSet_STATUS(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		list.ManagedRuleSets = managedRuleSetList
	} else {
		list.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// Defines the list of managed rule sets for the policy.
type ManagedRuleSetList_STATUS struct {
	// ManagedRuleSets: List of rule sets.
	ManagedRuleSets []ManagedRuleSet_STATUS `json:"managedRuleSets,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleSetList_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *ManagedRuleSetList_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleSetList_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *ManagedRuleSetList_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleSetList_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleSetList_STATUS_ARM, got %T", armInput)
	}

	// Set property "ManagedRuleSets":
	for _, item := range typedInput.ManagedRuleSets {
		var item1 ManagedRuleSet_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.ManagedRuleSets = append(list.ManagedRuleSets, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSetList_STATUS populates our ManagedRuleSetList_STATUS from the provided source ManagedRuleSetList_STATUS
func (list *ManagedRuleSetList_STATUS) AssignProperties_From_ManagedRuleSetList_STATUS(source *v20220501s.ManagedRuleSetList_STATUS) error {

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet_STATUS, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet_STATUS
			err := managedRuleSet.AssignProperties_From_ManagedRuleSet_STATUS(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		list.ManagedRuleSets = managedRuleSetList
	} else {
		list.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSetList_STATUS populates the provided destination ManagedRuleSetList_STATUS from our ManagedRuleSetList_STATUS
func (list *ManagedRuleSetList_STATUS) AssignProperties_To_ManagedRuleSetList_STATUS(destination *v20220501s.ManagedRuleSetList_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ManagedRuleSets
	if list.ManagedRuleSets != nil {
		managedRuleSetList := make([]v20220501s.ManagedRuleSet_STATUS, len(list.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range list.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet v20220501s.ManagedRuleSet_STATUS
			err := managedRuleSetItem.AssignProperties_To_ManagedRuleSet_STATUS(&managedRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		destination.ManagedRuleSets = managedRuleSetList
	} else {
		destination.ManagedRuleSets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines top-level WebApplicationFirewallPolicy configuration settings.
type PolicySettings struct {
	// +kubebuilder:validation:Pattern="^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$"
	// CustomBlockResponseBody: If the action type is block, customer can override the response body. The body must be
	// specified in base64 encoding.
	CustomBlockResponseBody *string `json:"customBlockResponseBody,omitempty"`

	// CustomBlockResponseStatusCode: If the action type is block, customer can override the response status code.
	CustomBlockResponseStatusCode *int `json:"customBlockResponseStatusCode,omitempty"`

	// EnabledState: Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *PolicySettings_EnabledState `json:"enabledState,omitempty"`

	// Mode: Describes if it is in detection mode or prevention mode at policy level.
	Mode *PolicySettings_Mode `json:"mode,omitempty"`

	// RedirectUrl: If action type is redirect, this field represents redirect URL for the client.
	RedirectUrl *string `json:"redirectUrl,omitempty"`

	// RequestBodyCheck: Describes if policy managed rules will inspect the request body content.
	RequestBodyCheck *PolicySettings_RequestBodyCheck `json:"requestBodyCheck,omitempty"`
}

var _ genruntime.ARMTransformer = &PolicySettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PolicySettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &PolicySettings_ARM{}

	// Set property "CustomBlockResponseBody":
	if settings.CustomBlockResponseBody != nil {
		customBlockResponseBody := *settings.CustomBlockResponseBody
		result.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if settings.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *settings.CustomBlockResponseStatusCode
		result.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "EnabledState":
	if settings.EnabledState != nil {
		enabledState := *settings.EnabledState
		result.EnabledState = &enabledState
	}

	// Set property "Mode":
	if settings.Mode != nil {
		mode := *settings.Mode
		result.Mode = &mode
	}

	// Set property "RedirectUrl":
	if settings.RedirectUrl != nil {
		redirectUrl := *settings.RedirectUrl
		result.RedirectUrl = &redirectUrl
	}

	// Set property "RequestBodyCheck":
	if settings.RequestBodyCheck != nil {
		requestBodyCheck := *settings.RequestBodyCheck
		result.RequestBodyCheck = &requestBodyCheck
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PolicySettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PolicySettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PolicySettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PolicySettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PolicySettings_ARM, got %T", armInput)
	}

	// Set property "CustomBlockResponseBody":
	if typedInput.CustomBlockResponseBody != nil {
		customBlockResponseBody := *typedInput.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if typedInput.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *typedInput.CustomBlockResponseStatusCode
		settings.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		enabledState := *typedInput.EnabledState
		settings.EnabledState = &enabledState
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		settings.Mode = &mode
	}

	// Set property "RedirectUrl":
	if typedInput.RedirectUrl != nil {
		redirectUrl := *typedInput.RedirectUrl
		settings.RedirectUrl = &redirectUrl
	}

	// Set property "RequestBodyCheck":
	if typedInput.RequestBodyCheck != nil {
		requestBodyCheck := *typedInput.RequestBodyCheck
		settings.RequestBodyCheck = &requestBodyCheck
	}

	// No error
	return nil
}

// AssignProperties_From_PolicySettings populates our PolicySettings from the provided source PolicySettings
func (settings *PolicySettings) AssignProperties_From_PolicySettings(source *v20220501s.PolicySettings) error {

	// CustomBlockResponseBody
	if source.CustomBlockResponseBody != nil {
		customBlockResponseBody := *source.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		settings.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	settings.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(source.CustomBlockResponseStatusCode)

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, policySettings_EnabledState_Values)
		settings.EnabledState = &enabledStateTemp
	} else {
		settings.EnabledState = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, policySettings_Mode_Values)
		settings.Mode = &modeTemp
	} else {
		settings.Mode = nil
	}

	// RedirectUrl
	settings.RedirectUrl = genruntime.ClonePointerToString(source.RedirectUrl)

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		requestBodyCheckTemp := genruntime.ToEnum(requestBodyCheck, policySettings_RequestBodyCheck_Values)
		settings.RequestBodyCheck = &requestBodyCheckTemp
	} else {
		settings.RequestBodyCheck = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicySettings populates the provided destination PolicySettings from our PolicySettings
func (settings *PolicySettings) AssignProperties_To_PolicySettings(destination *v20220501s.PolicySettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomBlockResponseBody
	if settings.CustomBlockResponseBody != nil {
		customBlockResponseBody := *settings.CustomBlockResponseBody
		destination.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		destination.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	destination.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(settings.CustomBlockResponseStatusCode)

	// EnabledState
	if settings.EnabledState != nil {
		enabledState := string(*settings.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// Mode
	if settings.Mode != nil {
		mode := string(*settings.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RedirectUrl
	destination.RedirectUrl = genruntime.ClonePointerToString(settings.RedirectUrl)

	// RequestBodyCheck
	if settings.RequestBodyCheck != nil {
		requestBodyCheck := string(*settings.RequestBodyCheck)
		destination.RequestBodyCheck = &requestBodyCheck
	} else {
		destination.RequestBodyCheck = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PolicySettings_STATUS populates our PolicySettings from the provided source PolicySettings_STATUS
func (settings *PolicySettings) Initialize_From_PolicySettings_STATUS(source *PolicySettings_STATUS) error {

	// CustomBlockResponseBody
	if source.CustomBlockResponseBody != nil {
		customBlockResponseBody := *source.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		settings.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	settings.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(source.CustomBlockResponseStatusCode)

	// EnabledState
	if source.EnabledState != nil {
		enabledState := PolicySettings_EnabledState(*source.EnabledState)
		settings.EnabledState = &enabledState
	} else {
		settings.EnabledState = nil
	}

	// Mode
	if source.Mode != nil {
		mode := PolicySettings_Mode(*source.Mode)
		settings.Mode = &mode
	} else {
		settings.Mode = nil
	}

	// RedirectUrl
	settings.RedirectUrl = genruntime.ClonePointerToString(source.RedirectUrl)

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := PolicySettings_RequestBodyCheck(*source.RequestBodyCheck)
		settings.RequestBodyCheck = &requestBodyCheck
	} else {
		settings.RequestBodyCheck = nil
	}

	// No error
	return nil
}

// Defines top-level WebApplicationFirewallPolicy configuration settings.
type PolicySettings_STATUS struct {
	// CustomBlockResponseBody: If the action type is block, customer can override the response body. The body must be
	// specified in base64 encoding.
	CustomBlockResponseBody *string `json:"customBlockResponseBody,omitempty"`

	// CustomBlockResponseStatusCode: If the action type is block, customer can override the response status code.
	CustomBlockResponseStatusCode *int `json:"customBlockResponseStatusCode,omitempty"`

	// EnabledState: Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *PolicySettings_EnabledState_STATUS `json:"enabledState,omitempty"`

	// Mode: Describes if it is in detection mode or prevention mode at policy level.
	Mode *PolicySettings_Mode_STATUS `json:"mode,omitempty"`

	// RedirectUrl: If action type is redirect, this field represents redirect URL for the client.
	RedirectUrl *string `json:"redirectUrl,omitempty"`

	// RequestBodyCheck: Describes if policy managed rules will inspect the request body content.
	RequestBodyCheck *PolicySettings_RequestBodyCheck_STATUS `json:"requestBodyCheck,omitempty"`
}

var _ genruntime.FromARMConverter = &PolicySettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PolicySettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PolicySettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PolicySettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PolicySettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PolicySettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "CustomBlockResponseBody":
	if typedInput.CustomBlockResponseBody != nil {
		customBlockResponseBody := *typedInput.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if typedInput.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *typedInput.CustomBlockResponseStatusCode
		settings.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		enabledState := *typedInput.EnabledState
		settings.EnabledState = &enabledState
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		settings.Mode = &mode
	}

	// Set property "RedirectUrl":
	if typedInput.RedirectUrl != nil {
		redirectUrl := *typedInput.RedirectUrl
		settings.RedirectUrl = &redirectUrl
	}

	// Set property "RequestBodyCheck":
	if typedInput.RequestBodyCheck != nil {
		requestBodyCheck := *typedInput.RequestBodyCheck
		settings.RequestBodyCheck = &requestBodyCheck
	}

	// No error
	return nil
}

// AssignProperties_From_PolicySettings_STATUS populates our PolicySettings_STATUS from the provided source PolicySettings_STATUS
func (settings *PolicySettings_STATUS) AssignProperties_From_PolicySettings_STATUS(source *v20220501s.PolicySettings_STATUS) error {

	// CustomBlockResponseBody
	settings.CustomBlockResponseBody = genruntime.ClonePointerToString(source.CustomBlockResponseBody)

	// CustomBlockResponseStatusCode
	settings.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(source.CustomBlockResponseStatusCode)

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, policySettings_EnabledState_STATUS_Values)
		settings.EnabledState = &enabledStateTemp
	} else {
		settings.EnabledState = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, policySettings_Mode_STATUS_Values)
		settings.Mode = &modeTemp
	} else {
		settings.Mode = nil
	}

	// RedirectUrl
	settings.RedirectUrl = genruntime.ClonePointerToString(source.RedirectUrl)

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		requestBodyCheckTemp := genruntime.ToEnum(requestBodyCheck, policySettings_RequestBodyCheck_STATUS_Values)
		settings.RequestBodyCheck = &requestBodyCheckTemp
	} else {
		settings.RequestBodyCheck = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicySettings_STATUS populates the provided destination PolicySettings_STATUS from our PolicySettings_STATUS
func (settings *PolicySettings_STATUS) AssignProperties_To_PolicySettings_STATUS(destination *v20220501s.PolicySettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomBlockResponseBody
	destination.CustomBlockResponseBody = genruntime.ClonePointerToString(settings.CustomBlockResponseBody)

	// CustomBlockResponseStatusCode
	destination.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(settings.CustomBlockResponseStatusCode)

	// EnabledState
	if settings.EnabledState != nil {
		enabledState := string(*settings.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// Mode
	if settings.Mode != nil {
		mode := string(*settings.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RedirectUrl
	destination.RedirectUrl = genruntime.ClonePointerToString(settings.RedirectUrl)

	// RequestBodyCheck
	if settings.RequestBodyCheck != nil {
		requestBodyCheck := string(*settings.RequestBodyCheck)
		destination.RequestBodyCheck = &requestBodyCheck
	} else {
		destination.RequestBodyCheck = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the Resource ID for a Routing Rule.
type RoutingRuleLink_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingRuleLink_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *RoutingRuleLink_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RoutingRuleLink_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *RoutingRuleLink_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RoutingRuleLink_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RoutingRuleLink_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingRuleLink_STATUS populates our RoutingRuleLink_STATUS from the provided source RoutingRuleLink_STATUS
func (link *RoutingRuleLink_STATUS) AssignProperties_From_RoutingRuleLink_STATUS(source *v20220501s.RoutingRuleLink_STATUS) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_RoutingRuleLink_STATUS populates the provided destination RoutingRuleLink_STATUS from our RoutingRuleLink_STATUS
func (link *RoutingRuleLink_STATUS) AssignProperties_To_RoutingRuleLink_STATUS(destination *v20220501s.RoutingRuleLink_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the Resource ID for a Security Policy.
type SecurityPolicyLink_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SecurityPolicyLink_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *SecurityPolicyLink_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecurityPolicyLink_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *SecurityPolicyLink_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecurityPolicyLink_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecurityPolicyLink_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SecurityPolicyLink_STATUS populates our SecurityPolicyLink_STATUS from the provided source SecurityPolicyLink_STATUS
func (link *SecurityPolicyLink_STATUS) AssignProperties_From_SecurityPolicyLink_STATUS(source *v20220501s.SecurityPolicyLink_STATUS) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SecurityPolicyLink_STATUS populates the provided destination SecurityPolicyLink_STATUS from our SecurityPolicyLink_STATUS
func (link *SecurityPolicyLink_STATUS) AssignProperties_To_SecurityPolicyLink_STATUS(destination *v20220501s.SecurityPolicyLink_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The pricing tier of the web application firewall policy.
type Sku struct {
	// Name: Name of the pricing tier.
	Name *Sku_Name `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &Sku_ARM{}

	// Set property "Name":
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *v20220501s.Sku) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, sku_Name_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *v20220501s.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Name
	if source.Name != nil {
		name := Sku_Name(*source.Name)
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// The pricing tier of the web application firewall policy.
type Sku_STATUS struct {
	// Name: Name of the pricing tier.
	Name *Sku_Name_STATUS `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *v20220501s.Sku_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, sku_Name_STATUS_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *v20220501s.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines contents of a web application rule
type CustomRule struct {
	// +kubebuilder:validation:Required
	// Action: Describes what action to be applied when rule matches.
	Action *ActionType `json:"action,omitempty"`

	// EnabledState: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *CustomRule_EnabledState `json:"enabledState,omitempty"`

	// +kubebuilder:validation:Required
	// MatchConditions: List of match conditions.
	MatchConditions []MatchCondition `json:"matchConditions,omitempty"`

	// +kubebuilder:validation:MaxLength=128
	// Name: Describes the name of the rule.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Priority: Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
	Priority *int `json:"priority,omitempty"`

	// +kubebuilder:validation:Maximum=5
	// +kubebuilder:validation:Minimum=0
	// RateLimitDurationInMinutes: Time window for resetting the rate limit count. Default is 1 minute.
	RateLimitDurationInMinutes *int `json:"rateLimitDurationInMinutes,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// RateLimitThreshold: Number of allowed requests per client within the time window.
	RateLimitThreshold *int `json:"rateLimitThreshold,omitempty"`

	// +kubebuilder:validation:Required
	// RuleType: Describes type of rule.
	RuleType *CustomRule_RuleType `json:"ruleType,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *CustomRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &CustomRule_ARM{}

	// Set property "Action":
	if rule.Action != nil {
		action := *rule.Action
		result.Action = &action
	}

	// Set property "EnabledState":
	if rule.EnabledState != nil {
		enabledState := *rule.EnabledState
		result.EnabledState = &enabledState
	}

	// Set property "MatchConditions":
	for _, item := range rule.MatchConditions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.MatchConditions = append(result.MatchConditions, *item_ARM.(*MatchCondition_ARM))
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Priority":
	if rule.Priority != nil {
		priority := *rule.Priority
		result.Priority = &priority
	}

	// Set property "RateLimitDurationInMinutes":
	if rule.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinutes := *rule.RateLimitDurationInMinutes
		result.RateLimitDurationInMinutes = &rateLimitDurationInMinutes
	}

	// Set property "RateLimitThreshold":
	if rule.RateLimitThreshold != nil {
		rateLimitThreshold := *rule.RateLimitThreshold
		result.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if rule.RuleType != nil {
		ruleType := *rule.RuleType
		result.RuleType = &ruleType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *CustomRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *CustomRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomRule_ARM, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		action := *typedInput.Action
		rule.Action = &action
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		enabledState := *typedInput.EnabledState
		rule.EnabledState = &enabledState
	}

	// Set property "MatchConditions":
	for _, item := range typedInput.MatchConditions {
		var item1 MatchCondition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.MatchConditions = append(rule.MatchConditions, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		rule.Priority = &priority
	}

	// Set property "RateLimitDurationInMinutes":
	if typedInput.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinutes := *typedInput.RateLimitDurationInMinutes
		rule.RateLimitDurationInMinutes = &rateLimitDurationInMinutes
	}

	// Set property "RateLimitThreshold":
	if typedInput.RateLimitThreshold != nil {
		rateLimitThreshold := *typedInput.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if typedInput.RuleType != nil {
		ruleType := *typedInput.RuleType
		rule.RuleType = &ruleType
	}

	// No error
	return nil
}

// AssignProperties_From_CustomRule populates our CustomRule from the provided source CustomRule
func (rule *CustomRule) AssignProperties_From_CustomRule(source *v20220501s.CustomRule) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, customRule_EnabledState_Values)
		rule.EnabledState = &enabledStateTemp
	} else {
		rule.EnabledState = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition
			err := matchCondition.AssignProperties_From_MatchCondition(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MatchCondition() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		rule.Name = &name
	} else {
		rule.Name = nil
	}

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDurationInMinutes
	if source.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinute := *source.RateLimitDurationInMinutes
		rule.RateLimitDurationInMinutes = &rateLimitDurationInMinute
	} else {
		rule.RateLimitDurationInMinutes = nil
	}

	// RateLimitThreshold
	if source.RateLimitThreshold != nil {
		rateLimitThreshold := *source.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	} else {
		rule.RateLimitThreshold = nil
	}

	// RuleType
	if source.RuleType != nil {
		ruleType := *source.RuleType
		ruleTypeTemp := genruntime.ToEnum(ruleType, customRule_RuleType_Values)
		rule.RuleType = &ruleTypeTemp
	} else {
		rule.RuleType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomRule populates the provided destination CustomRule from our CustomRule
func (rule *CustomRule) AssignProperties_To_CustomRule(destination *v20220501s.CustomRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// EnabledState
	if rule.EnabledState != nil {
		enabledState := string(*rule.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// MatchConditions
	if rule.MatchConditions != nil {
		matchConditionList := make([]v20220501s.MatchCondition, len(rule.MatchConditions))
		for matchConditionIndex, matchConditionItem := range rule.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition v20220501s.MatchCondition
			err := matchConditionItem.AssignProperties_To_MatchCondition(&matchCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MatchCondition() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		destination.MatchConditions = matchConditionList
	} else {
		destination.MatchConditions = nil
	}

	// Name
	if rule.Name != nil {
		name := *rule.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(rule.Priority)

	// RateLimitDurationInMinutes
	if rule.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinute := *rule.RateLimitDurationInMinutes
		destination.RateLimitDurationInMinutes = &rateLimitDurationInMinute
	} else {
		destination.RateLimitDurationInMinutes = nil
	}

	// RateLimitThreshold
	if rule.RateLimitThreshold != nil {
		rateLimitThreshold := *rule.RateLimitThreshold
		destination.RateLimitThreshold = &rateLimitThreshold
	} else {
		destination.RateLimitThreshold = nil
	}

	// RuleType
	if rule.RuleType != nil {
		ruleType := string(*rule.RuleType)
		destination.RuleType = &ruleType
	} else {
		destination.RuleType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomRule_STATUS populates our CustomRule from the provided source CustomRule_STATUS
func (rule *CustomRule) Initialize_From_CustomRule_STATUS(source *CustomRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := ActionType(*source.Action)
		rule.Action = &action
	} else {
		rule.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := CustomRule_EnabledState(*source.EnabledState)
		rule.EnabledState = &enabledState
	} else {
		rule.EnabledState = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition
			err := matchCondition.Initialize_From_MatchCondition_STATUS(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		rule.Name = &name
	} else {
		rule.Name = nil
	}

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDurationInMinutes
	if source.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinute := *source.RateLimitDurationInMinutes
		rule.RateLimitDurationInMinutes = &rateLimitDurationInMinute
	} else {
		rule.RateLimitDurationInMinutes = nil
	}

	// RateLimitThreshold
	if source.RateLimitThreshold != nil {
		rateLimitThreshold := *source.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	} else {
		rule.RateLimitThreshold = nil
	}

	// RuleType
	if source.RuleType != nil {
		ruleType := CustomRule_RuleType(*source.RuleType)
		rule.RuleType = &ruleType
	} else {
		rule.RuleType = nil
	}

	// No error
	return nil
}

// Defines contents of a web application rule
type CustomRule_STATUS struct {
	// Action: Describes what action to be applied when rule matches.
	Action *ActionType_STATUS `json:"action,omitempty"`

	// EnabledState: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
	EnabledState *CustomRule_EnabledState_STATUS `json:"enabledState,omitempty"`

	// MatchConditions: List of match conditions.
	MatchConditions []MatchCondition_STATUS `json:"matchConditions,omitempty"`

	// Name: Describes the name of the rule.
	Name *string `json:"name,omitempty"`

	// Priority: Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
	Priority *int `json:"priority,omitempty"`

	// RateLimitDurationInMinutes: Time window for resetting the rate limit count. Default is 1 minute.
	RateLimitDurationInMinutes *int `json:"rateLimitDurationInMinutes,omitempty"`

	// RateLimitThreshold: Number of allowed requests per client within the time window.
	RateLimitThreshold *int `json:"rateLimitThreshold,omitempty"`

	// RuleType: Describes type of rule.
	RuleType *CustomRule_RuleType_STATUS `json:"ruleType,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *CustomRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *CustomRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomRule_STATUS_ARM, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		action := *typedInput.Action
		rule.Action = &action
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		enabledState := *typedInput.EnabledState
		rule.EnabledState = &enabledState
	}

	// Set property "MatchConditions":
	for _, item := range typedInput.MatchConditions {
		var item1 MatchCondition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.MatchConditions = append(rule.MatchConditions, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		rule.Priority = &priority
	}

	// Set property "RateLimitDurationInMinutes":
	if typedInput.RateLimitDurationInMinutes != nil {
		rateLimitDurationInMinutes := *typedInput.RateLimitDurationInMinutes
		rule.RateLimitDurationInMinutes = &rateLimitDurationInMinutes
	}

	// Set property "RateLimitThreshold":
	if typedInput.RateLimitThreshold != nil {
		rateLimitThreshold := *typedInput.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if typedInput.RuleType != nil {
		ruleType := *typedInput.RuleType
		rule.RuleType = &ruleType
	}

	// No error
	return nil
}

// AssignProperties_From_CustomRule_STATUS populates our CustomRule_STATUS from the provided source CustomRule_STATUS
func (rule *CustomRule_STATUS) AssignProperties_From_CustomRule_STATUS(source *v20220501s.CustomRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_STATUS_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, customRule_EnabledState_STATUS_Values)
		rule.EnabledState = &enabledStateTemp
	} else {
		rule.EnabledState = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition_STATUS, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition_STATUS
			err := matchCondition.AssignProperties_From_MatchCondition_STATUS(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDurationInMinutes
	rule.RateLimitDurationInMinutes = genruntime.ClonePointerToInt(source.RateLimitDurationInMinutes)

	// RateLimitThreshold
	rule.RateLimitThreshold = genruntime.ClonePointerToInt(source.RateLimitThreshold)

	// RuleType
	if source.RuleType != nil {
		ruleType := *source.RuleType
		ruleTypeTemp := genruntime.ToEnum(ruleType, customRule_RuleType_STATUS_Values)
		rule.RuleType = &ruleTypeTemp
	} else {
		rule.RuleType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomRule_STATUS populates the provided destination CustomRule_STATUS from our CustomRule_STATUS
func (rule *CustomRule_STATUS) AssignProperties_To_CustomRule_STATUS(destination *v20220501s.CustomRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// EnabledState
	if rule.EnabledState != nil {
		enabledState := string(*rule.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// MatchConditions
	if rule.MatchConditions != nil {
		matchConditionList := make([]v20220501s.MatchCondition_STATUS, len(rule.MatchConditions))
		for matchConditionIndex, matchConditionItem := range rule.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition v20220501s.MatchCondition_STATUS
			err := matchConditionItem.AssignProperties_To_MatchCondition_STATUS(&matchCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		destination.MatchConditions = matchConditionList
	} else {
		destination.MatchConditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(rule.Priority)

	// RateLimitDurationInMinutes
	destination.RateLimitDurationInMinutes = genruntime.ClonePointerToInt(rule.RateLimitDurationInMinutes)

	// RateLimitThreshold
	destination.RateLimitThreshold = genruntime.ClonePointerToInt(rule.RateLimitThreshold)

	// RuleType
	if rule.RuleType != nil {
		ruleType := string(*rule.RuleType)
		destination.RuleType = &ruleType
	} else {
		destination.RuleType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines a managed rule set.
type ManagedRuleSet struct {
	// Exclusions: Describes the exclusions that are applied to all rules in the set.
	Exclusions []ManagedRuleExclusion `json:"exclusions,omitempty"`

	// RuleGroupOverrides: Defines the rule group overrides to apply to the rule set.
	RuleGroupOverrides []ManagedRuleGroupOverride `json:"ruleGroupOverrides,omitempty"`

	// RuleSetAction: Defines the rule set action.
	RuleSetAction *ManagedRuleSetActionType `json:"ruleSetAction,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetType: Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetVersion: Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ruleSet *ManagedRuleSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ruleSet == nil {
		return nil, nil
	}
	result := &ManagedRuleSet_ARM{}

	// Set property "Exclusions":
	for _, item := range ruleSet.Exclusions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Exclusions = append(result.Exclusions, *item_ARM.(*ManagedRuleExclusion_ARM))
	}

	// Set property "RuleGroupOverrides":
	for _, item := range ruleSet.RuleGroupOverrides {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.RuleGroupOverrides = append(result.RuleGroupOverrides, *item_ARM.(*ManagedRuleGroupOverride_ARM))
	}

	// Set property "RuleSetAction":
	if ruleSet.RuleSetAction != nil {
		ruleSetAction := *ruleSet.RuleSetAction
		result.RuleSetAction = &ruleSetAction
	}

	// Set property "RuleSetType":
	if ruleSet.RuleSetType != nil {
		ruleSetType := *ruleSet.RuleSetType
		result.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if ruleSet.RuleSetVersion != nil {
		ruleSetVersion := *ruleSet.RuleSetVersion
		result.RuleSetVersion = &ruleSetVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ManagedRuleSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleSet_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ManagedRuleSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleSet_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleSet_ARM, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.Exclusions = append(ruleSet.Exclusions, item1)
	}

	// Set property "RuleGroupOverrides":
	for _, item := range typedInput.RuleGroupOverrides {
		var item1 ManagedRuleGroupOverride
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.RuleGroupOverrides = append(ruleSet.RuleGroupOverrides, item1)
	}

	// Set property "RuleSetAction":
	if typedInput.RuleSetAction != nil {
		ruleSetAction := *typedInput.RuleSetAction
		ruleSet.RuleSetAction = &ruleSetAction
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		ruleSet.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		ruleSet.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSet populates our ManagedRuleSet from the provided source ManagedRuleSet
func (ruleSet *ManagedRuleSet) AssignProperties_From_ManagedRuleSet(source *v20220501s.ManagedRuleSet) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.AssignProperties_From_ManagedRuleExclusion(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		ruleSet.Exclusions = exclusionList
	} else {
		ruleSet.Exclusions = nil
	}

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride
			err := ruleGroupOverride.AssignProperties_From_ManagedRuleGroupOverride(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleGroupOverride() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if source.RuleSetAction != nil {
		ruleSetAction := *source.RuleSetAction
		ruleSetActionTemp := genruntime.ToEnum(ruleSetAction, managedRuleSetActionType_Values)
		ruleSet.RuleSetAction = &ruleSetActionTemp
	} else {
		ruleSet.RuleSetAction = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSet populates the provided destination ManagedRuleSet from our ManagedRuleSet
func (ruleSet *ManagedRuleSet) AssignProperties_To_ManagedRuleSet(destination *v20220501s.ManagedRuleSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if ruleSet.Exclusions != nil {
		exclusionList := make([]v20220501s.ManagedRuleExclusion, len(ruleSet.Exclusions))
		for exclusionIndex, exclusionItem := range ruleSet.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion v20220501s.ManagedRuleExclusion
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleGroupOverrides
	if ruleSet.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]v20220501s.ManagedRuleGroupOverride, len(ruleSet.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range ruleSet.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride v20220501s.ManagedRuleGroupOverride
			err := ruleGroupOverrideItem.AssignProperties_To_ManagedRuleGroupOverride(&ruleGroupOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleGroupOverride() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		destination.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		destination.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if ruleSet.RuleSetAction != nil {
		ruleSetAction := string(*ruleSet.RuleSetAction)
		destination.RuleSetAction = &ruleSetAction
	} else {
		destination.RuleSetAction = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(ruleSet.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(ruleSet.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleSet_STATUS populates our ManagedRuleSet from the provided source ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet) Initialize_From_ManagedRuleSet_STATUS(source *ManagedRuleSet_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.Initialize_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		ruleSet.Exclusions = exclusionList
	} else {
		ruleSet.Exclusions = nil
	}

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride
			err := ruleGroupOverride.Initialize_From_ManagedRuleGroupOverride_STATUS(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if source.RuleSetAction != nil {
		ruleSetAction := ManagedRuleSetActionType(*source.RuleSetAction)
		ruleSet.RuleSetAction = &ruleSetAction
	} else {
		ruleSet.RuleSetAction = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// Defines a managed rule set.
type ManagedRuleSet_STATUS struct {
	// Exclusions: Describes the exclusions that are applied to all rules in the set.
	Exclusions []ManagedRuleExclusion_STATUS `json:"exclusions,omitempty"`

	// RuleGroupOverrides: Defines the rule group overrides to apply to the rule set.
	RuleGroupOverrides []ManagedRuleGroupOverride_STATUS `json:"ruleGroupOverrides,omitempty"`

	// RuleSetAction: Defines the rule set action.
	RuleSetAction *ManagedRuleSetActionType_STATUS `json:"ruleSetAction,omitempty"`

	// RuleSetType: Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// RuleSetVersion: Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ManagedRuleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleSet_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ManagedRuleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleSet_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleSet_STATUS_ARM, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.Exclusions = append(ruleSet.Exclusions, item1)
	}

	// Set property "RuleGroupOverrides":
	for _, item := range typedInput.RuleGroupOverrides {
		var item1 ManagedRuleGroupOverride_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.RuleGroupOverrides = append(ruleSet.RuleGroupOverrides, item1)
	}

	// Set property "RuleSetAction":
	if typedInput.RuleSetAction != nil {
		ruleSetAction := *typedInput.RuleSetAction
		ruleSet.RuleSetAction = &ruleSetAction
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		ruleSet.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		ruleSet.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSet_STATUS populates our ManagedRuleSet_STATUS from the provided source ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet_STATUS) AssignProperties_From_ManagedRuleSet_STATUS(source *v20220501s.ManagedRuleSet_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion_STATUS, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion_STATUS
			err := exclusion.AssignProperties_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		ruleSet.Exclusions = exclusionList
	} else {
		ruleSet.Exclusions = nil
	}

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride_STATUS, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride_STATUS
			err := ruleGroupOverride.AssignProperties_From_ManagedRuleGroupOverride_STATUS(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if source.RuleSetAction != nil {
		ruleSetAction := *source.RuleSetAction
		ruleSetActionTemp := genruntime.ToEnum(ruleSetAction, managedRuleSetActionType_STATUS_Values)
		ruleSet.RuleSetAction = &ruleSetActionTemp
	} else {
		ruleSet.RuleSetAction = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSet_STATUS populates the provided destination ManagedRuleSet_STATUS from our ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet_STATUS) AssignProperties_To_ManagedRuleSet_STATUS(destination *v20220501s.ManagedRuleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if ruleSet.Exclusions != nil {
		exclusionList := make([]v20220501s.ManagedRuleExclusion_STATUS, len(ruleSet.Exclusions))
		for exclusionIndex, exclusionItem := range ruleSet.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion v20220501s.ManagedRuleExclusion_STATUS
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion_STATUS(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleGroupOverrides
	if ruleSet.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]v20220501s.ManagedRuleGroupOverride_STATUS, len(ruleSet.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range ruleSet.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride v20220501s.ManagedRuleGroupOverride_STATUS
			err := ruleGroupOverrideItem.AssignProperties_To_ManagedRuleGroupOverride_STATUS(&ruleGroupOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		destination.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		destination.RuleGroupOverrides = nil
	}

	// RuleSetAction
	if ruleSet.RuleSetAction != nil {
		ruleSetAction := string(*ruleSet.RuleSetAction)
		destination.RuleSetAction = &ruleSetAction
	} else {
		destination.RuleSetAction = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(ruleSet.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(ruleSet.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Exclude variables from managed rule evaluation.
type ManagedRuleExclusion struct {
	// +kubebuilder:validation:Required
	// MatchVariable: The variable type to be excluded.
	MatchVariable *ManagedRuleExclusion_MatchVariable `json:"matchVariable,omitempty"`

	// +kubebuilder:validation:Required
	// Selector: Selector value for which elements in the collection this exclusion applies to.
	Selector *string `json:"selector,omitempty"`

	// +kubebuilder:validation:Required
	// SelectorMatchOperator: Comparison operator to apply to the selector when specifying which elements in the collection
	// this exclusion applies to.
	SelectorMatchOperator *ManagedRuleExclusion_SelectorMatchOperator `json:"selectorMatchOperator,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleExclusion{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exclusion *ManagedRuleExclusion) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exclusion == nil {
		return nil, nil
	}
	result := &ManagedRuleExclusion_ARM{}

	// Set property "MatchVariable":
	if exclusion.MatchVariable != nil {
		matchVariable := *exclusion.MatchVariable
		result.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if exclusion.Selector != nil {
		selector := *exclusion.Selector
		result.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if exclusion.SelectorMatchOperator != nil {
		selectorMatchOperator := *exclusion.SelectorMatchOperator
		result.SelectorMatchOperator = &selectorMatchOperator
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exclusion *ManagedRuleExclusion) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleExclusion_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exclusion *ManagedRuleExclusion) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleExclusion_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleExclusion_ARM, got %T", armInput)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		matchVariable := *typedInput.MatchVariable
		exclusion.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		exclusion.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		selectorMatchOperator := *typedInput.SelectorMatchOperator
		exclusion.SelectorMatchOperator = &selectorMatchOperator
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleExclusion populates our ManagedRuleExclusion from the provided source ManagedRuleExclusion
func (exclusion *ManagedRuleExclusion) AssignProperties_From_ManagedRuleExclusion(source *v20220501s.ManagedRuleExclusion) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, managedRuleExclusion_MatchVariable_Values)
		exclusion.MatchVariable = &matchVariableTemp
	} else {
		exclusion.MatchVariable = nil
	}

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := *source.SelectorMatchOperator
		selectorMatchOperatorTemp := genruntime.ToEnum(selectorMatchOperator, managedRuleExclusion_SelectorMatchOperator_Values)
		exclusion.SelectorMatchOperator = &selectorMatchOperatorTemp
	} else {
		exclusion.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleExclusion populates the provided destination ManagedRuleExclusion from our ManagedRuleExclusion
func (exclusion *ManagedRuleExclusion) AssignProperties_To_ManagedRuleExclusion(destination *v20220501s.ManagedRuleExclusion) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchVariable
	if exclusion.MatchVariable != nil {
		matchVariable := string(*exclusion.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(exclusion.Selector)

	// SelectorMatchOperator
	if exclusion.SelectorMatchOperator != nil {
		selectorMatchOperator := string(*exclusion.SelectorMatchOperator)
		destination.SelectorMatchOperator = &selectorMatchOperator
	} else {
		destination.SelectorMatchOperator = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleExclusion_STATUS populates our ManagedRuleExclusion from the provided source ManagedRuleExclusion_STATUS
func (exclusion *ManagedRuleExclusion) Initialize_From_ManagedRuleExclusion_STATUS(source *ManagedRuleExclusion_STATUS) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := ManagedRuleExclusion_MatchVariable(*source.MatchVariable)
		exclusion.MatchVariable = &matchVariable
	} else {
		exclusion.MatchVariable = nil
	}

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := ManagedRuleExclusion_SelectorMatchOperator(*source.SelectorMatchOperator)
		exclusion.SelectorMatchOperator = &selectorMatchOperator
	} else {
		exclusion.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// Exclude variables from managed rule evaluation.
type ManagedRuleExclusion_STATUS struct {
	// MatchVariable: The variable type to be excluded.
	MatchVariable *ManagedRuleExclusion_MatchVariable_STATUS `json:"matchVariable,omitempty"`

	// Selector: Selector value for which elements in the collection this exclusion applies to.
	Selector *string `json:"selector,omitempty"`

	// SelectorMatchOperator: Comparison operator to apply to the selector when specifying which elements in the collection
	// this exclusion applies to.
	SelectorMatchOperator *ManagedRuleExclusion_SelectorMatchOperator_STATUS `json:"selectorMatchOperator,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleExclusion_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exclusion *ManagedRuleExclusion_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleExclusion_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exclusion *ManagedRuleExclusion_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleExclusion_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleExclusion_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		matchVariable := *typedInput.MatchVariable
		exclusion.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		exclusion.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		selectorMatchOperator := *typedInput.SelectorMatchOperator
		exclusion.SelectorMatchOperator = &selectorMatchOperator
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleExclusion_STATUS populates our ManagedRuleExclusion_STATUS from the provided source ManagedRuleExclusion_STATUS
func (exclusion *ManagedRuleExclusion_STATUS) AssignProperties_From_ManagedRuleExclusion_STATUS(source *v20220501s.ManagedRuleExclusion_STATUS) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, managedRuleExclusion_MatchVariable_STATUS_Values)
		exclusion.MatchVariable = &matchVariableTemp
	} else {
		exclusion.MatchVariable = nil
	}

	// Selector
	exclusion.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := *source.SelectorMatchOperator
		selectorMatchOperatorTemp := genruntime.ToEnum(selectorMatchOperator, managedRuleExclusion_SelectorMatchOperator_STATUS_Values)
		exclusion.SelectorMatchOperator = &selectorMatchOperatorTemp
	} else {
		exclusion.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleExclusion_STATUS populates the provided destination ManagedRuleExclusion_STATUS from our ManagedRuleExclusion_STATUS
func (exclusion *ManagedRuleExclusion_STATUS) AssignProperties_To_ManagedRuleExclusion_STATUS(destination *v20220501s.ManagedRuleExclusion_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchVariable
	if exclusion.MatchVariable != nil {
		matchVariable := string(*exclusion.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(exclusion.Selector)

	// SelectorMatchOperator
	if exclusion.SelectorMatchOperator != nil {
		selectorMatchOperator := string(*exclusion.SelectorMatchOperator)
		destination.SelectorMatchOperator = &selectorMatchOperator
	} else {
		destination.SelectorMatchOperator = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleGroupOverride struct {
	// Exclusions: Describes the exclusions that are applied to all rules in the group.
	Exclusions []ManagedRuleExclusion `json:"exclusions,omitempty"`

	// +kubebuilder:validation:Required
	// RuleGroupName: Describes the managed rule group to override.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules []ManagedRuleOverride `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleGroupOverride{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (override *ManagedRuleGroupOverride) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if override == nil {
		return nil, nil
	}
	result := &ManagedRuleGroupOverride_ARM{}

	// Set property "Exclusions":
	for _, item := range override.Exclusions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Exclusions = append(result.Exclusions, *item_ARM.(*ManagedRuleExclusion_ARM))
	}

	// Set property "RuleGroupName":
	if override.RuleGroupName != nil {
		ruleGroupName := *override.RuleGroupName
		result.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range override.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*ManagedRuleOverride_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleGroupOverride) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleGroupOverride_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleGroupOverride) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleGroupOverride_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleGroupOverride_ARM, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Exclusions = append(override.Exclusions, item1)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		override.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ManagedRuleOverride
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Rules = append(override.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleGroupOverride populates our ManagedRuleGroupOverride from the provided source ManagedRuleGroupOverride
func (override *ManagedRuleGroupOverride) AssignProperties_From_ManagedRuleGroupOverride(source *v20220501s.ManagedRuleGroupOverride) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.AssignProperties_From_ManagedRuleExclusion(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride
			err := rule.AssignProperties_From_ManagedRuleOverride(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleOverride() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleGroupOverride populates the provided destination ManagedRuleGroupOverride from our ManagedRuleGroupOverride
func (override *ManagedRuleGroupOverride) AssignProperties_To_ManagedRuleGroupOverride(destination *v20220501s.ManagedRuleGroupOverride) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if override.Exclusions != nil {
		exclusionList := make([]v20220501s.ManagedRuleExclusion, len(override.Exclusions))
		for exclusionIndex, exclusionItem := range override.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion v20220501s.ManagedRuleExclusion
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(override.RuleGroupName)

	// Rules
	if override.Rules != nil {
		ruleList := make([]v20220501s.ManagedRuleOverride, len(override.Rules))
		for ruleIndex, ruleItem := range override.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20220501s.ManagedRuleOverride
			err := ruleItem.AssignProperties_To_ManagedRuleOverride(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleOverride() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleGroupOverride_STATUS populates our ManagedRuleGroupOverride from the provided source ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride) Initialize_From_ManagedRuleGroupOverride_STATUS(source *ManagedRuleGroupOverride_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.Initialize_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride
			err := rule.Initialize_From_ManagedRuleOverride_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleGroupOverride_STATUS struct {
	// Exclusions: Describes the exclusions that are applied to all rules in the group.
	Exclusions []ManagedRuleExclusion_STATUS `json:"exclusions,omitempty"`

	// RuleGroupName: Describes the managed rule group to override.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules []ManagedRuleOverride_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleGroupOverride_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleGroupOverride_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleGroupOverride_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleGroupOverride_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleGroupOverride_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleGroupOverride_STATUS_ARM, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Exclusions = append(override.Exclusions, item1)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		override.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ManagedRuleOverride_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Rules = append(override.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleGroupOverride_STATUS populates our ManagedRuleGroupOverride_STATUS from the provided source ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride_STATUS) AssignProperties_From_ManagedRuleGroupOverride_STATUS(source *v20220501s.ManagedRuleGroupOverride_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion_STATUS, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion_STATUS
			err := exclusion.AssignProperties_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride_STATUS
			err := rule.AssignProperties_From_ManagedRuleOverride_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleGroupOverride_STATUS populates the provided destination ManagedRuleGroupOverride_STATUS from our ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride_STATUS) AssignProperties_To_ManagedRuleGroupOverride_STATUS(destination *v20220501s.ManagedRuleGroupOverride_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if override.Exclusions != nil {
		exclusionList := make([]v20220501s.ManagedRuleExclusion_STATUS, len(override.Exclusions))
		for exclusionIndex, exclusionItem := range override.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion v20220501s.ManagedRuleExclusion_STATUS
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion_STATUS(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(override.RuleGroupName)

	// Rules
	if override.Rules != nil {
		ruleList := make([]v20220501s.ManagedRuleOverride_STATUS, len(override.Rules))
		for ruleIndex, ruleItem := range override.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20220501s.ManagedRuleOverride_STATUS
			err := ruleItem.AssignProperties_To_ManagedRuleOverride_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Define a match condition.
type MatchCondition struct {
	// +kubebuilder:validation:Required
	// MatchValue: List of possible match values.
	MatchValue []string `json:"matchValue,omitempty"`

	// +kubebuilder:validation:Required
	// MatchVariable: Request variable to compare with.
	MatchVariable *MatchCondition_MatchVariable `json:"matchVariable,omitempty"`

	// NegateCondition: Describes if the result of this condition should be negated.
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Comparison type to use for matching with the variable value.
	Operator *MatchCondition_Operator `json:"operator,omitempty"`

	// Selector: Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is
	// null.
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms.
	Transforms []TransformType `json:"transforms,omitempty"`
}

var _ genruntime.ARMTransformer = &MatchCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *MatchCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &MatchCondition_ARM{}

	// Set property "MatchValue":
	for _, item := range condition.MatchValue {
		result.MatchValue = append(result.MatchValue, item)
	}

	// Set property "MatchVariable":
	if condition.MatchVariable != nil {
		matchVariable := *condition.MatchVariable
		result.MatchVariable = &matchVariable
	}

	// Set property "NegateCondition":
	if condition.NegateCondition != nil {
		negateCondition := *condition.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if condition.Operator != nil {
		operator := *condition.Operator
		result.Operator = &operator
	}

	// Set property "Selector":
	if condition.Selector != nil {
		selector := *condition.Selector
		result.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range condition.Transforms {
		result.Transforms = append(result.Transforms, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *MatchCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MatchCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *MatchCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MatchCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MatchCondition_ARM, got %T", armInput)
	}

	// Set property "MatchValue":
	for _, item := range typedInput.MatchValue {
		condition.MatchValue = append(condition.MatchValue, item)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		matchVariable := *typedInput.MatchVariable
		condition.MatchVariable = &matchVariable
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		condition.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		condition.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		condition.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		condition.Transforms = append(condition.Transforms, item)
	}

	// No error
	return nil
}

// AssignProperties_From_MatchCondition populates our MatchCondition from the provided source MatchCondition
func (condition *MatchCondition) AssignProperties_From_MatchCondition(source *v20220501s.MatchCondition) error {

	// MatchValue
	condition.MatchValue = genruntime.CloneSliceOfString(source.MatchValue)

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, matchCondition_MatchVariable_Values)
		condition.MatchVariable = &matchVariableTemp
	} else {
		condition.MatchVariable = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		condition.NegateCondition = &negateCondition
	} else {
		condition.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, matchCondition_Operator_Values)
		condition.Operator = &operatorTemp
	} else {
		condition.Operator = nil
	}

	// Selector
	condition.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]TransformType, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transformType_Values)
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MatchCondition populates the provided destination MatchCondition from our MatchCondition
func (condition *MatchCondition) AssignProperties_To_MatchCondition(destination *v20220501s.MatchCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValue
	destination.MatchValue = genruntime.CloneSliceOfString(condition.MatchValue)

	// MatchVariable
	if condition.MatchVariable != nil {
		matchVariable := string(*condition.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// NegateCondition
	if condition.NegateCondition != nil {
		negateCondition := *condition.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if condition.Operator != nil {
		operator := string(*condition.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(condition.Selector)

	// Transforms
	if condition.Transforms != nil {
		transformList := make([]string, len(condition.Transforms))
		for transformIndex, transformItem := range condition.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MatchCondition_STATUS populates our MatchCondition from the provided source MatchCondition_STATUS
func (condition *MatchCondition) Initialize_From_MatchCondition_STATUS(source *MatchCondition_STATUS) error {

	// MatchValue
	condition.MatchValue = genruntime.CloneSliceOfString(source.MatchValue)

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := MatchCondition_MatchVariable(*source.MatchVariable)
		condition.MatchVariable = &matchVariable
	} else {
		condition.MatchVariable = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		condition.NegateCondition = &negateCondition
	} else {
		condition.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := MatchCondition_Operator(*source.Operator)
		condition.Operator = &operator
	} else {
		condition.Operator = nil
	}

	// Selector
	condition.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]TransformType, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := TransformType(transformItem)
			transformList[transformIndex] = transform
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// Define a match condition.
type MatchCondition_STATUS struct {
	// MatchValue: List of possible match values.
	MatchValue []string `json:"matchValue,omitempty"`

	// MatchVariable: Request variable to compare with.
	MatchVariable *MatchCondition_MatchVariable_STATUS `json:"matchVariable,omitempty"`

	// NegateCondition: Describes if the result of this condition should be negated.
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Comparison type to use for matching with the variable value.
	Operator *MatchCondition_Operator_STATUS `json:"operator,omitempty"`

	// Selector: Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is
	// null.
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms.
	Transforms []TransformType_STATUS `json:"transforms,omitempty"`
}

var _ genruntime.FromARMConverter = &MatchCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *MatchCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MatchCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *MatchCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MatchCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MatchCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValue":
	for _, item := range typedInput.MatchValue {
		condition.MatchValue = append(condition.MatchValue, item)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		matchVariable := *typedInput.MatchVariable
		condition.MatchVariable = &matchVariable
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		condition.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		condition.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		condition.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		condition.Transforms = append(condition.Transforms, item)
	}

	// No error
	return nil
}

// AssignProperties_From_MatchCondition_STATUS populates our MatchCondition_STATUS from the provided source MatchCondition_STATUS
func (condition *MatchCondition_STATUS) AssignProperties_From_MatchCondition_STATUS(source *v20220501s.MatchCondition_STATUS) error {

	// MatchValue
	condition.MatchValue = genruntime.CloneSliceOfString(source.MatchValue)

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, matchCondition_MatchVariable_STATUS_Values)
		condition.MatchVariable = &matchVariableTemp
	} else {
		condition.MatchVariable = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		condition.NegateCondition = &negateCondition
	} else {
		condition.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, matchCondition_Operator_STATUS_Values)
		condition.Operator = &operatorTemp
	} else {
		condition.Operator = nil
	}

	// Selector
	condition.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]TransformType_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transformType_STATUS_Values)
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MatchCondition_STATUS populates the provided destination MatchCondition_STATUS from our MatchCondition_STATUS
func (condition *MatchCondition_STATUS) AssignProperties_To_MatchCondition_STATUS(destination *v20220501s.MatchCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValue
	destination.MatchValue = genruntime.CloneSliceOfString(condition.MatchValue)

	// MatchVariable
	if condition.MatchVariable != nil {
		matchVariable := string(*condition.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// NegateCondition
	if condition.NegateCondition != nil {
		negateCondition := *condition.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if condition.Operator != nil {
		operator := string(*condition.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(condition.Selector)

	// Transforms
	if condition.Transforms != nil {
		transformList := make([]string, len(condition.Transforms))
		for transformIndex, transformItem := range condition.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleOverride struct {
	// Action: Describes the override action to be applied when rule matches.
	Action *ActionType `json:"action,omitempty"`

	// EnabledState: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
	EnabledState *ManagedRuleEnabledState `json:"enabledState,omitempty"`

	// Exclusions: Describes the exclusions that are applied to this specific rule.
	Exclusions []ManagedRuleExclusion `json:"exclusions,omitempty"`

	// +kubebuilder:validation:Required
	// RuleId: Identifier for the managed rule.
	RuleId *string `json:"ruleId,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleOverride{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (override *ManagedRuleOverride) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if override == nil {
		return nil, nil
	}
	result := &ManagedRuleOverride_ARM{}

	// Set property "Action":
	if override.Action != nil {
		action := *override.Action
		result.Action = &action
	}

	// Set property "EnabledState":
	if override.EnabledState != nil {
		enabledState := *override.EnabledState
		result.EnabledState = &enabledState
	}

	// Set property "Exclusions":
	for _, item := range override.Exclusions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Exclusions = append(result.Exclusions, *item_ARM.(*ManagedRuleExclusion_ARM))
	}

	// Set property "RuleId":
	if override.RuleId != nil {
		ruleId := *override.RuleId
		result.RuleId = &ruleId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleOverride) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleOverride_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleOverride) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleOverride_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleOverride_ARM, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		action := *typedInput.Action
		override.Action = &action
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		enabledState := *typedInput.EnabledState
		override.EnabledState = &enabledState
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Exclusions = append(override.Exclusions, item1)
	}

	// Set property "RuleId":
	if typedInput.RuleId != nil {
		ruleId := *typedInput.RuleId
		override.RuleId = &ruleId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleOverride populates our ManagedRuleOverride from the provided source ManagedRuleOverride
func (override *ManagedRuleOverride) AssignProperties_From_ManagedRuleOverride(source *v20220501s.ManagedRuleOverride) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_Values)
		override.Action = &actionTemp
	} else {
		override.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, managedRuleEnabledState_Values)
		override.EnabledState = &enabledStateTemp
	} else {
		override.EnabledState = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.AssignProperties_From_ManagedRuleExclusion(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleOverride populates the provided destination ManagedRuleOverride from our ManagedRuleOverride
func (override *ManagedRuleOverride) AssignProperties_To_ManagedRuleOverride(destination *v20220501s.ManagedRuleOverride) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if override.Action != nil {
		action := string(*override.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// EnabledState
	if override.EnabledState != nil {
		enabledState := string(*override.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// Exclusions
	if override.Exclusions != nil {
		exclusionList := make([]v20220501s.ManagedRuleExclusion, len(override.Exclusions))
		for exclusionIndex, exclusionItem := range override.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion v20220501s.ManagedRuleExclusion
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleId
	destination.RuleId = genruntime.ClonePointerToString(override.RuleId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleOverride_STATUS populates our ManagedRuleOverride from the provided source ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride) Initialize_From_ManagedRuleOverride_STATUS(source *ManagedRuleOverride_STATUS) error {

	// Action
	if source.Action != nil {
		action := ActionType(*source.Action)
		override.Action = &action
	} else {
		override.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := ManagedRuleEnabledState(*source.EnabledState)
		override.EnabledState = &enabledState
	} else {
		override.EnabledState = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion
			err := exclusion.Initialize_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleOverride_STATUS struct {
	// Action: Describes the override action to be applied when rule matches.
	Action *ActionType_STATUS `json:"action,omitempty"`

	// EnabledState: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
	EnabledState *ManagedRuleEnabledState_STATUS `json:"enabledState,omitempty"`

	// Exclusions: Describes the exclusions that are applied to this specific rule.
	Exclusions []ManagedRuleExclusion_STATUS `json:"exclusions,omitempty"`

	// RuleId: Identifier for the managed rule.
	RuleId *string `json:"ruleId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleOverride_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleOverride_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedRuleOverride_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleOverride_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedRuleOverride_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedRuleOverride_STATUS_ARM, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		action := *typedInput.Action
		override.Action = &action
	}

	// Set property "EnabledState":
	if typedInput.EnabledState != nil {
		enabledState := *typedInput.EnabledState
		override.EnabledState = &enabledState
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 ManagedRuleExclusion_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Exclusions = append(override.Exclusions, item1)
	}

	// Set property "RuleId":
	if typedInput.RuleId != nil {
		ruleId := *typedInput.RuleId
		override.RuleId = &ruleId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleOverride_STATUS populates our ManagedRuleOverride_STATUS from the provided source ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride_STATUS) AssignProperties_From_ManagedRuleOverride_STATUS(source *v20220501s.ManagedRuleOverride_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_STATUS_Values)
		override.Action = &actionTemp
	} else {
		override.Action = nil
	}

	// EnabledState
	if source.EnabledState != nil {
		enabledState := *source.EnabledState
		enabledStateTemp := genruntime.ToEnum(enabledState, managedRuleEnabledState_STATUS_Values)
		override.EnabledState = &enabledStateTemp
	} else {
		override.EnabledState = nil
	}

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]ManagedRuleExclusion_STATUS, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion ManagedRuleExclusion_STATUS
			err := exclusion.AssignProperties_From_ManagedRuleExclusion_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		override.Exclusions = exclusionList
	} else {
		override.Exclusions = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleOverride_STATUS populates the provided destination ManagedRuleOverride_STATUS from our ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride_STATUS) AssignProperties_To_ManagedRuleOverride_STATUS(destination *v20220501s.ManagedRuleOverride_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if override.Action != nil {
		action := string(*override.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// EnabledState
	if override.EnabledState != nil {
		enabledState := string(*override.EnabledState)
		destination.EnabledState = &enabledState
	} else {
		destination.EnabledState = nil
	}

	// Exclusions
	if override.Exclusions != nil {
		exclusionList := make([]v20220501s.ManagedRuleExclusion_STATUS, len(override.Exclusions))
		for exclusionIndex, exclusionItem := range override.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion v20220501s.ManagedRuleExclusion_STATUS
			err := exclusionItem.AssignProperties_To_ManagedRuleExclusion_STATUS(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleExclusion_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// RuleId
	destination.RuleId = genruntime.ClonePointerToString(override.RuleId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&WebApplicationFirewallPolicy{}, &WebApplicationFirewallPolicyList{})
}
