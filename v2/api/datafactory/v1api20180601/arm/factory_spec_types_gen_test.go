// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_CMKIdentityDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CMKIdentityDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCMKIdentityDefinition, CMKIdentityDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCMKIdentityDefinition runs a test to see if a specific instance of CMKIdentityDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForCMKIdentityDefinition(subject CMKIdentityDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CMKIdentityDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CMKIdentityDefinition instances for property testing - lazily instantiated by
// CMKIdentityDefinitionGenerator()
var cmkIdentityDefinitionGenerator gopter.Gen

// CMKIdentityDefinitionGenerator returns a generator of CMKIdentityDefinition instances for property testing.
func CMKIdentityDefinitionGenerator() gopter.Gen {
	if cmkIdentityDefinitionGenerator != nil {
		return cmkIdentityDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCMKIdentityDefinition(generators)
	cmkIdentityDefinitionGenerator = gen.Struct(reflect.TypeOf(CMKIdentityDefinition{}), generators)

	return cmkIdentityDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForCMKIdentityDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCMKIdentityDefinition(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionConfiguration, EncryptionConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionConfiguration runs a test to see if a specific instance of EncryptionConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionConfiguration(subject EncryptionConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionConfiguration instances for property testing - lazily instantiated by
// EncryptionConfigurationGenerator()
var encryptionConfigurationGenerator gopter.Gen

// EncryptionConfigurationGenerator returns a generator of EncryptionConfiguration instances for property testing.
// We first initialize encryptionConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionConfigurationGenerator() gopter.Gen {
	if encryptionConfigurationGenerator != nil {
		return encryptionConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionConfiguration(generators)
	encryptionConfigurationGenerator = gen.Struct(reflect.TypeOf(EncryptionConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionConfiguration(generators)
	AddRelatedPropertyGeneratorsForEncryptionConfiguration(generators)
	encryptionConfigurationGenerator = gen.Struct(reflect.TypeOf(EncryptionConfiguration{}), generators)

	return encryptionConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionConfiguration(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
	gens["VaultBaseUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionConfiguration(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(CMKIdentityDefinitionGenerator())
}

func Test_FactoryGitHubConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FactoryGitHubConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFactoryGitHubConfiguration, FactoryGitHubConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFactoryGitHubConfiguration runs a test to see if a specific instance of FactoryGitHubConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForFactoryGitHubConfiguration(subject FactoryGitHubConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FactoryGitHubConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FactoryGitHubConfiguration instances for property testing - lazily instantiated by
// FactoryGitHubConfigurationGenerator()
var factoryGitHubConfigurationGenerator gopter.Gen

// FactoryGitHubConfigurationGenerator returns a generator of FactoryGitHubConfiguration instances for property testing.
// We first initialize factoryGitHubConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FactoryGitHubConfigurationGenerator() gopter.Gen {
	if factoryGitHubConfigurationGenerator != nil {
		return factoryGitHubConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactoryGitHubConfiguration(generators)
	factoryGitHubConfigurationGenerator = gen.Struct(reflect.TypeOf(FactoryGitHubConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactoryGitHubConfiguration(generators)
	AddRelatedPropertyGeneratorsForFactoryGitHubConfiguration(generators)
	factoryGitHubConfigurationGenerator = gen.Struct(reflect.TypeOf(FactoryGitHubConfiguration{}), generators)

	return factoryGitHubConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForFactoryGitHubConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFactoryGitHubConfiguration(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["CollaborationBranch"] = gen.PtrOf(gen.AlphaString())
	gens["DisablePublish"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["LastCommitId"] = gen.PtrOf(gen.AlphaString())
	gens["RepositoryName"] = gen.PtrOf(gen.AlphaString())
	gens["RootFolder"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.OneConstOf(FactoryGitHubConfiguration_Type_FactoryGitHubConfiguration)
}

// AddRelatedPropertyGeneratorsForFactoryGitHubConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFactoryGitHubConfiguration(gens map[string]gopter.Gen) {
	gens["ClientSecret"] = gen.PtrOf(GitHubClientSecretGenerator())
}

func Test_FactoryIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FactoryIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFactoryIdentity, FactoryIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFactoryIdentity runs a test to see if a specific instance of FactoryIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForFactoryIdentity(subject FactoryIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FactoryIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FactoryIdentity instances for property testing - lazily instantiated by FactoryIdentityGenerator()
var factoryIdentityGenerator gopter.Gen

// FactoryIdentityGenerator returns a generator of FactoryIdentity instances for property testing.
// We first initialize factoryIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FactoryIdentityGenerator() gopter.Gen {
	if factoryIdentityGenerator != nil {
		return factoryIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactoryIdentity(generators)
	factoryIdentityGenerator = gen.Struct(reflect.TypeOf(FactoryIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactoryIdentity(generators)
	AddRelatedPropertyGeneratorsForFactoryIdentity(generators)
	factoryIdentityGenerator = gen.Struct(reflect.TypeOf(FactoryIdentity{}), generators)

	return factoryIdentityGenerator
}

// AddIndependentPropertyGeneratorsForFactoryIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFactoryIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FactoryIdentity_Type_SystemAssigned, FactoryIdentity_Type_SystemAssignedUserAssigned, FactoryIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForFactoryIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFactoryIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_FactoryProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FactoryProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFactoryProperties, FactoryPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFactoryProperties runs a test to see if a specific instance of FactoryProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForFactoryProperties(subject FactoryProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FactoryProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FactoryProperties instances for property testing - lazily instantiated by FactoryPropertiesGenerator()
var factoryPropertiesGenerator gopter.Gen

// FactoryPropertiesGenerator returns a generator of FactoryProperties instances for property testing.
// We first initialize factoryPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FactoryPropertiesGenerator() gopter.Gen {
	if factoryPropertiesGenerator != nil {
		return factoryPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactoryProperties(generators)
	factoryPropertiesGenerator = gen.Struct(reflect.TypeOf(FactoryProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactoryProperties(generators)
	AddRelatedPropertyGeneratorsForFactoryProperties(generators)
	factoryPropertiesGenerator = gen.Struct(reflect.TypeOf(FactoryProperties{}), generators)

	return factoryPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForFactoryProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFactoryProperties(gens map[string]gopter.Gen) {
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(FactoryProperties_PublicNetworkAccess_Disabled, FactoryProperties_PublicNetworkAccess_Enabled))
}

// AddRelatedPropertyGeneratorsForFactoryProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFactoryProperties(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionConfigurationGenerator())
	gens["GlobalParameters"] = gen.MapOf(
		gen.AlphaString(),
		GlobalParameterSpecificationGenerator())
	gens["PurviewConfiguration"] = gen.PtrOf(PurviewConfigurationGenerator())
	gens["RepoConfiguration"] = gen.PtrOf(FactoryRepoConfigurationGenerator())
}

func Test_FactoryRepoConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FactoryRepoConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFactoryRepoConfiguration, FactoryRepoConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFactoryRepoConfiguration runs a test to see if a specific instance of FactoryRepoConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForFactoryRepoConfiguration(subject FactoryRepoConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FactoryRepoConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FactoryRepoConfiguration instances for property testing - lazily instantiated by
// FactoryRepoConfigurationGenerator()
var factoryRepoConfigurationGenerator gopter.Gen

// FactoryRepoConfigurationGenerator returns a generator of FactoryRepoConfiguration instances for property testing.
func FactoryRepoConfigurationGenerator() gopter.Gen {
	if factoryRepoConfigurationGenerator != nil {
		return factoryRepoConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFactoryRepoConfiguration(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(FactoryRepoConfiguration{}), map[string]gopter.Gen{propName: propGen}))
	}
	factoryRepoConfigurationGenerator = gen.OneGenOf(gens...)

	return factoryRepoConfigurationGenerator
}

// AddRelatedPropertyGeneratorsForFactoryRepoConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFactoryRepoConfiguration(gens map[string]gopter.Gen) {
	gens["FactoryGitHub"] = FactoryGitHubConfigurationGenerator().Map(func(it FactoryGitHubConfiguration) *FactoryGitHubConfiguration {
		return &it
	}) // generate one case for OneOf type
	gens["FactoryVSTS"] = FactoryVSTSConfigurationGenerator().Map(func(it FactoryVSTSConfiguration) *FactoryVSTSConfiguration {
		return &it
	}) // generate one case for OneOf type
}

func Test_FactoryVSTSConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FactoryVSTSConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFactoryVSTSConfiguration, FactoryVSTSConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFactoryVSTSConfiguration runs a test to see if a specific instance of FactoryVSTSConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForFactoryVSTSConfiguration(subject FactoryVSTSConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FactoryVSTSConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FactoryVSTSConfiguration instances for property testing - lazily instantiated by
// FactoryVSTSConfigurationGenerator()
var factoryVSTSConfigurationGenerator gopter.Gen

// FactoryVSTSConfigurationGenerator returns a generator of FactoryVSTSConfiguration instances for property testing.
func FactoryVSTSConfigurationGenerator() gopter.Gen {
	if factoryVSTSConfigurationGenerator != nil {
		return factoryVSTSConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactoryVSTSConfiguration(generators)
	factoryVSTSConfigurationGenerator = gen.Struct(reflect.TypeOf(FactoryVSTSConfiguration{}), generators)

	return factoryVSTSConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForFactoryVSTSConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFactoryVSTSConfiguration(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["CollaborationBranch"] = gen.PtrOf(gen.AlphaString())
	gens["DisablePublish"] = gen.PtrOf(gen.Bool())
	gens["LastCommitId"] = gen.PtrOf(gen.AlphaString())
	gens["ProjectName"] = gen.PtrOf(gen.AlphaString())
	gens["RepositoryName"] = gen.PtrOf(gen.AlphaString())
	gens["RootFolder"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.OneConstOf(FactoryVSTSConfiguration_Type_FactoryVSTSConfiguration)
}

func Test_Factory_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Factory_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFactory_Spec, Factory_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFactory_Spec runs a test to see if a specific instance of Factory_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFactory_Spec(subject Factory_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Factory_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Factory_Spec instances for property testing - lazily instantiated by Factory_SpecGenerator()
var factory_SpecGenerator gopter.Gen

// Factory_SpecGenerator returns a generator of Factory_Spec instances for property testing.
// We first initialize factory_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Factory_SpecGenerator() gopter.Gen {
	if factory_SpecGenerator != nil {
		return factory_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactory_Spec(generators)
	factory_SpecGenerator = gen.Struct(reflect.TypeOf(Factory_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFactory_Spec(generators)
	AddRelatedPropertyGeneratorsForFactory_Spec(generators)
	factory_SpecGenerator = gen.Struct(reflect.TypeOf(Factory_Spec{}), generators)

	return factory_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFactory_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFactory_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFactory_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFactory_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(FactoryIdentityGenerator())
	gens["Properties"] = gen.PtrOf(FactoryPropertiesGenerator())
}

func Test_GitHubClientSecret_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitHubClientSecret via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitHubClientSecret, GitHubClientSecretGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitHubClientSecret runs a test to see if a specific instance of GitHubClientSecret round trips to JSON and back losslessly
func RunJSONSerializationTestForGitHubClientSecret(subject GitHubClientSecret) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitHubClientSecret
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitHubClientSecret instances for property testing - lazily instantiated by GitHubClientSecretGenerator()
var gitHubClientSecretGenerator gopter.Gen

// GitHubClientSecretGenerator returns a generator of GitHubClientSecret instances for property testing.
func GitHubClientSecretGenerator() gopter.Gen {
	if gitHubClientSecretGenerator != nil {
		return gitHubClientSecretGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitHubClientSecret(generators)
	gitHubClientSecretGenerator = gen.Struct(reflect.TypeOf(GitHubClientSecret{}), generators)

	return gitHubClientSecretGenerator
}

// AddIndependentPropertyGeneratorsForGitHubClientSecret is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitHubClientSecret(gens map[string]gopter.Gen) {
	gens["ByoaSecretAkvUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ByoaSecretName"] = gen.PtrOf(gen.AlphaString())
}

func Test_GlobalParameterSpecification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GlobalParameterSpecification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGlobalParameterSpecification, GlobalParameterSpecificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGlobalParameterSpecification runs a test to see if a specific instance of GlobalParameterSpecification round trips to JSON and back losslessly
func RunJSONSerializationTestForGlobalParameterSpecification(subject GlobalParameterSpecification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GlobalParameterSpecification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GlobalParameterSpecification instances for property testing - lazily instantiated by
// GlobalParameterSpecificationGenerator()
var globalParameterSpecificationGenerator gopter.Gen

// GlobalParameterSpecificationGenerator returns a generator of GlobalParameterSpecification instances for property testing.
func GlobalParameterSpecificationGenerator() gopter.Gen {
	if globalParameterSpecificationGenerator != nil {
		return globalParameterSpecificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGlobalParameterSpecification(generators)
	globalParameterSpecificationGenerator = gen.Struct(reflect.TypeOf(GlobalParameterSpecification{}), generators)

	return globalParameterSpecificationGenerator
}

// AddIndependentPropertyGeneratorsForGlobalParameterSpecification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGlobalParameterSpecification(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		GlobalParameterSpecification_Type_Array,
		GlobalParameterSpecification_Type_Bool,
		GlobalParameterSpecification_Type_Float,
		GlobalParameterSpecification_Type_Int,
		GlobalParameterSpecification_Type_Object,
		GlobalParameterSpecification_Type_String))
}

func Test_PurviewConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurviewConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurviewConfiguration, PurviewConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurviewConfiguration runs a test to see if a specific instance of PurviewConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForPurviewConfiguration(subject PurviewConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurviewConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurviewConfiguration instances for property testing - lazily instantiated by
// PurviewConfigurationGenerator()
var purviewConfigurationGenerator gopter.Gen

// PurviewConfigurationGenerator returns a generator of PurviewConfiguration instances for property testing.
func PurviewConfigurationGenerator() gopter.Gen {
	if purviewConfigurationGenerator != nil {
		return purviewConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurviewConfiguration(generators)
	purviewConfigurationGenerator = gen.Struct(reflect.TypeOf(PurviewConfiguration{}), generators)

	return purviewConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForPurviewConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurviewConfiguration(gens map[string]gopter.Gen) {
	gens["PurviewResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}
