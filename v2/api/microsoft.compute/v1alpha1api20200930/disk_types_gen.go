// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200930

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/microsoft.compute/v1alpha1api20200930storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:rbac:groups=microsoft.compute.azure.com,resources=disks,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=microsoft.compute.azure.com,resources={disks/status,disks/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/resourceDefinitions/disks
type Disk struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Disks_Spec  `json:"spec,omitempty"`
	Status            Disk_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Disk{}

// GetConditions returns the conditions of the resource
func (disk *Disk) GetConditions() conditions.Conditions {
	return disk.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (disk *Disk) SetConditions(conditions conditions.Conditions) {
	disk.Status.Conditions = conditions
}

// +kubebuilder:webhook:path=/mutate-microsoft-compute-azure-com-v1alpha1api20200930-disk,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.compute.azure.com,resources=disks,verbs=create;update,versions=v1alpha1api20200930,name=default.v1alpha1api20200930.disks.microsoft.compute.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Disk{}

// Default applies defaults to the Disk resource
func (disk *Disk) Default() {
	disk.defaultImpl()
	var temp interface{} = disk
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (disk *Disk) defaultAzureName() {
	if disk.Spec.AzureName == "" {
		disk.Spec.AzureName = disk.Name
	}
}

// defaultImpl applies the code generated defaults to the Disk resource
func (disk *Disk) defaultImpl() { disk.defaultAzureName() }

var _ genruntime.KubernetesResource = &Disk{}

// AzureName returns the Azure name of the resource
func (disk *Disk) AzureName() string {
	return disk.Spec.AzureName
}

// GetResourceKind returns the kind of the resource
func (disk *Disk) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (disk *Disk) GetSpec() genruntime.ConvertibleSpec {
	return &disk.Spec
}

// GetStatus returns the status of this resource
func (disk *Disk) GetStatus() genruntime.ConvertibleStatus {
	return &disk.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/disks"
func (disk *Disk) GetType() string {
	return "Microsoft.Compute/disks"
}

// NewEmptyStatus returns a new empty (blank) status
func (disk *Disk) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Disk_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (disk *Disk) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(disk.Spec)
	return &genruntime.ResourceReference{
		Group:     group,
		Kind:      kind,
		Namespace: disk.Namespace,
		Name:      disk.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (disk *Disk) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Disk_Status); ok {
		disk.Status = *st
		return nil
	}

	// Convert status to required version
	var st Disk_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	disk.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-microsoft-compute-azure-com-v1alpha1api20200930-disk,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.compute.azure.com,resources=disks,verbs=create;update,versions=v1alpha1api20200930,name=validate.v1alpha1api20200930.disks.microsoft.compute.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Disk{}

// ValidateCreate validates the creation of the resource
func (disk *Disk) ValidateCreate() error {
	validations := disk.createValidations()
	var temp interface{} = disk
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (disk *Disk) ValidateDelete() error {
	validations := disk.deleteValidations()
	var temp interface{} = disk
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (disk *Disk) ValidateUpdate(old runtime.Object) error {
	validations := disk.updateValidations()
	var temp interface{} = disk
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (disk *Disk) createValidations() []func() error {
	return []func() error{disk.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (disk *Disk) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (disk *Disk) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return disk.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (disk *Disk) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&disk.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromDisk populates our Disk from the provided source Disk
func (disk *Disk) AssignPropertiesFromDisk(source *v1alpha1api20200930storage.Disk) error {

	// Spec
	var spec Disks_Spec
	err := spec.AssignPropertiesFromDisksSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromDisksSpec()")
	}
	disk.Spec = spec

	// Status
	var status Disk_Status
	err = status.AssignPropertiesFromDiskStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromDiskStatus()")
	}
	disk.Status = status

	// No error
	return nil
}

// AssignPropertiesToDisk populates the provided destination Disk from our Disk
func (disk *Disk) AssignPropertiesToDisk(destination *v1alpha1api20200930storage.Disk) error {

	// Spec
	var spec v1alpha1api20200930storage.Disks_Spec
	err := disk.Spec.AssignPropertiesToDisksSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToDisksSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20200930storage.Disk_Status
	err = disk.Status.AssignPropertiesToDiskStatus(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToDiskStatus()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (disk *Disk) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: disk.Spec.OriginalVersion(),
		Kind:    "Disk",
	}
}

// +kubebuilder:object:root=true
//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/resourceDefinitions/disks
type DiskList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Disk `json:"items"`
}

//Generated from:
type Disk_Status struct {
	//BurstingEnabled: Set to true to enable bursting beyond the provisioned
	//performance target of the disk. Bursting is disabled by default. Does not apply
	//to Ultra disks.
	BurstingEnabled *bool `json:"burstingEnabled,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//CreationData: Disk source information. CreationData information cannot be
	//changed after the disk has been created.
	CreationData *CreationData_Status `json:"creationData,omitempty"`

	//DiskAccessId: ARM id of the DiskAccess resource for using private endpoints on
	//disks.
	DiskAccessId *string `json:"diskAccessId,omitempty"`

	//DiskIOPSReadOnly: The total number of IOPS that will be allowed across all VMs
	//mounting the shared disk as ReadOnly. One operation can transfer between 4k and
	//256k bytes.
	DiskIOPSReadOnly *int `json:"diskIOPSReadOnly,omitempty"`

	//DiskIOPSReadWrite: The number of IOPS allowed for this disk; only settable for
	//UltraSSD disks. One operation can transfer between 4k and 256k bytes.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	//DiskMBpsReadOnly: The total throughput (MBps) that will be allowed across all
	//VMs mounting the shared disk as ReadOnly. MBps means millions of bytes per
	//second - MB here uses the ISO notation, of powers of 10.
	DiskMBpsReadOnly *int `json:"diskMBpsReadOnly,omitempty"`

	//DiskMBpsReadWrite: The bandwidth allowed for this disk; only settable for
	//UltraSSD disks. MBps means millions of bytes per second - MB here uses the ISO
	//notation, of powers of 10.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	//DiskSizeBytes: The size of the disk in bytes. This field is read only.
	DiskSizeBytes *int `json:"diskSizeBytes,omitempty"`

	//DiskSizeGB: If creationData.createOption is Empty, this field is mandatory and
	//it indicates the size of the disk to create. If this field is present for
	//updates or creation with other options, it indicates a resize. Resizes are only
	//allowed if the disk is not attached to a running VM, and can only increase the
	//disk's size.
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//DiskState: The state of the disk.
	DiskState *DiskState_Status `json:"diskState,omitempty"`

	//Encryption: Encryption property can be used to encrypt data at rest with
	//customer managed keys or platform managed keys.
	Encryption *Encryption_Status `json:"encryption,omitempty"`

	//EncryptionSettingsCollection: Encryption settings collection used for Azure Disk
	//Encryption, can contain multiple encryption settings per disk or snapshot.
	EncryptionSettingsCollection *EncryptionSettingsCollection_Status `json:"encryptionSettingsCollection,omitempty"`

	//ExtendedLocation: The extended location where the disk will be created. Extended
	//location cannot be changed.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//HyperVGeneration: The hypervisor generation of the Virtual Machine. Applicable
	//to OS disks only.
	HyperVGeneration *DiskPropertiesStatusHyperVGeneration `json:"hyperVGeneration,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Location: Resource location
	Location *string `json:"location,omitempty"`

	//ManagedBy: A relative URI containing the ID of the VM that has the disk attached.
	ManagedBy *string `json:"managedBy,omitempty"`

	//ManagedByExtended: List of relative URIs containing the IDs of the VMs that have
	//the disk attached. maxShares should be set to a value greater than one for disks
	//to allow attaching them to multiple VMs.
	ManagedByExtended []string `json:"managedByExtended,omitempty"`

	//MaxShares: The maximum number of VMs that can attach to the disk at the same
	//time. Value greater than one indicates a disk that can be mounted on multiple
	//VMs at the same time.
	MaxShares *int `json:"maxShares,omitempty"`

	//Name: Resource name
	Name                *string                     `json:"name,omitempty"`
	NetworkAccessPolicy *NetworkAccessPolicy_Status `json:"networkAccessPolicy,omitempty"`

	//OsType: The Operating System type.
	OsType *DiskPropertiesStatusOsType `json:"osType,omitempty"`

	//ProvisioningState: The disk provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//PurchasePlan: Purchase plan information for the the image from which the OS disk
	//was created. E.g. - {name: 2019-Datacenter, publisher: MicrosoftWindowsServer,
	//product: WindowsServer}
	PurchasePlan *PurchasePlan_Status `json:"purchasePlan,omitempty"`

	//ShareInfo: Details of the list of all VMs that have the disk attached. maxShares
	//should be set to a value greater than one for disks to allow attaching them to
	//multiple VMs.
	ShareInfo []ShareInfoElement_Status `json:"shareInfo,omitempty"`
	Sku       *DiskSku_Status           `json:"sku,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//Tier: Performance tier of the disk (e.g, P4, S10) as described here:
	//https://azure.microsoft.com/en-us/pricing/details/managed-disks/. Does not apply
	//to Ultra disks.
	Tier *string `json:"tier,omitempty"`

	//TimeCreated: The time when the disk was created.
	TimeCreated *string `json:"timeCreated,omitempty"`

	//Type: Resource type
	Type *string `json:"type,omitempty"`

	//UniqueId: Unique Guid identifying the resource.
	UniqueId *string `json:"uniqueId,omitempty"`

	//Zones: The Logical zone list for Disk.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Disk_Status{}

// ConvertStatusFrom populates our Disk_Status from the provided source
func (diskStatus *Disk_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20200930storage.Disk_Status)
	if ok {
		// Populate our instance from source
		return diskStatus.AssignPropertiesFromDiskStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20200930storage.Disk_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = diskStatus.AssignPropertiesFromDiskStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Disk_Status
func (diskStatus *Disk_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20200930storage.Disk_Status)
	if ok {
		// Populate destination from our instance
		return diskStatus.AssignPropertiesToDiskStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20200930storage.Disk_Status{}
	err := diskStatus.AssignPropertiesToDiskStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Disk_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diskStatus *Disk_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Disk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diskStatus *Disk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Disk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Disk_StatusARM, got %T", armInput)
	}

	// Set property ‘BurstingEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BurstingEnabled != nil {
			burstingEnabled := *typedInput.Properties.BurstingEnabled
			diskStatus.BurstingEnabled = &burstingEnabled
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘CreationData’:
	// copying flattened property:
	if typedInput.Properties != nil {
		var temp CreationData_Status
		var temp1 CreationData_Status
		err := temp1.PopulateFromARM(owner, typedInput.Properties.CreationData)
		if err != nil {
			return err
		}
		temp = temp1
		diskStatus.CreationData = &temp
	}

	// Set property ‘DiskAccessId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskAccessId != nil {
			diskAccessId := *typedInput.Properties.DiskAccessId
			diskStatus.DiskAccessId = &diskAccessId
		}
	}

	// Set property ‘DiskIOPSReadOnly’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskIOPSReadOnly != nil {
			diskIOPSReadOnly := *typedInput.Properties.DiskIOPSReadOnly
			diskStatus.DiskIOPSReadOnly = &diskIOPSReadOnly
		}
	}

	// Set property ‘DiskIOPSReadWrite’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskIOPSReadWrite != nil {
			diskIOPSReadWrite := *typedInput.Properties.DiskIOPSReadWrite
			diskStatus.DiskIOPSReadWrite = &diskIOPSReadWrite
		}
	}

	// Set property ‘DiskMBpsReadOnly’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskMBpsReadOnly != nil {
			diskMBpsReadOnly := *typedInput.Properties.DiskMBpsReadOnly
			diskStatus.DiskMBpsReadOnly = &diskMBpsReadOnly
		}
	}

	// Set property ‘DiskMBpsReadWrite’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskMBpsReadWrite != nil {
			diskMBpsReadWrite := *typedInput.Properties.DiskMBpsReadWrite
			diskStatus.DiskMBpsReadWrite = &diskMBpsReadWrite
		}
	}

	// Set property ‘DiskSizeBytes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskSizeBytes != nil {
			diskSizeBytes := *typedInput.Properties.DiskSizeBytes
			diskStatus.DiskSizeBytes = &diskSizeBytes
		}
	}

	// Set property ‘DiskSizeGB’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskSizeGB != nil {
			diskSizeGB := *typedInput.Properties.DiskSizeGB
			diskStatus.DiskSizeGB = &diskSizeGB
		}
	}

	// Set property ‘DiskState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskState != nil {
			diskState := *typedInput.Properties.DiskState
			diskStatus.DiskState = &diskState
		}
	}

	// Set property ‘Encryption’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 Encryption_Status
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			diskStatus.Encryption = &encryption
		}
	}

	// Set property ‘EncryptionSettingsCollection’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionSettingsCollection != nil {
			var encryptionSettingsCollection1 EncryptionSettingsCollection_Status
			err := encryptionSettingsCollection1.PopulateFromARM(owner, *typedInput.Properties.EncryptionSettingsCollection)
			if err != nil {
				return err
			}
			encryptionSettingsCollection := encryptionSettingsCollection1
			diskStatus.EncryptionSettingsCollection = &encryptionSettingsCollection
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		diskStatus.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HyperVGeneration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HyperVGeneration != nil {
			hyperVGeneration := *typedInput.Properties.HyperVGeneration
			diskStatus.HyperVGeneration = &hyperVGeneration
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		diskStatus.Id = &id
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		diskStatus.Location = &location
	}

	// Set property ‘ManagedBy’:
	if typedInput.ManagedBy != nil {
		managedBy := *typedInput.ManagedBy
		diskStatus.ManagedBy = &managedBy
	}

	// Set property ‘ManagedByExtended’:
	for _, item := range typedInput.ManagedByExtended {
		diskStatus.ManagedByExtended = append(diskStatus.ManagedByExtended, item)
	}

	// Set property ‘MaxShares’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxShares != nil {
			maxShares := *typedInput.Properties.MaxShares
			diskStatus.MaxShares = &maxShares
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		diskStatus.Name = &name
	}

	// Set property ‘NetworkAccessPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkAccessPolicy != nil {
			networkAccessPolicy := *typedInput.Properties.NetworkAccessPolicy
			diskStatus.NetworkAccessPolicy = &networkAccessPolicy
		}
	}

	// Set property ‘OsType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsType != nil {
			osType := *typedInput.Properties.OsType
			diskStatus.OsType = &osType
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			diskStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PurchasePlan’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PurchasePlan != nil {
			var purchasePlan1 PurchasePlan_Status
			err := purchasePlan1.PopulateFromARM(owner, *typedInput.Properties.PurchasePlan)
			if err != nil {
				return err
			}
			purchasePlan := purchasePlan1
			diskStatus.PurchasePlan = &purchasePlan
		}
	}

	// Set property ‘ShareInfo’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ShareInfo {
			var item1 ShareInfoElement_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			diskStatus.ShareInfo = append(diskStatus.ShareInfo, item1)
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 DiskSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		diskStatus.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		diskStatus.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			diskStatus.Tags[key] = value
		}
	}

	// Set property ‘Tier’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Tier != nil {
			tier := *typedInput.Properties.Tier
			diskStatus.Tier = &tier
		}
	}

	// Set property ‘TimeCreated’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TimeCreated != nil {
			timeCreated := *typedInput.Properties.TimeCreated
			diskStatus.TimeCreated = &timeCreated
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		diskStatus.Type = &typeVar
	}

	// Set property ‘UniqueId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UniqueId != nil {
			uniqueId := *typedInput.Properties.UniqueId
			diskStatus.UniqueId = &uniqueId
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		diskStatus.Zones = append(diskStatus.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskStatus populates our Disk_Status from the provided source Disk_Status
func (diskStatus *Disk_Status) AssignPropertiesFromDiskStatus(source *v1alpha1api20200930storage.Disk_Status) error {

	// BurstingEnabled
	if source.BurstingEnabled != nil {
		burstingEnabled := *source.BurstingEnabled
		diskStatus.BurstingEnabled = &burstingEnabled
	} else {
		diskStatus.BurstingEnabled = nil
	}

	// Conditions
	conditionList := make([]conditions.Condition, len(source.Conditions))
	for conditionIndex, conditionItem := range source.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	diskStatus.Conditions = conditionList

	// CreationData
	if source.CreationData != nil {
		var creationDatum CreationData_Status
		err := creationDatum.AssignPropertiesFromCreationDataStatus(source.CreationData)
		if err != nil {
			return errors.Wrap(err, "populating CreationData from CreationData, calling AssignPropertiesFromCreationDataStatus()")
		}
		diskStatus.CreationData = &creationDatum
	} else {
		diskStatus.CreationData = nil
	}

	// DiskAccessId
	if source.DiskAccessId != nil {
		diskAccessId := *source.DiskAccessId
		diskStatus.DiskAccessId = &diskAccessId
	} else {
		diskStatus.DiskAccessId = nil
	}

	// DiskIOPSReadOnly
	if source.DiskIOPSReadOnly != nil {
		diskIOPSReadOnly := *source.DiskIOPSReadOnly
		diskStatus.DiskIOPSReadOnly = &diskIOPSReadOnly
	} else {
		diskStatus.DiskIOPSReadOnly = nil
	}

	// DiskIOPSReadWrite
	if source.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *source.DiskIOPSReadWrite
		diskStatus.DiskIOPSReadWrite = &diskIOPSReadWrite
	} else {
		diskStatus.DiskIOPSReadWrite = nil
	}

	// DiskMBpsReadOnly
	if source.DiskMBpsReadOnly != nil {
		diskMBpsReadOnly := *source.DiskMBpsReadOnly
		diskStatus.DiskMBpsReadOnly = &diskMBpsReadOnly
	} else {
		diskStatus.DiskMBpsReadOnly = nil
	}

	// DiskMBpsReadWrite
	if source.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *source.DiskMBpsReadWrite
		diskStatus.DiskMBpsReadWrite = &diskMBpsReadWrite
	} else {
		diskStatus.DiskMBpsReadWrite = nil
	}

	// DiskSizeBytes
	if source.DiskSizeBytes != nil {
		diskSizeByte := *source.DiskSizeBytes
		diskStatus.DiskSizeBytes = &diskSizeByte
	} else {
		diskStatus.DiskSizeBytes = nil
	}

	// DiskSizeGB
	if source.DiskSizeGB != nil {
		diskSizeGB := *source.DiskSizeGB
		diskStatus.DiskSizeGB = &diskSizeGB
	} else {
		diskStatus.DiskSizeGB = nil
	}

	// DiskState
	if source.DiskState != nil {
		diskState := DiskState_Status(*source.DiskState)
		diskStatus.DiskState = &diskState
	} else {
		diskStatus.DiskState = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption Encryption_Status
		err := encryption.AssignPropertiesFromEncryptionStatus(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "populating Encryption from Encryption, calling AssignPropertiesFromEncryptionStatus()")
		}
		diskStatus.Encryption = &encryption
	} else {
		diskStatus.Encryption = nil
	}

	// EncryptionSettingsCollection
	if source.EncryptionSettingsCollection != nil {
		var encryptionSettingsCollection EncryptionSettingsCollection_Status
		err := encryptionSettingsCollection.AssignPropertiesFromEncryptionSettingsCollectionStatus(source.EncryptionSettingsCollection)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettingsCollection from EncryptionSettingsCollection, calling AssignPropertiesFromEncryptionSettingsCollectionStatus()")
		}
		diskStatus.EncryptionSettingsCollection = &encryptionSettingsCollection
	} else {
		diskStatus.EncryptionSettingsCollection = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		diskStatus.ExtendedLocation = &extendedLocation
	} else {
		diskStatus.ExtendedLocation = nil
	}

	// HyperVGeneration
	if source.HyperVGeneration != nil {
		hyperVGeneration := DiskPropertiesStatusHyperVGeneration(*source.HyperVGeneration)
		diskStatus.HyperVGeneration = &hyperVGeneration
	} else {
		diskStatus.HyperVGeneration = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		diskStatus.Id = &id
	} else {
		diskStatus.Id = nil
	}

	// Location
	if source.Location != nil {
		location := *source.Location
		diskStatus.Location = &location
	} else {
		diskStatus.Location = nil
	}

	// ManagedBy
	if source.ManagedBy != nil {
		managedBy := *source.ManagedBy
		diskStatus.ManagedBy = &managedBy
	} else {
		diskStatus.ManagedBy = nil
	}

	// ManagedByExtended
	managedByExtendedList := make([]string, len(source.ManagedByExtended))
	for managedByExtendedIndex, managedByExtendedItem := range source.ManagedByExtended {
		// Shadow the loop variable to avoid aliasing
		managedByExtendedItem := managedByExtendedItem
		managedByExtendedList[managedByExtendedIndex] = managedByExtendedItem
	}
	diskStatus.ManagedByExtended = managedByExtendedList

	// MaxShares
	if source.MaxShares != nil {
		maxShare := *source.MaxShares
		diskStatus.MaxShares = &maxShare
	} else {
		diskStatus.MaxShares = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		diskStatus.Name = &name
	} else {
		diskStatus.Name = nil
	}

	// NetworkAccessPolicy
	if source.NetworkAccessPolicy != nil {
		networkAccessPolicy := NetworkAccessPolicy_Status(*source.NetworkAccessPolicy)
		diskStatus.NetworkAccessPolicy = &networkAccessPolicy
	} else {
		diskStatus.NetworkAccessPolicy = nil
	}

	// OsType
	if source.OsType != nil {
		osType := DiskPropertiesStatusOsType(*source.OsType)
		diskStatus.OsType = &osType
	} else {
		diskStatus.OsType = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		diskStatus.ProvisioningState = &provisioningState
	} else {
		diskStatus.ProvisioningState = nil
	}

	// PurchasePlan
	if source.PurchasePlan != nil {
		var purchasePlan PurchasePlan_Status
		err := purchasePlan.AssignPropertiesFromPurchasePlanStatus(source.PurchasePlan)
		if err != nil {
			return errors.Wrap(err, "populating PurchasePlan from PurchasePlan, calling AssignPropertiesFromPurchasePlanStatus()")
		}
		diskStatus.PurchasePlan = &purchasePlan
	} else {
		diskStatus.PurchasePlan = nil
	}

	// ShareInfo
	shareInfoList := make([]ShareInfoElement_Status, len(source.ShareInfo))
	for shareInfoIndex, shareInfoItem := range source.ShareInfo {
		// Shadow the loop variable to avoid aliasing
		shareInfoItem := shareInfoItem
		var shareInfo ShareInfoElement_Status
		err := shareInfo.AssignPropertiesFromShareInfoElementStatus(&shareInfoItem)
		if err != nil {
			return errors.Wrap(err, "populating ShareInfo from ShareInfo, calling AssignPropertiesFromShareInfoElementStatus()")
		}
		shareInfoList[shareInfoIndex] = shareInfo
	}
	diskStatus.ShareInfo = shareInfoList

	// Sku
	if source.Sku != nil {
		var sku DiskSku_Status
		err := sku.AssignPropertiesFromDiskSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromDiskSkuStatus()")
		}
		diskStatus.Sku = &sku
	} else {
		diskStatus.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	diskStatus.Tags = tagMap

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		diskStatus.Tier = &tier
	} else {
		diskStatus.Tier = nil
	}

	// TimeCreated
	if source.TimeCreated != nil {
		timeCreated := *source.TimeCreated
		diskStatus.TimeCreated = &timeCreated
	} else {
		diskStatus.TimeCreated = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		diskStatus.Type = &typeVar
	} else {
		diskStatus.Type = nil
	}

	// UniqueId
	if source.UniqueId != nil {
		uniqueId := *source.UniqueId
		diskStatus.UniqueId = &uniqueId
	} else {
		diskStatus.UniqueId = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	diskStatus.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToDiskStatus populates the provided destination Disk_Status from our Disk_Status
func (diskStatus *Disk_Status) AssignPropertiesToDiskStatus(destination *v1alpha1api20200930storage.Disk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BurstingEnabled
	if diskStatus.BurstingEnabled != nil {
		burstingEnabled := *diskStatus.BurstingEnabled
		destination.BurstingEnabled = &burstingEnabled
	} else {
		destination.BurstingEnabled = nil
	}

	// Conditions
	conditionList := make([]conditions.Condition, len(diskStatus.Conditions))
	for conditionIndex, conditionItem := range diskStatus.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	destination.Conditions = conditionList

	// CreationData
	if diskStatus.CreationData != nil {
		var creationDatum v1alpha1api20200930storage.CreationData_Status
		err := (*diskStatus.CreationData).AssignPropertiesToCreationDataStatus(&creationDatum)
		if err != nil {
			return errors.Wrap(err, "populating CreationData from CreationData, calling AssignPropertiesToCreationDataStatus()")
		}
		destination.CreationData = &creationDatum
	} else {
		destination.CreationData = nil
	}

	// DiskAccessId
	if diskStatus.DiskAccessId != nil {
		diskAccessId := *diskStatus.DiskAccessId
		destination.DiskAccessId = &diskAccessId
	} else {
		destination.DiskAccessId = nil
	}

	// DiskIOPSReadOnly
	if diskStatus.DiskIOPSReadOnly != nil {
		diskIOPSReadOnly := *diskStatus.DiskIOPSReadOnly
		destination.DiskIOPSReadOnly = &diskIOPSReadOnly
	} else {
		destination.DiskIOPSReadOnly = nil
	}

	// DiskIOPSReadWrite
	if diskStatus.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *diskStatus.DiskIOPSReadWrite
		destination.DiskIOPSReadWrite = &diskIOPSReadWrite
	} else {
		destination.DiskIOPSReadWrite = nil
	}

	// DiskMBpsReadOnly
	if diskStatus.DiskMBpsReadOnly != nil {
		diskMBpsReadOnly := *diskStatus.DiskMBpsReadOnly
		destination.DiskMBpsReadOnly = &diskMBpsReadOnly
	} else {
		destination.DiskMBpsReadOnly = nil
	}

	// DiskMBpsReadWrite
	if diskStatus.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *diskStatus.DiskMBpsReadWrite
		destination.DiskMBpsReadWrite = &diskMBpsReadWrite
	} else {
		destination.DiskMBpsReadWrite = nil
	}

	// DiskSizeBytes
	if diskStatus.DiskSizeBytes != nil {
		diskSizeByte := *diskStatus.DiskSizeBytes
		destination.DiskSizeBytes = &diskSizeByte
	} else {
		destination.DiskSizeBytes = nil
	}

	// DiskSizeGB
	if diskStatus.DiskSizeGB != nil {
		diskSizeGB := *diskStatus.DiskSizeGB
		destination.DiskSizeGB = &diskSizeGB
	} else {
		destination.DiskSizeGB = nil
	}

	// DiskState
	if diskStatus.DiskState != nil {
		diskState := string(*diskStatus.DiskState)
		destination.DiskState = &diskState
	} else {
		destination.DiskState = nil
	}

	// Encryption
	if diskStatus.Encryption != nil {
		var encryption v1alpha1api20200930storage.Encryption_Status
		err := (*diskStatus.Encryption).AssignPropertiesToEncryptionStatus(&encryption)
		if err != nil {
			return errors.Wrap(err, "populating Encryption from Encryption, calling AssignPropertiesToEncryptionStatus()")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// EncryptionSettingsCollection
	if diskStatus.EncryptionSettingsCollection != nil {
		var encryptionSettingsCollection v1alpha1api20200930storage.EncryptionSettingsCollection_Status
		err := (*diskStatus.EncryptionSettingsCollection).AssignPropertiesToEncryptionSettingsCollectionStatus(&encryptionSettingsCollection)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettingsCollection from EncryptionSettingsCollection, calling AssignPropertiesToEncryptionSettingsCollectionStatus()")
		}
		destination.EncryptionSettingsCollection = &encryptionSettingsCollection
	} else {
		destination.EncryptionSettingsCollection = nil
	}

	// ExtendedLocation
	if diskStatus.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20200930storage.ExtendedLocation_Status
		err := (*diskStatus.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HyperVGeneration
	if diskStatus.HyperVGeneration != nil {
		hyperVGeneration := string(*diskStatus.HyperVGeneration)
		destination.HyperVGeneration = &hyperVGeneration
	} else {
		destination.HyperVGeneration = nil
	}

	// Id
	if diskStatus.Id != nil {
		id := *diskStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Location
	if diskStatus.Location != nil {
		location := *diskStatus.Location
		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// ManagedBy
	if diskStatus.ManagedBy != nil {
		managedBy := *diskStatus.ManagedBy
		destination.ManagedBy = &managedBy
	} else {
		destination.ManagedBy = nil
	}

	// ManagedByExtended
	managedByExtendedList := make([]string, len(diskStatus.ManagedByExtended))
	for managedByExtendedIndex, managedByExtendedItem := range diskStatus.ManagedByExtended {
		// Shadow the loop variable to avoid aliasing
		managedByExtendedItem := managedByExtendedItem
		managedByExtendedList[managedByExtendedIndex] = managedByExtendedItem
	}
	destination.ManagedByExtended = managedByExtendedList

	// MaxShares
	if diskStatus.MaxShares != nil {
		maxShare := *diskStatus.MaxShares
		destination.MaxShares = &maxShare
	} else {
		destination.MaxShares = nil
	}

	// Name
	if diskStatus.Name != nil {
		name := *diskStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// NetworkAccessPolicy
	if diskStatus.NetworkAccessPolicy != nil {
		networkAccessPolicy := string(*diskStatus.NetworkAccessPolicy)
		destination.NetworkAccessPolicy = &networkAccessPolicy
	} else {
		destination.NetworkAccessPolicy = nil
	}

	// OsType
	if diskStatus.OsType != nil {
		osType := string(*diskStatus.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// ProvisioningState
	if diskStatus.ProvisioningState != nil {
		provisioningState := *diskStatus.ProvisioningState
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PurchasePlan
	if diskStatus.PurchasePlan != nil {
		var purchasePlan v1alpha1api20200930storage.PurchasePlan_Status
		err := (*diskStatus.PurchasePlan).AssignPropertiesToPurchasePlanStatus(&purchasePlan)
		if err != nil {
			return errors.Wrap(err, "populating PurchasePlan from PurchasePlan, calling AssignPropertiesToPurchasePlanStatus()")
		}
		destination.PurchasePlan = &purchasePlan
	} else {
		destination.PurchasePlan = nil
	}

	// ShareInfo
	shareInfoList := make([]v1alpha1api20200930storage.ShareInfoElement_Status, len(diskStatus.ShareInfo))
	for shareInfoIndex, shareInfoItem := range diskStatus.ShareInfo {
		// Shadow the loop variable to avoid aliasing
		shareInfoItem := shareInfoItem
		var shareInfo v1alpha1api20200930storage.ShareInfoElement_Status
		err := shareInfoItem.AssignPropertiesToShareInfoElementStatus(&shareInfo)
		if err != nil {
			return errors.Wrap(err, "populating ShareInfo from ShareInfo, calling AssignPropertiesToShareInfoElementStatus()")
		}
		shareInfoList[shareInfoIndex] = shareInfo
	}
	destination.ShareInfo = shareInfoList

	// Sku
	if diskStatus.Sku != nil {
		var sku v1alpha1api20200930storage.DiskSku_Status
		err := (*diskStatus.Sku).AssignPropertiesToDiskSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToDiskSkuStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range diskStatus.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Tier
	if diskStatus.Tier != nil {
		tier := *diskStatus.Tier
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// TimeCreated
	if diskStatus.TimeCreated != nil {
		timeCreated := *diskStatus.TimeCreated
		destination.TimeCreated = &timeCreated
	} else {
		destination.TimeCreated = nil
	}

	// Type
	if diskStatus.Type != nil {
		typeVar := *diskStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UniqueId
	if diskStatus.UniqueId != nil {
		uniqueId := *diskStatus.UniqueId
		destination.UniqueId = &uniqueId
	} else {
		destination.UniqueId = nil
	}

	// Zones
	zoneList := make([]string, len(diskStatus.Zones))
	for zoneIndex, zoneItem := range diskStatus.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type Disks_Spec struct {
	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//BurstingEnabled: Set to true to enable bursting beyond the provisioned
	//performance target of the disk. Bursting is disabled by default. Does not apply
	//to Ultra disks.
	BurstingEnabled *bool `json:"burstingEnabled,omitempty"`

	// +kubebuilder:validation:Required
	//CreationData: Data used when creating a disk.
	CreationData CreationData `json:"creationData"`

	//DiskAccessReference: ARM id of the DiskAccess resource for using private
	//endpoints on disks.
	DiskAccessReference *genruntime.ResourceReference `armReference:"DiskAccessId" json:"diskAccessReference,omitempty"`

	//DiskIOPSReadOnly: The total number of IOPS that will be allowed across all VMs
	//mounting the shared disk as ReadOnly. One operation can transfer between 4k and
	//256k bytes.
	DiskIOPSReadOnly *int `json:"diskIOPSReadOnly,omitempty"`

	//DiskIOPSReadWrite: The number of IOPS allowed for this disk; only settable for
	//UltraSSD disks. One operation can transfer between 4k and 256k bytes.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	//DiskMBpsReadOnly: The total throughput (MBps) that will be allowed across all
	//VMs mounting the shared disk as ReadOnly. MBps means millions of bytes per
	//second - MB here uses the ISO notation, of powers of 10.
	DiskMBpsReadOnly *int `json:"diskMBpsReadOnly,omitempty"`

	//DiskMBpsReadWrite: The bandwidth allowed for this disk; only settable for
	//UltraSSD disks. MBps means millions of bytes per second - MB here uses the ISO
	//notation, of powers of 10.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	//DiskSizeGB: If creationData.createOption is Empty, this field is mandatory and
	//it indicates the size of the disk to create. If this field is present for
	//updates or creation with other options, it indicates a resize. Resizes are only
	//allowed if the disk is not attached to a running VM, and can only increase the
	//disk's size.
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//Encryption: Encryption at rest settings for disk or snapshot
	Encryption *Encryption `json:"encryption,omitempty"`

	//EncryptionSettingsCollection: Encryption settings for disk or snapshot
	EncryptionSettingsCollection *EncryptionSettingsCollection `json:"encryptionSettingsCollection,omitempty"`

	//ExtendedLocation: The complex type of the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	//HyperVGeneration: The hypervisor generation of the Virtual Machine. Applicable
	//to OS disks only.
	HyperVGeneration *DiskPropertiesHyperVGeneration `json:"hyperVGeneration,omitempty"`

	//Location: Location to deploy resource to
	Location string `json:"location,omitempty"`

	//MaxShares: The maximum number of VMs that can attach to the disk at the same
	//time. Value greater than one indicates a disk that can be mounted on multiple
	//VMs at the same time.
	MaxShares           *int                               `json:"maxShares,omitempty"`
	NetworkAccessPolicy *DiskPropertiesNetworkAccessPolicy `json:"networkAccessPolicy,omitempty"`

	//OsType: The Operating System type.
	OsType *DiskPropertiesOsType `json:"osType,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"microsoft.resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//PurchasePlan: Used for establishing the purchase context of any 3rd Party
	//artifact through MarketPlace.
	PurchasePlan *PurchasePlan `json:"purchasePlan,omitempty"`

	//Sku: The disks sku name. Can be Standard_LRS, Premium_LRS, StandardSSD_LRS, or
	//UltraSSD_LRS.
	Sku *DiskSku `json:"sku,omitempty"`

	//Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`

	//Tier: Performance tier of the disk (e.g, P4, S10) as described here:
	//https://azure.microsoft.com/en-us/pricing/details/managed-disks/. Does not apply
	//to Ultra disks.
	Tier *string `json:"tier,omitempty"`

	//Zones: The Logical zone list for Disk.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &Disks_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disksSpec *Disks_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disksSpec == nil {
		return nil, nil
	}
	var result Disks_SpecARM

	// Set property ‘APIVersion’:
	result.APIVersion = DisksSpecAPIVersion20200930

	// Set property ‘ExtendedLocation’:
	if disksSpec.ExtendedLocation != nil {
		extendedLocationARM, err := (*disksSpec.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Location’:
	result.Location = disksSpec.Location

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if disksSpec.BurstingEnabled != nil {
		burstingEnabled := *disksSpec.BurstingEnabled
		result.Properties.BurstingEnabled = &burstingEnabled
	}
	creationDataARM, err := disksSpec.CreationData.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.Properties.CreationData = creationDataARM.(CreationDataARM)
	if disksSpec.DiskAccessReference != nil {
		diskAccessIdARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*disksSpec.DiskAccessReference)
		if err != nil {
			return nil, err
		}
		diskAccessId := diskAccessIdARMID
		result.Properties.DiskAccessId = &diskAccessId
	}
	if disksSpec.DiskIOPSReadOnly != nil {
		diskIOPSReadOnly := *disksSpec.DiskIOPSReadOnly
		result.Properties.DiskIOPSReadOnly = &diskIOPSReadOnly
	}
	if disksSpec.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *disksSpec.DiskIOPSReadWrite
		result.Properties.DiskIOPSReadWrite = &diskIOPSReadWrite
	}
	if disksSpec.DiskMBpsReadOnly != nil {
		diskMBpsReadOnly := *disksSpec.DiskMBpsReadOnly
		result.Properties.DiskMBpsReadOnly = &diskMBpsReadOnly
	}
	if disksSpec.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *disksSpec.DiskMBpsReadWrite
		result.Properties.DiskMBpsReadWrite = &diskMBpsReadWrite
	}
	if disksSpec.DiskSizeGB != nil {
		diskSizeGB := *disksSpec.DiskSizeGB
		result.Properties.DiskSizeGB = &diskSizeGB
	}
	if disksSpec.Encryption != nil {
		encryptionARM, err := (*disksSpec.Encryption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := encryptionARM.(EncryptionARM)
		result.Properties.Encryption = &encryption
	}
	if disksSpec.EncryptionSettingsCollection != nil {
		encryptionSettingsCollectionARM, err := (*disksSpec.EncryptionSettingsCollection).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionSettingsCollection := encryptionSettingsCollectionARM.(EncryptionSettingsCollectionARM)
		result.Properties.EncryptionSettingsCollection = &encryptionSettingsCollection
	}
	if disksSpec.HyperVGeneration != nil {
		hyperVGeneration := *disksSpec.HyperVGeneration
		result.Properties.HyperVGeneration = &hyperVGeneration
	}
	if disksSpec.MaxShares != nil {
		maxShares := *disksSpec.MaxShares
		result.Properties.MaxShares = &maxShares
	}
	if disksSpec.NetworkAccessPolicy != nil {
		networkAccessPolicy := *disksSpec.NetworkAccessPolicy
		result.Properties.NetworkAccessPolicy = &networkAccessPolicy
	}
	if disksSpec.OsType != nil {
		osType := *disksSpec.OsType
		result.Properties.OsType = &osType
	}
	if disksSpec.PurchasePlan != nil {
		purchasePlanARM, err := (*disksSpec.PurchasePlan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		purchasePlan := purchasePlanARM.(PurchasePlanARM)
		result.Properties.PurchasePlan = &purchasePlan
	}
	if disksSpec.Tier != nil {
		tier := *disksSpec.Tier
		result.Properties.Tier = &tier
	}

	// Set property ‘Sku’:
	if disksSpec.Sku != nil {
		skuARM, err := (*disksSpec.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(DiskSkuARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if disksSpec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range disksSpec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	result.Type = DisksSpecTypeMicrosoftComputeDisks

	// Set property ‘Zones’:
	for _, item := range disksSpec.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disksSpec *Disks_Spec) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Disks_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disksSpec *Disks_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Disks_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Disks_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	disksSpec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘BurstingEnabled’:
	// copying flattened property:
	if typedInput.Properties.BurstingEnabled != nil {
		burstingEnabled := *typedInput.Properties.BurstingEnabled
		disksSpec.BurstingEnabled = &burstingEnabled
	}

	// Set property ‘CreationData’:
	// copying flattened property:
	var creationData CreationData
	err := creationData.PopulateFromARM(owner, typedInput.Properties.CreationData)
	if err != nil {
		return err
	}
	disksSpec.CreationData = creationData

	// no assignment for property ‘DiskAccessReference’

	// Set property ‘DiskIOPSReadOnly’:
	// copying flattened property:
	if typedInput.Properties.DiskIOPSReadOnly != nil {
		diskIOPSReadOnly := *typedInput.Properties.DiskIOPSReadOnly
		disksSpec.DiskIOPSReadOnly = &diskIOPSReadOnly
	}

	// Set property ‘DiskIOPSReadWrite’:
	// copying flattened property:
	if typedInput.Properties.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.Properties.DiskIOPSReadWrite
		disksSpec.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadOnly’:
	// copying flattened property:
	if typedInput.Properties.DiskMBpsReadOnly != nil {
		diskMBpsReadOnly := *typedInput.Properties.DiskMBpsReadOnly
		disksSpec.DiskMBpsReadOnly = &diskMBpsReadOnly
	}

	// Set property ‘DiskMBpsReadWrite’:
	// copying flattened property:
	if typedInput.Properties.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.Properties.DiskMBpsReadWrite
		disksSpec.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	// copying flattened property:
	if typedInput.Properties.DiskSizeGB != nil {
		diskSizeGB := *typedInput.Properties.DiskSizeGB
		disksSpec.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Encryption’:
	// copying flattened property:
	if typedInput.Properties.Encryption != nil {
		var encryption1 Encryption
		err = encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
		if err != nil {
			return err
		}
		encryption := encryption1
		disksSpec.Encryption = &encryption
	}

	// Set property ‘EncryptionSettingsCollection’:
	// copying flattened property:
	if typedInput.Properties.EncryptionSettingsCollection != nil {
		var encryptionSettingsCollection1 EncryptionSettingsCollection
		err = encryptionSettingsCollection1.PopulateFromARM(owner, *typedInput.Properties.EncryptionSettingsCollection)
		if err != nil {
			return err
		}
		encryptionSettingsCollection := encryptionSettingsCollection1
		disksSpec.EncryptionSettingsCollection = &encryptionSettingsCollection
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err = extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		disksSpec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HyperVGeneration’:
	// copying flattened property:
	if typedInput.Properties.HyperVGeneration != nil {
		hyperVGeneration := *typedInput.Properties.HyperVGeneration
		disksSpec.HyperVGeneration = &hyperVGeneration
	}

	// Set property ‘Location’:
	disksSpec.Location = typedInput.Location

	// Set property ‘MaxShares’:
	// copying flattened property:
	if typedInput.Properties.MaxShares != nil {
		maxShares := *typedInput.Properties.MaxShares
		disksSpec.MaxShares = &maxShares
	}

	// Set property ‘NetworkAccessPolicy’:
	// copying flattened property:
	if typedInput.Properties.NetworkAccessPolicy != nil {
		networkAccessPolicy := *typedInput.Properties.NetworkAccessPolicy
		disksSpec.NetworkAccessPolicy = &networkAccessPolicy
	}

	// Set property ‘OsType’:
	// copying flattened property:
	if typedInput.Properties.OsType != nil {
		osType := *typedInput.Properties.OsType
		disksSpec.OsType = &osType
	}

	// Set property ‘Owner’:
	disksSpec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘PurchasePlan’:
	// copying flattened property:
	if typedInput.Properties.PurchasePlan != nil {
		var purchasePlan1 PurchasePlan
		err = purchasePlan1.PopulateFromARM(owner, *typedInput.Properties.PurchasePlan)
		if err != nil {
			return err
		}
		purchasePlan := purchasePlan1
		disksSpec.PurchasePlan = &purchasePlan
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 DiskSku
		err = sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		disksSpec.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		disksSpec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			disksSpec.Tags[key] = value
		}
	}

	// Set property ‘Tier’:
	// copying flattened property:
	if typedInput.Properties.Tier != nil {
		tier := *typedInput.Properties.Tier
		disksSpec.Tier = &tier
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		disksSpec.Zones = append(disksSpec.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Disks_Spec{}

// ConvertSpecFrom populates our Disks_Spec from the provided source
func (disksSpec *Disks_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20200930storage.Disks_Spec)
	if ok {
		// Populate our instance from source
		return disksSpec.AssignPropertiesFromDisksSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20200930storage.Disks_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = disksSpec.AssignPropertiesFromDisksSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Disks_Spec
func (disksSpec *Disks_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20200930storage.Disks_Spec)
	if ok {
		// Populate destination from our instance
		return disksSpec.AssignPropertiesToDisksSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20200930storage.Disks_Spec{}
	err := disksSpec.AssignPropertiesToDisksSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromDisksSpec populates our Disks_Spec from the provided source Disks_Spec
func (disksSpec *Disks_Spec) AssignPropertiesFromDisksSpec(source *v1alpha1api20200930storage.Disks_Spec) error {

	// AzureName
	disksSpec.AzureName = source.AzureName

	// BurstingEnabled
	if source.BurstingEnabled != nil {
		burstingEnabled := *source.BurstingEnabled
		disksSpec.BurstingEnabled = &burstingEnabled
	} else {
		disksSpec.BurstingEnabled = nil
	}

	// CreationData
	if source.CreationData != nil {
		var creationDatum CreationData
		err := creationDatum.AssignPropertiesFromCreationData(source.CreationData)
		if err != nil {
			return errors.Wrap(err, "populating CreationData from CreationData, calling AssignPropertiesFromCreationData()")
		}
		disksSpec.CreationData = creationDatum
	} else {
		disksSpec.CreationData = CreationData{}
	}

	// DiskAccessReference
	if source.DiskAccessReference != nil {
		diskAccessReference := source.DiskAccessReference.Copy()
		disksSpec.DiskAccessReference = &diskAccessReference
	} else {
		disksSpec.DiskAccessReference = nil
	}

	// DiskIOPSReadOnly
	if source.DiskIOPSReadOnly != nil {
		diskIOPSReadOnly := *source.DiskIOPSReadOnly
		disksSpec.DiskIOPSReadOnly = &diskIOPSReadOnly
	} else {
		disksSpec.DiskIOPSReadOnly = nil
	}

	// DiskIOPSReadWrite
	if source.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *source.DiskIOPSReadWrite
		disksSpec.DiskIOPSReadWrite = &diskIOPSReadWrite
	} else {
		disksSpec.DiskIOPSReadWrite = nil
	}

	// DiskMBpsReadOnly
	if source.DiskMBpsReadOnly != nil {
		diskMBpsReadOnly := *source.DiskMBpsReadOnly
		disksSpec.DiskMBpsReadOnly = &diskMBpsReadOnly
	} else {
		disksSpec.DiskMBpsReadOnly = nil
	}

	// DiskMBpsReadWrite
	if source.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *source.DiskMBpsReadWrite
		disksSpec.DiskMBpsReadWrite = &diskMBpsReadWrite
	} else {
		disksSpec.DiskMBpsReadWrite = nil
	}

	// DiskSizeGB
	if source.DiskSizeGB != nil {
		diskSizeGB := *source.DiskSizeGB
		disksSpec.DiskSizeGB = &diskSizeGB
	} else {
		disksSpec.DiskSizeGB = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption Encryption
		err := encryption.AssignPropertiesFromEncryption(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "populating Encryption from Encryption, calling AssignPropertiesFromEncryption()")
		}
		disksSpec.Encryption = &encryption
	} else {
		disksSpec.Encryption = nil
	}

	// EncryptionSettingsCollection
	if source.EncryptionSettingsCollection != nil {
		var encryptionSettingsCollection EncryptionSettingsCollection
		err := encryptionSettingsCollection.AssignPropertiesFromEncryptionSettingsCollection(source.EncryptionSettingsCollection)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettingsCollection from EncryptionSettingsCollection, calling AssignPropertiesFromEncryptionSettingsCollection()")
		}
		disksSpec.EncryptionSettingsCollection = &encryptionSettingsCollection
	} else {
		disksSpec.EncryptionSettingsCollection = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocation()")
		}
		disksSpec.ExtendedLocation = &extendedLocation
	} else {
		disksSpec.ExtendedLocation = nil
	}

	// HyperVGeneration
	if source.HyperVGeneration != nil {
		hyperVGeneration := DiskPropertiesHyperVGeneration(*source.HyperVGeneration)
		disksSpec.HyperVGeneration = &hyperVGeneration
	} else {
		disksSpec.HyperVGeneration = nil
	}

	// Location
	if source.Location != nil {
		disksSpec.Location = *source.Location
	} else {
		disksSpec.Location = ""
	}

	// MaxShares
	if source.MaxShares != nil {
		maxShare := *source.MaxShares
		disksSpec.MaxShares = &maxShare
	} else {
		disksSpec.MaxShares = nil
	}

	// NetworkAccessPolicy
	if source.NetworkAccessPolicy != nil {
		networkAccessPolicy := DiskPropertiesNetworkAccessPolicy(*source.NetworkAccessPolicy)
		disksSpec.NetworkAccessPolicy = &networkAccessPolicy
	} else {
		disksSpec.NetworkAccessPolicy = nil
	}

	// OsType
	if source.OsType != nil {
		osType := DiskPropertiesOsType(*source.OsType)
		disksSpec.OsType = &osType
	} else {
		disksSpec.OsType = nil
	}

	// Owner
	disksSpec.Owner = source.Owner.Copy()

	// PurchasePlan
	if source.PurchasePlan != nil {
		var purchasePlan PurchasePlan
		err := purchasePlan.AssignPropertiesFromPurchasePlan(source.PurchasePlan)
		if err != nil {
			return errors.Wrap(err, "populating PurchasePlan from PurchasePlan, calling AssignPropertiesFromPurchasePlan()")
		}
		disksSpec.PurchasePlan = &purchasePlan
	} else {
		disksSpec.PurchasePlan = nil
	}

	// Sku
	if source.Sku != nil {
		var sku DiskSku
		err := sku.AssignPropertiesFromDiskSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromDiskSku()")
		}
		disksSpec.Sku = &sku
	} else {
		disksSpec.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	disksSpec.Tags = tagMap

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		disksSpec.Tier = &tier
	} else {
		disksSpec.Tier = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	disksSpec.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToDisksSpec populates the provided destination Disks_Spec from our Disks_Spec
func (disksSpec *Disks_Spec) AssignPropertiesToDisksSpec(destination *v1alpha1api20200930storage.Disks_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = disksSpec.AzureName

	// BurstingEnabled
	if disksSpec.BurstingEnabled != nil {
		burstingEnabled := *disksSpec.BurstingEnabled
		destination.BurstingEnabled = &burstingEnabled
	} else {
		destination.BurstingEnabled = nil
	}

	// CreationData
	var creationDatum v1alpha1api20200930storage.CreationData
	err := disksSpec.CreationData.AssignPropertiesToCreationData(&creationDatum)
	if err != nil {
		return errors.Wrap(err, "populating CreationData from CreationData, calling AssignPropertiesToCreationData()")
	}
	destination.CreationData = &creationDatum

	// DiskAccessReference
	if disksSpec.DiskAccessReference != nil {
		diskAccessReference := disksSpec.DiskAccessReference.Copy()
		destination.DiskAccessReference = &diskAccessReference
	} else {
		destination.DiskAccessReference = nil
	}

	// DiskIOPSReadOnly
	if disksSpec.DiskIOPSReadOnly != nil {
		diskIOPSReadOnly := *disksSpec.DiskIOPSReadOnly
		destination.DiskIOPSReadOnly = &diskIOPSReadOnly
	} else {
		destination.DiskIOPSReadOnly = nil
	}

	// DiskIOPSReadWrite
	if disksSpec.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *disksSpec.DiskIOPSReadWrite
		destination.DiskIOPSReadWrite = &diskIOPSReadWrite
	} else {
		destination.DiskIOPSReadWrite = nil
	}

	// DiskMBpsReadOnly
	if disksSpec.DiskMBpsReadOnly != nil {
		diskMBpsReadOnly := *disksSpec.DiskMBpsReadOnly
		destination.DiskMBpsReadOnly = &diskMBpsReadOnly
	} else {
		destination.DiskMBpsReadOnly = nil
	}

	// DiskMBpsReadWrite
	if disksSpec.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *disksSpec.DiskMBpsReadWrite
		destination.DiskMBpsReadWrite = &diskMBpsReadWrite
	} else {
		destination.DiskMBpsReadWrite = nil
	}

	// DiskSizeGB
	if disksSpec.DiskSizeGB != nil {
		diskSizeGB := *disksSpec.DiskSizeGB
		destination.DiskSizeGB = &diskSizeGB
	} else {
		destination.DiskSizeGB = nil
	}

	// Encryption
	if disksSpec.Encryption != nil {
		var encryption v1alpha1api20200930storage.Encryption
		err = (*disksSpec.Encryption).AssignPropertiesToEncryption(&encryption)
		if err != nil {
			return errors.Wrap(err, "populating Encryption from Encryption, calling AssignPropertiesToEncryption()")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// EncryptionSettingsCollection
	if disksSpec.EncryptionSettingsCollection != nil {
		var encryptionSettingsCollection v1alpha1api20200930storage.EncryptionSettingsCollection
		err = (*disksSpec.EncryptionSettingsCollection).AssignPropertiesToEncryptionSettingsCollection(&encryptionSettingsCollection)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettingsCollection from EncryptionSettingsCollection, calling AssignPropertiesToEncryptionSettingsCollection()")
		}
		destination.EncryptionSettingsCollection = &encryptionSettingsCollection
	} else {
		destination.EncryptionSettingsCollection = nil
	}

	// ExtendedLocation
	if disksSpec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20200930storage.ExtendedLocation
		err = (*disksSpec.ExtendedLocation).AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocation()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HyperVGeneration
	if disksSpec.HyperVGeneration != nil {
		hyperVGeneration := string(*disksSpec.HyperVGeneration)
		destination.HyperVGeneration = &hyperVGeneration
	} else {
		destination.HyperVGeneration = nil
	}

	// Location
	location := disksSpec.Location
	destination.Location = &location

	// MaxShares
	if disksSpec.MaxShares != nil {
		maxShare := *disksSpec.MaxShares
		destination.MaxShares = &maxShare
	} else {
		destination.MaxShares = nil
	}

	// NetworkAccessPolicy
	if disksSpec.NetworkAccessPolicy != nil {
		networkAccessPolicy := string(*disksSpec.NetworkAccessPolicy)
		destination.NetworkAccessPolicy = &networkAccessPolicy
	} else {
		destination.NetworkAccessPolicy = nil
	}

	// OriginalVersion
	destination.OriginalVersion = disksSpec.OriginalVersion()

	// OsType
	if disksSpec.OsType != nil {
		osType := string(*disksSpec.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Owner
	destination.Owner = disksSpec.Owner.Copy()

	// PurchasePlan
	if disksSpec.PurchasePlan != nil {
		var purchasePlan v1alpha1api20200930storage.PurchasePlan
		err = (*disksSpec.PurchasePlan).AssignPropertiesToPurchasePlan(&purchasePlan)
		if err != nil {
			return errors.Wrap(err, "populating PurchasePlan from PurchasePlan, calling AssignPropertiesToPurchasePlan()")
		}
		destination.PurchasePlan = &purchasePlan
	} else {
		destination.PurchasePlan = nil
	}

	// Sku
	if disksSpec.Sku != nil {
		var sku v1alpha1api20200930storage.DiskSku
		err = (*disksSpec.Sku).AssignPropertiesToDiskSku(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToDiskSku()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range disksSpec.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Tier
	if disksSpec.Tier != nil {
		tier := *disksSpec.Tier
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Zones
	zoneList := make([]string, len(disksSpec.Zones))
	for zoneIndex, zoneItem := range disksSpec.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func (disksSpec *Disks_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (disksSpec *Disks_Spec) SetAzureName(azureName string) { disksSpec.AzureName = azureName }

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/CreationData
type CreationData struct {
	// +kubebuilder:validation:Required
	//CreateOption: This enumerates the possible sources of a disk's creation.
	CreateOption CreationDataCreateOption `json:"createOption"`

	//GalleryImageReference: The source image used for creating the disk.
	GalleryImageReference *ImageDiskReference `json:"galleryImageReference,omitempty"`

	//ImageReference: The source image used for creating the disk.
	ImageReference *ImageDiskReference `json:"imageReference,omitempty"`

	//LogicalSectorSize: Logical sector size in bytes for Ultra disks. Supported
	//values are 512 ad 4096. 4096 is the default.
	LogicalSectorSize *int `json:"logicalSectorSize,omitempty"`

	//SourceResourceReference: If createOption is Copy, this is the ARM id of the
	//source snapshot or disk.
	SourceResourceReference *genruntime.ResourceReference `armReference:"SourceResourceId" json:"sourceResourceReference,omitempty"`

	//SourceUri: If createOption is Import, this is the URI of a blob to be imported
	//into a managed disk.
	SourceUri *string `json:"sourceUri,omitempty"`

	//StorageAccountId: Required if createOption is Import. The Azure Resource Manager
	//identifier of the storage account containing the blob to import as a disk.
	StorageAccountId *string `json:"storageAccountId,omitempty"`

	//UploadSizeBytes: If createOption is Upload, this is the size of the contents of
	//the upload including the VHD footer. This value should be between 20972032 (20
	//MiB + 512 bytes for the VHD footer) and 35183298347520 bytes (32 TiB + 512 bytes
	//for the VHD footer).
	UploadSizeBytes *int `json:"uploadSizeBytes,omitempty"`
}

var _ genruntime.ARMTransformer = &CreationData{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (creationData *CreationData) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if creationData == nil {
		return nil, nil
	}
	var result CreationDataARM

	// Set property ‘CreateOption’:
	result.CreateOption = creationData.CreateOption

	// Set property ‘GalleryImageReference’:
	if creationData.GalleryImageReference != nil {
		galleryImageReferenceARM, err := (*creationData.GalleryImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		galleryImageReference := galleryImageReferenceARM.(ImageDiskReferenceARM)
		result.GalleryImageReference = &galleryImageReference
	}

	// Set property ‘ImageReference’:
	if creationData.ImageReference != nil {
		imageReferenceARM, err := (*creationData.ImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageReference := imageReferenceARM.(ImageDiskReferenceARM)
		result.ImageReference = &imageReference
	}

	// Set property ‘LogicalSectorSize’:
	if creationData.LogicalSectorSize != nil {
		logicalSectorSize := *creationData.LogicalSectorSize
		result.LogicalSectorSize = &logicalSectorSize
	}

	// Set property ‘SourceResourceId’:
	if creationData.SourceResourceReference != nil {
		sourceResourceReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*creationData.SourceResourceReference)
		if err != nil {
			return nil, err
		}
		sourceResourceReference := sourceResourceReferenceARMID
		result.SourceResourceId = &sourceResourceReference
	}

	// Set property ‘SourceUri’:
	if creationData.SourceUri != nil {
		sourceUri := *creationData.SourceUri
		result.SourceUri = &sourceUri
	}

	// Set property ‘StorageAccountId’:
	if creationData.StorageAccountId != nil {
		storageAccountId := *creationData.StorageAccountId
		result.StorageAccountId = &storageAccountId
	}

	// Set property ‘UploadSizeBytes’:
	if creationData.UploadSizeBytes != nil {
		uploadSizeBytes := *creationData.UploadSizeBytes
		result.UploadSizeBytes = &uploadSizeBytes
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (creationData *CreationData) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &CreationDataARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (creationData *CreationData) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CreationDataARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CreationDataARM, got %T", armInput)
	}

	// Set property ‘CreateOption’:
	creationData.CreateOption = typedInput.CreateOption

	// Set property ‘GalleryImageReference’:
	if typedInput.GalleryImageReference != nil {
		var galleryImageReference1 ImageDiskReference
		err := galleryImageReference1.PopulateFromARM(owner, *typedInput.GalleryImageReference)
		if err != nil {
			return err
		}
		galleryImageReference := galleryImageReference1
		creationData.GalleryImageReference = &galleryImageReference
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageDiskReference
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		creationData.ImageReference = &imageReference
	}

	// Set property ‘LogicalSectorSize’:
	if typedInput.LogicalSectorSize != nil {
		logicalSectorSize := *typedInput.LogicalSectorSize
		creationData.LogicalSectorSize = &logicalSectorSize
	}

	// no assignment for property ‘SourceResourceReference’

	// Set property ‘SourceUri’:
	if typedInput.SourceUri != nil {
		sourceUri := *typedInput.SourceUri
		creationData.SourceUri = &sourceUri
	}

	// Set property ‘StorageAccountId’:
	if typedInput.StorageAccountId != nil {
		storageAccountId := *typedInput.StorageAccountId
		creationData.StorageAccountId = &storageAccountId
	}

	// Set property ‘UploadSizeBytes’:
	if typedInput.UploadSizeBytes != nil {
		uploadSizeBytes := *typedInput.UploadSizeBytes
		creationData.UploadSizeBytes = &uploadSizeBytes
	}

	// No error
	return nil
}

// AssignPropertiesFromCreationData populates our CreationData from the provided source CreationData
func (creationData *CreationData) AssignPropertiesFromCreationData(source *v1alpha1api20200930storage.CreationData) error {

	// CreateOption
	if source.CreateOption != nil {
		creationData.CreateOption = CreationDataCreateOption(*source.CreateOption)
	} else {
		creationData.CreateOption = ""
	}

	// GalleryImageReference
	if source.GalleryImageReference != nil {
		var galleryImageReference ImageDiskReference
		err := galleryImageReference.AssignPropertiesFromImageDiskReference(source.GalleryImageReference)
		if err != nil {
			return errors.Wrap(err, "populating GalleryImageReference from GalleryImageReference, calling AssignPropertiesFromImageDiskReference()")
		}
		creationData.GalleryImageReference = &galleryImageReference
	} else {
		creationData.GalleryImageReference = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageDiskReference
		err := imageReference.AssignPropertiesFromImageDiskReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesFromImageDiskReference()")
		}
		creationData.ImageReference = &imageReference
	} else {
		creationData.ImageReference = nil
	}

	// LogicalSectorSize
	if source.LogicalSectorSize != nil {
		logicalSectorSize := *source.LogicalSectorSize
		creationData.LogicalSectorSize = &logicalSectorSize
	} else {
		creationData.LogicalSectorSize = nil
	}

	// SourceResourceReference
	if source.SourceResourceReference != nil {
		sourceResourceReference := source.SourceResourceReference.Copy()
		creationData.SourceResourceReference = &sourceResourceReference
	} else {
		creationData.SourceResourceReference = nil
	}

	// SourceUri
	if source.SourceUri != nil {
		sourceUri := *source.SourceUri
		creationData.SourceUri = &sourceUri
	} else {
		creationData.SourceUri = nil
	}

	// StorageAccountId
	if source.StorageAccountId != nil {
		storageAccountId := *source.StorageAccountId
		creationData.StorageAccountId = &storageAccountId
	} else {
		creationData.StorageAccountId = nil
	}

	// UploadSizeBytes
	if source.UploadSizeBytes != nil {
		uploadSizeByte := *source.UploadSizeBytes
		creationData.UploadSizeBytes = &uploadSizeByte
	} else {
		creationData.UploadSizeBytes = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCreationData populates the provided destination CreationData from our CreationData
func (creationData *CreationData) AssignPropertiesToCreationData(destination *v1alpha1api20200930storage.CreationData) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreateOption
	createOption := string(creationData.CreateOption)
	destination.CreateOption = &createOption

	// GalleryImageReference
	if creationData.GalleryImageReference != nil {
		var galleryImageReference v1alpha1api20200930storage.ImageDiskReference
		err := (*creationData.GalleryImageReference).AssignPropertiesToImageDiskReference(&galleryImageReference)
		if err != nil {
			return errors.Wrap(err, "populating GalleryImageReference from GalleryImageReference, calling AssignPropertiesToImageDiskReference()")
		}
		destination.GalleryImageReference = &galleryImageReference
	} else {
		destination.GalleryImageReference = nil
	}

	// ImageReference
	if creationData.ImageReference != nil {
		var imageReference v1alpha1api20200930storage.ImageDiskReference
		err := (*creationData.ImageReference).AssignPropertiesToImageDiskReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesToImageDiskReference()")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// LogicalSectorSize
	if creationData.LogicalSectorSize != nil {
		logicalSectorSize := *creationData.LogicalSectorSize
		destination.LogicalSectorSize = &logicalSectorSize
	} else {
		destination.LogicalSectorSize = nil
	}

	// SourceResourceReference
	if creationData.SourceResourceReference != nil {
		sourceResourceReference := creationData.SourceResourceReference.Copy()
		destination.SourceResourceReference = &sourceResourceReference
	} else {
		destination.SourceResourceReference = nil
	}

	// SourceUri
	if creationData.SourceUri != nil {
		sourceUri := *creationData.SourceUri
		destination.SourceUri = &sourceUri
	} else {
		destination.SourceUri = nil
	}

	// StorageAccountId
	if creationData.StorageAccountId != nil {
		storageAccountId := *creationData.StorageAccountId
		destination.StorageAccountId = &storageAccountId
	} else {
		destination.StorageAccountId = nil
	}

	// UploadSizeBytes
	if creationData.UploadSizeBytes != nil {
		uploadSizeByte := *creationData.UploadSizeBytes
		destination.UploadSizeBytes = &uploadSizeByte
	} else {
		destination.UploadSizeBytes = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type CreationData_Status struct {
	// +kubebuilder:validation:Required
	//CreateOption: This enumerates the possible sources of a disk's creation.
	CreateOption CreationDataStatusCreateOption `json:"createOption"`

	//GalleryImageReference: Required if creating from a Gallery Image. The id of the
	//ImageDiskReference will be the ARM id of the shared galley image version from
	//which to create a disk.
	GalleryImageReference *ImageDiskReference_Status `json:"galleryImageReference,omitempty"`

	//ImageReference: Disk source information.
	ImageReference *ImageDiskReference_Status `json:"imageReference,omitempty"`

	//LogicalSectorSize: Logical sector size in bytes for Ultra disks. Supported
	//values are 512 ad 4096. 4096 is the default.
	LogicalSectorSize *int `json:"logicalSectorSize,omitempty"`

	//SourceResourceId: If createOption is Copy, this is the ARM id of the source
	//snapshot or disk.
	SourceResourceId *string `json:"sourceResourceId,omitempty"`

	//SourceUniqueId: If this field is set, this is the unique id identifying the
	//source of this resource.
	SourceUniqueId *string `json:"sourceUniqueId,omitempty"`

	//SourceUri: If createOption is Import, this is the URI of a blob to be imported
	//into a managed disk.
	SourceUri *string `json:"sourceUri,omitempty"`

	//StorageAccountId: Required if createOption is Import. The Azure Resource Manager
	//identifier of the storage account containing the blob to import as a disk.
	StorageAccountId *string `json:"storageAccountId,omitempty"`

	//UploadSizeBytes: If createOption is Upload, this is the size of the contents of
	//the upload including the VHD footer. This value should be between 20972032 (20
	//MiB + 512 bytes for the VHD footer) and 35183298347520 bytes (32 TiB + 512 bytes
	//for the VHD footer).
	UploadSizeBytes *int `json:"uploadSizeBytes,omitempty"`
}

var _ genruntime.FromARMConverter = &CreationData_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (creationDataStatus *CreationData_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &CreationData_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (creationDataStatus *CreationData_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CreationData_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CreationData_StatusARM, got %T", armInput)
	}

	// Set property ‘CreateOption’:
	creationDataStatus.CreateOption = typedInput.CreateOption

	// Set property ‘GalleryImageReference’:
	if typedInput.GalleryImageReference != nil {
		var galleryImageReference1 ImageDiskReference_Status
		err := galleryImageReference1.PopulateFromARM(owner, *typedInput.GalleryImageReference)
		if err != nil {
			return err
		}
		galleryImageReference := galleryImageReference1
		creationDataStatus.GalleryImageReference = &galleryImageReference
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageDiskReference_Status
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		creationDataStatus.ImageReference = &imageReference
	}

	// Set property ‘LogicalSectorSize’:
	if typedInput.LogicalSectorSize != nil {
		logicalSectorSize := *typedInput.LogicalSectorSize
		creationDataStatus.LogicalSectorSize = &logicalSectorSize
	}

	// Set property ‘SourceResourceId’:
	if typedInput.SourceResourceId != nil {
		sourceResourceId := *typedInput.SourceResourceId
		creationDataStatus.SourceResourceId = &sourceResourceId
	}

	// Set property ‘SourceUniqueId’:
	if typedInput.SourceUniqueId != nil {
		sourceUniqueId := *typedInput.SourceUniqueId
		creationDataStatus.SourceUniqueId = &sourceUniqueId
	}

	// Set property ‘SourceUri’:
	if typedInput.SourceUri != nil {
		sourceUri := *typedInput.SourceUri
		creationDataStatus.SourceUri = &sourceUri
	}

	// Set property ‘StorageAccountId’:
	if typedInput.StorageAccountId != nil {
		storageAccountId := *typedInput.StorageAccountId
		creationDataStatus.StorageAccountId = &storageAccountId
	}

	// Set property ‘UploadSizeBytes’:
	if typedInput.UploadSizeBytes != nil {
		uploadSizeBytes := *typedInput.UploadSizeBytes
		creationDataStatus.UploadSizeBytes = &uploadSizeBytes
	}

	// No error
	return nil
}

// AssignPropertiesFromCreationDataStatus populates our CreationData_Status from the provided source CreationData_Status
func (creationDataStatus *CreationData_Status) AssignPropertiesFromCreationDataStatus(source *v1alpha1api20200930storage.CreationData_Status) error {

	// CreateOption
	if source.CreateOption != nil {
		creationDataStatus.CreateOption = CreationDataStatusCreateOption(*source.CreateOption)
	} else {
		creationDataStatus.CreateOption = ""
	}

	// GalleryImageReference
	if source.GalleryImageReference != nil {
		var galleryImageReference ImageDiskReference_Status
		err := galleryImageReference.AssignPropertiesFromImageDiskReferenceStatus(source.GalleryImageReference)
		if err != nil {
			return errors.Wrap(err, "populating GalleryImageReference from GalleryImageReference, calling AssignPropertiesFromImageDiskReferenceStatus()")
		}
		creationDataStatus.GalleryImageReference = &galleryImageReference
	} else {
		creationDataStatus.GalleryImageReference = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageDiskReference_Status
		err := imageReference.AssignPropertiesFromImageDiskReferenceStatus(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesFromImageDiskReferenceStatus()")
		}
		creationDataStatus.ImageReference = &imageReference
	} else {
		creationDataStatus.ImageReference = nil
	}

	// LogicalSectorSize
	if source.LogicalSectorSize != nil {
		logicalSectorSize := *source.LogicalSectorSize
		creationDataStatus.LogicalSectorSize = &logicalSectorSize
	} else {
		creationDataStatus.LogicalSectorSize = nil
	}

	// SourceResourceId
	if source.SourceResourceId != nil {
		sourceResourceId := *source.SourceResourceId
		creationDataStatus.SourceResourceId = &sourceResourceId
	} else {
		creationDataStatus.SourceResourceId = nil
	}

	// SourceUniqueId
	if source.SourceUniqueId != nil {
		sourceUniqueId := *source.SourceUniqueId
		creationDataStatus.SourceUniqueId = &sourceUniqueId
	} else {
		creationDataStatus.SourceUniqueId = nil
	}

	// SourceUri
	if source.SourceUri != nil {
		sourceUri := *source.SourceUri
		creationDataStatus.SourceUri = &sourceUri
	} else {
		creationDataStatus.SourceUri = nil
	}

	// StorageAccountId
	if source.StorageAccountId != nil {
		storageAccountId := *source.StorageAccountId
		creationDataStatus.StorageAccountId = &storageAccountId
	} else {
		creationDataStatus.StorageAccountId = nil
	}

	// UploadSizeBytes
	if source.UploadSizeBytes != nil {
		uploadSizeByte := *source.UploadSizeBytes
		creationDataStatus.UploadSizeBytes = &uploadSizeByte
	} else {
		creationDataStatus.UploadSizeBytes = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCreationDataStatus populates the provided destination CreationData_Status from our CreationData_Status
func (creationDataStatus *CreationData_Status) AssignPropertiesToCreationDataStatus(destination *v1alpha1api20200930storage.CreationData_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreateOption
	createOption := string(creationDataStatus.CreateOption)
	destination.CreateOption = &createOption

	// GalleryImageReference
	if creationDataStatus.GalleryImageReference != nil {
		var galleryImageReference v1alpha1api20200930storage.ImageDiskReference_Status
		err := (*creationDataStatus.GalleryImageReference).AssignPropertiesToImageDiskReferenceStatus(&galleryImageReference)
		if err != nil {
			return errors.Wrap(err, "populating GalleryImageReference from GalleryImageReference, calling AssignPropertiesToImageDiskReferenceStatus()")
		}
		destination.GalleryImageReference = &galleryImageReference
	} else {
		destination.GalleryImageReference = nil
	}

	// ImageReference
	if creationDataStatus.ImageReference != nil {
		var imageReference v1alpha1api20200930storage.ImageDiskReference_Status
		err := (*creationDataStatus.ImageReference).AssignPropertiesToImageDiskReferenceStatus(&imageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesToImageDiskReferenceStatus()")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// LogicalSectorSize
	if creationDataStatus.LogicalSectorSize != nil {
		logicalSectorSize := *creationDataStatus.LogicalSectorSize
		destination.LogicalSectorSize = &logicalSectorSize
	} else {
		destination.LogicalSectorSize = nil
	}

	// SourceResourceId
	if creationDataStatus.SourceResourceId != nil {
		sourceResourceId := *creationDataStatus.SourceResourceId
		destination.SourceResourceId = &sourceResourceId
	} else {
		destination.SourceResourceId = nil
	}

	// SourceUniqueId
	if creationDataStatus.SourceUniqueId != nil {
		sourceUniqueId := *creationDataStatus.SourceUniqueId
		destination.SourceUniqueId = &sourceUniqueId
	} else {
		destination.SourceUniqueId = nil
	}

	// SourceUri
	if creationDataStatus.SourceUri != nil {
		sourceUri := *creationDataStatus.SourceUri
		destination.SourceUri = &sourceUri
	} else {
		destination.SourceUri = nil
	}

	// StorageAccountId
	if creationDataStatus.StorageAccountId != nil {
		storageAccountId := *creationDataStatus.StorageAccountId
		destination.StorageAccountId = &storageAccountId
	} else {
		destination.StorageAccountId = nil
	}

	// UploadSizeBytes
	if creationDataStatus.UploadSizeBytes != nil {
		uploadSizeByte := *creationDataStatus.UploadSizeBytes
		destination.UploadSizeBytes = &uploadSizeByte
	} else {
		destination.UploadSizeBytes = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"V1","V2"}
type DiskPropertiesHyperVGeneration string

const (
	DiskPropertiesHyperVGenerationV1 = DiskPropertiesHyperVGeneration("V1")
	DiskPropertiesHyperVGenerationV2 = DiskPropertiesHyperVGeneration("V2")
)

// +kubebuilder:validation:Enum={"AllowAll","AllowPrivate","DenyAll"}
type DiskPropertiesNetworkAccessPolicy string

const (
	DiskPropertiesNetworkAccessPolicyAllowAll     = DiskPropertiesNetworkAccessPolicy("AllowAll")
	DiskPropertiesNetworkAccessPolicyAllowPrivate = DiskPropertiesNetworkAccessPolicy("AllowPrivate")
	DiskPropertiesNetworkAccessPolicyDenyAll      = DiskPropertiesNetworkAccessPolicy("DenyAll")
)

// +kubebuilder:validation:Enum={"Linux","Windows"}
type DiskPropertiesOsType string

const (
	DiskPropertiesOsTypeLinux   = DiskPropertiesOsType("Linux")
	DiskPropertiesOsTypeWindows = DiskPropertiesOsType("Windows")
)

type DiskPropertiesStatusHyperVGeneration string

const (
	DiskPropertiesStatusHyperVGenerationV1 = DiskPropertiesStatusHyperVGeneration("V1")
	DiskPropertiesStatusHyperVGenerationV2 = DiskPropertiesStatusHyperVGeneration("V2")
)

type DiskPropertiesStatusOsType string

const (
	DiskPropertiesStatusOsTypeLinux   = DiskPropertiesStatusOsType("Linux")
	DiskPropertiesStatusOsTypeWindows = DiskPropertiesStatusOsType("Windows")
)

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/DiskSku
type DiskSku struct {
	//Name: The sku name.
	Name *DiskSkuName `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &DiskSku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diskSku *DiskSku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diskSku == nil {
		return nil, nil
	}
	var result DiskSkuARM

	// Set property ‘Name’:
	if diskSku.Name != nil {
		name := *diskSku.Name
		result.Name = &name
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diskSku *DiskSku) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskSkuARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diskSku *DiskSku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiskSkuARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskSkuARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		diskSku.Name = &name
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskSku populates our DiskSku from the provided source DiskSku
func (diskSku *DiskSku) AssignPropertiesFromDiskSku(source *v1alpha1api20200930storage.DiskSku) error {

	// Name
	if source.Name != nil {
		name := DiskSkuName(*source.Name)
		diskSku.Name = &name
	} else {
		diskSku.Name = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskSku populates the provided destination DiskSku from our DiskSku
func (diskSku *DiskSku) AssignPropertiesToDiskSku(destination *v1alpha1api20200930storage.DiskSku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if diskSku.Name != nil {
		name := string(*diskSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type DiskSku_Status struct {
	//Name: The sku name.
	Name *DiskSkuStatusName `json:"name,omitempty"`

	//Tier: The sku tier.
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &DiskSku_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diskSkuStatus *DiskSku_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskSku_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diskSkuStatus *DiskSku_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiskSku_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskSku_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		diskSkuStatus.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		diskSkuStatus.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromDiskSkuStatus populates our DiskSku_Status from the provided source DiskSku_Status
func (diskSkuStatus *DiskSku_Status) AssignPropertiesFromDiskSkuStatus(source *v1alpha1api20200930storage.DiskSku_Status) error {

	// Name
	if source.Name != nil {
		name := DiskSkuStatusName(*source.Name)
		diskSkuStatus.Name = &name
	} else {
		diskSkuStatus.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		diskSkuStatus.Tier = &tier
	} else {
		diskSkuStatus.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskSkuStatus populates the provided destination DiskSku_Status from our DiskSku_Status
func (diskSkuStatus *DiskSku_Status) AssignPropertiesToDiskSkuStatus(destination *v1alpha1api20200930storage.DiskSku_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if diskSkuStatus.Name != nil {
		name := string(*diskSkuStatus.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if diskSkuStatus.Tier != nil {
		tier := *diskSkuStatus.Tier
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type DiskState_Status string

const (
	DiskState_StatusActiveSAS     = DiskState_Status("ActiveSAS")
	DiskState_StatusActiveUpload  = DiskState_Status("ActiveUpload")
	DiskState_StatusAttached      = DiskState_Status("Attached")
	DiskState_StatusReadyToUpload = DiskState_Status("ReadyToUpload")
	DiskState_StatusReserved      = DiskState_Status("Reserved")
	DiskState_StatusUnattached    = DiskState_Status("Unattached")
)

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/Encryption
type Encryption struct {
	//DiskEncryptionSetId: ResourceId of the disk encryption set to use for enabling
	//encryption at rest.
	DiskEncryptionSetId *string         `json:"diskEncryptionSetId,omitempty"`
	Type                *EncryptionType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Encryption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *Encryption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	var result EncryptionARM

	// Set property ‘DiskEncryptionSetId’:
	if encryption.DiskEncryptionSetId != nil {
		diskEncryptionSetId := *encryption.DiskEncryptionSetId
		result.DiskEncryptionSetId = &diskEncryptionSetId
	}

	// Set property ‘Type’:
	if encryption.Type != nil {
		typeVar := *encryption.Type
		result.Type = &typeVar
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *Encryption) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *Encryption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSetId’:
	if typedInput.DiskEncryptionSetId != nil {
		diskEncryptionSetId := *typedInput.DiskEncryptionSetId
		encryption.DiskEncryptionSetId = &diskEncryptionSetId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		encryption.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromEncryption populates our Encryption from the provided source Encryption
func (encryption *Encryption) AssignPropertiesFromEncryption(source *v1alpha1api20200930storage.Encryption) error {

	// DiskEncryptionSetId
	if source.DiskEncryptionSetId != nil {
		diskEncryptionSetId := *source.DiskEncryptionSetId
		encryption.DiskEncryptionSetId = &diskEncryptionSetId
	} else {
		encryption.DiskEncryptionSetId = nil
	}

	// Type
	if source.Type != nil {
		typeVar := EncryptionType(*source.Type)
		encryption.Type = &typeVar
	} else {
		encryption.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEncryption populates the provided destination Encryption from our Encryption
func (encryption *Encryption) AssignPropertiesToEncryption(destination *v1alpha1api20200930storage.Encryption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSetId
	if encryption.DiskEncryptionSetId != nil {
		diskEncryptionSetId := *encryption.DiskEncryptionSetId
		destination.DiskEncryptionSetId = &diskEncryptionSetId
	} else {
		destination.DiskEncryptionSetId = nil
	}

	// Type
	if encryption.Type != nil {
		typeVar := string(*encryption.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/EncryptionSettingsCollection
type EncryptionSettingsCollection struct {
	// +kubebuilder:validation:Required
	//Enabled: Set this flag to true and provide DiskEncryptionKey and optional
	//KeyEncryptionKey to enable encryption. Set this flag to false and remove
	//DiskEncryptionKey and KeyEncryptionKey to disable encryption. If
	//EncryptionSettings is null in the request object, the existing settings remain
	//unchanged.
	Enabled bool `json:"enabled"`

	//EncryptionSettings: A collection of encryption settings, one for each disk
	//volume.
	EncryptionSettings []EncryptionSettingsElement `json:"encryptionSettings,omitempty"`

	//EncryptionSettingsVersion: Describes what type of encryption is used for the
	//disks. Once this field is set, it cannot be overwritten. '1.0' corresponds to
	//Azure Disk Encryption with AAD app.'1.1' corresponds to Azure Disk Encryption.
	EncryptionSettingsVersion *string `json:"encryptionSettingsVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionSettingsCollection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryptionSettingsCollection *EncryptionSettingsCollection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryptionSettingsCollection == nil {
		return nil, nil
	}
	var result EncryptionSettingsCollectionARM

	// Set property ‘Enabled’:
	result.Enabled = encryptionSettingsCollection.Enabled

	// Set property ‘EncryptionSettings’:
	for _, item := range encryptionSettingsCollection.EncryptionSettings {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.EncryptionSettings = append(result.EncryptionSettings, itemARM.(EncryptionSettingsElementARM))
	}

	// Set property ‘EncryptionSettingsVersion’:
	if encryptionSettingsCollection.EncryptionSettingsVersion != nil {
		encryptionSettingsVersion := *encryptionSettingsCollection.EncryptionSettingsVersion
		result.EncryptionSettingsVersion = &encryptionSettingsVersion
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionSettingsCollection *EncryptionSettingsCollection) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionSettingsCollectionARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionSettingsCollection *EncryptionSettingsCollection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionSettingsCollectionARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionSettingsCollectionARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	encryptionSettingsCollection.Enabled = typedInput.Enabled

	// Set property ‘EncryptionSettings’:
	for _, item := range typedInput.EncryptionSettings {
		var item1 EncryptionSettingsElement
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		encryptionSettingsCollection.EncryptionSettings = append(encryptionSettingsCollection.EncryptionSettings, item1)
	}

	// Set property ‘EncryptionSettingsVersion’:
	if typedInput.EncryptionSettingsVersion != nil {
		encryptionSettingsVersion := *typedInput.EncryptionSettingsVersion
		encryptionSettingsCollection.EncryptionSettingsVersion = &encryptionSettingsVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromEncryptionSettingsCollection populates our EncryptionSettingsCollection from the provided source EncryptionSettingsCollection
func (encryptionSettingsCollection *EncryptionSettingsCollection) AssignPropertiesFromEncryptionSettingsCollection(source *v1alpha1api20200930storage.EncryptionSettingsCollection) error {

	// Enabled
	if source.Enabled != nil {
		encryptionSettingsCollection.Enabled = *source.Enabled
	} else {
		encryptionSettingsCollection.Enabled = false
	}

	// EncryptionSettings
	encryptionSettingList := make([]EncryptionSettingsElement, len(source.EncryptionSettings))
	for encryptionSettingIndex, encryptionSettingItem := range source.EncryptionSettings {
		// Shadow the loop variable to avoid aliasing
		encryptionSettingItem := encryptionSettingItem
		var encryptionSetting EncryptionSettingsElement
		err := encryptionSetting.AssignPropertiesFromEncryptionSettingsElement(&encryptionSettingItem)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesFromEncryptionSettingsElement()")
		}
		encryptionSettingList[encryptionSettingIndex] = encryptionSetting
	}
	encryptionSettingsCollection.EncryptionSettings = encryptionSettingList

	// EncryptionSettingsVersion
	if source.EncryptionSettingsVersion != nil {
		encryptionSettingsVersion := *source.EncryptionSettingsVersion
		encryptionSettingsCollection.EncryptionSettingsVersion = &encryptionSettingsVersion
	} else {
		encryptionSettingsCollection.EncryptionSettingsVersion = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEncryptionSettingsCollection populates the provided destination EncryptionSettingsCollection from our EncryptionSettingsCollection
func (encryptionSettingsCollection *EncryptionSettingsCollection) AssignPropertiesToEncryptionSettingsCollection(destination *v1alpha1api20200930storage.EncryptionSettingsCollection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	enabled := encryptionSettingsCollection.Enabled
	destination.Enabled = &enabled

	// EncryptionSettings
	encryptionSettingList := make([]v1alpha1api20200930storage.EncryptionSettingsElement, len(encryptionSettingsCollection.EncryptionSettings))
	for encryptionSettingIndex, encryptionSettingItem := range encryptionSettingsCollection.EncryptionSettings {
		// Shadow the loop variable to avoid aliasing
		encryptionSettingItem := encryptionSettingItem
		var encryptionSetting v1alpha1api20200930storage.EncryptionSettingsElement
		err := encryptionSettingItem.AssignPropertiesToEncryptionSettingsElement(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesToEncryptionSettingsElement()")
		}
		encryptionSettingList[encryptionSettingIndex] = encryptionSetting
	}
	destination.EncryptionSettings = encryptionSettingList

	// EncryptionSettingsVersion
	if encryptionSettingsCollection.EncryptionSettingsVersion != nil {
		encryptionSettingsVersion := *encryptionSettingsCollection.EncryptionSettingsVersion
		destination.EncryptionSettingsVersion = &encryptionSettingsVersion
	} else {
		destination.EncryptionSettingsVersion = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type EncryptionSettingsCollection_Status struct {
	// +kubebuilder:validation:Required
	//Enabled: Set this flag to true and provide DiskEncryptionKey and optional
	//KeyEncryptionKey to enable encryption. Set this flag to false and remove
	//DiskEncryptionKey and KeyEncryptionKey to disable encryption. If
	//EncryptionSettings is null in the request object, the existing settings remain
	//unchanged.
	Enabled bool `json:"enabled"`

	//EncryptionSettings: A collection of encryption settings, one for each disk
	//volume.
	EncryptionSettings []EncryptionSettingsElement_Status `json:"encryptionSettings,omitempty"`

	//EncryptionSettingsVersion: Describes what type of encryption is used for the
	//disks. Once this field is set, it cannot be overwritten. '1.0' corresponds to
	//Azure Disk Encryption with AAD app.'1.1' corresponds to Azure Disk Encryption.
	EncryptionSettingsVersion *string `json:"encryptionSettingsVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionSettingsCollection_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionSettingsCollectionStatus *EncryptionSettingsCollection_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionSettingsCollection_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionSettingsCollectionStatus *EncryptionSettingsCollection_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionSettingsCollection_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionSettingsCollection_StatusARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	encryptionSettingsCollectionStatus.Enabled = typedInput.Enabled

	// Set property ‘EncryptionSettings’:
	for _, item := range typedInput.EncryptionSettings {
		var item1 EncryptionSettingsElement_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		encryptionSettingsCollectionStatus.EncryptionSettings = append(encryptionSettingsCollectionStatus.EncryptionSettings, item1)
	}

	// Set property ‘EncryptionSettingsVersion’:
	if typedInput.EncryptionSettingsVersion != nil {
		encryptionSettingsVersion := *typedInput.EncryptionSettingsVersion
		encryptionSettingsCollectionStatus.EncryptionSettingsVersion = &encryptionSettingsVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromEncryptionSettingsCollectionStatus populates our EncryptionSettingsCollection_Status from the provided source EncryptionSettingsCollection_Status
func (encryptionSettingsCollectionStatus *EncryptionSettingsCollection_Status) AssignPropertiesFromEncryptionSettingsCollectionStatus(source *v1alpha1api20200930storage.EncryptionSettingsCollection_Status) error {

	// Enabled
	if source.Enabled != nil {
		encryptionSettingsCollectionStatus.Enabled = *source.Enabled
	} else {
		encryptionSettingsCollectionStatus.Enabled = false
	}

	// EncryptionSettings
	encryptionSettingList := make([]EncryptionSettingsElement_Status, len(source.EncryptionSettings))
	for encryptionSettingIndex, encryptionSettingItem := range source.EncryptionSettings {
		// Shadow the loop variable to avoid aliasing
		encryptionSettingItem := encryptionSettingItem
		var encryptionSetting EncryptionSettingsElement_Status
		err := encryptionSetting.AssignPropertiesFromEncryptionSettingsElementStatus(&encryptionSettingItem)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesFromEncryptionSettingsElementStatus()")
		}
		encryptionSettingList[encryptionSettingIndex] = encryptionSetting
	}
	encryptionSettingsCollectionStatus.EncryptionSettings = encryptionSettingList

	// EncryptionSettingsVersion
	if source.EncryptionSettingsVersion != nil {
		encryptionSettingsVersion := *source.EncryptionSettingsVersion
		encryptionSettingsCollectionStatus.EncryptionSettingsVersion = &encryptionSettingsVersion
	} else {
		encryptionSettingsCollectionStatus.EncryptionSettingsVersion = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEncryptionSettingsCollectionStatus populates the provided destination EncryptionSettingsCollection_Status from our EncryptionSettingsCollection_Status
func (encryptionSettingsCollectionStatus *EncryptionSettingsCollection_Status) AssignPropertiesToEncryptionSettingsCollectionStatus(destination *v1alpha1api20200930storage.EncryptionSettingsCollection_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	enabled := encryptionSettingsCollectionStatus.Enabled
	destination.Enabled = &enabled

	// EncryptionSettings
	encryptionSettingList := make([]v1alpha1api20200930storage.EncryptionSettingsElement_Status, len(encryptionSettingsCollectionStatus.EncryptionSettings))
	for encryptionSettingIndex, encryptionSettingItem := range encryptionSettingsCollectionStatus.EncryptionSettings {
		// Shadow the loop variable to avoid aliasing
		encryptionSettingItem := encryptionSettingItem
		var encryptionSetting v1alpha1api20200930storage.EncryptionSettingsElement_Status
		err := encryptionSettingItem.AssignPropertiesToEncryptionSettingsElementStatus(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "populating EncryptionSettings from EncryptionSettings, calling AssignPropertiesToEncryptionSettingsElementStatus()")
		}
		encryptionSettingList[encryptionSettingIndex] = encryptionSetting
	}
	destination.EncryptionSettings = encryptionSettingList

	// EncryptionSettingsVersion
	if encryptionSettingsCollectionStatus.EncryptionSettingsVersion != nil {
		encryptionSettingsVersion := *encryptionSettingsCollectionStatus.EncryptionSettingsVersion
		destination.EncryptionSettingsVersion = &encryptionSettingsVersion
	} else {
		destination.EncryptionSettingsVersion = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type Encryption_Status struct {
	//DiskEncryptionSetId: ResourceId of the disk encryption set to use for enabling
	//encryption at rest.
	DiskEncryptionSetId *string                `json:"diskEncryptionSetId,omitempty"`
	Type                *EncryptionType_Status `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Encryption_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionStatus *Encryption_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Encryption_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionStatus *Encryption_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Encryption_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Encryption_StatusARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSetId’:
	if typedInput.DiskEncryptionSetId != nil {
		diskEncryptionSetId := *typedInput.DiskEncryptionSetId
		encryptionStatus.DiskEncryptionSetId = &diskEncryptionSetId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		encryptionStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromEncryptionStatus populates our Encryption_Status from the provided source Encryption_Status
func (encryptionStatus *Encryption_Status) AssignPropertiesFromEncryptionStatus(source *v1alpha1api20200930storage.Encryption_Status) error {

	// DiskEncryptionSetId
	if source.DiskEncryptionSetId != nil {
		diskEncryptionSetId := *source.DiskEncryptionSetId
		encryptionStatus.DiskEncryptionSetId = &diskEncryptionSetId
	} else {
		encryptionStatus.DiskEncryptionSetId = nil
	}

	// Type
	if source.Type != nil {
		typeVar := EncryptionType_Status(*source.Type)
		encryptionStatus.Type = &typeVar
	} else {
		encryptionStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEncryptionStatus populates the provided destination Encryption_Status from our Encryption_Status
func (encryptionStatus *Encryption_Status) AssignPropertiesToEncryptionStatus(destination *v1alpha1api20200930storage.Encryption_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSetId
	if encryptionStatus.DiskEncryptionSetId != nil {
		diskEncryptionSetId := *encryptionStatus.DiskEncryptionSetId
		destination.DiskEncryptionSetId = &diskEncryptionSetId
	} else {
		destination.DiskEncryptionSetId = nil
	}

	// Type
	if encryptionStatus.Type != nil {
		typeVar := string(*encryptionStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/ExtendedLocation
type ExtendedLocation struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (extendedLocation *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if extendedLocation == nil {
		return nil, nil
	}
	var result ExtendedLocationARM

	// Set property ‘Name’:
	if extendedLocation.Name != nil {
		name := *extendedLocation.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if extendedLocation.Type != nil {
		typeVar := *extendedLocation.Type
		result.Type = &typeVar
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocation *ExtendedLocation) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocation *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocationARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extendedLocation.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extendedLocation.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesFromExtendedLocation(source *v1alpha1api20200930storage.ExtendedLocation) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		extendedLocation.Name = &name
	} else {
		extendedLocation.Name = nil
	}

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType(*source.Type)
		extendedLocation.Type = &typeVar
	} else {
		extendedLocation.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesToExtendedLocation(destination *v1alpha1api20200930storage.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if extendedLocation.Name != nil {
		name := *extendedLocation.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Type
	if extendedLocation.Type != nil {
		typeVar := string(*extendedLocation.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ExtendedLocation_Status struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType_Status `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocationStatus *ExtendedLocation_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocationStatus *ExtendedLocation_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extendedLocationStatus.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extendedLocationStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocationStatus populates our ExtendedLocation_Status from the provided source ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesFromExtendedLocationStatus(source *v1alpha1api20200930storage.ExtendedLocation_Status) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		extendedLocationStatus.Name = &name
	} else {
		extendedLocationStatus.Name = nil
	}

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_Status(*source.Type)
		extendedLocationStatus.Type = &typeVar
	} else {
		extendedLocationStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocationStatus populates the provided destination ExtendedLocation_Status from our ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesToExtendedLocationStatus(destination *v1alpha1api20200930storage.ExtendedLocation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if extendedLocationStatus.Name != nil {
		name := *extendedLocationStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Type
	if extendedLocationStatus.Type != nil {
		typeVar := string(*extendedLocationStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type NetworkAccessPolicy_Status string

const (
	NetworkAccessPolicy_StatusAllowAll     = NetworkAccessPolicy_Status("AllowAll")
	NetworkAccessPolicy_StatusAllowPrivate = NetworkAccessPolicy_Status("AllowPrivate")
	NetworkAccessPolicy_StatusDenyAll      = NetworkAccessPolicy_Status("DenyAll")
)

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/PurchasePlan
type PurchasePlan struct {
	// +kubebuilder:validation:Required
	//Name: The plan ID.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Product: Specifies the product of the image from the marketplace. This is the
	//same value as Offer under the imageReference element.
	Product string `json:"product"`

	//PromotionCode: The Offer Promotion Code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// +kubebuilder:validation:Required
	//Publisher: The publisher ID.
	Publisher string `json:"publisher"`
}

var _ genruntime.ARMTransformer = &PurchasePlan{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (purchasePlan *PurchasePlan) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if purchasePlan == nil {
		return nil, nil
	}
	var result PurchasePlanARM

	// Set property ‘Name’:
	result.Name = purchasePlan.Name

	// Set property ‘Product’:
	result.Product = purchasePlan.Product

	// Set property ‘PromotionCode’:
	if purchasePlan.PromotionCode != nil {
		promotionCode := *purchasePlan.PromotionCode
		result.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	result.Publisher = purchasePlan.Publisher
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (purchasePlan *PurchasePlan) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PurchasePlanARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (purchasePlan *PurchasePlan) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PurchasePlanARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PurchasePlanARM, got %T", armInput)
	}

	// Set property ‘Name’:
	purchasePlan.Name = typedInput.Name

	// Set property ‘Product’:
	purchasePlan.Product = typedInput.Product

	// Set property ‘PromotionCode’:
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		purchasePlan.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	purchasePlan.Publisher = typedInput.Publisher

	// No error
	return nil
}

// AssignPropertiesFromPurchasePlan populates our PurchasePlan from the provided source PurchasePlan
func (purchasePlan *PurchasePlan) AssignPropertiesFromPurchasePlan(source *v1alpha1api20200930storage.PurchasePlan) error {

	// Name
	if source.Name != nil {
		purchasePlan.Name = *source.Name
	} else {
		purchasePlan.Name = ""
	}

	// Product
	if source.Product != nil {
		purchasePlan.Product = *source.Product
	} else {
		purchasePlan.Product = ""
	}

	// PromotionCode
	if source.PromotionCode != nil {
		promotionCode := *source.PromotionCode
		purchasePlan.PromotionCode = &promotionCode
	} else {
		purchasePlan.PromotionCode = nil
	}

	// Publisher
	if source.Publisher != nil {
		purchasePlan.Publisher = *source.Publisher
	} else {
		purchasePlan.Publisher = ""
	}

	// No error
	return nil
}

// AssignPropertiesToPurchasePlan populates the provided destination PurchasePlan from our PurchasePlan
func (purchasePlan *PurchasePlan) AssignPropertiesToPurchasePlan(destination *v1alpha1api20200930storage.PurchasePlan) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := purchasePlan.Name
	destination.Name = &name

	// Product
	product := purchasePlan.Product
	destination.Product = &product

	// PromotionCode
	if purchasePlan.PromotionCode != nil {
		promotionCode := *purchasePlan.PromotionCode
		destination.PromotionCode = &promotionCode
	} else {
		destination.PromotionCode = nil
	}

	// Publisher
	publisher := purchasePlan.Publisher
	destination.Publisher = &publisher

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type PurchasePlan_Status struct {
	// +kubebuilder:validation:Required
	//Name: The plan ID.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Product: Specifies the product of the image from the marketplace. This is the
	//same value as Offer under the imageReference element.
	Product string `json:"product"`

	//PromotionCode: The Offer Promotion Code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// +kubebuilder:validation:Required
	//Publisher: The publisher ID.
	Publisher string `json:"publisher"`
}

var _ genruntime.FromARMConverter = &PurchasePlan_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (purchasePlanStatus *PurchasePlan_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PurchasePlan_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (purchasePlanStatus *PurchasePlan_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PurchasePlan_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PurchasePlan_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	purchasePlanStatus.Name = typedInput.Name

	// Set property ‘Product’:
	purchasePlanStatus.Product = typedInput.Product

	// Set property ‘PromotionCode’:
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		purchasePlanStatus.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	purchasePlanStatus.Publisher = typedInput.Publisher

	// No error
	return nil
}

// AssignPropertiesFromPurchasePlanStatus populates our PurchasePlan_Status from the provided source PurchasePlan_Status
func (purchasePlanStatus *PurchasePlan_Status) AssignPropertiesFromPurchasePlanStatus(source *v1alpha1api20200930storage.PurchasePlan_Status) error {

	// Name
	if source.Name != nil {
		purchasePlanStatus.Name = *source.Name
	} else {
		purchasePlanStatus.Name = ""
	}

	// Product
	if source.Product != nil {
		purchasePlanStatus.Product = *source.Product
	} else {
		purchasePlanStatus.Product = ""
	}

	// PromotionCode
	if source.PromotionCode != nil {
		promotionCode := *source.PromotionCode
		purchasePlanStatus.PromotionCode = &promotionCode
	} else {
		purchasePlanStatus.PromotionCode = nil
	}

	// Publisher
	if source.Publisher != nil {
		purchasePlanStatus.Publisher = *source.Publisher
	} else {
		purchasePlanStatus.Publisher = ""
	}

	// No error
	return nil
}

// AssignPropertiesToPurchasePlanStatus populates the provided destination PurchasePlan_Status from our PurchasePlan_Status
func (purchasePlanStatus *PurchasePlan_Status) AssignPropertiesToPurchasePlanStatus(destination *v1alpha1api20200930storage.PurchasePlan_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := purchasePlanStatus.Name
	destination.Name = &name

	// Product
	product := purchasePlanStatus.Product
	destination.Product = &product

	// PromotionCode
	if purchasePlanStatus.PromotionCode != nil {
		promotionCode := *purchasePlanStatus.PromotionCode
		destination.PromotionCode = &promotionCode
	} else {
		destination.PromotionCode = nil
	}

	// Publisher
	publisher := purchasePlanStatus.Publisher
	destination.Publisher = &publisher

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ShareInfoElement_Status struct {
	//VmUri: A relative URI containing the ID of the VM that has the disk attached.
	VmUri *string `json:"vmUri,omitempty"`
}

var _ genruntime.FromARMConverter = &ShareInfoElement_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (shareInfoElementStatus *ShareInfoElement_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ShareInfoElement_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (shareInfoElementStatus *ShareInfoElement_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ShareInfoElement_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ShareInfoElement_StatusARM, got %T", armInput)
	}

	// Set property ‘VmUri’:
	if typedInput.VmUri != nil {
		vmUri := *typedInput.VmUri
		shareInfoElementStatus.VmUri = &vmUri
	}

	// No error
	return nil
}

// AssignPropertiesFromShareInfoElementStatus populates our ShareInfoElement_Status from the provided source ShareInfoElement_Status
func (shareInfoElementStatus *ShareInfoElement_Status) AssignPropertiesFromShareInfoElementStatus(source *v1alpha1api20200930storage.ShareInfoElement_Status) error {

	// VmUri
	if source.VmUri != nil {
		vmUri := *source.VmUri
		shareInfoElementStatus.VmUri = &vmUri
	} else {
		shareInfoElementStatus.VmUri = nil
	}

	// No error
	return nil
}

// AssignPropertiesToShareInfoElementStatus populates the provided destination ShareInfoElement_Status from our ShareInfoElement_Status
func (shareInfoElementStatus *ShareInfoElement_Status) AssignPropertiesToShareInfoElementStatus(destination *v1alpha1api20200930storage.ShareInfoElement_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmUri
	if shareInfoElementStatus.VmUri != nil {
		vmUri := *shareInfoElementStatus.VmUri
		destination.VmUri = &vmUri
	} else {
		destination.VmUri = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Attach","Copy","Empty","FromImage","Import","Restore","Upload"}
type CreationDataCreateOption string

const (
	CreationDataCreateOptionAttach    = CreationDataCreateOption("Attach")
	CreationDataCreateOptionCopy      = CreationDataCreateOption("Copy")
	CreationDataCreateOptionEmpty     = CreationDataCreateOption("Empty")
	CreationDataCreateOptionFromImage = CreationDataCreateOption("FromImage")
	CreationDataCreateOptionImport    = CreationDataCreateOption("Import")
	CreationDataCreateOptionRestore   = CreationDataCreateOption("Restore")
	CreationDataCreateOptionUpload    = CreationDataCreateOption("Upload")
)

type CreationDataStatusCreateOption string

const (
	CreationDataStatusCreateOptionAttach    = CreationDataStatusCreateOption("Attach")
	CreationDataStatusCreateOptionCopy      = CreationDataStatusCreateOption("Copy")
	CreationDataStatusCreateOptionEmpty     = CreationDataStatusCreateOption("Empty")
	CreationDataStatusCreateOptionFromImage = CreationDataStatusCreateOption("FromImage")
	CreationDataStatusCreateOptionImport    = CreationDataStatusCreateOption("Import")
	CreationDataStatusCreateOptionRestore   = CreationDataStatusCreateOption("Restore")
	CreationDataStatusCreateOptionUpload    = CreationDataStatusCreateOption("Upload")
)

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/EncryptionSettingsElement
type EncryptionSettingsElement struct {
	//DiskEncryptionKey: Key Vault Secret Url and vault id of the encryption key
	DiskEncryptionKey *KeyVaultAndSecretReference `json:"diskEncryptionKey,omitempty"`

	//KeyEncryptionKey: Key Vault Key Url and vault id of KeK, KeK is optional and
	//when provided is used to unwrap the encryptionKey
	KeyEncryptionKey *KeyVaultAndKeyReference `json:"keyEncryptionKey,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionSettingsElement{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryptionSettingsElement *EncryptionSettingsElement) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryptionSettingsElement == nil {
		return nil, nil
	}
	var result EncryptionSettingsElementARM

	// Set property ‘DiskEncryptionKey’:
	if encryptionSettingsElement.DiskEncryptionKey != nil {
		diskEncryptionKeyARM, err := (*encryptionSettingsElement.DiskEncryptionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionKey := diskEncryptionKeyARM.(KeyVaultAndSecretReferenceARM)
		result.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘KeyEncryptionKey’:
	if encryptionSettingsElement.KeyEncryptionKey != nil {
		keyEncryptionKeyARM, err := (*encryptionSettingsElement.KeyEncryptionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyEncryptionKey := keyEncryptionKeyARM.(KeyVaultAndKeyReferenceARM)
		result.KeyEncryptionKey = &keyEncryptionKey
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionSettingsElement *EncryptionSettingsElement) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionSettingsElementARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionSettingsElement *EncryptionSettingsElement) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionSettingsElementARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionSettingsElementARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionKey’:
	if typedInput.DiskEncryptionKey != nil {
		var diskEncryptionKey1 KeyVaultAndSecretReference
		err := diskEncryptionKey1.PopulateFromARM(owner, *typedInput.DiskEncryptionKey)
		if err != nil {
			return err
		}
		diskEncryptionKey := diskEncryptionKey1
		encryptionSettingsElement.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘KeyEncryptionKey’:
	if typedInput.KeyEncryptionKey != nil {
		var keyEncryptionKey1 KeyVaultAndKeyReference
		err := keyEncryptionKey1.PopulateFromARM(owner, *typedInput.KeyEncryptionKey)
		if err != nil {
			return err
		}
		keyEncryptionKey := keyEncryptionKey1
		encryptionSettingsElement.KeyEncryptionKey = &keyEncryptionKey
	}

	// No error
	return nil
}

// AssignPropertiesFromEncryptionSettingsElement populates our EncryptionSettingsElement from the provided source EncryptionSettingsElement
func (encryptionSettingsElement *EncryptionSettingsElement) AssignPropertiesFromEncryptionSettingsElement(source *v1alpha1api20200930storage.EncryptionSettingsElement) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultAndSecretReference
		err := diskEncryptionKey.AssignPropertiesFromKeyVaultAndSecretReference(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionKey from DiskEncryptionKey, calling AssignPropertiesFromKeyVaultAndSecretReference()")
		}
		encryptionSettingsElement.DiskEncryptionKey = &diskEncryptionKey
	} else {
		encryptionSettingsElement.DiskEncryptionKey = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultAndKeyReference
		err := keyEncryptionKey.AssignPropertiesFromKeyVaultAndKeyReference(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating KeyEncryptionKey from KeyEncryptionKey, calling AssignPropertiesFromKeyVaultAndKeyReference()")
		}
		encryptionSettingsElement.KeyEncryptionKey = &keyEncryptionKey
	} else {
		encryptionSettingsElement.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEncryptionSettingsElement populates the provided destination EncryptionSettingsElement from our EncryptionSettingsElement
func (encryptionSettingsElement *EncryptionSettingsElement) AssignPropertiesToEncryptionSettingsElement(destination *v1alpha1api20200930storage.EncryptionSettingsElement) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionKey
	if encryptionSettingsElement.DiskEncryptionKey != nil {
		var diskEncryptionKey v1alpha1api20200930storage.KeyVaultAndSecretReference
		err := (*encryptionSettingsElement.DiskEncryptionKey).AssignPropertiesToKeyVaultAndSecretReference(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionKey from DiskEncryptionKey, calling AssignPropertiesToKeyVaultAndSecretReference()")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// KeyEncryptionKey
	if encryptionSettingsElement.KeyEncryptionKey != nil {
		var keyEncryptionKey v1alpha1api20200930storage.KeyVaultAndKeyReference
		err := (*encryptionSettingsElement.KeyEncryptionKey).AssignPropertiesToKeyVaultAndKeyReference(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating KeyEncryptionKey from KeyEncryptionKey, calling AssignPropertiesToKeyVaultAndKeyReference()")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type EncryptionSettingsElement_Status struct {
	//DiskEncryptionKey: Key Vault Secret Url and vault id of the disk encryption key
	DiskEncryptionKey *KeyVaultAndSecretReference_Status `json:"diskEncryptionKey,omitempty"`

	//KeyEncryptionKey: Key Vault Key Url and vault id of the key encryption key.
	//KeyEncryptionKey is optional and when provided is used to unwrap the disk
	//encryption key.
	KeyEncryptionKey *KeyVaultAndKeyReference_Status `json:"keyEncryptionKey,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionSettingsElement_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionSettingsElementStatus *EncryptionSettingsElement_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionSettingsElement_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionSettingsElementStatus *EncryptionSettingsElement_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionSettingsElement_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionSettingsElement_StatusARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionKey’:
	if typedInput.DiskEncryptionKey != nil {
		var diskEncryptionKey1 KeyVaultAndSecretReference_Status
		err := diskEncryptionKey1.PopulateFromARM(owner, *typedInput.DiskEncryptionKey)
		if err != nil {
			return err
		}
		diskEncryptionKey := diskEncryptionKey1
		encryptionSettingsElementStatus.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property ‘KeyEncryptionKey’:
	if typedInput.KeyEncryptionKey != nil {
		var keyEncryptionKey1 KeyVaultAndKeyReference_Status
		err := keyEncryptionKey1.PopulateFromARM(owner, *typedInput.KeyEncryptionKey)
		if err != nil {
			return err
		}
		keyEncryptionKey := keyEncryptionKey1
		encryptionSettingsElementStatus.KeyEncryptionKey = &keyEncryptionKey
	}

	// No error
	return nil
}

// AssignPropertiesFromEncryptionSettingsElementStatus populates our EncryptionSettingsElement_Status from the provided source EncryptionSettingsElement_Status
func (encryptionSettingsElementStatus *EncryptionSettingsElement_Status) AssignPropertiesFromEncryptionSettingsElementStatus(source *v1alpha1api20200930storage.EncryptionSettingsElement_Status) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultAndSecretReference_Status
		err := diskEncryptionKey.AssignPropertiesFromKeyVaultAndSecretReferenceStatus(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionKey from DiskEncryptionKey, calling AssignPropertiesFromKeyVaultAndSecretReferenceStatus()")
		}
		encryptionSettingsElementStatus.DiskEncryptionKey = &diskEncryptionKey
	} else {
		encryptionSettingsElementStatus.DiskEncryptionKey = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultAndKeyReference_Status
		err := keyEncryptionKey.AssignPropertiesFromKeyVaultAndKeyReferenceStatus(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating KeyEncryptionKey from KeyEncryptionKey, calling AssignPropertiesFromKeyVaultAndKeyReferenceStatus()")
		}
		encryptionSettingsElementStatus.KeyEncryptionKey = &keyEncryptionKey
	} else {
		encryptionSettingsElementStatus.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEncryptionSettingsElementStatus populates the provided destination EncryptionSettingsElement_Status from our EncryptionSettingsElement_Status
func (encryptionSettingsElementStatus *EncryptionSettingsElement_Status) AssignPropertiesToEncryptionSettingsElementStatus(destination *v1alpha1api20200930storage.EncryptionSettingsElement_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionKey
	if encryptionSettingsElementStatus.DiskEncryptionKey != nil {
		var diskEncryptionKey v1alpha1api20200930storage.KeyVaultAndSecretReference_Status
		err := (*encryptionSettingsElementStatus.DiskEncryptionKey).AssignPropertiesToKeyVaultAndSecretReferenceStatus(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionKey from DiskEncryptionKey, calling AssignPropertiesToKeyVaultAndSecretReferenceStatus()")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// KeyEncryptionKey
	if encryptionSettingsElementStatus.KeyEncryptionKey != nil {
		var keyEncryptionKey v1alpha1api20200930storage.KeyVaultAndKeyReference_Status
		err := (*encryptionSettingsElementStatus.KeyEncryptionKey).AssignPropertiesToKeyVaultAndKeyReferenceStatus(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "populating KeyEncryptionKey from KeyEncryptionKey, calling AssignPropertiesToKeyVaultAndKeyReferenceStatus()")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"EncryptionAtRestWithCustomerKey","EncryptionAtRestWithPlatformAndCustomerKeys","EncryptionAtRestWithPlatformKey"}
type EncryptionType string

const (
	EncryptionTypeEncryptionAtRestWithCustomerKey             = EncryptionType("EncryptionAtRestWithCustomerKey")
	EncryptionTypeEncryptionAtRestWithPlatformAndCustomerKeys = EncryptionType("EncryptionAtRestWithPlatformAndCustomerKeys")
	EncryptionTypeEncryptionAtRestWithPlatformKey             = EncryptionType("EncryptionAtRestWithPlatformKey")
)

//Generated from:
type EncryptionType_Status string

const (
	EncryptionType_StatusEncryptionAtRestWithCustomerKey             = EncryptionType_Status("EncryptionAtRestWithCustomerKey")
	EncryptionType_StatusEncryptionAtRestWithPlatformAndCustomerKeys = EncryptionType_Status("EncryptionAtRestWithPlatformAndCustomerKeys")
	EncryptionType_StatusEncryptionAtRestWithPlatformKey             = EncryptionType_Status("EncryptionAtRestWithPlatformKey")
)

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/ImageDiskReference
type ImageDiskReference struct {
	//Lun: If the disk is created from an image's data disk, this is an index that
	//indicates which of the data disks in the image to use. For OS disks, this field
	//is null.
	Lun *int `json:"lun,omitempty"`

	// +kubebuilder:validation:Required
	//Reference: A relative uri containing either a Platform Image Repository or user
	//image reference.
	Reference genruntime.ResourceReference `armReference:"Id" json:"reference"`
}

var _ genruntime.ARMTransformer = &ImageDiskReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (imageDiskReference *ImageDiskReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if imageDiskReference == nil {
		return nil, nil
	}
	var result ImageDiskReferenceARM

	// Set property ‘Id’:
	referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(imageDiskReference.Reference)
	if err != nil {
		return nil, err
	}
	result.Id = referenceARMID

	// Set property ‘Lun’:
	if imageDiskReference.Lun != nil {
		lun := *imageDiskReference.Lun
		result.Lun = &lun
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (imageDiskReference *ImageDiskReference) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageDiskReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (imageDiskReference *ImageDiskReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageDiskReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageDiskReferenceARM, got %T", armInput)
	}

	// Set property ‘Lun’:
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		imageDiskReference.Lun = &lun
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromImageDiskReference populates our ImageDiskReference from the provided source ImageDiskReference
func (imageDiskReference *ImageDiskReference) AssignPropertiesFromImageDiskReference(source *v1alpha1api20200930storage.ImageDiskReference) error {

	// Lun
	if source.Lun != nil {
		lun := *source.Lun
		imageDiskReference.Lun = &lun
	} else {
		imageDiskReference.Lun = nil
	}

	// Reference
	imageDiskReference.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignPropertiesToImageDiskReference populates the provided destination ImageDiskReference from our ImageDiskReference
func (imageDiskReference *ImageDiskReference) AssignPropertiesToImageDiskReference(destination *v1alpha1api20200930storage.ImageDiskReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Lun
	if imageDiskReference.Lun != nil {
		lun := *imageDiskReference.Lun
		destination.Lun = &lun
	} else {
		destination.Lun = nil
	}

	// Reference
	destination.Reference = imageDiskReference.Reference.Copy()

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ImageDiskReference_Status struct {
	// +kubebuilder:validation:Required
	//Id: A relative uri containing either a Platform Image Repository or user image
	//reference.
	Id string `json:"id"`

	//Lun: If the disk is created from an image's data disk, this is an index that
	//indicates which of the data disks in the image to use. For OS disks, this field
	//is null.
	Lun *int `json:"lun,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageDiskReference_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (imageDiskReferenceStatus *ImageDiskReference_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageDiskReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (imageDiskReferenceStatus *ImageDiskReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageDiskReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageDiskReference_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	imageDiskReferenceStatus.Id = typedInput.Id

	// Set property ‘Lun’:
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		imageDiskReferenceStatus.Lun = &lun
	}

	// No error
	return nil
}

// AssignPropertiesFromImageDiskReferenceStatus populates our ImageDiskReference_Status from the provided source ImageDiskReference_Status
func (imageDiskReferenceStatus *ImageDiskReference_Status) AssignPropertiesFromImageDiskReferenceStatus(source *v1alpha1api20200930storage.ImageDiskReference_Status) error {

	// Id
	if source.Id != nil {
		imageDiskReferenceStatus.Id = *source.Id
	} else {
		imageDiskReferenceStatus.Id = ""
	}

	// Lun
	if source.Lun != nil {
		lun := *source.Lun
		imageDiskReferenceStatus.Lun = &lun
	} else {
		imageDiskReferenceStatus.Lun = nil
	}

	// No error
	return nil
}

// AssignPropertiesToImageDiskReferenceStatus populates the provided destination ImageDiskReference_Status from our ImageDiskReference_Status
func (imageDiskReferenceStatus *ImageDiskReference_Status) AssignPropertiesToImageDiskReferenceStatus(destination *v1alpha1api20200930storage.ImageDiskReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	id := imageDiskReferenceStatus.Id
	destination.Id = &id

	// Lun
	if imageDiskReferenceStatus.Lun != nil {
		lun := *imageDiskReferenceStatus.Lun
		destination.Lun = &lun
	} else {
		destination.Lun = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/KeyVaultAndKeyReference
type KeyVaultAndKeyReference struct {
	// +kubebuilder:validation:Required
	//KeyUrl: Url pointing to a key or secret in KeyVault
	KeyUrl string `json:"keyUrl"`

	// +kubebuilder:validation:Required
	//SourceVault: The vault id is an Azure Resource Manager Resource id in the form
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}
	SourceVault SourceVault `json:"sourceVault"`
}

var _ genruntime.ARMTransformer = &KeyVaultAndKeyReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (keyVaultAndKeyReference *KeyVaultAndKeyReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if keyVaultAndKeyReference == nil {
		return nil, nil
	}
	var result KeyVaultAndKeyReferenceARM

	// Set property ‘KeyUrl’:
	result.KeyUrl = keyVaultAndKeyReference.KeyUrl

	// Set property ‘SourceVault’:
	sourceVaultARM, err := keyVaultAndKeyReference.SourceVault.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.SourceVault = sourceVaultARM.(SourceVaultARM)
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keyVaultAndKeyReference *KeyVaultAndKeyReference) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultAndKeyReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keyVaultAndKeyReference *KeyVaultAndKeyReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultAndKeyReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultAndKeyReferenceARM, got %T", armInput)
	}

	// Set property ‘KeyUrl’:
	keyVaultAndKeyReference.KeyUrl = typedInput.KeyUrl

	// Set property ‘SourceVault’:
	var sourceVault SourceVault
	err := sourceVault.PopulateFromARM(owner, typedInput.SourceVault)
	if err != nil {
		return err
	}
	keyVaultAndKeyReference.SourceVault = sourceVault

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultAndKeyReference populates our KeyVaultAndKeyReference from the provided source KeyVaultAndKeyReference
func (keyVaultAndKeyReference *KeyVaultAndKeyReference) AssignPropertiesFromKeyVaultAndKeyReference(source *v1alpha1api20200930storage.KeyVaultAndKeyReference) error {

	// KeyUrl
	if source.KeyUrl != nil {
		keyVaultAndKeyReference.KeyUrl = *source.KeyUrl
	} else {
		keyVaultAndKeyReference.KeyUrl = ""
	}

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SourceVault
		err := sourceVault.AssignPropertiesFromSourceVault(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSourceVault()")
		}
		keyVaultAndKeyReference.SourceVault = sourceVault
	} else {
		keyVaultAndKeyReference.SourceVault = SourceVault{}
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultAndKeyReference populates the provided destination KeyVaultAndKeyReference from our KeyVaultAndKeyReference
func (keyVaultAndKeyReference *KeyVaultAndKeyReference) AssignPropertiesToKeyVaultAndKeyReference(destination *v1alpha1api20200930storage.KeyVaultAndKeyReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	keyUrl := keyVaultAndKeyReference.KeyUrl
	destination.KeyUrl = &keyUrl

	// SourceVault
	var sourceVault v1alpha1api20200930storage.SourceVault
	err := keyVaultAndKeyReference.SourceVault.AssignPropertiesToSourceVault(&sourceVault)
	if err != nil {
		return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSourceVault()")
	}
	destination.SourceVault = &sourceVault

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type KeyVaultAndKeyReference_Status struct {
	// +kubebuilder:validation:Required
	//KeyUrl: Url pointing to a key or secret in KeyVault
	KeyUrl string `json:"keyUrl"`

	// +kubebuilder:validation:Required
	//SourceVault: Resource id of the KeyVault containing the key or secret
	SourceVault SourceVault_Status `json:"sourceVault"`
}

var _ genruntime.FromARMConverter = &KeyVaultAndKeyReference_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keyVaultAndKeyReferenceStatus *KeyVaultAndKeyReference_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultAndKeyReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keyVaultAndKeyReferenceStatus *KeyVaultAndKeyReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultAndKeyReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultAndKeyReference_StatusARM, got %T", armInput)
	}

	// Set property ‘KeyUrl’:
	keyVaultAndKeyReferenceStatus.KeyUrl = typedInput.KeyUrl

	// Set property ‘SourceVault’:
	var sourceVault SourceVault_Status
	err := sourceVault.PopulateFromARM(owner, typedInput.SourceVault)
	if err != nil {
		return err
	}
	keyVaultAndKeyReferenceStatus.SourceVault = sourceVault

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultAndKeyReferenceStatus populates our KeyVaultAndKeyReference_Status from the provided source KeyVaultAndKeyReference_Status
func (keyVaultAndKeyReferenceStatus *KeyVaultAndKeyReference_Status) AssignPropertiesFromKeyVaultAndKeyReferenceStatus(source *v1alpha1api20200930storage.KeyVaultAndKeyReference_Status) error {

	// KeyUrl
	if source.KeyUrl != nil {
		keyVaultAndKeyReferenceStatus.KeyUrl = *source.KeyUrl
	} else {
		keyVaultAndKeyReferenceStatus.KeyUrl = ""
	}

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SourceVault_Status
		err := sourceVault.AssignPropertiesFromSourceVaultStatus(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSourceVaultStatus()")
		}
		keyVaultAndKeyReferenceStatus.SourceVault = sourceVault
	} else {
		keyVaultAndKeyReferenceStatus.SourceVault = SourceVault_Status{}
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultAndKeyReferenceStatus populates the provided destination KeyVaultAndKeyReference_Status from our KeyVaultAndKeyReference_Status
func (keyVaultAndKeyReferenceStatus *KeyVaultAndKeyReference_Status) AssignPropertiesToKeyVaultAndKeyReferenceStatus(destination *v1alpha1api20200930storage.KeyVaultAndKeyReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	keyUrl := keyVaultAndKeyReferenceStatus.KeyUrl
	destination.KeyUrl = &keyUrl

	// SourceVault
	var sourceVault v1alpha1api20200930storage.SourceVault_Status
	err := keyVaultAndKeyReferenceStatus.SourceVault.AssignPropertiesToSourceVaultStatus(&sourceVault)
	if err != nil {
		return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSourceVaultStatus()")
	}
	destination.SourceVault = &sourceVault

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/KeyVaultAndSecretReference
type KeyVaultAndSecretReference struct {
	// +kubebuilder:validation:Required
	//SecretUrl: Url pointing to a key or secret in KeyVault
	SecretUrl string `json:"secretUrl"`

	// +kubebuilder:validation:Required
	//SourceVault: The vault id is an Azure Resource Manager Resource id in the form
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}
	SourceVault SourceVault `json:"sourceVault"`
}

var _ genruntime.ARMTransformer = &KeyVaultAndSecretReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (keyVaultAndSecretReference *KeyVaultAndSecretReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if keyVaultAndSecretReference == nil {
		return nil, nil
	}
	var result KeyVaultAndSecretReferenceARM

	// Set property ‘SecretUrl’:
	result.SecretUrl = keyVaultAndSecretReference.SecretUrl

	// Set property ‘SourceVault’:
	sourceVaultARM, err := keyVaultAndSecretReference.SourceVault.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.SourceVault = sourceVaultARM.(SourceVaultARM)
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keyVaultAndSecretReference *KeyVaultAndSecretReference) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultAndSecretReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keyVaultAndSecretReference *KeyVaultAndSecretReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultAndSecretReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultAndSecretReferenceARM, got %T", armInput)
	}

	// Set property ‘SecretUrl’:
	keyVaultAndSecretReference.SecretUrl = typedInput.SecretUrl

	// Set property ‘SourceVault’:
	var sourceVault SourceVault
	err := sourceVault.PopulateFromARM(owner, typedInput.SourceVault)
	if err != nil {
		return err
	}
	keyVaultAndSecretReference.SourceVault = sourceVault

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultAndSecretReference populates our KeyVaultAndSecretReference from the provided source KeyVaultAndSecretReference
func (keyVaultAndSecretReference *KeyVaultAndSecretReference) AssignPropertiesFromKeyVaultAndSecretReference(source *v1alpha1api20200930storage.KeyVaultAndSecretReference) error {

	// SecretUrl
	if source.SecretUrl != nil {
		keyVaultAndSecretReference.SecretUrl = *source.SecretUrl
	} else {
		keyVaultAndSecretReference.SecretUrl = ""
	}

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SourceVault
		err := sourceVault.AssignPropertiesFromSourceVault(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSourceVault()")
		}
		keyVaultAndSecretReference.SourceVault = sourceVault
	} else {
		keyVaultAndSecretReference.SourceVault = SourceVault{}
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultAndSecretReference populates the provided destination KeyVaultAndSecretReference from our KeyVaultAndSecretReference
func (keyVaultAndSecretReference *KeyVaultAndSecretReference) AssignPropertiesToKeyVaultAndSecretReference(destination *v1alpha1api20200930storage.KeyVaultAndSecretReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretUrl
	secretUrl := keyVaultAndSecretReference.SecretUrl
	destination.SecretUrl = &secretUrl

	// SourceVault
	var sourceVault v1alpha1api20200930storage.SourceVault
	err := keyVaultAndSecretReference.SourceVault.AssignPropertiesToSourceVault(&sourceVault)
	if err != nil {
		return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSourceVault()")
	}
	destination.SourceVault = &sourceVault

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type KeyVaultAndSecretReference_Status struct {
	// +kubebuilder:validation:Required
	//SecretUrl: Url pointing to a key or secret in KeyVault
	SecretUrl string `json:"secretUrl"`

	// +kubebuilder:validation:Required
	//SourceVault: Resource id of the KeyVault containing the key or secret
	SourceVault SourceVault_Status `json:"sourceVault"`
}

var _ genruntime.FromARMConverter = &KeyVaultAndSecretReference_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keyVaultAndSecretReferenceStatus *KeyVaultAndSecretReference_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultAndSecretReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keyVaultAndSecretReferenceStatus *KeyVaultAndSecretReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultAndSecretReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultAndSecretReference_StatusARM, got %T", armInput)
	}

	// Set property ‘SecretUrl’:
	keyVaultAndSecretReferenceStatus.SecretUrl = typedInput.SecretUrl

	// Set property ‘SourceVault’:
	var sourceVault SourceVault_Status
	err := sourceVault.PopulateFromARM(owner, typedInput.SourceVault)
	if err != nil {
		return err
	}
	keyVaultAndSecretReferenceStatus.SourceVault = sourceVault

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultAndSecretReferenceStatus populates our KeyVaultAndSecretReference_Status from the provided source KeyVaultAndSecretReference_Status
func (keyVaultAndSecretReferenceStatus *KeyVaultAndSecretReference_Status) AssignPropertiesFromKeyVaultAndSecretReferenceStatus(source *v1alpha1api20200930storage.KeyVaultAndSecretReference_Status) error {

	// SecretUrl
	if source.SecretUrl != nil {
		keyVaultAndSecretReferenceStatus.SecretUrl = *source.SecretUrl
	} else {
		keyVaultAndSecretReferenceStatus.SecretUrl = ""
	}

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SourceVault_Status
		err := sourceVault.AssignPropertiesFromSourceVaultStatus(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSourceVaultStatus()")
		}
		keyVaultAndSecretReferenceStatus.SourceVault = sourceVault
	} else {
		keyVaultAndSecretReferenceStatus.SourceVault = SourceVault_Status{}
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultAndSecretReferenceStatus populates the provided destination KeyVaultAndSecretReference_Status from our KeyVaultAndSecretReference_Status
func (keyVaultAndSecretReferenceStatus *KeyVaultAndSecretReference_Status) AssignPropertiesToKeyVaultAndSecretReferenceStatus(destination *v1alpha1api20200930storage.KeyVaultAndSecretReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretUrl
	secretUrl := keyVaultAndSecretReferenceStatus.SecretUrl
	destination.SecretUrl = &secretUrl

	// SourceVault
	var sourceVault v1alpha1api20200930storage.SourceVault_Status
	err := keyVaultAndSecretReferenceStatus.SourceVault.AssignPropertiesToSourceVaultStatus(&sourceVault)
	if err != nil {
		return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSourceVaultStatus()")
	}
	destination.SourceVault = &sourceVault

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-09-30/Microsoft.Compute.json#/definitions/SourceVault
type SourceVault struct {
	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SourceVault{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sourceVault *SourceVault) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sourceVault == nil {
		return nil, nil
	}
	var result SourceVaultARM

	// Set property ‘Id’:
	if sourceVault.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*sourceVault.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sourceVault *SourceVault) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SourceVaultARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sourceVault *SourceVault) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(SourceVaultARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SourceVaultARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromSourceVault populates our SourceVault from the provided source SourceVault
func (sourceVault *SourceVault) AssignPropertiesFromSourceVault(source *v1alpha1api20200930storage.SourceVault) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		sourceVault.Reference = &reference
	} else {
		sourceVault.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSourceVault populates the provided destination SourceVault from our SourceVault
func (sourceVault *SourceVault) AssignPropertiesToSourceVault(destination *v1alpha1api20200930storage.SourceVault) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if sourceVault.Reference != nil {
		reference := sourceVault.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type SourceVault_Status struct {
	//Id: Resource Id
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SourceVault_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sourceVaultStatus *SourceVault_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SourceVault_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sourceVaultStatus *SourceVault_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SourceVault_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SourceVault_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		sourceVaultStatus.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSourceVaultStatus populates our SourceVault_Status from the provided source SourceVault_Status
func (sourceVaultStatus *SourceVault_Status) AssignPropertiesFromSourceVaultStatus(source *v1alpha1api20200930storage.SourceVault_Status) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		sourceVaultStatus.Id = &id
	} else {
		sourceVaultStatus.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSourceVaultStatus populates the provided destination SourceVault_Status from our SourceVault_Status
func (sourceVaultStatus *SourceVault_Status) AssignPropertiesToSourceVaultStatus(destination *v1alpha1api20200930storage.SourceVault_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if sourceVaultStatus.Id != nil {
		id := *sourceVaultStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Disk{}, &DiskList{})
}
